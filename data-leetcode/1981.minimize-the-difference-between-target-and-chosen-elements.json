[
    {
        "title": "Friends Of Appropriate Ages",
        "question_content": "There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person.\nA Person x will not send a friend request to a person y (x != y) if any of the following conditions is true:\n\n\tage[y] <= 0.5 * age[x] + 7\n\tage[y] > age[x]\n\tage[y] > 100 && age[x] < 100\n\nOtherwise, x will send a friend request to y.\nNote that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself.\nReturn the total number of friend requests made.\n&nbsp;\nExample 1:\n\nInput: ages = [16,16]\nOutput: 2\nExplanation: 2 people friend request each other.\n\nExample 2:\n\nInput: ages = [16,17,18]\nOutput: 2\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\n\nExample 3:\n\nInput: ages = [20,30,100,110,120]\nOutput: 3\nExplanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\n&nbsp;\nConstraints:\n\n\tn == ages.length\n\t1 <= n <= 2 * 104\n\t1 <= ages[i] <= 120",
        "solutions": [
            {
                "id": 127029,
                "title": "c-java-python-easy-and-straight-forward",
                "content": "## **Explanation**\\n1. Write a sub function `request(a, b)` to check if age `a` will friend requests age `b`.\\nI just copy it from description:\\n`return !(condition1 || condition2 || condition3)`\\n\\n2. Count nunmber of all ages to a `map`.\\nBecause we have at most 20000 ages but only in range [1, 120].\\n3. For each age `a` and each age `b != a`, if request(a, b), we will make count[a] * count[b] requests.\\n4. For each age `a`, if request(a, a), we will make `count[a] * (count[a] - 1)` requests.\\n\\n**C++:**\\n```cpp\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numFriendRequests(int[] ages) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int age : ages)\\n            count.put(age, count.getOrDefault(age, 0) + 1);\\n        int res = 0;\\n        for (Integer a : count.keySet())\\n            for (Integer b : count.keySet())\\n                if (request(a, b)) res += count.get(a) * (count.get(b) - (a == b ? 1 : 0));\\n        return res;\\n    }\\n\\n    private boolean request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def numFriendRequests(self, ages):\\n        def request(a, b):\\n            return not (b <= 0.5 * a + 7 or b > a or b > 100 and a < 100)\\n        c = collections.Counter(ages)\\n        return sum(request(a, b) * c[a] * (c[b] - (a == b)) for a in c for b in c)\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\n```java\\n    public int numFriendRequests(int[] ages) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int age : ages)\\n            count.put(age, count.getOrDefault(age, 0) + 1);\\n        int res = 0;\\n        for (Integer a : count.keySet())\\n            for (Integer b : count.keySet())\\n                if (request(a, b)) res += count.get(a) * (count.get(b) - (a == b ? 1 : 0));\\n        return res;\\n    }\\n\\n    private boolean request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\n```py\\n    def numFriendRequests(self, ages):\\n        def request(a, b):\\n            return not (b <= 0.5 * a + 7 or b > a or b > 100 and a < 100)\\n        c = collections.Counter(ages)\\n        return sum(request(a, b) * c[a] * (c[b] - (a == b)) for a in c for b in c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 127341,
                "title": "10ms-concise-java-solution-o-n-time-and-o-1-space",
                "content": "Three conditions could be merged to one: \\nThe Person with age A can request person with age B if\\n* B is in range **(** 0.5 * A + 7, A **]** \\n```\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        \\n        for(int i : ages) \\n            numInAge[i] ++;\\n        \\n        for(int i = 1; i <= 120; ++i) \\n            sumInAge[i] = numInAge[i] + sumInAge[i - 1];\\n        \\n        for(int i = 15; i <= 120; ++i) {\\n            if(numInAge[i] == 0) continue;\\n            int count = sumInAge[i] - sumInAge[i / 2 + 7];\\n            res += count * numInAge[i] - numInAge[i]; //people will not friend request themselves, so  - numInAge[i]\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        \\n        for(int i : ages) \\n            numInAge[i] ++;\\n        \\n        for(int i = 1; i <= 120; ++i) \\n            sumInAge[i] = numInAge[i] + sumInAge[i - 1];\\n        \\n        for(int i = 15; i <= 120; ++i) {\\n            if(numInAge[i] == 0) continue;\\n            int count = sumInAge[i] - sumInAge[i / 2 + 7];\\n            res += count * numInAge[i] - numInAge[i]; //people will not friend request themselves, so  - numInAge[i]\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126930,
                "title": "c-5-lines-o-n-sliding-sum",
                "content": "Since the age range is limited to [1..120], we can count number of people of each age and store in the array. Then we can use that array to count friend requests:\\n* People younger than 15 cannot make requests due to the first rule.\\n* From the age of 15, people can make requests to the same age: ```a[i] * (a[i] - 1)``` requests.\\n* People can make requests to younger people older than 0.5 * i + 7: ```a[j] * a[i]``` requests.\\n    * The third rule is redundant as the condition is already covered by the second rule.\\n\\nThe complexity is O(n) as we need to count ages in the input array. Counting requests is O(1) as it always takes 2862 operations precisely. \\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15; i <= 120; ++i)\\n    for (int j = 0.5 * i + 8; j <= i; ++j) res += a[j] * (a[i] - (i == j));\\n  return res;\\n}\\n```\\nWe can optimize the counting by using a sliding sum of friend requests. Note that the sum starts at the minimum age (```0.5 * i + 7```), per the first rule.\\n\\nThe complexity of optimized solution is O(n + m) vs. O(n + m * m), where m is the age range. In our case, we need only 159 operations for [1..120] range. I did not see much of a difference in the OJ runtime, though, probably because of the tight constraint. The second solution will shine if we need, for example, use days instead of years to compare ages.\\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15, minAge = 15, sSum = 0; i <= 120; sSum += a[i], res += a[i++] * (sSum - 1))\\n    while (minAge <= 0.5 * i + 7) sSum -= a[minAge++];\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```a[i] * (a[i] - 1)```\n```a[j] * a[i]```\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15; i <= 120; ++i)\\n    for (int j = 0.5 * i + 8; j <= i; ++j) res += a[j] * (a[i] - (i == j));\\n  return res;\\n}\\n```\n```0.5 * i + 7```\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15, minAge = 15, sSum = 0; i <= 120; sSum += a[i], res += a[i++] * (sSum - 1))\\n    while (minAge <= 0.5 * i + 7) sSum -= a[minAge++];\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231649,
                "title": "java-i-think-this-is-the-solution-interviewers-would-like-to-see",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i = 0; i < ages.length; ++i) {\\n            int age = ages[i];\\n            int lower = firstIdx(ages, age/2+7);\\n            int upper = firstIdx(ages, age);\\n            res += Math.max(upper-lower-1, 0);\\n        }\\n        return res;\\n    }\\n    \\n    private static int firstIdx(int[] ages, int target) {\\n        int beg = 0;\\n        int end = ages.length-1;\\n        while (beg <= end) {\\n            int mid = beg + (end-beg)/2;\\n            if (ages[mid] <= target) beg = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return beg;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i = 0; i < ages.length; ++i) {\\n            int age = ages[i];\\n            int lower = firstIdx(ages, age/2+7);\\n            int upper = firstIdx(ages, age);\\n            res += Math.max(upper-lower-1, 0);\\n        }\\n        return res;\\n    }\\n    \\n    private static int firstIdx(int[] ages, int target) {\\n        int beg = 0;\\n        int end = ages.length-1;\\n        while (beg <= end) {\\n            int mid = beg + (end-beg)/2;\\n            if (ages[mid] <= target) beg = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return beg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129665,
                "title": "super-clear-explanation-on-both-o-nlgn-and-o-n-solution-step-by-step",
                "content": "The NAIVE solution should be comparing each pair and has O(N^2) time complexity. However, after careful consideration, we can easily find that for every person, there\\'s a range of ages that he will make request to. As a result, it is not hard to think of an O(NlgN) solution, where we sort the array first, and for each person, we calculate the expected range, and use binary search to find the number of elements in ages[] that sit in that range. Note that,\\nage[B] > 100 && age[A] < 100 is an useless condition which is fully convered by the second one. Here is the code:\\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            auto low_it = lower_bound(ages.begin(), ages.end(), low_bound);\\n            auto high_it = upper_bound(ages.begin(), ages.end(), ages[i]);\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\\nlow_bound is the inclusive left bound for the range. the \"-1\" in the cacluation of request is getting rid of making request to himself/herself . However, it is not necessary that his own age is in the expected result (and also it is not necessary that low_it is before high_it), so in the end, we make sure that for every person, the minimum request he/she will make is 0 (get rid of negative values).\\nAfter this, I was thinking if we can get faster? I observerd that low_it and hight_it is always proceeding, which makes sense as the age of the person cannot decrease (after sort), the left and right bound of his/her expected range should also not decrease. So, we don\\'t need to apply the binary search for low_it and high_it in every step.\\nHere comes the code:\\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        auto low_it = lower_bound(ages.begin(), ages.end(), ages[0]/2 + 8);\\n        auto high_it = upper_bound(ages.begin(), ages.end(), ages[0]);\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            while (*low_it < low_bound) ++low_it;\\n            while (high_it != ages.end() && *high_it <= ages[i]) ++high_it;\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\\nWe can find the expected range for the first element and then increase its boundaries when possible. In the for loop, low_it, high_it, and index i cannot decrease, so the time complexity for the for loop is only O(N). Someone may argue that, the sort takes O(NlgN) and that is right! However, please remember the range of of age : 1 <= ages[i] <= 120. We can definitely apply an O(N) bucket sort if we want.\\nThe code is not optmized for the smallest xx ms on the test cases but should elaborate my idea for you!",
                "solutionTags": [],
                "code": "```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            auto low_it = lower_bound(ages.begin(), ages.end(), low_bound);\\n            auto high_it = upper_bound(ages.begin(), ages.end(), ages[i]);\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        auto low_it = lower_bound(ages.begin(), ages.end(), ages[0]/2 + 8);\\n        auto high_it = upper_bound(ages.begin(), ages.end(), ages[0]);\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            while (*low_it < low_bound) ++low_it;\\n            while (high_it != ages.end() && *high_it <= ages[i]) ++high_it;\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166776,
                "title": "2-solutions-both-with-o-n-time-and-o-1-space-chinese-explaination",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] map = new int[121]; //\\u6BCF\\u4E2A\\u5E74\\u9F84\\u6709\\u591A\\u5C11\\u4EBA, \\u4F18\\u53161 \\u4E0D\\u7528map\\u7528\\u5E38\\u6570\\u5927\\u5C0F\\u6570\\u7EC4\\uFF0C\\u8FD9\\u6837\\u65F6\\u95F4\\u548C\\u7A7A\\u95F4\\u90FD\\u662FO\\uFF081\\uFF09\\n        for (int age : ages) map[age]++;\\n        int count = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            for (int j = 0; j <= 120; j++) {\\n                if (valid(i, j)) count += map[i] * (i == j ? map[j] - 1 : map[j]); //\\u6CE8\\u610Fi,j\\u76F8\\u7B49\\u4E0D\\u80FDskip\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u591A\\u4E2A\\u76F8\\u7B49\\u5E74\\u9F84\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean valid(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100)); //\\u5176\\u5B9E\\u6761\\u4EF62\\u548C3\\u91CD\\u590D\\u4E86\\n    }\\n}\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { //\\u4F18\\u53162\\uFF0C\\u53E6\\u4E00\\u6570\\u7EC4sums\\u8BB0\\u5F55\\u8303\\u56F4\\uFF0C\\u8FD9\\u6837\\u8BA1\\u7B97count\\u4E0D\\u75282 for\\uFF0C\\u76F4\\u63A5\\u627E\\u8303\\u56F4\\u5185\\u4E2A\\u6570\\u5373\\u53EF\\n        int[] nums = new int[121], sums = new int[121];\\n        for (int age : ages) nums[age]++; //\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5E74\\u9F84\\u591A\\u5C11\\u4EBA\\n        for (int i = 1; i < sums.length; i++) sums[i] = sums[i - 1] + nums[i]; //\\u76F8\\u5F53\\u4E8E\\u8BB0\\u5F55\\u5C0F\\u4E8Ei\\u7684\\u6709\\u591A\\u5C11\\u4EBA\\n        int res = 0;\\n        for (int i = 15; i < sums.length; i++) { //i / 2 + 7 < i -> i>14\\n            if (nums[i] == 0) continue; //0\\u4E00\\u5B9A\\u8981\\u8DF3\\u8FC7\\uFF0C\\u5426\\u5219\\u540E\\u9762\\u662F\\u8D1F\\u6570\\n            int count = sums[i] - sums[i / 2 + 7]; //(i/2+7, i] \\u6709\\u591A\\u5C11\\u4E2A\\n            res += (count - 1) * nums[i]; //\\u4E0D\\u80FD\\u548C\\u81EA\\u8EABrequest\\n        }\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] map = new int[121]; //\\u6BCF\\u4E2A\\u5E74\\u9F84\\u6709\\u591A\\u5C11\\u4EBA, \\u4F18\\u53161 \\u4E0D\\u7528map\\u7528\\u5E38\\u6570\\u5927\\u5C0F\\u6570\\u7EC4\\uFF0C\\u8FD9\\u6837\\u65F6\\u95F4\\u548C\\u7A7A\\u95F4\\u90FD\\u662FO\\uFF081\\uFF09\\n        for (int age : ages) map[age]++;\\n        int count = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            for (int j = 0; j <= 120; j++) {\\n                if (valid(i, j)) count += map[i] * (i == j ? map[j] - 1 : map[j]); //\\u6CE8\\u610Fi,j\\u76F8\\u7B49\\u4E0D\\u80FDskip\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u591A\\u4E2A\\u76F8\\u7B49\\u5E74\\u9F84\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 744947,
                "title": "c-binary-search",
                "content": "A will friend B only if: \\n\\ni) B\\'s age is <= A and if, \\nii) B\\'s age is > 0.5*age[A]+7.\\n\\nAlgorithm: \\n\\n1) Sort the ages. \\n2) In the sorted array for any  j<sup>th</sup> index, we have to find all indexes which satisfy condition (i) and (ii). We do that using a binary search on the array to the left of the j<sup>th</sup> index. We terminate the search when we find the smallest index which satisfies the condition ages[mid] > 0.5*age[j]+7. Return the length of the array between j-1 and mid. \\n3) Keep a hash-map to store age and calculated friend-requests. That way if we have already found the number of friend requests that can be sent for a particular age, we can re-use it (since the array has duplicate ages). \\n4) **Traverse the age array from right to left** in the main function to compute step 2 for each index in the ages array.  \\n\\n**There is an important benefit to traverse the array from right to left (from ages.size()-1 to 0). It lets us compute the number of people of the same age as the j<sup>th</sup> person and the ones less than the j<sup>th</sup> person satisfying condition (ii), in the same binary search function.**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map <int,int> map; // key: age, val: FriendRequestCount. \\n    \\n    int findRequests (vector<int> & ages, int index) {\\n        \\n        if (map.find(ages[index]) != map.end()) {\\n            return map[ages[index]];\\n        }\\n        \\n        int left = 0;\\n        int right = index-1;\\n        double target = (double) (0.5*ages[index]) + 7; // find ages >= target.\\n        \\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (ages[mid] <= target) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        \\n        map[ages[index]] = index-left;\\n        return index-left; // len between index-1 and left. \\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        sort (ages.begin(), ages.end());\\n        \\n        int count = 0;\\n        \\n        for (int i = ages.size()-1; i >= 0 ; i--) {\\n            count += findRequests (ages, i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map <int,int> map; // key: age, val: FriendRequestCount. \\n    \\n    int findRequests (vector<int> & ages, int index) {\\n        \\n        if (map.find(ages[index]) != map.end()) {\\n            return map[ages[index]];\\n        }\\n        \\n        int left = 0;\\n        int right = index-1;\\n        double target = (double) (0.5*ages[index]) + 7; // find ages >= target.\\n        \\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (ages[mid] <= target) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        \\n        map[ages[index]] = index-left;\\n        return index-left; // len between index-1 and left. \\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        sort (ages.begin(), ages.end());\\n        \\n        int count = 0;\\n        \\n        for (int i = ages.size()-1; i >= 0 ; i--) {\\n            count += findRequests (ages, i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126944,
                "title": "python-easy-solution-using-binary-search",
                "content": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        if not ages: return 0\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            if a<=14: continue\\n            idx1 = bisect.bisect(ages, a)\\n            x = 0.5*a+7\\n            idx2 = bisect.bisect(ages, x)\\n            while idx2<N and ages[idx2]==x:\\n                idx2 += 1\\n            cnt += max(0, idx1-idx2+(-1 if idx2<=i<=idx1 else 0)) \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        if not ages: return 0\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            if a<=14: continue\\n            idx1 = bisect.bisect(ages, a)\\n            x = 0.5*a+7\\n            idx2 = bisect.bisect(ages, x)\\n            while idx2<N and ages[idx2]==x:\\n                idx2 += 1\\n            cnt += max(0, idx1-idx2+(-1 if idx2<=i<=idx1 else 0)) \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558722,
                "title": "java-2-ms-short-and-simple",
                "content": "Many posts have already mentioned the conditions can be summed up as:\\n> Person A will friend request B iif \\n> **0.5 * age[A] + 7 < age[B] <= age[A]**\\n\\nSo just iterate over the possible values of B\\'s age.\\nSum how many people there are in each age year to make calculations more efficient.\\n\\n```\\n    public int numFriendRequests(int[] ages) {\\n        int[] ageCounts = new int[121];\\n        int friendReqCount = 0;\\n        \\n        // Count how many people there are for each age\\n        for(int age : ages) {\\n            ageCounts[age]++;\\n        }\\n        \\n        for(int a=0; a<=120; a++) {\\n            // Iterate over the allowed range for B\\'s age\\n            for(int b=(int)(0.5*a)+7+1; b<=a; b++) {\\n                friendReqCount += ageCounts[a] * ageCounts[b];\\n                \\n                if(a==b) {\\n                    // A will not friend request him/herself\\n                    friendReqCount -= ageCounts[a];\\n                }\\n            }\\n        }\\n        \\n        return friendReqCount;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int[] ageCounts = new int[121];\\n        int friendReqCount = 0;\\n        \\n        // Count how many people there are for each age\\n        for(int age : ages) {\\n            ageCounts[age]++;\\n        }\\n        \\n        for(int a=0; a<=120; a++) {\\n            // Iterate over the allowed range for B\\'s age\\n            for(int b=(int)(0.5*a)+7+1; b<=a; b++) {\\n                friendReqCount += ageCounts[a] * ageCounts[b];\\n                \\n                if(a==b) {\\n                    // A will not friend request him/herself\\n                    friendReqCount -= ageCounts[a];\\n                }\\n            }\\n        }\\n        \\n        return friendReqCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704499,
                "title": "python-bucket-sorting-o-n-time",
                "content": "```\\ndef numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smaller_eq = [0] * 121\\n        for age in ages:\\n          smaller_eq[age] += 1\\n        for i in range(1, 121):\\n          smaller_eq[i] += smaller_eq[i-1]\\n\\n        res = 0\\n        for age in ages:\\n            res += max(0, smaller_eq[age] - smaller_eq[int(0.5*age)+7]-1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smaller_eq = [0] * 121\\n        for age in ages:\\n          smaller_eq[age] += 1\\n        for i in range(1, 121):\\n          smaller_eq[i] += smaller_eq[i-1]\\n\\n        res = 0\\n        for age in ages:\\n            res += max(0, smaller_eq[age] - smaller_eq[int(0.5*age)+7]-1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 737217,
                "title": "python-simple-solution-using-counters-beats-85",
                "content": "### Algorithm\\n**Step 1**: construct a dictionary with age as key and number of members in that age group as values. This can be done using Counter in collections module.\\n**Step 2**: iterate for every age group (not every person!!) say \"me\"\\n**Step 3**: for every age group check condition take (\"age\",\"me\") pair and check if the conditions asked are satisfied with \\n* age<= 0.5 * me +7\\n* age>me\\n* 3rd condition is always false so we can omit it.\\n\\n**Step 4**:\\nHere we have 2 cases.\\n* **case(a): if your age is different from the other age**\\nfor example 16,15,15 then 15->16 and 15->16\\n\\t\\tie 2\\\\*1 which is `age_count * me_count`\\n* **case(b): if your age is same as other age**\\nfor example 16,16 then 16<->16 ie 2. \\nThis would be same as number of edges in a graph with n vertices where each edge considered 2 times which is 2\\\\*nC2 which would be `me_count*(me_count-1)`\\n### Python code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count=0\\n\\t\\t# Step 1\\n        dicto=Counter(ages)\\n\\t\\t# Step 2\\n        for me in dicto:\\n            my_age_count=dicto[me]\\n\\t\\t\\t# Step 3\\n            for age in dicto:\\n                if not (age<= 0.5 * me +7 or age>me):\\n\\t\\t\\t\\t\\t# Step 4 case (a)\\n                    if age!=me :\\n                        count+=dicto[age]*my_age_count\\n\\t\\t\\t\\t\\t# Step 4 case (b)\\n                    else:\\n                        count+=int(my_age_count*(my_age_count-1))\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count=0\\n\\t\\t# Step 1\\n        dicto=Counter(ages)\\n\\t\\t# Step 2\\n        for me in dicto:\\n            my_age_count=dicto[me]\\n\\t\\t\\t# Step 3\\n            for age in dicto:\\n                if not (age<= 0.5 * me +7 or age>me):\\n\\t\\t\\t\\t\\t# Step 4 case (a)\\n                    if age!=me :\\n                        count+=dicto[age]*my_age_count\\n\\t\\t\\t\\t\\t# Step 4 case (b)\\n                    else:\\n                        count+=int(my_age_count*(my_age_count-1))\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141466,
                "title": "python-3-with-counter",
                "content": "The third contion is redundant. \\n```python\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        cnt = collections.Counter(ages)\\n        for k1, v1 in cnt.items():\\n            for k2, v2 in cnt.items():\\n                if (k2 > 0.5*k1 + 7 and\\n                    k2 <= k1):\\n                    # if both conditions met\\n                    ans += v1 * v2\\n                    if k1 == k2:\\n                        ans -= v1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        cnt = collections.Counter(ages)\\n        for k1, v1 in cnt.items():\\n            for k2, v2 in cnt.items():\\n                if (k2 > 0.5*k1 + 7 and\\n                    k2 <= k1):\\n                    # if both conditions met\\n                    ans += v1 * v2\\n                    if k1 == k2:\\n                        ans -= v1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074946,
                "title": "python-3-three-methods-binary-search-counter-hashmap-math-explanation",
                "content": "### Approach 1. Binary Search + Math\\n- Time Complexity: `O(NlogN), N = len(ages)`\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()                                   # sort the `ages`\\n        ans = 0\\n        n = len(ages)\\n        for idx, age in enumerate(ages):              # for each age\\n            lb = age                                  # lower bound\\n            ub = (age - 7) * 2                        # upper bound\\n            i = bisect.bisect_left(ages, lb)          # binary search lower bound\\n            j = bisect.bisect_left(ages, ub)          # binary search upper bound\\n            if j - i <= 0: continue\\n            ans += j - i                              # count number of potential friends\\n            if lb <= age < ub:                        # ignore itself\\n                ans -= 1\\n        return ans\\n```\\n### Approach 2. Counter + Nested loop\\n- Time complexity: `max(O(121*121), N), N = len(ages)`\\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                           # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        ans = 0\\n        for ageA, countA in enumerate(count):       # nested loop, pretty straightforward\\n            for ageB, countB in enumerate(count):\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                if ageA < 100 < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans    \\n```\\t\\t\\n### Approach 3. Counter + Binary Search + Math\\n- Time complexity: `max(O(121*log(121)), N), N = len(ages)`\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()                                   # sort the `ages`\\n        ans = 0\\n        n = len(ages)\\n        for idx, age in enumerate(ages):              # for each age\\n            lb = age                                  # lower bound\\n            ub = (age - 7) * 2                        # upper bound\\n            i = bisect.bisect_left(ages, lb)          # binary search lower bound\\n            j = bisect.bisect_left(ages, ub)          # binary search upper bound\\n            if j - i <= 0: continue\\n            ans += j - i                              # count number of potential friends\\n            if lb <= age < ub:                        # ignore itself\\n                ans -= 1\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                           # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        ans = 0\\n        for ageA, countA in enumerate(count):       # nested loop, pretty straightforward\\n            for ageB, countB in enumerate(count):\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                if ageA < 100 < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans    \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547711,
                "title": "binary-search-c-very-easy-solution",
                "content": "->First We will Sort the array \\n->now for all element i we have to find range of ind which satisfy the condition of friendship\\n->condition for friendship\\nlet x and y be 2 person and x want to be friend of y then\\n->x>y/2+7 &&x<=y \\n->or we can say   (y/2+7<x<=y)\\n\\n->now to find val >y/2+7 we can apply binary search \\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n       sort(ages.begin(),ages.end());\\n        int count =0;\\n        for(int i=0;i<ages.size();i++)\\n        {\\n             int val=ages[i]/2+7;\\n            if(ages[i]<=val) //invalid condition\\n                continue;\\n            \\n            int ind1=upper_bound(ages.begin(),ages.end(),val)-ages.begin();\\n            int ind2=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n            \\n            ind2--;         //because upper bound will give val greater than ages[i] soo we need to decrement ind2 to get \\n            if(ind2>=ind1)    // val<=ages[i]\\n                count+=ind2-ind1;\\n            \\n         }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n       sort(ages.begin(),ages.end());\\n        int count =0;\\n        for(int i=0;i<ages.size();i++)\\n        {\\n             int val=ages[i]/2+7;\\n            if(ages[i]<=val) //invalid condition\\n                continue;\\n            \\n            int ind1=upper_bound(ages.begin(),ages.end(),val)-ages.begin();\\n            int ind2=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n            \\n            ind2--;         //because upper bound will give val greater than ages[i] soo we need to decrement ind2 to get \\n            if(ind2>=ind1)    // val<=ages[i]\\n                count+=ind2-ind1;\\n            \\n         }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152040,
                "title": "cpp-100-easy-to-understand-and-elegant",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int map[121] = { 0 };\\n        int minage = 0, ans = 0, group = 0;\\n        \\n        for (auto a : ages)\\n            map[a]++;\\n        \\n        for (int i = 1; i < 121; ++i)\\n            map[i] += map[i-1];\\n        \\n        for (int i = 15; i < 121; ++i) {\\n            minage = (i/2 + 7);\\n            group = map[i]-map[i-1];\\n            ans += group * (map[i] - map[minage] - 1); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int map[121] = { 0 };\\n        int minage = 0, ans = 0, group = 0;\\n        \\n        for (auto a : ages)\\n            map[a]++;\\n        \\n        for (int i = 1; i < 121; ++i)\\n            map[i] += map[i-1];\\n        \\n        for (int i = 15; i < 121; ++i) {\\n            minage = (i/2 + 7);\\n            group = map[i]-map[i-1];\\n            ans += group * (map[i] - map[minage] - 1); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225554,
                "title": "o-n-solution-with-explanation",
                "content": "```\\n public int NumFriendRequests(int[] ages) {\\n        //we can see that condition age[B] > 100 && age[A] < 100 are redunant just \\n        //because of condition age[B] > age[A], the condition is actually that B should be in         //a range of (0.5 * age[A] + 7, A]\\n        // We would solve it with commulative sum approach solution:\\n        // Max age is set as 120\\n        // We would mark how many people in each age exists;\\n        var peopleInAge = new int[121];\\n        for (int i = 0; i < ages.Length; i++) {\\n            peopleInAge[ages[i]]++;\\n        }\\n        //here we count how many people bellow their age, using commulative sum approach.\\n        var countYongestPeople = new int[121];\\n        for (int  i = 1; i < 121; i++) {\\n           countYongestPeople[i] = peopleInAge[i] + countYongestPeople[i-1];\\n        }\\n        \\n        var result = 0;\\n        //there is conditions:\\n        // (1) B < A;\\n        // (2) B >= 0.5*A + 7;\\n        // if B is greater than or equal to (0.5*A + 7) then from (1), A is greater than (0.5)*A + 7;\\n        // A > 0.5*A + 7;\\n        // A - 0.5*A > 7;\\n        // 0.5*A > 7;\\n        // A > 15;\\n        for (int i = 15; i < 121; i++) {\\n            //if we don\\'t have such people, just skip it\\n            if (peopleInAge[i] == 0) continue;\\n            \\n            //calculate how many people between range (0.5 * age[A] + 7, A];\\n            var suitablePeople = countYongestPeople[i] - countYongestPeople[i/2 + 7];\\n            var suitableWithoutThemSelf = suitablePeople*peopleInAge[i] - peopleInAge[i];\\n            result += suitableWithoutThemSelf;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int NumFriendRequests(int[] ages) {\\n        //we can see that condition age[B] > 100 && age[A] < 100 are redunant just \\n        //because of condition age[B] > age[A], the condition is actually that B should be in         //a range of (0.5 * age[A] + 7, A]\\n        // We would solve it with commulative sum approach solution:\\n        // Max age is set as 120\\n        // We would mark how many people in each age exists;\\n        var peopleInAge = new int[121];\\n        for (int i = 0; i < ages.Length; i++) {\\n            peopleInAge[ages[i]]++;\\n        }\\n        //here we count how many people bellow their age, using commulative sum approach.\\n        var countYongestPeople = new int[121];\\n        for (int  i = 1; i < 121; i++) {\\n           countYongestPeople[i] = peopleInAge[i] + countYongestPeople[i-1];\\n        }\\n        \\n        var result = 0;\\n        //there is conditions:\\n        // (1) B < A;\\n        // (2) B >= 0.5*A + 7;\\n        // if B is greater than or equal to (0.5*A + 7) then from (1), A is greater than (0.5)*A + 7;\\n        // A > 0.5*A + 7;\\n        // A - 0.5*A > 7;\\n        // 0.5*A > 7;\\n        // A > 15;\\n        for (int i = 15; i < 121; i++) {\\n            //if we don\\'t have such people, just skip it\\n            if (peopleInAge[i] == 0) continue;\\n            \\n            //calculate how many people between range (0.5 * age[A] + 7, A];\\n            var suitablePeople = countYongestPeople[i] - countYongestPeople[i/2 + 7];\\n            var suitableWithoutThemSelf = suitablePeople*peopleInAge[i] - peopleInAge[i];\\n            result += suitableWithoutThemSelf;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000595,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int n = ages.size(), count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val = 0.5 * ages[i] + 7;\\n            int index = upper_bound(ages.begin(), ages.end(), val) - ages.begin();\\n            int c = 1, prev = i;\\n            while (i - 1 >= 0 && ages[i] == ages[i - 1]) {\\n                c++;\\n                i--;\\n            }\\n            if (index >= prev) continue;\\n            count += (prev - index) * c;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int n = ages.size(), count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val = 0.5 * ages[i] + 7;\\n            int index = upper_bound(ages.begin(), ages.end(), val) - ages.begin();\\n            int c = 1, prev = i;\\n            while (i - 1 >= 0 && ages[i] == ages[i - 1]) {\\n                c++;\\n                i--;\\n            }\\n            if (index >= prev) continue;\\n            count += (prev - index) * c;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707318,
                "title": "python-2-solutions-binary-search-and-using-counter",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH  : BINARY SEARCH ##\\n        ## 1. Sort by age\\n        ## 2. index i person will not send friend request to ages[i]+1, ages[i]+2 ....\\n        ## 3. index i person will not send friend request to elements whose age is less than (0.5 * ages[i] + 7)\\n        ## 4. Using binary search we can find upper and lower limit, persons which fall in this range, can send friend requests (remove 1, ith person itself)\\n        \\n        ages.sort()\\n        count = 0\\n        for i in range(len(ages)):\\n            left = bisect.bisect_right( ages, (0.5 * ages[i]) + 7 )\\n            right = bisect.bisect_right( ages, ages[i])\\n            count += max(0, right - left - 1)                       # you cannot have negative count\\n        return count\\n    \\n        ## APPROACH : COUNTER ##\\n        ages = collections.Counter(ages)\\n        ans = 0\\n        for ageA, countA in ages.items():\\n            for ageB, countB in ages.items():\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH  : BINARY SEARCH ##\\n        ## 1. Sort by age\\n        ## 2. index i person will not send friend request to ages[i]+1, ages[i]+2 ....\\n        ## 3. index i person will not send friend request to elements whose age is less than (0.5 * ages[i] + 7)\\n        ## 4. Using binary search we can find upper and lower limit, persons which fall in this range, can send friend requests (remove 1, ith person itself)\\n        \\n        ages.sort()\\n        count = 0\\n        for i in range(len(ages)):\\n            left = bisect.bisect_right( ages, (0.5 * ages[i]) + 7 )\\n            right = bisect.bisect_right( ages, ages[i])\\n            count += max(0, right - left - 1)                       # you cannot have negative count\\n        return count\\n    \\n        ## APPROACH : COUNTER ##\\n        ages = collections.Counter(ages)\\n        ans = 0\\n        for ageA, countA in ages.items():\\n            for ageB, countB in ages.items():\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 212431,
                "title": "o-n-counting-dp-c",
                "content": "Since we have the condition 1 <= age <= 120, we can do something similar to counting sort. Then for every age, `a`, we want to count the number of ages within (a,b] (specifically `(a/2+7, a]`). To do this we can simply use the accumulation of the counts (i.e. first we preprocess our count array via modifying it such that it is a cumulative sum array, i.e. `count[i] = count[i] + count[i-1]`), and then we simply have: # people between `(a/2+7, a]` = `count[a] - count[a/2+7] - 1` (using `-1` to remove counting ourself).\\n\\n```\\nint counts[121] = {};\\nfor(int age : ages) {\\n\\tcounts[age]++;\\n}\\n\\nfor(int i = 1; i < 121; ++i) {\\n\\tcounts[i] += counts[i - 1];\\n}\\n\\nint total = 0;\\nfor(int age : ages) {\\n\\tint lower = age/2 + 7;\\n\\tif(lower >= age) continue;\\n\\ttotal += (counts[age] - counts[lower] - 1);\\n}\\n\\nreturn total;\\n```",
                "solutionTags": [],
                "code": "```\\nint counts[121] = {};\\nfor(int age : ages) {\\n\\tcounts[age]++;\\n}\\n\\nfor(int i = 1; i < 121; ++i) {\\n\\tcounts[i] += counts[i - 1];\\n}\\n\\nint total = 0;\\nfor(int age : ages) {\\n\\tint lower = age/2 + 7;\\n\\tif(lower >= age) continue;\\n\\ttotal += (counts[age] - counts[lower] - 1);\\n}\\n\\nreturn total;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128010,
                "title": "java-o-n-solution",
                "content": "    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int x : ages) count[x]++;\\n        int ans = 0;\\n        for(int i = 1; i <= 120; i++) {\\n            if (i > 14)\\n                ans += count[i] * (count[i]-1 + count[i-1] - count[i/2 + 7]);\\n            count[i] += count[i-1];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int x : ages) count[x]++;\\n        int ans = 0;\\n        for(int i = 1; i <= 120; i++) {\\n            if (i > 14)\\n                ans += count[i] * (count[i]-1 + count[i-1] - count[i/2 + 7]);\\n            count[i] += count[i-1];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3185944,
                "title": "java-o-nlogn-easy-to-understand-highly-commented-for-beginners",
                "content": "```\\n//     the basic intution of this code is to sort the array\\n//     and for each element we must search the first index where the condition age[y]>0.5*age[x]+7 is satisified \\n//     after that we just need to subtract the index of the array and the starting index to get no of pairs\\n//     but there is  a trick here as array contains duplicate elements if we calculate ans for ages=[16,16]\\n//     we will get wrong ans \\n//     so we maintain hashmap named index which contains last index of the element\\n//     we also maintain an hashmap named count which contains count of each element\\n//     we must now just iterate through keys of hashmap named index and search the first index satisfiying the given\\n//     condition and keep the count of no of pairs\\nclass Solution {\\n    private int solve(int ages[],int start,int end,int num){\\n        int flag=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(ages[mid]>(.5*num+7)){\\n                flag=1;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n//         this flag is the check whether there is any element which satisfies the conndition \\n//          if no such element is found we return -1 \\n        if(flag==-1){\\n            return -1;\\n        }\\n        return start;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n//         to apply binary search we are sorting \\n        Arrays.sort(ages); \\n        int c=0;\\n        HashMap<Integer,Integer>index=new HashMap<>();\\n        HashMap<Integer,Integer>count=new HashMap<>();\\n//         storing the count of each element as well as the last index of each element\\n        for(int i=0;i<ages.length;i++){\\n            index.put(ages[i],i);\\n            count.put(ages[i],count.getOrDefault(ages[i],0)+1);\\n        }\\n// iterating through the hashmap keys and find the first index where the condition age[y]>0.5*age[x]+7 is satisfied\\n//  the function will returen index subtract start current index from start index  add 1 to include that index and add the final result to c\\n        for(int x:index.keySet()){\\n            int k=solve(ages,0,index.get(x)-1,x);\\n          \\n            if(k!=-1){\\n            c+=((index.get(x)-k)*count.get(x));\\n            }\\n          \\n        }\\n        return c;\\n    }\\n}\\n// Pls do Upvote if you like :)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n//     the basic intution of this code is to sort the array\\n//     and for each element we must search the first index where the condition age[y]>0.5*age[x]+7 is satisified \\n//     after that we just need to subtract the index of the array and the starting index to get no of pairs\\n//     but there is  a trick here as array contains duplicate elements if we calculate ans for ages=[16,16]\\n//     we will get wrong ans \\n//     so we maintain hashmap named index which contains last index of the element\\n//     we also maintain an hashmap named count which contains count of each element\\n//     we must now just iterate through keys of hashmap named index and search the first index satisfiying the given\\n//     condition and keep the count of no of pairs\\nclass Solution {\\n    private int solve(int ages[],int start,int end,int num){\\n        int flag=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(ages[mid]>(.5*num+7)){\\n                flag=1;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n//         this flag is the check whether there is any element which satisfies the conndition \\n//          if no such element is found we return -1 \\n        if(flag==-1){\\n            return -1;\\n        }\\n        return start;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n//         to apply binary search we are sorting \\n        Arrays.sort(ages); \\n        int c=0;\\n        HashMap<Integer,Integer>index=new HashMap<>();\\n        HashMap<Integer,Integer>count=new HashMap<>();\\n//         storing the count of each element as well as the last index of each element\\n        for(int i=0;i<ages.length;i++){\\n            index.put(ages[i],i);\\n            count.put(ages[i],count.getOrDefault(ages[i],0)+1);\\n        }\\n// iterating through the hashmap keys and find the first index where the condition age[y]>0.5*age[x]+7 is satisfied\\n//  the function will returen index subtract start current index from start index  add 1 to include that index and add the final result to c\\n        for(int x:index.keySet()){\\n            int k=solve(ages,0,index.get(x)-1,x);\\n          \\n            if(k!=-1){\\n            c+=((index.get(x)-k)*count.get(x));\\n            }\\n          \\n        }\\n        return c;\\n    }\\n}\\n// Pls do Upvote if you like :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886317,
                "title": "c-self-explained-simple-code-easy-to-understand-tc-o-n-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint numFriendRequests(vector<int>& ages) {\\n        int n=ages.size(), ages_count[121]={0};\\n        for(int i=0;i<n;++i) ages_count[ages[i]]++;\\n        \\n        int friend_request=0;\\n        for(int i=1;i<=120;i++){\\n            for(int j=1;j<=120;++j){\\n                if(i<=0.5*double(j)+7 ||  i>j || (i>100 && j<100)) continue;\\n                if(i==j) friend_request+=(ages_count[i]-1)*(ages_count[i]);\\n                else friend_request+=(ages_count[i])*(ages_count[j]);\\n            }\\n        }\\n        \\n        return friend_request;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint numFriendRequests(vector<int>& ages) {\\n        int n=ages.size(), ages_count[121]={0};\\n        for(int i=0;i<n;++i) ages_count[ages[i]]++;\\n        \\n        int friend_request=0;\\n        for(int i=1;i<=120;i++){\\n            for(int j=1;j<=120;++j){\\n                if(i<=0.5*double(j)+7 ||  i>j || (i>100 && j<100)) continue;\\n                if(i==j) friend_request+=(ages_count[i]-1)*(ages_count[i]);\\n                else friend_request+=(ages_count[i])*(ages_count[j]);\\n            }\\n        }\\n        \\n        return friend_request;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1881256,
                "title": "prefix-sum",
                "content": "`age_count[i]` is a accumulative number of people with age up to ` i`.\\nExample:\\n`age_count[1]` is the number of people of age 1\\n`age_count[2]` is the number of people of age 1,2\\n`age_count[3]` is the number of people of age 1,2,3\\n...\\n`age_count[120]` is the number of people of age 1,2,3,...,120\\n\\nTo find the requests a person can make, we find the age lower bound and upper bound according to the rules. Let\\'s say the current person of the `age`.\\n\\nage[y] <= 0.5 * age[x] + 7            => discard any one with age <= `0.5 * age + 7`\\nage[y] > age[x]                              => discard any one with age > `age`\\nage[y] > 100 && age[x] < 100     => this rule is satisfied if the second one is satisfied.\\n\\nThe firsst rule will form the lower bound and the second rule will form the upper bound.\\nLet\\'s recall how sum range works with prefix sum. Suppose we have the following prefix sum:\\n```\\n0      l         r\\n.......a.........b\\n```\\nwhere \\n`l` stands for running sum from source array [0..l],\\n`r` stands for running sum from source array [0..r],\\n\\nthen, `prefix[r] - prefix[l]` is the running sum from source array [l+1..r].\\n\\nThis fits perfectly into our scenario. Here \\n`l` will be `0.5 * age + 7`\\n`r` will be `age` of the current person.\\n\\nOne edge case if when `0.5 * age + 7 > age`, there is no requests can be made.\\nIt happens when age is < 14.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        // age_count[i] means the number of people with age <= i\\n        vector<int> age_count(121, 0);\\n        for(int age: ages)\\n            age_count[age]++;\\n        for(int i=2; i<=120; i++) {\\n            age_count[i] += age_count[i-1];\\n        }\\n        \\n        int requests = 0;\\n        for(int age: ages) {\\n            int left = age*0.5+7; \\n            int right = age;\\n            if(left < right) {\\n                // -1 to excluse self\\n                requests += age_count[right] - age_count[left] - 1; \\n            }\\n        }\\n        \\n        return requests;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0      l         r\\n.......a.........b\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        // age_count[i] means the number of people with age <= i\\n        vector<int> age_count(121, 0);\\n        for(int age: ages)\\n            age_count[age]++;\\n        for(int i=2; i<=120; i++) {\\n            age_count[i] += age_count[i-1];\\n        }\\n        \\n        int requests = 0;\\n        for(int age: ages) {\\n            int left = age*0.5+7; \\n            int right = age;\\n            if(left < right) {\\n                // -1 to excluse self\\n                requests += age_count[right] - age_count[left] - 1; \\n            }\\n        }\\n        \\n        return requests;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621896,
                "title": "java-sorting-binary-search-o-n-log-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int n = ages.length, ans = 0;\\n        int [] cnt = new int[121];\\n        for (int i = 0; i<n; i++) {\\n            int lo = 0, hi = i-1, res = -1;\\n            // lower bound\\n            while (lo<=hi) {\\n                int mid = (lo+hi)/2;\\n                if (0.5*ages[i]+7.0>=ages[mid]) {\\n                    lo = mid+1;\\n                }\\n                else {\\n                    hi = mid-1;\\n                    res = mid;\\n                }\\n            }\\n            if (res!=-1) {\\n                ans+=(i-res); \\n                ans+=cnt[ages[i]];\\n            }\\n            cnt[ages[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int n = ages.length, ans = 0;\\n        int [] cnt = new int[121];\\n        for (int i = 0; i<n; i++) {\\n            int lo = 0, hi = i-1, res = -1;\\n            // lower bound\\n            while (lo<=hi) {\\n                int mid = (lo+hi)/2;\\n                if (0.5*ages[i]+7.0>=ages[mid]) {\\n                    lo = mid+1;\\n                }\\n                else {\\n                    hi = mid-1;\\n                    res = mid;\\n                }\\n            }\\n            if (res!=-1) {\\n                ans+=(i-res); \\n                ans+=cnt[ages[i]];\\n            }\\n            cnt[ages[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761812,
                "title": "python-easy-solution-with-sort-and-sliding-window",
                "content": "I think the intuition is pretty simple. Once we look at the rules carefully, we realize that each person wants to Add others who are younger or at the same age at them, but also, not too young.\\nWe use a dict to store the rightmost index of each age at the array. This is to make sure we consider people of the same age.\\nWe also keep a counter at the left side of the array too keep track of ages that are too young to befriend.\\nSo basically, this will end up being very much similar to a typical sliding window approach where we expand the window at each step and shrink it when it starts to become invalid.\\n\\n```\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        right_most = {}\\n        for ix,x in enumerate(ages):\\n            right_most[x] = ix\\n        \\n        l = 0\\n        count = 0\\n        for ix,x in enumerate(ages):\\n            while ages[l]<= (x/2 + 7) and l<right_most[x]:\\n                l+=1\\n            count+= right_most[x] - l\\n        return count\\n",
                "solutionTags": [],
                "code": "I think the intuition is pretty simple. Once we look at the rules carefully, we realize that each person wants to Add others who are younger or at the same age at them, but also, not too young.\\nWe use a dict to store the rightmost index of each age at the array. This is to make sure we consider people of the same age.\\nWe also keep a counter at the left side of the array too keep track of ages that are too young to befriend.\\nSo basically, this will end up being very much similar to a typical sliding window approach where we expand the window at each step and shrink it when it starts to become invalid.\\n\\n```\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        right_most = {}\\n        for ix,x in enumerate(ages):\\n            right_most[x] = ix\\n        \\n        l = 0\\n        count = 0\\n        for ix,x in enumerate(ages):\\n            while ages[l]<= (x/2 + 7) and l<right_most[x]:\\n                l+=1\\n            count+= right_most[x] - l\\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 565958,
                "title": "python-counting-and-then-one-pass",
                "content": "Calculate the min idx (age) for every age to be considered as friend\\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        cnts = [0] * 121\\n        for age in ages:\\n            cnts[age] += 1\\n        count = cnts\\n        res = 0\\n        for i in range(1,121):\\n            if cnts[i]:\\n                k = int(i* 0.5 + 7)\\n                res += cnts[i]*sum(cnts[k+1:i])\\n                if i>k:\\n                    res += cnts[i]*(cnts[i]-1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        cnts = [0] * 121\\n        for age in ages:\\n            cnts[age] += 1\\n        count = cnts\\n        res = 0\\n        for i in range(1,121):\\n            if cnts[i]:\\n                k = int(i* 0.5 + 7)\\n                res += cnts[i]*sum(cnts[k+1:i])\\n                if i>k:\\n                    res += cnts[i]*(cnts[i]-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148918,
                "title": "binary-search-upper-and-lower-bound-solution-java",
                "content": "```\\nclass Solution {\\n     public int numFriendRequests(int[] ages) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i : ages) {\\n\\n            int lowerBound = (int )(0.5*i + 8);\\n            int upperBound = i > 100 ? i :  Math.min(100, i);\\n            int index = lower(ages, lowerBound);\\n            int index2 = upper(ages, upperBound);\\n            if (index != -1 && index2 != -1 && index2 >= index) {\\n                res += index2 - index + 1;\\n                if ( i <= upperBound && i >= lowerBound) {\\n                    res--;\\n                }\\n            }\\n\\n        }\\n\\n        return res;\\n\\n    }\\n\\n    public int lower(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target <= ages[0]) {\\n            return 0;\\n        }\\n        if (target > ages[r]) {\\n            return -1;\\n        }\\n        while (l  <  r) {\\n            int m = l + (r - l ) / 2 ;\\n\\n            if (ages[m] >= target) {\\n                r = m;\\n            }else {\\n                l = m + 1;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public int upper(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target < ages[0]) {\\n            return -1;\\n        }\\n        if (target >= ages[r]) {\\n            return r;\\n        }\\n        while (l  <  r - 1) {\\n            int m = l + (r - l ) / 2 ;\\n            if (ages[m] <= target) {\\n                l = m;\\n            }else {\\n                r = m - 1;\\n            }\\n        }\\n        return ages[r] <= target ? r : l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int numFriendRequests(int[] ages) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i : ages) {\\n\\n            int lowerBound = (int )(0.5*i + 8);\\n            int upperBound = i > 100 ? i :  Math.min(100, i);\\n            int index = lower(ages, lowerBound);\\n            int index2 = upper(ages, upperBound);\\n            if (index != -1 && index2 != -1 && index2 >= index) {\\n                res += index2 - index + 1;\\n                if ( i <= upperBound && i >= lowerBound) {\\n                    res--;\\n                }\\n            }\\n\\n        }\\n\\n        return res;\\n\\n    }\\n\\n    public int lower(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target <= ages[0]) {\\n            return 0;\\n        }\\n        if (target > ages[r]) {\\n            return -1;\\n        }\\n        while (l  <  r) {\\n            int m = l + (r - l ) / 2 ;\\n\\n            if (ages[m] >= target) {\\n                r = m;\\n            }else {\\n                l = m + 1;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public int upper(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target < ages[0]) {\\n            return -1;\\n        }\\n        if (target >= ages[r]) {\\n            return r;\\n        }\\n        while (l  <  r - 1) {\\n            int m = l + (r - l ) / 2 ;\\n            if (ages[m] <= target) {\\n                l = m;\\n            }else {\\n                r = m - 1;\\n            }\\n        }\\n        return ages[r] <= target ? r : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127303,
                "title": "java-two-pointer-o-1-space-solution",
                "content": "ages[A] >= ages[B] > ages[A] * 0.5 +7,\\nB has to be older than 14 to make the above equation valid.\\n\\nThere are two possible directions of requests after we sort ages int[]:\\n1. From upstream bigger or equal number to all people with age bigger than ages[A] * 0.5 +7.\\n2. From downstream to all people with same age upwards in the array\\n\\nFor No.1, one way to is to use binary search to find the lower bound, then add to result, but we can also just keep a pointer j to current upstream number, then keep going down. Since ages are sorted, and the lower bounder if a linear function of ages[A], before we process the higher ages[A] lower bound, we won\\'t have to worry about missing other friend requests from other people with lower ages than A.\\nFor No.2, we keep a state variable ageSame. Each time we find a j, lower j by 1, we compare and see if it has same age as last one, if same, sameAge++, if not, we reset it to 0. \\nLastly, after we break out of for loop, j needs to keep going down until it hits the end or someone with age under 15, with same logic as the for loop.\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int res = 0;\\n        int sameAge = 0;\\n        int curLowerBound = (int) (ages[ages.length - 1]/2) + 7;\\n        int j = ages.length - 1;\\n        int i = 0;\\n        for (i = ages.length - 2; i >= 0; i--) {\\n            if (ages[i] < 15) break;\\n            while (ages[i] <= curLowerBound) {\\n                res += j - i - 1;\\n                j--;\\n                curLowerBound = (int)(ages[j]/2) + 7;\\n                if (ages[j] == ages[j+1]) {\\n                    sameAge++;\\n                    res += sameAge;\\n                } else sameAge = 0;\\n            }\\n        }\\n\\n        while (j > 0 && ages[j] > 14) {        \\n            res += j - i - 1;\\n            j--;\\n            if (ages[j] == ages[j+1]) {\\n                sameAge++;\\n                res += sameAge;\\n            } else sameAge = 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int res = 0;\\n        int sameAge = 0;\\n        int curLowerBound = (int) (ages[ages.length - 1]/2) + 7;\\n        int j = ages.length - 1;\\n        int i = 0;\\n        for (i = ages.length - 2; i >= 0; i--) {\\n            if (ages[i] < 15) break;\\n            while (ages[i] <= curLowerBound) {\\n                res += j - i - 1;\\n                j--;\\n                curLowerBound = (int)(ages[j]/2) + 7;\\n                if (ages[j] == ages[j+1]) {\\n                    sameAge++;\\n                    res += sameAge;\\n                } else sameAge = 0;\\n            }\\n        }\\n\\n        while (j > 0 && ages[j] > 14) {        \\n            res += j - i - 1;\\n            j--;\\n            if (ages[j] == ages[j+1]) {\\n                sameAge++;\\n                res += sameAge;\\n            } else sameAge = 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748863,
                "title": "python-o-n-2-o-nlogn-easy-to-understand",
                "content": "## **1. BRUTE FORCE - O(N^2)**\\n\\nThe Brute Force Solution is pretty simple. For every age, find every other age to which friend request can be sent.\\n\\n\\tIt is given that, \"x\" cannot send a friend request to \"y\" if - \\n\\t\\n\\t\\tage[y] <= 0.5 * age[x] + 7\\n\\t\\tage[y] > age[x]\\n\\t\\tage[y] > 100 && age[x] < 100\\n\\t\\t\\nWe can rewrite these conditions such that,\\n\\n\\t\"x\" can send a friend request to \"y\" if - \\n\\t\\n\\t\\tage[y] > 0.5 * age[x] + 7\\n\\t\\tage[y] <= age[x]\\n\\t\\t\\nWe do not need to care about third condition as that will be covered in the above two because in the above two, we are checking that age of \"y\" should be at most equal to age of \"x\", not more than that. \\n\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # For every person, we need to find how many friend requests he/she can make\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                \\n                if i != j:\\n                    # A person \"x\" can send a request to \"y if\\n                    # age[y] > 0.5 * age[x] + 7\\n                    # and age[y] <= age[x]\\n                    \\n                    condition1 = ages[j] > 0.5 * ages[i] + 7\\n                    condition2 = ages[j] <= ages[i]\\n                \\n                    if (condition1 and condition2): requestCount += 1\\n\\n        return requestCount\\n\\t\\t\\n## **2. BINARY SEARCH - O(NLogN)**\\t\\t\\n\\nTake a look at the conditions carefully -\\n\\n\\t\\tage[y] > 0.5 * age[x] + 7\\n\\t\\tage[y] <= age[x]\\n\\t\\t\\n\\nThis means, the range of valid values of age[y] for any age[x] is from -> 0.5 * age[x] + 7 to age[x]\\n\\nHence, for any age[x], we can try to find the smallest possible value in the array that is  > 0.5 * age[x] + 7\\nAnd also, we can try to find the largest possible value that is =<= age[x]\\n\\nAnd then, the number of values in between will be the number of friend requests that x can send.\\n\\nWe can do that using Binary Search but for that, we also need to sort the list first.\\n\\n\\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        for i in range(n):\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            requestCount += count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\\n\\n\\n## **3. OPTIMIZED BINARY SEARCH FOR DUPLICATE AGES - O(NLogN)**\\t\\t\\n\\nSince ages may be duplicate, why do the same process for an age if we have done it before? \\n\\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        # Since there can be duplicate ages\\n        # We can avoid doing same work again for same age\\n        dict = {}\\n        \\n        for i in range(n):\\n            \\n            # Avoid running below code if we have already have the count availabl\\n            # This is for duplicate ages\\n            if ages[i] in dict: \\n                requestCount += dict[ages[i]]\\n                continue\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            \\n            requestCount += count if count > 0 else 0\\n            \\n            # For this age value, how many friend requests can we send?\\n            dict[ages[i]] = count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        for i in range(n):\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            requestCount += count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        # Since there can be duplicate ages\\n        # We can avoid doing same work again for same age\\n        dict = {}\\n        \\n        for i in range(n):\\n            \\n            # Avoid running below code if we have already have the count availabl\\n            # This is for duplicate ages\\n            if ages[i] in dict: \\n                requestCount += dict[ages[i]]\\n                continue\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            \\n            requestCount += count if count > 0 else 0\\n            \\n            # For this age value, how many friend requests can we send?\\n            dict[ages[i]] = count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2635031,
                "title": "java-8-feature-s-more-concise-code-3-lines-most-voted",
                "content": "```\\n**UPVOTE PLEASE**\\n\\npublic int numFriendRequests(int[] ages) {\\nvar count = new HashMap<Integer,Integer>();\\n    BiPredicate<Integer,Integer> p=(a,b)->!(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    Arrays.stream(ages).boxed().forEach(age->count.put(age, count.getOrDefault(age,0)+1));\\n    var res = new AtomicInteger(0);\\n    count.keySet().forEach(a->count.keySet().forEach(b->{if (p.test(a, b)){res.set(count.get(a) * (count.get(b) - (a == b ? 1 : 0))+res.get());}}));\\n    return res.get();    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n**UPVOTE PLEASE**\\n\\npublic int numFriendRequests(int[] ages) {\\nvar count = new HashMap<Integer,Integer>();\\n    BiPredicate<Integer,Integer> p=(a,b)->!(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    Arrays.stream(ages).boxed().forEach(age->count.put(age, count.getOrDefault(age,0)+1));\\n    var res = new AtomicInteger(0);\\n    count.keySet().forEach(a->count.keySet().forEach(b->{if (p.test(a, b)){res.set(count.get(a) * (count.get(b) - (a == b ? 1 : 0))+res.get());}}));\\n    return res.get();    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043130,
                "title": "simple-python-solution-beats-88",
                "content": "\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\t    # send request or not\\n        def request(x,y):\\n            if y <= 0.5 * x + 7 or y > x or (y > 100 and x < 100):\\n                return False\\n            return True\\n        \\n\\t\\t# Construct a dictionary that the keys are ages and the values are the frequency of the age in the list. \\n        ages_map = collections.Counter(ages)\\n\\t\\t\\n\\t\\t# Sort age list\\n        ages = list(ages_map.keys())\\n        ages.sort(reverse=True)\\n\\n        count = 0\\n        for i in range(len(ages)):\\n            for j in range(i+1,len(ages)):\\n\\t\\t\\t# Different age: {a:2, b:3}\\n\\t\\t\\t# a --> b :  number of a * number of b\\n                if request(ages[i],ages[j]):\\n                    count += ages_map[ages[i]]* ages_map[ages[j]]\\n            # Same age: {a:2}\\n\\t\\t\\t# a --> a: n * (n -1)\\n\\t\\t\\t\\t# example1 : [16, 16, 16]: request --> True --> 3 * (3-1) = 6\\n\\t\\t\\t\\t# example2: [6,6] : request --> False \\n            if request(ages[i],ages[i]):\\n                count += ages_map[ages[i]]*(ages_map[ages[i]]-1)\\n        return count\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\t    # send request or not\\n        def request(x,y):\\n            if y <= 0.5 * x + 7 or y > x or (y > 100 and x < 100):\\n                return False\\n            return True\\n        \\n\\t\\t# Construct a dictionary that the keys are ages and the values are the frequency of the age in the list. \\n        ages_map = collections.Counter(ages)\\n\\t\\t\\n\\t\\t# Sort age list\\n        ages = list(ages_map.keys())\\n        ages.sort(reverse=True)\\n\\n        count = 0\\n        for i in range(len(ages)):\\n            for j in range(i+1,len(ages)):\\n\\t\\t\\t# Different age: {a:2, b:3}\\n\\t\\t\\t# a --> b :  number of a * number of b\\n                if request(ages[i],ages[j]):\\n                    count += ages_map[ages[i]]* ages_map[ages[j]]\\n            # Same age: {a:2}\\n\\t\\t\\t# a --> a: n * (n -1)\\n\\t\\t\\t\\t# example1 : [16, 16, 16]: request --> True --> 3 * (3-1) = 6\\n\\t\\t\\t\\t# example2: [6,6] : request --> False \\n            if request(ages[i],ages[i]):\\n                count += ages_map[ages[i]]*(ages_map[ages[i]]-1)\\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1999119,
                "title": "the-actual-facebook-interview-question-java",
                "content": "Thanks to @connect2grp for pointing out an error in my initial solution :)\\n```\\n/*\\nA group of centaurs (mythical half-human, half-horse creatures) all sign up for Facebook accounts at the same time. They immediately start sending each other friend requests, in accordance with the ancient rules that have governed centaur friendship since the dawn of time:\\n\\n1. A centaur will only send a friend request to another centaur if the recipient is at least (X/2 + 7) of the sender\\'s age. For example, a 200-year old centaur can only send friend requests to centaurs that are at least 107 years old.\\n2. A centaur will not send a friend request to another centaur that is older than it is.\\n3. A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n4. If any of the conditions for sending a friend request are not met, no friend request will be sent.\\nWrite a function that, given an array of centaur ages, returns an integer of the total number of friend requests that the group of centaurs will send to each other.\\n*/\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] test1 = new int[]{120, 110}; // => 1\\n        int[] test2 = new int[]{120,110,99}; // => 1\\n        int[] test3 = new int[]{120,45,230,400,88,300,101}; // => 4\\n        int[] test4 = new int[]{120,45,55,230,400,88,300,101}; // => 6\\n        int[] test5 = new int[]{100,110,120};\\n    }\\n\\n    public static int numFriendRequests(int[] ages) {\\n        if (ages.length == 0) {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(ages);\\n        int requests = 0;\\n        \\n        for (int i = 0; i < ages.length; i++) {\\n            int curr_age = ages[i];\\n            int left = findIndex(ages, curr_age, curr_age / 2 + 7);\\n            int right = findIndex(ages, curr_age, curr_age);\\n            requests += Math.max(0, right - left);\\n        }\\n        return requests;\\n    }\\n    \\n    public static int findIndex(int[] ages, int curr_age, int target) {\\n        if (curr_age >= 100) {\\n            target = Math.max(target, 100);\\n        }\\n        \\n        int left = 0;\\n        int right = ages.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ages[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nA group of centaurs (mythical half-human, half-horse creatures) all sign up for Facebook accounts at the same time. They immediately start sending each other friend requests, in accordance with the ancient rules that have governed centaur friendship since the dawn of time:\\n\\n1. A centaur will only send a friend request to another centaur if the recipient is at least (X/2 + 7) of the sender\\'s age. For example, a 200-year old centaur can only send friend requests to centaurs that are at least 107 years old.\\n2. A centaur will not send a friend request to another centaur that is older than it is.\\n3. A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n4. If any of the conditions for sending a friend request are not met, no friend request will be sent.\\nWrite a function that, given an array of centaur ages, returns an integer of the total number of friend requests that the group of centaurs will send to each other.\\n*/\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] test1 = new int[]{120, 110}; // => 1\\n        int[] test2 = new int[]{120,110,99}; // => 1\\n        int[] test3 = new int[]{120,45,230,400,88,300,101}; // => 4\\n        int[] test4 = new int[]{120,45,55,230,400,88,300,101}; // => 6\\n        int[] test5 = new int[]{100,110,120};\\n    }\\n\\n    public static int numFriendRequests(int[] ages) {\\n        if (ages.length == 0) {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(ages);\\n        int requests = 0;\\n        \\n        for (int i = 0; i < ages.length; i++) {\\n            int curr_age = ages[i];\\n            int left = findIndex(ages, curr_age, curr_age / 2 + 7);\\n            int right = findIndex(ages, curr_age, curr_age);\\n            requests += Math.max(0, right - left);\\n        }\\n        return requests;\\n    }\\n    \\n    public static int findIndex(int[] ages, int curr_age, int target) {\\n        if (curr_age >= 100) {\\n            target = Math.max(target, 100);\\n        }\\n        \\n        int left = 0;\\n        int right = ages.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ages[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973990,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121,0);\\n        int n=ages.size();\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v[ages[i]]++;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=15;i<=120;i++)\\n        {\\n            ans+=v[i]*(v[i]-1);\\n        }\\n        \\n        for(int i=1;i<=120;i++)\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                if(j>(i/2)+7)\\n                {\\n                    ans+=v[i]*v[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121,0);\\n        int n=ages.size();\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v[ages[i]]++;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=15;i<=120;i++)\\n        {\\n            ans+=v[i]*(v[i]-1);\\n        }\\n        \\n        for(int i=1;i<=120;i++)\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                if(j>(i/2)+7)\\n                {\\n                    ans+=v[i]*v[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855680,
                "title": "javascript-cumulative-sum-o-n",
                "content": "This approach uses multiple O(Max(N, 120)) passes and O(Max(N, 120)) auxiliary space.\\nPlease let me know if you have suggestions for improvement or if my time / space analysis is off.\\n\\nGeneral Approach:\\nAnother way to rephrase the requirements is that, for each age X, there is an acceptable age interval [Y1, Y2]  to which we can send friend requests.\\nLower boundary (Y1): Y must be > 7 + 0.5 * X\\nUpper boundary (Y2): Y must be <= X\\nThe last condition described in the problem (\"no request sent if X < 100 and Y > 100\") is essentially covered by our upper bound, so the problem can really be reduced to dealing with the interval described above.\\n\\n\\n```\\nvar numFriendRequests = function(ages) {\\n    let count = 0;\\n    \\n    const ageCountMap = new Map(); // S: O(N)\\n    const ageCountArr = [0]; // S: O(120)\\n    \\n    // Count how many people have a certain age.\\n    for (let age of ages) { // T: O(N)\\n        let currCount = ageCountMap.get(age) || 0;\\n        ageCountMap.set(age, currCount + 1);\\n    }\\n    // Count how many people have up to (and including) a certain age\\n    for (let i = 1; i <= 120; i++) { // T: O(120)\\n        let ageCount = ageCountMap.get(i) || 0;\\n        ageCountArr.push(ageCount + ageCountArr[i - 1]);\\n    }\\n    \\n    for (let age of ages) { // T: O(N)\\n        let lowerBound = Math.floor((age * 0.5)) + 7 + 1; // Inclusive\\n        let upperBound = age; // Inclusive\\n\\t\\t// Calculate requests by subtracting cumulative sum up to the lower bound from the cumulative sum up to the upper bound\\n\\t\\t// Need \"-1\" to deduct a given person from the request, since we can\\'t send requests to ourselves\\n        let requests = ageCountArr[upperBound] - ageCountArr[lowerBound - 1] - 1; \\n        if (requests < 0) continue;\\n        count += requests;\\n    }\\n    return count;\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "This approach uses multiple O(Max(N, 120)) passes and O(Max(N, 120)) auxiliary space.\\nPlease let me know if you have suggestions for improvement or if my time / space analysis is off.\\n\\nGeneral Approach:\\nAnother way to rephrase the requirements is that, for each age X, there is an acceptable age interval [Y1, Y2]  to which we can send friend requests.\\nLower boundary (Y1): Y must be > 7 + 0.5 * X\\nUpper boundary (Y2): Y must be <= X\\nThe last condition described in the problem (\"no request sent if X < 100 and Y > 100\") is essentially covered by our upper bound, so the problem can really be reduced to dealing with the interval described above.\\n\\n\\n```\\nvar numFriendRequests = function(ages) {\\n    let count = 0;\\n    \\n    const ageCountMap = new Map(); // S: O(N)\\n    const ageCountArr = [0]; // S: O(120)\\n    \\n    // Count how many people have a certain age.\\n    for (let age of ages) { // T: O(N)\\n        let currCount = ageCountMap.get(age) || 0;\\n        ageCountMap.set(age, currCount + 1);\\n    }\\n    // Count how many people have up to (and including) a certain age\\n    for (let i = 1; i <= 120; i++) { // T: O(120)\\n        let ageCount = ageCountMap.get(i) || 0;\\n        ageCountArr.push(ageCount + ageCountArr[i - 1]);\\n    }\\n    \\n    for (let age of ages) { // T: O(N)\\n        let lowerBound = Math.floor((age * 0.5)) + 7 + 1; // Inclusive\\n        let upperBound = age; // Inclusive\\n\\t\\t// Calculate requests by subtracting cumulative sum up to the lower bound from the cumulative sum up to the upper bound\\n\\t\\t// Need \"-1\" to deduct a given person from the request, since we can\\'t send requests to ourselves\\n        let requests = ageCountArr[upperBound] - ageCountArr[lowerBound - 1] - 1; \\n        if (requests < 0) continue;\\n        count += requests;\\n    }\\n    return count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1397398,
                "title": "java-easy-map",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n         Map<Integer,Integer> mp = new HashMap<>();\\n      \\n         for(int age : ages){\\n            mp.put(age,mp.getOrDefault(age,0) + 1);\\n         }\\n        int count = 0; //count of friend requests\\n        for(int a : mp.keySet()){\\n           for(int b : mp.keySet()){\\n              if(canSendFReq(a,b) == true){\\n                  int AsF = mp.get(a); //A\\'s Friends\\n                  int BsF = mp.get(b); //B\\'s Friends\\n                //As a person cannot send req to himself\\n                  if(a == b){\\n                     BsF--;   //Reduce B\\'s friends by one as B is iterating inside the inner loop\\n                  }\\n\\t\\t\\t   //As both of them gonna sent req to each other (also persons with same ages will be doing same thing)\\n                 count = count + AsF * BsF;\\n              }\\n           }\\n        }\\n      return count;\\n    }\\n    public boolean canSendFReq(int x,int y){\\n        return !(y <= 0.5 * x + 7 || y > x || (y > 100 && x < 100));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n         Map<Integer,Integer> mp = new HashMap<>();\\n      \\n         for(int age : ages){\\n            mp.put(age,mp.getOrDefault(age,0) + 1);\\n         }\\n        int count = 0; //count of friend requests\\n        for(int a : mp.keySet()){\\n           for(int b : mp.keySet()){\\n              if(canSendFReq(a,b) == true){\\n                  int AsF = mp.get(a); //A\\'s Friends\\n                  int BsF = mp.get(b); //B\\'s Friends\\n                //As a person cannot send req to himself\\n                  if(a == b){\\n                     BsF--;   //Reduce B\\'s friends by one as B is iterating inside the inner loop\\n                  }\\n\\t\\t\\t   //As both of them gonna sent req to each other (also persons with same ages will be doing same thing)\\n                 count = count + AsF * BsF;\\n              }\\n           }\\n        }\\n      return count;\\n    }\\n    public boolean canSendFReq(int x,int y){\\n        return !(y <= 0.5 * x + 7 || y > x || (y > 100 && x < 100));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297207,
                "title": "javascript-solution-cumulative-sum-and-sliding-window",
                "content": "```\\nvar numFriendRequests = function(ages) {\\n    const count = new Array(121).fill(0);\\n    \\n    ages.forEach((age) => count[age]++);\\n\\n    let res = 0; // total friend request sent\\n    let tot = 0;  // cumulative count of people so far\\n    \\n    for (let i = 0; i <= 120; i++) {\\n\\n        if (i > 14 && count[i] != 0) {\\n            const limit = Math.floor(0.5 * i) + 7;\\n            const rest = tot - count[limit];\\n\\n            res += (count[i] * rest); // current age group send friend request to other people who are within their limit\\n            res += (count[i] * (count[i] - 1)); // current age group send friend request to each other\\n        }\\n\\n        tot += count[i];\\n        count[i] = tot; \\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar numFriendRequests = function(ages) {\\n    const count = new Array(121).fill(0);\\n    \\n    ages.forEach((age) => count[age]++);\\n\\n    let res = 0; // total friend request sent\\n    let tot = 0;  // cumulative count of people so far\\n    \\n    for (let i = 0; i <= 120; i++) {\\n\\n        if (i > 14 && count[i] != 0) {\\n            const limit = Math.floor(0.5 * i) + 7;\\n            const rest = tot - count[limit];\\n\\n            res += (count[i] * rest); // current age group send friend request to other people who are within their limit\\n            res += (count[i] * (count[i] - 1)); // current age group send friend request to each other\\n        }\\n\\n        tot += count[i];\\n        count[i] = tot; \\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216308,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n            int k , count=0;\\n               sort(ages.begin(),ages.end());\\n        for(int i=ages.size()-1;i>0;i--)\\n        {\\n                  k=upper_bound(ages.begin(),ages.begin()+i,((ages[i]/2)+7))-ages.begin(); \\n\\t\\t\\t\\t       // it returns the index that is greater than (ages[i]/2+7) \\n             \\n                     if(k<=i)  \\n                      {\\n\\t\\t\\t\\t\\t       count+=i-k;   // i-k gives the no of requests can ages[i] can send \\n\\t\\t\\t\\t\\t  }   \\n\\t\\t\\t\\t\\t     // k is greater than i if upper_bound of (ages[i]/2+7)  is not found\\n              \\n\\t\\t\\t      k=i-1;\\n               while(k>=0&&ages[k]==ages[i]&&ages[k]>((ages[i]/2)+7))\\n               {\\n                   count++;\\n                   k--;\\n               }\\n\\t\\t\\t   // to check if there are any equal ages and also satisfy (ages[i]/2+7)  condition\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n            int k , count=0;\\n               sort(ages.begin(),ages.end());\\n        for(int i=ages.size()-1;i>0;i--)\\n        {\\n                  k=upper_bound(ages.begin(),ages.begin()+i,((ages[i]/2)+7))-ages.begin(); \\n\\t\\t\\t\\t       // it returns the index that is greater than (ages[i]/2+7) \\n             \\n                     if(k<=i)  \\n                      {\\n\\t\\t\\t\\t\\t       count+=i-k;   // i-k gives the no of requests can ages[i] can send \\n\\t\\t\\t\\t\\t  }   \\n\\t\\t\\t\\t\\t     // k is greater than i if upper_bound of (ages[i]/2+7)  is not found\\n              \\n\\t\\t\\t      k=i-1;\\n               while(k>=0&&ages[k]==ages[i]&&ages[k]>((ages[i]/2)+7))\\n               {\\n                   count++;\\n                   k--;\\n               }\\n\\t\\t\\t   // to check if there are any equal ages and also satisfy (ages[i]/2+7)  condition\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066096,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "1. Brute force O(n^2)\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int num=0,n =ages.length;\\n        for(int i=0;i<n-1;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(canMakeRequest(ages[i],ages[j])) {\\n                    num++;\\n                }\\n                if(canMakeRequest(ages[j],ages[i])) {\\n                    num++;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n    private boolean canMakeRequest(int from, int to) {\\n        return to<=from && to>0.5*from+7;\\n    }\\n```\\n2. Binary search O(nlogn). B is in (0.5A+7, A]. We can sort the array and compute number of Bs for each A.\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int num=0;\\n        for(int i=0;i<ages.length;i++) {\\n            int left = leftBound(ages[i]/2+8,ages), right = rightBound(ages[i], ages);\\n            num+=Math.max(right-left,0);   \\n        }\\n        return num;\\n    }\\n    private int leftBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r)/2;\\n            if(ages[mid]<target) {\\n                l = mid+1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n    private int rightBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r+1)/2;\\n            if(ages[mid]<=target) {\\n                l = mid;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n```\\n3. Bucket sort O(n)\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int age:ages) {\\n            count[age]++;\\n        }\\n        int num=0;\\n        for(int i=1;i<=120;i++) {\\n            for(int j=i/2+8;j<=i;j++) {\\n                if(i == j) {\\n                    num += count[i]*(count[i]-1);\\n                } else {\\n                    num += count[i]*count[j];   \\n                }\\n            }\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int num=0,n =ages.length;\\n        for(int i=0;i<n-1;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(canMakeRequest(ages[i],ages[j])) {\\n                    num++;\\n                }\\n                if(canMakeRequest(ages[j],ages[i])) {\\n                    num++;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n    private boolean canMakeRequest(int from, int to) {\\n        return to<=from && to>0.5*from+7;\\n    }\\n```\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int num=0;\\n        for(int i=0;i<ages.length;i++) {\\n            int left = leftBound(ages[i]/2+8,ages), right = rightBound(ages[i], ages);\\n            num+=Math.max(right-left,0);   \\n        }\\n        return num;\\n    }\\n    private int leftBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r)/2;\\n            if(ages[mid]<target) {\\n                l = mid+1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n    private int rightBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r+1)/2;\\n            if(ages[mid]<=target) {\\n                l = mid;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n```\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int age:ages) {\\n            count[age]++;\\n        }\\n        int num=0;\\n        for(int i=1;i<=120;i++) {\\n            for(int j=i/2+8;j<=i;j++) {\\n                if(i == j) {\\n                    num += count[i]*(count[i]-1);\\n                } else {\\n                    num += count[i]*count[j];   \\n                }\\n            }\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022078,
                "title": "python-3-sliding-window-beats-99-6",
                "content": "Nothing fancy, I just applied counter to speed up processing same agers.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages = sorted(Counter(ages).items(), key=lambda x: x[0])\\n\\n        def calc(arr):\\n            total = 0\\n            window = 0\\n            left = 0\\n            for right, (age, count) in enumerate(arr):\\n                while left < right and arr[left][0] <= 0.5 * age + 7:\\n                    window -= arr[left][1]\\n                    left += 1\\n                total += window * count\\n                if count > 1 and age > 0.5 * age + 7:\\n                    total += (count - 1) * count\\n                window += count\\n            return total\\n\\n        return calc(ages)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages = sorted(Counter(ages).items(), key=lambda x: x[0])\\n\\n        def calc(arr):\\n            total = 0\\n            window = 0\\n            left = 0\\n            for right, (age, count) in enumerate(arr):\\n                while left < right and arr[left][0] <= 0.5 * age + 7:\\n                    window -= arr[left][1]\\n                    left += 1\\n                total += window * count\\n                if count > 1 and age > 0.5 * age + 7:\\n                    total += (count - 1) * count\\n                window += count\\n            return total\\n\\n        return calc(ages)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923906,
                "title": "java-1-ms-faster-than-100-00-40-9-mb-less-than-7-93",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] cnts = new int[121];\\n        int[] sums = new int[121];\\n        for (int age : ages) {\\n            ++cnts[age];\\n        }\\n        for (int i = 1; i <= 120; ++i) {\\n            sums[i] = sums[i - 1] + cnts[i];\\n        }\\n        int sum = 0;\\n        for (int i = 15; i <= 120; ++i) {\\n            if (cnts[i] <= 0) {\\n                continue;\\n            }\\n            int cnt = sums[i] - sums[i / 2 + 7];\\n            sum += (cnt - 1) * cnts[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] cnts = new int[121];\\n        int[] sums = new int[121];\\n        for (int age : ages) {\\n            ++cnts[age];\\n        }\\n        for (int i = 1; i <= 120; ++i) {\\n            sums[i] = sums[i - 1] + cnts[i];\\n        }\\n        int sum = 0;\\n        for (int i = 15; i <= 120; ++i) {\\n            if (cnts[i] <= 0) {\\n                continue;\\n            }\\n            int cnt = sums[i] - sums[i / 2 + 7];\\n            sum += (cnt - 1) * cnts[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388169,
                "title": "wrong-test-case",
                "content": "```\\nInput: [16,17,18]\\nOutput: 2\\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\\n```\\n\\nIn this given test case, how come ages[2] doesn\\'t friend request ages[0]? (i.e. why is 18 -> 16 invalid?)",
                "solutionTags": [],
                "code": "```\\nInput: [16,17,18]\\nOutput: 2\\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330880,
                "title": "python-sliding-window-one-pass",
                "content": "I use `L` and `R` to maintain a sliding window to calculate the requests made from the current element to elements in the window.\\nAnd I also use the varible `n` to calculate the request made from within the window to the current element ( Since we have sorted the array, the elements which made requests from within the window must have the same value with the current element).\\n```python\\ndef numFriendRequests(self, ages):\\n    ages.sort()\\n    L = res = n = 0\\n    for R, V in enumerate(ages):\\n        limit = V/2 + 7\\n        while L < R and ages[L] <= limit:\\n            L += 1\\n        n = n+1 if R and ages[R] == ages[R-1] and ages[R] > 14 else 0\\n        res += R-L+n\\n    return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef numFriendRequests(self, ages):\\n    ages.sort()\\n    L = res = n = 0\\n    for R, V in enumerate(ages):\\n        limit = V/2 + 7\\n        while L < R and ages[L] <= limit:\\n            L += 1\\n        n = n+1 if R and ages[R] == ages[R-1] and ages[R] > 14 else 0\\n        res += R-L+n\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 282361,
                "title": "o-n-high-school-logic-a-2-7-b-a",
                "content": "A cannot send B request if (B<=A/2+7) || (B>A) || (B>100&&A<100). Then\\nA can send B request if ![(B<=A/2+7) || (B>A) || (B>100&&A<100)], which is equivalent to\\nA/2+7<B<=A && (B<=100 || A>=100).\\nLastly, we can see that (B<=100 || A>=100) is redundant, this is because (1) if A >= 100, we don\\'t need to consider B, since the boolean expression is already true. (2) if A <100, then by B<=A, B has to be less than 100, hence B<=100 is true. Hence, the restriction can be reduced to A/2+7<B<=A. By simple algebra, we can see that A/2+7<A, A>14.\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        //A send request to B if A/2+7<B<=A && (B<=100 || A >=100)\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            for(int B=A/2+8; B<=A; B++) {\\n                if(B < A) ret += count[B]*count[A];\\n                else if(B == A) ret += count[A] * (count[A]-1);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\nThe above time complexity is O(N^2), however If we watch the second loop carefully, we can see that it is actually the **count[A]\\\\*(range sum of count[A/2+8 : A] - 1)**, hence we can use prefix sum to handle it quickly in O(N). The optimization is shown below.\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        for(int i=1; i<=120; i++) count[i] += count[i-1];\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            int B = A/2+8;\\n            ret += (count[A]-count[A-1]) * (count[A] - count[B-1] - 1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        //A send request to B if A/2+7<B<=A && (B<=100 || A >=100)\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            for(int B=A/2+8; B<=A; B++) {\\n                if(B < A) ret += count[B]*count[A];\\n                else if(B == A) ret += count[A] * (count[A]-1);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        for(int i=1; i<=120; i++) count[i] += count[i-1];\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            int B = A/2+8;\\n            ret += (count[A]-count[A-1]) * (count[A] - count[B-1] - 1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126969,
                "title": "python-collections-counter-ac-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cntr=Counter(ages)\\n        res=0\\n        for A in cntr:\\n            for B in cntr:\\n                if A==B:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=(cntr[A]*(cntr[A]-1))\\n                else:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=cntr[A]*cntr[B]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cntr=Counter(ages)\\n        res=0\\n        for A in cntr:\\n            for B in cntr:\\n                if A==B:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=(cntr[A]*(cntr[A]-1))\\n                else:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=cntr[A]*cntr[B]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126943,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        if(ages.length < 2) return 0;\\n        int[] cnt = new int[125];\\n        for(int n:ages){\\n            cnt[n]++;\\n        }\\n        int res = 0;\\n        for(int i=2;i<=120;i++){\\n            if(cnt[i] == 0) continue;\\n            int total = 0;\\n            int start = (int)(0.5 * i) + 8;    \\n            if(start > i) continue;// violates this rule age[B] <= 0.5 * age[A] + 7...so skip this i\\n            for(int j=start;j<i;j++){\\n                total += cnt[j];\\n            }            \\n            if(cnt[i] > 1)\\n                total += (cnt[i] - 1);            \\n            res += (total * cnt[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\nNote: Please see comments for explanation",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        if(ages.length < 2) return 0;\\n        int[] cnt = new int[125];\\n        for(int n:ages){\\n            cnt[n]++;\\n        }\\n        int res = 0;\\n        for(int i=2;i<=120;i++){\\n            if(cnt[i] == 0) continue;\\n            int total = 0;\\n            int start = (int)(0.5 * i) + 8;    \\n            if(start > i) continue;// violates this rule age[B] <= 0.5 * age[A] + 7...so skip this i\\n            for(int j=start;j<i;j++){\\n                total += cnt[j];\\n            }            \\n            if(cnt[i] > 1)\\n                total += (cnt[i] - 1);            \\n            res += (total * cnt[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126935,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int freq [] = new int [121];\\n        int ret = 0;\\n        \\n        for(int i = 0; i < ages.length; i++){\\n            freq[ages[i]]++;\\n        }\\n        \\n        for(int i = 1; i <= 120; i++){\\n            for(int j = 1; j <= 120; j++){\\n                if(!((j <= 0.5 * i + 7) || (j > i) || (j > 100 && i < 100))){\\n                    if(i == j) {\\n                        ret = ret + ((freq[i] * (freq[i] - 1)));\\n                    } else {\\n                        ret = ret + (freq[i] * freq[j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int freq [] = new int [121];\\n        int ret = 0;\\n        \\n        for(int i = 0; i < ages.length; i++){\\n            freq[ages[i]]++;\\n        }\\n        \\n        for(int i = 1; i <= 120; i++){\\n            for(int j = 1; j <= 120; j++){\\n                if(!((j <= 0.5 * i + 7) || (j > i) || (j > 100 && i < 100))){\\n                    if(i == j) {\\n                        ret = ret + ((freq[i] * (freq[i] - 1)));\\n                    } else {\\n                        ret = ret + (freq[i] * freq[j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034801,
                "title": "best-java-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481569,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121, 0);\\n        for(auto it: ages)\\n            v[it]++;\\n        int ans=0;\\n        for(int i=1; i<121; i++)\\n        {\\n            if(v[i]==0) continue;\\n            int tmp =0;\\n            for(int j=1; j<121; j++)\\n            {\\n                if(v[j]==0) continue;\\n                if(i==j)\\n                {\\n                    if(j>(i*0.5+7))\\n                        tmp+=(v[i]-1);\\n                }\\n                else\\n                {\\n                    bool flag= true;\\n                    if(j<=(i*0.5+7)) flag= false;\\n                    if(j>i) flag= false;\\n                    if(i<100 && j>100) flag= false;\\n                    if(flag)\\n                        tmp+=v[j];\\n                }\\n            }\\n            ans= ans + v[i]*tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass FriendRequest:\\n    def _binarySearch(self, ages, target):\\n        lo = 0\\n        hi = len(ages) - 1\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if ages[mid] <= target:\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return lo\\n    \\n    def numOfRequests(self, ages):\\n        requests = 0\\n        ages.sort()\\n        for age in ages:\\n            left = self._binarySearch(ages, age // 2 + 7)\\n            right = self._binarySearch(ages, age) - 1\\n            requests += max(0, right - left)\\n        return requests\\n\\nclass FriendRequest2:\\n    def _bucketSort(self, ages):\\n        buckets = [0] * 121\\n        for age in ages:\\n            buckets[age] += 1\\n        return buckets\\n    \\n    def _buildPrefixSum(self, buckets):\\n        prefix = [0] * 121\\n        for i in range(1, 121):\\n            prefix[i] += prefix[i - 1] + buckets[i]\\n        return prefix\\n    \\n    def numOfRequests(self, ages):\\n        buckets = self._bucketSort(ages)\\n        prefix = self._buildPrefixSum(buckets)\\n        requests = 0\\n        for age in range(15, 121):\\n            if buckets[age] == 0:\\n                continue\\n            cur_requests = prefix[age] - prefix[age // 2 + 7]\\n            requests += buckets[age] * cur_requests - buckets[age]\\n        return requests\\n\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        return FriendRequest2().numOfRequests(ages)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        for(int a : ages) {\\n            numInAge[a]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            sumInAge[i] = numInAge[i] + sumInAge[i-1];\\n        }\\n        for(int i = 15; i <= 120; i++) {\\n            if (numInAge[i] == 0)   continue;\\n            int c = sumInAge[i] - sumInAge[i/2 + 7];\\n            res += c * numInAge[i] - numInAge[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121, 0);\\n        for(auto it: ages)\\n            v[it]++;\\n        int ans=0;\\n        for(int i=1; i<121; i++)\\n        {\\n            if(v[i]==0) continue;\\n            int tmp =0;\\n            for(int j=1; j<121; j++)\\n            {\\n                if(v[j]==0) continue;\\n                if(i==j)\\n                {\\n                    if(j>(i*0.5+7))\\n                        tmp+=(v[i]-1);\\n                }\\n                else\\n                {\\n                    bool flag= true;\\n                    if(j<=(i*0.5+7)) flag= false;\\n                    if(j>i) flag= false;\\n                    if(i<100 && j>100) flag= false;\\n                    if(flag)\\n                        tmp+=v[j];\\n                }\\n            }\\n            ans= ans + v[i]*tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass FriendRequest:\\n    def _binarySearch(self, ages, target):\\n        lo = 0\\n        hi = len(ages) - 1\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if ages[mid] <= target:\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return lo\\n    \\n    def numOfRequests(self, ages):\\n        requests = 0\\n        ages.sort()\\n        for age in ages:\\n            left = self._binarySearch(ages, age // 2 + 7)\\n            right = self._binarySearch(ages, age) - 1\\n            requests += max(0, right - left)\\n        return requests\\n\\nclass FriendRequest2:\\n    def _bucketSort(self, ages):\\n        buckets = [0] * 121\\n        for age in ages:\\n            buckets[age] += 1\\n        return buckets\\n    \\n    def _buildPrefixSum(self, buckets):\\n        prefix = [0] * 121\\n        for i in range(1, 121):\\n            prefix[i] += prefix[i - 1] + buckets[i]\\n        return prefix\\n    \\n    def numOfRequests(self, ages):\\n        buckets = self._bucketSort(ages)\\n        prefix = self._buildPrefixSum(buckets)\\n        requests = 0\\n        for age in range(15, 121):\\n            if buckets[age] == 0:\\n                continue\\n            cur_requests = prefix[age] - prefix[age // 2 + 7]\\n            requests += buckets[age] * cur_requests - buckets[age]\\n        return requests\\n\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        return FriendRequest2().numOfRequests(ages)\\n```\n```Java []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        for(int a : ages) {\\n            numInAge[a]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            sumInAge[i] = numInAge[i] + sumInAge[i-1];\\n        }\\n        for(int i = 15; i <= 120; i++) {\\n            if (numInAge[i] == 0)   continue;\\n            int c = sumInAge[i] - sumInAge[i/2 + 7];\\n            res += c * numInAge[i] - numInAge[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230757,
                "title": "golang-two-pointers",
                "content": "It is a straightforward solution but took a bit of time to get it right for people with same ages.\\n\\n```go\\nfunc numFriendRequests(ages []int) int {\\n  // Let\\'s sort the ages in ascendig order\\n  sort.Ints(ages)\\n  counts := make(map[int]int)\\n  // Keep track of the first occurrence of each age in the sorted order\\n  // so that we can get the number of people that are below the current age\\n  // and the other same age people that we can send friend requests to.\\n  first := make(map[int]int)\\n  for i := 0; i < len(ages); i++ {\\n    counts[ages[i]]++\\n    if _, ok := first[ages[i]]; !ok {\\n      first[ages[i]] = i\\n    }\\n  }\\n  // We\\'re going to use a two pointers approach. Left is updated to point to the\\n  // person with the minimum age that follows the requirements for the current person.\\n  // Then the number of people the current person can send friend requests to is the\\n  // number of people between pointed by left and current person (excluding)\\n  left := 0\\n  var res int\\n  for right := 0; right < len(ages); right++ {\\n    minAge := float64(ages[right]) * 0.5 + 7.0\\n    for left < right && float64(ages[left]) <= minAge {\\n      left++\\n    }\\n    // left can move forward when we have the same age repeated\\n    res += first[ages[right]] - min(first[ages[right]], left)\\n    if float64(ages[right]) > minAge {\\n      res += counts[ages[right]]-1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```go\\nfunc numFriendRequests(ages []int) int {\\n  // Let\\'s sort the ages in ascendig order\\n  sort.Ints(ages)\\n  counts := make(map[int]int)\\n  // Keep track of the first occurrence of each age in the sorted order\\n  // so that we can get the number of people that are below the current age\\n  // and the other same age people that we can send friend requests to.\\n  first := make(map[int]int)\\n  for i := 0; i < len(ages); i++ {\\n    counts[ages[i]]++\\n    if _, ok := first[ages[i]]; !ok {\\n      first[ages[i]] = i\\n    }\\n  }\\n  // We\\'re going to use a two pointers approach. Left is updated to point to the\\n  // person with the minimum age that follows the requirements for the current person.\\n  // Then the number of people the current person can send friend requests to is the\\n  // number of people between pointed by left and current person (excluding)\\n  left := 0\\n  var res int\\n  for right := 0; right < len(ages); right++ {\\n    minAge := float64(ages[right]) * 0.5 + 7.0\\n    for left < right && float64(ages[left]) <= minAge {\\n      left++\\n    }\\n    // left can move forward when we have the same age repeated\\n    res += first[ages[right]] - min(first[ages[right]], left)\\n    if float64(ages[right]) > minAge {\\n      res += counts[ages[right]]-1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648164,
                "title": "cpp-easy-solution",
                "content": "Any person of age x will send request to every person of age from 0.5x + 7(not including) to x(including). The minus sign is because we are also adding the person itself and acccording to the question the person himself cannot send request to himself. \\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int* temp = new int[122]{0};\\n        for (int i = 0;i <  ages.size();i++)\\n        {\\n            temp[ages[i]]++;\\n        }\\n        \\n        for (int i = 1;i < 122;i++)\\n        {\\n            temp[i] = temp[i] + temp[i - 1];\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0;i < ages.size(); i++)\\n        {\\n            if (ages[i] > 14)\\n                res += (temp[ages[i]] - temp[(int)(0.5*ages[i]) + 7]) - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int* temp = new int[122]{0};\\n        for (int i = 0;i <  ages.size();i++)\\n        {\\n            temp[ages[i]]++;\\n        }\\n        \\n        for (int i = 1;i < 122;i++)\\n        {\\n            temp[i] = temp[i] + temp[i - 1];\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0;i < ages.size(); i++)\\n        {\\n            if (ages[i] > 14)\\n                res += (temp[ages[i]] - temp[(int)(0.5*ages[i]) + 7]) - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505228,
                "title": "python-time-o-max-n-120-space-o-1-prefixsum-and-numbersort-solution",
                "content": "The ages is restricted to be between 1 and 120 so we can make an array with 120 slots to count all persons with a certain age.\\n\\nWe can then compute the prefix sum for every age by passing through the 120-slot array one time and summing up.\\n\\nNow we can compute all the values needed for our result by differencing prefix sums.\\n\\nALSO: The last restriction (age[y] > 100 && age[x] < 100) can be ignored, as it is covered by age[y] > age[x].\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \\n        # make a number sort\\n        sort_ages = [0]*120\\n        \\n        # sort the ages\\n        for age in ages:\\n            sort_ages[age-1] += 1\\n            \\n        # make prefix sum\\n        for age in range(2,121):\\n            sort_ages[age-1] = sort_ages[age-1] + sort_ages[age-2]\\n            \\n        # make a sliding window through the array\\n        result = 0\\n        for age in ages:\\n            \\n            # these ages fall out due to the first restriction\\n            # 14//2 + 7 = 14 -> 14 <= 14 -> falls out\\n            if age <= 14:\\n                continue\\n            \\n            # calculate the index of persons we don\\'t want\\n            dox = age//2 + 7\\n            \\n            # this is the amount of persons younger than ourselves\\n            # but older than age//2 + 7\\n            result += sort_ages[age-2] - sort_ages[dox-1]\\n            \\n            # this is the amount of persons the same age as us but\\n            # without ourselves as we don\\'t send a request to ourself\\n            result += (sort_ages[age-1] - sort_ages[age-2]) - 1\\n        \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \\n        # make a number sort\\n        sort_ages = [0]*120\\n        \\n        # sort the ages\\n        for age in ages:\\n            sort_ages[age-1] += 1\\n            \\n        # make prefix sum\\n        for age in range(2,121):\\n            sort_ages[age-1] = sort_ages[age-1] + sort_ages[age-2]\\n            \\n        # make a sliding window through the array\\n        result = 0\\n        for age in ages:\\n            \\n            # these ages fall out due to the first restriction\\n            # 14//2 + 7 = 14 -> 14 <= 14 -> falls out\\n            if age <= 14:\\n                continue\\n            \\n            # calculate the index of persons we don\\'t want\\n            dox = age//2 + 7\\n            \\n            # this is the amount of persons younger than ourselves\\n            # but older than age//2 + 7\\n            result += sort_ages[age-2] - sort_ages[dox-1]\\n            \\n            # this is the amount of persons the same age as us but\\n            # without ourselves as we don\\'t send a request to ourself\\n            result += (sort_ages[age-1] - sort_ages[age-2]) - 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469842,
                "title": "simple-c-solution-binary-search",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int ans = 0;\\n        // 2 check \\n        // 1. ->  y > x/2 + 7 ;\\n        // 2. ->  y <= x;\\n        for(int i=0;i<ages.size();i++){\\n            int x = ages[i];\\n            int y = x/2 + 7;\\n\\t\\t\\t// condition check\\n            if(y >= x) continue;\\n            auto it = upper_bound(ages.begin() , ages.end() , y) - ages.begin();\\n            auto it2 = upper_bound(ages.begin(), ages.end() , x) - ages.begin();\\n            if(it < i){ans += (i - it);}\\n            if(it2 > i) ans += (it2 - i - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int ans = 0;\\n        // 2 check \\n        // 1. ->  y > x/2 + 7 ;\\n        // 2. ->  y <= x;\\n        for(int i=0;i<ages.size();i++){\\n            int x = ages[i];\\n            int y = x/2 + 7;\\n\\t\\t\\t// condition check\\n            if(y >= x) continue;\\n            auto it = upper_bound(ages.begin() , ages.end() , y) - ages.begin();\\n            auto it2 = upper_bound(ages.begin(), ages.end() , x) - ages.begin();\\n            if(it < i){ans += (i - it);}\\n            if(it2 > i) ans += (it2 - i - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290506,
                "title": "python-counter-simple-iterative-approach-using-ifs",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ct = {}     # counter\\n        for n in ages:\\n            if n not in ct:\\n                ct[n] = ages.count(n)\\n        mreq = 0\\n        for x in ct:\\n            for y in ct:\\n                if y <= (0.5*x) + 7 or y > x or (y > 100 and x < 100):\\n                    continue\\n                if x == y:\\n                    mreq += ct[x] * (ct[x] - 1)     # send reqs except itself\\n                else:\\n                    mreq += ct[x] * ct[y]                \\n        return mreq\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ct = {}     # counter\\n        for n in ages:\\n            if n not in ct:\\n                ct[n] = ages.count(n)\\n        mreq = 0\\n        for x in ct:\\n            for y in ct:\\n                if y <= (0.5*x) + 7 or y > x or (y > 100 and x < 100):\\n                    continue\\n                if x == y:\\n                    mreq += ct[x] * (ct[x] - 1)     # send reqs except itself\\n                else:\\n                    mreq += ct[x] * ct[y]                \\n        return mreq\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257939,
                "title": "simple-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            idx1 = bisect.bisect(ages, a)\\n            idx2 = bisect.bisect(ages, 0.5 * a + 7)\\n            cnt += max(0, idx1 - idx2 - 1) \\n        return cnt\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            idx1 = bisect.bisect(ages, a)\\n            idx2 = bisect.bisect(ages, 0.5 * a + 7)\\n            cnt += max(0, idx1 - idx2 - 1) \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166214,
                "title": "well-explained-c-easy-code-don-t-worry-have-fun",
                "content": "# intution:-\\nThese are ***the 3 conditions which must not follow to if we want to send a friend request according to the question.***\\n```\\nage[y] <= 0.5 * age[x] + 7\\nage[y] > age[x]\\nage[y] > 100 && age[x] < 100\\n```\\n\\nThink of something, yes take all the cases diffently what must not occur\\n  after thinking you know we need to do sorting because:-\\n  1. age[y] <= age[x]  so to do so  do sorting \\n  2.     age[y] > 100 than we must find age[x] >= 100  **** hint no.2****\\n  3.     age[x] must be =>     age[x] < 2*(age[y]-7)   so to find this index we need to apply lower_bound function **(so do sorting** \\n\\n---------age[y]-------------------------age[x]-------- -----    sorted array\\n            index = i                                  index = j\\n\\nso all the element which follow age[y] <= age[x]  it will be    j-i-1\\n\\nLet\\'s talk about why we need map here\\nso take example no.1 =>     *[16,16]*     each of them can send friend request to each other. but we have sorted the array so we need their first occurence that\\'s why we are using map.\\n\\n**second condition will be automatically followed no need to worrrrrry because of sorting**\\n\\n**Here is the code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        sort(ages.begin(), ages.end());\\n        \\n        \\n        unordered_map<int,int> mp;\\n        for(int i = 0; i < ages.size(); i++) {\\n            if(!mp.count(ages[i])) mp[ages[i]] = i;\\n        }\\n        \\n        \\n        for(int i = 0; i < ages.size(); i++) {\\n            int x= lower_bound(ages.begin(), ages.end(), 2*(ages[i]-7)) - ages.begin();\\n            if(x <= i) continue;\\n            ans += x-mp[ages[i]]-1; \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nT.C. => O(nlonn)   n = ages.size()\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nage[y] <= 0.5 * age[x] + 7\\nage[y] > age[x]\\nage[y] > 100 && age[x] < 100\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        sort(ages.begin(), ages.end());\\n        \\n        \\n        unordered_map<int,int> mp;\\n        for(int i = 0; i < ages.size(); i++) {\\n            if(!mp.count(ages[i])) mp[ages[i]] = i;\\n        }\\n        \\n        \\n        for(int i = 0; i < ages.size(); i++) {\\n            int x= lower_bound(ages.begin(), ages.end(), 2*(ages[i]-7)) - ages.begin();\\n            if(x <= i) continue;\\n            ans += x-mp[ages[i]]-1; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970058,
                "title": "the-question-is-wrong-the-100-years-condition-should-be-reversed",
                "content": "This question comes from Facebook tech screening: https://leetcode.com/discuss/interview-question/469422/facebook-phone-count-all-friend-requests\\n\\nBut note that in there it says \\n> A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n\\nwhereas in Leetcode, it says\\n> \"A Person x will not send a friend request to a person y if age[y] > 100 && age[x] < 100\". \\n\\nWhich is the opposite. So much so, that Leetcode also says that: \\n> \"A Person x will not send a friend request to a person y if age[y] > age[x]\"\\n\\nwhich is a generalization of the previous one. This makes this solution pass:\\n\\n```\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int invites = 0;\\n        for (int x = ages.length - 1 ; x >= 0 ; x--) {\\n            boolean shouldContinue = true;\\n            for (int y = x-1 ; y >= 0 && shouldContinue ; y--) {\\n                if (ages[y] <= 0.5 * ages[x] + 7) {\\n                    shouldContinue = false;\\n                    break;\\n                }\\n                if (ages[x] == ages[y]) invites++;\\n                invites++;\\n            }\\n        }\\n        return invites;\\n    }\\n```\\n\\neven if it\\'s totally ignoring the 100 years condition.",
                "solutionTags": [],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int invites = 0;\\n        for (int x = ages.length - 1 ; x >= 0 ; x--) {\\n            boolean shouldContinue = true;\\n            for (int y = x-1 ; y >= 0 && shouldContinue ; y--) {\\n                if (ages[y] <= 0.5 * ages[x] + 7) {\\n                    shouldContinue = false;\\n                    break;\\n                }\\n                if (ages[x] == ages[y]) invites++;\\n                invites++;\\n            }\\n        }\\n        return invites;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958434,
                "title": "c-set-counting-prefix-sum-binary-search-solution-o-n-logn",
                "content": "Runtime: 70 ms, faster than 63.12% of C++ online submissions for Friends Of Appropriate Ages.\\nMemory Usage: 37.7 MB, less than 6.74% of C++ online submissions for Friends Of Appropriate Ages.\\n\\n\\n```\\n1. Sort ages on descending order and track all unique ages\\n2. Count the frequency of ages and do prefix sum on frequency count array on descending order\\n3. Loop through age array in descending order and check if current age > target => age/2 + 7\\n4. Then do binary search on right elements and find last index where age > target and get the count of\\nages until last index using prefix sum array. Total request  => current age count * other valid age count\\n5. In case of same age meet condition age > target request count => current age count * (current age count -1)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& persons) {\\n        \\n        // count freq of the ages\\n        int freq[121] = {0};\\n        \\n        // track the descending order of age\\n        set<int,greater<int>>uniqueAges;\\n        \\n        int n = persons.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            uniqueAges.insert(persons[i]);\\n            freq[persons[i]]++;\\n        }\\n        \\n        // add unique age from set in descending order and update the prefix sum larger to smaller age\\n        vector<int>ages;\\n        for(auto iter=uniqueAges.begin();iter!=uniqueAges.end();iter++)\\n        {\\n            ages.push_back(*iter);\\n            if(next(iter)!=uniqueAges.end())\\n                freq[*next(iter)] += freq[*iter];\\n        }\\n\\n        // total request count\\n        int count = 0;\\n        \\n        int fcount; // current age freq\\n\\n        int left,right,mid,target,index;\\n        int ageLen = ages.size();\\n        \\n        for(int i=0;i<ageLen;i++)\\n        {\\n            // get current age count from prefix sum \\n            fcount = freq[ages[i]] - (i > 0 ? freq[ages[i-1]] : 0);\\n            \\n            // target age for sending request\\n            target = ages[i]/2 + 7;\\n             \\n            // if current age meets condition then search further\\n            if(ages[i] > target)\\n            {\\n                // send same age request count => n * (n-1) \\n                // as every n person can send request to other n-1 persons \\n                count += (fcount-1) * fcount;\\n                \\n                // check if next age meets condition then do binary search in the right elements\\n                if(i+1 < ageLen && ages[i+1] > target)\\n                {\\n                    left = i+1;\\n                    right = ages.size()-1;\\n                    index = i+1;\\n                    \\n                    // find the last index which meets the condition\\n                    while(left <= right)\\n                    {\\n                        mid = left + (right-left)/2;\\n\\n                        if(ages[mid] > target)left=mid+1,index=mid;\\n                        else right = mid-1,index=mid-1;\\n                    }\\n\\n                    // get freq count K from next of current age to last index age using prefix sum array\\n                    // then request count => fcount * K\\n                    if(index< ageLen && ages[index] > target)\\n                        count+= fcount * (freq[ages[index]] - freq[ages[i]]);                    \\n                }\\n            }    \\n        }\\n        \\n        return count;\\n            \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n1. Sort ages on descending order and track all unique ages\\n2. Count the frequency of ages and do prefix sum on frequency count array on descending order\\n3. Loop through age array in descending order and check if current age > target => age/2 + 7\\n4. Then do binary search on right elements and find last index where age > target and get the count of\\nages until last index using prefix sum array. Total request  => current age count * other valid age count\\n5. In case of same age meet condition age > target request count => current age count * (current age count -1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& persons) {\\n        \\n        // count freq of the ages\\n        int freq[121] = {0};\\n        \\n        // track the descending order of age\\n        set<int,greater<int>>uniqueAges;\\n        \\n        int n = persons.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            uniqueAges.insert(persons[i]);\\n            freq[persons[i]]++;\\n        }\\n        \\n        // add unique age from set in descending order and update the prefix sum larger to smaller age\\n        vector<int>ages;\\n        for(auto iter=uniqueAges.begin();iter!=uniqueAges.end();iter++)\\n        {\\n            ages.push_back(*iter);\\n            if(next(iter)!=uniqueAges.end())\\n                freq[*next(iter)] += freq[*iter];\\n        }\\n\\n        // total request count\\n        int count = 0;\\n        \\n        int fcount; // current age freq\\n\\n        int left,right,mid,target,index;\\n        int ageLen = ages.size();\\n        \\n        for(int i=0;i<ageLen;i++)\\n        {\\n            // get current age count from prefix sum \\n            fcount = freq[ages[i]] - (i > 0 ? freq[ages[i-1]] : 0);\\n            \\n            // target age for sending request\\n            target = ages[i]/2 + 7;\\n             \\n            // if current age meets condition then search further\\n            if(ages[i] > target)\\n            {\\n                // send same age request count => n * (n-1) \\n                // as every n person can send request to other n-1 persons \\n                count += (fcount-1) * fcount;\\n                \\n                // check if next age meets condition then do binary search in the right elements\\n                if(i+1 < ageLen && ages[i+1] > target)\\n                {\\n                    left = i+1;\\n                    right = ages.size()-1;\\n                    index = i+1;\\n                    \\n                    // find the last index which meets the condition\\n                    while(left <= right)\\n                    {\\n                        mid = left + (right-left)/2;\\n\\n                        if(ages[mid] > target)left=mid+1,index=mid;\\n                        else right = mid-1,index=mid-1;\\n                    }\\n\\n                    // get freq count K from next of current age to last index age using prefix sum array\\n                    // then request count => fcount * K\\n                    if(index< ageLen && ages[index] > target)\\n                        count+= fcount * (freq[ages[index]] - freq[ages[i]]);                    \\n                }\\n            }    \\n        }\\n        \\n        return count;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900650,
                "title": "a-c-solution-using-binary-search",
                "content": "First, we need to analyze these rules given from the problem. If any condition happens, x **won\\'t** send the friend request to y.\\n1. `age[y] <= 0.5 * age[x] + 7`\\n2. `age[y] > age[x]`\\n3. `age[y] > 100 && age[x] < 100`\\n\\nRule 2 is easy to understand. From this rule, we know that x may send the request to y if `y <= x`. And from rule 1, we know that x may send the request to y if `y > 0.5x + 7`. Based on rule 1 and 2, we can get the range of ages of y which fits x\\'s favor: `(0.5x + 7, x]`. \\n\\nNow, let\\'s deal with rule 3. And you will see that rule 3 never happens because in rule 3, y is greater than x which is out of the range of x\\' favor. So, we just need to focus on `0.5x + 7 < y <= x`.\\n\\nTime complexity : sorting is O(nlog(n)). Per-user checking is O(n). Binary search is O(log(n)). Overall will be O(nlog(n)).\\nSpace complexity: O(1)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        int l, u;\\n        \\n\\t\\t// Sorting ages, and then we can do binary search.\\n        sort(ages.begin(), ages.end());\\n        \\n\\t\\t// Find the range of each user.\\n        for (int i = 0; i < ages.size(); ++i) {\\n            \\n\\t\\t\\t// 0.5x + 7 may be greater than x. We can skip this loop if it happens.\\n            if (0.5 * ages[i] + 7 >= ages[i]) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// Search the smallest y in the range (0.5x + 7, x].\\n\\t\\t\\t// A trick is that passing right hand side to limit the searching range\\n\\t\\t\\t// which can improve its speed a little.\\n            l = searchLowerBound(ages, 0.5 * ages[i] + 7, i);\\n            \\n\\t\\t\\t// Search the largest y. Because we need to consider the duplicated values of x.\\n\\t\\t\\t// The index of largest y may be greater than i.\\n\\t\\t\\t// Minusing 1 at the end is to exclude self.\\n            u = upper_bound(\\n                ages.begin() + i, ages.end(), ages[i]) - ages.begin() - 1;\\n            \\n            ans += u - l;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n\\t// This function searchs the index of the smallest value greater than `val`\\n    int searchLowerBound(vector<int>& ages, int val, int r) {\\n        int l = 0;\\n        \\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            \\n            if (ages[m] <= val) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        int l, u;\\n        \\n\\t\\t// Sorting ages, and then we can do binary search.\\n        sort(ages.begin(), ages.end());\\n        \\n\\t\\t// Find the range of each user.\\n        for (int i = 0; i < ages.size(); ++i) {\\n            \\n\\t\\t\\t// 0.5x + 7 may be greater than x. We can skip this loop if it happens.\\n            if (0.5 * ages[i] + 7 >= ages[i]) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// Search the smallest y in the range (0.5x + 7, x].\\n\\t\\t\\t// A trick is that passing right hand side to limit the searching range\\n\\t\\t\\t// which can improve its speed a little.\\n            l = searchLowerBound(ages, 0.5 * ages[i] + 7, i);\\n            \\n\\t\\t\\t// Search the largest y. Because we need to consider the duplicated values of x.\\n\\t\\t\\t// The index of largest y may be greater than i.\\n\\t\\t\\t// Minusing 1 at the end is to exclude self.\\n            u = upper_bound(\\n                ages.begin() + i, ages.end(), ages[i]) - ages.begin() - 1;\\n            \\n            ans += u - l;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n\\t// This function searchs the index of the smallest value greater than `val`\\n    int searchLowerBound(vector<int>& ages, int val, int r) {\\n        int l = 0;\\n        \\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            \\n            if (ages[m] <= val) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876627,
                "title": "python-o-n-faster-99-5-cumulative-sum-and-age-buckets",
                "content": "I have seen a few solutions that do a sum in the main loop over the age buckets. To avoid this, we can precalculate the cumulative sums and use them instead to make the main logic loop highly efficient.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # in a sense: \"bucket sort\"\\n        ageMax = max(ages)\\n        ageBuckets = [0]*(ageMax+1)\\n        for age in ages:\\n            ageBuckets[age] += 1\\n        \\n        # build cumulative sum\\n        ageCum = [ageBuckets[0]]*(ageMax+1)\\n        for i in range(1,len(ageBuckets)):\\n            ageCum[i] = ageCum[i-1] + ageBuckets[i]\\n            \\n        # main logic\\n        ans = 0\\n        for age in range(1,len(ageBuckets)):\\n            if ageBuckets[age]:\\n                k = int(age * 0.5 + 7)\\n                if k < age:\\n                    ans += ageBuckets[age] * (ageCum[age-1] - ageCum[k])\\n                if age > k:\\n                    ans += ageBuckets[age]*(ageBuckets[age]-1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # in a sense: \"bucket sort\"\\n        ageMax = max(ages)\\n        ageBuckets = [0]*(ageMax+1)\\n        for age in ages:\\n            ageBuckets[age] += 1\\n        \\n        # build cumulative sum\\n        ageCum = [ageBuckets[0]]*(ageMax+1)\\n        for i in range(1,len(ageBuckets)):\\n            ageCum[i] = ageCum[i-1] + ageBuckets[i]\\n            \\n        # main logic\\n        ans = 0\\n        for age in range(1,len(ageBuckets)):\\n            if ageBuckets[age]:\\n                k = int(age * 0.5 + 7)\\n                if k < age:\\n                    ans += ageBuckets[age] * (ageCum[age-1] - ageCum[k])\\n                if age > k:\\n                    ans += ageBuckets[age]*(ageBuckets[age]-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853310,
                "title": "python-o-nlogn-bisect",
                "content": "There are cleaner implementations that include all ages when bisecting. This takes a slightly different approach and instead dedupes all ages and keeps counts.\\n```\\nimport bisect\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        new_ages = []\\n        counts = []\\n        for a in ages:\\n            if new_ages and new_ages[-1] == a:\\n                counts[-1] += 1\\n            else:\\n                new_ages.append(a)\\n                counts.append(1)\\n        prefix = [0]\\n        for c in counts:\\n            prefix.append(prefix[-1]+c)\\n        ages = new_ages\\n        total_requests = 0\\n        for i, age in enumerate(ages):\\n            min_age = age / 2 + 7\\n            j = bisect.bisect_right(ages, min_age)\\n            # we can\\'t friend someone older than us\\n            if j > i:\\n                continue\\n            # get number of people younger than `age` multiplied by number of people with `age`\\n            total_requests += (prefix[i]-prefix[j])*counts[i]\\n        # for any ages with more than 1 person, sum all possible requests n*(n-1)\\n        # but make sure that the age requirement is met (which is really only for young kids)\\n        # 6 < (6/2+7=10)\\n        # 16 > (16/2+7=15)\\n        total_requests += sum(n*(n-1) for a, n in zip(ages, counts) if a > (a / 2 + 7))\\n        return total_requests\\n```\\n\\nHere\\'s a cleaner solution:\\n```\\nimport bisect\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        counts = Counter(ages)\\n        total = 0\\n        for age in counts:\\n            min_age = age / 2 + 7\\n            left = bisect.bisect_right(ages, min_age)\\n            right = bisect.bisect_right(ages, age)\\n            total += max(right - left - 1, 0)*counts[age]\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        new_ages = []\\n        counts = []\\n        for a in ages:\\n            if new_ages and new_ages[-1] == a:\\n                counts[-1] += 1\\n            else:\\n                new_ages.append(a)\\n                counts.append(1)\\n        prefix = [0]\\n        for c in counts:\\n            prefix.append(prefix[-1]+c)\\n        ages = new_ages\\n        total_requests = 0\\n        for i, age in enumerate(ages):\\n            min_age = age / 2 + 7\\n            j = bisect.bisect_right(ages, min_age)\\n            # we can\\'t friend someone older than us\\n            if j > i:\\n                continue\\n            # get number of people younger than `age` multiplied by number of people with `age`\\n            total_requests += (prefix[i]-prefix[j])*counts[i]\\n        # for any ages with more than 1 person, sum all possible requests n*(n-1)\\n        # but make sure that the age requirement is met (which is really only for young kids)\\n        # 6 < (6/2+7=10)\\n        # 16 > (16/2+7=15)\\n        total_requests += sum(n*(n-1) for a, n in zip(ages, counts) if a > (a / 2 + 7))\\n        return total_requests\\n```\n```\\nimport bisect\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        counts = Counter(ages)\\n        total = 0\\n        for age in counts:\\n            min_age = age / 2 + 7\\n            left = bisect.bisect_right(ages, min_age)\\n            right = bisect.bisect_right(ages, age)\\n            total += max(right - left - 1, 0)*counts[age]\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847580,
                "title": "python-3-two-solutions",
                "content": "sorting + deque solution\\nO(nlogn) time\\nO(n) space\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        deque = collections.deque()\\n        ages.sort(reverse=True)\\n        res = 0\\n        curSame = 0\\n        \\n        for i, age in enumerate(ages):\\n            if i and age >= 15 and age == ages[i-1]:\\n                curSame += 1\\n            else:\\n                curSame = 0\\n\\n            while deque and age <= deque[0]:\\n                deque.popleft()\\n                \\n            res += len(deque) + curSame\\n            deque.append(0.5*age + 7)\\n        \\n        return res\\n```\\nprefix sum solution\\nO(n) time\\nO(1) space\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        prefixSum = collections.Counter(ages)\\n        for i in range(2, 121):\\n            prefixSum[i] += prefixSum[i-1]\\n        \\n        res = 0\\n        for age in ages:\\n            left = int(0.5*age + 7)\\n            if age > left:\\n                res += prefixSum[age] - prefixSum[left] - 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        deque = collections.deque()\\n        ages.sort(reverse=True)\\n        res = 0\\n        curSame = 0\\n        \\n        for i, age in enumerate(ages):\\n            if i and age >= 15 and age == ages[i-1]:\\n                curSame += 1\\n            else:\\n                curSame = 0\\n\\n            while deque and age <= deque[0]:\\n                deque.popleft()\\n                \\n            res += len(deque) + curSame\\n            deque.append(0.5*age + 7)\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        prefixSum = collections.Counter(ages)\\n        for i in range(2, 121):\\n            prefixSum[i] += prefixSum[i-1]\\n        \\n        res = 0\\n        for age in ages:\\n            left = int(0.5*age + 7)\\n            if age > left:\\n                res += prefixSum[age] - prefixSum[left] - 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831668,
                "title": "java-solution-with-prefixsum-o-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        int[] prefixSum = new int[121];\\n        for (int age : ages) {\\n            prefixSum[age]++;\\n        }\\n        for (int i = 1; i < prefixSum.length; i++) {\\n            prefixSum[i] += prefixSum[i-1];\\n        }\\n        for (int age : ages) {\\n            int left = (int)(0.5 * age) + 7;\\n            if (left < age) {\\n                ans += prefixSum[age] - prefixSum[left] - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nThe last for loop could be optimized.\\n```\\nfor (int age = 1; age < 121; age++) {\\n\\tint left = (int)(0.5 * age) + 7;\\n\\tif (left < age) {\\n\\t\\tans += (prefixSum[age] - prefixSum[left] - 1) * (prefixSum[age] - prefixSum[age - 1]);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        int[] prefixSum = new int[121];\\n        for (int age : ages) {\\n            prefixSum[age]++;\\n        }\\n        for (int i = 1; i < prefixSum.length; i++) {\\n            prefixSum[i] += prefixSum[i-1];\\n        }\\n        for (int age : ages) {\\n            int left = (int)(0.5 * age) + 7;\\n            if (left < age) {\\n                ans += prefixSum[age] - prefixSum[left] - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nfor (int age = 1; age < 121; age++) {\\n\\tint left = (int)(0.5 * age) + 7;\\n\\tif (left < age) {\\n\\t\\tans += (prefixSum[age] - prefixSum[left] - 1) * (prefixSum[age] - prefixSum[age - 1]);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734617,
                "title": "c-short",
                "content": "Using @votrubac solution\\nTime: O(n)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121,0);\\n        for(int x : ages) {\\n            count[x]++;\\n        }\\n        int ans = 0;\\n        for(int i = 15;i<121;i++) {\\n            for(int j = 0.5*i + 8;j<=i;j++) {\\n                ans+= count[j] * (count[i]- (i==j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121,0);\\n        for(int x : ages) {\\n            count[x]++;\\n        }\\n        int ans = 0;\\n        for(int i = 15;i<121;i++) {\\n            for(int j = 0.5*i + 8;j<=i;j++) {\\n                ans+= count[j] * (count[i]- (i==j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698046,
                "title": "python-two-pointers-after-sorting",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        if not ages:\\n            return 0\\n        \\n        ages.sort()\\n        \\n        count = 0\\n        left, right = 0, 0\\n        for age in ages:\\n            while left < len(ages) and ages[left] <= 0.5 * age + 7:\\n                left += 1\\n            while right < len(ages) and ages[right] <= age:\\n                right += 1\\n            if right - 1 >= left:\\n                count += right - left - 1\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        if not ages:\\n            return 0\\n        \\n        ages.sort()\\n        \\n        count = 0\\n        left, right = 0, 0\\n        for age in ages:\\n            while left < len(ages) and ages[left] <= 0.5 * age + 7:\\n                left += 1\\n            while right < len(ages) and ages[right] <= age:\\n                right += 1\\n            if right - 1 >= left:\\n                count += right - left - 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690666,
                "title": "ruby-o-n-and-o-1-space",
                "content": "The difficult part of this problem is avoiding the easy TLE. The first solution bellow results in it:\\n\\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    ages.each.with_index do |age1, idx1|\\n        ages.each.with_index do |age2, idx2|\\n            next if idx1 == idx2\\n            count += 1 if possible_friend(age1, age2)\\n        end\\n    end\\n    count\\nend\\n\\ndef possible_friend(x, y)\\n    !((y <= 0.5*x + 7) || (y > x) || (y > 100 && x < 100))\\nend\\n```\\n\\nThere are some improvements that may be performed:\\n- as only 0 <= age <= 120 is valid, every number doesn\\'t need to be verified against every other element in the array. Counting how many occurrences of every number happens and then verifying it against every other number turns the total solution from O(n^2) into O(n + 121 * 121) = O(n). Space is O(121) = O(1);\\n\\n- instead of comparing every number with every other number, simply add to the total number of friend requests the product of count(age X) * count(age Y) for (age Y) that is valid. If age Y == age X, substract age X from the total number of friend requests. That is still a O(n) for time and O(1) for space,;\\n\\nBear in mind that the restriction age[y] > 100 && age[x] < 100 does not mean anything, as it is already taken care of by age[y] > age[x]. The other restriction, age[x] * 0.5 + 7 >= age[y] results in age[x] / 2 + 8 < age[y] for a friend request to happen.\\n\\nThe final solution is:\\n\\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    age_count = Array.new(121) { 0 }\\n    ages.each { |age| age_count[age] += 1 }\\n    age_count.each.with_index do |curr_count, age|\\n        intervals = [age / 2 + 8, age]\\n        for i in intervals[0]..intervals[1]\\n            count += (age_count[i] * curr_count)\\n            count -= curr_count if i == age\\n        end\\n    end\\n    count\\nend\\n```\\n\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    ages.each.with_index do |age1, idx1|\\n        ages.each.with_index do |age2, idx2|\\n            next if idx1 == idx2\\n            count += 1 if possible_friend(age1, age2)\\n        end\\n    end\\n    count\\nend\\n\\ndef possible_friend(x, y)\\n    !((y <= 0.5*x + 7) || (y > x) || (y > 100 && x < 100))\\nend\\n```\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    age_count = Array.new(121) { 0 }\\n    ages.each { |age| age_count[age] += 1 }\\n    age_count.each.with_index do |curr_count, age|\\n        intervals = [age / 2 + 8, age]\\n        for i in intervals[0]..intervals[1]\\n            count += (age_count[i] * curr_count)\\n            count -= curr_count if i == age\\n        end\\n    end\\n    count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1686736,
                "title": "python-o-n-solution-beats-90-of-the-solution",
                "content": "Might be a bit redundant code, but I came up with this solution.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646281,
                "title": "python-easy-solution-best-approach",
                "content": "**Condition 1:**  If your age is different from the other age\\n*E.g.* 16, 15, 15 then 15 ->16 and 15 ->16\\nie 2*1 which is **xCount** * **yCount**.\\n\\n**Condition 2:** If your age is the same.\\n*E.g.* 16, 16 then 16 <-> 16 *i.e.* 2 which is **xCount** * **(xCount-1)** or **yCount** * **(yCount-1)**\\n\\n\\tclass Solution:\\n\\t\\tdef numFriendRequests(self, ages: List[int]) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tages = Counter(ages)\\n\\t\\t\\tfor x in ages:\\n\\t\\t\\t\\txCount = ages[x]\\n\\t\\t\\t\\tfor y in ages:\\n\\t\\t\\t\\t\\tif not (y <= 0.5*x+7 or y > x):\\n\\t\\t\\t\\t\\t\\tyCount = ages[y]\\n\\t\\t\\t\\t\\t\\tif x != y:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*yCount\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*(xCount-1)\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "**Condition 1:**  If your age is different from the other age\\n*E.g.* 16, 15, 15 then 15 ->16 and 15 ->16\\nie 2*1 which is **xCount** * **yCount**.\\n\\n**Condition 2:** If your age is the same.\\n*E.g.* 16, 16 then 16 <-> 16 *i.e.* 2 which is **xCount** * **(xCount-1)** or **yCount** * **(yCount-1)**\\n\\n\\tclass Solution:\\n\\t\\tdef numFriendRequests(self, ages: List[int]) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tages = Counter(ages)\\n\\t\\t\\tfor x in ages:\\n\\t\\t\\t\\txCount = ages[x]\\n\\t\\t\\t\\tfor y in ages:\\n\\t\\t\\t\\t\\tif not (y <= 0.5*x+7 or y > x):\\n\\t\\t\\t\\t\\t\\tyCount = ages[y]\\n\\t\\t\\t\\t\\t\\tif x != y:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*yCount\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*(xCount-1)\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 1560590,
                "title": "simple-to-understand-using-map-binary-search-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\nIn this solution, we sort the ages and use a map that keeps track of the ages, and the total friend request count that age can recieve.\\n\\nBinary search is used to get the age range in the array that satisfies the friend request conditions.\\n\\n```\\npublic class Solution {\\n    public int NumFriendRequests(int[] ages) {\\n        var result = 0;\\n        \\n        // Sort ages\\n        Array.Sort(ages);\\n        \\n        // Keep track of results calculated\\n        var seen = new Dictionary<int, int>();\\n        \\n        // Iterate array backwards\\n        for (int index = ages.Length - 1; index >= 0; --index) { \\n            // Check if we already calculated result for age\\n            if (!seen.ContainsKey(ages[index])) {\\n                // Binary search\\n                var lo = 0;\\n                var hi = index;\\n                while (lo < hi) {\\n                    var mid = lo + (hi - lo) / 2;\\n\\n                    // Check if friends can be made in this range\\n                    if (!CanFriend(ages[index], ages[mid])) {\\n                        lo = mid + 1;\\n                    } else {\\n                        hi = mid;\\n                    }\\n                }\\n                // Get distance between index and hi. This is the friend count for the age\\n                seen[ages[index]] = index - hi; \\n            }\\n            // Update result count\\n            result += seen[ages[index]];\\n        }        \\n        return result;\\n    }\\n    \\n    private bool CanFriend(int x, int y) {\\n        return !((y > x) || (y > 100 && x < 100) || (y <= 0.5 * x + 7));\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumFriendRequests(int[] ages) {\\n        var result = 0;\\n        \\n        // Sort ages\\n        Array.Sort(ages);\\n        \\n        // Keep track of results calculated\\n        var seen = new Dictionary<int, int>();\\n        \\n        // Iterate array backwards\\n        for (int index = ages.Length - 1; index >= 0; --index) { \\n            // Check if we already calculated result for age\\n            if (!seen.ContainsKey(ages[index])) {\\n                // Binary search\\n                var lo = 0;\\n                var hi = index;\\n                while (lo < hi) {\\n                    var mid = lo + (hi - lo) / 2;\\n\\n                    // Check if friends can be made in this range\\n                    if (!CanFriend(ages[index], ages[mid])) {\\n                        lo = mid + 1;\\n                    } else {\\n                        hi = mid;\\n                    }\\n                }\\n                // Get distance between index and hi. This is the friend count for the age\\n                seen[ages[index]] = index - hi; \\n            }\\n            // Update result count\\n            result += seen[ages[index]];\\n        }        \\n        return result;\\n    }\\n    \\n    private bool CanFriend(int x, int y) {\\n        return !((y > x) || (y > 100 && x < 100) || (y <= 0.5 * x + 7));\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223329,
                "title": "easy-c-solution-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int a,int b) {\\n         float A=a;\\n         float B=b;\\n         if(B<=(0.5*A)+7 || B>A || (B>100 && A<100)) return false;\\n         return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> mp;\\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++) mp[ages[i]]++;\\n        for(pair<int,int> p : mp) {\\n            for(pair<int,int> q : mp) {\\n                if(isvalid(p.first,q.first)) {\\n                   if(p.first==q.first) ans+=p.second*(p.second-1);\\n                   else ans+=p.second*q.second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int a,int b) {\\n         float A=a;\\n         float B=b;\\n         if(B<=(0.5*A)+7 || B>A || (B>100 && A<100)) return false;\\n         return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> mp;\\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++) mp[ages[i]]++;\\n        for(pair<int,int> p : mp) {\\n            for(pair<int,int> q : mp) {\\n                if(isvalid(p.first,q.first)) {\\n                   if(p.first==q.first) ans+=p.second*(p.second-1);\\n                   else ans+=p.second*q.second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169867,
                "title": "1ms-simple-java-solution-loop-with-window-o-1-space-o-n-time",
                "content": "Java 1ms, beats 100% time. Simple moving window loop over 120 ages starting age 15 with lower range as age/2+7. Linear time `O(n)` and constant space `O(1)` complexity.\\n\\n```java\\n\\n/**\\n* A will friend request B iff\\n* age: A/2+7 < B < A but for some  A /2+7 >=A -> A/2<=7 A<=14\\n* So anyone under 15 cannot friend request\\n* Solution: store people in age buckets and loop over it with window starting form age 15\\n**/\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleByAge = new int[121];\\n        for(int i = 0; i < ages.length; i++)\\n            peopleByAge[ages[i]]++;\\n        int result = 0, peopleCount = 0, lowerAgeRange = 15;\\n        for(int i = 15; i <= 120; i++) {\\n            if (i % 2 == 0)\\n                peopleCount -= peopleByAge[lowerAgeRange++];\\n            peopleCount += peopleByAge[i];\\n            result += peopleByAge[i] * (peopleCount-1);  // we can all befriend each other. -1 is to exclude ourselves\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n\\n/**\\n* A will friend request B iff\\n* age: A/2+7 < B < A but for some  A /2+7 >=A -> A/2<=7 A<=14\\n* So anyone under 15 cannot friend request\\n* Solution: store people in age buckets and loop over it with window starting form age 15\\n**/\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleByAge = new int[121];\\n        for(int i = 0; i < ages.length; i++)\\n            peopleByAge[ages[i]]++;\\n        int result = 0, peopleCount = 0, lowerAgeRange = 15;\\n        for(int i = 15; i <= 120; i++) {\\n            if (i % 2 == 0)\\n                peopleCount -= peopleByAge[lowerAgeRange++];\\n            peopleCount += peopleByAge[i];\\n            result += peopleByAge[i] * (peopleCount-1);  // we can all befriend each other. -1 is to exclude ourselves\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100755,
                "title": "greedy-beats-90-time-and-space",
                "content": "O(N ^ 2) time, O(N) space\\n\\nSort and Filter out lower ages from earlier iterations\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        res = 0\\n        ages = sorted(Counter(ages).items())\\n\\n        left = 0\\n        for i, (ownAge, count) in enumerate(ages):\\n            if count > 1 and ownAge > 0.5 * ownAge + 7: res += count * (count - 1)\\n\\n            for j in range(left, i):\\n                if ages[j][0] > 0.5 * ownAge + 7: res += ages[j][1] * count\\n                else: left += 1\\n                    \\n        return res",
                "solutionTags": [],
                "code": "O(N ^ 2) time, O(N) space\\n\\nSort and Filter out lower ages from earlier iterations\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        res = 0\\n        ages = sorted(Counter(ages).items())\\n\\n        left = 0\\n        for i, (ownAge, count) in enumerate(ages):\\n            if count > 1 and ownAge > 0.5 * ownAge + 7: res += count * (count - 1)\\n\\n            for j in range(left, i):\\n                if ages[j][0] > 0.5 * ownAge + 7: res += ages[j][1] * count\\n                else: left += 1\\n                    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1067229,
                "title": "javascript-easy-and-simple-solution",
                "content": "```javascript\\nvar numFriendRequests = function(ages) {\\n    const range = [];\\n    const freq = {}\\n    let count = 0;\\n    \\n    for(let n of ages) {\\n        freq[n] = (freq[n] || 0) + 1;\\n        const min = Math.floor(n/2 + 8);\\n        range.push([min, n]);\\n    }\\n    \\n    for(let i = 0; i < range.length; i++) {\\n        const [min, max] = range[i];\\n        \\n        for(let j = min; j <= max; j++) {\\n            if(!freq[j]) continue;\\n            count += freq[j];\\n            if(j === max) count--;\\n        }\\n    }\\n    return count;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar numFriendRequests = function(ages) {\\n    const range = [];\\n    const freq = {}\\n    let count = 0;\\n    \\n    for(let n of ages) {\\n        freq[n] = (freq[n] || 0) + 1;\\n        const min = Math.floor(n/2 + 8);\\n        range.push([min, n]);\\n    }\\n    \\n    for(let i = 0; i < range.length; i++) {\\n        const [min, max] = range[i];\\n        \\n        for(let j = min; j <= max; j++) {\\n            if(!freq[j]) continue;\\n            count += freq[j];\\n            if(j === max) count--;\\n        }\\n    }\\n    return count;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1062882,
                "title": "simple-o-n-java-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        ages = ages == null ? new int[0] : ages;\\n        \\n        int[] count = new int[121];\\n        int requests = 0;\\n        \\n        for (int age : ages)\\n            count[age]++;\\n        \\n        for (int a = 1; a <= 120; a++) {\\n            for (int b = 1; b <= 120; b++) {\\n                if (count[a] + count[b] <= 1 || aCannotRequestB(a, b))\\n                    continue; //not enough people or any of the rule violates\\n                \\n                int numAgesOfA = count[a], numAgesOfB = count[b];\\n                if (a == b) //special case if both a and b are pointing to the same age slot\\n                    numAgesOfB--;\\n                \\n                requests += numAgesOfA * numAgesOfB;\\n            }\\n        }\\n        \\n        return requests;\\n    }\\n    \\n    private boolean aCannotRequestB(int a, int b) {\\n        return b <= (a / 2 + 7) || b > a || b > 100 && a < 100;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        ages = ages == null ? new int[0] : ages;\\n        \\n        int[] count = new int[121];\\n        int requests = 0;\\n        \\n        for (int age : ages)\\n            count[age]++;\\n        \\n        for (int a = 1; a <= 120; a++) {\\n            for (int b = 1; b <= 120; b++) {\\n                if (count[a] + count[b] <= 1 || aCannotRequestB(a, b))\\n                    continue; //not enough people or any of the rule violates\\n                \\n                int numAgesOfA = count[a], numAgesOfB = count[b];\\n                if (a == b) //special case if both a and b are pointing to the same age slot\\n                    numAgesOfB--;\\n                \\n                requests += numAgesOfA * numAgesOfB;\\n            }\\n        }\\n        \\n        return requests;\\n    }\\n    \\n    private boolean aCannotRequestB(int a, int b) {\\n        return b <= (a / 2 + 7) || b > a || b > 100 && a < 100;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958504,
                "title": "5-ms-concise-java",
                "content": "```\\nclass Solution {\\n    /*\\n    Valid conditions for A to friend req. B\\n    0.5 * age[A] + 7 < age[B] <= age[A]\\n    \\n    1 <= ages.length <= 20000.\\n    1 <= ages[i] <= 120.\\n    */\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int ans = 0;\\n        for(int age : ages){\\n            count[age]++;\\n        }\\n        // i -> age[A] ------ j -> age[B]\\n        for(int i=0; i<=120; i++){\\n            for(int j=0; j<=120; j++){\\n                if((0.5 * i + 7) < j && j <= i){\\n                    ans += count[i]*count[j];\\n                    if(i == j) {\\n                        ans -= count[i];\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n    Valid conditions for A to friend req. B\\n    0.5 * age[A] + 7 < age[B] <= age[A]\\n    \\n    1 <= ages.length <= 20000.\\n    1 <= ages[i] <= 120.\\n    */\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int ans = 0;\\n        for(int age : ages){\\n            count[age]++;\\n        }\\n        // i -> age[A] ------ j -> age[B]\\n        for(int i=0; i<=120; i++){\\n            for(int j=0; j<=120; j++){\\n                if((0.5 * i + 7) < j && j <= i){\\n                    ans += count[i]*count[j];\\n                    if(i == j) {\\n                        ans -= count[i];\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934783,
                "title": "python3-two-approaches",
                "content": "**Approach 1 - sliding window**\\nSort `ages`. For each age, find the range of ages to make request based on \"no friend\" rule, i.e. given `x` requests friends whose ages fall in range `(0.5*x+7, x]`.  The range can be found via sliding window. \\n\\nImplementation (384ms, 34.85%)\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = lo = hi = 0 \\n        for x in ages: \\n            while hi < len(ages) and x == ages[hi]: hi += 1\\n            while lo+1 < hi and ages[lo] <= x//2 + 7: lo += 1\\n            ans += hi - lo - 1\\n        return ans \\n```\\n\\nAnalysis\\nTime complexity `O(NlogN)`\\nSpace complexity `O(1)`\\n\\nApproach 2 - frequency table \\nAlthough the length of `ages` can go all the way up to `20000` there are only up to `120` distinct values. So we leverage on frequency table. \\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        freq = {}\\n        for x in ages: freq[x] = 1 + freq.get(x, 0)\\n        \\n        ans = 0 \\n        for x in freq: \\n            for y in freq: \\n                if 0.5*x + 7 < y <= x: \\n                    ans += freq[x] * freq[y]\\n                    if x == y: ans -= freq[x]\\n        return ans \\n```\\n\\nAnalysis \\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = lo = hi = 0 \\n        for x in ages: \\n            while hi < len(ages) and x == ages[hi]: hi += 1\\n            while lo+1 < hi and ages[lo] <= x//2 + 7: lo += 1\\n            ans += hi - lo - 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        freq = {}\\n        for x in ages: freq[x] = 1 + freq.get(x, 0)\\n        \\n        ans = 0 \\n        for x in freq: \\n            for y in freq: \\n                if 0.5*x + 7 < y <= x: \\n                    ans += freq[x] * freq[y]\\n                    if x == y: ans -= freq[x]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 857963,
                "title": "java-solution-using-binary-search",
                "content": "We can use binary search to find the range of ages (age[A]*0.5 +7) where friend requests can be sent.\\n\\n\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        Arrays.sort(ages);\\n        for(int i = 0; i < ages.length; i++) {\\n            int age = ages[i];\\n            //upper can be i but in same ages upper change\\n            //so need to find upper index also\\n            int upper = findIndex(ages, age);\\n            //lower index is from where all the ages comes in\\n            //range age[A]*.5 + 7 \\n            int lower = findIndex(ages, ((age/2)+7));\\n            ans += Math.max(upper-lower-1, 0);\\n        }\\n        return ans;\\n    }\\n    \\n    //binary search\\n    public static int findIndex(int[] ages, int target) {\\n        int start = 0;\\n        int end = ages.length-1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(ages[mid] <= target) start = mid + 1;\\n            else end = mid-1;\\n        }\\n        return start;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        Arrays.sort(ages);\\n        for(int i = 0; i < ages.length; i++) {\\n            int age = ages[i];\\n            //upper can be i but in same ages upper change\\n            //so need to find upper index also\\n            int upper = findIndex(ages, age);\\n            //lower index is from where all the ages comes in\\n            //range age[A]*.5 + 7 \\n            int lower = findIndex(ages, ((age/2)+7));\\n            ans += Math.max(upper-lower-1, 0);\\n        }\\n        return ans;\\n    }\\n    \\n    //binary search\\n    public static int findIndex(int[] ages, int target) {\\n        int start = 0;\\n        int end = ages.length-1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(ages[mid] <= target) start = mid + 1;\\n            else end = mid-1;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848515,
                "title": "java-1ms-solution-beats-100-time-o-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int[] ageSum = new int[121];\\n        for (int age : ages)\\n            count[age]++;\\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 15; i <= 120; i++) {\\n            sum += count[i];\\n            ageSum[i] = sum;\\n            if (count[i] > 0)\\n                ans += ((ageSum[i] - ageSum[i / 2 + 7] - 1) * count[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int[] ageSum = new int[121];\\n        for (int age : ages)\\n            count[age]++;\\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 15; i <= 120; i++) {\\n            sum += count[i];\\n            ageSum[i] = sum;\\n            if (count[i] > 0)\\n                ans += ((ageSum[i] - ageSum[i / 2 + 7] - 1) * count[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815506,
                "title": "javascript-solution-o-1-space-o-n-time",
                "content": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var nums = new Array(121).fill(0)\\n\\t//O(n) loop here\\n    for(let i of ages){ nums[i]++ }\\n        var ans = 0\\n    for(let i = 0 ;i <= 120; i++){\\n        let countA = nums[i]\\n        for(let j = 0; j <= 120; j++){\\n            let countB = nums[j]\\n            if((i * 0.5 + 7 >= j) || (i < j)) continue\\n            ans += countA * countB\\n            if(i === j) ans -= countA\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var nums = new Array(121).fill(0)\\n\\t//O(n) loop here\\n    for(let i of ages){ nums[i]++ }\\n        var ans = 0\\n    for(let i = 0 ;i <= 120; i++){\\n        let countA = nums[i]\\n        for(let j = 0; j <= 120; j++){\\n            let countB = nums[j]\\n            if((i * 0.5 + 7 >= j) || (i < j)) continue\\n            ans += countA * countB\\n            if(i === j) ans -= countA\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738407,
                "title": "javascript-two-pointer",
                "content": "```\\nconst numFriendRequests = (ages) => {\\n    ages.sort((a, b) => a - b);\\n    let cnt = 0;\\n    let i = 0;\\n    while (i < ages.length) {\\n        let j = i + 1;\\n        let A = ages[i];\\n        while (j < ages.length) {\\n            let B = ages[j];\\n            if ((B > 0.5 * A + 7) && (B <= 100 || A >= 100) && (B == A)) {\\n                cnt++;\\n            }\\n            if ((A > 0.5 * B + 7) && (A <= 100 || B >= 100)) {\\n                cnt++;\\n            }\\n            j++;\\n        }\\n        i++;\\n    }\\n    return cnt;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numFriendRequests = (ages) => {\\n    ages.sort((a, b) => a - b);\\n    let cnt = 0;\\n    let i = 0;\\n    while (i < ages.length) {\\n        let j = i + 1;\\n        let A = ages[i];\\n        while (j < ages.length) {\\n            let B = ages[j];\\n            if ((B > 0.5 * A + 7) && (B <= 100 || A >= 100) && (B == A)) {\\n                cnt++;\\n            }\\n            if ((A > 0.5 * B + 7) && (A <= 100 || B >= 100)) {\\n                cnt++;\\n            }\\n            j++;\\n        }\\n        i++;\\n    }\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 658569,
                "title": "the-easiest-way",
                "content": "```\\n/*\\u5B98\\u89E3\\u6CD5\\n *2020\\u5E745\\u670829\\u65E5 20:01\\n *\\u6267\\u884C\\u7528\\u65F6 :7 ms, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8653.67%\\u7684\\u7528\\u6237\\n *\\u5185\\u5B58\\u6D88\\u8017 :42.3 MB, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8611.11%\\u7684\\u7528\\u6237\\n *\\u4F5C\\u8005@v7fgg\\n */\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int nianling[]=new int[121];\\n        int ans=0;\\n        for(int a:ages){\\n            nianling[a]++;\\n        }\\n        for(int i=1;i<121;i++){\\n            for(int j=1;j<121;j++){\\n                int a=nianling[i];\\n                int b=nianling[j];\\n                if(j>0.5*i+7&&i>=j&&(j<=100||i>=100)){\\n                    ans+=i==j?a*b-a:a*b;\\n                }                \\n            }\\n        }return ans;\\n    }\\n}\\n//on leetcode.com\\n//Runtime: 6 ms, faster than 50.67% of Java online submissions for Friends Of Appropriate Ages.\\n//Memory Usage: 41.4 MB, less than 20.00% of Java online submissions for Friends Of Appropriate Ages.\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\u5B98\\u89E3\\u6CD5\\n *2020\\u5E745\\u670829\\u65E5 20:01\\n *\\u6267\\u884C\\u7528\\u65F6 :7 ms, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8653.67%\\u7684\\u7528\\u6237\\n *\\u5185\\u5B58\\u6D88\\u8017 :42.3 MB, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8611.11%\\u7684\\u7528\\u6237\\n *\\u4F5C\\u8005@v7fgg\\n */\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int nianling[]=new int[121];\\n        int ans=0;\\n        for(int a:ages){\\n            nianling[a]++;\\n        }\\n        for(int i=1;i<121;i++){\\n            for(int j=1;j<121;j++){\\n                int a=nianling[i];\\n                int b=nianling[j];\\n                if(j>0.5*i+7&&i>=j&&(j<=100||i>=100)){\\n                    ans+=i==j?a*b-a:a*b;\\n                }                \\n            }\\n        }return ans;\\n    }\\n}\\n//on leetcode.com\\n//Runtime: 6 ms, faster than 50.67% of Java online submissions for Friends Of Appropriate Ages.\\n//Memory Usage: 41.4 MB, less than 20.00% of Java online submissions for Friends Of Appropriate Ages.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656218,
                "title": "pretty-fast-c-solution-using-hash-table-and-some-pruning-of-age-range",
                "content": "```\\nint numFriendRequests(int* ages, int agesSize){\\nint count=0;\\nint i, j;\\nint min_age;\\nint max_age;\\nint age_hash[150];\\n// Initialize a hash table of ages, 0 to 149, and hash all ages into it\\nfor (i=0; i<150; i++) age_hash[i]=0;\\nfor (i=0; i<agesSize; i++) age_hash[ages[i]]++;\\n\\n// Reduce the work by finding youngest and oldest ages\\nfor (i=0; i<150; i++) if (age_hash[i]!=0) { min_age=i; break; }\\nfor (i=149; i>0; i--) if (age_hash[i]!=0) { max_age=i; break; }\\n\\n// Check friending status of each pair of ages, and multiply by how\\n// many of each we have; if ages are same, remember you can\\'t friend\\n// yourself!\\nfor (i=min_age; i<=max_age; i++)\\n    for (j=min_age; j<=max_age; j++) {\\n        if ((age_hash[i]!=0) && (age_hash[j]!=0)) {\\n          if ((j>0.5*i+7) && (j<=i) && \\n              ((j<=100) || (i>=100)))\\n            if (i==j) count += age_hash[i] * (age_hash[i]-1);\\n              else count += age_hash[i] * age_hash[j];\\n        }\\n    }\\n        \\nreturn count;\\n}\\n",
                "solutionTags": [],
                "code": "```\\nint numFriendRequests(int* ages, int agesSize){\\nint count=0;\\nint i, j;\\nint min_age;\\nint max_age;\\nint age_hash[150];\\n// Initialize a hash table of ages, 0 to 149, and hash all ages into it\\nfor (i=0; i<150; i++) age_hash[i]=0;\\nfor (i=0; i<agesSize; i++) age_hash[ages[i]]++;\\n\\n// Reduce the work by finding youngest and oldest ages\\nfor (i=0; i<150; i++) if (age_hash[i]!=0) { min_age=i; break; }\\nfor (i=149; i>0; i--) if (age_hash[i]!=0) { max_age=i; break; }\\n\\n// Check friending status of each pair of ages, and multiply by how\\n// many of each we have; if ages are same, remember you can\\'t friend\\n// yourself!\\nfor (i=min_age; i<=max_age; i++)\\n    for (j=min_age; j<=max_age; j++) {\\n        if ((age_hash[i]!=0) && (age_hash[j]!=0)) {\\n          if ((j>0.5*i+7) && (j<=i) && \\n              ((j<=100) || (i>=100)))\\n            if (i==j) count += age_hash[i] * (age_hash[i]-1);\\n              else count += age_hash[i] * age_hash[j];\\n        }\\n    }\\n        \\nreturn count;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 620199,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\n    bool isReq(int ageA, int ageB) {\\n        \\n        if (ageB <= 0.5*ageA + 7) return false;\\n        if (ageB > ageA) return false;\\n        return true;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        int n = ages.size();\\n        \\n        unordered_map<int, int>hm;\\n        for (int i = 0; i < n; i++)\\n            hm[ages[i]]++;\\n        \\n        int ans = 0;\\n        for (auto a = hm.begin(); a != hm.end(); a++) {\\n            for (auto b = hm.begin(); b != hm.end(); b++) {\\n                if (isReq(a->first, b->first))\\n                    ans += a->second * (b->second - (a->first == b->first ? 1 : 0));\\n            } \\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isReq(int ageA, int ageB) {\\n        \\n        if (ageB <= 0.5*ageA + 7) return false;\\n        if (ageB > ageA) return false;\\n        return true;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        int n = ages.size();\\n        \\n        unordered_map<int, int>hm;\\n        for (int i = 0; i < n; i++)\\n            hm[ages[i]]++;\\n        \\n        int ans = 0;\\n        for (auto a = hm.begin(); a != hm.end(); a++) {\\n            for (auto b = hm.begin(); b != hm.end(); b++) {\\n                if (isReq(a->first, b->first))\\n                    ans += a->second * (b->second - (a->first == b->first ? 1 : 0));\\n            } \\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609380,
                "title": "java-o-n-with-explanation",
                "content": "```   /**\\n     * O(n) solution\\n     * Thought: From  nlogn solution, the thing that cost most is the binary search to find the count of ages between lowerBound and upperBound\\n     * so the idea is to see whether we can reduce find counts from O(nlogn) O(1)\\n     *\\n     * since the total ages are between [1, 120]\\n     * so we can first use an array count the number of each ages O(n)\\n     *\\n     * for each age, we know there\\'s a lowerBound and higherBound that ages[i] will send request\\n     * lowerBound = ages[i] / 2 + 8, upperBound = ages[i]\\n     * \\n     * To calculate the count of ages between lowerBound and highBound in O(1), \\n     * we use a prefixCount array\\n     * The count between age[upperBound] and age[lowerBound] will be\\n     * int count = prefixCount[i] - prefixCount[i / 2 + 7]; (prefixCount[i / 2 + 7] is exclusive)\\n     * then we can calcute the res for ages[i] by \\n     * res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n     *\\n     * @param ages\\n     * @return\\n     */\\n    public int numFriendRequestsII(int[] ages) {\\n\\n        // total 120 possible ages in this question, use + 1 avoid overflow\\n        int[] countAges = new int[121];\\n       // prefixSum used to easy find out count of ages between lowerBound and higherBound\\n        int[] prefixCount = new int[121];\\n        for (int i : ages) {\\n            countAges[i]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            prefixCount[i] = countAges[i] + prefixCount[i - 1];\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            if(countAges[i] == 0) {\\n                continue;\\n            }\\n            if(i / 2 + 7 >= i) {\\n                continue;\\n            }\\n            int count = prefixCount[i] - prefixCount[i / 2 + 7];\\n            res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   /**\\n     * O(n) solution\\n     * Thought: From  nlogn solution, the thing that cost most is the binary search to find the count of ages between lowerBound and upperBound\\n     * so the idea is to see whether we can reduce find counts from O(nlogn) O(1)\\n     *\\n     * since the total ages are between [1, 120]\\n     * so we can first use an array count the number of each ages O(n)\\n     *\\n     * for each age, we know there\\'s a lowerBound and higherBound that ages[i] will send request\\n     * lowerBound = ages[i] / 2 + 8, upperBound = ages[i]\\n     * \\n     * To calculate the count of ages between lowerBound and highBound in O(1), \\n     * we use a prefixCount array\\n     * The count between age[upperBound] and age[lowerBound] will be\\n     * int count = prefixCount[i] - prefixCount[i / 2 + 7]; (prefixCount[i / 2 + 7] is exclusive)\\n     * then we can calcute the res for ages[i] by \\n     * res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n     *\\n     * @param ages\\n     * @return\\n     */\\n    public int numFriendRequestsII(int[] ages) {\\n\\n        // total 120 possible ages in this question, use + 1 avoid overflow\\n        int[] countAges = new int[121];\\n       // prefixSum used to easy find out count of ages between lowerBound and higherBound\\n        int[] prefixCount = new int[121];\\n        for (int i : ages) {\\n            countAges[i]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            prefixCount[i] = countAges[i] + prefixCount[i - 1];\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            if(countAges[i] == 0) {\\n                continue;\\n            }\\n            if(i / 2 + 7 >= i) {\\n                continue;\\n            }\\n            int count = prefixCount[i] - prefixCount[i / 2 + 7];\\n            res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534421,
                "title": "cpp-beats-100-submissions-in-time-and-space",
                "content": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        int ans=0;\\n        int freq[121]={0};\\n        for(int age : ages)\\n            freq[age]++;\\n        int vec[121];\\n        vec[0]=freq[0];\\n        for(int i=1;i<=120;i++)\\n            vec[i]=vec[i-1]+freq[i];\\n        //persons with age from 1 to 14 will not be able to make friend requests\\n        for(int i=15;i<=120;i++)\\n        {\\n            int t=i/2+7;\\n            int val=vec[i]-vec[t]-1;\\n            ans+=freq[i]*val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        int ans=0;\\n        int freq[121]={0};\\n        for(int age : ages)\\n            freq[age]++;\\n        int vec[121];\\n        vec[0]=freq[0];\\n        for(int i=1;i<=120;i++)\\n            vec[i]=vec[i-1]+freq[i];\\n        //persons with age from 1 to 14 will not be able to make friend requests\\n        for(int i=15;i<=120;i++)\\n        {\\n            int t=i/2+7;\\n            int val=vec[i]-vec[t]-1;\\n            ans+=freq[i]*val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499670,
                "title": "why-doesn-t-this-work",
                "content": "```\\n public int numFriendRequests(int[] ages) { \\n        \\n        int[] counts = new int[121];\\n        for(int age : ages) {\\n            counts[age]++;\\n        }\\n        int result = 0;\\n        for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               \\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                    if(canRequest(i, j)){\\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n\\t\\n\\tand if I make the logic change as follows it works\\n\\t  for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               if(!canRequest(i,j)) continue;\\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                  \\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n    \\n    private boolean canRequest(int A, int B) {\\n        if((B <= 0.5 * A + 7) ||  B > A || (B > 100 && A < 100 )) return false;\\n         \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) { \\n        \\n        int[] counts = new int[121];\\n        for(int age : ages) {\\n            counts[age]++;\\n        }\\n        int result = 0;\\n        for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               \\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                    if(canRequest(i, j)){\\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n\\t\\n\\tand if I make the logic change as follows it works\\n\\t  for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               if(!canRequest(i,j)) continue;\\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                  \\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n    \\n    private boolean canRequest(int A, int B) {\\n        if((B <= 0.5 * A + 7) ||  B > A || (B > 100 && A < 100 )) return false;\\n         \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 478473,
                "title": "concise-solution-for-interviews-simpler-than-official-solution",
                "content": "\\tpublic int numFriendRequests(int[] ages) {\\n\\t\\tint[] freq = new int[121];\\n\\t\\tfor (int age : ages) {\\n\\t\\t  freq[age]++;\\n\\t\\t}\\n\\n\\t\\tint req = 0;\\n\\n\\t\\tfor (int a = 1; a <= 120; a++) {\\n\\t\\t  for (int b = 1; b <= 120; b++) {\\n\\t\\t\\tif (b > a || b <= 0.5 * a + 7) {\\n\\t\\t\\t  continue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a == b) {\\n\\t\\t\\t  req += freq[a] * (freq[a] - 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t  req += freq[a] * freq[b];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn req;\\n\\t  }",
                "solutionTags": [
                    "Array"
                ],
                "code": "\\tpublic int numFriendRequests(int[] ages) {\\n\\t\\tint[] freq = new int[121];\\n\\t\\tfor (int age : ages) {\\n\\t\\t  freq[age]++;\\n\\t\\t}\\n\\n\\t\\tint req = 0;\\n\\n\\t\\tfor (int a = 1; a <= 120; a++) {\\n\\t\\t  for (int b = 1; b <= 120; b++) {\\n\\t\\t\\tif (b > a || b <= 0.5 * a + 7) {\\n\\t\\t\\t  continue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a == b) {\\n\\t\\t\\t  req += freq[a] * (freq[a] - 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t  req += freq[a] * freq[b];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn req;\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 447775,
                "title": "javascript-solution",
                "content": "```\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var friendships = 0;\\n    var nums = {};\\n    ages.forEach(function(age){\\n        if(age >= 15) nums[age] = age in nums ? nums[age] + 1: 1;\\n    });\\n    var ages = Object.keys(nums).sort((a,b) => b - a);\\n    for(var i = 0; i < ages.length; i++){\\n        for(var j = i + 1; j < ages.length; j++){\\n            if(ages[j] > 0.5 * ages[i] + 7){\\n                friendships += nums[ages[i]] * nums[ages[j]];\\n            }\\n        }\\n        friendships += ((nums[ages[i]] - 1) * nums[ages[i]]);\\n    }\\n    return friendships;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var friendships = 0;\\n    var nums = {};\\n    ages.forEach(function(age){\\n        if(age >= 15) nums[age] = age in nums ? nums[age] + 1: 1;\\n    });\\n    var ages = Object.keys(nums).sort((a,b) => b - a);\\n    for(var i = 0; i < ages.length; i++){\\n        for(var j = i + 1; j < ages.length; j++){\\n            if(ages[j] > 0.5 * ages[i] + 7){\\n                friendships += nums[ages[i]] * nums[ages[j]];\\n            }\\n        }\\n        friendships += ((nums[ages[i]] - 1) * nums[ages[i]]);\\n    }\\n    return friendships;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401164,
                "title": "short-simple-python-binary-search-solution",
                "content": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = 0\\n        ages.sort()\\n        for n in ages:\\n            l, r = n//2 + 8, n \\n            ll = bisect_left(ages,l)\\n            rr = bisect_right(ages,r)\\n            val = rr - ll - 1\\n            count += val if val > 0  else 0\\n        return count\\n            ```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = 0\\n        ages.sort()\\n        for n in ages:\\n            l, r = n//2 + 8, n \\n            ll = bisect_left(ages,l)\\n            rr = bisect_right(ages,r)\\n            val = rr - ll - 1\\n            count += val if val > 0  else 0\\n        return count\\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 342382,
                "title": "python-easy-to-understand-o-n-log-n-o-1-space",
                "content": "1. Sort the ages\\n2. Have a left pointer and right pointer\\n3. The pointers indicate which people can be friended\\n\\t- left pointer is increased until 0.5 * A + 7 is false\\n\\t- right pointer is the current age (people don\\'t friend people older than them)\\n4. Special handling is needed for the case where we have multiple people of the same age\\n\\t- to handle this keep track of the duplicates `sameAge` and add them to our ans\\n\\t- for example we have 3 people of age 30\\n\\t\\t- for first guy, sameAge = 0\\n\\t\\t- for second guy, sameAge = 1. ans += 1 - first guy making friends with the second guy\\n\\t\\t- for third guy, sameAge = 2. ans += 2  - first and second guy making friends with the third guy\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages): \\n        ages.sort()\\n        ans = 0\\n        l = 0\\n        \\n        sameAge = 0\\n        \\n        for r, A in enumerate(ages):\\n            if r and ages[r] == ages[r - 1]:\\n                sameAge += 1\\n            else:\\n                sameAge = 0\\n            \\n            while l < len(ages) and ages[l] <= 0.5 * A + 7:\\n                l += 1\\n        \\n            if l <= r:\\n                ans += r - l + sameAge     \\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages): \\n        ages.sort()\\n        ans = 0\\n        l = 0\\n        \\n        sameAge = 0\\n        \\n        for r, A in enumerate(ages):\\n            if r and ages[r] == ages[r - 1]:\\n                sameAge += 1\\n            else:\\n                sameAge = 0\\n            \\n            while l < len(ages) and ages[l] <= 0.5 * A + 7:\\n                l += 1\\n        \\n            if l <= r:\\n                ans += r - l + sameAge     \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146319,
                "title": "logical-thinking-with-java-code",
                "content": "**Logical Thinking**\\n```\\nNotes:\\n1 <= ages.length <= 20000.\\n1 <= ages[i] <= 120.\\n```\\nThe notes above is the key to solve the problem.\\nThe `value range of ages` is far smaller than the `number of ages`. Thus, we loop through all possible values for age rather than ages of all possible candidates, i.e.,  `[1, 120] rather than [1, 20000]`.\\nPlease note that, if A1 = ageA, A2 = ageA, B1 = ageB, B2 = ageB, B3 = ageB, then total requests made by ageA and ageB is 2 x 3 = 6, that is, `map[ageA] x map[ageB]`. What if ageA equals to ageB? The the result shoulD minus `map[ageA/ageB] `for people cannot make friend requests to himself.\\n\\n**Clear Java Code**\\n```\\n    public int numFriendRequests(int[] ages) {\\n        int cntFriendRequests = 0;\\n        int[] map = new int[121]; // 1 ~ 120;\\n        for (int age : ages) {\\n            map[age]++;\\n        }\\n        for (int A = 1; A <= 120; A++) {\\n            for (int B = 1; B <= 120; B++) {\\n                if (B <= 0.5 * A + 7) continue;\\n                if (B > A) continue;\\n                if (B > 100 && A < 100) continue;\\n                cntFriendRequests += map[A] * map[B];\\n                if (A == B) {\\n                    cntFriendRequests -= map[A];\\n                }\\n            }\\n        }\\n        return cntFriendRequests;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nNotes:\\n1 <= ages.length <= 20000.\\n1 <= ages[i] <= 120.\\n```\n```\\n    public int numFriendRequests(int[] ages) {\\n        int cntFriendRequests = 0;\\n        int[] map = new int[121]; // 1 ~ 120;\\n        for (int age : ages) {\\n            map[age]++;\\n        }\\n        for (int A = 1; A <= 120; A++) {\\n            for (int B = 1; B <= 120; B++) {\\n                if (B <= 0.5 * A + 7) continue;\\n                if (B > A) continue;\\n                if (B > 100 && A < 100) continue;\\n                cntFriendRequests += map[A] * map[B];\\n                if (A == B) {\\n                    cntFriendRequests -= map[A];\\n                }\\n            }\\n        }\\n        return cntFriendRequests;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135447,
                "title": "concise-c-code",
                "content": "```\\nint\\nnumFriendRequests(const int *const ages, const int agesSize)\\n{\\n\\tstatic int cnt[121];\\n\\tint a, b, sum;\\n\\n\\t(void)memset(cnt, 0, sizeof(cnt));\\n\\tfor (a = 0; a < agesSize; ++a)\\n\\t\\t++cnt[ages[a]];\\n\\tsum = 0;\\n\\tfor (a = 15; a <= 120; ++a)\\n\\t\\tif (cnt[a] != 0)\\n\\t\\t\\tfor (b = a / 2 + 8; b <= a; ++b)\\n\\t\\t\\t\\tif (cnt[b] != 0)\\n\\t\\t\\t\\t\\tsum += (cnt[a] - (a == b)) * cnt[b];\\n\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint\\nnumFriendRequests(const int *const ages, const int agesSize)\\n{\\n\\tstatic int cnt[121];\\n\\tint a, b, sum;\\n\\n\\t(void)memset(cnt, 0, sizeof(cnt));\\n\\tfor (a = 0; a < agesSize; ++a)\\n\\t\\t++cnt[ages[a]];\\n\\tsum = 0;\\n\\tfor (a = 15; a <= 120; ++a)\\n\\t\\tif (cnt[a] != 0)\\n\\t\\t\\tfor (b = a / 2 + 8; b <= a; ++b)\\n\\t\\t\\t\\tif (cnt[b] != 0)\\n\\t\\t\\t\\t\\tsum += (cnt[a] - (a == b)) * cnt[b];\\n\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 127885,
                "title": "c-hash-map",
                "content": "I first have some difficulty to understand the problem.\\nThe three condition is C1, C2 and C3\\nA not friend request B: C1||C2||C3\\nA friend request B: !(C1||C2||C3)=!C1&&!C2&&!C3\\n!C1: B>0.5A+7. If B=A, B>14\\n!C2: B<=A\\n!C3: B<=100 || A>=100, this always is true\\nWe build a hash map (using a vector is simpler) and check the !C1 and !C2.\\nsame age friend request if met condition: N*(N-1)\\ndifferent age friend request if met condition: N*M\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int va[121]={0};\\n        for(int i=0;i<ages.size();i++) va[ages[i]]++;\\n        //larger age friend request smaller age\\n        //age difference\\n        //can use binary search\\n        int total=0;\\n        for(int i=1;i<=120;i++)\\n        {\\n            if(i>14 && va[i]>1) total+=va[i]*(va[i]-1); //C1 condition\\n            if(i>1 && va[i]) //2nd condition, only friend request with smaller age\\n            {\\n                int smallest_age=i/2+7+1;//>age C1 condition\\n                //cout<<smallest_age<<endl;\\n                for(int j=smallest_age;j<i;j++) total+=va[j]*va[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int va[121]={0};\\n        for(int i=0;i<ages.size();i++) va[ages[i]]++;\\n        //larger age friend request smaller age\\n        //age difference\\n        //can use binary search\\n        int total=0;\\n        for(int i=1;i<=120;i++)\\n        {\\n            if(i>14 && va[i]>1) total+=va[i]*(va[i]-1); //C1 condition\\n            if(i>1 && va[i]) //2nd condition, only friend request with smaller age\\n            {\\n                int smallest_age=i/2+7+1;//>age C1 condition\\n                //cout<<smallest_age<<endl;\\n                for(int j=smallest_age;j<i;j++) total+=va[j]*va[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 127109,
                "title": "simple-java-solution",
                "content": "```\\n public int numFriendRequests(int[] ages) {\\n       int[] map =  new int[121];\\n       for(int n : ages)\\n           map[n]++;  // frequency count\\n       \\n       int req = 0;\\n        for(int i = 120; i>0 ;--i){\\n            if( map[i]  > 0){\\n                int k = i + 14;  // ages[j] must be > 0.5*ages[i] + 7  =>  ages[j]*2 > ages[i] + 14 \\n                for(int j = i-1; 2*j > k  ;--j){\\n                    if(map[j] > 0) req+=map[i]*map[j]; // ways A can make friend requests to B\\n                }\\n                if( 2*i > k)  req+=map[i]*(map[i]-1);  // friend requests made to each other (same age)\\n            }\\n        }\\n       return req;\\n   }",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) {\\n       int[] map =  new int[121];\\n       for(int n : ages)\\n           map[n]++;  // frequency count\\n       \\n       int req = 0;\\n        for(int i = 120; i>0 ;--i){\\n            if( map[i]  > 0){\\n                int k = i + 14;  // ages[j] must be > 0.5*ages[i] + 7  =>  ages[j]*2 > ages[i] + 14 \\n                for(int j = i-1; 2*j > k  ;--j){\\n                    if(map[j] > 0) req+=map[i]*map[j]; // ways A can make friend requests to B\\n                }\\n                if( 2*i > k)  req+=map[i]*(map[i]-1);  // friend requests made to each other (same age)\\n            }\\n        }\\n       return req;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 127038,
                "title": "easy-and-simple-c-o-nlogn-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int ans = 0;\\n        for(int i = 0; i < ages.size(); i++){\\n            int j = i+1;\\n            while(j<ages.size() && ages[i]==ages[j]) j++;\\n            j--;\\n            auto itr = upper_bound(ages.begin(), ages.end(), 0.5*ages[i] + 7);\\n            if(itr != ages.end() && (itr-ages.begin())<j) {\\n                ans += j - (itr-ages.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int ans = 0;\\n        for(int i = 0; i < ages.size(); i++){\\n            int j = i+1;\\n            while(j<ages.size() && ages[i]==ages[j]) j++;\\n            j--;\\n            auto itr = upper_bound(ages.begin(), ages.end(), 0.5*ages[i] + 7);\\n            if(itr != ages.end() && (itr-ages.begin())<j) {\\n                ans += j - (itr-ages.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126971,
                "title": "python-solution",
                "content": "```\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from bisect import bisect_left, bisect_right\\n        total=0\\n        ages.sort()\\n\\n        for i in xrange(len(ages)-1, -1, -1):\\n            a = ages[i]\\n            r = bisect_right(ages, a) - 1\\n            l = bisect_right(ages, a/2 + 7)\\n            if r-l >= 0:\\n                total += (r-l)\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from bisect import bisect_left, bisect_right\\n        total=0\\n        ages.sort()\\n\\n        for i in xrange(len(ages)-1, -1, -1):\\n            a = ages[i]\\n            r = bisect_right(ages, a) - 1\\n            l = bisect_right(ages, a/2 + 7)\\n            if r-l >= 0:\\n                total += (r-l)\\n        return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4090663,
                "title": "go-simple",
                "content": "```\\nfunc numFriendRequests(ages []int) int {\\n    people := make([]int, 121)\\n\\n    for _, age := range ages {\\n        people[age]++\\n    }\\n\\n    res := 0\\n\\n    for i := 1; i <= 120; i++ {\\n        if people[i] == 0 { continue }\\n\\n        limit := (i / 2) + 7\\n\\n        for j := limit + 1; j < i; j++ {\\n            res += people[i] * people[j]\\n        }\\n\\n        if i > limit {\\n            res += people[i] * (people[i] - 1)\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numFriendRequests(ages []int) int {\\n    people := make([]int, 121)\\n\\n    for _, age := range ages {\\n        people[age]++\\n    }\\n\\n    res := 0\\n\\n    for i := 1; i <= 120; i++ {\\n        if people[i] == 0 { continue }\\n\\n        limit := (i / 2) + 7\\n\\n        for j := limit + 1; j < i; j++ {\\n            res += people[i] * people[j]\\n        }\\n\\n        if i > limit {\\n            res += people[i] * (people[i] - 1)\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024957,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java  []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```java  []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934494,
                "title": "java-code",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean check(int x, int y) {\\n        return !((y <= (0.5*x)+7) || (y > x) || (y > 100 && x<100));\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int el : ages) {\\n            map.put(el, map.getOrDefault(el, 0)+1);\\n        }\\n\\n        int count = 0;\\n\\n        for(int a : map.keySet()) {\\n            for(int b : map.keySet()) {\\n                if(check(a,b)) {\\n                    count += map.get(a)*(map.get(b) - ((a == b)? 1 : 0));\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean check(int x, int y) {\\n        return !((y <= (0.5*x)+7) || (y > x) || (y > 100 && x<100));\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int el : ages) {\\n            map.put(el, map.getOrDefault(el, 0)+1);\\n        }\\n\\n        int count = 0;\\n\\n        for(int a : map.keySet()) {\\n            for(int b : map.keySet()) {\\n                if(check(a,b)) {\\n                    count += map.get(a)*(map.get(b) - ((a == b)? 1 : 0));\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891045,
                "title": "brute-force-and-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(N2) and O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// || (b>100 and a<100)\\n    bool cond(int a,int b){\\n        if(b>a || b<=((0.5*a)+7))return false;\\n        return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        // unordered_map<int,int>mp;\\n        // for(auto it:ages)mp[it]++;\\n        // int ans=0;\\n        // for(auto &it1:mp){\\n        //     for(auto &it2:mp){\\n        //         if(cond(it1.first,it2.first)){\\n        //         if(it1.first==it2.first)ans+=it1.second*(it2.second-1);\\n        //          else ans+=it1.second*it2.second;\\n        //         }\\n                \\n        //     }\\n        // }\\n        // return ans;\\n        int n=ages.size();\\n\\n        sort(ages.begin(),ages.end());\\n        unordered_map<int,int>dict;\\n        int ans=0;\\n        for(auto it:ages){\\n            if(dict.find(it)!=dict.end()){\\n                ans+=dict[it];\\n                continue;\\n            }\\n            int leftmost=-1;\\n            int start=0;\\n            int end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]>0.5*it+7){\\n                    leftmost=mid;\\n                    end=mid-1;\\n                }else start=mid+1;\\n                               \\n            }\\n            if(leftmost<0)continue;\\n            int rightmost=-1;\\n           start=0,end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]<=it){\\n                    rightmost=mid;\\n                    start=mid+1;\\n                }else end=mid-1;\\n\\n            }\\n            int count=rightmost-leftmost;\\n            if(count>0){\\n                ans+=count;\\n            }\\n            if(count>0){\\n                dict[it]=count;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// || (b>100 and a<100)\\n    bool cond(int a,int b){\\n        if(b>a || b<=((0.5*a)+7))return false;\\n        return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        // unordered_map<int,int>mp;\\n        // for(auto it:ages)mp[it]++;\\n        // int ans=0;\\n        // for(auto &it1:mp){\\n        //     for(auto &it2:mp){\\n        //         if(cond(it1.first,it2.first)){\\n        //         if(it1.first==it2.first)ans+=it1.second*(it2.second-1);\\n        //          else ans+=it1.second*it2.second;\\n        //         }\\n                \\n        //     }\\n        // }\\n        // return ans;\\n        int n=ages.size();\\n\\n        sort(ages.begin(),ages.end());\\n        unordered_map<int,int>dict;\\n        int ans=0;\\n        for(auto it:ages){\\n            if(dict.find(it)!=dict.end()){\\n                ans+=dict[it];\\n                continue;\\n            }\\n            int leftmost=-1;\\n            int start=0;\\n            int end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]>0.5*it+7){\\n                    leftmost=mid;\\n                    end=mid-1;\\n                }else start=mid+1;\\n                               \\n            }\\n            if(leftmost<0)continue;\\n            int rightmost=-1;\\n           start=0,end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]<=it){\\n                    rightmost=mid;\\n                    start=mid+1;\\n                }else end=mid-1;\\n\\n            }\\n            int count=rightmost-leftmost;\\n            if(count>0){\\n                ans+=count;\\n            }\\n            if(count>0){\\n                dict[it]=count;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840372,
                "title": "100-in-time-100-in-space-why-no-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI think the problem was somewhat poorly phrased since condition 2 is essentially condition 3, where you don\\'t friend people older than you. With that in mind, we can sort the array first and essentially eliminate needing to check 2/3 of conditions (since anyone before you in age won\\'t friend you back).\\n\\nAfter that it\\'s just a matter of checking for the calculated age condition, with a small statement to handle when people are the same age.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numFriendRequests(ages: number[]): number {\\n\\n    let requests = 0\\n    ages.sort((a, b) => b - a)\\n\\n    for (let i = 0; i < ages.length - 1; i++) {\\n        const mylimit = Math.floor(ages[i] / 2) + 7\\n        inner: for (let k = i + 1; k < ages.length; k++) {\\n            if (ages[k] > mylimit) {\\n                requests++\\n                if (ages[k] === ages[i]) {\\n                    requests++\\n                }\\n            } else {\\n                break inner\\n\\n            }\\n        }\\n    }\\n    return requests\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numFriendRequests(ages: number[]): number {\\n\\n    let requests = 0\\n    ages.sort((a, b) => b - a)\\n\\n    for (let i = 0; i < ages.length - 1; i++) {\\n        const mylimit = Math.floor(ages[i] / 2) + 7\\n        inner: for (let k = i + 1; k < ages.length; k++) {\\n            if (ages[k] > mylimit) {\\n                requests++\\n                if (ages[k] === ages[i]) {\\n                    requests++\\n                }\\n            } else {\\n                break inner\\n\\n            }\\n        }\\n    }\\n    return requests\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825943,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe workflow of the code is as follows:\\n\\ncount is a list whose index represents age and whose value represents the number of people with that age. For example, if there are three people with age 15, count[15] = 3. This step is done in a for age in ages: count[age] += 1 loop.\\n\\nThe code then checks all possible age pairs (a,b) with two nested loops, where ageA and ageB represent the ages of a and b, respectively, and countA and countB represent the number of people of ages a and b, respectively.\\n\\nFor each age pair, if the age of b does not satisfy the condition for sending a friend request (i.e., ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100)), then continue to the next age pair.\\n\\nOtherwise, the person with ageA can send friend requests to all people with ageB, so add countA * countB to the result.\\n\\nHowever, if a and b have the same age (i.e. ageA == ageB), then the person of age a cannot send a friend request to himself. Therefore, we need to subtract countA, which is the number of people of age a, from the result.\\n\\nFinally, return the result res, which is the total number of friend requests that satisfy the condition.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0] * 121  # \\u5E74\\u9F84\\u5230\\u9891\\u7387\\u7684\\u6620\\u5C04,121\\u662F\\u56E0\\u4E3A\\u6700\\u5927\\u5E74\\u9F84\\u662F120\\n        for age in ages:\\n            count[age] += 1\\n\\n        res = 0\\n        for ageA, countA in enumerate(count):\\n            for ageB, countB in enumerate(count):\\n                if ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100):\\n                    continue\\n                res += countA * countB\\n                if ageA == ageB:  # \\u5E74\\u9F84\\u76F8\\u540C\\u7684\\u4EBA\\u4E0D\\u80FD\\u5411\\u81EA\\u5DF1\\u53D1\\u9001\\u8BF7\\u6C42\\n                    res -= countA\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0] * 121  # \\u5E74\\u9F84\\u5230\\u9891\\u7387\\u7684\\u6620\\u5C04,121\\u662F\\u56E0\\u4E3A\\u6700\\u5927\\u5E74\\u9F84\\u662F120\\n        for age in ages:\\n            count[age] += 1\\n\\n        res = 0\\n        for ageA, countA in enumerate(count):\\n            for ageB, countB in enumerate(count):\\n                if ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100):\\n                    continue\\n                res += countA * countB\\n                if ageA == ageB:  # \\u5E74\\u9F84\\u76F8\\u540C\\u7684\\u4EBA\\u4E0D\\u80FD\\u5411\\u81EA\\u5DF1\\u53D1\\u9001\\u8BF7\\u6C42\\n                    res -= countA\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803257,
                "title": "faster-than-100-python3-binary-search-prefix-sum-hash-table",
                "content": "# Intuition\\nUse a counter to count how many times an age is in array and work with all the distinct values.\\n# Approach\\nSort the list with different ages and for every age use binary search or use a last pointer approach to find the youngest one for a request. All the values beetwen this and current age will verify the conditions, and use a prefix sum to compute the sum of them faster.\\n\\n# Complexity\\n- Time complexity:\\nO( n + mlog(m)), m  = the number of distinct values\\n\\n# Code Approach 1: Binary Search\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n            start = 0\\n            end = i-1\\n            last = -1\\n            while start <= end:\\n                m = (start + end) //2\\n                if l[m] <= 0.5*l[i]+7:\\n                    start = m+1\\n\\n                else:\\n                    last = m\\n                    end = m-1\\n\\n            if last>=0:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n\\n        \\n```\\n\\n# Code Approach 2: Two Pointers\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        last = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n        \\n            while last <= i-2 and l[last] <= 0.5 * age + 7:\\n                last += 1\\n\\n            if last <= i-1 and l[last] > 0.5 * age + 7:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n            start = 0\\n            end = i-1\\n            last = -1\\n            while start <= end:\\n                m = (start + end) //2\\n                if l[m] <= 0.5*l[i]+7:\\n                    start = m+1\\n\\n                else:\\n                    last = m\\n                    end = m-1\\n\\n            if last>=0:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n\\n        \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        last = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n        \\n            while last <= i-2 and l[last] <= 0.5 * age + 7:\\n                last += 1\\n\\n            if last <= i-1 and l[last] > 0.5 * age + 7:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751261,
                "title": "c-best-approach-and-easy-to-understand-t-c-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nfind all the age less then age[i] and find minimum age[j] (j<i) such that it follows the condition of friend request and all the ages after jth age till age[i] will follow the condition to send request.\\nso add (i-j) to count.\\n\\nAlong with the upper approach here is one catch.\\n\\nif we have same elements like [16,16,16]\\nnow as per the above example all the three 16 will be able to make friends with other two 16 so total requests sent is 3*(2 each)=6\\nso in such repeating ages what we will do is to count the number of repeating ages and find the requests for last most repeated age and multiply that answer with total number of repeated ages....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNlog(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLowerBound(vector<int>& a,int n,int x)\\n    {\\n        int l=0;\\n        int r=n-1;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(a[mid]>x/2+7)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int numFriendRequests(vector<int>& a) {\\n        \\n        sort(a.begin(),a.end());\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            int j=i;\\n            int sameOccurences=0;\\n            while(j<n && a[i]==a[j])\\n            {\\n                j++;\\n                sameOccurences++;\\n            }\\n            int lowerBound=findLowerBound(a,j-1,a[i]);\\n            //cout<<\"i:\"<<i<<\"LB\"<<lowerBound<<endl;\\n            if(lowerBound!=-1)\\n            {\\n                count+=(j-1-lowerBound)*sameOccurences;\\n            }\\n            i=j-1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLowerBound(vector<int>& a,int n,int x)\\n    {\\n        int l=0;\\n        int r=n-1;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(a[mid]>x/2+7)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int numFriendRequests(vector<int>& a) {\\n        \\n        sort(a.begin(),a.end());\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            int j=i;\\n            int sameOccurences=0;\\n            while(j<n && a[i]==a[j])\\n            {\\n                j++;\\n                sameOccurences++;\\n            }\\n            int lowerBound=findLowerBound(a,j-1,a[i]);\\n            //cout<<\"i:\"<<i<<\"LB\"<<lowerBound<<endl;\\n            if(lowerBound!=-1)\\n            {\\n                count+=(j-1-lowerBound)*sameOccurences;\\n            }\\n            i=j-1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3733163,
                "title": "c-upper-bound-start-and-end-of-range",
                "content": "1. Sort the Ages array\\n2. Find a range of appropriate ages to send requests to. Use *upper bound* flavor of binary search to place a pointer 1 after the first acceptable ages[i], and a pointer 1 position after the current ages[i]\\n3. Count the size of this range.\\n\\n```\\nclass Solution {\\npublic:\\n  int numFriendRequests(vector<int>& ages) {\\n    std::sort(ages.begin(), ages.end());\\n    int n = ages.size(), count = 0;\\n\\n    for (int i = 0; i < n; ++i) {\\n      int low_index = std::upper_bound(ages.begin(), ages.end(), (ages[i] / 2) + 7) - ages.begin();\\n      int high_index = std::upper_bound(ages.begin(), ages.end(), ages[i]) - ages.begin();\\n      count += std::max(high_index - low_index - 1, 0);\\n    }\\n\\n    return count;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numFriendRequests(vector<int>& ages) {\\n    std::sort(ages.begin(), ages.end());\\n    int n = ages.size(), count = 0;\\n\\n    for (int i = 0; i < n; ++i) {\\n      int low_index = std::upper_bound(ages.begin(), ages.end(), (ages[i] / 2) + 7) - ages.begin();\\n      int high_index = std::upper_bound(ages.begin(), ages.end(), ages[i]) - ages.begin();\\n      count += std::max(high_index - low_index - 1, 0);\\n    }\\n\\n    return count;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690755,
                "title": "array",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the negation of the second condition is True, then the negation of the third condition is True.(suppose age[y] <= age[x] and age[y] > 100 --> age[x] > 100 --> thus age[x] >= 100) Hence we could discard the third condition.\\n\\nSince range of age is relative small to the input size, DAA may come in handy.\\n\\nFrom the negation of the second condition we could realize that we might overcount someone who sends a friend request to themself and suppose his/her age is x. As the negation of the first condition is met, 2x > x + 14 --> x > 14.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(121)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ret = 0\\n        L = [0 for _ in range(121)]\\n        \\n        for age in ages:\\n            L[age] += 1\\n        \\n        for age_x in range(1, 121):\\n            for age_y in range(age_x//2+8, age_x+1):\\n                ret += L[age_x] * L[age_y]\\n            \\n            if age_x > 14:\\n                ret -= L[age_x]\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ret = 0\\n        L = [0 for _ in range(121)]\\n        \\n        for age in ages:\\n            L[age] += 1\\n        \\n        for age_x in range(1, 121):\\n            for age_y in range(age_x//2+8, age_x+1):\\n                ret += L[age_x] * L[age_y]\\n            \\n            if age_x > 14:\\n                ret -= L[age_x]\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689143,
                "title": "swift-easy-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   func numFriendRequests(_ ages: [Int]) -> Int {\\n    var requestCount = 0\\n    var ages = ages.sorted()\\n    var length = ages.count\\n    for i in 0..<length{\\n        var leftMostValidIndex = -1\\n        var start1 = 0\\n        var end1 = length-1\\n        while start1 <= end1{\\n            var mid = start1 + (end1 - start1)/2\\n            if Double(ages[mid]) > Double(0.5) * Double(ages[i]) + 7{\\n                leftMostValidIndex = mid\\n                end1 = mid-1\\n            } else {\\n                start1 = mid+1\\n            }\\n        }\\n        if leftMostValidIndex < 0{\\n            continue\\n        }\\n        var rightmostValidIndex = -1\\n        var start = 0\\n        var end = length-1\\n        while start <= end{\\n            var mid = start + (end - start)/2\\n            if ages[mid] <= ages[i]{\\n                rightmostValidIndex = mid\\n                start = mid + 1\\n            }else{\\n                end = mid-1\\n            }\\n        }\\n        var count = rightmostValidIndex - leftMostValidIndex\\n        if count > 0{\\n            requestCount += count\\n        }else{\\n            requestCount += 0\\n        }\\n       \\n    }\\n    return requestCount\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func numFriendRequests(_ ages: [Int]) -> Int {\\n    var requestCount = 0\\n    var ages = ages.sorted()\\n    var length = ages.count\\n    for i in 0..<length{\\n        var leftMostValidIndex = -1\\n        var start1 = 0\\n        var end1 = length-1\\n        while start1 <= end1{\\n            var mid = start1 + (end1 - start1)/2\\n            if Double(ages[mid]) > Double(0.5) * Double(ages[i]) + 7{\\n                leftMostValidIndex = mid\\n                end1 = mid-1\\n            } else {\\n                start1 = mid+1\\n            }\\n        }\\n        if leftMostValidIndex < 0{\\n            continue\\n        }\\n        var rightmostValidIndex = -1\\n        var start = 0\\n        var end = length-1\\n        while start <= end{\\n            var mid = start + (end - start)/2\\n            if ages[mid] <= ages[i]{\\n                rightmostValidIndex = mid\\n                start = mid + 1\\n            }else{\\n                end = mid-1\\n            }\\n        }\\n        var count = rightmostValidIndex - leftMostValidIndex\\n        if count > 0{\\n            requestCount += count\\n        }else{\\n            requestCount += 0\\n        }\\n       \\n    }\\n    return requestCount\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683837,
                "title": "easy-solution-from-byte-benders",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n    \\n        int[] agecount = new int[121];\\n        for(int age : ages)\\n        {\\n            agecount[age]++;\\n        }\\n    int cnt=0;\\n    for(int i=1;i<=120;i++)\\n    {\\n        for(int j=i/2+8;j<=i;j++)\\n        {\\n            cnt+=agecount[i] * (agecount[j]-(i==j?1:0));\\n        }\\n    }\\n    return cnt;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    /*class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n*/}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n    \\n        int[] agecount = new int[121];\\n        for(int age : ages)\\n        {\\n            agecount[age]++;\\n        }\\n    int cnt=0;\\n    for(int i=1;i<=120;i++)\\n    {\\n        for(int j=i/2+8;j<=i;j++)\\n        {\\n            cnt+=agecount[i] * (agecount[j]-(i==j?1:0));\\n        }\\n    }\\n    return cnt;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    /*class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n*/}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615441,
                "title": "c-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121);\\n        for (auto& n : ages) if (n > 14) ++v[n];\\n        int ans = 0, c = 0;\\n        for (int i = 15; i <= 120; ++i){\\n            c += v[i] - v[i / 2 + 7];\\n            v[i / 2 + 7] = 0;\\n            ans += v[i] * (c - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121);\\n        for (auto& n : ages) if (n > 14) ++v[n];\\n        int ans = 0, c = 0;\\n        for (int i = 15; i <= 120; ++i){\\n            c += v[i] - v[i / 2 + 7];\\n            v[i / 2 + 7] = 0;\\n            ans += v[i] * (c - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614765,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counts = [0]*121\\n        \\n        for a in ages:\\n            counts[a]+=1\\n        ans = 0\\n        \\n        for i in ages:\\n            for j in range(i, 0, -1):\\n                if i==j and counts[i]==1: continue\\n                if counts[j]==0: continue\\n                if j<=0.5*i+7: continue\\n                if i==j:\\n                    ans += counts[j]-1\\n                else:\\n                    ans += counts[j]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counts = [0]*121\\n        \\n        for a in ages:\\n            counts[a]+=1\\n        ans = 0\\n        \\n        for i in ages:\\n            for j in range(i, 0, -1):\\n                if i==j and counts[i]==1: continue\\n                if counts[j]==0: continue\\n                if j<=0.5*i+7: continue\\n                if i==j:\\n                    ans += counts[j]-1\\n                else:\\n                    ans += counts[j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522862,
                "title": "friends-of-appropriate-ages-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497884,
                "title": "counting-the-number-of-people-in-different-age-using-list-no-binary-search",
                "content": "# Intuition\\nIf age i can send request to age j, the number of request is #i*#j if i!=j, else #i*(#i-1) because it wont send request to it self.\\nThus, we can group the number of people in different ages.\\nFor any age i, we need to find its bounrdary of age for sending request. There are two conditions: j<=0.5*i+7 or j>i. **Note** the first condition, event though j>0.5*i+7 but j>i, i won\\'t sent request! \\n\\n# Approach\\nGroup the people in differnt ages. Note that, if a dictionary or a Counters is used for this purpose, every time we find the lower bound of i (j>0.5*i+7, and j<i), we need to go through the age list again, which takes O(N) (binary search cost O(logN)).\\nBecause the age range is fixed, we can use a list for this purpose c = [0]*121 to indicate the age (0,120).\\nIf i>0.5*i+7, the number of request within the age group i is c\\\\[i\\\\]*(c\\\\[i\\\\]-1)\\nIf j=0.5*i+7, and j<i, j!=i, the request between age i and ages (j+1,i-1) is sum(cc\\\\[j+1:i\\\\])*c\\\\[i\\\\]\\n\\n# Complexity\\n- Time complexity:\\nGroup the ages takes O(N), loop to calculate the request O(#age), so total O(N+#age)=O(N)\\n\\n- Space complexity:\\nO(121) to store the number of people in different age\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0]*121\\n        age = set()\\n        print(sorted(ages))\\n        for i in ages:\\n            count[i]+=1\\n            age.add(i)\\n\\n        res = 0\\n        for i in age:\\n            b = i//2+7\\n            \\n            if b<i:\\n                res += (count[i]-1)*count[i]\\n            \\n            if b<=i:\\n                s = sum(count[b+1:i])\\n            else:\\n                s=0\\n            \\n            res +=s*count[i]\\n            print(i,b,s,res)\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0]*121\\n        age = set()\\n        print(sorted(ages))\\n        for i in ages:\\n            count[i]+=1\\n            age.add(i)\\n\\n        res = 0\\n        for i in age:\\n            b = i//2+7\\n            \\n            if b<i:\\n                res += (count[i]-1)*count[i]\\n            \\n            if b<=i:\\n                s = sum(count[b+1:i])\\n            else:\\n                s=0\\n            \\n            res +=s*count[i]\\n            print(i,b,s,res)\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475843,
                "title": "ez-understand-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven that the total number of age cohorts is predetermined, a prudent approach would involve a preliminary enumeration of each cohort, followed by a systematic examination of each group.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. To effectively analyze the data, we can compile a comprehensive list of each age and its corresponding population count, denoted as (x, y).\\n2. Next, we can systematically examine each entry in the counter list and evaluate the specified conditions.\\n3. For each instance where the condition is met, we can compute the product of the relevant figures and accumulate the results in a variable named \\'res\\'.\\n4. In the event that we need to assess the number of individuals within the same age group, we can multiply the population count of that age by the count of individuals in the same group minus one, since it is possible for each person to have a friend who is not themselves.\\n# Complexity\\n- Time complexity: O(max(N, 120)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # counter list (x, y) where x is the age and y is the number of people at that age\\n        counter = []\\n        for age in ages:\\n            new = True\\n            for i in range(len(counter)):\\n                if counter[i][0] == age:\\n                    counter[i][1] += 1\\n                    new = False\\n            if new:\\n                counter.append([age, 1])\\n        # go through the counter list and check the condition\\n        res = 0\\n        for i in range(len(counter)):\\n            for j in range(len(counter)):\\n                # check condition\\n                if counter[j][0] <= 0.5 * counter[i][0] + 7 or counter[j][0] > counter[i][0]:\\n                    continue\\n                else:\\n                    if i != j:\\n                        res += counter[j][1] * counter[i][1]\\n                    else:\\n                        if counter[j][1] > 1:\\n                            res += counter[j][1] * (counter[i][1] - 1)\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # counter list (x, y) where x is the age and y is the number of people at that age\\n        counter = []\\n        for age in ages:\\n            new = True\\n            for i in range(len(counter)):\\n                if counter[i][0] == age:\\n                    counter[i][1] += 1\\n                    new = False\\n            if new:\\n                counter.append([age, 1])\\n        # go through the counter list and check the condition\\n        res = 0\\n        for i in range(len(counter)):\\n            for j in range(len(counter)):\\n                # check condition\\n                if counter[j][0] <= 0.5 * counter[i][0] + 7 or counter[j][0] > counter[i][0]:\\n                    continue\\n                else:\\n                    if i != j:\\n                        res += counter[j][1] * counter[i][1]\\n                    else:\\n                        if counter[j][1] > 1:\\n                            res += counter[j][1] * (counter[i][1] - 1)\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457445,
                "title": "c-binary-search-63ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int n=ages.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(ages[i]>13){\\n                int x=lower_bound(ages.begin(),ages.end(),ages[i]/2 + 8)-ages.begin();\\n                int y=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n                // while(y<n && ages[y]==ages[i]) y++;\\n                if(x<y) ans+=(y-i)*(y-x-1);\\n                i=y;\\n                if(y<n) i--;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int n=ages.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(ages[i]>13){\\n                int x=lower_bound(ages.begin(),ages.end(),ages[i]/2 + 8)-ages.begin();\\n                int y=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n                // while(y<n && ages[y]==ages[i]) y++;\\n                if(x<y) ans+=(y-i)*(y-x-1);\\n                i=y;\\n                if(y<n) i--;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361480,
                "title": "simple-binary-search-python-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            idx1 = bisect_right(ages, ages[i])\\n            idx2 = bisect_right(ages, ages[i]*0.5+7)\\n            ans+=max(0,idx1-idx2-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            idx1 = bisect_right(ages, ages[i])\\n            idx2 = bisect_right(ages, ages[i]*0.5+7)\\n            ans+=max(0,idx1-idx2-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345251,
                "title": "javascript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount amount of people for each age. Go through hash array and check conditions for `x` and `y`. Get amount of requests by multiplying `arr[x]` and `arr[y]`. If `x` equals `y` we subtract `1` as a person will not send a friend request to themself.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    let arr = new Array(121).fill(0);\\n    let result = 0;\\n\\n    for (let i = 0; i < ages.length; i++) {\\n        arr[ages[i]]++;\\n    }\\n\\n    for (let x = 0; x < arr.length; x++) {\\n        for (let y = 0; y <= x; y++) {\\n            if (y <= (0.5 * x + 7)) {\\n                continue;\\n            } else {\\n                if (x === y) {\\n                    result += (arr[x] - 1) * arr[y];\\n                } else {\\n                    result += arr[x] * arr[y];\\n                }\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\nUpdated version: one of conditions `y > (0.5 * x + 7)` so we can start `for` from this value + 1 to reduce iterations and make it really shorter.\\n\\n```\\n/* Hide the same code... */\\n\\nfor (let x = 0; x < arr.length; x++) {\\n    for (let y = Math.floor(0.5 * x + 7) + 1; y <= x; y++) {\\n        result += (arr[x] - (x === y)) * arr[y];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    let arr = new Array(121).fill(0);\\n    let result = 0;\\n\\n    for (let i = 0; i < ages.length; i++) {\\n        arr[ages[i]]++;\\n    }\\n\\n    for (let x = 0; x < arr.length; x++) {\\n        for (let y = 0; y <= x; y++) {\\n            if (y <= (0.5 * x + 7)) {\\n                continue;\\n            } else {\\n                if (x === y) {\\n                    result += (arr[x] - 1) * arr[y];\\n                } else {\\n                    result += arr[x] * arr[y];\\n                }\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```\n```\\n/* Hide the same code... */\\n\\nfor (let x = 0; x < arr.length; x++) {\\n    for (let y = Math.floor(0.5 * x + 7) + 1; y <= x; y++) {\\n        result += (arr[x] - (x === y)) * arr[y];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341362,
                "title": "no-need-to-sort-o-n-solution",
                "content": "# Intuition\\nAge constraint is very less(<=120). Bucket map can be created to hold count of people by age\\n\\n# Approach\\nWith given condition, friend request can be sent to only people with age greater than ages[i]/2+7 and lesser than ages[i]. \\nAnd map[ages[i]]-map[cond]-1 will give us total no of people that can be friend listed\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(121)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299954,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool check(int A, int B){\\n        if(B <= 0.5 * A + 7 )\\n            return false ;\\n        if(B > A)\\n            return false ;\\n        if(B > 100 && A < 100)\\n            return false ;\\n        return true ;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ret = 0 ;\\n        unordered_map<int, int>Map ; //{age, count}  \\n        for(auto& a : ages)\\n            Map[a]++ ;\\n        \\n        for(auto& [ageA, numA] : Map)\\n        {\\n            for(auto& [ageB, numB] : Map)\\n            {\\n                if(check(ageA, ageB)){\\n                    if(ageA == ageB)\\n                        ret += numA * (numA - 1) ; \\n                    else\\n                        ret += numA * numB ;\\n                }\\n            }\\n        }    \\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool check(int A, int B){\\n        if(B <= 0.5 * A + 7 )\\n            return false ;\\n        if(B > A)\\n            return false ;\\n        if(B > 100 && A < 100)\\n            return false ;\\n        return true ;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ret = 0 ;\\n        unordered_map<int, int>Map ; //{age, count}  \\n        for(auto& a : ages)\\n            Map[a]++ ;\\n        \\n        for(auto& [ageA, numA] : Map)\\n        {\\n            for(auto& [ageB, numB] : Map)\\n            {\\n                if(check(ageA, ageB)){\\n                    if(ageA == ageB)\\n                        ret += numA * (numA - 1) ; \\n                    else\\n                        ret += numA * numB ;\\n                }\\n            }\\n        }    \\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232791,
                "title": "c-solution-time-o-n-space-o-1-hashmap-and-prefix-sum",
                "content": "# Intuition\\nMake a prefix array to store the count of people till the age (age == index).\\nTo make prefix array first we will make a hashmap to store count of people of particular age (without sorting);\\n\\n# Approach\\n- Make a **count** array to store the count of people of particular age.\\n- Make a **prefixSum** array to store the count of people less than or equal to the current age (index).\\n- Traverse the **prefixSum** array and add the number of people satisfy the condition given in question in contant time.\\n- Please **upvote** if you find approach helpful.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n\\n        for(auto it: ages) {\\n            count[it]++;\\n        }\\n\\n        vector<int> prefixSum(121, 0);\\n        for(int i=1; i<121; i++) {\\n            prefixSum[i] = prefixSum[i-1] + count[i];\\n        }\\n\\n        int res = 0;\\n        for(int i=1; i<121; i++) {\\n            int min = (i/2) + 7;\\n            if(min >= i) {\\n                continue;\\n            }\\n\\n            res += (count[i] * (count[i] - 1));\\n            res += (prefixSum[i-1] - prefixSum[min]) * count[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n\\n        for(auto it: ages) {\\n            count[it]++;\\n        }\\n\\n        vector<int> prefixSum(121, 0);\\n        for(int i=1; i<121; i++) {\\n            prefixSum[i] = prefixSum[i-1] + count[i];\\n        }\\n\\n        int res = 0;\\n        for(int i=1; i<121; i++) {\\n            int min = (i/2) + 7;\\n            if(min >= i) {\\n                continue;\\n            }\\n\\n            res += (count[i] * (count[i] - 1));\\n            res += (prefixSum[i-1] - prefixSum[min]) * count[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228546,
                "title": "c-solution-using-map-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> temp;\\n        int req=0;\\n        for(int i:ages)   //storing value and its frequency in map\\n            temp[i]++;\\n        for(auto &a:temp)\\n            for(auto &b:temp)\\n            {\\n                if(checkt(a.first,b.first))  //checking for the conditions for friends request\\n                {\\n                    if(a.first==b.first)  //if frequency of that age is more than one\\n                        req+=(a.second)*(b.second-1);\\n                    else                 //if it occured only once in map\\n                        req+=(a.second)*(b.second);\\n                }\\n            }\\n        return req;   //returning the request\\n    }\\n    bool checkt(int a,int b)\\n    {\\n        return !(b <= 0.5 * a + 7 || b > a );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> temp;\\n        int req=0;\\n        for(int i:ages)   //storing value and its frequency in map\\n            temp[i]++;\\n        for(auto &a:temp)\\n            for(auto &b:temp)\\n            {\\n                if(checkt(a.first,b.first))  //checking for the conditions for friends request\\n                {\\n                    if(a.first==b.first)  //if frequency of that age is more than one\\n                        req+=(a.second)*(b.second-1);\\n                    else                 //if it occured only once in map\\n                        req+=(a.second)*(b.second);\\n                }\\n            }\\n        return req;   //returning the request\\n    }\\n    bool checkt(int a,int b)\\n    {\\n        return !(b <= 0.5 * a + 7 || b > a );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202645,
                "title": "java-group-by-age-and-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Looking at the input data, the ages are between 1 and 120. \\nIf person of age X can send a friend request to person of age Y, it means ALL people of age X can sent requests to ALL people of age Y.\\nThis means it makes more sense to COUNT each age in an int[121]\\n2. Looking at the criteria age[y] > age[x], we see a younger person cannot befriend an older person.\\nSo we have to traverse this array from right to left, checking if person of age 120 can befriend age 120, 119..1.\\n3. If can yes, if i == j (same group) add the permutation (n! / (n-2)!) which is n * (n-1).\\nif i !=j, then add their multiplication. (group[i] * group[j]).\\n\\n# Complexity\\n- Time complexity:$$O(n + 120 * 120)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(121)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleAges = new int[121];\\n        int requests = 0;\\n        for (int age : ages) {\\n            peopleAges[age]++;\\n        }\\n        for (int i = peopleAges.length -1; i>= 1; i--) {\\n            if (peopleAges[i] > 0) {\\n                boolean canBefriend = true;\\n                for (int j = i; j >= 1 && canBefriend; j--) {\\n                    if (peopleAges[j] > 0 && (canBefriend = canBefriend(i, j))) {\\n                        requests += (i == j ? peopleAges[i] * (peopleAges[i]-1) : peopleAges[i] * peopleAges[j]);   \\n                    }\\n                }\\n            }\\n        }\\n        return requests;\\n    }\\n\\n    private boolean canBefriend(int i, int j) {\\n        return !(j <= 0.5 * i + 7 || j > 100 && i < 100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleAges = new int[121];\\n        int requests = 0;\\n        for (int age : ages) {\\n            peopleAges[age]++;\\n        }\\n        for (int i = peopleAges.length -1; i>= 1; i--) {\\n            if (peopleAges[i] > 0) {\\n                boolean canBefriend = true;\\n                for (int j = i; j >= 1 && canBefriend; j--) {\\n                    if (peopleAges[j] > 0 && (canBefriend = canBefriend(i, j))) {\\n                        requests += (i == j ? peopleAges[i] * (peopleAges[i]-1) : peopleAges[i] * peopleAges[j]);   \\n                    }\\n                }\\n            }\\n        }\\n        return requests;\\n    }\\n\\n    private boolean canBefriend(int i, int j) {\\n        return !(j <= 0.5 * i + 7 || j > 100 && i < 100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159901,
                "title": "python-binary-search-solution-92-faster",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = dict()\\n\\n        for age in ages:\\n            if age in counter:\\n                counter[age] += 1\\n            else:\\n                counter[age] = 1\\n\\n        res = 0\\n        keys = sorted(list(counter.keys()))\\n        val = [counter[key] for key in keys]\\n        prefix = [val[0]]\\n        for i in range(1,len(keys)):prefix.append(prefix[-1] + val[i])\\n\\n        x = (0.5 * keys[0])+ 7\\n        if keys[0] > x:res += (counter[keys[0]] - 1) * counter[keys[0]]\\n\\n        for i in range(1,len(keys)):\\n            x = (0.5 * keys[i])+ 7\\n\\n            if keys[i] > x:res += (counter[keys[i]] - 1) * counter[keys[i]]\\n\\n            index = bisect.bisect_right(keys,x)\\n            \\n            cur = prefix[i-1]\\n            if index > 0:cur -= prefix[index-1]\\n            cur *= counter[keys[i]]\\n            res += max(0,cur)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = dict()\\n\\n        for age in ages:\\n            if age in counter:\\n                counter[age] += 1\\n            else:\\n                counter[age] = 1\\n\\n        res = 0\\n        keys = sorted(list(counter.keys()))\\n        val = [counter[key] for key in keys]\\n        prefix = [val[0]]\\n        for i in range(1,len(keys)):prefix.append(prefix[-1] + val[i])\\n\\n        x = (0.5 * keys[0])+ 7\\n        if keys[0] > x:res += (counter[keys[0]] - 1) * counter[keys[0]]\\n\\n        for i in range(1,len(keys)):\\n            x = (0.5 * keys[i])+ 7\\n\\n            if keys[i] > x:res += (counter[keys[i]] - 1) * counter[keys[i]]\\n\\n            index = bisect.bisect_right(keys,x)\\n            \\n            cur = prefix[i-1]\\n            if index > 0:cur -= prefix[index-1]\\n            cur *= counter[keys[i]]\\n            res += max(0,cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141346,
                "title": "java-solution-with-seperate-int-array",
                "content": "# Intuition/Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly I looked at the lowest number that can send/recieve friend requests. This turns out to be 15 as 15*0.5+7=14.5, which is lower than 15. Additionally 15 is not larger than 15.\\n\\nWith every other n (1<=n<=14) this won\\'t work. \\nI.e. 14*0.5+7 =14 which is equal to 14 and therefore wont work according to the first rule (age[y] <= 0.5 * age[x] + 7 =>will not send a friend request );\\n\\nAfter this one can add up every number with equal value in a seperate int[] Array with the length of 121 as 1<=n<=120. \\n\\nNext one can add up every possible friend Request between certain ages. \\nWithin the same age>=15 every person of that age can send every other person of the same age a friend request. \\nfriendRequests+=(sameNumbers-1)*sameNumbers; \\nHere numbers are the individual ages.\\n\\nEvery person of a certain age can send friend requests to people of lower ages who are equal to age/2+7+1.\\nThe total amount of people of lower ages which a specific age can send friend requests to are summed up in a loop.\\nFinally the total amount of people of a certain age send friend requests to people of lower ages up to the lower bound (age/2+7+1).\\n\\nfriendRequests+=validLowerNumbers*sameNumbers;\\n\\nFinally this can be done for every age individually and summed up and returned.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int friendRequests=0;\\n    int[] totalCount= new int[121];\\n\\n    public int numFriendRequests(int[] ages) {\\n        \\n        for(int a=0;a<ages.length;a++)\\n        {\\n            totalCount[ages[a]]+=1;\\n        }\\n\\n        int sameNumbers;\\n        int validLowerNumbers=0;\\n        \\n        for(int a=15; a<121;a++)\\n        {\\n            int lowestAccepted= a/2+7+1;\\n            sameNumbers=totalCount[a];\\n\\n            validLowerNumbers=0;\\n\\n            for(int b=lowestAccepted; b<a;b++)\\n            {\\n                validLowerNumbers+=totalCount[b];\\n            }\\n            friendRequests+=(sameNumbers-1)*sameNumbers;\\n            friendRequests+=validLowerNumbers*sameNumbers;\\n        }\\n        \\n        return friendRequests;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int friendRequests=0;\\n    int[] totalCount= new int[121];\\n\\n    public int numFriendRequests(int[] ages) {\\n        \\n        for(int a=0;a<ages.length;a++)\\n        {\\n            totalCount[ages[a]]+=1;\\n        }\\n\\n        int sameNumbers;\\n        int validLowerNumbers=0;\\n        \\n        for(int a=15; a<121;a++)\\n        {\\n            int lowestAccepted= a/2+7+1;\\n            sameNumbers=totalCount[a];\\n\\n            validLowerNumbers=0;\\n\\n            for(int b=lowestAccepted; b<a;b++)\\n            {\\n                validLowerNumbers+=totalCount[b];\\n            }\\n            friendRequests+=(sameNumbers-1)*sameNumbers;\\n            friendRequests+=validLowerNumbers*sameNumbers;\\n        }\\n        \\n        return friendRequests;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116814,
                "title": "functional-o-n-69ms-runtime-nice",
                "content": "# Intuition\\n\\n* People below age 15 are not able to request or be requested by anyone, because of the first condition.\\n* The third condition is a red herring.\\n* To solve for just the second condition, we can iterate through a mapping of the number of people by age, and add to a running total of requests as well as a running total of lower aged people.\\n  * The running total of lower aged people is used to compute how many people someone at the current age would request, which can then be multiplied by how many people have that current age and added into the running total of requests.\\n  * To extend this to account for the first condition as well, we change our running total of lower aged people into the number of people who should still be requested.\\n    * We update the running total of lower aged people to still request as people \\'age out\\', which happens at every other age we visit because of the `0.5`(aka `1 / 2`) in the first condition.\\n\\n# Approach\\nMake a mapping of the number of people by age, and then reduce it to the total requests, utilizing an appropriate running number of people who should still be requested, as we compute all the requests happening at or below each age. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction numFriendRequests(ages: number[]): number {\\n    const numOfPeopleByAge = new Array(120 + 1).fill(0, 15, 120 + 1) ; ages.forEach(age => {\\n        if (age >= 15)\\n            numOfPeopleByAge[age]++\\n    })\\n    const [_, totalRequests] = numOfPeopleByAge.reduce(\\n        ([lowerAgedPeopleToRequest, totalRequests], numOfPeopleWithCurrentAge, currentAge, numOfPeopleByAge) => {\\n            if (currentAge % 2 == 0)\\n                lowerAgedPeopleToRequest -= numOfPeopleByAge[0.5 * currentAge + 7]\\n            const numOfPeopleToRequestAtCurrentAge = (numOfPeopleWithCurrentAge - 1 + lowerAgedPeopleToRequest)\\n            totalRequests += numOfPeopleToRequestAtCurrentAge * numOfPeopleWithCurrentAge\\n            lowerAgedPeopleToRequest += numOfPeopleWithCurrentAge\\n            return [lowerAgedPeopleToRequest, totalRequests]\\n        }, [0, 0])\\n    return totalRequests\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numFriendRequests(ages: number[]): number {\\n    const numOfPeopleByAge = new Array(120 + 1).fill(0, 15, 120 + 1) ; ages.forEach(age => {\\n        if (age >= 15)\\n            numOfPeopleByAge[age]++\\n    })\\n    const [_, totalRequests] = numOfPeopleByAge.reduce(\\n        ([lowerAgedPeopleToRequest, totalRequests], numOfPeopleWithCurrentAge, currentAge, numOfPeopleByAge) => {\\n            if (currentAge % 2 == 0)\\n                lowerAgedPeopleToRequest -= numOfPeopleByAge[0.5 * currentAge + 7]\\n            const numOfPeopleToRequestAtCurrentAge = (numOfPeopleWithCurrentAge - 1 + lowerAgedPeopleToRequest)\\n            totalRequests += numOfPeopleToRequestAtCurrentAge * numOfPeopleWithCurrentAge\\n            lowerAgedPeopleToRequest += numOfPeopleWithCurrentAge\\n            return [lowerAgedPeopleToRequest, totalRequests]\\n        }, [0, 0])\\n    return totalRequests\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3060571,
                "title": "fast-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a counting sort to store the number of people for each age. Then, for each person, we can check the number of people with age greater than the person\\'s age and less than the person\\'s age times 0.5 + 7. We need to exclude the case when age i equals age j.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a count array of length 121 to store the number of people for each age.\\n2. For each age in the given ages array, increment the corresponding count array index.\\n3. For each age i in the range 15 to 120:\\n   1. For each age j in the range 15 to 120:\\n      1. If age i is less than or equal to age j times 0.5 + 7, skip this iteration.\\n      2. If age i is less than age j, skip this iteration.\\n      3. If age i is greater than 100 and age j is less than 100, skip this iteration.\\n      4. Add the number of people with age i to the result multiplied by the number of people with age j, excluding the cases when i and j are the same age.\\n4. Return the result.\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n * m), where n and m are the maximum ages in the given array. This is because we need to loop through the entire array of ages, and for each age, we need to loop through every age from 15 to 120.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is O(1), as we only use a count array of fixed size 121.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int res = 0;\\n        vector<int> count(121);\\n        for (int age : ages) ++count[age];\\n        for (int i = 15; i <= 120; ++i)\\n            for (int j = 15; j <= 120; ++j) {\\n                if (i * 0.5 + 7 >= j) continue;\\n                if (i < j) continue;\\n                if (i < 100 && 100 < j) continue;\\n                res += count[i] * (count[j] - (i == j));\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int res = 0;\\n        vector<int> count(121);\\n        for (int age : ages) ++count[age];\\n        for (int i = 15; i <= 120; ++i)\\n            for (int j = 15; j <= 120; ++j) {\\n                if (i * 0.5 + 7 >= j) continue;\\n                if (i < j) continue;\\n                if (i < 100 && 100 < j) continue;\\n                res += count[i] * (count[j] - (i == j));\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054171,
                "title": "basic-solution-using-maps-cpp",
                "content": "# Explanation :\\n```\\npush all the ages into a hash map \\n\\nmaintaining the count of each age\\nwe will check for each age number(key) in map to which age group can\\nthey send an request \\n\\nmake a function to check all the constraints by sending two ages :\\none fixed by first for loop \\nsecond will be traversing the whole map one by one ;\\n\\nwhen ages will be same in the both loops \\neach person can send **(count-1)** requests to this same group \\n```\\n# Code\\n```\\nclass Solution {\\n\\n    bool canNotBeFriends(int x,int y){\\n            if(y<=0.5*x+7)\\n                return true;\\n            if(y>x)\\n                return true;\\n            if(y>100 && x<100)\\n                return true;\\n            return false;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        map<int,int> mp;\\n        int x,y,total=0;\\n        for(auto val: ages)\\n            mp[val]++;\\n        for(auto it1: mp){\\n            x=it1.first;\\n            for(auto it2: mp){\\n                y=it2.first;\\n                if(canNotBeFriends(x,y)){\\n                    continue;\\n                }\\n                if(x==y)\\n                    total+=(mp[x]-1)*mp[x];\\n                else\\n                    total+=mp[x]*mp[y];\\n\\n            }\\n        }\\n        return total ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npush all the ages into a hash map \\n\\nmaintaining the count of each age\\nwe will check for each age number(key) in map to which age group can\\nthey send an request \\n\\nmake a function to check all the constraints by sending two ages :\\none fixed by first for loop \\nsecond will be traversing the whole map one by one ;\\n\\nwhen ages will be same in the both loops \\neach person can send **(count-1)** requests to this same group \\n```\n```\\nclass Solution {\\n\\n    bool canNotBeFriends(int x,int y){\\n            if(y<=0.5*x+7)\\n                return true;\\n            if(y>x)\\n                return true;\\n            if(y>100 && x<100)\\n                return true;\\n            return false;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        map<int,int> mp;\\n        int x,y,total=0;\\n        for(auto val: ages)\\n            mp[val]++;\\n        for(auto it1: mp){\\n            x=it1.first;\\n            for(auto it2: mp){\\n                y=it2.first;\\n                if(canNotBeFriends(x,y)){\\n                    continue;\\n                }\\n                if(x==y)\\n                    total+=(mp[x]-1)*mp[x];\\n                else\\n                    total+=mp[x]*mp[y];\\n\\n            }\\n        }\\n        return total ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047636,
                "title": "beats-100-time-and-space",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    // initiate 0 filled array for hash\\n    let hash = new Array(122).fill(0);\\n    \\n    // makes a normal hash of ages\\n    for(let i = 0; i < ages.length; i++) {\\n        const currAge = ages[i];\\n        hash[currAge]++;\\n    }\\n\\n    // turns hash into \"running hash\" that keeps total number so far\\n    let count = 0;\\n    for(let i = 0; i < hash.length - 1; i++) {\\n        hash[i] = count;\\n        count += hash[i + 1];\\n    }\\n\\n    // loops through ages and checks how many friends each person will have\\n    // add each persons friends to total\\n    let total = 0;\\n    for(let i = 0; i < ages.length; i++) {\\n        const age = ages[i];\\n\\n        // bottom cutoff for friends\\n        let index = Math.floor(age / 2 + 7);\\n        let bottom = hash[index];\\n        // top cutoff for friends\\n        let top = hash[age] - 1;\\n        // subtract top from bottom since hash uses running total;\\n        let addToTotal = (top - bottom);\\n\\n        // cannot subtract friends\\n        if(addToTotal > 0) total += addToTotal;\\n    }\\n\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    // initiate 0 filled array for hash\\n    let hash = new Array(122).fill(0);\\n    \\n    // makes a normal hash of ages\\n    for(let i = 0; i < ages.length; i++) {\\n        const currAge = ages[i];\\n        hash[currAge]++;\\n    }\\n\\n    // turns hash into \"running hash\" that keeps total number so far\\n    let count = 0;\\n    for(let i = 0; i < hash.length - 1; i++) {\\n        hash[i] = count;\\n        count += hash[i + 1];\\n    }\\n\\n    // loops through ages and checks how many friends each person will have\\n    // add each persons friends to total\\n    let total = 0;\\n    for(let i = 0; i < ages.length; i++) {\\n        const age = ages[i];\\n\\n        // bottom cutoff for friends\\n        let index = Math.floor(age / 2 + 7);\\n        let bottom = hash[index];\\n        // top cutoff for friends\\n        let top = hash[age] - 1;\\n        // subtract top from bottom since hash uses running total;\\n        let addToTotal = (top - bottom);\\n\\n        // cannot subtract friends\\n        if(addToTotal > 0) total += addToTotal;\\n    }\\n\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3044407,
                "title": "easy-c-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint helper(vector<int>&ages,int target)\\n{\\n    int low=0;\\n    int high=ages.size()-1;\\n    while(low<=high)\\n    {\\n        int mid=low+(high-low)/2;\\n        if (ages[mid]<=target)\\n        low=mid+1;\\n        else high=mid-1;\\n    }\\n    return low;\\n}\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        sort(ages.begin(),ages.end());\\n        int ans=0;\\n        for (int i=0;i<ages.size();i++)\\n        {\\n            int lower=helper(ages,ages[i]*0.5+7);\\n            int higher=helper(ages,ages[i]);\\n            ans+=max(higher-lower-1,0);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint helper(vector<int>&ages,int target)\\n{\\n    int low=0;\\n    int high=ages.size()-1;\\n    while(low<=high)\\n    {\\n        int mid=low+(high-low)/2;\\n        if (ages[mid]<=target)\\n        low=mid+1;\\n        else high=mid-1;\\n    }\\n    return low;\\n}\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        sort(ages.begin(),ages.end());\\n        int ans=0;\\n        for (int i=0;i<ages.size();i++)\\n        {\\n            int lower=helper(ages,ages[i]*0.5+7);\\n            int higher=helper(ages,ages[i]);\\n            ans+=max(higher-lower-1,0);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028823,
                "title": "python-binary-search",
                "content": "# Complexity\\n- Time complexity: $O(n\\\\log n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        def get_candidates(i):\\n            if i == 0: return 0\\n            if ages[i]<=14: return 0\\n\\n            if ages[i-1]<=0.5*ages[i]+7: return 0\\n\\n            l, r = 0, i-1\\n            while l<=r:\\n                mid = (l+r)//2\\n                if ages[mid]<=0.5*ages[i]+7:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n\\n            if ages[mid]<=0.5*ages[i]+7:\\n                mid  += 1\\n\\n            return i-mid\\n        \\n\\n        ages.sort()\\n        n = len(ages)\\n        res = 0\\n\\n        prev = 0\\n        prev_cnt = 0\\n        for i in range(n):\\n            if ages[i]<=14: continue\\n\\n            if i>=1 and ages[i] == ages[i-1]:\\n                prev_cnt += 1\\n                prev = prev + 1\\n                res += prev + prev_cnt\\n                continue\\n\\n\\n            candidates = get_candidates(i)\\n            res += candidates\\n\\n            prev = candidates\\n            prev_cnt = 0\\n\\n\\n        return res\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        def get_candidates(i):\\n            if i == 0: return 0\\n            if ages[i]<=14: return 0\\n\\n            if ages[i-1]<=0.5*ages[i]+7: return 0\\n\\n            l, r = 0, i-1\\n            while l<=r:\\n                mid = (l+r)//2\\n                if ages[mid]<=0.5*ages[i]+7:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n\\n            if ages[mid]<=0.5*ages[i]+7:\\n                mid  += 1\\n\\n            return i-mid\\n        \\n\\n        ages.sort()\\n        n = len(ages)\\n        res = 0\\n\\n        prev = 0\\n        prev_cnt = 0\\n        for i in range(n):\\n            if ages[i]<=14: continue\\n\\n            if i>=1 and ages[i] == ages[i-1]:\\n                prev_cnt += 1\\n                prev = prev + 1\\n                res += prev + prev_cnt\\n                continue\\n\\n\\n            candidates = get_candidates(i)\\n            res += candidates\\n\\n            prev = candidates\\n            prev_cnt = 0\\n\\n\\n        return res\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993868,
                "title": "c-tricky-problem-detail-explanation-with-comment",
                "content": "**NOTE :** Start reading solution from ```numFriendRequests``` function. I have explained my approach and thought process in the code itself.\\n```\\nclass Solution {\\npublic:\\n    \\n    int binarySearch1(vector<int>& arr, int start, int end, double tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(1.0*arr[mid]<=tgt){\\n                end= mid-1;\\n            }\\n            else if(1.0*arr[mid]>tgt){\\n                potCand=mid;\\n                start=mid+1;\\n            }\\n        }\\n        \\n        return potCand;\\n    }\\n    \\n    int binarySearch3(vector<int>& arr, int start, int end, int tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(arr[mid]<=tgt){\\n                potCand=mid;\\n                end= mid-1;\\n            }\\n            else if(arr[mid]>tgt){\\n                start= mid+1;\\n            }\\n        }\\n        return potCand;\\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end(), greater<int>()); // Non-increasingly sort\\n        \\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++){\\n            double tgt= 1.0*ages[i];  // target\\n            \\n            /*\\n                1. (arr[y] > arr[x]/2 +7) &&\\n                2. (arr[y] <= arr[x]) &&\\n                3. (arr[x]>=100 || arr[y]<=100)\\n            */\\n            \\n            int idx1= binarySearch1(ages, i, ages.size()-1, 0.5*tgt+7); // cond 1 : arr[y] > arr[x]/2 +7\\n            // valid positions are [i-idx1]\\n            if(idx1==-1){ continue; }\\n            \\n            int idx2= ages.size()-1; // cond 2 : arr[y] <= arr[x]\\n            // valid positions are [i-idx2]\\n            \\n            int idx3;\\n            if(ages[i]>=100){ idx3= i; } // all index of y are valid\\n            else{\\n                idx3= binarySearch3(ages, i, ages.size()-1, 100); // cond 3: arr[y] <=100\\n                if(idx3==-1){ continue; }\\n            }\\n            // valid positions are [idx3-ages.size()-1]\\n            \\n            // cout<<idx1<<\" \"<<idx2<<\" \"<<idx3<<endl;\\n            \\n            // Now we need intersection of all 3 conditions.\\n            int finalIdxHigh= min(idx1, idx2);\\n            int finalIdxLow= max(i, idx3);\\n            \\n            ans+=(finalIdxHigh-finalIdxLow);\\n            if(finalIdxLow>i){ ans++; }   \\n        }\\n        \\n        /*\\n            \\uD83D\\uDC49 Now here is a catch : assume [16,16] (repeating case).\\n            \\uD83D\\uDC49 Now when we are at i(here x), we are taking care of all index in [i,size-1]. So, when we are at 0th idx, we are taking care of indexes from [0,1], \\n            and we get at pair ( 0-->1 ), but in this case ( 1-->0 ) is also a valid pair which we are missing.\\n            \\uD83D\\uDC49 For this reason we are storing freq of each element and handling repeating case separately below.\\n\\n            \\uD83D\\uDC49 For eg: assume [16,16,16]\\n            \\uD83D\\uDC49 Above process will handle cases like (0->1), (0->2), (1->2); so ans=3. But we are missing cases like (1->0), (2->1), (2->0). \\n            \\uD83D\\uDC49 From hashmap, we know m[16]=3 (freq). So we just add ans+=((3-1)*3)/2;\\n        */\\n        \\n        unordered_map<int, int> m; // {element, freq}\\n        for(auto it: ages){  m[it]++;  }\\n        \\n        for(auto it: m){\\n            int num= it.first; int n= it.second;\\n            bool flag= 1.0*num > 0.5*num +7;\\n            if(n>1 && flag==true){\\n                ans+=((n-1)*n)/2; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThanks !",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```numFriendRequests```\n```\\nclass Solution {\\npublic:\\n    \\n    int binarySearch1(vector<int>& arr, int start, int end, double tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(1.0*arr[mid]<=tgt){\\n                end= mid-1;\\n            }\\n            else if(1.0*arr[mid]>tgt){\\n                potCand=mid;\\n                start=mid+1;\\n            }\\n        }\\n        \\n        return potCand;\\n    }\\n    \\n    int binarySearch3(vector<int>& arr, int start, int end, int tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(arr[mid]<=tgt){\\n                potCand=mid;\\n                end= mid-1;\\n            }\\n            else if(arr[mid]>tgt){\\n                start= mid+1;\\n            }\\n        }\\n        return potCand;\\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end(), greater<int>()); // Non-increasingly sort\\n        \\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++){\\n            double tgt= 1.0*ages[i];  // target\\n            \\n            /*\\n                1. (arr[y] > arr[x]/2 +7) &&\\n                2. (arr[y] <= arr[x]) &&\\n                3. (arr[x]>=100 || arr[y]<=100)\\n            */\\n            \\n            int idx1= binarySearch1(ages, i, ages.size()-1, 0.5*tgt+7); // cond 1 : arr[y] > arr[x]/2 +7\\n            // valid positions are [i-idx1]\\n            if(idx1==-1){ continue; }\\n            \\n            int idx2= ages.size()-1; // cond 2 : arr[y] <= arr[x]\\n            // valid positions are [i-idx2]\\n            \\n            int idx3;\\n            if(ages[i]>=100){ idx3= i; } // all index of y are valid\\n            else{\\n                idx3= binarySearch3(ages, i, ages.size()-1, 100); // cond 3: arr[y] <=100\\n                if(idx3==-1){ continue; }\\n            }\\n            // valid positions are [idx3-ages.size()-1]\\n            \\n            // cout<<idx1<<\" \"<<idx2<<\" \"<<idx3<<endl;\\n            \\n            // Now we need intersection of all 3 conditions.\\n            int finalIdxHigh= min(idx1, idx2);\\n            int finalIdxLow= max(i, idx3);\\n            \\n            ans+=(finalIdxHigh-finalIdxLow);\\n            if(finalIdxLow>i){ ans++; }   \\n        }\\n        \\n        /*\\n            \\uD83D\\uDC49 Now here is a catch : assume [16,16] (repeating case).\\n            \\uD83D\\uDC49 Now when we are at i(here x), we are taking care of all index in [i,size-1]. So, when we are at 0th idx, we are taking care of indexes from [0,1], \\n            and we get at pair ( 0-->1 ), but in this case ( 1-->0 ) is also a valid pair which we are missing.\\n            \\uD83D\\uDC49 For this reason we are storing freq of each element and handling repeating case separately below.\\n\\n            \\uD83D\\uDC49 For eg: assume [16,16,16]\\n            \\uD83D\\uDC49 Above process will handle cases like (0->1), (0->2), (1->2); so ans=3. But we are missing cases like (1->0), (2->1), (2->0). \\n            \\uD83D\\uDC49 From hashmap, we know m[16]=3 (freq). So we just add ans+=((3-1)*3)/2;\\n        */\\n        \\n        unordered_map<int, int> m; // {element, freq}\\n        for(auto it: ages){  m[it]++;  }\\n        \\n        for(auto it: m){\\n            int num= it.first; int n= it.second;\\n            bool flag= 1.0*num > 0.5*num +7;\\n            if(n>1 && flag==true){\\n                ans+=((n-1)*n)/2; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2945359,
                "title": "python3-concise-solution-beats-99",
                "content": "# Counter + Binary Search + Math\\n# Time complexity: \\nmax(O(121*log(121)), N), N = len(ages)\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931880,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut count = vec![0; 121];\\n        for age in ages {\\n            count[age as usize] += 1;\\n        }\\n        let mut result = 0;\\n        for age in 1..=120 {\\n            if count[age] == 0 {\\n                continue;\\n            }\\n            for other in (age / 2 + 8)..=age {\\n                if count[other] == 0 {\\n                    continue;\\n                }\\n                if age == other {\\n                    result += count[age] * (count[age] - 1);\\n                } else {\\n                    result += count[age] * count[other];\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut count = vec![0; 121];\\n        for age in ages {\\n            count[age as usize] += 1;\\n        }\\n        let mut result = 0;\\n        for age in 1..=120 {\\n            if count[age] == 0 {\\n                continue;\\n            }\\n            for other in (age / 2 + 8)..=age {\\n                if count[other] == 0 {\\n                    continue;\\n                }\\n                if age == other {\\n                    result += count[age] * (count[age] - 1);\\n                } else {\\n                    result += count[age] * count[other];\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2913512,
                "title": "java-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895031,
                "title": "o-120-2-python-straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def doSend(x, y):\\n            if 0.5 * x + 7 >= y:\\n                return False\\n\\n            if x < y:\\n                return False\\n\\n            if x < 100 and y > 100:\\n                return False\\n\\n            return True\\n\\n        counter = collections.Counter(ages)\\n        ans = 0\\n        ages = sorted(counter.keys())\\n        print(ages)\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                isSent = doSend(ages[i], ages[j])\\n                if ages[i] == ages[j]:\\n                    if isSent:\\n                        ans += ((counter[ages[i]] - 1) * counter[ages[i]])\\n                        \\n                else:\\n                    if isSent:\\n                        ans += (counter[ages[i]] * counter[ages[j]])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def doSend(x, y):\\n            if 0.5 * x + 7 >= y:\\n                return False\\n\\n            if x < y:\\n                return False\\n\\n            if x < 100 and y > 100:\\n                return False\\n\\n            return True\\n\\n        counter = collections.Counter(ages)\\n        ans = 0\\n        ages = sorted(counter.keys())\\n        print(ages)\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                isSent = doSend(ages[i], ages[j])\\n                if ages[i] == ages[j]:\\n                    if isSent:\\n                        ans += ((counter[ages[i]] - 1) * counter[ages[i]])\\n                        \\n                else:\\n                    if isSent:\\n                        ans += (counter[ages[i]] * counter[ages[j]])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861540,
                "title": "basic-rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut sum = 0;\\n        for (i, &x) in ages.iter().enumerate() {\\n            for &y in &ages[i as usize + 1..] {\\n                if sends_request(x, y) {\\n                    sum += 1;\\n                }\\n                if sends_request(y, x) {\\n                    sum += 1;\\n                }\\n            }\\n        }\\n        sum\\n    }\\n}\\n\\nfn sends_request(x: i32, y: i32) -> bool {\\n    y > x / 2 + 7 && y <= x\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut sum = 0;\\n        for (i, &x) in ages.iter().enumerate() {\\n            for &y in &ages[i as usize + 1..] {\\n                if sends_request(x, y) {\\n                    sum += 1;\\n                }\\n                if sends_request(y, x) {\\n                    sum += 1;\\n                }\\n            }\\n        }\\n        sum\\n    }\\n}\\n\\nfn sends_request(x: i32, y: i32) -> bool {\\n    y > x / 2 + 7 && y <= x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2829948,
                "title": "python-bisect-3rd-condition-is-redundant",
                "content": "3rd condition is redundant because according to condition 2 we already know `age[y] > age[x]`\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            ans += max(0, bisect.bisect(ages, ages[i]) - bisect.bisect(ages, ages[i] * 0.5 + 7) - 1)\\n        return ans",
                "solutionTags": [],
                "code": "3rd condition is redundant because according to condition 2 we already know `age[y] > age[x]`\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            ans += max(0, bisect.bisect(ages, ages[i]) - bisect.bisect(ages, ages[i] * 0.5 + 7) - 1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2803994,
                "title": "java-solution",
                "content": "```\\n    public int numFriendRequests(int[] ages) {\\n        int n = ages.length, sum = 0;\\n        Arrays.sort(ages);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = i-1; j >= 0; j--){\\n               if(ages[i] >= 2 * (ages[j] - 7))\\n                   break;\\n                else \\n                    sum++;\\n            }\\n            \\n            int k = i;\\n            while(k < n-1 && ages[++k] == ages[i])\\n                if(ages[i]< 2 * (ages[k]-7))\\n                sum++;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int n = ages.length, sum = 0;\\n        Arrays.sort(ages);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = i-1; j >= 0; j--){\\n               if(ages[i] >= 2 * (ages[j] - 7))\\n                   break;\\n                else \\n                    sum++;\\n            }\\n            \\n            int k = i;\\n            while(k < n-1 && ages[++k] == ages[i])\\n                if(ages[i]< 2 * (ages[k]-7))\\n                sum++;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720987,
                "title": "o-n-solution-easily-updated-to-o-120-solution-or-constant-time-for-any-input",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        age_count = [0] * 121\\n        summ = 0\\n        dic = {}\\n        \\n        # count ages frpom 0 to 120\\n        for age in ages:\\n            age_count[age] += 1\\n            \\n        # range sum, helps in calculating number of friend requests to be sent \\n        # without binary search\\n        for i in range (121):\\n            summ += age_count[i]\\n            dic[i] = summ\\n\\n        \\n        total_count = 0\\n        # loop through all the ages\\n        # Alternately, You can even loop through 0 to 120 and still be able to calculate\\n        # that will reduce time complexity to O(120) basically almost constant time for inputs of any sizes\\n        \\n        for age in ages:\\n            lower_age = (age * 0.5) + 7\\n            rem = lower_age % 1.0\\n            lower_age = int(lower_age-0.5) if rem>0 else int(lower_age)\\n            higher_age = int(min(age, 100) if age < 100 else age)\\n                        \\n            if lower_age>higher_age:\\n                continue\\n            \\n            if lower_age<age<=higher_age:\\n                decrease_count=1\\n            else:\\n                decrease_count = 0\\n            if higher_age==lower_age:\\n                increase_count = 0\\n            else:\\n                increase_count = dic[higher_age] - dic[lower_age]\\n                \\n            total_count += increase_count - decrease_count\\n            \\n        return total_count\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        age_count = [0] * 121\\n        summ = 0\\n        dic = {}\\n        \\n        # count ages frpom 0 to 120\\n        for age in ages:\\n            age_count[age] += 1\\n            \\n        # range sum, helps in calculating number of friend requests to be sent \\n        # without binary search\\n        for i in range (121):\\n            summ += age_count[i]\\n            dic[i] = summ\\n\\n        \\n        total_count = 0\\n        # loop through all the ages\\n        # Alternately, You can even loop through 0 to 120 and still be able to calculate\\n        # that will reduce time complexity to O(120) basically almost constant time for inputs of any sizes\\n        \\n        for age in ages:\\n            lower_age = (age * 0.5) + 7\\n            rem = lower_age % 1.0\\n            lower_age = int(lower_age-0.5) if rem>0 else int(lower_age)\\n            higher_age = int(min(age, 100) if age < 100 else age)\\n                        \\n            if lower_age>higher_age:\\n                continue\\n            \\n            if lower_age<age<=higher_age:\\n                decrease_count=1\\n            else:\\n                decrease_count = 0\\n            if higher_age==lower_age:\\n                increase_count = 0\\n            else:\\n                increase_count = dic[higher_age] - dic[lower_age]\\n                \\n            total_count += increase_count - decrease_count\\n            \\n        return total_count\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675263,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar numFriendRequests = function(ages) {\\n\\t\\tconst agesMap = new Map();\\n\\t\\tconst agesSum = Array(121).fill(0);\\n\\n\\t\\tages.forEach(age => {\\n\\t\\t\\tconst count = agesMap.get(age) ?? 0;\\n\\t\\t\\tagesMap.set(age, count + 1);\\n\\t\\t});\\n\\n\\t\\tfor (let age = 1; age < 121; age++) {\\n\\t\\t\\tagesSum[age] = (agesMap.get(age) ?? 0) + agesSum[age - 1];\\n\\t\\t}\\n\\n\\t\\treturn [...new Set(ages)].reduce((result, age) => {\\n\\t\\t\\tconst validAge = (age * 0.5 | 0) + 7;\\n\\t\\t\\tif (validAge >= age) return result;\\n\\t\\t\\tconst multiple = agesSum[age] - agesSum[validAge];\\n\\t\\t\\treturn result + (multiple - 1) * agesMap.get(age);\\n\\t\\t}, 0);\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar numFriendRequests = function(ages) {\\n\\t\\tconst agesMap = new Map();\\n\\t\\tconst agesSum = Array(121).fill(0);\\n\\n\\t\\tages.forEach(age => {\\n\\t\\t\\tconst count = agesMap.get(age) ?? 0;\\n\\t\\t\\tagesMap.set(age, count + 1);\\n\\t\\t});\\n\\n\\t\\tfor (let age = 1; age < 121; age++) {\\n\\t\\t\\tagesSum[age] = (agesMap.get(age) ?? 0) + agesSum[age - 1];\\n\\t\\t}\\n\\n\\t\\treturn [...new Set(ages)].reduce((result, age) => {\\n\\t\\t\\tconst validAge = (age * 0.5 | 0) + 7;\\n\\t\\t\\tif (validAge >= age) return result;\\n\\t\\t\\tconst multiple = agesSum[age] - agesSum[validAge];\\n\\t\\t\\treturn result + (multiple - 1) * agesMap.get(age);\\n\\t\\t}, 0);\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2668841,
                "title": "pyton-binary-search",
                "content": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        res = 0\\n        for i, x in enumerate(ages):\\n            if x < 100:\\n                r = bisect_right(ages, min(x,100))\\n            else:\\n                r = bisect_right(ages, x)\\n            l = bisect_right(ages, 0.5*x + 7)\\n            if l < r:\\n                res += r - l - 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        res = 0\\n        for i, x in enumerate(ages):\\n            if x < 100:\\n                r = bisect_right(ages, min(x,100))\\n            else:\\n                r = bisect_right(ages, x)\\n            l = bisect_right(ages, 0.5*x + 7)\\n            if l < r:\\n                res += r - l - 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2661724,
                "title": "simple-java-solution-space-o-1-time-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { \\n        int[] numPerAge = new int[150];\\n        \\n        for(int i : ages)\\n            numPerAge[i] += 1;\\n        \\n        int sum = 0;\\n        for(int currentAge = 0; currentAge <150; currentAge++) {\\n            //if perf\\n            if(numPerAge[currentAge] == 0)\\n                continue;\\n            \\n            // To be elibigle to receive request\\n            // Y person should be greater than or equal to \\'startAge\\'. (+1 is for equal and greater than)\\n            int startAge = (int)(currentAge * 0.5) + 7 + 1;\\n            \\n            // If Eligible age is greater than current age, \\n            // Person of currentAge wont be able to send any request due to rule#2.\\n            if(startAge > currentAge)\\n                continue;\\n            \\n            // Get count of all person whoes age starts with startAge and currentAge-1;\\n            int eligiblePeopleCount = getCount(numPerAge, startAge, currentAge-1);\\n            \\n            // Persons of Same age (as currentAge) will send request to each of the eligible people.\\n            sum += (eligiblePeopleCount * numPerAge[currentAge]);\\n\\n            // X Person can send request to the other presons who is of same age of X.\\n            sum += (numPerAge[currentAge] * (numPerAge[currentAge] -1));\\n        }\\n        return sum;\\n    }\\n    private int getCount(int[] numPerAge, int startAge, int currentAge) {\\n        if(currentAge < startAge)\\n            return 0;\\n\\n        int sum = 0;\\n        for(int i = startAge; i <= currentAge; i++) {\\n            sum += numPerAge[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { \\n        int[] numPerAge = new int[150];\\n        \\n        for(int i : ages)\\n            numPerAge[i] += 1;\\n        \\n        int sum = 0;\\n        for(int currentAge = 0; currentAge <150; currentAge++) {\\n            //if perf\\n            if(numPerAge[currentAge] == 0)\\n                continue;\\n            \\n            // To be elibigle to receive request\\n            // Y person should be greater than or equal to \\'startAge\\'. (+1 is for equal and greater than)\\n            int startAge = (int)(currentAge * 0.5) + 7 + 1;\\n            \\n            // If Eligible age is greater than current age, \\n            // Person of currentAge wont be able to send any request due to rule#2.\\n            if(startAge > currentAge)\\n                continue;\\n            \\n            // Get count of all person whoes age starts with startAge and currentAge-1;\\n            int eligiblePeopleCount = getCount(numPerAge, startAge, currentAge-1);\\n            \\n            // Persons of Same age (as currentAge) will send request to each of the eligible people.\\n            sum += (eligiblePeopleCount * numPerAge[currentAge]);\\n\\n            // X Person can send request to the other presons who is of same age of X.\\n            sum += (numPerAge[currentAge] * (numPerAge[currentAge] -1));\\n        }\\n        return sum;\\n    }\\n    private int getCount(int[] numPerAge, int startAge, int currentAge) {\\n        if(currentAge < startAge)\\n            return 0;\\n\\n        int sum = 0;\\n        for(int i = startAge; i <= currentAge; i++) {\\n            sum += numPerAge[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653687,
                "title": "golang-o-n-2",
                "content": "```\\nfunc numFriendRequests(ages []int) int {\\n    requestCount := 0\\n    \\n    ageToCount := make(map[int]int)\\n    for i := 0; i < len(ages); i++ {\\n        ageToCount[ages[i]]++\\n    }\\n    \\n    uniqueAges := make([]int, 0, len(ageToCount))\\n    for age, _ := range ageToCount {\\n        uniqueAges = append(uniqueAges, age)\\n    }\\n    \\n    sort.Ints(uniqueAges)\\n    \\n    n := len(uniqueAges)\\n    for i := 0; i < n; i ++ {\\n        for j := 0; j < n; j++ {\\n            if sendRequest(uniqueAges[i], uniqueAges[j]) {\\n                if i == j {\\n                    requestCount += ageToCount[uniqueAges[i]] * (ageToCount[uniqueAges[i]] - 1) \\n                } else {\\n                    requestCount += (ageToCount[uniqueAges[i]] * ageToCount[uniqueAges[j]])\\n                }\\n            }\\n        }\\n    }\\n    \\n    return requestCount\\n}\\n\\nfunc sendRequest(a int, b int) bool {\\n    return !((2 * b - 14 <= a) || b > a)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numFriendRequests(ages []int) int {\\n    requestCount := 0\\n    \\n    ageToCount := make(map[int]int)\\n    for i := 0; i < len(ages); i++ {\\n        ageToCount[ages[i]]++\\n    }\\n    \\n    uniqueAges := make([]int, 0, len(ageToCount))\\n    for age, _ := range ageToCount {\\n        uniqueAges = append(uniqueAges, age)\\n    }\\n    \\n    sort.Ints(uniqueAges)\\n    \\n    n := len(uniqueAges)\\n    for i := 0; i < n; i ++ {\\n        for j := 0; j < n; j++ {\\n            if sendRequest(uniqueAges[i], uniqueAges[j]) {\\n                if i == j {\\n                    requestCount += ageToCount[uniqueAges[i]] * (ageToCount[uniqueAges[i]] - 1) \\n                } else {\\n                    requestCount += (ageToCount[uniqueAges[i]] * ageToCount[uniqueAges[j]])\\n                }\\n            }\\n        }\\n    }\\n    \\n    return requestCount\\n}\\n\\nfunc sendRequest(a int, b int) bool {\\n    return !((2 * b - 14 <= a) || b > a)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617352,
                "title": "my-solutions",
                "content": "**1. Use the binary search**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(vector<int> &ages) {\\n    const int n = static_cast<int>(ages.size());\\n    sort(ages.begin(), ages.end());\\n    int ret = 0;\\n    for (int x = 0; x < n; ++x) {\\n      int upper_y = ages[x];\\n      if (ages[x] < 100) {\\n        upper_y = min(upper_y, 100);\\n      }\\n\\n      const int lower_y = ages[x] / 2 + 7;\\n      ret += static_cast<int>(max(0L,\\n                                  upper_bound(ages.begin(), ages.end(), upper_y) -\\n                                  upper_bound(ages.begin(), ages.end(), lower_y) -\\n                                  (ages[x] <= upper_y && ages[x] >= lower_y ? 1 : 0)));\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the unordered map**\\n```\\n/**\\n * Time Complexity: O(n_ages * a_ages)\\n * Space Complexity: O(n_ages)\\n * where `n_ages` is the number of distinct values (ages) of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(const vector<int> &ages) {\\n    unordered_map<int, int> age_to_persons;\\n    for (const int age : ages) {\\n      ++age_to_persons[age];\\n    }\\n   \\n    int ret = 0;\\n    for (const auto [x, x_persons] : age_to_persons) {\\n      for (const auto [y, y_persons] : age_to_persons) {\\n        if (can_make_friend_request(x, y)) {\\n          ret += x_persons * (y_persons + (x == y ? -1 : 0));\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool can_make_friend_request(const int x, const int y) {\\n    return !(y <= x / 2 + 7 || y > x || (y > 100 && x < 100));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(vector<int> &ages) {\\n    const int n = static_cast<int>(ages.size());\\n    sort(ages.begin(), ages.end());\\n    int ret = 0;\\n    for (int x = 0; x < n; ++x) {\\n      int upper_y = ages[x];\\n      if (ages[x] < 100) {\\n        upper_y = min(upper_y, 100);\\n      }\\n\\n      const int lower_y = ages[x] / 2 + 7;\\n      ret += static_cast<int>(max(0L,\\n                                  upper_bound(ages.begin(), ages.end(), upper_y) -\\n                                  upper_bound(ages.begin(), ages.end(), lower_y) -\\n                                  (ages[x] <= upper_y && ages[x] >= lower_y ? 1 : 0)));\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n_ages * a_ages)\\n * Space Complexity: O(n_ages)\\n * where `n_ages` is the number of distinct values (ages) of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(const vector<int> &ages) {\\n    unordered_map<int, int> age_to_persons;\\n    for (const int age : ages) {\\n      ++age_to_persons[age];\\n    }\\n   \\n    int ret = 0;\\n    for (const auto [x, x_persons] : age_to_persons) {\\n      for (const auto [y, y_persons] : age_to_persons) {\\n        if (can_make_friend_request(x, y)) {\\n          ret += x_persons * (y_persons + (x == y ? -1 : 0));\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool can_make_friend_request(const int x, const int y) {\\n    return !(y <= x / 2 + 7 || y > x || (y > 100 && x < 100));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611773,
                "title": "python-o-nlgn-binary-search-easy-solution",
                "content": "import bisect\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \\n        x, result = 0, 0\\n        \\n        ages.sort()\\n        \\n        while(x < len(ages)):\\n            x1 = bisect.bisect_right(ages, ages[x])\\n            y1 = bisect.bisect_right(ages, ages[x] * 0.5 + 7)\\n            result += max(0, x1 - y1 - 1)\\n            x += 1\\n \\n        return result\\n",
                "solutionTags": [],
                "code": "import bisect\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \\n        x, result = 0, 0\\n        \\n        ages.sort()\\n        \\n        while(x < len(ages)):\\n            x1 = bisect.bisect_right(ages, ages[x])\\n            y1 = bisect.bisect_right(ages, ages[x] * 0.5 + 7)\\n            result += max(0, x1 - y1 - 1)\\n            x += 1\\n \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 2568904,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func numFriendRequests(_ ages: [Int]) -> Int {\\n        var req: Int = 0, map: [Int:Int] = [:]\\n        for age in ages {\\n            map[age, default: 0] += 1\\n        }\\n        for y in 1 ... 120 {\\n            for x in 1 ... 120 {\\n                if (Double(y) <= (Double(x) * 0.5 + 7)) || (y > x) || (y > 100 && x < 100) {\\n                    continue\\n                }\\n                req += map[y, default: 0] * map[x, default: 0]\\n                if x == y { req -= map[y, default: 0] }\\n            }\\n        }\\n        return req\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numFriendRequests(_ ages: [Int]) -> Int {\\n        var req: Int = 0, map: [Int:Int] = [:]\\n        for age in ages {\\n            map[age, default: 0] += 1\\n        }\\n        for y in 1 ... 120 {\\n            for x in 1 ... 120 {\\n                if (Double(y) <= (Double(x) * 0.5 + 7)) || (y > x) || (y > 100 && x < 100) {\\n                    continue\\n                }\\n                req += map[y, default: 0] * map[x, default: 0]\\n                if x == y { req -= map[y, default: 0] }\\n            }\\n        }\\n        return req\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568688,
                "title": "o-n-120-solution",
                "content": "inspired by the solution here  https://leetcode.com/problems/friends-of-appropriate-ages/discuss/2505228/Python-Time%3A-O(max(N-120))-Space-O(1)-Prefixsum-and-Numbersort-Solution\\nI have a different one\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        num_person_by_age = [0 for i in range(121)]\\n        for age in ages:\\n            num_person_by_age[age] += 1\\n        \\n        count = 0\\n        num_person_by_age_presum = [0 for i in range(121)]\\n        for age in range(15, 121):\\n            num_person_by_age_presum[age] = num_person_by_age[age]+num_person_by_age_presum[age-1]\\n            \\n        for age in range(15, 121):\\n            if num_person_by_age[age] == 0:\\n                continue\\n            limit = age // 2 + 7\\n            num_request = (num_person_by_age_presum[age-1] - num_person_by_age_presum[limit] )*num_person_by_age[age]\\n            count += num_request + num_person_by_age[age] * (num_person_by_age[age]-1)\\n         \\n        return count\\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        num_person_by_age = [0 for i in range(121)]\\n        for age in ages:\\n            num_person_by_age[age] += 1\\n        \\n        count = 0\\n        num_person_by_age_presum = [0 for i in range(121)]\\n        for age in range(15, 121):\\n            num_person_by_age_presum[age] = num_person_by_age[age]+num_person_by_age_presum[age-1]\\n            \\n        for age in range(15, 121):\\n            if num_person_by_age[age] == 0:\\n                continue\\n            limit = age // 2 + 7\\n            num_request = (num_person_by_age_presum[age-1] - num_person_by_age_presum[limit] )*num_person_by_age[age]\\n            count += num_request + num_person_by_age[age] * (num_person_by_age[age]-1)\\n         \\n        return count\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2567097,
                "title": "friends-of-appropiate-ages",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def  friendRequest(a, b):\\n            if b <=  .5 * a + 7:\\n                return False\\n            if b > a:\\n                return False\\n            return True\\n        \\n        age_groups = collections.Counter(ages)\\n        total_request =  0\\n        for a, num_a in age_groups.items():\\n            for b, num_b in age_groups.items():\\n                if friendRequest(a, b):\\n                    total_request += num_a * num_b\\n                    if a == b :\\n                        total_request -= num_a\\n        return total_request\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def  friendRequest(a, b):\\n            if b <=  .5 * a + 7:\\n                return False\\n            if b > a:\\n                return False\\n            return True\\n        \\n        age_groups = collections.Counter(ages)\\n        total_request =  0\\n        for a, num_a in age_groups.items():\\n            for b, num_b in age_groups.items():\\n                if friendRequest(a, b):\\n                    total_request += num_a * num_b\\n                    if a == b :\\n                        total_request -= num_a\\n        return total_request\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562864,
                "title": "python-prefix-sum-deque-easy-understanding",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \"\"\"\\n        1. age[y] <= 0.5 * age[x] + 7: set the left bound\\n        2. age[y] > age[x]: check smaller prefix sum\\n        3. age[y] > 100 && age[x] < 100: no need if we check smaller prefix sum\\n        \"\"\"\\n        c = collections.Counter(ages)\\n        inPresum = deque() # the window that \"key\" will send request to\\n        preSum = 0 # count of people of inPresum\\n        ans = 0\\n        for key in sorted(c):\\n            # check left bound\\n            while inPresum and inPresum[0] <= 0.5 * key + 7:\\n                preSum -= c[inPresum.popleft()]\\n            \\n            currCount = c[key]\\n            # request between same ages\\n\\t\\t\\t# note: also need to check condition 1 here\\n            if currCount > 1 and key > (0.5 * key + 7):\\n                combination = math.factorial(currCount) // (2 * math.factorial(currCount-2) ) \\n                ans += combination * 2\\n            ans += currCount * preSum\\n            \\n            preSum += currCount\\n            inPresum.append(key)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \"\"\"\\n        1. age[y] <= 0.5 * age[x] + 7: set the left bound\\n        2. age[y] > age[x]: check smaller prefix sum\\n        3. age[y] > 100 && age[x] < 100: no need if we check smaller prefix sum\\n        \"\"\"\\n        c = collections.Counter(ages)\\n        inPresum = deque() # the window that \"key\" will send request to\\n        preSum = 0 # count of people of inPresum\\n        ans = 0\\n        for key in sorted(c):\\n            # check left bound\\n            while inPresum and inPresum[0] <= 0.5 * key + 7:\\n                preSum -= c[inPresum.popleft()]\\n            \\n            currCount = c[key]\\n            # request between same ages\\n\\t\\t\\t# note: also need to check condition 1 here\\n            if currCount > 1 and key > (0.5 * key + 7):\\n                combination = math.factorial(currCount) // (2 * math.factorial(currCount-2) ) \\n                ans += combination * 2\\n            ans += currCount * preSum\\n            \\n            preSum += currCount\\n            inPresum.append(key)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531829,
                "title": "c-hashing-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool request(int a,int b)\\n    {\\n        return !(a<=0.5*b+7||a>b||a>100&&b<100);\\n    }\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        unordered_map<int,int> m;\\n        int ans=0;\\n        for(auto &a:ages)\\n        {\\n            m[a]++;\\n        }\\n        for(auto &a:m)\\n        {\\n            for(auto &b:m)\\n            {\\n                if(request(a.first,b.first))\\n                {\\n                    ans+=a.second*(b.second-(a.first==b.first?1:0));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool request(int a,int b)\\n    {\\n        return !(a<=0.5*b+7||a>b||a>100&&b<100);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2459938,
                "title": "clean-o-n-solution-beat-100",
                "content": "```\\n public int numFriendRequests(int[] ages) {\\n    int[] cnt = new int[121];\\n    for(int age: ages){\\n      cnt[age]++;\\n    }\\n    int[] presum = new int[cnt.length];\\n    for(int i=1; i< presum.length; i++){\\n      presum[i] = presum[i-1] + cnt[i];\\n    }\\n    int sum  =0;\\n    for(int age =1 ; age< cnt.length; age++){\\n      int c = cnt[age];\\n      if(c ==0 ) continue;\\n      int left = age/2 +7 , right = age; //(left, right]\\n      if(left >= right) continue;\\n      sum +=(presum[right]-1 - presum[left]) * c;\\n    }\\n    return sum;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) {\\n    int[] cnt = new int[121];\\n    for(int age: ages){\\n      cnt[age]++;\\n    }\\n    int[] presum = new int[cnt.length];\\n    for(int i=1; i< presum.length; i++){\\n      presum[i] = presum[i-1] + cnt[i];\\n    }\\n    int sum  =0;\\n    for(int age =1 ; age< cnt.length; age++){\\n      int c = cnt[age];\\n      if(c ==0 ) continue;\\n      int left = age/2 +7 , right = age; //(left, right]\\n      if(left >= right) continue;\\n      sum +=(presum[right]-1 - presum[left]) * c;\\n    }\\n    return sum;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2367237,
                "title": "java-simple-solution",
                "content": "```java\\nclass Solution {\\n    static int upperBound(int arr[], int target) {\\n        int l = 0, h = arr.length - 1;\\n        for (; l <= h;) {\\n            int mid = (l + h) >> 1;\\n            if (arr[mid] <= target)\\n                l = mid + 1;\\n            else\\n                h = mid - 1;\\n        }\\n        return l;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        long ans = 0;\\n        Arrays.sort(ages);\\n\\t\\t// traversing order doesn\\'t matter as we are doing binary-search in whole array\\n\\t\\t// you can traverse from left side also\\n        for(int i = ages.length - 1;i >= 0;--i){\\n            int k = upperBound(ages,ages[i] / 2 + 7);\\n            int t = upperBound(ages,ages[i]);\\n            ans += Math.max(0,t - k - 1);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    static int upperBound(int arr[], int target) {\\n        int l = 0, h = arr.length - 1;\\n        for (; l <= h;) {\\n            int mid = (l + h) >> 1;\\n            if (arr[mid] <= target)\\n                l = mid + 1;\\n            else\\n                h = mid - 1;\\n        }\\n        return l;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        long ans = 0;\\n        Arrays.sort(ages);\\n\\t\\t// traversing order doesn\\'t matter as we are doing binary-search in whole array\\n\\t\\t// you can traverse from left side also\\n        for(int i = ages.length - 1;i >= 0;--i){\\n            int k = upperBound(ages,ages[i] / 2 + 7);\\n            int t = upperBound(ages,ages[i]);\\n            ans += Math.max(0,t - k - 1);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564622,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1564837,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1565764,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1570680,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 2014524,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1574850,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1573685,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 2070855,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            }
        ]
    },
    {
        "title": "Monthly Transactions I",
        "question_content": "<p>Table: <code>Transactions</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| country       | varchar |\n| state         | enum    |\n| amount        | int     |\n| trans_date    | date    |\n+---------------+---------+\nid is the primary key of this table.\nThe table has information about incoming transactions.\nThe state column is an enum of type [&quot;approved&quot;, &quot;declined&quot;].\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The query result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTransactions table:\n+------+---------+----------+--------+------------+\n| id   | country | state    | amount | trans_date |\n+------+---------+----------+--------+------------+\n| 121  | US      | approved | 1000   | 2018-12-18 |\n| 122  | US      | declined | 2000   | 2018-12-19 |\n| 123  | US      | approved | 2000   | 2019-01-01 |\n| 124  | DE      | approved | 2000   | 2019-01-07 |\n+------+---------+----------+--------+------------+\n<strong>Output:</strong> \n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |\n| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |\n| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n</pre>\n",
        "solutions": [
            {
                "id": 396359,
                "title": "simple-sql",
                "content": "```\\nSELECT \\nLEFT(trans_date, 7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\nLEFT(trans_date, 7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3756098,
                "title": "step-by-step-detailed-solution-easy-to-understand-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA beginner friendly answer is written by following basic concepts step by step.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLooking at the result table we write the basic select statement\\nSELECT ___ as month, country, __ as trans_count, __ as approved_count, ___ as trans_total_amount,___ as approved_total_amount\\nFROM Transactions\\n\\nNow we form the solution column by column, starting from month.\\nAs the month column contains only a part (year and month) from trans_date column in Transactions, we use SUBSTR() function to select a substring of trans_date starting from index 1 and going upto 7th index: SUBSTR(trans_date,1,7) as month.\\nWe modify the select statement as\\nSELECT SUBSTR(trans_date,1,7) as month, country, __ as trans_count, __ as approved_count, ___ as trans_total_amount,___ as approved_total_amount\\nFROM Transactions\\n\\nNow, we go for trans_count column (as country column is as it is taken from table Transactions), looking at the result table, we need to count the number of transections per month in a country so, we count transaction ids and GROUP them by month and country.\\nThe code will look like this now\\nSELECT SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, __ as approved_count, ___ as trans_total_amount,___ as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n\\nNow for next approved_count column, we need to check if the state of transection is \"approved\" if yes then we count else we don\\'t. For this here we used CASE statement along with SUM() function as follows:\\nSUM(CASE WHEN state = \\'approved\\' then 1 else 0 END).\\nLastly, modify the select statement by adding: \\nSUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count\\n\\nNow for trans_total_amount, as we have already grouped transactions based on month and country so, we can directly write trans_total_amount column as SUM(amount). \\nNow updated select statement will look like this:\\nSELECT  SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count, SUM(amount) as trans_total_amount, ___ as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n\\nAs we wrote the condition for approved_count column similarly, we \\ncan write for approved_total_amount. The only difference is instead of adding 1, in case the state = \\'approved\\', we add transaction amount: SUM(CASE WHEN state = \\'approved\\' then amount else 0 END).\\n\\nThus the final code becomes\\nSELECT  SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' then amount else 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n\\n# Complexity\\n- Runtime: 927 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Beats: 92.67%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT  SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' then amount else 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```\\nIf you like my explanation kindly upvote for me :)",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT  SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' then amount else 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386961,
                "title": "simple-mysql",
                "content": "```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(id) AS trans_count,\\n    COUNT(IF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(IF(state=\\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(id) AS trans_count,\\n    COUNT(IF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(IF(state=\\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671116,
                "title": "easy-approach-explained-sql",
                "content": "\\n\\n# Intuition\\n \\uD83D\\uDCA1To solve this problem, we can use SQL aggregation functions like COUNT and SUM to calculate the desired values. We need to group the transactions by month and country to perform the necessary calculations.\\n\\n# Approach\\n \\uD83D\\uDD0D Here is the step-by-step approach to solve the problem:\\n\\n1. Write a SELECT statement to specify the desired columns.\\n2. Use the DATE_FORMAT function to extract the month from the `trans_date` column and assign it an alias.\\n3. Include the country column.\\n4. Use COUNT(*) to calculate the total number of transactions for each group.\\n5. Use SUM and an IF statement to calculate the number of approved transactions for each group.\\n6. Use SUM to calculate the total amount of transactions for each group.\\n7. Use SUM and an IF statement to calculate the total amount of approved transactions for each group.\\n8. Specify the table name in the FROM clause.\\n9. Use the GROUP BY clause to group the data by month and country.\\n\\n# SQL Solution\\n\\n\\n\\uD83D\\uDCBBThe SQL code implementing the above approach is as follows:\\n\\n> Feel free to post your doubts in the comment section :)\\n\\n```sql\\nSELECT\\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n  country,\\n  COUNT(*) AS trans_count,\\n  SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n```\\n\\n\\u2728 This solution efficiently calculates the required information by utilizing SQL aggregation functions and grouping the data appropriately. The use of conditional statements within the SUM function allows us to selectively include transactions based on their state (approved or declined).\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT\\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n  country,\\n  COUNT(*) AS trans_count,\\n  SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540365,
                "title": "mysql-solution-for-monthly-transactions-i-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given SQL query aims to retrieve aggregated information about transactions, including the count and total amount, grouped by month and country. It also calculates the count and total amount specifically for transactions with the \\'approved\\' state. The DATE_FORMAT function is used to extract the month from the trans_date column.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The query selects the formatted month (month), country, and calculates several aggregates: trans_count, approved_count, trans_total_amount, and approved_total_amount.\\n1. The trans_count represents the count of transactions in each month and country.\\n1. The approved_count represents the count of transactions with the \\'approved\\' state in each month and country.\\n1. The trans_total_amount represents the sum of all transaction amounts in each month and country.\\n1. The approved_total_amount represents the sum of transaction amounts with the \\'approved\\' state in each month and country.\\n1. The query groups the rows by the formatted month and country using the GROUP BY clause.\\n1. The result is a set of rows, where each row represents a unique combination of formatted month and country, along with the corresponding counts and total amounts.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the query depends on the size of the \"Transactions\" table, the number of distinct months and countries, and the efficiency of the database\\'s query execution plan. The query requires scanning the entire \"Transactions\" table, grouping the rows by formatted month and country, and calculating the aggregates. The time complexity can vary, but it typically ranges from linear to quadratic based on the number of rows and the efficiency of index usage.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the query depends on the size of the result set, which is determined by the number of distinct month and country combinations in the \"Transactions\" table. The space required to store the result grows linearly with the number of combinations.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect date_format(trans_date, \\'%Y-%m\\') as month, country, count(*) as trans_count,\\nsum(if(state = \\'approved\\', 1, 0)) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(if(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect date_format(trans_date, \\'%Y-%m\\') as month, country, count(*) as trans_count,\\nsum(if(state = \\'approved\\', 1, 0)) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(if(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2940817,
                "title": "simple-mssql-using-case-when-no-join-needed",
                "content": "\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect \\n    FORMAT(trans_date, \\'yyyy-MM\\') as month, \\n    country, \\n    count(id) as trans_count,\\n    sum(case when state =\\'approved\\' then 1 else 0 end) approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by FORMAT(trans_date, \\'yyyy-MM\\'), country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect \\n    FORMAT(trans_date, \\'yyyy-MM\\') as month, \\n    country, \\n    count(id) as trans_count,\\n    sum(case when state =\\'approved\\' then 1 else 0 end) approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by FORMAT(trans_date, \\'yyyy-MM\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913013,
                "title": "91-21-faster-solution-using-simple-case-statement",
                "content": "```\\nselect\\n      DATE_FORMAT(trans_date,\"%Y-%m\") as month,\\n      country,\\n      count(id) as trans_count,\\n      sum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\n      sum(amount) as trans_total_amount,\\n      sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\n       group by country, month",
                "solutionTags": [],
                "code": "```\\nselect\\n      DATE_FORMAT(trans_date,\"%Y-%m\") as month,\\n      country,\\n      count(id) as trans_count,\\n      sum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\n      sum(amount) as trans_total_amount,\\n      sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\n       group by country, month",
                "codeTag": "Unknown"
            },
            {
                "id": 2181398,
                "title": "mysql-properly-styled-count-if-sum-if-group-by",
                "content": "```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    COUNT(iF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(iF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    COUNT(iF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(iF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3719103,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date ,\\'%Y-%m\\') as month,country ,count(state) as trans_count , SUM(CASE WHEN state=\\'approved \\' then 1 else 0 END) as approved_count   ,sum(amount)as trans_total_amount , sum(Case when state=\\'approved \\' then amount else 0 end ) as approved_total_amount \\n\\nfrom Transactions \\ngroup by DATE_FORMAT(trans_date ,\\'%Y-%m\\'),country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date ,\\'%Y-%m\\') as month,country ,count(state) as trans_count , SUM(CASE WHEN state=\\'approved \\' then 1 else 0 END) as approved_count   ,sum(amount)as trans_total_amount , sum(Case when state=\\'approved \\' then amount else 0 end ) as approved_total_amount \\n\\nfrom Transactions \\ngroup by DATE_FORMAT(trans_date ,\\'%Y-%m\\'),country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037097,
                "title": "easy-mysql-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n\\nFormatting Date: It uses the LEFT(trans_date, 7) function to format the trans_date column, extracting the year and month portion in the format \"YYYY-MM.\"\\n\\nGrouping: The GROUP BY 1, 2 clause groups the rows by the formatted date (month) and the country column. This grouping ensures that we get results for each month and country combination.\\n\\nCounting Total Transactions: COUNT(id) calculates the total number of transactions for each group, giving us the trans_count column.\\n\\nCounting Approved Transactions: SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) is used to count the number of approved transactions within each group. It effectively counts 1 for each row where state is \\'approved\\' and 0 otherwise. This gives us the approved_count column.\\n\\nSumming Total Transaction Amounts: SUM(amount) calculates the total transaction amount for each group, providing the trans_total_amount column.\\n\\nSumming Approved Transaction Amounts: SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) is used to sum the transaction amounts for approved transactions within each group. It adds the amount for each row where state is \\'approved\\' and 0 otherwise, giving us the approved_total_amount column.\\n\\nBy performing these operations within the SELECT statement and properly grouping the results with GROUP BY, the query effectively calculates the number of transactions, the number of approved transactions, and their respective total amounts for each month and country combination in the Transactions table.<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nSELECT LEFT(trans_date, 7) AS month,\\n       country,\\n       COUNT(id) AS trans_count,\\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY 1, 2;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT LEFT(trans_date, 7) AS month,\\n       country,\\n       COUNT(id) AS trans_count,\\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY 1, 2;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871182,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT TO_CHAR(trans_date, \\'YYYY-MM\\') month, country, count(*)\\n\\ntrans_count, SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END)\\n\\napproved_count, SUM(amount)  trans_total_amount, \\n\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) as\\n\\napproved_total_amount FROM Transactions\\n\\nGROUP BY TO_CHAR(trans_date, \\'YYYY-MM\\'), country\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/521f5128-b504-4f64-96e0-0b6ec1cb5b1e_1691311275.1776528.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT TO_CHAR(trans_date, \\'YYYY-MM\\') month, country, count(*)\\n\\ntrans_count, SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END)\\n\\napproved_count, SUM(amount)  trans_total_amount, \\n\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) as\\n\\napproved_total_amount FROM Transactions\\n\\nGROUP BY TO_CHAR(trans_date, \\'YYYY-MM\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2353063,
                "title": "easy-case-when-and-date-format",
                "content": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, \\ncountry, count(id) as trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, \\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by country, month",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, \\ncountry, count(id) as trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, \\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by country, month",
                "codeTag": "Unknown"
            },
            {
                "id": 1113755,
                "title": "straightforward-mysql",
                "content": "```sql\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(state=\"approved\") AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(state=\"approved\") AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632161,
                "title": "simple-sql-solution-javith-sadham-hussain",
                "content": "# Code\\n```\\nSelect left(trans_date, 7) as month, \\n    country,\\n    count(id) as trans_count,\\n    sum(state = \\'approved\\') as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case \\n            when state = \\'approved\\' then amount \\n            else 0\\n        end) as approved_total_amount\\nfrom Transactions \\ngroup by month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect left(trans_date, 7) as month, \\n    country,\\n    count(id) as trans_count,\\n    sum(state = \\'approved\\') as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case \\n            when state = \\'approved\\' then amount \\n            else 0\\n        end) as approved_total_amount\\nfrom Transactions \\ngroup by month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644038,
                "title": "mysql-using-case-when-beats-93",
                "content": "select \\n    date_format(trans_date, \"%Y-%m\") as month,\\n    country,\\n    count(id) as trans_count,\\n    sum(case when state = \"approved\" then 1 else 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state = \"approved\" then amount else 0 end) as approved_total_amount\\n    from Transactions\\n    group by date_format(trans_date, \"%Y-%m\"), country;",
                "solutionTags": [],
                "code": "select \\n    date_format(trans_date, \"%Y-%m\") as month,\\n    country,\\n    count(id) as trans_count,\\n    sum(case when state = \"approved\" then 1 else 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state = \"approved\" then amount else 0 end) as approved_total_amount\\n    from Transactions\\n    group by date_format(trans_date, \"%Y-%m\"), country;",
                "codeTag": "Unknown"
            },
            {
                "id": 3695557,
                "title": "simple-oracle-code-with-a-tip",
                "content": "# Code\\n```\\nselect to_char(trans_date, \\'YYYY-MM\\') as month, country, count(*) as trans_count, \\nsum(case \\n    when state=\\'approved\\' then 1\\n    else 0 end) as approved_count, \\nsum(amount) as trans_total_amount, \\nsum(case\\n    when state=\\'approved\\' then amount\\n    else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by to_char(trans_date, \\'YYYY-MM\\'), country\\n```\\n\\nJust as me, you might have used the `group by` statement as i did, which is: writing `month` in there and wondering why the code is showing run-time error.\\n\\nThis is a problem, and if you have made the same mistake, then remember to write the whole expression and not the alias.\\n** It is a problem in `Oracle` only. `MySQL` donot have this.\\n\\nHope it Helps \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n![image.png](https://assets.leetcode.com/users/images/21da4b20-aba4-4ca8-a33d-8fd87ab71822_1688022940.395717.png)\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect to_char(trans_date, \\'YYYY-MM\\') as month, country, count(*) as trans_count, \\nsum(case \\n    when state=\\'approved\\' then 1\\n    else 0 end) as approved_count, \\nsum(amount) as trans_total_amount, \\nsum(case\\n    when state=\\'approved\\' then amount\\n    else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by to_char(trans_date, \\'YYYY-MM\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589803,
                "title": "optimum-solution-with-step-by-step-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe goal is to obtain aggregated information from the \"Transactions\" table based on the formatted month and country. This includes the total count of transactions, the count of approved transactions, the total transaction amount, and the total amount of approved transactions.\\n\\n# Approach\\n1. Use the **DATE_FORMAT** function in SQL to format the \"trans_date\" column into the desired month format, **\\'%Y-%m\\'**.\\n1. Select the formatted month **(DATE_FORMAT(trans_date, \\'%Y-%m\\'))**, country, and apply various aggregate functions to calculate the desired statistics:\\n1. **count(*)** is used to count the total number of transactions.\\n1. **sum(if(state=\\'approved\\',1,0))** is used to count the number of approved transactions by evaluating a conditional statement.\\n1. **sum(amount)** is used to calculate the total transaction amount.\\n1. **sum(if(state=\\'approved\\',amount,0))** is used to calculate the total amount of approved transactions by evaluating a conditional statement.\\n1. Group the results by the formatted month and country using the GROUP BY clause.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the query depends on the size of the \"Transactions\" table and the efficiency of the database engine. In general, the time complexity is influenced by the performance of indexing, data retrieval, and aggregation operations. Assuming the table is properly indexed, the time complexity can be considered as linear, $$O(n)$$, where n is the number of rows in the \"Transactions\" table.\\n\\n- Space complexity:\\nThe space complexity is determined by the memory required to store the result set of the query. It also depends on the number of distinct formatted month and country combinations present in the \"Transactions\" table. Assuming the result set is stored in memory, the space complexity can be considered linear, $$O(n)$$, where n is the number of distinct formatted month and country combinations in the \"Transactions\" table.\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT \\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n  country, count(*) as trans_count, \\n  sum(if(state=\\'approved\\',1,0)) as approved_count, \\n  sum(amount) as trans_total_amount, \\n  sum(if(state=\\'approved\\',amount,0)) as approved_total_amount \\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/ceb8c03d-74fc-41ae-abd2-c82ba3d36790_1685716714.292304.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT \\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n  country, count(*) as trans_count, \\n  sum(if(state=\\'approved\\',1,0)) as approved_count, \\n  sum(amount) as trans_total_amount, \\n  sum(if(state=\\'approved\\',amount,0)) as approved_total_amount \\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2338360,
                "title": "mysql-solution-with-case-date-fromat-explaination",
                "content": "#create a query that:\\n#extract the yy-mm from transdate\\n#count the number of trans\\n#approved count using case-aggreagate\\n#total amount using sum\\n#total_trans_amount using case-aggregate\\n#and approved total\\n\\n```\\nselect date_format(trans_date, \\'%Y-%m\\') as month,country, count(id) as trans_count, \\nsum(case when state =\\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state =\\'approved\\' then amount else 0 end) as \\'approved_total_amount\\'\\nfrom Transactions\\ngroup by 1,2\\n```",
                "solutionTags": [],
                "code": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month,country, count(id) as trans_count, \\nsum(case when state =\\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state =\\'approved\\' then amount else 0 end) as \\'approved_total_amount\\'\\nfrom Transactions\\ngroup by 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914061,
                "title": "easy-solution-using-decode",
                "content": "# Code\\n```\\nSELECT TO_CHAR(TO_DATE(trans_date, \\'YYYY-MM-DD\\'), \\'YYYY-MM\\') AS month,\\n       country,\\n       COUNT(*) AS trans_count,\\n       SUM(DECODE(state, \\'approved\\', 1, 0)) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(DECODE(state, \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM transactions\\nGROUP BY TO_CHAR(TO_DATE(trans_date, \\'YYYY-MM-DD\\'), \\'YYYY-MM\\'),\\n         country\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT TO_CHAR(TO_DATE(trans_date, \\'YYYY-MM-DD\\'), \\'YYYY-MM\\') AS month,\\n       country,\\n       COUNT(*) AS trans_count,\\n       SUM(DECODE(state, \\'approved\\', 1, 0)) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(DECODE(state, \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM transactions\\nGROUP BY TO_CHAR(TO_DATE(trans_date, \\'YYYY-MM-DD\\'), \\'YYYY-MM\\'),\\n         country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590732,
                "title": "simple-solution-for-oracle-or-postgres",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We could apply built-in function - `TO_CHAR` so as to etract the necessary month. After this we just need to aggregate our records by the appropriate functions in each column.\\n2. In order to obtain the right `SUM` it\\'s common to use `CASE - THEN` statements.\\n\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\n\\nSELECT\\n    TO_CHAR(trans_date, \\'YYYY-MM\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(\\n        CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END\\n    ) AS approved_total_amount\\n\\nFROM \\n    Transactions\\nGROUP BY \\n    TO_CHAR(trans_date, \\'YYYY-MM\\'),\\n    country;\\n\\n```",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\n\\nSELECT\\n    TO_CHAR(trans_date, \\'YYYY-MM\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(\\n        CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END\\n    ) AS approved_total_amount\\n\\nFROM \\n    Transactions\\nGROUP BY \\n    TO_CHAR(trans_date, \\'YYYY-MM\\'),\\n    country;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564645,
                "title": "sql-left-count-coalesce-sum-case-when-group-by-easy-to-understand",
                "content": "# Intuition\\nThe main task is to use the count and sum functions to create columns\\n\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/a7a60aac-46bc-4c11-8d47-aac2563f4389_1685096810.5151806.png)\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\nleft(trans_date,7) as month,\\ncountry,\\ncount(state) as trans_count,\\ncoalesce(sum(case when state = \\'approved\\'then 1 end),0)as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions \\ngroup by left(trans_date,7),country\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\nleft(trans_date,7) as month,\\ncountry,\\ncount(state) as trans_count,\\ncoalesce(sum(case when state = \\'approved\\'then 1 end),0)as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions \\ngroup by left(trans_date,7),country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432044,
                "title": "solution-with-window-function-sql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT distinct\\n\\tleft(convert(nvarchar(100),trans_date,121),7) [Month],\\n\\tcountry,\\n\\tISNULL(COUNT(id) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ),0) trans_count,\\n\\tISNULL(COUNT(IIF(state = \\'approved\\' , id , null)) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_count,\\n\\tISNULL(SUM(amount) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)trans_total_amount,\\n\\tISNULL(SUM(IIF(state = \\'approved\\' , amount , null)) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_total_amount\\nFROM\\t\\n\\tTransactions\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT distinct\\n\\tleft(convert(nvarchar(100),trans_date,121),7) [Month],\\n\\tcountry,\\n\\tISNULL(COUNT(id) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ),0) trans_count,\\n\\tISNULL(COUNT(IIF(state = \\'approved\\' , id , null)) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_count,\\n\\tISNULL(SUM(amount) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)trans_total_amount,\\n\\tISNULL(SUM(IIF(state = \\'approved\\' , amount , null)) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_total_amount\\nFROM\\t\\n\\tTransactions\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1454062,
                "title": "this-is-the-simplest-and-straightforward-you-will-see",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') month,\\n       country,\\n       COUNT(state) trans_count,\\n       SUM(state = \\'approved\\') approved_count,\\n       SUM(amount) trans_total_amount,\\n       SUM(IF(state = \\'approved\\', amount, 0)) approved_total_amount\\nFROM transactions\\nGROUP BY 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') month,\\n       country,\\n       COUNT(state) trans_count,\\n       SUM(state = \\'approved\\') approved_count,\\n       SUM(amount) trans_total_amount,\\n       SUM(IF(state = \\'approved\\', amount, 0)) approved_total_amount\\nFROM transactions\\nGROUP BY 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947615,
                "title": "mysql-solution-using-group-by-faster-than-92-89",
                "content": "```\\nselect\\n    substring(trans_date,1,7) month\\n    ,country\\n    ,count(*) trans_count\\n    ,sum(if(state=\\'approved\\',1,0)) approved_count\\n    ,sum(amount) trans_total_amount\\n    ,sum(if(state=\\'approved\\',amount,0)) approved_total_amount\\nfrom transactions\\ngroup by 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    substring(trans_date,1,7) month\\n    ,country\\n    ,count(*) trans_count\\n    ,sum(if(state=\\'approved\\',1,0)) approved_count\\n    ,sum(amount) trans_total_amount\\n    ,sum(if(state=\\'approved\\',amount,0)) approved_total_amount\\nfrom transactions\\ngroup by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384354,
                "title": "mysql-100-faster",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, COUNT(*) as trans_count, SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, COUNT(*) as trans_count, SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100744,
                "title": "sql-easy-to-understand-solution",
                "content": "\\uD83D\\uDE4F\\uD83D\\uDE4F PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```\\nselect\\ndate_format(trans_date, \\'%Y-%m\\') as month, \\ncountry, \\ncount(id) as trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, \\nsum(amount) as trans_total_amount, \\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\n\\nfrom \\ntransactions\\n\\ngroup by \\ndate_format(trans_date, \\'%Y-%m\\'), country\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\ndate_format(trans_date, \\'%Y-%m\\') as month, \\ncountry, \\ncount(id) as trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, \\nsum(amount) as trans_total_amount, \\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\n\\nfrom \\ntransactions\\n\\ngroup by \\ndate_format(trans_date, \\'%Y-%m\\'), country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612652,
                "title": "all-3-db-query-using-switch-case-and-group-by-and-substring",
                "content": "Idea is to use substring to get first 7 characters of date. rest of the logic is pretty simple by using switch case we can count only approved transactions.\\n\\n# Oracle\\n```\\nselect substr(trans_date,1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount \\nfrom Transactions \\ngroup by substr(trans_date,1,7), country;\\n```\\n\\n# MySql\\n```\\nselect SUBSTRING(trans_date,1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount \\nfrom Transactions \\ngroup by SUBSTRING(trans_date,1,7), country;\\n```\\n\\n# MSSql server\\nHere SUBSTRING method does not support date type as argument and hence formatting needed\\n```\\nselect SUBSTRING(format(trans_date,\\'yyyy-MM-dd hh:mm:ss tt\\'),1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions \\ngroup by SUBSTRING(format(trans_date,\\'yyyy-MM-dd hh:mm:ss tt\\'),1,7), country;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect substr(trans_date,1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount \\nfrom Transactions \\ngroup by substr(trans_date,1,7), country;\\n```\n```\\nselect SUBSTRING(trans_date,1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount \\nfrom Transactions \\ngroup by SUBSTRING(trans_date,1,7), country;\\n```\n```\\nselect SUBSTRING(format(trans_date,\\'yyyy-MM-dd hh:mm:ss tt\\'),1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions \\ngroup by SUBSTRING(format(trans_date,\\'yyyy-MM-dd hh:mm:ss tt\\'),1,7), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611657,
                "title": "solution-with-simple-query-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT distinct\\n\\tleft(trans_date,7) Month,\\n\\tcountry,\\n\\tIFNULL(COUNT(id) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ),0) trans_count,\\n\\tIFNULL(COUNT(CASE WHEN state = \\'approved\\' THEN id ELSE  null END ) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_count,\\n\\tIFNULL(SUM(amount) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)trans_total_amount,\\n\\tIFNULL(SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE null END ) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_total_amount\\nFROM\\t\\n\\tTransactions\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT distinct\\n\\tleft(trans_date,7) Month,\\n\\tcountry,\\n\\tIFNULL(COUNT(id) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ),0) trans_count,\\n\\tIFNULL(COUNT(CASE WHEN state = \\'approved\\' THEN id ELSE  null END ) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_count,\\n\\tIFNULL(SUM(amount) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)trans_total_amount,\\n\\tIFNULL(SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE null END ) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_total_amount\\nFROM\\t\\n\\tTransactions\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282348,
                "title": "simple-mysql-solution-using-case-when-statement",
                "content": "```\\nSELECT LEFT(trans_date ,7) as month,country,\\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 else 0 end) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount else 0 end) as approved_total_amount\\nfrom Transactions GROUP BY month,country\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT LEFT(trans_date ,7) as month,country,\\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 else 0 end) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount else 0 end) as approved_total_amount\\nfrom Transactions GROUP BY month,country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200214,
                "title": "simple-case-when-solution-sql-server",
                "content": "select left(trans_date,7) as month, country,count(id) as trans_count,\\nCount(case when state = \\'approved\\' then 1 else null end) as approved_count,\\nsum(amount) as trans_total_amount ,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by left(trans_date,7), country",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "select left(trans_date,7) as month, country,count(id) as trans_count,\\nCount(case when state = \\'approved\\' then 1 else null end) as approved_count,\\nsum(amount) as trans_total_amount ,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by left(trans_date,7), country",
                "codeTag": "Unknown"
            },
            {
                "id": 2143037,
                "title": "simple-mysql-case-and-date-format",
                "content": "```\\nselect date_format(trans_date, \"%Y-%m\") month,\\n       country,\\n       count(id) trans_count,\\n       sum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\n       sum(amount) trans_total_amount,\\n       sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date, \"%Y-%m\"), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect date_format(trans_date, \"%Y-%m\") month,\\n       country,\\n       count(id) trans_count,\\n       sum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\n       sum(amount) trans_total_amount,\\n       sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date, \"%Y-%m\"), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068821,
                "title": "mysql-case-when-simple-faster-that-85",
                "content": "```\\nSELECT      DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, # NOTE m IS NOT CAPITAL\\n            country,\\n            COUNT(amount) AS trans_count,\\n            COUNT(CASE WHEN state = \\'approved\\' THEN amount END) AS approved_count,\\n            IFNULL(SUM(amount),0) AS trans_total_amount,\\n            IFNULL(SUM(CASE WHEN state = \\'approved\\' THEN amount END),0) AS approved_total_amount\\nFROM        Transactions \\nGROUP BY    MONTH(trans_date), country\\n            \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT      DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, # NOTE m IS NOT CAPITAL\\n            country,\\n            COUNT(amount) AS trans_count,\\n            COUNT(CASE WHEN state = \\'approved\\' THEN amount END) AS approved_count,\\n            IFNULL(SUM(amount),0) AS trans_total_amount,\\n            IFNULL(SUM(CASE WHEN state = \\'approved\\' THEN amount END),0) AS approved_total_amount\\nFROM        Transactions \\nGROUP BY    MONTH(trans_date), country\\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982834,
                "title": "mysql-multiple-solutions-using-date-format-count-sum-and-if",
                "content": "1. We first select from the `Transactions` table.\\n\\n```\\nSELECT *\\nFROM Transactions\\n```\\n\\n2. We need to group by month and country. We can use `DATE_FORMAT` to extract both the year and month. I have also seen someone use `LEFT(trans_date, 7)` in place of `DATE_FORMAT`.\\n\\n```\\nSELECT\\n\\tDATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```\\n\\n3. We use `COUNT`, `SUM` and `IF` to do computations per group for the remaining columns:\\n\\t* **The number of transactions**: We count rows with `COUNT` and label this `trans_count`.\\n\\t* **The total amount**: We sum the amount column with `SUM` and label this `trans_total_amount`.\\n\\t* **The number of approved transactions**: We label this `approved_count`. As for the computation, we have some options:\\n\\t\\t1. `COUNT(IF(state = \\'approved\\', 1, NULL))` \\n\\t\\t\\t- We have to use `NULL` instead of 0 here, since `COUNT` will count everything except for `NULL`. `COUNT(1)` would achieve the same as `COUNT(0)`, or even `COUNT(\\'insert anything here\\')`.\\n\\t\\t2. `SUM(IF(state = \\'approved\\', 1, 0))` \\n\\t\\t\\t- If you want to use 0 instead of `NULL` like described above, you can do so but wrap the `IF` statement with `SUM` instead of `COUNT`.\\n\\t\\t3. `SUM(state = \\'approved\\')` \\n\\t\\t\\t- Since `state=\\'approved\\'` is of type Boolean, we either have true or false values, or in computation, 1 or 0 respectively. So in essense we a summing a bunch of 1s and 0s like the option right above this one.\\n\\t\\t4. `IF` statements above can also be replaced with `CASE WHEN THEN ELSE END`.\\n\\t* **The total amount for approved transactions**: We label this `approved_total_amount`. As for the computation, we have some options:\\n\\t\\t1. `SUM(IF(state = \\'approved\\', amount, 0))`\\n\\t\\t\\t- We only want to include the amount in the sum of amounts if the transaction state is approved. Otherwise its value should be 0 in the sum.\\n\\t\\t2. `SUM((state = \\'approved\\') * amount)`\\n\\t\\t\\t- We can also include or exclude the amount in the sum by multiplying it by 1 if it is approved or 0 if not approved, which means we can multiple by `state = \\'approved\\'`. \\n\\t\\t3. `IF` statements above can also be replaced with `CASE WHEN THEN ELSE END`.\\n\\n```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    COUNT(IF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n\\tSUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT *\\nFROM Transactions\\n```\n```\\nSELECT\\n\\tDATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```\n```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    COUNT(IF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n\\tSUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532891,
                "title": "mysql-solution-straight-forward-using-groupby-and-case-faster-than-93",
                "content": "```\\nSELECT\\n    LEFT(trans_date, 7) as month,\\n    country,\\n    COUNT(*) as trans_count,\\n    COUNT(CASE WHEN state = \\'approved\\' THEN 1 ELSE NULL END) as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY 1,2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    LEFT(trans_date, 7) as month,\\n    country,\\n    COUNT(*) as trans_count,\\n    COUNT(CASE WHEN state = \\'approved\\' THEN 1 ELSE NULL END) as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517408,
                "title": "dateformat-sum-count-year-month",
                "content": "Similar to other answers\\n```\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month,\\n    country,\\n    COUNT(amount) AS trans_count,\\n    SUM(state = \\'approved\\') AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(amount * (state = \\'approved\\')) AS approved_total_amount\\nFROM transactions\\nGROUP BY YEAR(trans_date), MONTH(trans_date), country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month,\\n    country,\\n    COUNT(amount) AS trans_count,\\n    SUM(state = \\'approved\\') AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(amount * (state = \\'approved\\')) AS approved_total_amount\\nFROM transactions\\nGROUP BY YEAR(trans_date), MONTH(trans_date), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007814,
                "title": "beats-90-08-of-users-with-ms-sql-server",
                "content": "# Code\\n```\\n\\nselect\\n  LEFT(t.trans_date, \\'7\\') month,\\n  t.country country,\\n  count(*) trans_count,\\n  sum(t.amount) trans_total_amount,\\n  SUM(CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(CASE WHEN t.state = \\'approved\\' THEN t.amount ELSE 0 END) AS approved_total_amount\\n\\n\\nfrom [Transactions] t\\ngroup by LEFT(t.trans_date, \\'7\\'), t.country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n\\nselect\\n  LEFT(t.trans_date, \\'7\\') month,\\n  t.country country,\\n  count(*) trans_count,\\n  sum(t.amount) trans_total_amount,\\n  SUM(CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(CASE WHEN t.state = \\'approved\\' THEN t.amount ELSE 0 END) AS approved_total_amount\\n\\n\\nfrom [Transactions] t\\ngroup by LEFT(t.trans_date, \\'7\\'), t.country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876760,
                "title": "easy-sql-solution",
                "content": "\\n# Code\\n```\\nSELECT TO_CHAR(TRANS_DATE, \\'YYYY-MM\\') AS MONTH, \\nCOUNTRY, COUNT(*) AS TRANS_COUNT, \\nSUM(CASE WHEN STATE=\\'approved\\' THEN 1 ELSE 0 END) AS APPROVED_COUNT, \\nSUM(AMOUNT) AS TRANS_TOTAL_AMOUNT, \\nSUM(CASE WHEN STATE=\\'approved\\' THEN AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT FROM TRANSACTIONS GROUP BY TO_CHAR(TRANS_DATE, \\'YYYY-MM\\'), COUNTRY;\\n```",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\nSELECT TO_CHAR(TRANS_DATE, \\'YYYY-MM\\') AS MONTH, \\nCOUNTRY, COUNT(*) AS TRANS_COUNT, \\nSUM(CASE WHEN STATE=\\'approved\\' THEN 1 ELSE 0 END) AS APPROVED_COUNT, \\nSUM(AMOUNT) AS TRANS_TOTAL_AMOUNT, \\nSUM(CASE WHEN STATE=\\'approved\\' THEN AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT FROM TRANSACTIONS GROUP BY TO_CHAR(TRANS_DATE, \\'YYYY-MM\\'), COUNTRY;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601114,
                "title": "easiest-solution-with-explanation-best-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly, we format the date in the required format by using **DATE_FORMAT()** function and giving the format **\\'%Y-%m\\'** as argument.\\n- We use **if() conditional statement** to sum the **number of times the transaction is approved** and then again to find the **total_approved_amount**.\\n- We group the output by the format of month we obtained and also the country because the **question asks us to find the output for each month and country**.\\nP.S : It is very important to understand GROUP BY clause and its application as it is used very often in SQL.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the required columns by solving them as described in the intuition section.\\n2. In the FROM statement, we write the table name **Transactions**.\\n3. The GROUP BY clause groups the output by **month and country** because the question asks us to find the output for each month and country.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, COUNT(*) as trans_count,\\n    SUM(if(state=\\'approved\\',1,0)) as approved_count, \\n    SUM(amount) as trans_total_amount, \\n    SUM(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```\\n# Note\\nPlease upvote if you find my solution helpful. If you have any doubts, suggestion or want to discuss any solution, comment it. If you wish to discuss other related topics, feel free to message me on LinkedIn, https://leetcode.com/prathams29/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, COUNT(*) as trans_count,\\n    SUM(if(state=\\'approved\\',1,0)) as approved_count, \\n    SUM(amount) as trans_total_amount, \\n    SUM(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733904,
                "title": "two-cte-tables-solution",
                "content": "Originally had this two CTE tables solution, it turned out to be not that efficient...\\n\\n```\\nWITH approve_table AS(\\n    SELECT\\n        DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n        country,\\n    COUNT(state=\\'approved\\') AS approved_count,\\n    sum(amount) AS approved_total_amount\\n    FROM Transactions\\n    WHERE state = \\'approved\\'\\n    GROUP BY country, month\\n),\\ntotal_table AS (\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n    country,\\n    COUNT(*) AS trans_count,\\n    sum(amount) AS trans_total_amount\\nFROM Transactions\\nGROUP BY country, month\\n)\\nSELECT\\n    a.month,\\n    a.country,\\n    t.trans_count,\\n    a.approved_count,\\n    t.trans_total_amount,\\n    a.approved_total_amount\\nFROM \\n    approve_table a\\nJOIN \\n    total_table t\\nON \\n    a.month = t.month\\nAND\\n    a.country = t.country\\n```",
                "solutionTags": [],
                "code": "```\\nWITH approve_table AS(\\n    SELECT\\n        DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n        country,\\n    COUNT(state=\\'approved\\') AS approved_count,\\n    sum(amount) AS approved_total_amount\\n    FROM Transactions\\n    WHERE state = \\'approved\\'\\n    GROUP BY country, month\\n),\\ntotal_table AS (\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n    country,\\n    COUNT(*) AS trans_count,\\n    sum(amount) AS trans_total_amount\\nFROM Transactions\\nGROUP BY country, month\\n)\\nSELECT\\n    a.month,\\n    a.country,\\n    t.trans_count,\\n    a.approved_count,\\n    t.trans_total_amount,\\n    a.approved_total_amount\\nFROM \\n    approve_table a\\nJOIN \\n    total_table t\\nON \\n    a.month = t.month\\nAND\\n    a.country = t.country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540887,
                "title": "my-sql-solution",
                "content": "select SUBSTRING(trans_date,1,7) as month,country,count(id) as trans_count,sum(if(state = \\'approved\\', 1, 0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state = \\'approved\\', amount, 0)) as approved_total_amount from Transactions group by month, country",
                "solutionTags": [],
                "code": "select SUBSTRING(trans_date,1,7) as month,country,count(id) as trans_count,sum(if(state = \\'approved\\', 1, 0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state = \\'approved\\', amount, 0)) as approved_total_amount from Transactions group by month, country",
                "codeTag": "Unknown"
            },
            {
                "id": 2482941,
                "title": "monthly-transactions",
                "content": "\\nselect a.month,a.country,a.trans_count,ifnull(b.approved_count,0) approved_count  ,a.trans_total_amount,ifnull(b.approved_total_amount,0) approved_total_amount\\nfrom\\n(\\nselect substring(trans_date,1,7) as \\'month\\' , country, sum(amount) as \\'trans_total_amount\\' ,count(1) as\\' trans_count\\' from Transactions  \\ngroup by substring(trans_date,1,7),country\\n) a\\nLEFT JOIN  \\n(\\nselect substring(trans_date,1,7) as \\'month\\' , country, ifnull(sum(amount),0) as \\'approved_total_amount\\',count(1) as \\'approved_count\\' from Transactions \\nwhere state     = \\'approved\\' \\ngroup by substring(trans_date,1,7),country\\n) b\\n\\non \\na.month = b.month \\nand  a.country = b.country \\n",
                "solutionTags": [],
                "code": "\\nselect a.month,a.country,a.trans_count,ifnull(b.approved_count,0) approved_count  ,a.trans_total_amount,ifnull(b.approved_total_amount,0) approved_total_amount\\nfrom\\n(\\nselect substring(trans_date,1,7) as \\'month\\' , country, sum(amount) as \\'trans_total_amount\\' ,count(1) as\\' trans_count\\' from Transactions  \\ngroup by substring(trans_date,1,7),country\\n) a\\nLEFT JOIN  \\n(\\nselect substring(trans_date,1,7) as \\'month\\' , country, ifnull(sum(amount),0) as \\'approved_total_amount\\',count(1) as \\'approved_count\\' from Transactions \\nwhere state     = \\'approved\\' \\ngroup by substring(trans_date,1,7),country\\n) b\\n\\non \\na.month = b.month \\nand  a.country = b.country \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2376501,
                "title": "simple-mysql-using-sum-and-if",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month, \\n       country, \\n       COUNT(*) AS trans_count,\\n       SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \"%Y-%m\"), country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month, \\n       country, \\n       COUNT(*) AS trans_count,\\n       SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \"%Y-%m\"), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2310655,
                "title": "mysql-solution",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, SUM(1) AS trans_count,\\n    SUM(IF(state = \"approved\", 1, 0)) AS approved_count,\\n    SUM(amount) as trans_total_amount , SUM(IF(state = \"approved\", amount, 0)) AS approved_total_amount \\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, SUM(1) AS trans_count,\\n    SUM(IF(state = \"approved\", 1, 0)) AS approved_count,\\n    SUM(amount) as trans_total_amount , SUM(IF(state = \"approved\", amount, 0)) AS approved_total_amount \\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248311,
                "title": "oracle-count-sum-decode-group-by-faster-than-100",
                "content": "/* Write your PL/SQL query statement below */\\nselect to_char(trans_date,\\'YYYY-MM\\') as month,\\n    country,\\n    count(*) as trans_count,\\n    count(decode(state,\\'approved\\',state,null)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(decode(state,\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),\\n    country\\norder by 1,2;",
                "solutionTags": [],
                "code": "/* Write your PL/SQL query statement below */\\nselect to_char(trans_date,\\'YYYY-MM\\') as month,\\n    country,\\n    count(*) as trans_count,\\n    count(decode(state,\\'approved\\',state,null)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(decode(state,\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),\\n    country\\norder by 1,2;",
                "codeTag": "Unknown"
            },
            {
                "id": 2128104,
                "title": "combining-aggregate-with-conditional",
                "content": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, \\n    country,\\n    count(id) as \\'trans_count\\',\\n    count(if(state=\\'approved\\',id,null)) as \\'approved_count\\',\\n    sum(amount) as \\'trans_total_amount\\',\\n    sum(if(state=\\'approved\\', amount, 0)) as \\'approved_total_amount\\'\\nfrom transactions\\ngroup by month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, \\n    country,\\n    count(id) as \\'trans_count\\',\\n    count(if(state=\\'approved\\',id,null)) as \\'approved_count\\',\\n    sum(amount) as \\'trans_total_amount\\',\\n    sum(if(state=\\'approved\\', amount, 0)) as \\'approved_total_amount\\'\\nfrom transactions\\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060906,
                "title": "mysql-group-by-and-join",
                "content": "WITH tx_month_table AS\\n(\\nSELECT country, state, amount, DATE_FORMAT(trans_date, \"%Y-%m\") AS month_year\\nFROM Transactions\\n),\\n\\napproved_transactions AS\\n(\\nSELECT month_year, country, SUM(amount) AS approved_total_amount, COUNT(*) AS approved_count\\nFROM tx_month_table\\nWHERE state = \"approved\"\\nGROUP BY month_year, country\\n),\\n\\nall_transactions AS\\n(\\nSELECT month_year, country, SUM(amount) AS trans_total_amount, COUNT(*) AS trans_count\\nFROM tx_month_table \\nGROUP BY month_year, country\\n)\\n\\nSELECT a.month_year AS month, a.country, trans_count, \\n(CASE WHEN approved_count IS NULL THEN 0 ELSE approved_count END) AS approved_count,\\ntrans_total_amount, \\n(CASE WHEN approved_total_amount IS NULL THEN 0 ELSE approved_total_amount END) AS approved_total_amount\\nFROM all_transactions a\\nLEFT JOIN approved_transactions  b\\nON a.month_year=b.month_year AND a.country=b.country;\\n",
                "solutionTags": [],
                "code": "WITH tx_month_table AS\\n(\\nSELECT country, state, amount, DATE_FORMAT(trans_date, \"%Y-%m\") AS month_year\\nFROM Transactions\\n),\\n\\napproved_transactions AS\\n(\\nSELECT month_year, country, SUM(amount) AS approved_total_amount, COUNT(*) AS approved_count\\nFROM tx_month_table\\nWHERE state = \"approved\"\\nGROUP BY month_year, country\\n),\\n\\nall_transactions AS\\n(\\nSELECT month_year, country, SUM(amount) AS trans_total_amount, COUNT(*) AS trans_count\\nFROM tx_month_table \\nGROUP BY month_year, country\\n)\\n\\nSELECT a.month_year AS month, a.country, trans_count, \\n(CASE WHEN approved_count IS NULL THEN 0 ELSE approved_count END) AS approved_count,\\ntrans_total_amount, \\n(CASE WHEN approved_total_amount IS NULL THEN 0 ELSE approved_total_amount END) AS approved_total_amount\\nFROM all_transactions a\\nLEFT JOIN approved_transactions  b\\nON a.month_year=b.month_year AND a.country=b.country;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2036361,
                "title": "runtime-1445-ms-faster-than-98-80-of-ms-sql-server",
                "content": "\\n```\\nSelect \\n    month = CONVERT(char(7), trans_date,126)\\n    ,country\\n    ,trans_count = count(id)\\n    ,approved_count = SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END)\\n    ,trans_total_amount = SUM(amount)\\n    ,approved_total_amount = SUM(CASE WHEN state = \\'approved\\' then amount else 0 END)\\nFROM Transactions\\nGroup By CONVERT(char(7), trans_date,126), country\\n```",
                "solutionTags": [],
                "code": "```\\nSelect \\n    month = CONVERT(char(7), trans_date,126)\\n    ,country\\n    ,trans_count = count(id)\\n    ,approved_count = SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END)\\n    ,trans_total_amount = SUM(amount)\\n    ,approved_total_amount = SUM(CASE WHEN state = \\'approved\\' then amount else 0 END)\\nFROM Transactions\\nGroup By CONVERT(char(7), trans_date,126), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015003,
                "title": "accepted-mysql-if-solution",
                "content": "```\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month\\n        , country\\n        , count(*) as trans_count\\n        , sum(IF(state = \\'approved\\', 1, 0)) as approved_count\\n        , SUM(amount) as trans_total_amount\\n        , sum(IF(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by \\n        DATE_FORMAT(trans_date, \\'%Y-%m\\')\\n        , country\\nORDER BY month\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month\\n        , country\\n        , count(*) as trans_count\\n        , sum(IF(state = \\'approved\\', 1, 0)) as approved_count\\n        , SUM(amount) as trans_total_amount\\n        , sum(IF(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by \\n        DATE_FORMAT(trans_date, \\'%Y-%m\\')\\n        , country\\nORDER BY month\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1972318,
                "title": "accepted-solution-for-mysql-very-easy-code",
                "content": "```\\nSELECT DATE_FORMAT(trans_date,\"%Y-%m\") AS month,country, COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count, SUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month,country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DATE_FORMAT(trans_date,\"%Y-%m\") AS month,country, COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count, SUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month,country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959726,
                "title": "simple-and-easiest-mysql-solution",
                "content": "```\\nselect LEFT(trans_date, 7) as month, country, \\nCOUNT(*) as trans_count,\\nSUM(state = \"approved\") as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(IF(state = \"approved\", amount, 0)) as approved_total_amount\\nfrom transactions\\ngroup by LEFT(trans_date, 7), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect LEFT(trans_date, 7) as month, country, \\nCOUNT(*) as trans_count,\\nSUM(state = \"approved\") as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(IF(state = \"approved\", amount, 0)) as approved_total_amount\\nfrom transactions\\ngroup by LEFT(trans_date, 7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933488,
                "title": "why-it-is-wrong",
                "content": "select date_format (trans_date,\\'%Y-%m\\') as month,country,\\ncount(id)as trans_count,*count(state=\\'approved\\')as approved_count,*sum(amount) as trans_total_amount,sum((state=\\'approved\\')*amount)as approved_total_amount\\nfrom transactions\\n\\nwhy we cannot use count(state=\\'approved\\') as approved_account to get the same answer???",
                "solutionTags": [],
                "code": "select date_format (trans_date,\\'%Y-%m\\') as month,country,\\ncount(id)as trans_count,*count(state=\\'approved\\')as approved_count,*sum(amount) as trans_total_amount,sum((state=\\'approved\\')*amount)as approved_total_amount\\nfrom transactions\\n\\nwhy we cannot use count(state=\\'approved\\') as approved_account to get the same answer???",
                "codeTag": "Unknown"
            },
            {
                "id": 1926531,
                "title": "simple-solution-with-date-format-99-1-faster",
                "content": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, country,\\ncount(amount) as trans_count, sum(state=\\'approved\\') as approved_count, \\nsum(amount) as trans_total_amount, sum((state=\\'approved\\')*amount) as approved_total_amount  \\nfrom Transactions\\ngroup by month, country\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, country,\\ncount(amount) as trans_count, sum(state=\\'approved\\') as approved_count, \\nsum(amount) as trans_total_amount, sum((state=\\'approved\\')*amount) as approved_total_amount  \\nfrom Transactions\\ngroup by month, country\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897469,
                "title": "mysql-simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\n\\nselect date_format(trans_date, \\'%Y-%m\\') as month,\\n       country,\\n       count(1) as trans_count,\\n       sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\n       sum(amount) as trans_total_amount,\\n       sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by 1, 2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect date_format(trans_date, \\'%Y-%m\\') as month,\\n       country,\\n       count(1) as trans_count,\\n       sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\n       sum(amount) as trans_total_amount,\\n       sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891920,
                "title": "mysql-sum-with-case-when",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\', \\n        country,\\n        COUNT(id) AS \\'trans_count\\',\\n        SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS \\'approved_count\\',\\n        SUM(amount) AS \\'trans_total_amount\\',\\n        SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\', \\n        country,\\n        COUNT(id) AS \\'trans_count\\',\\n        SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS \\'approved_count\\',\\n        SUM(amount) AS \\'trans_total_amount\\',\\n        SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788571,
                "title": "mssql-simple-solution",
                "content": "```\\nselect \\n    left(trans_date, 7) as month, \\n    country, \\n    count(id) as trans_count, \\n    sum(iif(state = \\'approved\\', 1, 0)) as approved_count, \\n    sum(amount) as trans_total_amount, \\n    sum(iif(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date, 7), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    left(trans_date, 7) as month, \\n    country, \\n    count(id) as trans_count, \\n    sum(iif(state = \\'approved\\', 1, 0)) as approved_count, \\n    sum(amount) as trans_total_amount, \\n    sum(iif(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date, 7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747607,
                "title": "mysql",
                "content": "select left(trans_date,7) as month,country,count(id) as trans_count,sum(case when state=\\'approved\\' then 1 else 0 END) as approved_count,sum(amount) as trans_total_amount,sum(case when state=\\'approved\\' then amount else 0 END) as approved_total_amount\\nfrom Transactions\\ngroup by month,country",
                "solutionTags": [],
                "code": "select left(trans_date,7) as month,country,count(id) as trans_count,sum(case when state=\\'approved\\' then 1 else 0 END) as approved_count,sum(amount) as trans_total_amount,sum(case when state=\\'approved\\' then amount else 0 END) as approved_total_amount\\nfrom Transactions\\ngroup by month,country",
                "codeTag": "Unknown"
            },
            {
                "id": 1740850,
                "title": "sumif-dateformat-solution",
                "content": "```\\n\\nselect DATE_FORMAT(trans_date, \"%Y-%m\") as month, country, \\ncount(*) as trans_count,\\nsum(if(state=\\'approved\\',1,0)) as approved_count, \\nsum(amount) as trans_total_amount,\\nsum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by month, country\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect DATE_FORMAT(trans_date, \"%Y-%m\") as month, country, \\ncount(*) as trans_count,\\nsum(if(state=\\'approved\\',1,0)) as approved_count, \\nsum(amount) as trans_total_amount,\\nsum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1671849,
                "title": "solution-oracle-sum-case-statement-group-by",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nSELECT to_char(trans_date, \\'YYYY-MM\\') as month, \\n    country, \\n    count(id) as trans_count, \\n    sum(CASE WHEN state=\\'approved\\' then 1 ELSE 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(CASE WHEN state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nFROM Transactions GROUP BY to_char(trans_date, \\'YYYY-MM\\'), country;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT to_char(trans_date, \\'YYYY-MM\\') as month, \\n    country, \\n    count(id) as trans_count, \\n    sum(CASE WHEN state=\\'approved\\' then 1 ELSE 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(CASE WHEN state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nFROM Transactions GROUP BY to_char(trans_date, \\'YYYY-MM\\'), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595900,
                "title": "simple-oracle-solution",
                "content": "```\\nselect to_char(trans_date, \\'YYYY-MM\\')       month\\n      ,country\\n      ,count(1)         trans_count \\n      ,sum(case when state = \\'approved\\' then 1 else 0 end) approved_count \\n      ,sum(amount)      trans_total_amount \\n      ,sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount \\n  from Transactions\\n  group by to_char(trans_date, \\'YYYY-MM\\'), country\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect to_char(trans_date, \\'YYYY-MM\\')       month\\n      ,country\\n      ,count(1)         trans_count \\n      ,sum(case when state = \\'approved\\' then 1 else 0 end) approved_count \\n      ,sum(amount)      trans_total_amount \\n      ,sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount \\n  from Transactions\\n  group by to_char(trans_date, \\'YYYY-MM\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524892,
                "title": "92-faster-mysql-sum-case-when",
                "content": "```\\nselect month, country, trans_count,\\n    approved_count,\\n    trans_total_amount,\\n    approved_total_amount\\nfrom (\\n    select date_format(trans_date,\\'%Y-%m\\') as month, country, \\n         count(id) as trans_count,\\n         sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,  \\n         sum(amount) as trans_total_amount,\\n         sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\n    from Transactions\\n    group by month, country) tmp\\n\\t```",
                "solutionTags": [],
                "code": "```\\nselect month, country, trans_count,\\n    approved_count,\\n    trans_total_amount,\\n    approved_total_amount\\nfrom (\\n    select date_format(trans_date,\\'%Y-%m\\') as month, country, \\n         count(id) as trans_count,\\n         sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,  \\n         sum(amount) as trans_total_amount,\\n         sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\n    from Transactions\\n    group by month, country) tmp\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499668,
                "title": "simple-mysql-using-sum-and-case",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n        country, \\n        COUNT(id) AS \\'trans_count\\',\\n        SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS \\'approved_count\\',\\n        SUM(amount) AS \\'trans_total_amount\\',\\n        SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY 1,2\\nORDER BY 1, 2",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n        country, \\n        COUNT(id) AS \\'trans_count\\',\\n        SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS \\'approved_count\\',\\n        SUM(amount) AS \\'trans_total_amount\\',\\n        SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY 1,2\\nORDER BY 1, 2",
                "codeTag": "Unknown"
            },
            {
                "id": 1489504,
                "title": "mysql-solution",
                "content": "select date_format(trans_date, \\'%Y-%m\\') as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(case when state  = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state  = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by 1, 2",
                "solutionTags": [],
                "code": "select date_format(trans_date, \\'%Y-%m\\') as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(case when state  = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state  = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by 1, 2",
                "codeTag": "Unknown"
            },
            {
                "id": 1370095,
                "title": "mssql-subquery",
                "content": "```\\nSELECT month, country, COUNT(*) as trans_count, SUM(approved) as approved_count, SUM(amount) as trans_total_amount, SUM(approved_amount) as approved_total_amount\\nFROM (SELECT id, country, amount, LEFT(trans_date, 7) as month,\\n        CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END AS \\'approved\\',\\n        CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END AS \\'approved_amount\\'\\n      FROM Transactions) data\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT month, country, COUNT(*) as trans_count, SUM(approved) as approved_count, SUM(amount) as trans_total_amount, SUM(approved_amount) as approved_total_amount\\nFROM (SELECT id, country, amount, LEFT(trans_date, 7) as month,\\n        CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END AS \\'approved\\',\\n        CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END AS \\'approved_amount\\'\\n      FROM Transactions) data\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295093,
                "title": "mysql",
                "content": "```\\nwith temp as\\n(\\nselect *, case when state=\\'approved\\' then 1 else 0 end as approved_count,\\n    case when state=\\'approved\\' then amount else 0 end as approved_amount\\nfrom transactions\\n)\\n\\nselect substr(trans_date,1,7) as month, country, count(id) as trans_count,\\n    sum(approved_count) as approved_count, \\n    sum(amount) as trans_total_amount, sum(approved_amount) as approved_total_amount\\nfrom temp\\ngroup by country, substr(trans_date,1,7)\\n```",
                "solutionTags": [],
                "code": "```\\nwith temp as\\n(\\nselect *, case when state=\\'approved\\' then 1 else 0 end as approved_count,\\n    case when state=\\'approved\\' then amount else 0 end as approved_amount\\nfrom transactions\\n)\\n\\nselect substr(trans_date,1,7) as month, country, count(id) as trans_count,\\n    sum(approved_count) as approved_count, \\n    sum(amount) as trans_total_amount, sum(approved_amount) as approved_total_amount\\nfrom temp\\ngroup by country, substr(trans_date,1,7)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1226352,
                "title": "simple-mysql-solution",
                "content": "```\\nSELECT\\n    LEFT(trans_date, 7) AS month,\\n    country,\\n    COUNT(*) as trans_count,\\n    SUM(state = \\'approved\\') as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions t\\nGROUP BY month, country;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    LEFT(trans_date, 7) AS month,\\n    country,\\n    COUNT(*) as trans_count,\\n    SUM(state = \\'approved\\') as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions t\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168824,
                "title": "easy-sum-combine-case-when",
                "content": "select \\n        date_format(trans_date,\"%Y-%m\") month, \\n        country,\\n        count(*) trans_count,\\n        sum(case when state=\\'approved\\' then 1 else 0 end) approved_count, \\n        sum(amount) trans_total_amount,\\n        sum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date,\"%Y-%m\") , country\\n\\n",
                "solutionTags": [],
                "code": "select \\n        date_format(trans_date,\"%Y-%m\") month, \\n        country,\\n        count(*) trans_count,\\n        sum(case when state=\\'approved\\' then 1 else 0 end) approved_count, \\n        sum(amount) trans_total_amount,\\n        sum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date,\"%Y-%m\") , country\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1087544,
                "title": "easy-mysql-solution",
                "content": "```\\nselect left(trans_date,7) as month, \\ncountry, \\ncount(id) as trans_count,\\n sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\n sum(amount) as trans_total_amount,\\n sum(case when state= \"approved\" then amount else 0 end) as approved_total_amount\\n from Transactions\\ngroup by 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect left(trans_date,7) as month, \\ncountry, \\ncount(id) as trans_count,\\n sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\n sum(amount) as trans_total_amount,\\n sum(case when state= \"approved\" then amount else 0 end) as approved_total_amount\\n from Transactions\\ngroup by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1078472,
                "title": "bit-99-82",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, COUNT(*) AS trans_count, SUM(state = \\'approved\\') AS approved_count, SUM(amount) AS trans_total_amount, SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, COUNT(*) AS trans_count, SUM(state = \\'approved\\') AS approved_count, SUM(amount) AS trans_total_amount, SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1050009,
                "title": "mysql",
                "content": "```\\nSELECT SUBSTR(TRANS_DATE,1,7) AS MONTH,\\n       COUNTRY,\\n\\t   COUNT(*) AS TRANS_COUNT,\\n\\t   SUM(CASE\\n           WHEN STATE=\\'approved\\'\\n           THEN 1\\n           ELSE 0 \\n           END)AS APPROVED_COUNT,\\n\\t   SUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,\\n\\t   SUM(CASE\\n\\t       WHEN STATE = \\'approved\\'\\n\\t\\t   THEN AMOUNT\\n\\t\\t   ELSE 0\\n\\t\\t   END) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS\\nGROUP BY SUBSTR(TRANS_DATE,1,7),\\n       COUNTRY\\nORDER BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SUBSTR(TRANS_DATE,1,7) AS MONTH,\\n       COUNTRY,\\n\\t   COUNT(*) AS TRANS_COUNT,\\n\\t   SUM(CASE\\n           WHEN STATE=\\'approved\\'\\n           THEN 1\\n           ELSE 0 \\n           END)AS APPROVED_COUNT,\\n\\t   SUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,\\n\\t   SUM(CASE\\n\\t       WHEN STATE = \\'approved\\'\\n\\t\\t   THEN AMOUNT\\n\\t\\t   ELSE 0\\n\\t\\t   END) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS\\nGROUP BY SUBSTR(TRANS_DATE,1,7),\\n       COUNTRY\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039880,
                "title": "sum-if",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT\\n    LEFT(trans_date, 7) AS \\'month\\',\\n    country, \\n    SUM(IF(state=\\'approved\\', 1, 1)) AS trans_count,\\n    SUM(IF(state=\\'approved\\', 1, 0)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(IF(state=\\'approved\\', amount,0)) AS approved_total_amount\\nFROM \\n    transactions\\nGROUP BY\\n    1, 2\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    LEFT(trans_date, 7) AS \\'month\\',\\n    country, \\n    SUM(IF(state=\\'approved\\', 1, 1)) AS trans_count,\\n    SUM(IF(state=\\'approved\\', 1, 0)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(IF(state=\\'approved\\', amount,0)) AS approved_total_amount\\nFROM \\n    transactions\\nGROUP BY\\n    1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981279,
                "title": "faster-than-90-57",
                "content": "```\\n\\nselect date_format(trans_date,\"%Y-%m\") as month, country, \\ncount(id) as trans_count,\\nsum(case when state=\\'approved\\' then 1  else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state=\\'approved\\' then amount  else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by 1,2;\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect date_format(trans_date,\"%Y-%m\") as month, country, \\ncount(id) as trans_count,\\nsum(case when state=\\'approved\\' then 1  else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state=\\'approved\\' then amount  else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by 1,2;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880930,
                "title": "simple-mysql-solution",
                "content": "Simple solution using case statement \\n\\n```\\nselect DATE_FORMAT(trans_date,\"%Y-%m\") as month,country, \\ncount(*) as trans_count, \\nsum(CASE WHEN state=\\'approved\\' then 1 else 0 end) as approved_count,sum(amount) as trans_total_amount,\\nsum(CASE WHEN state=\\'approved\\' then amount else 0 end)as approved_total_amount \\nfrom Transactions \\ngroup by MONTH(trans_date),country\\n```",
                "solutionTags": [],
                "code": "```\\nselect DATE_FORMAT(trans_date,\"%Y-%m\") as month,country, \\ncount(*) as trans_count, \\nsum(CASE WHEN state=\\'approved\\' then 1 else 0 end) as approved_count,sum(amount) as trans_total_amount,\\nsum(CASE WHEN state=\\'approved\\' then amount else 0 end)as approved_total_amount \\nfrom Transactions \\ngroup by MONTH(trans_date),country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879493,
                "title": "simple-mssql-solution",
                "content": "```\\nselect convert(varchar(7), trans_date, 126) as month, country,\\ncount(trans_date) as trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end)as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by convert(varchar(7), trans_date, 126), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect convert(varchar(7), trans_date, 126) as month, country,\\ncount(trans_date) as trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end)as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by convert(varchar(7), trans_date, 126), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 870063,
                "title": "simple-mysql-solution-using-if",
                "content": "```sql\\nselect\\n    left(trans_date,7) as \\'month\\',\\n    country,\\n    count(id) as trans_count,\\n    sum(if(state = \\'approved\\',1,0)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(if(state = \\'approved\\',amount,0)) as approved_total_amount \\nfrom transactions\\ngroup by 1,2\\n```",
                "solutionTags": [],
                "code": "```sql\\nselect\\n    left(trans_date,7) as \\'month\\',\\n    country,\\n    count(id) as trans_count,\\n    sum(if(state = \\'approved\\',1,0)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(if(state = \\'approved\\',amount,0)) as approved_total_amount \\nfrom transactions\\ngroup by 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868620,
                "title": "mssql-sum-case-when",
                "content": "```\\n-- solution: using case when statements\\nselect\\nleft(trans_date,7) as month,\\ncountry,\\nsum(case when state is not null then 1 else 0 end) as trans_count,\\nsum(case when lower(state) =\\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state is not null then amount else 0 end) as trans_total_amount,\\nsum(case when lower(state) =\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by left(trans_date,7), country\\norder by sum(case when state is not null then 1 else 0 end) desc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n-- solution: using case when statements\\nselect\\nleft(trans_date,7) as month,\\ncountry,\\nsum(case when state is not null then 1 else 0 end) as trans_count,\\nsum(case when lower(state) =\\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state is not null then amount else 0 end) as trans_total_amount,\\nsum(case when lower(state) =\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by left(trans_date,7), country\\norder by sum(case when state is not null then 1 else 0 end) desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815288,
                "title": "super-easy-faster-than-90",
                "content": "select to_char(trans_date, \\'YYYY-MM\\') month,\\ncountry, \\ncount(state) trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\ncoalesce(sum(case when state = \\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions \\ngroup by to_char(trans_date, \\'YYYY-MM\\'),country\\norder by to_char(trans_date, \\'YYYY-MM\\')",
                "solutionTags": [],
                "code": "select to_char(trans_date, \\'YYYY-MM\\') month,\\ncountry, \\ncount(state) trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\ncoalesce(sum(case when state = \\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions \\ngroup by to_char(trans_date, \\'YYYY-MM\\'),country\\norder by to_char(trans_date, \\'YYYY-MM\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 776688,
                "title": "simple-mysql",
                "content": "```\\nselect  month, \\ncountry, \\ncount(state) as trans_count, \\nsum(approve_state)  as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(approve_amount) as approved_total_amount\\nfrom\\n(select country, amount, state, left(trans_date, 7) as month,\\ncase when state = \\'approved\\' then 1 else 0 end as approve_state,\\ncase when state = \\'approved\\' then amount else 0 end as approve_amount\\nfrom Transactions)t\\ngroup by 1, 2\\norder by 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect  month, \\ncountry, \\ncount(state) as trans_count, \\nsum(approve_state)  as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(approve_amount) as approved_total_amount\\nfrom\\n(select country, amount, state, left(trans_date, 7) as month,\\ncase when state = \\'approved\\' then 1 else 0 end as approve_state,\\ncase when state = \\'approved\\' then amount else 0 end as approve_amount\\nfrom Transactions)t\\ngroup by 1, 2\\norder by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750131,
                "title": "simple-solution",
                "content": "```\\nSELECT month, country, \\n       COUNT(state) AS trans_count, \\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount, \\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM (SELECT *, DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month FROM Transactions) tm\\nGROUP BY month, country;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT month, country, \\n       COUNT(state) AS trans_count, \\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount, \\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM (SELECT *, DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month FROM Transactions) tm\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 577620,
                "title": "very-easy-mysql-solution",
                "content": "```\\nselect\\n    left(trans_date,7) as month\\n    ,country\\n    ,count(*) as trans_count\\n    ,sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count\\n    ,sum(amount) as trans_total_amount\\n    ,sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom\\n    Transactions\\ngroup by\\n    left(trans_date,7), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    left(trans_date,7) as month\\n    ,country\\n    ,count(*) as trans_count\\n    ,sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count\\n    ,sum(amount) as trans_total_amount\\n    ,sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom\\n    Transactions\\ngroup by\\n    left(trans_date,7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512749,
                "title": "mysql-simple-solution",
                "content": "```\\nSELECT LEFT(trans_date, 7) AS month, country,\\n       COUNT(state) AS trans_count,\\n       SUM(state=\\'approved\\') AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT LEFT(trans_date, 7) AS month, country,\\n       COUNT(state) AS trans_count,\\n       SUM(state=\\'approved\\') AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488576,
                "title": "simple-oracle-solution",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nselect to_char(t.trans_date,\\'YYYY-MM\\') month, t.country, COUNT(t.id) trans_count, \\nSUM(case when t.state = \\'approved\\' then 1 else 0 end) approved_count,SUM(amount) trans_total_amount,\\nSUM(case when t.state = \\'approved\\' then t.amount else 0 end) approved_total_amount\\nfrom Transactions t\\ngroup by to_char(t.trans_date,\\'YYYY-MM\\'),t.country\\norder by 1 asc\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect to_char(t.trans_date,\\'YYYY-MM\\') month, t.country, COUNT(t.id) trans_count, \\nSUM(case when t.state = \\'approved\\' then 1 else 0 end) approved_count,SUM(amount) trans_total_amount,\\nSUM(case when t.state = \\'approved\\' then t.amount else 0 end) approved_total_amount\\nfrom Transactions t\\ngroup by to_char(t.trans_date,\\'YYYY-MM\\'),t.country\\norder by 1 asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470306,
                "title": "mysql-simple",
                "content": "```\\nselect \\nDATE_FORMAT(trans_date, \"%Y-%m\") as month,\\ncountry ,\\ncount(*) as trans_count,\\nsum(state=\\'approved\\') as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\n\\nfrom Transactions\\ngroup by\\n DATE_FORMAT(trans_date, \"%Y-%m\"),country\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\nDATE_FORMAT(trans_date, \"%Y-%m\") as month,\\ncountry ,\\ncount(*) as trans_count,\\nsum(state=\\'approved\\') as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\n\\nfrom Transactions\\ngroup by\\n DATE_FORMAT(trans_date, \"%Y-%m\"),country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450723,
                "title": "simple-ms-sql-no-sub-query-no-join",
                "content": "```\\nselect left(trans_date,7) as \\'month\\',\\n\\tcountry,\\n\\tcount(id) as trans_count,\\n\\tsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count,\\n\\tsum(amount) as trans_total_amount,\\n\\tsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date,7), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect left(trans_date,7) as \\'month\\',\\n\\tcountry,\\n\\tcount(id) as trans_count,\\n\\tsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count,\\n\\tsum(amount) as trans_total_amount,\\n\\tsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date,7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 445041,
                "title": "simple-mysql-with-date-format-function",
                "content": "```\\nSELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,\\ncountry,\\nCOUNT(id) AS trans_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY 1,2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,\\ncountry,\\nCOUNT(id) AS trans_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430904,
                "title": "mysql-easy-understanding-only-use-case-when",
                "content": "\\n    select month,\\n\\t\\tcountry,\\n\\t\\tcount(*) as trans_count,\\n\\t\\tsum(case state when \\'approved\\' then 1 else 0 end) as approved_count,\\n\\t\\tsum(amount) as trans_total_amount,\\n\\t\\tsum(case state when \\'approved\\' then amount else 0 end) as approved_total_amount\\n\\tfrom \\n\\t\\t(\\n\\t\\tselect country,state,amount,DATE_FORMAT(trans_date,\\'%Y-%m\\') as month\\n\\t\\tfrom transactions\\n\\t\\t) a\\n\\t\\tgroup by month, country",
                "solutionTags": [],
                "code": "\\n    select month,\\n\\t\\tcountry,\\n\\t\\tcount(*) as trans_count,\\n\\t\\tsum(case state when \\'approved\\' then 1 else 0 end) as approved_count,\\n\\t\\tsum(amount) as trans_total_amount,\\n\\t\\tsum(case state when \\'approved\\' then amount else 0 end) as approved_total_amount\\n\\tfrom \\n\\t\\t(\\n\\t\\tselect country,state,amount,DATE_FORMAT(trans_date,\\'%Y-%m\\') as month\\n\\t\\tfrom transactions\\n\\t\\t) a\\n\\t\\tgroup by month, country",
                "codeTag": "Unknown"
            },
            {
                "id": 401938,
                "title": "simple-mysql-solution",
                "content": "```\\nselect left(trans_date, 7) as \"month\",\\n       country, \\n       count(id) as \"trans_count\",\\n       sum(case when state=\"approved\" then 1 else 0 end) as \"approved_count\",\\n       sum(amount) as \"trans_total_amount\",\\n       sum(case when state=\"approved\" then amount else 0 end) as \"approved_total_amount\"\\nfrom Transactions\\ngroup by left(trans_date, 7), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect left(trans_date, 7) as \"month\",\\n       country, \\n       count(id) as \"trans_count\",\\n       sum(case when state=\"approved\" then 1 else 0 end) as \"approved_count\",\\n       sum(amount) as \"trans_total_amount\",\\n       sum(case when state=\"approved\" then amount else 0 end) as \"approved_total_amount\"\\nfrom Transactions\\ngroup by left(trans_date, 7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392625,
                "title": "mysql-solution-w-grouping-and-aggregation",
                "content": "```\\nselect \\n    date_format(trans_date, \\'%Y-%m\\') \\'month\\',\\n    country,\\n    count(*) \\'trans_count\\',\\n    sum(state = \\'approved\\') \\'approved_count\\',\\n    sum(amount) \\'trans_total_amount\\',\\n    sum(case when state = \\'approved\\' then amount else 0 end) \\'approved_total_amount\\'\\nfrom \\n    Transactions\\ngroup by \\n    month, country\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    date_format(trans_date, \\'%Y-%m\\') \\'month\\',\\n    country,\\n    count(*) \\'trans_count\\',\\n    sum(state = \\'approved\\') \\'approved_count\\',\\n    sum(amount) \\'trans_total_amount\\',\\n    sum(case when state = \\'approved\\' then amount else 0 end) \\'approved_total_amount\\'\\nfrom \\n    Transactions\\ngroup by \\n    month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383992,
                "title": "mysql-solution-using-case-when-and-group-by",
                "content": "SELECT \\n  DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month, \\n  country, \\n  COUNT(id) AS trans_count, \\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country",
                "solutionTags": [],
                "code": "SELECT \\n  DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month, \\n  country, \\n  COUNT(id) AS trans_count, \\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country",
                "codeTag": "Unknown"
            },
            {
                "id": 383931,
                "title": "simple-mysql-solution-without-using-join",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT SUBSTR(trans_date,1,7) as month,\\ncountry,\\nCOUNT(*) as trans_count,\\nSUM(CASE WHEN state=\"approved\" THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month,country;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT SUBSTR(trans_date,1,7) as month,\\ncountry,\\nCOUNT(*) as trans_count,\\nSUM(CASE WHEN state=\"approved\" THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month,country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4106568,
                "title": "using-case-and-sum-basic-aggregate-functions-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\nUsing CASE() and SUM()\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY month, country;\\n\\n```\\n\\n# Explanation\\n**SELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,**\\n\\n-- This line of code specifies that we want to format the \\'trans_date\\' column as \\'%Y-%m\\' to get the year and month.\\n-- It also aliases the result as \\'month\\'.\\n    \\n-- In the next part of the query, we\\'re performing calculations on the grouped data.\\n\\n---\\n\\n**COUNT( * ) AS trans_count,**\\n-- count(*) as trans_count:\\n-- This part counts the number of rows (transactions) in each group (month and country).\\n\\n\\n---\\n\\n**SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,**\\n-- sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count:\\n-- Here, we use a conditional statement to count the number of rows with \\'state\\' equal to \\'approved\\'.\\n    \\n\\n---\\n\\n**SUM(amount) AS trans_total_amount,**\\n-- 3. sum(amount) as trans_total_amount:\\n-- This sums up the \\'amount\\' column for all rows in each group, giving the total transaction amount.\\n    \\n\\n---\\n\\n **SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount**\\n-- 4. sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount:\\n-- Similar to the second calculation, this sums up the \\'amount\\' column for rows where \\'state\\' is \\'approved\\'.\\n   \\n\\n---\\n\\n\\n\\n# Please Upvote the Solution!",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY month, country;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102417,
                "title": "better-than-80-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect CONCAT(YEAR(trans_date), \\'-\\', LPAD(MONTH(trans_date), 2, \\'0\\')) as month, country, count(*) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count,\\nsum(amount) as trans_total_amount, sum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by year(trans_date), Month(trans_date), country\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect CONCAT(YEAR(trans_date), \\'-\\', LPAD(MONTH(trans_date), 2, \\'0\\')) as month, country, count(*) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count,\\nsum(amount) as trans_total_amount, sum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by year(trans_date), Month(trans_date), country\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100737,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country, month\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country, month\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100216,
                "title": "beats-85-users-sum-if-with-sub-query",
                "content": "# Complexity\\n- Time complexity: 1001 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0.00 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  a.`month`\\n       ,a.country\\n       ,count(*) as trans_count\\n       ,sum(a.approved_count) as approved_count\\n       ,sum(a.amount) as trans_total_amount\\n       ,sum(a.approved_amount) as approved_total_amount\\nfrom (\\n    select DATE_FORMAT(trans_date,\\'%Y-%m\\') as `month`\\n       ,country\\n       ,if(state = \\'approved\\', 1, 0) as approved_count\\n       ,amount\\n       ,if(state = \\'approved\\', amount, 0) as approved_amount\\n    from Transactions\\n) a\\ngroup by a.`month`\\n         ,a.country\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  a.`month`\\n       ,a.country\\n       ,count(*) as trans_count\\n       ,sum(a.approved_count) as approved_count\\n       ,sum(a.amount) as trans_total_amount\\n       ,sum(a.approved_amount) as approved_total_amount\\nfrom (\\n    select DATE_FORMAT(trans_date,\\'%Y-%m\\') as `month`\\n       ,country\\n       ,if(state = \\'approved\\', 1, 0) as approved_count\\n       ,amount\\n       ,if(state = \\'approved\\', amount, 0) as approved_amount\\n    from Transactions\\n) a\\ngroup by a.`month`\\n         ,a.country\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097803,
                "title": "monthly-transactions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\n#elect DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, count(*) as trans_count, SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count , SUM(amount) AS trans_total_amount , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount FROM Transactions GROUP BY month, country\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, count(*) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state=\\'approved\\',amount,0)) as approved_total_amount from transactions group by month,country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\n#elect DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, count(*) as trans_count, SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count , SUM(amount) AS trans_total_amount , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount FROM Transactions GROUP BY month, country\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, count(*) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state=\\'approved\\',amount,0)) as approved_total_amount from transactions group by month,country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097620,
                "title": "go-with-asking-statement-for-beginners-mysql",
                "content": "\\n# Code\\n```\\nselect date_format(trans_date , \\'%Y-%m\\') as month , country , \\ncount(state) as  trans_count , \\nSum(case when state = \\'approved\\' then 1 else 0 end) as approved_count , \\nsum(amount) as trans_total_amount , \\nSUM(case when state = \\'approved\\' then amount else 0 end ) as approved_total_amount\\n\\nfrom Transactions \\ngroup by date_format(trans_date , \\'%Y-%m\\') , country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_format(trans_date , \\'%Y-%m\\') as month , country , \\ncount(state) as  trans_count , \\nSum(case when state = \\'approved\\' then 1 else 0 end) as approved_count , \\nsum(amount) as trans_total_amount , \\nSUM(case when state = \\'approved\\' then amount else 0 end ) as approved_total_amount\\n\\nfrom Transactions \\ngroup by date_format(trans_date , \\'%Y-%m\\') , country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097459,
                "title": "step-by-step-easy-mysql-solution-with-date-format",
                "content": "# Intuition\\nMonthly Transactions I\\n# Approach\\nUse DATE_FORMAT(col_name,\\'%Y-%m\\') to find month of the year. Use if condition alonfg with sum to find approved state count.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date,\\'%Y-%m\\') \\'month\\',country,count(state) \\'trans_count\\',sum(if(state=\\'approved\\',1,0)) \\'approved_count\\', sum(amount) \\'trans_total_amount\\', sum(if(state=\\'approved\\',amount,0)) \\'approved_total_amount\\' from Transactions group by month,country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date,\\'%Y-%m\\') \\'month\\',country,count(state) \\'trans_count\\',sum(if(state=\\'approved\\',1,0)) \\'approved_count\\', sum(amount) \\'trans_total_amount\\', sum(if(state=\\'approved\\',amount,0)) \\'approved_total_amount\\' from Transactions group by month,country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096584,
                "title": "sql-server-simple-solution-using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,format(trans_date,\\'yyyy-MM\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,format(trans_date,\\'yyyy-MM\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096580,
                "title": "mysql-simple-solution-using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,DATE_FORMAT(trans_date,\\'%Y-%m\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,DATE_FORMAT(trans_date,\\'%Y-%m\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096575,
                "title": "oracle-simple-solution-using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,to_char(trans_date,\\'YYYY-MM\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,to_char(trans_date,\\'YYYY-MM\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095939,
                "title": "clean-single-select",
                "content": "# CLEAN SINGLE SELECT\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') \"month\", \\n        country,\\n        COUNT(state) \"trans_count\",\\n        SUM(IF(state = \"approved\", 1, 0)) \\'approved_count\\',\\n        SUM(amount) \"trans_total_amount\",\\n        SUM(IF(state= \"approved\", amount, 0)) \\'approved_total_amount\\'\\nFROM Transactions t\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') \"month\", \\n        country,\\n        COUNT(state) \"trans_count\",\\n        SUM(IF(state = \"approved\", 1, 0)) \\'approved_count\\',\\n        SUM(amount) \"trans_total_amount\",\\n        SUM(IF(state= \"approved\", amount, 0)) \\'approved_total_amount\\'\\nFROM Transactions t\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095863,
                "title": "faster-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, \\n  country, \\n  count(*) as trans_count, \\n  sum(\\n    case when Transactions.state = \\'approved\\' then 1 else 0 end\\n  ) as approved_count, \\n  sum(Transactions.amount) as trans_total_amount, \\n  sum(\\n    case when Transactions.state = \\'approved\\' then Transactions.amount else 0 end\\n  ) as approved_total_amount \\nfrom \\n  Transactions \\ngroup by \\n  country, \\n  month\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, \\n  country, \\n  count(*) as trans_count, \\n  sum(\\n    case when Transactions.state = \\'approved\\' then 1 else 0 end\\n  ) as approved_count, \\n  sum(Transactions.amount) as trans_total_amount, \\n  sum(\\n    case when Transactions.state = \\'approved\\' then Transactions.amount else 0 end\\n  ) as approved_total_amount \\nfrom \\n  Transactions \\ngroup by \\n  country, \\n  month\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095393,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSelect \\n    LEFT(trans_date, char_length(trans_date) - 3) as month,\\n    country,\\n    count(*) as  trans_count,\\n    SUM(if(state = \\'approved\\', 1, 0)) as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(if(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions trx\\ngroup by month, country;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSelect \\n    LEFT(trans_date, char_length(trans_date) - 3) as month,\\n    country,\\n    count(*) as  trans_count,\\n    SUM(if(state = \\'approved\\', 1, 0)) as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(if(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions trx\\ngroup by month, country;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094934,
                "title": "remember-to-sum-after-using-case-when",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, \\n    country, \\n    COUNT(*) as trans_count, \\n    SUM((CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END)) as approved_count, \\n    SUM(amount) as trans_total_amount, \\n    SUM((CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END)) as approved_total_amount\\nFROM Transactions \\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, \\n    country, \\n    COUNT(*) as trans_count, \\n    SUM((CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END)) as approved_count, \\n    SUM(amount) as trans_total_amount, \\n    SUM((CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END)) as approved_total_amount\\nFROM Transactions \\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093298,
                "title": "easy-and-fun",
                "content": "Simple use case of aggregate functions with filters\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    count(1) trans_count,\\n    sum(if(state = \\'approved\\',1,0)) approved_count,\\n    sum(amount) trans_total_amount,\\n    sum(if(state = \\'approved\\',amount,0)) approved_total_amount\\n  from transactions\\n  group by 1, 2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    count(1) trans_count,\\n    sum(if(state = \\'approved\\',1,0)) approved_count,\\n    sum(amount) trans_total_amount,\\n    sum(if(state = \\'approved\\',amount,0)) approved_total_amount\\n  from transactions\\n  group by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091721,
                "title": "beats-81-users-in-time-and-100-users-in-memory-simple-approach-using-group-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect date_format(trans_date, \\'%Y-%m\\') as month,\\ncountry, count(1) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by 1, 2\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_format(trans_date, \\'%Y-%m\\') as month,\\ncountry, count(1) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091609,
                "title": "good-but-complex-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect concat(\\'20\\',r.da) as month,r.country,trans_count,coalesce(approved_count,0) as approved_count,trans_total_amount,coalesce(approved_total_amount,0) as approved_total_amount\\nfrom (select date_format(trans_date,\"%y-%m\") as da,country,count(amount) as trans_count,sum(amount) as trans_total_amount from transactions group by country,month(trans_date),year(trans_date)) as r\\nleft join\\n(select date_format(trans_date,\"%y-%m\") as da,country,count(amount) as approved_count,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by country,month(trans_date),year(trans_date)) as rp\\non r.da=rp.da and r.country=rp.country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect concat(\\'20\\',r.da) as month,r.country,trans_count,coalesce(approved_count,0) as approved_count,trans_total_amount,coalesce(approved_total_amount,0) as approved_total_amount\\nfrom (select date_format(trans_date,\"%y-%m\") as da,country,count(amount) as trans_count,sum(amount) as trans_total_amount from transactions group by country,month(trans_date),year(trans_date)) as r\\nleft join\\n(select date_format(trans_date,\"%y-%m\") as da,country,count(amount) as approved_count,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by country,month(trans_date),year(trans_date)) as rp\\non r.da=rp.da and r.country=rp.country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090780,
                "title": "mysql-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nSelect date_format(trans_date, \\'%Y-%m\\') as month\\n, country\\n, count(id) as trans_count\\n, count(if(state = \\'approved\\', 1, null) ) as approved_count\\n, sum(amount) as trans_total_amount\\n, sum(if(state=\\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions t\\nGroup by date_format(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nSelect date_format(trans_date, \\'%Y-%m\\') as month\\n, country\\n, count(id) as trans_count\\n, count(if(state = \\'approved\\', 1, null) ) as approved_count\\n, sum(amount) as trans_total_amount\\n, sum(if(state=\\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions t\\nGroup by date_format(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090174,
                "title": "please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as(\\nselect *\\nfrom Transactions t\\nwhere state = \\'approved\\'\\n)\\nselect DATE_FORMAT(t.trans_date,  \\'%Y-%m\\') as month,\\nt.country,\\ncount(t.id) as trans_count,\\nsum(t.state = \\'approved\\') as approved_count,\\nsum(t.amount) as trans_total_amount,\\nCOALESCE(sum(cte.amount), 0) as approved_total_amount \\nfrom Transactions t\\nleft outer join cte on cte.id = t.id\\ngroup by country, DATE_FORMAT(trans_date,  \\'%Y-%m\\')\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as(\\nselect *\\nfrom Transactions t\\nwhere state = \\'approved\\'\\n)\\nselect DATE_FORMAT(t.trans_date,  \\'%Y-%m\\') as month,\\nt.country,\\ncount(t.id) as trans_count,\\nsum(t.state = \\'approved\\') as approved_count,\\nsum(t.amount) as trans_total_amount,\\nCOALESCE(sum(cte.amount), 0) as approved_total_amount \\nfrom Transactions t\\nleft outer join cte on cte.id = t.id\\ngroup by country, DATE_FORMAT(trans_date,  \\'%Y-%m\\')\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087156,
                "title": "sql-simple-solution",
                "content": "# Code\\n``` mysql []\\n# Write your MySQL query statement below\\n\\nSELECT\\n    date_format(trans_date, \"%Y-%m\") AS month,\\n    country,\\n    count(*) AS trans_count,\\n    sum(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    sum(amount) AS trans_total_amount,\\n    sum(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY year(trans_date), month(trans_date), country\\n```\\n``` mssql []\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    format(min(trans_date), \\'yyyy-MM\\') AS month,\\n    country,\\n    count(*) AS trans_count,\\n    sum(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    sum(amount) AS trans_total_amount,\\n    sum(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY year(trans_date), month(trans_date), country\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "``` mysql []\\n# Write your MySQL query statement below\\n\\nSELECT\\n    date_format(trans_date, \"%Y-%m\") AS month,\\n    country,\\n    count(*) AS trans_count,\\n    sum(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    sum(amount) AS trans_total_amount,\\n    sum(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY year(trans_date), month(trans_date), country\\n```\n``` mssql []\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    format(min(trans_date), \\'yyyy-MM\\') AS month,\\n    country,\\n    count(*) AS trans_count,\\n    sum(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    sum(amount) AS trans_total_amount,\\n    sum(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY year(trans_date), month(trans_date), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086364,
                "title": "two-solutions-one-large-and-a-bit-complex-and-one-short-and-easy",
                "content": "# 1. Code\\n```\\nSELECT trans.month, trans.country, COALESCE(trans_count, 0) AS trans_count, COALESCE(approved_count, 0) AS approved_count, COALESCE(trans_total_amount, 0) AS trans_total_amount, COALESCE(approved_total_amount, 0) AS approved_total_amount FROM\\n(SELECT DISTINCT(DATE_FORMAT(trans_date, \\'%Y-%m\\')) AS month, country, COUNT(state) AS trans_count, SUM(amount) AS trans_total_amount\\nFROM transactions\\nGROUP BY month, country) AS trans\\nLEFT JOIN\\n(SELECT DISTINCT(DATE_FORMAT(trans_date, \\'%Y-%m\\')) AS month, country, COUNT(state) AS approved_count, SUM(amount) AS approved_total_amount\\nFROM transactions\\nWHERE state = \"approved\"\\nGROUP BY month, country) AS approved\\nON trans.month = approved.month AND trans.country = approved.country \\n\\n```\\n\\n# 2. Code\\n```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, COUNT(state) AS trans_count, SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count, SUM(amount) AS trans_total_amount, SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY month, country \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT trans.month, trans.country, COALESCE(trans_count, 0) AS trans_count, COALESCE(approved_count, 0) AS approved_count, COALESCE(trans_total_amount, 0) AS trans_total_amount, COALESCE(approved_total_amount, 0) AS approved_total_amount FROM\\n(SELECT DISTINCT(DATE_FORMAT(trans_date, \\'%Y-%m\\')) AS month, country, COUNT(state) AS trans_count, SUM(amount) AS trans_total_amount\\nFROM transactions\\nGROUP BY month, country) AS trans\\nLEFT JOIN\\n(SELECT DISTINCT(DATE_FORMAT(trans_date, \\'%Y-%m\\')) AS month, country, COUNT(state) AS approved_count, SUM(amount) AS approved_total_amount\\nFROM transactions\\nWHERE state = \"approved\"\\nGROUP BY month, country) AS approved\\nON trans.month = approved.month AND trans.country = approved.country \\n\\n```\n```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, COUNT(state) AS trans_count, SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count, SUM(amount) AS trans_total_amount, SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY month, country \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085563,
                "title": "easy-sql",
                "content": "\\n\\n# Code\\n```\\nSELECT \\nLEFT(trans_date, 7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\nLEFT(trans_date, 7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084890,
                "title": "beats-100-in-memory-usage-simple-group-by-case",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect date_format(trans_date, \\'%Y-%m\\') as month,country,count(id) as trans_count,\\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by DATE_FORMAT(trans_date, \\'%Y-%m\\'),country;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect date_format(trans_date, \\'%Y-%m\\') as month,country,count(id) as trans_count,\\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by DATE_FORMAT(trans_date, \\'%Y-%m\\'),country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082703,
                "title": "single-query-solving-using-if-condition",
                "content": "# Intuition\\nShould be performed in 1 single query without using subqueries\\n\\n# Approach\\nTry going 1 column at a time satisfying the conditions as you move left to right. Using simple if conditions can ensure the approved transactions to be considered accordingly and use 0 in the else block to avoid counting the invalid ones\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect SUBSTR(trans_date, 1,7) month, country,count(id) trans_count,sum(if(state=\\'approved\\',1,0))  approved_count,sum(amount) trans_total_amount,sum(if(state=\\'approved\\',amount,0)) approved_total_amount\\nfrom transactions \\ngroup by month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect SUBSTR(trans_date, 1,7) month, country,count(id) trans_count,sum(if(state=\\'approved\\',1,0))  approved_count,sum(amount) trans_total_amount,sum(if(state=\\'approved\\',amount,0)) approved_total_amount\\nfrom transactions \\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082679,
                "title": "top-99-solution-using-if",
                "content": "# Explanation\\nThis code uses SUBSTR() on the trans date to get the date for each month. We then get the count for the dates to figure out what the total count of transactions was on each date. Then using if statements we get the number of approved transactions. And we get the sum of amount as the total amount of money. Then we get the total approved amount by only summing up the transaction amounts that were approved. We group by month and country to get a row for each month, as well as for each country. **Like if this was useful please**.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT SUBSTR(trans_date, 1, 7) AS month, country, COUNT(trans_date) AS trans_count,\\nSUM(IF(state = \\'approved\\', 1, 0)) AS approved_count, SUM(amount) AS trans_total_amount,\\nSUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT SUBSTR(trans_date, 1, 7) AS month, country, COUNT(trans_date) AS trans_count,\\nSUM(IF(state = \\'approved\\', 1, 0)) AS approved_count, SUM(amount) AS trans_total_amount,\\nSUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082313,
                "title": "easy-solution-using-aggregation",
                "content": "# Code\\n```\\nSELECT \\nsubstr(trans_date, 1,7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\nsubstr(trans_date, 1,7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081829,
                "title": "built-using-basics",
                "content": "with table1 as(\\nselect id,country,amount,date_format(trans_date,\\'%Y-%m\\') as month , case\\nwhen state = \\'approved\\' then 1\\nelse 0 end as state from transactions),\\ntable2 as(\\nselect distinct month ,country , sum((if(state = 1,amount,0))) over(partition by country,month) as approved_total_amount from table1)\\nselect distinct t1.month , t1.country , count(state) over(partition by t1.country,t1.month) as trans_count, sum(state) over(partition by t1.country,t1.month) as approved_count , sum(amount) over(partition by t1.country,t1.month) as trans_total_amount , approved_total_amount \\nfrom table1 t1 join table2 t2\\non t1.month = t2.month and t1.country=t2.country\\norder by t1.country desc;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "with table1 as(\\nselect id,country,amount,date_format(trans_date,\\'%Y-%m\\') as month , case\\nwhen state = \\'approved\\' then 1\\nelse 0 end as state from transactions),\\ntable2 as(\\nselect distinct month ,country , sum((if(state = 1,amount,0))) over(partition by country,month) as approved_total_amount from table1)\\nselect distinct t1.month , t1.country , count(state) over(partition by t1.country,t1.month) as trans_count, sum(state) over(partition by t1.country,t1.month) as approved_count , sum(amount) over(partition by t1.country,t1.month) as trans_total_amount , approved_total_amount \\nfrom table1 t1 join table2 t2\\non t1.month = t2.month and t1.country=t2.country\\norder by t1.country desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 4081065,
                "title": "simple-code",
                "content": "SubStr() is used to convert the date to yyyy-mm, if statement is used to get approved count and case statement is used tto get approved total count and then group by month and country\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect substr(trans_date,1,7) as month, country,count(id) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count, sum(amount) as trans_total_amount, sum(CASE when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nFrom Transactions\\ngroup by month,country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect substr(trans_date,1,7) as month, country,count(id) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count, sum(amount) as trans_total_amount, sum(CASE when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nFrom Transactions\\ngroup by month,country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080342,
                "title": "simple-clean-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month ,\\ncountry,count(id) as trans_count, \\nsum(case state when \\'approved\\' then 1 else 0 end)  as approved_count ,\\nsum(amount) as trans_total_amount , \\nsum(case WHEN state = \\'approved\\' then amount else 0 END)  as approved_total_amount\\nfrom Transactions\\nGROUP BY month, country\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month ,\\ncountry,count(id) as trans_count, \\nsum(case state when \\'approved\\' then 1 else 0 end)  as approved_count ,\\nsum(amount) as trans_total_amount , \\nsum(case WHEN state = \\'approved\\' then amount else 0 END)  as approved_total_amount\\nfrom Transactions\\nGROUP BY month, country\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080319,
                "title": "easy-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT  DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, COUNTRY,\\nCOUNT(ID) AS TRANS_COUNT,\\nSUM(IF(STATE = \\'approved\\',1,0)) AS APPROVED_COUNT,\\nSUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,\\nSUM(IF(STATE = \\'approved\\',AMOUNT,0)) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS\\nGROUP BY MONTH, COUNTRY;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT  DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, COUNTRY,\\nCOUNT(ID) AS TRANS_COUNT,\\nSUM(IF(STATE = \\'approved\\',1,0)) AS APPROVED_COUNT,\\nSUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,\\nSUM(IF(STATE = \\'approved\\',AMOUNT,0)) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS\\nGROUP BY MONTH, COUNTRY;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079161,
                "title": "group-by-solution-with-aggregations-explained-in-details",
                "content": "# Intuition\\nFrom example we know the result has to be groupped by date and country, after that we just need to use aggregation opperations to get certain resulting columns.\\n\\n# Approach\\nFormatting Date: \\nThe DATE_FORMAT function is used to convert the trans_date field into the desired format.\\n\\nCounting Transactions:\\nCOUNT(trans_date): Counts the total number of transactions for each month and country.\\nCOUNT(CASE ...): Counts the number of approved transactions for each month and country.\\n\\nSumming Amounts:\\nSUM(amount): Calculates the total transaction amount for each month and country.\\nSUM(CASE ...): Calculates the total amount for approved transactions for each month and country.\\nGrouping and Aggregating: The data is then grouped by month and country, and aggregate functions are applied to calculate the desired metrics.\\n\\n# Complexity\\n- Time complexity:\\nOverall, the time complexity of the entire query is dominated by the GROUP BY operation, so it\\'s $$O(n log n)$$\\n\\n- Space complexity:\\n$$O(7)$$\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, count(trans_date) as trans_count,\\ncount(case when state = \\'approved\\' then 1 else null end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions \\ngroup by month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, count(trans_date) as trans_count,\\ncount(case when state = \\'approved\\' then 1 else null end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions \\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078487,
                "title": "easy-solution-explanation-for-sum-state-approved",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n      DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n      country,\\n      COUNT(id) AS trans_count,\\n      SUM(state = \\'approved\\') AS approved_count,\\n      SUM(amount) AS trans_total_amount,\\n      SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount \\nFROM Transactions\\nGROUP BY month, country;\\n```\\n\\n**In case you are wondering why I have used ```SUM(state=\\'approved\\')``` instead of ```COUNT(state=\\'approved\\')``` to calculate  approved_count:**\\n\\n- ```SUM(state=\\'approved\\'):``` This expression is using the ```SUM``` function to count the number of rows where the ```state``` column equals \\'**approved**\\'. It works as expected because ```SUM``` is an aggregation function that counts the number of true values in the specified condition. In SQL, ```true``` is typically represented as **1**, and false as **0**. So, by summing up the ```true``` values, you effectively count the rows where the condition is met.\\n\\n- ```COUNT(state=\\'approved\\'):``` This expression is using the ```COUNT``` function to count the number of rows where the ```state``` column equals \\'approved\\'. However, ```COUNT``` is an aggregation function that counts the number of **non-null** values in a column. It doesn\\'t work as expected for conditions like ```state=\\'approved\\'``` because it doesn\\'t directly count ```true``` or ```false``` values. Instead, it counts the number of non-null rows, and in this case, it counts all rows, including those where ```state``` is \\'**declined**\\', because \\'**declined**\\' is also a non-null value.\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n      DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n      country,\\n      COUNT(id) AS trans_count,\\n      SUM(state = \\'approved\\') AS approved_count,\\n      SUM(amount) AS trans_total_amount,\\n      SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount \\nFROM Transactions\\nGROUP BY month, country;\\n```\n```SUM(state=\\'approved\\')```\n```COUNT(state=\\'approved\\')```\n```SUM(state=\\'approved\\'):```\n```SUM```\n```state```\n```SUM```\n```true```\n```true```\n```COUNT(state=\\'approved\\'):```\n```COUNT```\n```state```\n```COUNT```\n```state=\\'approved\\'```\n```true```\n```false```\n```state```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077553,
                "title": "pandas-3-lines",
                "content": "# Intuition\\nIt\\'s very simple solution with just 2 simple initial transformations:\\n1. full date to year-month\\n2. approved amount column - when state is \\'approved\\' we give amount, else `None`; this is important, becouse it\\'s ignored during summing and counting. Normally, if value is anything but `None`, it\\'s always counted as 1, no matter it\\'s value or dtype.\\n\\nFinally just create multiple required columns with one .agg() method.\\n\\n# Code\\n```\\nimport pandas as pd\\nimport numpy as np\\ndef monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:\\n    transactions[\"month\"] = transactions[\"trans_date\"].dt.strftime(\"%Y-%m\")\\n    transactions[\"appr_amnt\"] = np.where(transactions.state == \"approved\", transactions[\"amount\"], None)\\n    return transactions.groupby([\"month\",\"country\"], as_index = False).agg(trans_count=(\"amount\",\"count\"), approved_count =(\"appr_amnt\",\"count\"), trans_total_amount = (\"amount\",\"sum\"), approved_total_amount = (\"appr_amnt\",\"sum\"))\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\nimport numpy as np\\ndef monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:\\n    transactions[\"month\"] = transactions[\"trans_date\"].dt.strftime(\"%Y-%m\")\\n    transactions[\"appr_amnt\"] = np.where(transactions.state == \"approved\", transactions[\"amount\"], None)\\n    return transactions.groupby([\"month\",\"country\"], as_index = False).agg(trans_count=(\"amount\",\"count\"), approved_count =(\"appr_amnt\",\"count\"), trans_total_amount = (\"amount\",\"sum\"), approved_total_amount = (\"appr_amnt\",\"sum\"))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4076204,
                "title": "mssql",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    cast(trans_date as varchar(7)) as month, --actually this is hack\\n    country,\\n    count(*) as trans_count,\\n    sum(case when state=\\'approved\\' then 1 else 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by\\n    cast(trans_date as varchar(7)),\\n    country\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    cast(trans_date as varchar(7)) as month, --actually this is hack\\n    country,\\n    count(*) as trans_count,\\n    sum(case when state=\\'approved\\' then 1 else 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by\\n    cast(trans_date as varchar(7)),\\n    country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074288,
                "title": "my-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') as \\'month\\', \\n    country,\\n    COUNT(id) as \\'trans_count\\',\\n    SUM(CASE \\n            WHEN state = \\'approved\\'\\n            THEN 1\\n            ELSE 0\\n        END) as \\'approved_count\\',\\n    SUM(amount) as \\'trans_total_amount\\',\\n    SUM(CASE\\n            WHEN state = \\'approved\\'\\n            THEN amount\\n            ELSE 0\\n        END) as \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY country, month\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') as \\'month\\', \\n    country,\\n    COUNT(id) as \\'trans_count\\',\\n    SUM(CASE \\n            WHEN state = \\'approved\\'\\n            THEN 1\\n            ELSE 0\\n        END) as \\'approved_count\\',\\n    SUM(amount) as \\'trans_total_amount\\',\\n    SUM(CASE\\n            WHEN state = \\'approved\\'\\n            THEN amount\\n            ELSE 0\\n        END) as \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY country, month\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074259,
                "title": "easy-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\nDATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n       country,\\n       COUNT(id) AS trans_count,\\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\nDATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n       country,\\n       COUNT(id) AS trans_count,\\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073968,
                "title": "case-mysql-solution",
                "content": "\\n# Approach\\nUsing DATE_FORMAT (DATE, \\'%Y-%m\\') you obtain the Month-Year format, that you have to use in the SELECT  and in the Group By.\\nFor the Trans_Count you can simply count the IDs, and for the Approved you can use SUM(CASE) with Approved being 1 and else being 0.\\nSame thing for the amount, but instead of 1 you use the amount value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(T.TRANS_DATE, \\'%Y-%m\\') AS MONTH\\n, T.COUNTRY\\n, COUNT(T.ID) AS TRANS_COUNT\\n, SUM(CASE WHEN T.STATE = \\'APPROVED\\' THEN 1 ELSE 0 END) AS APPROVED_COUNT\\n, SUM(T.AMOUNT)  AS TRANS_TOTAL_AMOUNT\\n, SUM(CASE WHEN T.STATE = \\'APPROVED\\' THEN T.AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS T\\nGROUP BY DATE_FORMAT(T.TRANS_DATE, \\'%Y-%m\\'), T.COUNTRY\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(T.TRANS_DATE, \\'%Y-%m\\') AS MONTH\\n, T.COUNTRY\\n, COUNT(T.ID) AS TRANS_COUNT\\n, SUM(CASE WHEN T.STATE = \\'APPROVED\\' THEN 1 ELSE 0 END) AS APPROVED_COUNT\\n, SUM(T.AMOUNT)  AS TRANS_TOTAL_AMOUNT\\n, SUM(CASE WHEN T.STATE = \\'APPROVED\\' THEN T.AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS T\\nGROUP BY DATE_FORMAT(T.TRANS_DATE, \\'%Y-%m\\'), T.COUNTRY\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072286,
                "title": "beats-97-57-of-users-with-mysql-using-date-format-group-by",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT\\n    DATE_FORMAT(trans_date,\"%Y-%m\") AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \"approved\" THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = \"approved\" THEN amount ELSE 0 END) AS approved_total_amount \\nFROM transactions\\nGROUP BY 1,2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT\\n    DATE_FORMAT(trans_date,\"%Y-%m\") AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \"approved\" THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = \"approved\" THEN amount ELSE 0 END) AS approved_total_amount \\nFROM transactions\\nGROUP BY 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070775,
                "title": "easy-solution",
                "content": "select date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, \\nsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount\\n, sum(case when state =\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions group by country, date_format(trans_date,\\'%Y-%m\\');",
                "solutionTags": [],
                "code": "select date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, \\nsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount\\n, sum(case when state =\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions group by country, date_format(trans_date,\\'%Y-%m\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 4070090,
                "title": "without-using-case",
                "content": "\\n# Code\\n```\\nSELECT DATE_FORMAT(t1.trans_date, \"%Y-%m\") AS month, \\n  t1.country,\\n  count(t1.id) AS trans_count,\\n  count(t2.id) AS approved_count,\\n  SUM(t1.amount) AS trans_total_amount,\\n  IFNULL(SUM(t2.amount),0) AS approved_total_amount\\nFROM Transactions t1 LEFT JOIN \\n(\\n  SELECT * \\n  FROM Transactions\\n  WHERE state = \\'approved\\'\\n)t2 \\nON t1.id = t2.id\\nGROUP BY country, DATE_FORMAT(trans_date, \"%Y-%m\")\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DATE_FORMAT(t1.trans_date, \"%Y-%m\") AS month, \\n  t1.country,\\n  count(t1.id) AS trans_count,\\n  count(t2.id) AS approved_count,\\n  SUM(t1.amount) AS trans_total_amount,\\n  IFNULL(SUM(t2.amount),0) AS approved_total_amount\\nFROM Transactions t1 LEFT JOIN \\n(\\n  SELECT * \\n  FROM Transactions\\n  WHERE state = \\'approved\\'\\n)t2 \\nON t1.id = t2.id\\nGROUP BY country, DATE_FORMAT(trans_date, \"%Y-%m\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070008,
                "title": "simple-solution",
                "content": "# Common mistake\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUSE SUM ELSE YOU WILL GET THIS ERROR\\n[42000] [Microsoft][ODBC Driver 17 for SQL Server][SQL Server]Column \\'Transactions.state\\' is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause. (8120) (SQLExecDirectW)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT \\nLEFT(t.trans_date, \\'7\\') month, \\nt.country country, \\nCOUNT(*) trans_count, \\nSUM(t.amount) trans_total_amount, \\nSUM(CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\nSUM(CASE WHEN t.state = \\'approved\\' THEN t.amount ELSE 0 END) AS approved_total_amount\\n\\nFROM [Transactions] t\\nGROUP BY LEFT(t.trans_date,\\'7\\'), t.country;\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT \\nLEFT(t.trans_date, \\'7\\') month, \\nt.country country, \\nCOUNT(*) trans_count, \\nSUM(t.amount) trans_total_amount, \\nSUM(CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\nSUM(CASE WHEN t.state = \\'approved\\' THEN t.amount ELSE 0 END) AS approved_total_amount\\n\\nFROM [Transactions] t\\nGROUP BY LEFT(t.trans_date,\\'7\\'), t.country;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068243,
                "title": "monthly-transactions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect SUBSTR(trans_date, 1,7) as month, country, count(id) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect SUBSTR(trans_date, 1,7) as month, country, count(id) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067865,
                "title": "2-approach-provided-optimal-join-non-optimal-2-subqueries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n  DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AS month,\\n  t.country,\\n  COUNT(t.trans_date) AS trans_count,\\n  COALESCE(approved_count, 0) AS approved_count,\\n  SUM(t.amount) AS trans_total_amount,\\n  COALESCE(approved_total_amount, 0) AS approved_total_amount\\nFROM\\n  Transactions AS t\\n  ## i made a table so i can left join with it ... i named the table subquery\\n  LEFT JOIN (\\n    SELECT\\n      DATE_FORMAT(t1.trans_date, \\'%Y-%m\\') AS month1,\\n      t1.country,\\n      COUNT(t1.trans_date) AS approved_count,\\n      SUM(t1.amount) AS approved_total_amount\\n    FROM\\n      Transactions AS t1\\n    WHERE\\n      t1.state = \\'approved\\'\\n    GROUP BY\\n      month1,\\n      t1.country\\n  ) AS subquery ON subquery.month1 = DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AND subquery.country = t.country\\nGROUP BY\\n  month,\\n  t.country;\\n\\n## My non optimal solution 2 subqueries used\\n\\n# SELECT DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AS month,t.country,COUNT(t.trans_date) as trans_count,\\n\\n# COALESCE(\\n# (SELECT COUNT(t1.trans_date) FROM Transactions as t1\\n# WHERE t1.state = \"approved\" and DATE_FORMAT(t1.trans_date, \\'%Y-%m\\') = month and t1.country = t.country\\n# GROUP BY DATE_FORMAT(t1.trans_date, \\'%Y-%m\\'),t1.country\\n# ),0) AS approved_count,\\n\\n# SUM(t.amount) as trans_total_amount,\\n\\n# COALESCE(\\n# (SELECT SUM(t2.amount) FROM Transactions as t2\\n# WHERE t2.state = \"approved\" and DATE_FORMAT(t2.trans_date, \\'%Y-%m\\') = month and t2.country = t.country\\n# GROUP BY DATE_FORMAT(t2.trans_date, \\'%Y-%m\\'),t2.country\\n# ),0) AS approved_total_amount\\n\\n# FROM Transactions AS t\\n# GROUP BY month,t.country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n  DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AS month,\\n  t.country,\\n  COUNT(t.trans_date) AS trans_count,\\n  COALESCE(approved_count, 0) AS approved_count,\\n  SUM(t.amount) AS trans_total_amount,\\n  COALESCE(approved_total_amount, 0) AS approved_total_amount\\nFROM\\n  Transactions AS t\\n  ## i made a table so i can left join with it ... i named the table subquery\\n  LEFT JOIN (\\n    SELECT\\n      DATE_FORMAT(t1.trans_date, \\'%Y-%m\\') AS month1,\\n      t1.country,\\n      COUNT(t1.trans_date) AS approved_count,\\n      SUM(t1.amount) AS approved_total_amount\\n    FROM\\n      Transactions AS t1\\n    WHERE\\n      t1.state = \\'approved\\'\\n    GROUP BY\\n      month1,\\n      t1.country\\n  ) AS subquery ON subquery.month1 = DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AND subquery.country = t.country\\nGROUP BY\\n  month,\\n  t.country;\\n\\n## My non optimal solution 2 subqueries used\\n\\n# SELECT DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AS month,t.country,COUNT(t.trans_date) as trans_count,\\n\\n# COALESCE(\\n# (SELECT COUNT(t1.trans_date) FROM Transactions as t1\\n# WHERE t1.state = \"approved\" and DATE_FORMAT(t1.trans_date, \\'%Y-%m\\') = month and t1.country = t.country\\n# GROUP BY DATE_FORMAT(t1.trans_date, \\'%Y-%m\\'),t1.country\\n# ),0) AS approved_count,\\n\\n# SUM(t.amount) as trans_total_amount,\\n\\n# COALESCE(\\n# (SELECT SUM(t2.amount) FROM Transactions as t2\\n# WHERE t2.state = \"approved\" and DATE_FORMAT(t2.trans_date, \\'%Y-%m\\') = month and t2.country = t.country\\n# GROUP BY DATE_FORMAT(t2.trans_date, \\'%Y-%m\\'),t2.country\\n# ),0) AS approved_total_amount\\n\\n# FROM Transactions AS t\\n# GROUP BY month,t.country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067738,
                "title": "ms-sql-solution-with-aggregate-functions-without-cte-and-joins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n2557 ms \\nBeats 70.01%of users with MS SQL Server\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT FORMAT(trans_date, \\'yyyy-MM\\') AS month, \\ncountry, \\nCOUNT(id) AS trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY FORMAT(trans_date, \\'yyyy-MM\\'), country\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT FORMAT(trans_date, \\'yyyy-MM\\') AS month, \\ncountry, \\nCOUNT(id) AS trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY FORMAT(trans_date, \\'yyyy-MM\\'), country\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065988,
                "title": "beats-89-64-of-users-with-mysql",
                "content": "\\n```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\ncountry, \\nCOUNT(id) as trans_count, \\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount \\nFROM Transactions \\nGROUP BY month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\ncountry, \\nCOUNT(id) as trans_count, \\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount \\nFROM Transactions \\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064490,
                "title": "pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:\\n    transactions[\\'month\\'] = transactions[\\'trans_date\\'].apply(lambda x:str(x)[0:7])\\n    transactions[\\'trans_count\\'] = transactions[\\'trans_date\\']\\n    transactions[\\'approved_count\\'] = transactions[\\'state\\'].apply(lambda x:1 if x==\\'approved\\' else 0)\\n    transactions[\\'approved_total_amount\\'] = transactions.apply(lambda x:x[\\'amount\\'] if x[\\'approved_count\\']==1 else 0,axis=1)\\n    print(transactions)\\n    transactions = transactions.groupby([\\'month\\',\\'country\\'], as_index=False).agg(\\n      \\n        trans_count=pd.NamedAgg(column=\"trans_count\", aggfunc=\"count\"),\\n        approved_count=pd.NamedAgg(column=\"approved_count\", aggfunc=\"sum\"),\\n        trans_total_amount=pd.NamedAgg(column=\"amount\", aggfunc=\"sum\"),\\n        approved_total_amount=pd.NamedAgg(column=\"approved_total_amount\", aggfunc=\"sum\")\\n        \\n        )\\n    \\n    return transactions    \\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:\\n    transactions[\\'month\\'] = transactions[\\'trans_date\\'].apply(lambda x:str(x)[0:7])\\n    transactions[\\'trans_count\\'] = transactions[\\'trans_date\\']\\n    transactions[\\'approved_count\\'] = transactions[\\'state\\'].apply(lambda x:1 if x==\\'approved\\' else 0)\\n    transactions[\\'approved_total_amount\\'] = transactions.apply(lambda x:x[\\'amount\\'] if x[\\'approved_count\\']==1 else 0,axis=1)\\n    print(transactions)\\n    transactions = transactions.groupby([\\'month\\',\\'country\\'], as_index=False).agg(\\n      \\n        trans_count=pd.NamedAgg(column=\"trans_count\", aggfunc=\"count\"),\\n        approved_count=pd.NamedAgg(column=\"approved_count\", aggfunc=\"sum\"),\\n        trans_total_amount=pd.NamedAgg(column=\"amount\", aggfunc=\"sum\"),\\n        approved_total_amount=pd.NamedAgg(column=\"approved_total_amount\", aggfunc=\"sum\")\\n        \\n        )\\n    \\n    return transactions    \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4064447,
                "title": "super-easy-solution-dattebayo",
                "content": "# Intuition\\nThe problem looks straight forward and i believe will not take much time. A beginner friendly answer is written by following basic concepts step by step.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nThis SQL query extracts the month and country from the \"Transactions\" table, then groups the data by these columns. Within each group, it calculates several aggregates:\\n\\ncount(*) as trans_count: Counts the total number of transactions in each group.\\n\\nSUM(IF(state=\\'approved\\',1,0)) as approved_count: Counts the number of transactions with the \\'approved\\' state.\\n\\nSUM(amount) as trans_total_amount: Calculates the total transaction amount for all transactions in each group.\\n\\nSUM(IF(state=\\'approved\\',amount,0)) as approved_total_amount: Calculates the total transaction amount for transactions with the \\'approved\\' state.\\n\\nThis query provides a summary of transaction data, including counts and amounts, broken down by month and country. It\\'s useful for analyzing transaction activity and approvals in different regions and over time.\\n\\n# Complexity\\n- Time complexity: $$918ms$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$96.76%$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n LEFT(trans_date,7) AS month,\\n country,count(*) as trans_count ,\\n SUM(IF(state=\\'approved\\',1,0)) as approved_count,\\nSUM(amount) as trans_total_amount,\\n SUM(IF(state=\\'approved\\',amount,0)) as approved_total_amount\\n from Transactions group by month,country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n LEFT(trans_date,7) AS month,\\n country,count(*) as trans_count ,\\n SUM(IF(state=\\'approved\\',1,0)) as approved_count,\\nSUM(amount) as trans_total_amount,\\n SUM(IF(state=\\'approved\\',amount,0)) as approved_total_amount\\n from Transactions group by month,country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064359,
                "title": "beats-90-answers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month ,country, count(*) as trans_count, \\nsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, \\nsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\n from Transactions\\n group by 1,2\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month ,country, count(*) as trans_count, \\nsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, \\nsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\n from Transactions\\n group by 1,2\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060986,
                "title": "easy-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPLEASE UPVOTE\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n    concat(YEAR(trans_date),\\'-\\',lpad(month(trans_date),2,\\'0\\')) as month,\\n    country,\\n    count(id) as trans_count,\\n    count(if(state=\\'approved\\',1,null)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\n    from transactions\\n    GROUP BY YEAR(trans_date), MONTH(trans_date),country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n    concat(YEAR(trans_date),\\'-\\',lpad(month(trans_date),2,\\'0\\')) as month,\\n    country,\\n    count(id) as trans_count,\\n    count(if(state=\\'approved\\',1,null)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\n    from transactions\\n    GROUP BY YEAR(trans_date), MONTH(trans_date),country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056645,
                "title": "beats-98-87-single-query-using-aggregate-functions-and-case-statements",
                "content": "# Approach\\n- **Month**\\n    `left(trans_date,7)` to retrieve the year and month in yyyy-mm.\\n- **trans_count**\\n    A simple $$group\\\\ by$$ query with count on the $$id$$.\\n    ```\\n    select count(id) from Transactions\\n    group by left(trans_date,7),country\\n    ```\\n- **approve_count**\\n    To get the count whenever the $$state$$ is $$approved$$, perform a case statement to count as 1.\\n    ```\\n    select\\n    sum(case \\n            when state = \\'approved\\' then 1 else 0 \\n        end)\\n    from Transactions\\n    group by left(trans_date,7),country\\n    ```\\n- **trans_total_amount**\\n    A simple $$group\\\\ by$$ query with the $$sum()$$ on the $$id$$.\\n    ```\\n    select sum(amount) from Transactions\\n    group by left(trans_date,7),country\\n    ```\\n- **approved_total_amount**\\n    To get the sum whenever the $$state$$ is $$approved$$, perform a case statement to cumulate the $$amount$$.\\n    ```\\n    select\\n    sum(case \\n        when state = \\'approved\\' then amount else 0 \\n        end)\\n    from Transactions\\n    group by left(trans_date,7),country\\n    ```\\n\\n# Code\\n```\\nselect\\n    left(trans_date,7) as Month,\\n    country,\\n    count(id) as trans_count,\\n    sum(case \\n        when state = \\'approved\\' then 1 else 0 \\n        end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case \\n        when state = \\'approved\\' then amount else 0 \\n        end) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date,7),country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n    select count(id) from Transactions\\n    group by left(trans_date,7),country\\n    ```\n```\\n    select\\n    sum(case \\n            when state = \\'approved\\' then 1 else 0 \\n        end)\\n    from Transactions\\n    group by left(trans_date,7),country\\n    ```\n```\\n    select sum(amount) from Transactions\\n    group by left(trans_date,7),country\\n    ```\n```\\n    select\\n    sum(case \\n        when state = \\'approved\\' then amount else 0 \\n        end)\\n    from Transactions\\n    group by left(trans_date,7),country\\n    ```\n```\\nselect\\n    left(trans_date,7) as Month,\\n    country,\\n    count(id) as trans_count,\\n    sum(case \\n        when state = \\'approved\\' then 1 else 0 \\n        end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case \\n        when state = \\'approved\\' then amount else 0 \\n        end) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date,7),country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054270,
                "title": "easy-approach-beats-99-03-sql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT LEFT(trans_date, 7) as month,\\ncountry, COUNT(*) AS trans_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM((CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END)*amount) AS approved_total_amount\\nFROM Transactions\\nGROUP BY LEFT(trans_date, 7), country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT LEFT(trans_date, 7) as month,\\ncountry, COUNT(*) AS trans_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM((CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END)*amount) AS approved_total_amount\\nFROM Transactions\\nGROUP BY LEFT(trans_date, 7), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053801,
                "title": "beats-93-33-easy-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect LEFT(CONVERT(varchar(10), trans_date, 120), 7) as month, country, count(id) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by LEFT(CONVERT(varchar(10), trans_date, 120), 7),country\\norder  by month asc, country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect LEFT(CONVERT(varchar(10), trans_date, 120), 7) as month, country, count(id) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by LEFT(CONVERT(varchar(10), trans_date, 120), 7),country\\norder  by month asc, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053122,
                "title": "clean-and-simple-solution-using-basic-sql-commands",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT\\n     DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n     country, \\n     COUNT(id) AS trans_count,\\n     SUM(CASE WHEN state = \"approved\" Then 1 ELSE 0 END) AS approved_count,\\n     SUM(amount) AS trans_total_amount, \\n     SUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) AS approved_total_amount\\nFROM\\n    Transactions \\nGROUP BY\\n     MONTH,YEAR(trans_date), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT\\n     DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n     country, \\n     COUNT(id) AS trans_count,\\n     SUM(CASE WHEN state = \"approved\" Then 1 ELSE 0 END) AS approved_count,\\n     SUM(amount) AS trans_total_amount, \\n     SUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) AS approved_total_amount\\nFROM\\n    Transactions \\nGROUP BY\\n     MONTH,YEAR(trans_date), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052945,
                "title": "simple-mysql-solution-which-beats-98-incredibly-straight-forward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince it was only one table first thing that comes to my mind is to join table to itself and then utilize if + count/sum to figure out differences \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStarted with each column at a time, figured out the group by in beginning and start configured select statement accordingly, just 1 column, focus on one column > make it right > move to next column > repeat.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect left(t1.trans_date, 7) as month, t1.country, count(t1.state) as trans_count ,\\n sum(if(t1.state=\\'approved\\', 1,0)) as approved_count, sum(t1.amount) as trans_total_amount, sum(if(t1.state=\\'approved\\', t1.amount,0)) as approved_total_amount from Transactions  t1\\n join transactions t2 on t1.id = t2.id\\ngroup by 1, country\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect left(t1.trans_date, 7) as month, t1.country, count(t1.state) as trans_count ,\\n sum(if(t1.state=\\'approved\\', 1,0)) as approved_count, sum(t1.amount) as trans_total_amount, sum(if(t1.state=\\'approved\\', t1.amount,0)) as approved_total_amount from Transactions  t1\\n join transactions t2 on t1.id = t2.id\\ngroup by 1, country\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052874,
                "title": "oracle-solution-with-decode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n  to_char(trunc(trans_date, \\'MONTH\\'), \\'YYYY-MM\\') as month,\\n  country, \\n  count(id) trans_count,\\n  sum(amount) trans_total_amount,\\n  sum(decode(state, \\'approved\\', 1, 0)) approved_count,\\n  sum(decode(state, \\'approved\\', 1, 0) * amount) approved_total_amount\\nfrom Transactions\\ngroup by trunc(trans_date, \\'MONTH\\'), country\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n  to_char(trunc(trans_date, \\'MONTH\\'), \\'YYYY-MM\\') as month,\\n  country, \\n  count(id) trans_count,\\n  sum(amount) trans_total_amount,\\n  sum(decode(state, \\'approved\\', 1, 0)) approved_count,\\n  sum(decode(state, \\'approved\\', 1, 0) * amount) approved_total_amount\\nfrom Transactions\\ngroup by trunc(trans_date, \\'MONTH\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049641,
                "title": "easy-solution-beats-98-18-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWith ttl as (Select\\nSubstring(trans_date,1,7) as month,\\ncountry,\\ncount(*) as trans_count, sum(amount) as trans_total_amount\\nFrom Transactions\\ngroup by country, month),\\n\\napp as (\\nSelect\\nsubstring(trans_date,1,7) as month,country,\\nSum(Case when state = \\'Approved\\' then 1 else 0 end)as approved_count, sum(Case when state = \\'Approved\\' then amount else 0 end) as approved_total_amount\\nFrom Transactions\\ngroup by country, month )\\n\\nSelect\\nttl.month, ttl.country, ttl.trans_count,app.approved_count, ttl.trans_total_amount, app.approved_total_amount\\nFrom ttl\\nleft join app\\non\\nttl.month = app.month \\nand\\nttl.country = app.country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWith ttl as (Select\\nSubstring(trans_date,1,7) as month,\\ncountry,\\ncount(*) as trans_count, sum(amount) as trans_total_amount\\nFrom Transactions\\ngroup by country, month),\\n\\napp as (\\nSelect\\nsubstring(trans_date,1,7) as month,country,\\nSum(Case when state = \\'Approved\\' then 1 else 0 end)as approved_count, sum(Case when state = \\'Approved\\' then amount else 0 end) as approved_total_amount\\nFrom Transactions\\ngroup by country, month )\\n\\nSelect\\nttl.month, ttl.country, ttl.trans_count,app.approved_count, ttl.trans_total_amount, app.approved_total_amount\\nFrom ttl\\nleft join app\\non\\nttl.month = app.month \\nand\\nttl.country = app.country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049249,
                "title": "1193-monthly-transactions-i-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n       country,\\n       count(*) as trans_count,\\n       sum(state = \\'approved\\') as approved_count,\\n       sum(amount) as trans_total_amount,\\n       sum((state = \\'approved\\')*amount) as approved_total_amount\\nfrom transactions\\ngroup by month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n       country,\\n       count(*) as trans_count,\\n       sum(state = \\'approved\\') as approved_count,\\n       sum(amount) as trans_total_amount,\\n       sum((state = \\'approved\\')*amount) as approved_total_amount\\nfrom transactions\\ngroup by month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049124,
                "title": "easy-solution-beats-96",
                "content": "\\n\\n# Code\\n```\\nselect substr(trans_date, 1, 7) as month, country, count(id) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect substr(trans_date, 1, 7) as month, country, count(id) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049098,
                "title": "sql-advance-optimal-sol-beats-90-cte-join-aggregation-case-stmt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH base as(\\n  select \\n    id, \\n    concat (\\n      year(trans_date), \\n      \\'-\\', \\n      CASE \\n        WHEN month(trans_date) in (1, 2, 3, 4, 5, 6, 7, 8, 9) THEN concat(\\'0\\', month(trans_date)) \\n        ELSE month(trans_date) \\n      END\\n    ) as month \\n  from \\n    Transactions\\n) \\nselect \\n  b.month, \\n  t.country, \\n  count(t.id) as trans_count, \\n  sum(\\n    CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END\\n  ) as approved_count, \\n  sum(amount) as trans_total_amount, \\n  sum(\\n    CASE WHEN t.state = \\'approved\\' THEN amount ELSE 0 END\\n  ) as approved_total_amount \\nfrom \\n  Transactions t \\n  left outer join base b on b.id = t.id \\ngroup by \\n  month, \\n  country\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH base as(\\n  select \\n    id, \\n    concat (\\n      year(trans_date), \\n      \\'-\\', \\n      CASE \\n        WHEN month(trans_date) in (1, 2, 3, 4, 5, 6, 7, 8, 9) THEN concat(\\'0\\', month(trans_date)) \\n        ELSE month(trans_date) \\n      END\\n    ) as month \\n  from \\n    Transactions\\n) \\nselect \\n  b.month, \\n  t.country, \\n  count(t.id) as trans_count, \\n  sum(\\n    CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END\\n  ) as approved_count, \\n  sum(amount) as trans_total_amount, \\n  sum(\\n    CASE WHEN t.state = \\'approved\\' THEN amount ELSE 0 END\\n  ) as approved_total_amount \\nfrom \\n  Transactions t \\n  left outer join base b on b.id = t.id \\ngroup by \\n  month, \\n  country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049021,
                "title": "98-beat-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH NTRANS AS\\n(SELECT DATE_FORMAT(TRANS_DATE, \\'%Y-%m\\') MONTH,\\nCOUNTRY,\\nSTATE,\\nAMOUNT,\\n(CASE WHEN STATE=\\'approved\\' THEN 1 ELSE 0 END) APPROVED,\\n(CASE WHEN STATE=\\'approved\\' THEN AMOUNT ELSE 0 END) APPROVED_AMOUNT\\nFROM TRANSACTIONS)\\n\\nSELECT MONTH,COUNTRY,COUNT(STATE) TRANS_COUNT,SUM(APPROVED) APPROVED_COUNT,SUM(AMOUNT) TRANS_TOTAL_AMOUNT,SUM(APPROVED_AMOUNT) APPROVED_TOTAL_AMOUNT FROM NTRANS GROUP BY MONTH,COUNTRY\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH NTRANS AS\\n(SELECT DATE_FORMAT(TRANS_DATE, \\'%Y-%m\\') MONTH,\\nCOUNTRY,\\nSTATE,\\nAMOUNT,\\n(CASE WHEN STATE=\\'approved\\' THEN 1 ELSE 0 END) APPROVED,\\n(CASE WHEN STATE=\\'approved\\' THEN AMOUNT ELSE 0 END) APPROVED_AMOUNT\\nFROM TRANSACTIONS)\\n\\nSELECT MONTH,COUNTRY,COUNT(STATE) TRANS_COUNT,SUM(APPROVED) APPROVED_COUNT,SUM(AMOUNT) TRANS_TOTAL_AMOUNT,SUM(APPROVED_AMOUNT) APPROVED_TOTAL_AMOUNT FROM NTRANS GROUP BY MONTH,COUNTRY\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046509,
                "title": "beast-s-99",
                "content": "# Intuition\\nused inbuit month and year function\\'s\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n  concat(YEAR(trans_date),\\'-\\',\\n  if(MONTH(trans_date)<10,concat(\\'0\\',MONTH(trans_date)),MONTH(trans_date))) as month,\\n  country,\\n  COUNT(state) AS trans_count,\\n  SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY YEAR(trans_date),MONTH(trans_date), country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n  concat(YEAR(trans_date),\\'-\\',\\n  if(MONTH(trans_date)<10,concat(\\'0\\',MONTH(trans_date)),MONTH(trans_date))) as month,\\n  country,\\n  COUNT(state) AS trans_count,\\n  SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY YEAR(trans_date),MONTH(trans_date), country;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1872045,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1918001,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1975789,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1576235,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2076396,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2075164,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2074236,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2074128,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2063288,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2009187,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1872045,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1918001,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1975789,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1576235,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2076396,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2075164,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2074236,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2074128,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2063288,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2009187,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1995856,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1988090,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1977063,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1976292,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1967522,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1959964,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1958571,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1958557,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1952315,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1907626,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Operations to Reduce X to Zero",
        "question_content": "<p>You are given an integer array <code>nums</code> and an integer <code>x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code>nums</code> and subtract its value from <code>x</code>. Note that this <strong>modifies</strong> the array for future operations.</p>\n\n<p>Return <em>the <strong>minimum number</strong> of operations to reduce </em><code>x</code> <em>to <strong>exactly</strong></em> <code>0</code> <em>if it is possible</em><em>, otherwise, return </em><code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,4,2,3], x = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The optimal solution is to remove the last two elements to reduce x to zero.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,6,7,8,9], x = 4\n<strong>Output:</strong> -1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,20,1,1,3], x = 10\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= x &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2136570,
                "title": "change-your-perspective-java-explanation",
                "content": "### Logic\\nInitially, this question might look like a DP problem: pick either left or right recursively and collect the number of operations along the way. A brute force approach would result in an `O(2^n)` complexity which isn\\'t great. Memoization would improve this but we\\'ll exceed the memory limit as I\\'ve tested. Besides, we can do better.\\n\\nBy simply reframing the question, we can come up with an `O(n)` complexity solution. The difficulty in this question arises from deciding whether to choose the left or the right element to remove at any given point. However, while we\\'re removing elements from the array, we\\'re definitely going to be letting some elements remain as well. In particular, the middle elements. \\n\\n**Key observation:**\\n> The number of elements removed equals <ins>n minus the number of elements that *aren\\'t* removed</ins>.\\n>> Therefore, to find the minimum number of elements to remove, we can find the maximum number of elements to not remove!\\n\\n\\n\\nSo, instead of trying to find the minimum number of operations, why don\\'t we focus on finding the longest subarray in the middle. One main thing to note is that our subarray should sum to **`sum - x`** (where `sum` is the sum of all elements in our array).\\nWhy? because the middle elements are technically the ones we don\\'t want. If the sum of the outer elements equals `x`, then we\\'re looking for a middle sum of `sum - x`. If this doesn\\'t quite make sense, pay attention to the below diagram with `nums = [1,5,3,9,1,7,1,3], x = 12`:\\n![image](https://assets.leetcode.com/users/images/c708624c-73d5-496b-b275-e624493ba520_1654915557.0749335.png)\\n(Keep in mind that this approach only works due to the absence of negative numbers!)\\n___\\n### Finding our max middle subarray length:\\nWe can find this using a two-pointer / sliding window approach. Start left and right both at index 0.\\n* Increment right until the current window sum is `> sum - x`\\n* Update our `maxLength` if and only if our current window sum `== sum - x`\\n* Repeat the above steps until we reach the end of the array.\\n\\n![image](https://assets.leetcode.com/users/images/bba3415f-8822-4040-9f9e-4515cc4bba5f_1654910535.4160361.png)\\n\\nAwesome! Now we have everything we need to start coding.\\n___\\n### How should I approach this question in an interview?\\nWhen you\\'re presented this question, it might not be obvious that there exists a solution other than DP (at least, it wasn\\'t obvious for me!). So, how would you know to approach the question through any other means? What saved me when doing this question was the simple realisation that removing edge values is the same as shrinking the array. Hence, there will always remain a middle subarray of length >= 0.\\n\\nA habit that I\\'ve developed over time whenever I run into trouble coming up with a solution is to <ins>reframe the question</ins>. Often times when you\\'re given a question in an interview, it\\'s riddled with questionable requirements or red herrings. The interviewer is likely expecting you to *extract out* the core requirements from the question and truncate it down to as simple a question as you can manage.\\n\\nIt does take time and practice to spot the owl from the trees. That being said, here are some effective ways to ease yourself into the right mindset: \\n* If a question is implicitly asking for A when the question is actually solved using B, draw examples and look for alternate patterns.\\n* Pay attention to the constraints of the inputs/outputs (in this question, the values being strictly positive was a hint!)\\n* Be creative! Even try rewording the question to something as different as you can think of while still maintaining the requirements of the question. \\n\\nIf all else fails, pay attention to the subtle hints your interviewer might be throwing your way. (By the way, the best way to get hints from your interviewer is to explain all your thoughts to them as you go. If they don\\'t know where you\\'re stuck, they can\\'t help you). \\n\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n```java\\npublic int minOperations(int[] nums, int x) {\\n\\tint sum = 0;\\n\\tfor (int num: nums) sum += num;\\n\\n\\tint maxLength = -1, currSum = 0;\\n\\tfor (int l=0, r=0; r<nums.length; r++) {\\n\\t\\tcurrSum += nums[r];\\n\\t\\twhile (l <= r && currSum > sum - x) currSum -= nums[l++];\\n\\t\\tif (currSum == sum - x) maxLength = Math.max(maxLength, r-l+1);\\n\\t}\\n\\n\\treturn maxLength == -1 ? -1 : nums.length - maxLength;\\n}\\n```\\n\\n**Time complexity:** `O(n)`\\n**Space complexity:** `O(1)`",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\npublic int minOperations(int[] nums, int x) {\\n\\tint sum = 0;\\n\\tfor (int num: nums) sum += num;\\n\\n\\tint maxLength = -1, currSum = 0;\\n\\tfor (int l=0, r=0; r<nums.length; r++) {\\n\\t\\tcurrSum += nums[r];\\n\\t\\twhile (l <= r && currSum > sum - x) currSum -= nums[l++];\\n\\t\\tif (currSum == sum - x) maxLength = Math.max(maxLength, r-l+1);\\n\\t}\\n\\n\\treturn maxLength == -1 ? -1 : nums.length - maxLength;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935935,
                "title": "java-detailed-explanation-o-n-prefix-sum-map-longest-target-sub-array",
                "content": "**Key Notes:**\\n- We could use dfs+memo or BFS, but they are too slow and will TLE (?)\\n- If it exists an answer, then it means we have **a subarray in the middle of original array whose sum is == totalSum - x**\\n- If we want to minimize our operations, then we should **maximize the length of the middle subarray.**\\n\\t- Then the qeustion becomes: *Find the Longest Subarray with Sum Equals to TotalSum - X*\\n\\t- We could simply use Map + Prefix Sum to get it!\\n\\n![image](https://assets.leetcode.com/users/images/bf560734-2107-4a1b-811a-f3dd6d54c6e6_1605413025.6626496.png)\\n\\n**Similar Idea:** \\n- [918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/)\\n- [1423. Maximum Points You Can Obtain from Cards](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/)\\n\\n```java\\nint target = -x;\\nfor (int num : nums) target += num;\\n\\nif (target == 0) return nums.length;  // since all elements are positive, we have to take all of them\\n\\nMap<Integer, Integer> map = new HashMap<>();\\nmap.put(0, -1);\\nint sum = 0;\\nint res = Integer.MIN_VALUE;\\n\\nfor (int i = 0; i < nums.length; ++i) {\\n\\n\\tsum += nums[i];\\n\\tif (map.containsKey(sum - target)) {\\n\\t\\tres = Math.max(res, i - map.get(sum - target));\\n\\t}\\n\\n    // no need to check containsKey since sum is unique\\n\\tmap.put(sum, i);\\n}\\n\\nreturn res == Integer.MIN_VALUE ? -1 : nums.length - res;\\n```",
                "solutionTags": [],
                "code": "```java\\nint target = -x;\\nfor (int num : nums) target += num;\\n\\nif (target == 0) return nums.length;  // since all elements are positive, we have to take all of them\\n\\nMap<Integer, Integer> map = new HashMap<>();\\nmap.put(0, -1);\\nint sum = 0;\\nint res = Integer.MIN_VALUE;\\n\\nfor (int i = 0; i < nums.length; ++i) {\\n\\n\\tsum += nums[i];\\n\\tif (map.containsKey(sum - target)) {\\n\\t\\tres = Math.max(res, i - map.get(sum - target));\\n\\t}\\n\\n    // no need to check containsKey since sum is unique\\n\\tmap.put(sum, i);\\n}\\n\\nreturn res == Integer.MIN_VALUE ? -1 : nums.length - res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1080880,
                "title": "are-you-stuck-once-read-this-logic-explained-clearly-easy-to-understand",
                "content": "so , the problem is saying that we can remove either leftmost or rightmost element and we have to remove them in such a way that \\n1.remove minimum number of elements and\\n2. sum of all removed element is X \\n\\nNow main point is that if successfully remove elements such that sum of removed elements is X , then \\n1. sum of remaining array elements will be (sum-X) \\n2. remaing array will be subarray of original array.\\n\\n![image](https://assets.leetcode.com/users/images/e2f0f0ae-f30d-4c7c-9057-23bbbae4b5ed_1614173643.6058571.png)\\n.\\n\\nSo , now our task is find subaarray whose sum is (sum - X) and its length is maximum ( because we want to remove minimum number of elements , so we will have to maximise remianing element ) .\\n\\ntime - O(N)\\nspace - O(1)\\n\\n```\\nint minOperations(vector<int>& v, int x) \\n    {\\n        int i,len=0,sum1=0,sum2=0;\\n        for(i=0;i<v.size();i++)\\n            sum2+=v[i];                  // calculating sum of whole array \\n\\t\\t\\t\\n        sum2-=x;   //  this is sum of remiaing elements . after removing X \\n\\t\\t\\n        if(sum2==0)        // sum of array is equal to X . means we\\'ll have to remove all elements\\n            return v.size();\\n\\t\\t\\t\\n// sliding window technique \\n// i points to begining of subarray and j points to end of subarray \\n\\n\\t\\t// sum2 is desired sum while sum1 is current sum\\n        int j;i=0;\\n        for(j=0;j<v.size();j++)\\n        {\\n            sum1+=v[j];\\n\\t\\t\\t\\n            while(i<v.size()&&sum1>sum) // if sum of current subaaray is greater than desired sum\\n                sum1-=v[i++];\\n\\t\\t\\t\\t\\n            if(sum1==sum2)  // if sum of current subarray is equal to desired sum then update length\\n                len=max(len,j-i+1); // we want subarray  with maximum length \\n        }\\n        if(!len)        // No subarray found with desired sum .\\n            return -1;\\n        return v.size()-len;\\n    }\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "so , the problem is saying that we can remove either leftmost or rightmost element and we have to remove them in such a way that \\n1.remove minimum number of elements and\\n2. sum of all removed element is X \\n\\nNow main point is that if successfully remove elements such that sum of removed elements is X , then \\n1. sum of remaining array elements will be (sum-X) \\n2. remaing array will be subarray of original array.\\n\\n![image](https://assets.leetcode.com/users/images/e2f0f0ae-f30d-4c7c-9057-23bbbae4b5ed_1614173643.6058571.png)\\n.\\n\\nSo , now our task is find subaarray whose sum is (sum - X) and its length is maximum ( because we want to remove minimum number of elements , so we will have to maximise remianing element ) .\\n\\ntime - O(N)\\nspace - O(1)\\n\\n```\\nint minOperations(vector<int>& v, int x) \\n    {\\n        int i,len=0,sum1=0,sum2=0;\\n        for(i=0;i<v.size();i++)\\n            sum2+=v[i];                  // calculating sum of whole array \\n\\t\\t\\t\\n        sum2-=x;   //  this is sum of remiaing elements . after removing X \\n\\t\\t\\n        if(sum2==0)        // sum of array is equal to X . means we\\'ll have to remove all elements\\n            return v.size();\\n\\t\\t\\t\\n// sliding window technique \\n// i points to begining of subarray and j points to end of subarray \\n\\n\\t\\t// sum2 is desired sum while sum1 is current sum\\n        int j;i=0;\\n        for(j=0;j<v.size();j++)\\n        {\\n            sum1+=v[j];\\n\\t\\t\\t\\n            while(i<v.size()&&sum1>sum) // if sum of current subaaray is greater than desired sum\\n                sum1-=v[i++];\\n\\t\\t\\t\\t\\n            if(sum1==sum2)  // if sum of current subarray is equal to desired sum then update length\\n                len=max(len,j-i+1); // we want subarray  with maximum length \\n        }\\n        if(!len)        // No subarray found with desired sum .\\n            return -1;\\n        return v.size()-len;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2136555,
                "title": "c-python-simple-solution-w-explanation-sliding-window",
                "content": "Sometimes, converting a problem into some other familiar one helps a lot. This question is one of them.\\nLet me state a different problem, and your task is to relate how solving this problem will help in solving the actual one.\\n> Given an array containing integers, your task is to find the length of the longest subarray with a given sum.\\n\\nIf you were able to relate, congratulations! \\uD83C\\uDF89\\nAnd if not, don\\'t worry; it happens with all of us (or maybe use hints \\uD83D\\uDE09).\\nContinue reading below to find the solution.\\n___\\n___\\n\\u2705 **Solution I - Sliding Window [Accepted]**\\n\\nWe need to make `prefix_sum + suffix_sum = x`. But instead of this, finding a subarray whose sum is `sum(nums) - x` will do the job. Now we only need to maximize the length of this subarray to minimize the length of `prefix + suffix`, which can be done greedily. By doing this, we can get the minimum length, i.e., the minimum number of operations to reduce `x` to exactly `0` (if possible).\\n\\nIf you haven\\'t heard the term \"sliding window\" before, visit [this link](https://stackoverflow.com/questions/8269916/what-is-sliding-window-algorithm-examples).\\n\\n1. Let us take a sliding window whose ends are defined by `start_idx` and `end_idx`.\\n2. If the sum of this sliding window (subarray) exceeds the target, keep reducing the window size (by increasing `start_idx`) until its sum becomes `<= target`.\\n3. If the sum becomes equal to the target, compare the length, and store if it exceeds the previous length.\\n4. Return `-1` if the sum of the sliding window never becomes equal to `target`.\\n\\n<iframe src=\"https://leetcode.com/playground/PoeSGL3x/shared\" frameBorder=\"0\" width=\"1080\" height=\"450\"></iframe>\\n\\n- **Time Complexity:** `O(n)`\\n- **Space Complexity:** `O(1)`\\n\\n___\\n___\\nIf you like the solution, please **upvote**! \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "Sometimes, converting a problem into some other familiar one helps a lot. This question is one of them.\\nLet me state a different problem, and your task is to relate how solving this problem will help in solving the actual one.\\n> Given an array containing integers, your task is to find the length of the longest subarray with a given sum.\\n\\nIf you were able to relate, congratulations! \\uD83C\\uDF89\\nAnd if not, don\\'t worry; it happens with all of us (or maybe use hints \\uD83D\\uDE09).\\nContinue reading below to find the solution.\\n___\\n___\\n\\u2705 **Solution I - Sliding Window [Accepted]**\\n\\nWe need to make `prefix_sum + suffix_sum = x`. But instead of this, finding a subarray whose sum is `sum(nums) - x` will do the job. Now we only need to maximize the length of this subarray to minimize the length of `prefix + suffix`, which can be done greedily. By doing this, we can get the minimum length, i.e., the minimum number of operations to reduce `x` to exactly `0` (if possible).\\n\\nIf you haven\\'t heard the term \"sliding window\" before, visit [this link](https://stackoverflow.com/questions/8269916/what-is-sliding-window-algorithm-examples).\\n\\n1. Let us take a sliding window whose ends are defined by `start_idx` and `end_idx`.\\n2. If the sum of this sliding window (subarray) exceeds the target, keep reducing the window size (by increasing `start_idx`) until its sum becomes `<= target`.\\n3. If the sum becomes equal to the target, compare the length, and store if it exceeds the previous length.\\n4. Return `-1` if the sum of the sliding window never becomes equal to `target`.\\n\\n<iframe src=\"https://leetcode.com/playground/PoeSGL3x/shared\" frameBorder=\"0\" width=\"1080\" height=\"450\"></iframe>\\n\\n- **Time Complexity:** `O(n)`\\n- **Space Complexity:** `O(1)`\\n\\n___\\n___\\nIf you like the solution, please **upvote**! \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4066422,
                "title": "96-51-sliding-window",
                "content": "# Comprehensive Guide to Solving \"Minimum Operations to Reduce X to Zero\"\\n\\n## Introduction & Problem Statement\\n\\nGiven an integer array `nums` and an integer `x`, the task is to find the minimum number of operations to reduce `x` to exactly 0 by removing either the leftmost or rightmost element from the array `nums` in each operation. What makes this problem intriguing is that it\\'s not a straightforward minimization problem; it involves searching for subarrays, working with prefix sums, and applying two-pointer techniques.\\n\\n## Key Concepts and Constraints\\n\\n### What Makes This Problem Unique?\\n\\n1. **Array Constraints**:  \\n    - $$1 \\\\leq \\\\text{nums.length} \\\\leq 10^5$$\\n    - $$1 \\\\leq \\\\text{nums}[i] \\\\leq 10^4$$\\n  \\n2. **Target Number `x`**:\\n    - $$1 \\\\leq x \\\\leq 10^9$$\\n\\n3. **Operations**:  \\n    You can either remove the leftmost or the rightmost element from the array `nums` and subtract its value from $$ x $$.\\n\\n4. **Minimization Objective**:  \\n    The goal is to minimize the number of operations to reduce $$ x $$ to zero.\\n\\n---\\n\\n## One Primary Strategy to Solve the Problem:\\n\\n## Live Coding & Explain\\nhttps://youtu.be/3dhzAV81hBI?si=QgcosgkvdbMBBKtq\\n\\n# Approach: Sliding Window with Prefix Sum\\n\\nTo solve this problem, we apply the Sliding Window technique with a twist involving Prefix Sum. We use two pointers, `left` and `right`, to traverse the array `nums` and find the longest subarray whose sum equals the total sum of elements in `nums` minus `x`.\\n\\n## Key Data Structures:\\n\\n- **max_len**: An integer to store the length of the longest subarray that can be excluded to make the sum equal to `x`.\\n- **cur_sum**: An integer to store the sum of elements in the current subarray.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialize and Calculate the Target**:\\n   - Compute `target = sum(nums) - x`, as we\\'re interested in finding a subarray with this sum.\\n   - Initialize `max_len`, `cur_sum`, and `left` to 0.\\n  \\n2. **Check for Edge Cases**:\\n   - If `target` is zero, it means we need to remove all elements to make the sum equal to `x`. In this case, return the total number of elements, `n`.\\n\\n3. **Traverse the Array with Two Pointers**:\\n   - Iterate through `nums` using a `right` pointer.\\n   - Update `cur_sum` by adding the current element `nums[right]`.\\n   \\n4. **Sliding Window Adjustment**:\\n   - If `cur_sum` exceeds `target`, slide the `left` pointer to the right by one position and decrease `cur_sum` by `nums[left]`.\\n\\n5. **Update Max Length**:\\n   - If `cur_sum` matches `target`, update `max_len` with the length of the current subarray, which is `right - left + 1`.\\n\\n6. **Conclude and Return**:\\n   - After the loop, if `max_len` is non-zero, return `n - max_len`. Otherwise, return -1, indicating it\\'s not possible to reduce `x` to zero.\\n\\n## Complexity Analysis:\\n\\n**Time Complexity**: \\n- Since we traverse the array only once, the time complexity is $$ O(n) $$.\\n\\n**Space Complexity**: \\n- The algorithm uses only a constant amount of extra space, thus having a space complexity of $$ O(1) $$.\\n\\n---\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target, n = sum(nums) - x, len(nums)\\n        \\n        if target == 0:\\n            return n\\n        \\n        max_len = cur_sum = left = 0\\n        \\n        for right, val in enumerate(nums):\\n            cur_sum += val\\n            while left <= right and cur_sum > target:\\n                cur_sum -= nums[left]\\n                left += 1\\n            if cur_sum == target:\\n                max_len = max(max_len, right - left + 1)\\n        \\n        return n - max_len if max_len else -1\\n```\\n``` Go []\\nfunc minOperations(nums []int, x int) int {\\n    target, n := -x, len(nums)\\n    for _, num := range nums {\\n        target += num\\n    }\\n    \\n    if target == 0 {\\n        return n\\n    }\\n    \\n    maxLen, curSum, left := 0, 0, 0\\n    \\n    for right, val := range nums {\\n        curSum += val\\n        for left <= right && curSum > target {\\n            curSum -= nums[left]\\n            left++\\n        }\\n        if curSum == target {\\n            if right - left + 1 > maxLen {\\n                maxLen = right - left + 1\\n            }\\n        }\\n    }\\n    \\n    if maxLen != 0 {\\n        return n - maxLen\\n    }\\n    return -1\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>, x: i32) -> i32 {\\n        let mut target: i32 = -x;\\n        let n = nums.len() as i32;\\n        \\n        for &num in &nums {\\n            target += num;\\n        }\\n        \\n        if target == 0 {\\n            return n;\\n        }\\n        \\n        let (mut max_len, mut cur_sum, mut left) = (0, 0, 0);\\n        \\n        for right in 0..n as usize {\\n            cur_sum += nums[right];\\n            while left <= right as i32 && cur_sum > target {\\n                cur_sum -= nums[left as usize];\\n                left += 1;\\n            }\\n            if cur_sum == target {\\n                max_len = std::cmp::max(max_len, right as i32 - left + 1);\\n            }\\n        }\\n        \\n        if max_len != 0 { n - max_len } else { -1 }\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int target = 0, n = nums.size();\\n        for (int num : nums) target += num;\\n        target -= x;\\n        \\n        if (target == 0) return n;\\n        \\n        int max_len = 0, cur_sum = 0, left = 0;\\n        \\n        for (int right = 0; right < n; ++right) {\\n            cur_sum += nums[right];\\n            while (left <= right && cur_sum > target) {\\n                cur_sum -= nums[left];\\n                left++;\\n            }\\n            if (cur_sum == target) {\\n                max_len = max(max_len, right - left + 1);\\n            }\\n        }\\n        \\n        return max_len ? n - max_len : -1;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int target = -x, n = nums.length;\\n        for (int num : nums) target += num;\\n        \\n        if (target == 0) return n;\\n        \\n        int maxLen = 0, curSum = 0, left = 0;\\n        \\n        for (int right = 0; right < n; ++right) {\\n            curSum += nums[right];\\n            while (left <= right && curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n            if (curSum == target) {\\n                maxLen = Math.max(maxLen, right - left + 1);\\n            }\\n        }\\n        \\n        return maxLen != 0 ? n - maxLen : -1;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function minOperations($nums, $x) {\\n        $target = 0;\\n        $n = count($nums);\\n        foreach ($nums as $num) $target += $num;\\n        $target -= $x;\\n        \\n        if ($target === 0) return $n;\\n        \\n        $maxLen = $curSum = $left = 0;\\n        \\n        for ($right = 0; $right < $n; ++$right) {\\n            $curSum += $nums[$right];\\n            while ($left <= $right && $curSum > $target) {\\n                $curSum -= $nums[$left];\\n                $left++;\\n            }\\n            if ($curSum === $target) {\\n                $maxLen = max($maxLen, $right - $left + 1);\\n            }\\n        }\\n        \\n        return $maxLen ? $n - $maxLen : -1;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} x\\n * @return {number}\\n */\\nvar minOperations = function(nums, x) {\\n    let target = -x, n = nums.length;\\n    for (let num of nums) target += num;\\n    \\n    if (target === 0) return n;\\n    \\n    let maxLen = 0, curSum = 0, left = 0;\\n    \\n    for (let right = 0; right < n; ++right) {\\n        curSum += nums[right];\\n        while (left <= right && curSum > target) {\\n            curSum -= nums[left];\\n            left++;\\n        }\\n        if (curSum === target) {\\n            maxLen = Math.max(maxLen, right - left + 1);\\n        }\\n    }\\n    \\n    return maxLen ? n - maxLen : -1;\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        int target = -x, n = nums.Length;\\n        foreach (int num in nums) target += num;\\n        \\n        if (target == 0) return n;\\n        \\n        int maxLen = 0, curSum = 0, left = 0;\\n        \\n        for (int right = 0; right < n; ++right) {\\n            curSum += nums[right];\\n            while (left <= right && curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n            if (curSum == target) {\\n                maxLen = Math.Max(maxLen, right - left + 1);\\n            }\\n        }\\n        \\n        return maxLen != 0 ? n - maxLen : -1;\\n    }\\n}\\n```\\n\\n## Performance\\n\\n| Language  | Fastest Runtime (ms) | Memory Usage (MB) |\\n|-----------|----------------------|-------------------|\\n| Java      | 4                    | 56                |\\n| Rust      | 15                   | 3                 |\\n| JavaScript| 76                   | 52.8              |\\n| C++       | 110                  | 99                |\\n| Go        | 137                  | 8.6               |\\n| C#        | 236                  | 54.6              |\\n| PHP       | 340                  | 31.8              |\\n| Python3   | 913                  | 30.2              |\\n\\n![v3.png](https://assets.leetcode.com/users/images/efa56265-94fe-4673-a7d5-8a6d85ef7e55_1695170969.160347.png)\\n\\n\\n## Live Coding in Rust\\nhttps://youtu.be/CU93rMboS7w?si=r2ryBueD4fCiKZ7w\\n\\n## Conclusion\\n\\nThe problem \"Minimum Operations to Reduce X to Zero\" may look complicated initially due to its minimization objective. However, understanding the underlying logic of subarray sums and applying a sliding window approach can simplify it. This not only solves the problem efficiently but also enhances one\\'s understanding of array manipulation techniques. Happy coding!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target, n = sum(nums) - x, len(nums)\\n        \\n        if target == 0:\\n            return n\\n        \\n        max_len = cur_sum = left = 0\\n        \\n        for right, val in enumerate(nums):\\n            cur_sum += val\\n            while left <= right and cur_sum > target:\\n                cur_sum -= nums[left]\\n                left += 1\\n            if cur_sum == target:\\n                max_len = max(max_len, right - left + 1)\\n        \\n        return n - max_len if max_len else -1\\n```\n``` Go []\\nfunc minOperations(nums []int, x int) int {\\n    target, n := -x, len(nums)\\n    for _, num := range nums {\\n        target += num\\n    }\\n    \\n    if target == 0 {\\n        return n\\n    }\\n    \\n    maxLen, curSum, left := 0, 0, 0\\n    \\n    for right, val := range nums {\\n        curSum += val\\n        for left <= right && curSum > target {\\n            curSum -= nums[left]\\n            left++\\n        }\\n        if curSum == target {\\n            if right - left + 1 > maxLen {\\n                maxLen = right - left + 1\\n            }\\n        }\\n    }\\n    \\n    if maxLen != 0 {\\n        return n - maxLen\\n    }\\n    return -1\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>, x: i32) -> i32 {\\n        let mut target: i32 = -x;\\n        let n = nums.len() as i32;\\n        \\n        for &num in &nums {\\n            target += num;\\n        }\\n        \\n        if target == 0 {\\n            return n;\\n        }\\n        \\n        let (mut max_len, mut cur_sum, mut left) = (0, 0, 0);\\n        \\n        for right in 0..n as usize {\\n            cur_sum += nums[right];\\n            while left <= right as i32 && cur_sum > target {\\n                cur_sum -= nums[left as usize];\\n                left += 1;\\n            }\\n            if cur_sum == target {\\n                max_len = std::cmp::max(max_len, right as i32 - left + 1);\\n            }\\n        }\\n        \\n        if max_len != 0 { n - max_len } else { -1 }\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int target = 0, n = nums.size();\\n        for (int num : nums) target += num;\\n        target -= x;\\n        \\n        if (target == 0) return n;\\n        \\n        int max_len = 0, cur_sum = 0, left = 0;\\n        \\n        for (int right = 0; right < n; ++right) {\\n            cur_sum += nums[right];\\n            while (left <= right && cur_sum > target) {\\n                cur_sum -= nums[left];\\n                left++;\\n            }\\n            if (cur_sum == target) {\\n                max_len = max(max_len, right - left + 1);\\n            }\\n        }\\n        \\n        return max_len ? n - max_len : -1;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int target = -x, n = nums.length;\\n        for (int num : nums) target += num;\\n        \\n        if (target == 0) return n;\\n        \\n        int maxLen = 0, curSum = 0, left = 0;\\n        \\n        for (int right = 0; right < n; ++right) {\\n            curSum += nums[right];\\n            while (left <= right && curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n            if (curSum == target) {\\n                maxLen = Math.max(maxLen, right - left + 1);\\n            }\\n        }\\n        \\n        return maxLen != 0 ? n - maxLen : -1;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function minOperations($nums, $x) {\\n        $target = 0;\\n        $n = count($nums);\\n        foreach ($nums as $num) $target += $num;\\n        $target -= $x;\\n        \\n        if ($target === 0) return $n;\\n        \\n        $maxLen = $curSum = $left = 0;\\n        \\n        for ($right = 0; $right < $n; ++$right) {\\n            $curSum += $nums[$right];\\n            while ($left <= $right && $curSum > $target) {\\n                $curSum -= $nums[$left];\\n                $left++;\\n            }\\n            if ($curSum === $target) {\\n                $maxLen = max($maxLen, $right - $left + 1);\\n            }\\n        }\\n        \\n        return $maxLen ? $n - $maxLen : -1;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums\\n * @param {number} x\\n * @return {number}\\n */\\nvar minOperations = function(nums, x) {\\n    let target = -x, n = nums.length;\\n    for (let num of nums) target += num;\\n    \\n    if (target === 0) return n;\\n    \\n    let maxLen = 0, curSum = 0, left = 0;\\n    \\n    for (let right = 0; right < n; ++right) {\\n        curSum += nums[right];\\n        while (left <= right && curSum > target) {\\n            curSum -= nums[left];\\n            left++;\\n        }\\n        if (curSum === target) {\\n            maxLen = Math.max(maxLen, right - left + 1);\\n        }\\n    }\\n    \\n    return maxLen ? n - maxLen : -1;\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        int target = -x, n = nums.Length;\\n        foreach (int num in nums) target += num;\\n        \\n        if (target == 0) return n;\\n        \\n        int maxLen = 0, curSum = 0, left = 0;\\n        \\n        for (int right = 0; right < n; ++right) {\\n            curSum += nums[right];\\n            while (left <= right && curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n            if (curSum == target) {\\n                maxLen = Math.Max(maxLen, right - left + 1);\\n            }\\n        }\\n        \\n        return maxLen != 0 ? n - maxLen : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935974,
                "title": "c-sliding-window-o-n-time-o-1-space",
                "content": "**This problem is equivalent to finding the longest subarray whose sum is == totalSum - x**\\n\\n```\\npublic class Solution\\n{\\n    public int MinOperations(int[] nums, int x)\\n    {\\n        int sum = nums.Sum() - x;\\n        if(sum < 0) return -1;\\n        if(sum == 0) return nums.Length;\\n        int start = 0, cur = 0, len = -1;\\n        for(int end = 0; end < nums.Length; end++)\\n        {\\n            if (cur < sum)\\n                cur += nums[end];\\n            while (cur >= sum)\\n            {\\n                if (cur == sum)\\n                    len = Math.Max(len, end - start + 1);\\n                cur -= nums[start++];\\n            }\\n        }\\n\\n        return len == -1 ? -1 : nums.Length - len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MinOperations(int[] nums, int x)\\n    {\\n        int sum = nums.Sum() - x;\\n        if(sum < 0) return -1;\\n        if(sum == 0) return nums.Length;\\n        int start = 0, cur = 0, len = -1;\\n        for(int end = 0; end < nums.Length; end++)\\n        {\\n            if (cur < sum)\\n                cur += nums[end];\\n            while (cur >= sum)\\n            {\\n                if (cur == sum)\\n                    len = Math.Max(len, end - start + 1);\\n                cur -= nums[start++];\\n            }\\n        }\\n\\n        return len == -1 ? -1 : nums.Length - len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935956,
                "title": "two-sum-vs-hash-map",
                "content": "Started solving this problem using DP, but then realized that the constraints are too large.\\n\\nThen, I realized that, to reach `x`, we will take `l` numbers from the left, and `r` numbers from the right. We just need to find `min(l + r)`.\\n\\n#### Approach 1: Hash Map\\nAs you count the sum of the first `l` numbers, you need to find a complement `(x - sum)` number formed by numbers on the right. To do so, we can use a hashmap where we will store the rolling sum.\\n**C++**\\n```cpp\\nint minOperations(vector<int>& nums, int x) {\\n    unordered_map<int, int> left;\\n    int res = INT_MAX;\\n    for (auto l = 0, sum = 0; l <= nums.size() && sum <= x; ++l) {\\n        left[sum] = l;\\n        if (l < nums.size())\\n            sum += nums[l];\\n    }\\n    for (int r = nums.size() - 1, sum = 0; r >= 0 && sum <= x; --r) {\\n        auto it = left.find(x - sum);\\n        if (it != end(left) && r + 1 >= it->second) {\\n            res = min(res, (int)nums.size() - r - 1 + it->second);\\n        }\\n        sum += nums[r];\\n    }\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\\n#### Approach 2: Two Sum\\n> Note that this only works because we do not have negative values in the input array.\\n\\nI got a feeling that this problem is a twisted variation of [Two Sum](https://leetcode.com/problems/two-sum/). The rolling sum always increases, so we can use two pointers - both starting from one side - to find portions of the array that sum to `x`. \\n**C++**\\n```cpp\\nint minOperations(vector<int>& nums, int x) {\\n    int sum = accumulate(begin(nums), end(nums), 0);\\n    int l = 0, r = 0, res = INT_MAX, sz = nums.size();\\n    while (l <= r)\\n        if (sum >= x) {\\n            if (sum == x)\\n                res = min(res, l + sz - r);\\n            if (r < sz)\\n                sum -= nums[r++];\\n            else\\n                break;\\n        }\\n        else\\n            sum += nums[l++];\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minOperations(vector<int>& nums, int x) {\\n    unordered_map<int, int> left;\\n    int res = INT_MAX;\\n    for (auto l = 0, sum = 0; l <= nums.size() && sum <= x; ++l) {\\n        left[sum] = l;\\n        if (l < nums.size())\\n            sum += nums[l];\\n    }\\n    for (int r = nums.size() - 1, sum = 0; r >= 0 && sum <= x; --r) {\\n        auto it = left.find(x - sum);\\n        if (it != end(left) && r + 1 >= it->second) {\\n            res = min(res, (int)nums.size() - r - 1 + it->second);\\n        }\\n        sum += nums[r];\\n    }\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\n```cpp\\nint minOperations(vector<int>& nums, int x) {\\n    int sum = accumulate(begin(nums), end(nums), 0);\\n    int l = 0, r = 0, res = INT_MAX, sz = nums.size();\\n    while (l <= r)\\n        if (sum >= x) {\\n            if (sum == x)\\n                res = min(res, l + sz - r);\\n            if (r < sz)\\n                sum -= nums[r++];\\n            else\\n                break;\\n        }\\n        else\\n            sum += nums[l++];\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016199,
                "title": "python-o-n-solution-using-cumulative-sums",
                "content": "We can reformulate this problem: we need to choose several values from the beginning and several values from end, such that sum of this numbers is equal to `x`. It is equivalent to finding some contiguous subarray, such that it has sum of elements equal to `sum(nums) - x`, which has the biggest length. In this way problem becomes quite classical and I prefer to solve it using cumulative sums.\\n\\nImagine, that we have `nums = [1,1,4,2,3], x = 5`. Then we need to find contiguous subarray, such that its sum is equal to `sum(nums) - x = 6`. It means, that we need to find two cumulative sums, one of them equal to `goal` plus another one. Note also, that all `nums` are **positive**, so all cumulative sums will be different.\\n\\nWe keep in `dic` indexes for each cumulative sum, so, when we iterate `num in dic` and check if `num + goal in dic`, then we can get length of window: `dic[num + goal] - dic[num]` and update `ans`.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity as well.\\n\\n**Remark**: this idea will work also if we can have **negative** numbers in our `nums`. We need to keep in `dic` smallest and biggest indexes for each value of cumulative sum and then find maximum between ends of two segments.  If we asked to find window of minimum length, and we have negative numbers, it is also possible, but we need to keep defaultdict of all indexes and then use idea of merge sort to find closest pair. Complexities will be also `O(n)`. I think I saw these problems on leetcode, but I do not remember they numbers, if you recognize them, please let me know!\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums, x) :\\n        cumsum = [0] + list(accumulate(nums))\\n        dic = {c:i for i,c in enumerate(cumsum)}\\n        goal = cumsum[-1] - x\\n        ans = -float(\"inf\")\\n\\n        if goal < 0: return -1\\n\\n        for num in dic:\\n            if num + goal in dic:\\n                ans = max(ans, dic[num + goal] - dic[num])\\n\\n        return len(nums) - ans if ans != -float(\"inf\") else -1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums, x) :\\n        cumsum = [0] + list(accumulate(nums))\\n        dic = {c:i for i,c in enumerate(cumsum)}\\n        goal = cumsum[-1] - x\\n        ans = -float(\"inf\")\\n\\n        if goal < 0: return -1\\n\\n        for num in dic:\\n            if num + goal in dic:\\n                ans = max(ans, dic[num + goal] - dic[num])\\n\\n        return len(nums) - ans if ans != -float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938838,
                "title": "c-sliding-window-easy-solution",
                "content": "**If helpful do upvote\\nThanks**\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total=0, n=nums.size();\\n        for(auto i:nums) total+=i;\\n        if(x>total) return -1;\\n        int left=0,right=0, curr=0, ans=-1;\\n        for(; right<n;right++){\\n            curr+=nums[right];\\n            while(curr>total-x&&left<=right){\\n                curr-=nums[left];\\n                left++;\\n            }\\n            if(curr==total-x) ans=max(ans, right-left+1);\\n        }\\n        if(ans==-1) return ans;\\n        return n-ans;\\n                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total=0, n=nums.size();\\n        for(auto i:nums) total+=i;\\n        if(x>total) return -1;\\n        int left=0,right=0, curr=0, ans=-1;\\n        for(; right<n;right++){\\n            curr+=nums[right];\\n            while(curr>total-x&&left<=right){\\n                curr-=nums[left];\\n                left++;\\n            }\\n            if(curr==total-x) ans=max(ans, right-left+1);\\n        }\\n        if(ans==-1) return ans;\\n        return n-ans;\\n                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066462,
                "title": "95-97-two-pointers-sliding-window-commented-code",
                "content": "# Porblem Description\\nGiven an array of integers, `nums`, and an integer `x`. Each element in `nums` can be subtracted from x. The **goal** is to reduce `x` to exactly `0` using a **minimum** number of operations.\\n\\nIn each **operation**, you can choose to **remove** either the `leftmost` or the `rightmost` element from the array `nums` and subtract its value from `x`.\\n\\n- **Constraints:**\\n- `1 <= nums.length <= 10e5`\\n- `1 <= nums[i] <= 10e4`\\n- `1 <= x <= 10e9`\\n\\n---\\n\\n\\n\\n# Intuition\\nHello There\\uD83D\\uDE00\\nLet\\'s take a look on our today\\'s interesting problem\\uD83D\\uDE80\\n\\nToday we have **two things**, **array** of intergers and **number** `x`.\\nWe can do **one** operation **each** time select `rightmost` or `leftmost` item from the array and **subtract** it from `x`.\\nThe goal is to make `x` equal to `zero`.\\n\\nLook interesting \\uD83E\\uDD2F\\nLet\\'s **simplify** our problem a little ?\\nWe only need to know **sum** of numbers from `right` and `left` that equal to `x`.\\nBut how we get this number ?\\uD83E\\uDD14\\nLet\\'s see this example:\\n```\\nnums = (3, 4, 7, 1, 3, 8, 2, 4), x = 9\\n```\\nwe can see here that the answer of minimum elements from `left` and `right` (operations) is `3` which are `(3, 2, 4)`\\nThere is also something interesting.\\uD83E\\uDD29\\nWe can see that there is a subarray that we **didn\\'t touch** which is `(4, 7, 1, 3, 8)`\\n\\nLet\\'s make a **relation** between them\\uD83D\\uDE80\\n```\\nsum(3, 4, 7, 1, 3, 8, 2, 4) = sum(4, 7, 1, 3, 8) + sum(3, 2, 4)\\nsum(3, 4, 7, 1, 3, 8, 2, 4) = sum(4, 7, 1, 3, 8) + x\\nsum(3, 4, 7, 1, 3, 8, 2, 4) - x = sum(4, 7, 1, 3, 8) \\n23 = sum(4, 7, 1, 3, 8) \\n```\\nWe can see something here.\\uD83D\\uDE00\\nThat the `sum subarray` that I talked about before is the `sum of the whole array - x`\\n\\nOk we made a **relation** between them but **why** I walked through all of this ?\\n\\nThe reason is that we can **utilize** an efficient technique that is called **Two Pointers**.\\uD83D\\uDE80\\uD83D\\uDE80\\n\\nThats it, instead of finding the **minimum** number of operations from `leftmost` and `rightmost` elements. We can find the **continous subarray** that **anyother** element in the array is the **answer** to our **minimum** operations.\\n\\nAnd this is the solution for our today problem I hope that you understood it\\uD83D\\uDE80\\uD83D\\uDE80\\n\\n\\n---\\n\\n\\n\\n# Approach\\n1. Calculate the total sum of elements.\\n2. Compute the target value as the difference between the total sum and the provided target `x`.\\n3. Check if the target value is `negative`; if so, return `-1` as the target sum is not achievable.\\n4. Check if the target value is `zero`; if so, **return** the **size** of nums since we need to subtract **all** of the elements from x.\\n5. Initialize pointers `leftIndex` and `rightIndex` to track a sliding window.\\n6. Within the loop, check if `currentSum` exceeds the target value. If it does, increment `leftIndex` and update `currentSum`.\\n7. Whenever `currentSum` equals the target value, calculate the **minimum** number of operations required and update `minOperations`.\\n8. **Return** the **minimum** number of operations.\\n\\n---\\n\\n\\n\\n# Complexity\\n- **Time complexity:**$$O(N)$$\\nIn this method we have two pointers, each of them can iterate over the array at most once. So the complexity is `2 * N` which is `O(N)`.\\n- **Space complexity:**$$O(1)$$\\nWe are storing couple of variables and not storing arrays or other data structure so the complexity is `O(1)`.\\n\\n\\n---\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int targetSum) {\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0);\\n        int target = totalSum - targetSum; // Calculate the target sum difference\\n\\n        if (target < 0)\\n            return -1; // Return -1 if target sum is not achievable\\n\\n        if (target == 0)\\n            return nums.size(); // Return the number of elements if target sum is 0\\n\\n        int n = nums.size(); // Number of elements in the vector\\n        int minOperations = INT_MAX; // Minimum operations to achieve the target sum\\n        int currentSum = 0; // Current sum of elements\\n        int leftIndex = 0, rightIndex = 0; // Pointers for the sliding window\\n\\n        while (rightIndex < n) {\\n            currentSum += nums[rightIndex];\\n            rightIndex++;\\n\\n            while (currentSum > target && leftIndex < n) {\\n                currentSum -= nums[leftIndex];\\n                leftIndex++;\\n            }\\n\\n            if (currentSum == target)\\n                minOperations = min(minOperations, n - (rightIndex - leftIndex));\\n        }\\n\\n        return (minOperations == INT_MAX) ? -1 : minOperations; // Return the minimum operations or -1 if not possible\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int minOperations(int[] nums, int targetSum) {\\n        int totalSum = Arrays.stream(nums).sum();\\n        int target = totalSum - targetSum; // Calculate the target sum difference\\n\\n        if (target < 0)\\n            return -1; // Return -1 if target sum is not achievable\\n\\n        if (target == 0)\\n            return nums.length; // Return the number of elements if target sum is 0\\n\\n        int n = nums.length; // Number of elements in the array\\n        int minOperations = Integer.MAX_VALUE; // Minimum operations to achieve the target sum\\n        int currentSum = 0; // Current sum of elements\\n        int leftIndex = 0, rightIndex = 0; // Pointers for the sliding window\\n\\n        while (rightIndex < n) {\\n            currentSum += nums[rightIndex];\\n            rightIndex++;\\n\\n            while (currentSum > target && leftIndex < n) {\\n                currentSum -= nums[leftIndex];\\n                leftIndex++;\\n            }\\n\\n            if (currentSum == target)\\n                minOperations = Math.min(minOperations, n - (rightIndex - leftIndex));\\n        }\\n\\n        return (minOperations == Integer.MAX_VALUE) ? -1 : minOperations; // Return the minimum operations or -1 if not possible\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minOperations(self, nums, targetSum) -> int:\\n        totalSum = sum(nums)\\n        target = totalSum - targetSum  # Calculate the target sum difference\\n\\n        if target < 0:\\n            return -1  # Return -1 if target sum is not achievable\\n\\n        if target == 0:\\n            return len(nums)  # Return the number of elements if target sum is 0\\n\\n        n = len(nums)  # Number of elements in the list\\n        minOperations = float(\\'inf\\')  # Minimum operations to achieve the target sum\\n        currentSum = 0  # Current sum of elements\\n        leftIndex = 0\\n        rightIndex = 0  # Pointers for the sliding window\\n\\n        while rightIndex < n:\\n            currentSum += nums[rightIndex]\\n            rightIndex += 1\\n\\n            while currentSum > target and leftIndex < n:\\n                currentSum -= nums[leftIndex]\\n                leftIndex += 1\\n\\n            if currentSum == target:\\n                minOperations = min(minOperations, n - (rightIndex - leftIndex))\\n\\n        return -1 if minOperations == float(\\'inf\\') else minOperations  # Return the minimum operations or -1 if not possible\\n```\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/19b0293e-dd7e-425a-b678-ae4168be235c_1695170376.8653944.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nnums = (3, 4, 7, 1, 3, 8, 2, 4), x = 9\\n```\n```\\nsum(3, 4, 7, 1, 3, 8, 2, 4) = sum(4, 7, 1, 3, 8) + sum(3, 2, 4)\\nsum(3, 4, 7, 1, 3, 8, 2, 4) = sum(4, 7, 1, 3, 8) + x\\nsum(3, 4, 7, 1, 3, 8, 2, 4) - x = sum(4, 7, 1, 3, 8) \\n23 = sum(4, 7, 1, 3, 8) \\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int targetSum) {\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0);\\n        int target = totalSum - targetSum; // Calculate the target sum difference\\n\\n        if (target < 0)\\n            return -1; // Return -1 if target sum is not achievable\\n\\n        if (target == 0)\\n            return nums.size(); // Return the number of elements if target sum is 0\\n\\n        int n = nums.size(); // Number of elements in the vector\\n        int minOperations = INT_MAX; // Minimum operations to achieve the target sum\\n        int currentSum = 0; // Current sum of elements\\n        int leftIndex = 0, rightIndex = 0; // Pointers for the sliding window\\n\\n        while (rightIndex < n) {\\n            currentSum += nums[rightIndex];\\n            rightIndex++;\\n\\n            while (currentSum > target && leftIndex < n) {\\n                currentSum -= nums[leftIndex];\\n                leftIndex++;\\n            }\\n\\n            if (currentSum == target)\\n                minOperations = min(minOperations, n - (rightIndex - leftIndex));\\n        }\\n\\n        return (minOperations == INT_MAX) ? -1 : minOperations; // Return the minimum operations or -1 if not possible\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int minOperations(int[] nums, int targetSum) {\\n        int totalSum = Arrays.stream(nums).sum();\\n        int target = totalSum - targetSum; // Calculate the target sum difference\\n\\n        if (target < 0)\\n            return -1; // Return -1 if target sum is not achievable\\n\\n        if (target == 0)\\n            return nums.length; // Return the number of elements if target sum is 0\\n\\n        int n = nums.length; // Number of elements in the array\\n        int minOperations = Integer.MAX_VALUE; // Minimum operations to achieve the target sum\\n        int currentSum = 0; // Current sum of elements\\n        int leftIndex = 0, rightIndex = 0; // Pointers for the sliding window\\n\\n        while (rightIndex < n) {\\n            currentSum += nums[rightIndex];\\n            rightIndex++;\\n\\n            while (currentSum > target && leftIndex < n) {\\n                currentSum -= nums[leftIndex];\\n                leftIndex++;\\n            }\\n\\n            if (currentSum == target)\\n                minOperations = Math.min(minOperations, n - (rightIndex - leftIndex));\\n        }\\n\\n        return (minOperations == Integer.MAX_VALUE) ? -1 : minOperations; // Return the minimum operations or -1 if not possible\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minOperations(self, nums, targetSum) -> int:\\n        totalSum = sum(nums)\\n        target = totalSum - targetSum  # Calculate the target sum difference\\n\\n        if target < 0:\\n            return -1  # Return -1 if target sum is not achievable\\n\\n        if target == 0:\\n            return len(nums)  # Return the number of elements if target sum is 0\\n\\n        n = len(nums)  # Number of elements in the list\\n        minOperations = float(\\'inf\\')  # Minimum operations to achieve the target sum\\n        currentSum = 0  # Current sum of elements\\n        leftIndex = 0\\n        rightIndex = 0  # Pointers for the sliding window\\n\\n        while rightIndex < n:\\n            currentSum += nums[rightIndex]\\n            rightIndex += 1\\n\\n            while currentSum > target and leftIndex < n:\\n                currentSum -= nums[leftIndex]\\n                leftIndex += 1\\n\\n            if currentSum == target:\\n                minOperations = min(minOperations, n - (rightIndex - leftIndex))\\n\\n        return -1 if minOperations == float(\\'inf\\') else minOperations  # Return the minimum operations or -1 if not possible\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136558,
                "title": "c-2-approaches",
                "content": "Approach 1: Hash map, prefix sum, two sum\\n\\t- Idea: + create hash map satisfy mapLeft[prefix sum] = i, i is last index in prefix sum\\n\\t\\t\\t+  brute force from last index in array to first index and create suffix sum, find i satisfy mapLeft[x - suffix sum] > 0 \\n\\t\\t\\t   => that\\'s mean prefix sum + suffix sum = x,  and min operation = min (min operation, size(prefix sum) + size(suffix sum) );\\n\\t+ Time: O(n)\\n\\t+ Space: O(n)\\n\\t\\t\\t   \\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums, int x) {\\n\\t\\t\\tunordered_map<int, int> mapLeft;\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint ans = INT_MAX;\\n\\n\\t\\t\\tfor(int i = 0, prefixSum = 0; i < n; i++) {\\n\\t\\t\\t\\tprefixSum += nums[i];\\n\\t\\t\\t\\tmapLeft[prefixSum] = i + 1;\\n\\t\\t\\t\\tif (prefixSum == x)\\n\\t\\t\\t\\t\\tans = min(ans, i + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = n - 1, suffixSum = 0; i >= 0; i--) {\\n\\t\\t\\t\\tsuffixSum += nums[i];\\n\\t\\t\\t\\tif(suffixSum == x)\\n\\t\\t\\t\\t\\tans = min(ans, n - i);\\n\\t\\t\\t\\tif(mapLeft[x - suffixSum] > 0 && i + 1 > mapLeft[x - suffixSum]) // if i + 1 <= mapLeft => both prefix sum and suffix sum have same elements\\n\\t\\t\\t\\t\\tans = min(ans, n - i + mapLeft[x - suffixSum]); // n - i is size suffix sum, mapLeft[x - suffixSum] is size prefix sum\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans == INT_MAX ? -1 : ans;\\n\\t\\t}\\n\\t};\\n\\t\\nApproach 2: longest subarray have sum == sum(nums) - x\\n\\t- Idea: If u find longest subarray have sum == sum(nums) - x \\n\\t\\t\\t=> minimun operation = nums.size() - size(longest subarray)\\n![image](https://assets.leetcode.com/users/images/af4ac248-08a8-4903-8a23-c81f37fbfa55_1654910719.3698483.png)\\nTime: O(n)\\nSpace: O(1)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums, int x) {\\n\\t\\t\\tint sum = accumulate(nums.begin(), nums.end(), 0);\\n\\n\\t\\t\\tif(sum < x) return -1;\\n\\t\\t\\tif(sum == x) return nums.size();\\n\\n\\t\\t\\tint target = sum - x, currentSum = 0, start = 0, maxSize = 0;\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\tcurrentSum += nums[i];\\n\\n\\t\\t\\t\\twhile(currentSum > target)\\n\\t\\t\\t\\t\\tcurrentSum -= nums[start++];\\n\\n\\t\\t\\t\\tif(currentSum == target)\\n\\t\\t\\t\\t\\tmaxSize = max(maxSize, i - start + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (maxSize == 0) ? - 1 : nums.size() - maxSize;\\n\\t\\t}\\n\\t};\\n\\t",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums, int x) {\\n\\t\\t\\tunordered_map<int, int> mapLeft;\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint ans = INT_MAX;\\n\\n\\t\\t\\tfor(int i = 0, prefixSum = 0; i < n; i++) {\\n\\t\\t\\t\\tprefixSum += nums[i];\\n\\t\\t\\t\\tmapLeft[prefixSum] = i + 1;\\n\\t\\t\\t\\tif (prefixSum == x)\\n\\t\\t\\t\\t\\tans = min(ans, i + 1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4066549,
                "title": "how-we-think-about-a-solution-o-n-time-o-1-space-python-javascript-java-c",
                "content": "Welcome to my article. Before starting the article, why do I have to get multiple downvotes for a miniute every day? That is obviously deliberate downvotes. I can tell who is doing it. Please show your respect to others! Thanks.\\n\\n# Intuition\\nTry to find target number with sum(nums) - x which is `unnecessary numbers`\\n\\n---\\n\\n# Solution Video\\n\\nIn the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/RUF-4_3fzew\\n\\n\\u25A0 Timeline of the video\\n`0:00` Read the question of Minimum Operations to Reduce X to Zero \\n`1:13` How we think about a solution\\n`3:47` Explain how to solve Minimum Operations to Reduce X to Zero\\n`13:00` Coding\\n`15:26` Time Complexity and Space Complexity\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,382\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n### How we think about a solution\\n\\nWe have two choices to take numbers from left or right side. But problem is we don\\'t know what numbers are coming next, next next or next next next...so it\\'s tough to manage left and right numbers at the same time.\\n\\nThat\\'s why I changed my idea to this. We have to subtract some numbers from `x`.  In other words, If we can calculate numbers which don\\'t need for `x` and subtract the `unnecessary numbers` from `total number` of input array, we can get `x`. That formula is\\n\\n```\\ntotal numbers in array - unnecessary numbers = x\\n```\\n\\nAnd an important point is that as I told you, we have two choices to take numbers from left side or right side. That\\'s why `position of unnecessary numbers` is around middle of input array for the most cases and `it is consecutive places`.\\n\\nLet\\'s see concrete expamle.\\n```\\nInput: nums = [3,2,20,1,1,3], x = 10\\n```\\n\\ncalculation of `unnecessary numbers` is\\n```\\ntotal numbers in array - unnecessary numbers = x\\n\\u2193\\ntotal numbers in array - x = unnecessary numbers\\n\\n30 - 10 = 20\\n\\n30: total number of input array\\n10: x\\n20: unnecessary numbers \\n```\\n\\n\\nAt first, we have to find `20` from `input array`. Let\\'s break the numbers into small pieces.\\n\\n```\\n[3,2] = 5\\n[20] = 20\\n[1,1,3] = 5\\n\\n[3,2] is an case where we take 3 and 2 from left side.\\n[1,1,3] is an case where we take 3, 1 and 1 from right side.\\nThe total of [3,2] and [1,1,3] is 10 (3+2+1+1+3) which is x.\\n```\\nIn this case, if we can find `[20]`, all we have to do is to calculate this.\\n```\\n6 - 1 = 5\\n\\n6: total length of input array\\n1: length of [20]\\n5: length of [3,2] + [1,1,3]\\n```\\n```\\nOutput : 5 (minimum number of operations to make x zero)\\n```\\n\\n`position of unnecessary numbers` is around middle of input array and it is `consective places`, so looks like we can use `sliding window` technique to find `length of array for unnecessary numbers`.\\n\\n\\n### Overview Algorithm\\n1. Calculate the target sum as the sum of `nums` minus `x`.\\n2. Check if the target sum is negative, return -1 if it is.\\n3. Initialize variables `left`, `cur_sum`, and `max_sub_length`.\\n4. Iterate through the `nums` array using a sliding window approach to find the longest subarray with the sum equal to the target.\\n\\n### Detailed Explanation\\n1. Calculate the target sum:\\n   - Calculate the `target` as the sum of `nums` minus `x`. This is the sum we want to achieve by finding a subarray in the given array.\\n\\n2. Check if the target sum is negative:\\n   - If `target` is less than 0, it means it\\'s not possible to achieve the target sum by removing elements from the array. Return -1.\\n\\n3. Initialize variables:\\n   - `left`: Initialize a pointer to the left end of the window.\\n   - `cur_sum`: Initialize a variable to keep track of the current sum in the window.\\n   - `max_sub_length`: Initialize a variable to keep track of the maximum subarray length with the sum equal to the target.\\n\\n4. Iterate through the array using a sliding window:\\n   - Start a loop over the array using the right pointer.\\n   - Update the current sum by adding the current element at the right pointer.\\n   - Check if the current sum is greater than the target:\\n     - If the current sum exceeds the target, move the left pointer to the right until the current sum is less than or equal to the target.\\n   - Check if the current sum is equal to the target:\\n     - If the current sum equals the target, update the maximum subarray length if needed.\\n   - At each iteration, keep track of the maximum subarray length found so far.\\n\\n5. Return the result:\\n   - After the loop, return -1 if no valid subarray was found (max_sub_length remains as initialized), or return the difference between the total length of the array and the maximum subarray length.\\n\\nThis algorithm efficiently finds the longest subarray with a sum equal to the target sum using a sliding window approach.\\n\\n# How it works\\nLet\\'s think about this input.\\n```\\nInput: nums = [3,2,20,1,1,3], x = 10\\n\\ntarget(unnecessary numbers) = 20 (fixed)\\ncur_sum = 0\\nleft = 0\\nright = 0\\nmax_sub_length = 0\\nn = 6 (fixed)\\n```\\niteration thorugh input array one by one\\n```\\nwhen right = 0, add 3 to cur_sum\\n\\ncur_sum = 3\\nleft = 0\\nmax_sub_length = 0\\n```\\n\\n```\\nwhen right = 1, add 2 to cur_sum\\n\\ncur_sum = 5\\nleft = 0\\nmax_sub_length = 0\\n```\\n\\n```\\nwhen right = 2, add 20 to cur_sum\\n\\ncur_sum = 25 \\u2192 20(while loop, 25 - 3 - 2)\\nleft = 0 \\u2192 2 (while loop, 0 + 1 + 1)\\nmax_sub_length = 1 (if statement, max(-inf, 2 - 2 + 1))\\n```\\n\\n```\\nwhen right = 3, add 1 to cur_sum\\n\\ncur_sum = 21 \\u2192 1(while loop, 21 - 20)\\nleft = 2 \\u2192 3 (while loop, 2 + 1)\\nmax_sub_length = 1\\n```\\n\\n```\\nwhen right = 4, add 1 to cur_sum\\n\\ncur_sum = 2\\nleft = 3\\nmax_sub_length = 1\\n```\\n\\n```\\nwhen right = 5, add 3 to cur_sum\\n\\ncur_sum = 5\\nleft = 3\\nmax_sub_length = 1\\n```\\n\\n```\\nreturn 6(n) - 1(max_sub_length)\\n```\\n\\n```\\nOutput: 5 (operations)\\n```\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n`n` is the length of the input nums array. This is because there is a single loop that iterates through the elements of the array once.\\n\\n\\n- Space complexity: O(1)\\nbecause the code uses a constant amount of additional memory regardless of the size of the input nums array. The space used for variables like `target`, `left`, `cur_sum`, `max_sub_length`, and `n` does not depend on the size of the input array and remains constant.\\n\\n\\n```python []\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target = sum(nums) - x\\n        \\n        if target < 0:\\n            return -1\\n        \\n        left = 0\\n        cur_sum = 0\\n        max_sub_length = float(\\'-inf\\')\\n        n = len(nums)\\n        \\n        for right in range(n):\\n            cur_sum += nums[right]\\n            \\n            while cur_sum > target:\\n                cur_sum -= nums[left]\\n                left += 1\\n                \\n            if cur_sum == target:\\n                max_sub_length = max(max_sub_length, right - left + 1)\\n        \\n        return -1 if max_sub_length == float(\\'-inf\\') else n - max_sub_length\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} x\\n * @return {number}\\n */\\nvar minOperations = function(nums, x) {\\n    const target = nums.reduce((acc, num) => acc + num, 0) - x;\\n    \\n    if (target < 0) {\\n        return -1;\\n    }\\n    \\n    let left = 0;\\n    let curSum = 0;\\n    let maxSubLength = Number.NEGATIVE_INFINITY;\\n    const n = nums.length;\\n    \\n    for (let right = 0; right < n; right++) {\\n        curSum += nums[right];\\n        \\n        while (curSum > target) {\\n            curSum -= nums[left];\\n            left++;\\n        }\\n        \\n        if (curSum === target) {\\n            maxSubLength = Math.max(maxSubLength, right - left + 1);\\n        }\\n    }\\n    \\n    return maxSubLength === Number.NEGATIVE_INFINITY ? -1 : n - maxSubLength;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int target = 0;\\n        for (int num : nums) {\\n            target += num;\\n        }\\n        target -= x;\\n\\n        if (target < 0) {\\n            return -1;\\n        }\\n\\n        int left = 0;\\n        int curSum = 0;\\n        int maxSubLength = Integer.MIN_VALUE;\\n        int n = nums.length;\\n\\n        for (int right = 0; right < n; right++) {\\n            curSum += nums[right];\\n\\n            while (curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (curSum == target) {\\n                maxSubLength = Math.max(maxSubLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxSubLength == Integer.MIN_VALUE ? -1 : n - maxSubLength;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int target = 0;\\n        for (int i : nums) {\\n            target += i;\\n        }\\n        target -= x;\\n\\n        if (target < 0) {\\n            return -1;\\n        }\\n\\n        int left = 0;\\n        int curSum = 0;\\n        int maxSubLength = INT_MIN;\\n        int n = nums.size();\\n\\n        for (int right = 0; right < n; right++) {\\n            curSum += nums[right];\\n\\n            while (curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (curSum == target) {\\n                maxSubLength = std::max(maxSubLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxSubLength == INT_MIN ? -1 : n - maxSubLength;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\nThank you for reading such a long article. \\n\\n\\u2B50\\uFE0F Please upvote it if you understand how we think about a solution and don\\'t forget to subscribe to my youtube channel!\\n\\n\\nMy next post for daily coding challenge on Sep 21, 2023\\nhttps://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4070884/my-thought-process-ologminn-m-time-o1-space-python-javascript-java-c/\\n\\nHave a nice day!\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\ntotal numbers in array - unnecessary numbers = x\\n```\n```\\nInput: nums = [3,2,20,1,1,3], x = 10\\n```\n```\\ntotal numbers in array - unnecessary numbers = x\\n\\u2193\\ntotal numbers in array - x = unnecessary numbers\\n\\n30 - 10 = 20\\n\\n30: total number of input array\\n10: x\\n20: unnecessary numbers \\n```\n```\\n[3,2] = 5\\n[20] = 20\\n[1,1,3] = 5\\n\\n[3,2] is an case where we take 3 and 2 from left side.\\n[1,1,3] is an case where we take 3, 1 and 1 from right side.\\nThe total of [3,2] and [1,1,3] is 10 (3+2+1+1+3) which is x.\\n```\n```\\n6 - 1 = 5\\n\\n6: total length of input array\\n1: length of [20]\\n5: length of [3,2] + [1,1,3]\\n```\n```\\nOutput : 5 (minimum number of operations to make x zero)\\n```\n```\\nInput: nums = [3,2,20,1,1,3], x = 10\\n\\ntarget(unnecessary numbers) = 20 (fixed)\\ncur_sum = 0\\nleft = 0\\nright = 0\\nmax_sub_length = 0\\nn = 6 (fixed)\\n```\n```\\nwhen right = 0, add 3 to cur_sum\\n\\ncur_sum = 3\\nleft = 0\\nmax_sub_length = 0\\n```\n```\\nwhen right = 1, add 2 to cur_sum\\n\\ncur_sum = 5\\nleft = 0\\nmax_sub_length = 0\\n```\n```\\nwhen right = 2, add 20 to cur_sum\\n\\ncur_sum = 25 \\u2192 20(while loop, 25 - 3 - 2)\\nleft = 0 \\u2192 2 (while loop, 0 + 1 + 1)\\nmax_sub_length = 1 (if statement, max(-inf, 2 - 2 + 1))\\n```\n```\\nwhen right = 3, add 1 to cur_sum\\n\\ncur_sum = 21 \\u2192 1(while loop, 21 - 20)\\nleft = 2 \\u2192 3 (while loop, 2 + 1)\\nmax_sub_length = 1\\n```\n```\\nwhen right = 4, add 1 to cur_sum\\n\\ncur_sum = 2\\nleft = 3\\nmax_sub_length = 1\\n```\n```\\nwhen right = 5, add 3 to cur_sum\\n\\ncur_sum = 5\\nleft = 3\\nmax_sub_length = 1\\n```\n```\\nreturn 6(n) - 1(max_sub_length)\\n```\n```\\nOutput: 5 (operations)\\n```\n```python []\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target = sum(nums) - x\\n        \\n        if target < 0:\\n            return -1\\n        \\n        left = 0\\n        cur_sum = 0\\n        max_sub_length = float(\\'-inf\\')\\n        n = len(nums)\\n        \\n        for right in range(n):\\n            cur_sum += nums[right]\\n            \\n            while cur_sum > target:\\n                cur_sum -= nums[left]\\n                left += 1\\n                \\n            if cur_sum == target:\\n                max_sub_length = max(max_sub_length, right - left + 1)\\n        \\n        return -1 if max_sub_length == float(\\'-inf\\') else n - max_sub_length\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} x\\n * @return {number}\\n */\\nvar minOperations = function(nums, x) {\\n    const target = nums.reduce((acc, num) => acc + num, 0) - x;\\n    \\n    if (target < 0) {\\n        return -1;\\n    }\\n    \\n    let left = 0;\\n    let curSum = 0;\\n    let maxSubLength = Number.NEGATIVE_INFINITY;\\n    const n = nums.length;\\n    \\n    for (let right = 0; right < n; right++) {\\n        curSum += nums[right];\\n        \\n        while (curSum > target) {\\n            curSum -= nums[left];\\n            left++;\\n        }\\n        \\n        if (curSum === target) {\\n            maxSubLength = Math.max(maxSubLength, right - left + 1);\\n        }\\n    }\\n    \\n    return maxSubLength === Number.NEGATIVE_INFINITY ? -1 : n - maxSubLength;    \\n};\\n```\n```java []\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int target = 0;\\n        for (int num : nums) {\\n            target += num;\\n        }\\n        target -= x;\\n\\n        if (target < 0) {\\n            return -1;\\n        }\\n\\n        int left = 0;\\n        int curSum = 0;\\n        int maxSubLength = Integer.MIN_VALUE;\\n        int n = nums.length;\\n\\n        for (int right = 0; right < n; right++) {\\n            curSum += nums[right];\\n\\n            while (curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (curSum == target) {\\n                maxSubLength = Math.max(maxSubLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxSubLength == Integer.MIN_VALUE ? -1 : n - maxSubLength;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int target = 0;\\n        for (int i : nums) {\\n            target += i;\\n        }\\n        target -= x;\\n\\n        if (target < 0) {\\n            return -1;\\n        }\\n\\n        int left = 0;\\n        int curSum = 0;\\n        int maxSubLength = INT_MIN;\\n        int n = nums.size();\\n\\n        for (int right = 0; right < n; right++) {\\n            curSum += nums[right];\\n\\n            while (curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (curSum == target) {\\n                maxSubLength = std::max(maxSubLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxSubLength == INT_MIN ? -1 : n - maxSubLength;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016596,
                "title": "python3-o-n-time-o-1-space-solution",
                "content": "The idea is to find the length of the maximum length subarray that has a sum equal to ```sum(nums) - x```. This makes sense because after removing the optimal elements from the ends, this is what we will be left with. So instead of removing elements, add elements to this subarray in a sliding window fashion and optimize for the largest length of this subarray.\\n\\nExample:\\n```nums = [1,1,4,2,3], x = 5```\\n\\nsum = 11\\nreq_subarray_sum = 11 - 5 = 6\\nThe longest subarray with this sum is from index 0 to index 2 (1 + 1 + 4). This has length 3.\\nresult = len(nums) - max_subarray_size = 5 - 3 = 2\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        arr_sum = sum(nums)\\n        if arr_sum < x:\\n            return -1\\n        if arr_sum == x:\\n            return len(nums)\\n        \\n        required_subarray_sum = arr_sum - x\\n        left = curr_sum = max_subarray_size = 0\\n        for right, num in enumerate(nums):\\n            curr_sum += num\\n            while curr_sum > required_subarray_sum:\\n                curr_sum -= nums[left]\\n                left += 1\\n            if curr_sum == required_subarray_sum:\\n                max_subarray_size = max(max_subarray_size, right - left + 1)\\n                \\n        return len(nums) - max_subarray_size if max_subarray_size > 0 else -1\\n```",
                "solutionTags": [],
                "code": "```sum(nums) - x```\n```nums = [1,1,4,2,3], x = 5```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        arr_sum = sum(nums)\\n        if arr_sum < x:\\n            return -1\\n        if arr_sum == x:\\n            return len(nums)\\n        \\n        required_subarray_sum = arr_sum - x\\n        left = curr_sum = max_subarray_size = 0\\n        for right, num in enumerate(nums):\\n            curr_sum += num\\n            while curr_sum > required_subarray_sum:\\n                curr_sum -= nums[left]\\n                left += 1\\n            if curr_sum == required_subarray_sum:\\n                max_subarray_size = max(max_subarray_size, right - left + 1)\\n                \\n        return len(nums) - max_subarray_size if max_subarray_size > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017236,
                "title": "minimum-operations-to-reduce-x-to-zero-js-explanation-beats-100",
                "content": "***Idea:***\\n\\nThis problem is tasking us to essentially find when the sum of the starting and ending subarrays of **nums** is equal to **x**. Put another way, it\\'s asking us to find when any subarray of consecutive elements in **nums** is equal to the sum of all elements in **nums** minus **x**.\\n```\\n               <-A->   <------ B ------>   <-C->\\n       nums = [1,  1,  1,  1,  1,  1,  1,  1,  1]\\n\\t   \\n\\t   if      sum(A) + sum(C) = x\\n\\t   then    x = sum(nums) - sum(B)\\n```\\nSo now we need to find any consecutive subarray of **nums** whose sum is equal to a specific value. Any time you\\'re talking about checking the sum of a consecutive subarray, it should naturally bring to mind the use of a **prefix sum array**.\\n\\nThe sum of any consecutive subarray, **i** to **j**, of **nums** can be defined as the sum of all elements of **nums** up to **j** minus the sum of all the elements of **nums** *before* **i**. This is aided by creating a prefix sum array containing the running sum of elements in **nums**.\\n```\\n\\t\\t\\t   <------ A ------>\\n               <-B->\\n\\t\\t\\t           <-- C -->\\n       nums = [1,  1,  1,  1,  1,  1,  1,  1,  1]\\n\\t\\t\\t\\t\\t   i       j\\n  prefixSum = [1,  2,  3,  4,  5,  6,  7,  8,  9]\\n\\t   \\n\\t   if      prefixSum[n] = sum(nums[0] to nums[n])\\n\\t   and     sum(A) = prefixSum[j]\\n\\t   and     sum(B) = prefixSum[i-1]\\n\\t   then    sum(C) = prefixSum[j] - prefixSum[i-1]\\n```\\n\\nUsing a prefix sum array, we can then use a **2-pointer** **sliding window** to evaluate which subarrays have the specified value and keep track of which one has the largest subarray size. The answer, if possible, will be its difference from **nums.length**.\\n\\nThe best result for the code below is **92ms / 50.2MB**.\\n\\n` `\\n***Implementation:***\\n\\nThe prefix sum array is simple to achieve; we just iterate through **nums** and make each **i**th element of the prefix sum array the sum of **nums[0]** through **nums[i]** by taking the previous value (**nums[i-1]**) and adding **nums[i]** to it. Since we don\\'t need the individual elements of **nums** after this, we can run the conversion in place.\\n\\n(***Note**: Normally in a prefix sum array you will want to add a leading **0** to the array as the equation for a subarray starting with **i = 0** will lead to an **nums[i-1]** value outside the range of **nums**. In this instance, however, we can handle the issue more efficiently later.*)\\n\\nOnce **nums** has been updated, the last element **nums[len-1]** will equal the total sum of **nums**. This means that we\\'ll be looking for a subarray of nums that sums to **nums[len-1] - x**, or **y**. If **y** is negative, then there exists no possibility for a solution, since all elements of **nums** are positive integers, so we can **return -1**. If **y** is **0**, then the only possible solution is the entire **nums** array, so we can **return len**.\\n\\nOtherwise, we can use **i** and **j** as two pointers to form a sliding window of **nums**. While we iterate, we should keep track of the size (**best**) of the largest successful subarray. If at any time during the iteration, **i** moves far enough that no remaining subarray can beat **best**, or if **nums[i]** is already larger than **x**, then we should force an end. Starting with **best = 0** means that **i** should move all the way to **len** if no matches are found.\\n\\nSince we\\'ll be using **nums[i]** a number of times, we can store it in **l**, representing the left endpoint value sum. Setting the initial value of **l** to **0** and only updating it to be based off **nums[i]** *after* the first iteration will allow us to avoid needing to **unshift()** a **0** onto the prefix sum array beforehand.\\n\\nThen, during each iteration, we\\'ll move **j** up as long as the subarray sum (**nums[j] - l**) is less than **y**. If the sliding window has stopped on a subarray that equals **y**, then we update **best** if necessary.\\n\\nSince **best** represents the largest subarray length, we actually want to **return len - best**, but if no match was ever found (**best > 0**), then we should **return -1** instead.\\n\\n` `\\n***Code:***\\n```\\nvar minOperations = function(nums, x) {\\n    let len = nums.length, best = 0\\n    for (let i = 1; i < len; i++) nums[i] += nums[i-1]\\n    let y = nums[len-1] - x\\n    if (y < 0) return -1\\n    if (y === 0) return len\\n    for (let i = -1, j = l = 0; i < len - best && l <= x; l = nums[++i]) {\\n        while (nums[j] - l < y) j++\\n        if (nums[j] - l === y) best = Math.max(best, j - i)\\n    }\\n    return best > 0 ? len - best : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n               <-A->   <------ B ------>   <-C->\\n       nums = [1,  1,  1,  1,  1,  1,  1,  1,  1]\\n\\t   \\n\\t   if      sum(A) + sum(C) = x\\n\\t   then    x = sum(nums) - sum(B)\\n```\n```\\n\\t\\t\\t   <------ A ------>\\n               <-B->\\n\\t\\t\\t           <-- C -->\\n       nums = [1,  1,  1,  1,  1,  1,  1,  1,  1]\\n\\t\\t\\t\\t\\t   i       j\\n  prefixSum = [1,  2,  3,  4,  5,  6,  7,  8,  9]\\n\\t   \\n\\t   if      prefixSum[n] = sum(nums[0] to nums[n])\\n\\t   and     sum(A) = prefixSum[j]\\n\\t   and     sum(B) = prefixSum[i-1]\\n\\t   then    sum(C) = prefixSum[j] - prefixSum[i-1]\\n```\n```\\nvar minOperations = function(nums, x) {\\n    let len = nums.length, best = 0\\n    for (let i = 1; i < len; i++) nums[i] += nums[i-1]\\n    let y = nums[len-1] - x\\n    if (y < 0) return -1\\n    if (y === 0) return len\\n    for (let i = -1, j = l = 0; i < len - best && l <= x; l = nums[++i]) {\\n        while (nums[j] - l < y) j++\\n        if (nums[j] - l === y) best = Math.max(best, j - i)\\n    }\\n    return best > 0 ? len - best : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137386,
                "title": "c-simple-o-n-sliding-window",
                "content": "* Goal is to **find a window of longest length** which has sum equal to `s - x`, where `s` is sum of all the elements of the array.\\n* When such a window is found all the elements outside this window will sum to `x` and no of operations will be equal to their count. \\n* **TC : O(N) | SC : O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int n = nums.size(), s = 0, ans = 1000000;\\n        \\n        for(int i = 0; i < n ; i++) s += nums[i];\\n        \\n        if(s < x) return -1;\\n        \\n        int st = 0, end = 0, windowSum = 0;\\n        \\n        while(end < n){            \\n            windowSum += nums[end];            \\n            while(windowSum > (s - x)){\\n                windowSum -= nums[st]; //Reducing window size\\n                st++;\\n            }            \\n            if(windowSum == s - x){\\n                ans = min(ans, n - (end - st + 1));\\n            }            \\n            end++;            \\n        }\\n\\t\\t\\n        return (ans == 1000000 ? -1 : ans);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int n = nums.size(), s = 0, ans = 1000000;\\n        \\n        for(int i = 0; i < n ; i++) s += nums[i];\\n        \\n        if(s < x) return -1;\\n        \\n        int st = 0, end = 0, windowSum = 0;\\n        \\n        while(end < n){            \\n            windowSum += nums[end];            \\n            while(windowSum > (s - x)){\\n                windowSum -= nums[st]; //Reducing window size\\n                st++;\\n            }            \\n            if(windowSum == s - x){\\n                ans = min(ans, n - (end - st + 1));\\n            }            \\n            end++;            \\n        }\\n\\t\\t\\n        return (ans == 1000000 ? -1 : ans);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936074,
                "title": "java-python-3-sliding-window-longest-subarray-sum-to-the-target-sum-nums-x",
                "content": "Using sliding window to find the longest subarry that sums to `sum(nums) - x`.\\n```java\\n    public int minOperations(int[] nums, int x) {\\n        int target = Arrays.stream(nums).sum() - x, size = -1, n = nums.length;\\n        for (int lo = -1, hi = 0, winSum = 0; hi < n; ++hi) {\\n            winSum += nums[hi];\\n            while (lo + 1 < nums.length && winSum > target) {\\n                winSum -= nums[++lo];\\n            }\\n            if (winSum == target) {\\n                size = Math.max(size, hi - lo);\\n            }\\n        }\\n        return size < 0 ? -1 : n - size;\\n    }\\n```\\n\\n```python\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target, size, win_sum, lo, n = sum(nums) - x, -1, 0, -1, len(nums)\\n        for hi, num in enumerate(nums):\\n            win_sum += num\\n            while lo + 1 < n and win_sum > target:\\n                lo += 1\\n                win_sum -= nums[lo]\\n            if win_sum == target:\\n                size = max(size, hi - lo)\\n        return -1 if size < 0 else n - size\\n```\\n\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = nums.length.\\n\\n----\\n\\nSimilar problems:\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/description/)\\n[1423. Maximum Points You Can Obtain from Cards](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/discuss/597777/JavaPython-3-Sliding-window-O(k)-short-codes-w-brief-comments-and-analysis.)",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int minOperations(int[] nums, int x) {\\n        int target = Arrays.stream(nums).sum() - x, size = -1, n = nums.length;\\n        for (int lo = -1, hi = 0, winSum = 0; hi < n; ++hi) {\\n            winSum += nums[hi];\\n            while (lo + 1 < nums.length && winSum > target) {\\n                winSum -= nums[++lo];\\n            }\\n            if (winSum == target) {\\n                size = Math.max(size, hi - lo);\\n            }\\n        }\\n        return size < 0 ? -1 : n - size;\\n    }\\n```\n```python\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target, size, win_sum, lo, n = sum(nums) - x, -1, 0, -1, len(nums)\\n        for hi, num in enumerate(nums):\\n            win_sum += num\\n            while lo + 1 < n and win_sum > target:\\n                lo += 1\\n                win_sum -= nums[lo]\\n            if win_sum == target:\\n                size = max(size, hi - lo)\\n        return -1 if size < 0 else n - size\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935986,
                "title": "python3-o-n-hash-table-of-prefix",
                "content": "Algo \\nHere, we maintain a mapping of prefix sum to index mapping. Then, we go over `nums` inversely to compute suffix sum, and check if a complement exists in the prefix sum (via hash table). If so, check the length and update `ans`. \\n\\nImplementation \\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        mp = {0: 0}\\n        prefix = 0\\n        for i, num in enumerate(nums, 1): \\n            prefix += num\\n            mp[prefix] = i \\n            \\n        ans = mp.get(x, inf)\\n        for i, num in enumerate(reversed(nums), 1): \\n            x -= num\\n            if x in mp and mp[x] + i <= len(nums): ans = min(ans, i + mp[x])\\n        return ans if ans < inf else -1 \\n```\\n\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`\\n\\nEdited on 1/14/2021\\nAdding implementation to use complement\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        x = sum(nums) - x\\n        if not x: return len(nums) # edge case \\n        \\n        seen = {0: -1}\\n        ans = prefix = 0\\n        for i, num in enumerate(nums): \\n            prefix += num\\n            if prefix - x in seen: ans = max(ans, i - seen[prefix - x])\\n            seen.setdefault(prefix, i)\\n        return len(nums) - ans if ans else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        mp = {0: 0}\\n        prefix = 0\\n        for i, num in enumerate(nums, 1): \\n            prefix += num\\n            mp[prefix] = i \\n            \\n        ans = mp.get(x, inf)\\n        for i, num in enumerate(reversed(nums), 1): \\n            x -= num\\n            if x in mp and mp[x] + i <= len(nums): ans = min(ans, i + mp[x])\\n        return ans if ans < inf else -1 \\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        x = sum(nums) - x\\n        if not x: return len(nums) # edge case \\n        \\n        seen = {0: -1}\\n        ans = prefix = 0\\n        for i, num in enumerate(nums): \\n            prefix += num\\n            if prefix - x in seen: ans = max(ans, i - seen[prefix - x])\\n            seen.setdefault(prefix, i)\\n        return len(nums) - ans if ans else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215865,
                "title": "python-3-two-sum-problem-using-hashmap-o-n-clean-concise",
                "content": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n\\n        leftMap = dict()\\n        leftMap[0] = -1\\n        left = 0\\n        for i in range(n):\\n            left += nums[i]\\n            if left not in leftMap:\\n                leftMap[left] = i\\n\\n        right = 0\\n        ans = n + 1\\n        for i in range(n, -1, -1):\\n            if i < n:  right += nums[i]\\n            left = x - right\\n            if left in leftMap:  # left + right = x -> left = x - right\\n                ans = min(ans, leftMap[left] + 1 + n - i)\\n        if ans == n + 1: return -1\\n        return ans\\n```\\nComplexity:\\n- Time & Space: `O(N)`, where `N` is number of elements in the array `nums`.\\n\\n**Simillar problems**\\n1. [1. Two Sum](https://leetcode.com/problems/two-sum/)\\n2. [1865. Finding Pairs With a Certain Sum](https://leetcode.com/problems/finding-pairs-with-a-certain-sum/)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n\\n        leftMap = dict()\\n        leftMap[0] = -1\\n        left = 0\\n        for i in range(n):\\n            left += nums[i]\\n            if left not in leftMap:\\n                leftMap[left] = i\\n\\n        right = 0\\n        ans = n + 1\\n        for i in range(n, -1, -1):\\n            if i < n:  right += nums[i]\\n            left = x - right\\n            if left in leftMap:  # left + right = x -> left = x - right\\n                ans = min(ans, leftMap[left] + 1 + n - i)\\n        if ans == n + 1: return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137853,
                "title": "c-explained-solution-best-time-and-space-complexity",
                "content": "**Please Upvote the solution if helpful --> else comment down the problem and I will try to improve upon that! Thanks for reading .**\\n```\\nclass Solution {\\npublic:\\n    // O(n) time complexity solution and O(1) space complexity\\n    // Given Problem (equivalent) => Finding longest subarray with sum=totalSum(nums) - x \\n    // The above problem will minimize the target(x) using minimum elements from extreme left and right \\n\\t// Not clear ???? \\n\\t// Okay , let me explain it !\\n    // Assume array to be divided into 3 portions : ----- [-----] ----- \\n    // Observe we can take elements from left and right portion to form x and our goal is to use least elements possible\\n    // So , we alternatively need to maximize the size of the middle portion and its sum = total sum-x\\n    \\n    int minOperations(vector<int>& nums, int x) {\\n        // Finding total sum of the array\\n        int sum=0;\\n        for(auto it:nums){\\n            sum+=it;\\n        }\\n        // Finding required sum of the middle portion\\n        sum-=x;     \\n        // Edge Case --> If middle portion Sum =0 --> we need to take all elements (Since all elements >=1)\\n        if(sum==0){\\n            return nums.size();\\n        }\\n        // Edge Case --> If middle portion Sum < 0 --> Not possible because this implies that total sum of array< x\\n        if(sum<0) return -1;\\n        int curr=nums[0];\\n        int ans=-1; // number of elements taken in middle portion \\n        // start --> starting index of middle portion taken into account currently , end--> last index taken into account\\n        int start=0,end=0;\\n        // we will traverse the array till end <= last index\\n        while(end<nums.size()){\\n            // case 1 --> current sum is less than required sum --> move end to next pointer \\n            if(curr<sum){\\n                end++;\\n                if(end==nums.size()) break;\\n                curr+=nums[end];\\n            }\\n            // case 2 --> current sum is greater than required sum --> move start pointer to next index \\n            else if(curr>sum){\\n                curr-=nums[start];\\n                start++;\\n            }\\n            \\n            // case 3 --> current sum is equal to required Sum --> move start pointer to next index to explore better answer\\n            // alternatively we could have taken end pointer to next index , but to avoid edge cases of end pointer (out of bound), we have taken former case\\n            else if(curr==sum){\\n                int val=end-start+1;\\n                ans=max(ans,val);\\n                curr-=nums[start];\\n                start++;\\n            }\\n        }\\n        if(ans==-1) return -1;  // if after whole traversal , ans==-1 (initialized value) --> we didn\\'t find any valid answer --> hence return -1\\n        else return nums.size()-ans;    // else return ( total array length) - (maximum length of middle portion )\\n    }\\n    // Time Complexity : Linear O(n)\\n    // Space Complexity : O(1) since we only used constant number of variable and hence fixed memory \\n\\t\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // O(n) time complexity solution and O(1) space complexity\\n    // Given Problem (equivalent) => Finding longest subarray with sum=totalSum(nums) - x \\n    // The above problem will minimize the target(x) using minimum elements from extreme left and right \\n\\t// Not clear ???? \\n\\t// Okay , let me explain it !\\n    // Assume array to be divided into 3 portions : ----- [-----] ----- \\n    // Observe we can take elements from left and right portion to form x and our goal is to use least elements possible\\n    // So , we alternatively need to maximize the size of the middle portion and its sum = total sum-x\\n    \\n    int minOperations(vector<int>& nums, int x) {\\n        // Finding total sum of the array\\n        int sum=0;\\n        for(auto it:nums){\\n            sum+=it;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1016246,
                "title": "sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total=0,n=nums.size();\\n        for(int num : nums)total+=num;\\n        int need=total-x,cur=0,longest=0;\\n        if(need==0)return n;\\n        int l=0,r=0;\\n        while(l<=r){\\n            if(cur<need){\\n                if(r<n)cur+=nums[r++];\\n                else break;\\n            }else if(cur>need){\\n                cur-=nums[l++];\\n            }else{\\n                longest=max(longest,r-l);\\n                cur-=nums[l++];\\n            }\\n        }\\n        if(cur==need)longest=max(longest,r-l);\\n        if(longest==0)return -1;\\n        return n-longest;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total=0,n=nums.size();\\n        for(int num : nums)total+=num;\\n        int need=total-x,cur=0,longest=0;\\n        if(need==0)return n;\\n        int l=0,r=0;\\n        while(l<=r){\\n            if(cur<need){\\n                if(r<n)cur+=nums[r++];\\n                else break;\\n            }else if(cur>need){\\n                cur-=nums[l++];\\n            }else{\\n                longest=max(longest,r-l);\\n                cur-=nums[l++];\\n            }\\n        }\\n        if(cur==need)longest=max(longest,r-l);\\n        if(longest==0)return -1;\\n        return n-longest;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067121,
                "title": "easiest-solution-with-explanation-and-annotations",
                "content": "# Intuition\\nWe can use prefix sum and suffix sum here. \\nFor every number in prefix sum we\\'ll check if its complement is present in suffix. If it is it means we can make our `x` if it is not it means we can\\'t make `x` with that particular prefix, so move on to the next one.\\n\\n# Approach\\n- Firstly we find our `n` which is size of the array.\\n- Write base cases for `n = 1, sum < x and sum == x.`\\n- Now we find our prefix sum using a for loop and sotre it in an array `prefix`.\\n- Now create a map for suffix sum `suff`, we are creating map so we get the index of the suffix sum which we will require later for finding the number of operations.\\n- Our last prefixSum `sum` will be equal to total sum of the array. So we use it to find suffix sum and store it in `suff`. We also store the index here in the map so our `key` is `sum` and `value` is `index`.\\n- We do `suff[0] = n` because the sum 0 will be at last so its index will be last.\\n\\nNow, starts the main logic - \\n- Iterate over the `prefix` array and find our `target`.\\n- If target is present in the map `suff` as a key, we find minimum noOfOps by taking `minimum of noOfOps and current number of ops`.\\n- We find current `no of ops` by following- we have our index of prefix sum as `i` it means we need to pop `i` numbers from start. \\n- We have our suffix Sum index as `suff[target]` but this is from start. So we need to pop `n - suff[target]` to get that suffix sum.\\n- hence ` i + n - suff[target]`\\n- Note how we are updating noOfOps only if we have our target, so at last if `noOfOps` is still `INT_MAX` it means we have no answer hence return `-1 ` else return `noOfOps`.\\n\\n# I\\'ve explained test case 3 below for better understanding.\\n![image.png](https://assets.leetcode.com/users/images/53820838-be18-47a5-8849-39caa8fcc2d7_1695188923.6781495.png)\\n\\n\\n# Note- This code doesnt\\'t beat 100% because i\\'ve kept it simple for better understanding. You can use the same for loop used for prefixsum to calculate suffixsum and you\\'ll save a lot of time there. Also a lot of times runtime isn\\'t accurate because of slow network so try resubmitting for better runtime.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        if(n == 1 && nums[0] != x) return -1;\\n        vector<int> prefix;\\n        prefix.push_back(0);\\n\\n        int sum = 0;\\n        for(int i =0;i < n ;i++){\\n            sum += nums[i];\\n            prefix.push_back(sum);\\n        }\\n        if(sum < x) return -1;\\n        if(sum == x) return n;\\n        unordered_map<int,int> suff;\\n\\n        for(int i = 0;i < n; i++){\\n            suff[sum] = i;\\n            sum -= nums[i];\\n\\n        }\\n        suff[0] = n;\\n\\n        // Main Logic\\n\\n        int noOfOps = INT_MAX;\\n\\n        int i = 0;\\n        while(prefix[i] <= x){\\n            int target = x - prefix[i];\\n\\n            if(suff[target]){\\n                noOfOps = min(noOfOps, i + n - suff[target]);\\n            }\\n            i++;\\n        }\\n        if(noOfOps == INT_MAX) return -1;\\n        return noOfOps;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        if(n == 1 && nums[0] != x) return -1;\\n        vector<int> prefix;\\n        prefix.push_back(0);\\n\\n        int sum = 0;\\n        for(int i =0;i < n ;i++){\\n            sum += nums[i];\\n            prefix.push_back(sum);\\n        }\\n        if(sum < x) return -1;\\n        if(sum == x) return n;\\n        unordered_map<int,int> suff;\\n\\n        for(int i = 0;i < n; i++){\\n            suff[sum] = i;\\n            sum -= nums[i];\\n\\n        }\\n        suff[0] = n;\\n\\n        // Main Logic\\n\\n        int noOfOps = INT_MAX;\\n\\n        int i = 0;\\n        while(prefix[i] <= x){\\n            int target = x - prefix[i];\\n\\n            if(suff[target]){\\n                noOfOps = min(noOfOps, i + n - suff[target]);\\n            }\\n            i++;\\n        }\\n        if(noOfOps == INT_MAX) return -1;\\n        return noOfOps;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268221,
                "title": "very-easy-c-solution-with-explanation-sliding-window-beats-88-2-submissions",
                "content": "**Explanation**\\nThis is a slighty tricky variant of Sliding Window problem.\\n\\nTrick to make this question easy :\\n* Total = Sum of all elements of the nums array.\\n* Now find max operation to find (total-x) in the array\\n\\nCheck result :\\n* If the result comes to 0 then return -1\\n* else return size-result\\n\\nTime Complexity : O(n)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& n, int x) {\\n          int size = n.size();\\n          int total = 0;\\n          int len = 0;\\n          for(int i : n) total += i;\\n          if(total == x) return size;\\n          int need = total - x;\\n          int i = 0 , j = 0;\\n          int sum = 0;\\n          while( j < size ) {\\n                sum += n[j];  \\n                while(i < j && sum > need){\\n                        sum -= n[i++];\\n                }\\n                if(sum == need){\\n                    \\n                    len = max(len, j-i+1);\\n                }\\n                j++;\\n          } \\n          if(len == 0) return -1;  \\n          return size-len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& n, int x) {\\n          int size = n.size();\\n          int total = 0;\\n          int len = 0;\\n          for(int i : n) total += i;\\n          if(total == x) return size;\\n          int need = total - x;\\n          int i = 0 , j = 0;\\n          int sum = 0;\\n          while( j < size ) {\\n                sum += n[j];  \\n                while(i < j && sum > need){\\n                        sum -= n[i++];\\n                }\\n                if(sum == need){\\n                    \\n                    len = max(len, j-i+1);\\n                }\\n                j++;\\n          } \\n          if(len == 0) return -1;  \\n          return size-len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136846,
                "title": "c-easy-solution-w-explanation-sliding-window",
                "content": "**Please upvote the post if you like it :)**\\n\\n**Intuition:**\\nwe can basically think this problem as `finding the longest subarray` with **sum** `sum - x`, since we are deleting only from the ends so we will be left out with sum `sum-x` left if we are able to remove elements with sum `x` \\nThis is how we come to down to the approach of using `sliding window` with variable size using `2 pointers` \\n\\n* Here we are taking **2 pointers** -> `start_ind, end_ind`\\n* If the `sum` of the `subarray` exceeds the `target` then we simply reduce the `window size` i.e increasing `start_ind` until it is `<=target`\\n* If the sum==target we simply mark the found as true and compare the length(`end_ind-start_ind+1`) if it is more than `max_len` then we store it.\\n* Return `-1` if the **sum** of the sliding window never becomes equal to **target**\\n****\\n**Code(C++):**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int sum=0;\\n        for(int i:nums) sum+=i;\\n        int target = sum-x;\\n        int cur_sum=0,max_len=0;\\n        int start_ind=0;\\n        bool found = false;\\n        for(int end_ind=0;end_ind<n;end_ind++){\\n            cur_sum+=nums[end_ind];\\n            while(start_ind<=end_ind && cur_sum>target){\\n                cur_sum -=nums[start_ind];\\n                start_ind+=1;\\n            }\\n            if(cur_sum==target){\\n                found = true;\\n                max_len = max(max_len,end_ind-start_ind+1);\\n            }\\n        }\\n        return found?n-max_len:-1;\\n    }\\n};\\n```\\n\\n**Time Complexity : O(N)**\\n**Space Complexity : O(1)**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int sum=0;\\n        for(int i:nums) sum+=i;\\n        int target = sum-x;\\n        int cur_sum=0,max_len=0;\\n        int start_ind=0;\\n        bool found = false;\\n        for(int end_ind=0;end_ind<n;end_ind++){\\n            cur_sum+=nums[end_ind];\\n            while(start_ind<=end_ind && cur_sum>target){\\n                cur_sum -=nums[start_ind];\\n                start_ind+=1;\\n            }\\n            if(cur_sum==target){\\n                found = true;\\n                max_len = max(max_len,end_ind-start_ind+1);\\n            }\\n        }\\n        return found?n-max_len:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258133,
                "title": "java-greedy-dp-hashmap-binarysearch-prefix-sum-sliding-window-5-approaches",
                "content": "\\n\\t// O(2^n) O(n)\\n\\t// Recursion\\n\\t// TLE\\n\\tpublic int minOperationsRec(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tint count = minOperationsHelper(nums, x, 0, len - 1);\\n\\t\\treturn (count == Integer.MAX_VALUE) ? -1 : count;\\n\\t}\\n\\n\\t// O(2^n) O(n)\\n\\t// Recursion\\n\\tpublic int minOperationsHelper(int[] nums, int x, int si, int ei) {\\n\\n\\t\\tif (x == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (x < 0 || si > ei)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\n\\t\\tint front = minOperationsHelper(nums, x - nums[si], si + 1, ei);\\n\\t\\tint rear = minOperationsHelper(nums, x - nums[ei], si, ei - 1);\\n\\n\\t\\tint min = Math.min(front, rear);\\n\\t\\treturn min == Integer.MAX_VALUE ? min : min + 1;\\n\\t}\\n\\n\\t// O(n^2) O(n^2)\\n\\t// Memoization\\n\\t// TLE\\n\\tpublic int minOperationsMemo(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tint[][] memo = new int[len][len];\\n\\t\\tint count = minOperationsHelper(nums, x, 0, len - 1, memo);\\n\\t\\treturn (count == Integer.MAX_VALUE) ? -1 : count;\\n\\t}\\n\\n\\t// O(n^2) O(n^2)\\n\\t// Memoization\\n\\tpublic int minOperationsHelper(int[] nums, int x, int si, int ei, int[][] memo) {\\n\\n\\t\\tif (x == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (x < 0 || si > ei)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\n\\t\\tif (memo[si][ei] != 0)\\n\\t\\t\\treturn memo[si][ei];\\n\\n\\t\\tint front = minOperationsHelper(nums, x - nums[si], si + 1, ei, memo);\\n\\t\\tint rear = minOperationsHelper(nums, x - nums[ei], si, ei - 1, memo);\\n\\n\\t\\tint min = Math.min(front, rear);\\n\\t\\tint ans = (min == Integer.MAX_VALUE) ? min : min + 1;\\n\\t\\tmemo[si][ei] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\t// HashMap\\n\\tpublic int minOperations1(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length, total = 0;\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\ttotal += nums[i];\\n\\n\\t\\tint target = total - x;\\n\\t\\tint ans = subArraySumK1(nums, target);\\n\\t\\treturn (ans == -1) ? -1 : len - ans;\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\t// HashMap\\n\\tpublic int subArraySumK1(int[] arr, int K) {\\n\\n\\t\\tif (K == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint len = arr.length, sum = 0, ans = -1;\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(sum, -1);\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tif (map.containsKey(sum - K)) {\\n\\t\\t\\t\\tint idx = map.get(sum - K);\\n\\t\\t\\t\\tif (i - idx > ans)\\n\\t\\t\\t\\t\\tans = i - idx;\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(sum, i);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n^2) O(n)\\n\\t// Brute Force\\n\\t// TLE\\n\\tpublic int minOperations2(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length, total = 0;\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\ttotal += nums[i];\\n\\n\\t\\tint target = total - x;\\n\\t\\tint ans = subArraySum2(nums, target);\\n\\t\\treturn (ans == -1) ? -1 : len - ans;\\n\\t}\\n\\n\\t// O(n^2) O(n)\\n\\t// Brute Force\\n\\tpublic int subArraySum2(int[] nums, int target) {\\n\\n\\t\\tint len = nums.length, ans = -1;\\n\\n\\t\\tint[] prefix = new int[len];\\n\\t\\tprefix[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefix[i] = prefix[i - 1] + nums[i];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tfor (int j = i; j < len; j++) {\\n\\t\\t\\t\\tint sum = prefix[j] - prefix[i] + nums[i];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tif (j - i + 1 > ans)\\n\\t\\t\\t\\t\\t\\tans = j - i + 1;\\n\\t\\t\\t\\t} else if (sum > target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\t// Binary Search\\n\\tpublic int minOperations3(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length, total = 0;\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\ttotal += nums[i];\\n\\n\\t\\tint target = total - x;\\n\\t\\tint ans = subArraySum3(nums, target);\\n\\t\\treturn (ans == -1) ? -1 : len - ans;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\t// Binary Search\\n\\tpublic int subArraySum3(int[] nums, int target) {\\n\\n\\t\\tint len = nums.length, ans = -1;\\n\\t\\tint[] prefix = new int[len];\\n\\n\\t\\tprefix[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefix[i] = prefix[i - 1] + nums[i];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint sum = target + prefix[i] - nums[i];\\n\\t\\t\\tint j = binarySearch(prefix, i, len - 1, sum);\\n\\t\\t\\tif (j != -1 && j - i + 1 > ans)\\n\\t\\t\\t\\tans = j - i + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\t// Binary Search\\n\\tpublic int binarySearch(int[] prefix, int lo, int hi, int key) {\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (prefix[mid] == key)\\n\\t\\t\\t\\treturn mid;\\n\\t\\t\\telse if (prefix[mid] > key)\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\t// Sliding Window\\n\\tpublic int minOperations4(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length, total = 0;\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\ttotal += nums[i];\\n\\n\\t\\tint target = total - x;\\n\\t\\tint ans = subArraySumK4(nums, target);\\n\\t\\treturn (ans == -1) ? -1 : len - ans;\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\t// Sliding Window\\n\\tpublic int subArraySumK4(int[] arr, int K) {\\n\\n\\t\\tint len = arr.length, ptr1 = 0, ptr2 = -1, sum = 0, ans = -1;\\n\\n\\t\\twhile (ptr1 < len) {\\n\\n\\t\\t\\twhile (ptr1 < len) {\\n\\t\\t\\t\\tsum += arr[ptr1];\\n\\t\\t\\t\\tif (sum == K) {\\n\\t\\t\\t\\t\\tif (ptr1 - ptr2 > ans)\\n\\t\\t\\t\\t\\t\\tans = ptr1 - ptr2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum > K) {\\n\\t\\t\\t\\t\\tptr1++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tptr1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (ptr2 < ptr1 - 1) {\\n\\t\\t\\t\\tptr2++;\\n\\t\\t\\t\\tsum -= arr[ptr2];\\n\\t\\t\\t\\tif (sum == K) {\\n\\t\\t\\t\\t\\tif (ptr1 - ptr2 - 1 > ans)\\n\\t\\t\\t\\t\\t\\tans = ptr1 - ptr2 - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum < K)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// O(2^n) O(n)\\n\\t// Recursion\\n\\t// TLE\\n\\tpublic int minOperationsRec(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tint count = minOperationsHelper(nums, x, 0, len - 1);\\n\\t\\treturn (count == Integer.MAX_VALUE) ? -1 : count;\\n\\t}\\n\\n\\t// O(2^n) O(n)\\n\\t// Recursion\\n\\tpublic int minOperationsHelper(int[] nums, int x, int si, int ei) {\\n\\n\\t\\tif (x == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (x < 0 || si > ei)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\n\\t\\tint front = minOperationsHelper(nums, x - nums[si], si + 1, ei);\\n\\t\\tint rear = minOperationsHelper(nums, x - nums[ei], si, ei - 1);\\n\\n\\t\\tint min = Math.min(front, rear);\\n\\t\\treturn min == Integer.MAX_VALUE ? min : min + 1;\\n\\t}\\n\\n\\t// O(n^2) O(n^2)\\n\\t// Memoization\\n\\t// TLE\\n\\tpublic int minOperationsMemo(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tint[][] memo = new int[len][len];\\n\\t\\tint count = minOperationsHelper(nums, x, 0, len - 1, memo);\\n\\t\\treturn (count == Integer.MAX_VALUE) ? -1 : count;\\n\\t}\\n\\n\\t// O(n^2) O(n^2)\\n\\t// Memoization\\n\\tpublic int minOperationsHelper(int[] nums, int x, int si, int ei, int[][] memo) {\\n\\n\\t\\tif (x == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (x < 0 || si > ei)\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n\\n\\t\\tif (memo[si][ei] != 0)\\n\\t\\t\\treturn memo[si][ei];\\n\\n\\t\\tint front = minOperationsHelper(nums, x - nums[si], si + 1, ei, memo);\\n\\t\\tint rear = minOperationsHelper(nums, x - nums[ei], si, ei - 1, memo);\\n\\n\\t\\tint min = Math.min(front, rear);\\n\\t\\tint ans = (min == Integer.MAX_VALUE) ? min : min + 1;\\n\\t\\tmemo[si][ei] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\t// HashMap\\n\\tpublic int minOperations1(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length, total = 0;\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\ttotal += nums[i];\\n\\n\\t\\tint target = total - x;\\n\\t\\tint ans = subArraySumK1(nums, target);\\n\\t\\treturn (ans == -1) ? -1 : len - ans;\\n\\t}\\n\\n\\t// O(n) O(n)\\n\\t// HashMap\\n\\tpublic int subArraySumK1(int[] arr, int K) {\\n\\n\\t\\tif (K == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint len = arr.length, sum = 0, ans = -1;\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(sum, -1);\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\n\\t\\t\\tsum += arr[i];\\n\\t\\t\\tif (map.containsKey(sum - K)) {\\n\\t\\t\\t\\tint idx = map.get(sum - K);\\n\\t\\t\\t\\tif (i - idx > ans)\\n\\t\\t\\t\\t\\tans = i - idx;\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(sum, i);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n^2) O(n)\\n\\t// Brute Force\\n\\t// TLE\\n\\tpublic int minOperations2(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length, total = 0;\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\ttotal += nums[i];\\n\\n\\t\\tint target = total - x;\\n\\t\\tint ans = subArraySum2(nums, target);\\n\\t\\treturn (ans == -1) ? -1 : len - ans;\\n\\t}\\n\\n\\t// O(n^2) O(n)\\n\\t// Brute Force\\n\\tpublic int subArraySum2(int[] nums, int target) {\\n\\n\\t\\tint len = nums.length, ans = -1;\\n\\n\\t\\tint[] prefix = new int[len];\\n\\t\\tprefix[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefix[i] = prefix[i - 1] + nums[i];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tfor (int j = i; j < len; j++) {\\n\\t\\t\\t\\tint sum = prefix[j] - prefix[i] + nums[i];\\n\\t\\t\\t\\tif (sum == target) {\\n\\t\\t\\t\\t\\tif (j - i + 1 > ans)\\n\\t\\t\\t\\t\\t\\tans = j - i + 1;\\n\\t\\t\\t\\t} else if (sum > target)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\t// Binary Search\\n\\tpublic int minOperations3(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length, total = 0;\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\ttotal += nums[i];\\n\\n\\t\\tint target = total - x;\\n\\t\\tint ans = subArraySum3(nums, target);\\n\\t\\treturn (ans == -1) ? -1 : len - ans;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\t// Binary Search\\n\\tpublic int subArraySum3(int[] nums, int target) {\\n\\n\\t\\tint len = nums.length, ans = -1;\\n\\t\\tint[] prefix = new int[len];\\n\\n\\t\\tprefix[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefix[i] = prefix[i - 1] + nums[i];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint sum = target + prefix[i] - nums[i];\\n\\t\\t\\tint j = binarySearch(prefix, i, len - 1, sum);\\n\\t\\t\\tif (j != -1 && j - i + 1 > ans)\\n\\t\\t\\t\\tans = j - i + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\t// Binary Search\\n\\tpublic int binarySearch(int[] prefix, int lo, int hi, int key) {\\n\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (prefix[mid] == key)\\n\\t\\t\\t\\treturn mid;\\n\\t\\t\\telse if (prefix[mid] > key)\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\t// Sliding Window\\n\\tpublic int minOperations4(int[] nums, int x) {\\n\\n\\t\\tint len = nums.length, total = 0;\\n\\t\\tfor (int i = 0; i < len; i++)\\n\\t\\t\\ttotal += nums[i];\\n\\n\\t\\tint target = total - x;\\n\\t\\tint ans = subArraySumK4(nums, target);\\n\\t\\treturn (ans == -1) ? -1 : len - ans;\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\t// Sliding Window\\n\\tpublic int subArraySumK4(int[] arr, int K) {\\n\\n\\t\\tint len = arr.length, ptr1 = 0, ptr2 = -1, sum = 0, ans = -1;\\n\\n\\t\\twhile (ptr1 < len) {\\n\\n\\t\\t\\twhile (ptr1 < len) {\\n\\t\\t\\t\\tsum += arr[ptr1];\\n\\t\\t\\t\\tif (sum == K) {\\n\\t\\t\\t\\t\\tif (ptr1 - ptr2 > ans)\\n\\t\\t\\t\\t\\t\\tans = ptr1 - ptr2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum > K) {\\n\\t\\t\\t\\t\\tptr1++;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tptr1++;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (ptr2 < ptr1 - 1) {\\n\\t\\t\\t\\tptr2++;\\n\\t\\t\\t\\tsum -= arr[ptr2];\\n\\t\\t\\t\\tif (sum == K) {\\n\\t\\t\\t\\t\\tif (ptr1 - ptr2 - 1 > ans)\\n\\t\\t\\t\\t\\t\\tans = ptr1 - ptr2 - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (sum < K)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 4067235,
                "title": "1-method-c-java-python-javascript",
                "content": "Read Whole article : https://www.nileshblog.tech/minimum-operations-to-reduce-x-to-zero/\\n\\nExplanation of Problem with Example (HandWritten).\\nTime Complexity:\\n\\n**Prefix Sum + Hashmap (Longest Subarry )Approach : O(N)**\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/minimum-operations-to-reduce-x-to-zero/\\n\\n![image](https://assets.leetcode.com/users/images/4d040d19-6d33-42a4-8d58-8bef6ff16117_1695190442.0211067.png)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "Read Whole article : https://www.nileshblog.tech/minimum-operations-to-reduce-x-to-zero/\\n\\nExplanation of Problem with Example (HandWritten).\\nTime Complexity:\\n\\n**Prefix Sum + Hashmap (Longest Subarry )Approach : O(N)**\\n\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/minimum-operations-to-reduce-x-to-zero/\\n\\n![image](https://assets.leetcode.com/users/images/4d040d19-6d33-42a4-8d58-8bef6ff16117_1695190442.0211067.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4066455,
                "title": "97-65-sum-of-subarray-reduction",
                "content": "# Problem\\n\\n### This problem involves finding the minimum number of operations to reduce the sum of elements in the array nums to exactly zero, given that you can perform operations to remove elements from either the left or right end of the array.\\n---\\n# Solution\\n\\n##### **1.** Calculate the total sum of all elements in the nums array and store it in the variable total.\\n\\n##### **2.** Calculate the target value that we want to reach, which is target = total - x. Essentially, we want to find a subarray whose sum is equal to target.\\n\\n##### **3.** Initialize two pointers, left and right, both starting at index 0, and a variable running_sum to keep track of the sum of elements within the sliding window.\\n\\n##### **4.** Initialize a variable max_length to -1. This variable will be used to keep track of the maximum length of a subarray with a sum equal to target.\\n\\n#### **5.** Iterate through the nums array using the right pointer. At each step, add the value at nums[right] to running_sum.\\n\\n#### **6.** Check if running_sum is greater than target. If it is, this means the current subarray sum is too large. In this case, we need to shrink the sliding window by incrementing the left pointer and subtracting the value at nums[left] from running_sum until running_sum is less than or equal to target.\\n\\n#### **7.** Once the sliding window is valid (i.e., running_sum is equal to target), calculate its length (right - left + 1) and update max_length if this length is greater than the current maximum length.\\n\\n#### **8.** Continue this process until you\\'ve iterated through the entire nums array.\\n\\n#### **9.** After the loop, check if max_length has been updated. If it has, it means we found a subarray with the sum equal to target. The minimum number of operations required to reduce x to zero is equal to n - max_length, where n is the length of the original array nums. If max_length is still -1, return -1 to indicate that it\\'s not possible to reduce x to zero.\\n---\\n# Summary\\n\\n#### In summary, the algorithm uses a sliding window approach to find the subarray with the sum equal to the target, and then calculates the minimum number of operations required based on the length of that subarray. If no such subarray exists, it returns -1.\\n\\n---\\n# Code\\n```Python3 []\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        total = sum(nums)\\n        target = total - x\\n        left = 0\\n        n = len(nums)\\n        max_length = -1\\n        running_sum = 0\\n\\n        for right in range(n):\\n            running_sum += nums[right]\\n\\n            #shrink sliding window to make sure running_sum is not greater than target\\n            while running_sum > target and left <= right:\\n                running_sum -= nums[left]\\n                left += 1\\n\\n            #now we have a avalid sliding window\\n            if running_sum == target:\\n                max_length = max(max_length, right - left + 1)\\n        \\n        return n - max_length if max_length != -1 else -1\\n```\\n```python []\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        total = sum(nums)\\n        target = total - x\\n        left = 0\\n        n = len(nums)\\n        max_length = -1\\n        running_sum = 0\\n\\n        for right in range(n):\\n            running_sum += nums[right]\\n\\n            #shrink sliding window to make sure running_sum is not greater than target\\n            while running_sum > target and left <= right:\\n                running_sum -= nums[left]\\n                left += 1\\n\\n            #now we have a avalid sliding window\\n            if running_sum == target:\\n                max_length = max(max_length, right - left + 1)\\n        \\n        return n - max_length if max_length != -1 else -1\\n```\\n```C# []\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        int total = nums.Sum();\\n        int target = total - x;\\n        int left = 0;\\n        int n = nums.Length;\\n        int maxLength = -1;\\n        int runningSum = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            runningSum += nums[right];\\n\\n            while (runningSum > target && left <= right) {\\n                runningSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (runningSum == target) {\\n                maxLength = Math.Max(maxLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxLength != -1 ? n - maxLength : -1;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(std::vector<int>& nums, int x) {\\n        int total = std::accumulate(nums.begin(), nums.end(), 0);\\n        int target = total - x;\\n        int left = 0;\\n        int n = nums.size();\\n        int maxLength = -1;\\n        int runningSum = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            runningSum += nums[right];\\n\\n            while (runningSum > target && left <= right) {\\n                runningSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (runningSum == target) {\\n                maxLength = std::max(maxLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxLength != -1 ? n - maxLength : -1;\\n    }\\n};\\n\\n```\\n```C []\\nint minOperations(int* nums, int numsSize, int x) {\\n    int total = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        total += nums[i];\\n    }\\n\\n    int target = total - x;\\n    int left = 0;\\n    int maxLength = -1;\\n    int runningSum = 0;\\n\\n    for (int right = 0; right < numsSize; right++) {\\n        runningSum += nums[right];\\n\\n        while (runningSum > target && left <= right) {\\n            runningSum -= nums[left];\\n            left++;\\n        }\\n\\n        if (runningSum == target) {\\n            int currentLength = right - left + 1;\\n            maxLength = (maxLength == -1) ? currentLength : (currentLength > maxLength ? currentLength : maxLength);\\n        }\\n    }\\n\\n    return (maxLength != -1) ? numsSize - maxLength : -1;\\n}\\n\\n```\\n```Java []\\npublic class Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int total = 0;\\n        for (int num : nums) {\\n            total += num;\\n        }\\n\\n        int target = total - x;\\n        int left = 0;\\n        int n = nums.length;\\n        int maxLength = -1;\\n        int runningSum = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            runningSum += nums[right];\\n\\n            while (runningSum > target && left <= right) {\\n                runningSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (runningSum == target) {\\n                maxLength = Math.max(maxLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxLength != -1 ? n - maxLength : -1;\\n    }\\n}\\n\\n```\\n```Go []\\nfunc minOperations(nums []int, x int) int {\\n    total := 0\\n    for _, num := range nums {\\n        total += num\\n    }\\n\\n    target := total - x\\n    left := 0\\n    n := len(nums)\\n    maxLength := -1\\n    runningSum := 0\\n\\n    for right := 0; right < n; right++ {\\n        runningSum += nums[right]\\n\\n        for runningSum > target && left <= right {\\n            runningSum -= nums[left]\\n            left++\\n        }\\n\\n        if runningSum == target {\\n            currentLength := right - left + 1\\n            if maxLength == -1 || currentLength > maxLength {\\n                maxLength = currentLength\\n            }\\n        }\\n    }\\n\\n    if maxLength != -1 {\\n        return n - maxLength\\n    }\\n\\n    return -1\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "Go",
                    "Array",
                    "Hash Table"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        total = sum(nums)\\n        target = total - x\\n        left = 0\\n        n = len(nums)\\n        max_length = -1\\n        running_sum = 0\\n\\n        for right in range(n):\\n            running_sum += nums[right]\\n\\n            #shrink sliding window to make sure running_sum is not greater than target\\n            while running_sum > target and left <= right:\\n                running_sum -= nums[left]\\n                left += 1\\n\\n            #now we have a avalid sliding window\\n            if running_sum == target:\\n                max_length = max(max_length, right - left + 1)\\n        \\n        return n - max_length if max_length != -1 else -1\\n```\n```python []\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        total = sum(nums)\\n        target = total - x\\n        left = 0\\n        n = len(nums)\\n        max_length = -1\\n        running_sum = 0\\n\\n        for right in range(n):\\n            running_sum += nums[right]\\n\\n            #shrink sliding window to make sure running_sum is not greater than target\\n            while running_sum > target and left <= right:\\n                running_sum -= nums[left]\\n                left += 1\\n\\n            #now we have a avalid sliding window\\n            if running_sum == target:\\n                max_length = max(max_length, right - left + 1)\\n        \\n        return n - max_length if max_length != -1 else -1\\n```\n```C# []\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        int total = nums.Sum();\\n        int target = total - x;\\n        int left = 0;\\n        int n = nums.Length;\\n        int maxLength = -1;\\n        int runningSum = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            runningSum += nums[right];\\n\\n            while (runningSum > target && left <= right) {\\n                runningSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (runningSum == target) {\\n                maxLength = Math.Max(maxLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxLength != -1 ? n - maxLength : -1;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(std::vector<int>& nums, int x) {\\n        int total = std::accumulate(nums.begin(), nums.end(), 0);\\n        int target = total - x;\\n        int left = 0;\\n        int n = nums.size();\\n        int maxLength = -1;\\n        int runningSum = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            runningSum += nums[right];\\n\\n            while (runningSum > target && left <= right) {\\n                runningSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (runningSum == target) {\\n                maxLength = std::max(maxLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxLength != -1 ? n - maxLength : -1;\\n    }\\n};\\n\\n```\n```C []\\nint minOperations(int* nums, int numsSize, int x) {\\n    int total = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        total += nums[i];\\n    }\\n\\n    int target = total - x;\\n    int left = 0;\\n    int maxLength = -1;\\n    int runningSum = 0;\\n\\n    for (int right = 0; right < numsSize; right++) {\\n        runningSum += nums[right];\\n\\n        while (runningSum > target && left <= right) {\\n            runningSum -= nums[left];\\n            left++;\\n        }\\n\\n        if (runningSum == target) {\\n            int currentLength = right - left + 1;\\n            maxLength = (maxLength == -1) ? currentLength : (currentLength > maxLength ? currentLength : maxLength);\\n        }\\n    }\\n\\n    return (maxLength != -1) ? numsSize - maxLength : -1;\\n}\\n\\n```\n```Java []\\npublic class Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int total = 0;\\n        for (int num : nums) {\\n            total += num;\\n        }\\n\\n        int target = total - x;\\n        int left = 0;\\n        int n = nums.length;\\n        int maxLength = -1;\\n        int runningSum = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            runningSum += nums[right];\\n\\n            while (runningSum > target && left <= right) {\\n                runningSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (runningSum == target) {\\n                maxLength = Math.max(maxLength, right - left + 1);\\n            }\\n        }\\n\\n        return maxLength != -1 ? n - maxLength : -1;\\n    }\\n}\\n\\n```\n```Go []\\nfunc minOperations(nums []int, x int) int {\\n    total := 0\\n    for _, num := range nums {\\n        total += num\\n    }\\n\\n    target := total - x\\n    left := 0\\n    n := len(nums)\\n    maxLength := -1\\n    runningSum := 0\\n\\n    for right := 0; right < n; right++ {\\n        runningSum += nums[right]\\n\\n        for runningSum > target && left <= right {\\n            runningSum -= nums[left]\\n            left++\\n        }\\n\\n        if runningSum == target {\\n            currentLength := right - left + 1\\n            if maxLength == -1 || currentLength > maxLength {\\n                maxLength = currentLength\\n            }\\n        }\\n    }\\n\\n    if maxLength != -1 {\\n        return n - maxLength\\n    }\\n\\n    return -1\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017216,
                "title": "c-cumulative-sums-solution-explained-100-time-70-space",
                "content": "Okay, I tried a number of approaches, including a 2d matrix for DP and a double-ended BFS, before realising that there was a much easier and performant solution; the tips for the problem definitely did not help.\\n\\nThe core idea is to compute and store all the partial sums from the left together with the indexes in which we can achieve them, then look for matches computing cumulative sums from the right, but I guess it will become clearer with some explanations.\\n\\nFirst of all we declare a few support variables:\\n* `res`, our accumulator variable, initialised to `-1` (which will flag no valid solution was found);\\n* `len` will store the length of the vector;\\n* `tot` will store the partial sums;\\n* `m` is an `unordered_map` that we will use with partial sums as keys and indexes at which they were obtained as values.\\n\\nWe will then proceed and populate `m`; first of all we will have `0` obtained at the fictitious position of `-1`, that is to say: before even starting the sum, that is our initial value for it.\\n\\nLooping from the left, we will compute the cumulative sum, store it in `tot` and store the matching index in `m[tot]`, as announced; we will loop as long as `i` is within the margins of our vector and `tot` is less than `x` (no point in proceeding further).\\n\\nOnce done, we have to deal with 2 edge cases:\\n* we run through the whole vector (`m[tot] == len - 1)`, so we return `len` if `tot == x` (ie: we need each single element to reach that value) or `-1` otherwise (ie: even summing them all, we cannot reach `x`);\\n* alternatively, if `tot == x`, it means that potentially we might proceed only removing from the left, but we do not return it yet, since removing from the right or a mix of the two might be even more convenient, so we just store `m[tot] + 1` (because we were storing `0`-based indexes) into `res` and move on with the second loop to check that.\\n\\nWe can now reset `tot == 0` and start computing a cumulative sum from the right. As soon as we find a matching key of `x - tot`, we update `res`, since it means that we might achieve `x` summing `tot` and, of course `x - tot`.\\n\\nTo update `res`, we check if a value of `res` was previously found (ie: `res > -1`), otherwise we take the top value `len` and then compute the minimum between it and the current one, found moving `m[tot] + 1` steps from the left (as explained above) and `len - j` steps from the right.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // support variables\\n        int res = -1, len = nums.size(), tot = 0;\\n        unordered_map<int, int> m;\\n        // storing the position of all the partial sums from left up to x\\n        // and relative indexes\\n        m[0] = -1;\\n        for (int i = 0; i < len && tot < x; i++) {\\n            m[tot += nums[i]] = i;\\n        }\\n        // edge case: x >= the sum of all the elements in the vector\\n        if (m[tot] == len - 1) return tot == x ? m[tot] + 1 : -1;\\n        // edge case: x found just summing left numbers\\n        if (tot == x) res = m[tot] + 1;\\n        // resetting tot\\n        tot = 0;\\n        // moving on from the right\\n        for (int j = len - 1; j >= 0 && tot < x; j--) {\\n            // updating res if there is a match\\n            if (m.find(x - (tot += nums[j])) != end(m)) {\\n                res = min(res > -1 ? res : len, m[x - tot] + 1 + len - j);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nMicro-optimisation, you might find even more efficient to limit the second loop in some edge cases, when a viable `res` was already found and it does not make sense to parse from the right a long list of values relatively small compared to `x`:\\n\\n```cpp\\n\\n        // moving on from the right\\n        for (int j = len - 1, lmt = res > -1 ? len - res : 0; j >= lmt && tot < x; j--) {\\n            // updating res if there is a match\\n            if (m.find(x - (tot += nums[j])) != end(m)) {\\n                res = min(res > -1 ? res : len, m[x - tot] + 1 + len - j);\\n            }\\n        }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // support variables\\n        int res = -1, len = nums.size(), tot = 0;\\n        unordered_map<int, int> m;\\n        // storing the position of all the partial sums from left up to x\\n        // and relative indexes\\n        m[0] = -1;\\n        for (int i = 0; i < len && tot < x; i++) {\\n            m[tot += nums[i]] = i;\\n        }\\n        // edge case: x >= the sum of all the elements in the vector\\n        if (m[tot] == len - 1) return tot == x ? m[tot] + 1 : -1;\\n        // edge case: x found just summing left numbers\\n        if (tot == x) res = m[tot] + 1;\\n        // resetting tot\\n        tot = 0;\\n        // moving on from the right\\n        for (int j = len - 1; j >= 0 && tot < x; j--) {\\n            // updating res if there is a match\\n            if (m.find(x - (tot += nums[j])) != end(m)) {\\n                res = min(res > -1 ? res : len, m[x - tot] + 1 + len - j);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\n\\n        // moving on from the right\\n        for (int j = len - 1, lmt = res > -1 ? len - res : 0; j >= lmt && tot < x; j--) {\\n            // updating res if there is a match\\n            if (m.find(x - (tot += nums[j])) != end(m)) {\\n                res = min(res > -1 ? res : len, m[x - tot] + 1 + len - j);\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136601,
                "title": "c-sliding-window-o-1-space-o-n-time",
                "content": "The problem can be thought of as finding the longest subarray with sum `total - x` ,because we are deleting elements from the ends only .So there will be a subarray left of sum `total-x` left if we were able to remove elements with sum `x`. \\n The approach is to use the concept of the variable-size sliding window using 2 pointers. Initialize i, j and sum = k .If the sum is less than k just increment j, if the sum is equal to k compute the max and if the sum is greater than k subtract ith element while the sum is less than k.\\n# Time Complexity : O(n)\\n# Space Complexity : O(1)\\n```\\n    int total = 0;\\n        for(int i : nums)total+=i;\\n        \\n       int target = total -x;\\n        \\n        if(target<0)return -1;\\n        if(target ==0)return nums.size();\\n        \\n    int i = 0, j = 0, sum = 0;\\n    int maxLen = -1;\\n   \\n    while (j < nums.size()) {\\n        sum += nums[j];\\n        if (sum < target) {\\n            j++;\\n        }\\n        else if (sum == target) {\\n            maxLen = max(maxLen, j-i+1);\\n            j++;\\n        }\\n        else if (sum > target) {\\n            while (sum > target) {\\n                sum -= nums[i];\\n                 i++;\\n            }\\n              if(sum == target){\\n              maxLen = max(maxLen, j-i+1);\\n            }\\n            j++;\\n        }\\n    }\\n        \\n    if(maxLen==-1)return -1;\\n        \\n        return nums.size()-maxLen;\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    int total = 0;\\n        for(int i : nums)total+=i;\\n        \\n       int target = total -x;\\n        \\n        if(target<0)return -1;\\n        if(target ==0)return nums.size();\\n        \\n    int i = 0, j = 0, sum = 0;\\n    int maxLen = -1;\\n   \\n    while (j < nums.size()) {\\n        sum += nums[j];\\n        if (sum < target) {\\n            j++;\\n        }\\n        else if (sum == target) {\\n            maxLen = max(maxLen, j-i+1);\\n            j++;\\n        }\\n        else if (sum > target) {\\n            while (sum > target) {\\n                sum -= nums[i];\\n                 i++;\\n            }\\n              if(sum == target){\\n              maxLen = max(maxLen, j-i+1);\\n            }\\n            j++;\\n        }\\n    }\\n        \\n    if(maxLen==-1)return -1;\\n        \\n        return nums.size()-maxLen;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016563,
                "title": "java-recursion-sliding-window-2-solutions",
                "content": "**Recursive Solution:** (Please note that it will give time limit exceeded (TLE) if submitted )\\n```\\nclass Solution {\\n    int ans;\\n    public int minOperations(int[] nums, int x) {\\n        ans = Integer.MAX_VALUE;\\n        recur(nums,0,nums.length-1,x,0);\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n    public void recur(int nums[],int start, int end,int target,int steps){\\n         if(target==0){\\n            ans = Math.min(ans,steps);\\n            return;\\n        }\\n        if(start>end || target<0){\\n            return;\\n        }\\n       \\n        recur(nums,start+1,end,target-nums[start],steps+1);\\n        recur(nums,start,end-1,target-nums[end],steps+1); \\n    }\\n}\\n```\\n\\n**Sliding Window Approach:**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for(int num: nums){\\n            sum+=num;\\n        }\\n        sum -= x; // ****totalsum-target to find maxSubArray \\n        int left = 0,right = 0,ans = -1;\\n        int subArraySum = 0;\\n        while(right<nums.length){\\n            subArraySum+=nums[right];\\n            if(subArraySum>sum){\\n                while(subArraySum>sum && left<=right){\\n                    subArraySum-=nums[left++];\\n                }\\n            }\\n            if(subArraySum==sum){\\n                ans = Math.max(ans,right-left+1);\\n            }\\n            right++;\\n        }\\n        return ans==-1?ans:nums.length-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int minOperations(int[] nums, int x) {\\n        ans = Integer.MAX_VALUE;\\n        recur(nums,0,nums.length-1,x,0);\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n    public void recur(int nums[],int start, int end,int target,int steps){\\n         if(target==0){\\n            ans = Math.min(ans,steps);\\n            return;\\n        }\\n        if(start>end || target<0){\\n            return;\\n        }\\n       \\n        recur(nums,start+1,end,target-nums[start],steps+1);\\n        recur(nums,start,end-1,target-nums[end],steps+1); \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for(int num: nums){\\n            sum+=num;\\n        }\\n        sum -= x; // ****totalsum-target to find maxSubArray \\n        int left = 0,right = 0,ans = -1;\\n        int subArraySum = 0;\\n        while(right<nums.length){\\n            subArraySum+=nums[right];\\n            if(subArraySum>sum){\\n                while(subArraySum>sum && left<=right){\\n                    subArraySum-=nums[left++];\\n                }\\n            }\\n            if(subArraySum==sum){\\n                ans = Math.max(ans,right-left+1);\\n            }\\n            right++;\\n        }\\n        return ans==-1?ans:nums.length-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936488,
                "title": "c-prefix-sums-o-n",
                "content": "We can observe that we are deleting some part of prefix(possibly none) and some part of suffix(possibly none) from the given array such that sum of prefix and suffix deleted is x\\nSo we create a map between the suffix sum and the length of suffix\\nNow we iterate from left to right,\\nlet say we are at index i, then let say prefix[i] denotes the prefix sum till i.\\nThen we have prefix[i] value for the current prefix , we need x - prefix[i] from the suffix to get a sum of x. So we can use the map created to check and update the answer.\\nWe check all prefix and report the minimum answer.Since this algorithm checks all prefixes , it would include the optimal solution\\nWe need to handle base case where x > sum , return -1 since the array sum is less than x , so no prefix or suffix could reduce x to zero\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(n)\\n\\n\\tclass Solution \\n\\t{\\n\\t\\tpublic:\\n\\t\\t\\tint minOperations(vector<int>& nums, int x) {\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < nums.size(); i++)sum += nums[i];\\n\\t\\t\\t\\tif(x > sum)return -1;\\n\\n\\t\\t\\t\\tunordered_map<int,int> mp;\\n\\n\\t\\t\\t\\t sum = 0;\\n\\t\\t\\t\\tint ans = 1000000000;\\n\\t\\t\\t\\tfor(int i = 0; i < nums.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\t\\tif(sum == x)ans = min(ans,i+1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\tfor(int i = nums.size()-1; i >=0 ; i--)\\n\\t\\t\\t\\t{   \\n\\t\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\t\\tmp[sum] = nums.size()-i;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(mp.find(x) != mp.end())ans = min(ans,mp[x]);\\n\\n\\t\\t\\t\\tsum = 0;\\n\\n\\t\\t\\t\\tfor(int i = 0; i < nums.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\t\\tif(mp.find(x-sum) != mp.end())ans = min(ans, i + 1 + mp[x-sum]);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(ans ==1000000000)ans = -1;\\n\\n\\t\\t\\t\\treturn ans;\\n\\n\\n\\t\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution \\n\\t{\\n\\t\\tpublic:\\n\\t\\t\\tint minOperations(vector<int>& nums, int x) {\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < nums.size(); i++)sum += nums[i];\\n\\t\\t\\t\\tif(x > sum)return -1;\\n\\n\\t\\t\\t\\tunordered_map<int,int> mp;\\n\\n\\t\\t\\t\\t sum = 0;\\n\\t\\t\\t\\tint ans = 1000000000;\\n\\t\\t\\t\\tfor(int i = 0; i < nums.size(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t\\t\\tif(sum == x)ans = min(ans,i+1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4066611,
                "title": "c-prefix-sum-binary-search-unordered-map-sliding-window-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code efficiently finds the minimum length of a subarray that sums up to x using prefix sums and binary search techniques.\\n\\nSecond approach does not use binary search. Insteadly the hash table unordered_map plays the role! The TC is reduced to linear $O(n)$.\\n\\n3rd approach uses sliding window method. TC=O(n) SC=O(1).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code begins by initializing a prefix vector with the first element of the nums array. This prefix vector is used to store prefix sums of the nums array.\\n2. It then enters a loop to calculate the prefix sums for the remaining elements of the nums array. If at any point the sum exceeds the target x, the loop breaks. This loop accumulates the prefix sums and stores them in the prefix vector.\\n3. After calculating the prefix sums, the code performs a binary search using lower_bound to find the index of x in the prefix vector. This binary search is crucial for efficiently searching for a subarray that sums up to x\\n4. f the binary search finds an exact match for x in the prefix vector, the code updates the answer (ans) with the index (idx + 1). If no match is found, ans remains at its initial value of INT_MAX.\\n5. The code then enters a backward loop, starting from the end of the nums array and decrementing x by the value of the current element. If x becomes negative, the loop breaks, as no subarray can sum to a negative value.\\n6. If x becomes zero, it means the current subarray from the end of the nums array to the current position has a sum equal to x. The code updates ans with the length of this subarray (n - j).\\n7. In this loop, a second binary search is performed to find the index of x in the prefix vector, but this time it\\'s done in reverse. The condition idx < j ensures that we\\'re not considering prefixes that include the current element itself.\\n8. f the binary search in the reverse loop finds an exact match for x, the code updates ans with the minimum of its current value and the length of the subarray from the reverse binary search (idx + 1 + (n - j)).\\n9. Finally, the code checks if ans remains at its initial value of INT_MAX. If so, it returns -1, indicating that no subarray was found. Otherwise, it returns the calculated ans.\\n\\nLet\\'s consider the testcase\\n```[3,2,20,1,1,3], x=10 ```\\nThe process\\n```\\nsz=3, prefix=25\\nx=10 ans=2147483647\\nprefix=5\\nj=5 suffix=3 prefix=5 idx=2\\nj=4 suffix=4 prefix=5 idx=2\\nupdate  ans=5\\nj=3 suffix=5 prefix=5 idx=2\\nj=2 suffix=25 prefix=0 idx=0\\n```\\nThe testcase ```[1,1,4,2,3] x=5 ```Process\\nsz=3, prefix=6\\nx=5 ans=2147483647\\nprefix=2\\nupdate  ans=3\\nj=4 suffix=3 prefix=2 idx=2\\nupdate  ans=2\\nj=3 suffix=5 prefix=0 idx=0\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$ O(n * \\\\log n)$ vs $O(n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> prefix={nums[0]};\\n        for(int i=1; i<n; i++){\\n        //    cout<<prefix[i-1]<<endl;\\n            if (prefix[i-1]>=x) break;\\n            prefix.push_back(prefix[i-1]+nums[i]);\\n        }\\n        int sz=prefix.size();\\n    //    cout<<\"sz=\"<<sz<<endl;\\n        int idx=lower_bound(prefix.begin(), prefix.end(), x)-prefix.begin();\\n        int ans=INT_MAX;\\n        if (idx!=sz && prefix[idx]==x){\\n            ans=idx+1;\\n        //    cout<<\"x=\"<<x<<\" idx=\"<<idx<<\" ans=\"<<ans<<endl;\\n        }\\n        for(int j=n-1; j>=0; j--){\\n            x-=nums[j];\\n            if (x<0) break;\\n            if (x==0) ans=min(ans, (n-j));\\n            idx=lower_bound(prefix.begin(), prefix.end(), x)-prefix.begin();\\n            if (idx<j && prefix[idx]==x){//idx<j very important\\n            //    cout<<\"x=\"<<x<<\" idx=\"<<idx<<\" ans=\"<<idx+(n-j)+1<<endl;\\n                ans=min(ans, idx+1+(n-j));\\n            } \\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```\\n# code with Explaination in comments\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<int> prefix = {nums[0]}; // Initialize a prefix sum array with the first element of nums.\\n\\n        for (int i = 1; i < n; i++) {\\n            // Calculate the prefix sum for each element in nums.\\n            if (prefix[i - 1] >= x) break; // If the sum exceeds x, exit the loop.\\n            prefix.push_back(prefix[i - 1] + nums[i]);\\n        }\\n\\n        int sz = prefix.size(); // Get the size of the prefix sum array.\\n\\n        int idx = lower_bound(prefix.begin(), prefix.end(), x) - prefix.begin(); // Find the index of x in the prefix sum array.\\n\\n        int ans = INT_MAX; // Initialize ans to a large value.\\n\\n        if (idx != sz && prefix[idx] == x) {\\n            ans = idx + 1; // If x is found in the prefix sum array, update ans.\\n        }\\n\\n        for (int j = n - 1; j >= 0; j--) {\\n            x -= nums[j]; // Subtract the current element from x.\\n\\n            if (x < 0) break; // If x becomes negative, exit the loop.\\n\\n            if (x == 0) ans = min(ans, (n - j)); // If x becomes zero, update ans with the length of the subarray.\\n\\n            idx = lower_bound(prefix.begin(), prefix.end(), x) - prefix.begin(); // Find the index of x in the prefix sum array.\\n\\n            if (idx < j && prefix[idx] == x) {\\n                // If x is found before the current element in the prefix sum array, update ans.\\n                ans = min(ans, idx + 1 + (n - j));\\n            }\\n        }\\n\\n        return ans == INT_MAX ? -1 : ans; // If ans is still the initial large value, return -1; otherwise, return ans.\\n    }\\n};\\n\\n```\\n# Code without binary searching using unordered_map\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int prefix=nums[0]; // Initialize the prefix sum with the first element.\\n        unordered_map<int, int> mp={{prefix, 0}};\\n        int ans = INT_MAX;\\n\\n        for (int i=1; i < n; i++) {\\n            prefix+=nums[i];\\n            if (prefix>x) break;\\n            mp[prefix]=i;   \\n        }\\n    //    for (auto [k, v]: mp)\\n    //       cout<<k<<\"->\"<<v<<endl;\\n\\n        if (mp.count(x)) ans=mp[x]+1;\\n    //    cout<<\"x=\"<<x<<\" idx=\"<<ans-1<<\" ans=\"<<ans<<endl;\\n\\n        for (int j=n-1; j >= 0; j--) {\\n            x-=nums[j];\\n            if (x<0) break;\\n            if (x==0) ans=min(ans, (n-j));\\n            int idx=-1;\\n            if (mp.count(x) && (idx=mp[x])<j) {\\n            //    cout<<\"x=\"<<x<<\" idx=\"<<idx<<\" ans=\"<<idx+(n-j)+1<<endl;\\n                ans=min(ans, idx+1+(n-j));\\n            }\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n\\n\\n```\\n# Code with sliding windows\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        int prefix=nums[0];\\n        int sz=n;\\n        for(int i=1; i<n; i++){\\n//          cout<<prefix<<endl;\\n            if (prefix>x) {\\n                sz=i;\\n                break;\\n            }\\n            prefix+=nums[i];\\n        }\\n    //    cout<<\"sz=\"<<sz<<\", prefix=\"<<prefix<<endl;\\n        \\n        if (sz==n && prefix<x) //impossible\\n            return -1;\\n\\n        prefix-=nums[sz-1];// let prefix<=x\\n        int idx=sz-1;\\n        int ans=INT_MAX;\\n        if (idx>=0 && prefix==x) ans=sz-1;\\n\\n        int suffix=0;\\n\\n        for (int j=n-1; j >= 0; j--) {\\n            suffix+=nums[j];\\n            while (suffix+prefix>x && prefix>0){\\n                idx--;\\n                prefix-=nums[idx];\\n                if (suffix+prefix <= x) break;\\n            }\\n            if (suffix+prefix==x){\\n                ans=min(ans, (n-j)+idx);\\n            //    cout<<(n-j)<<\" idx=\"<<idx<<\" ,\"<<(n-j)+idx<<endl;\\n            }\\n            if (suffix>=x) break;\\n        }\\n\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```[3,2,20,1,1,3], x=10 ```\n```\\nsz=3, prefix=25\\nx=10 ans=2147483647\\nprefix=5\\nj=5 suffix=3 prefix=5 idx=2\\nj=4 suffix=4 prefix=5 idx=2\\nupdate  ans=5\\nj=3 suffix=5 prefix=5 idx=2\\nj=2 suffix=25 prefix=0 idx=0\\n```\n```[1,1,4,2,3] x=5 ```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> prefix={nums[0]};\\n        for(int i=1; i<n; i++){\\n        //    cout<<prefix[i-1]<<endl;\\n            if (prefix[i-1]>=x) break;\\n            prefix.push_back(prefix[i-1]+nums[i]);\\n        }\\n        int sz=prefix.size();\\n    //    cout<<\"sz=\"<<sz<<endl;\\n        int idx=lower_bound(prefix.begin(), prefix.end(), x)-prefix.begin();\\n        int ans=INT_MAX;\\n        if (idx!=sz && prefix[idx]==x){\\n            ans=idx+1;\\n        //    cout<<\"x=\"<<x<<\" idx=\"<<idx<<\" ans=\"<<ans<<endl;\\n        }\\n        for(int j=n-1; j>=0; j--){\\n            x-=nums[j];\\n            if (x<0) break;\\n            if (x==0) ans=min(ans, (n-j));\\n            idx=lower_bound(prefix.begin(), prefix.end(), x)-prefix.begin();\\n            if (idx<j && prefix[idx]==x){//idx<j very important\\n            //    cout<<\"x=\"<<x<<\" idx=\"<<idx<<\" ans=\"<<idx+(n-j)+1<<endl;\\n                ans=min(ans, idx+1+(n-j));\\n            } \\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<int> prefix = {nums[0]}; // Initialize a prefix sum array with the first element of nums.\\n\\n        for (int i = 1; i < n; i++) {\\n            // Calculate the prefix sum for each element in nums.\\n            if (prefix[i - 1] >= x) break; // If the sum exceeds x, exit the loop.\\n            prefix.push_back(prefix[i - 1] + nums[i]);\\n        }\\n\\n        int sz = prefix.size(); // Get the size of the prefix sum array.\\n\\n        int idx = lower_bound(prefix.begin(), prefix.end(), x) - prefix.begin(); // Find the index of x in the prefix sum array.\\n\\n        int ans = INT_MAX; // Initialize ans to a large value.\\n\\n        if (idx != sz && prefix[idx] == x) {\\n            ans = idx + 1; // If x is found in the prefix sum array, update ans.\\n        }\\n\\n        for (int j = n - 1; j >= 0; j--) {\\n            x -= nums[j]; // Subtract the current element from x.\\n\\n            if (x < 0) break; // If x becomes negative, exit the loop.\\n\\n            if (x == 0) ans = min(ans, (n - j)); // If x becomes zero, update ans with the length of the subarray.\\n\\n            idx = lower_bound(prefix.begin(), prefix.end(), x) - prefix.begin(); // Find the index of x in the prefix sum array.\\n\\n            if (idx < j && prefix[idx] == x) {\\n                // If x is found before the current element in the prefix sum array, update ans.\\n                ans = min(ans, idx + 1 + (n - j));\\n            }\\n        }\\n\\n        return ans == INT_MAX ? -1 : ans; // If ans is still the initial large value, return -1; otherwise, return ans.\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int prefix=nums[0]; // Initialize the prefix sum with the first element.\\n        unordered_map<int, int> mp={{prefix, 0}};\\n        int ans = INT_MAX;\\n\\n        for (int i=1; i < n; i++) {\\n            prefix+=nums[i];\\n            if (prefix>x) break;\\n            mp[prefix]=i;   \\n        }\\n    //    for (auto [k, v]: mp)\\n    //       cout<<k<<\"->\"<<v<<endl;\\n\\n        if (mp.count(x)) ans=mp[x]+1;\\n    //    cout<<\"x=\"<<x<<\" idx=\"<<ans-1<<\" ans=\"<<ans<<endl;\\n\\n        for (int j=n-1; j >= 0; j--) {\\n            x-=nums[j];\\n            if (x<0) break;\\n            if (x==0) ans=min(ans, (n-j));\\n            int idx=-1;\\n            if (mp.count(x) && (idx=mp[x])<j) {\\n            //    cout<<\"x=\"<<x<<\" idx=\"<<idx<<\" ans=\"<<idx+(n-j)+1<<endl;\\n                ans=min(ans, idx+1+(n-j));\\n            }\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        int prefix=nums[0];\\n        int sz=n;\\n        for(int i=1; i<n; i++){\\n//          cout<<prefix<<endl;\\n            if (prefix>x) {\\n                sz=i;\\n                break;\\n            }\\n            prefix+=nums[i];\\n        }\\n    //    cout<<\"sz=\"<<sz<<\", prefix=\"<<prefix<<endl;\\n        \\n        if (sz==n && prefix<x) //impossible\\n            return -1;\\n\\n        prefix-=nums[sz-1];// let prefix<=x\\n        int idx=sz-1;\\n        int ans=INT_MAX;\\n        if (idx>=0 && prefix==x) ans=sz-1;\\n\\n        int suffix=0;\\n\\n        for (int j=n-1; j >= 0; j--) {\\n            suffix+=nums[j];\\n            while (suffix+prefix>x && prefix>0){\\n                idx--;\\n                prefix-=nums[idx];\\n                if (suffix+prefix <= x) break;\\n            }\\n            if (suffix+prefix==x){\\n                ans=min(ans, (n-j)+idx);\\n            //    cout<<(n-j)<<\" idx=\"<<idx<<\" ,\"<<(n-j)+idx<<endl;\\n            }\\n            if (suffix>=x) break;\\n        }\\n\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1017206,
                "title": "python-sliding-window-using-maxlen-of-continuous-subarray-concept",
                "content": "Idea is to do using continous subarray with max length size which return continous subarray length. The elements that are not included in the subarray (exterior to it) is the ans. So, in this case len(nums) - maxLen of continous subarray.\\nNow x is actually sum of exterior, to do continous subarray we need total sum - x (exclude x sum)\\n\\n```\\nclass Solution(object):\\n    def minOperations(self, nums, x):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        maxLen = total = windowStart = 0\\n        targetSum = sum(nums)\\n        \\n        # edge cases\\n        if targetSum < x: return -1\\n        if targetSum == x: return len(nums)\\n        \\n        # opposite of sliding window but still do sliding window\\n        # so instead of find continous subarray,\\n        # we need to find outer points that is not included in continous subarray\\n        k = targetSum - x # this is for continous subarray\\n        \\n        for windowEnd in range(len(nums)):\\n            total += nums[windowEnd]\\n            \\n            while total > k:\\n                total -= nums[windowStart]\\n                windowStart += 1\\n            \\n            if total == k:\\n                maxLen = max(maxLen, windowEnd - windowStart + 1)\\n    \\n        \\n        return len(nums) - maxLen if maxLen != 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, nums, x):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        maxLen = total = windowStart = 0\\n        targetSum = sum(nums)\\n        \\n        # edge cases\\n        if targetSum < x: return -1\\n        if targetSum == x: return len(nums)\\n        \\n        # opposite of sliding window but still do sliding window\\n        # so instead of find continous subarray,\\n        # we need to find outer points that is not included in continous subarray\\n        k = targetSum - x # this is for continous subarray\\n        \\n        for windowEnd in range(len(nums)):\\n            total += nums[windowEnd]\\n            \\n            while total > k:\\n                total -= nums[windowStart]\\n                windowStart += 1\\n            \\n            if total == k:\\n                maxLen = max(maxLen, windowEnd - windowStart + 1)\\n    \\n        \\n        return len(nums) - maxLen if maxLen != 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067729,
                "title": "java-beats-99-dp-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDp will give memory limit exceeded.\\nso we need to do it by sliding window\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need a {  subarray of sum  }  as \\ntarget = total sum - x\\nthen max subarray sum of target \\nto get min operation on x\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->   \\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n- Dp\\n```\\n class Solution {\\n     public int minOperations(int[] nums, int x) {\\n         int n = nums.length;\\n         int dp[][] = new int [n+1][n+1];\\n\\n         for(int [] arr : dp)Arrays.fill(arr,-1);\\n\\n         int temp = helper(nums,x,0,n-1,n,dp);\\n\\n         return temp == 1000000 ? -1:temp;\\n     }\\n     public int helper(int[] nums,int x,int i,int j,int n,int dp[][]){\\n         if(x == 0)return 0;\\n         if(i > j || i >= n || j < 0 || x < 0){\\n             return 1000000;\\n         }\\n         if(dp[i][j] != -1)return dp[i][j];\\n\\n         int ans = 1000000;\\n         ans = Math.min(ans,1+helper(nums,x-nums[i],i+1,j,n,dp));\\n         ans = Math.min(ans,1+helper(nums,x-nums[j],i,j-1,n,dp));\\n         return dp[i][j] = ans;\\n     }\\n }\\n```\\n# Code\\n- Sliding Window\\n```\\nclass Solution {\\n    public int minOperations(int [] nums,int x){\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i : nums)sum += i;\\n        int target = sum - x;\\n        int j = 0;\\n        int min = Integer.MIN_VALUE;\\n        sum = 0;\\n        for(int i = 0;i < n; i++){\\n            sum += nums[i];\\n            while(j <= i && sum > target){\\n                sum -= nums[j];\\n                j++;\\n            }\\n            if(sum == target){\\n                min = Math.max(min,i-j+1);\\n            }\\n        }\\n        if(min == Integer.MIN_VALUE)return -1;\\n        return n-min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\n class Solution {\\n     public int minOperations(int[] nums, int x) {\\n         int n = nums.length;\\n         int dp[][] = new int [n+1][n+1];\\n\\n         for(int [] arr : dp)Arrays.fill(arr,-1);\\n\\n         int temp = helper(nums,x,0,n-1,n,dp);\\n\\n         return temp == 1000000 ? -1:temp;\\n     }\\n     public int helper(int[] nums,int x,int i,int j,int n,int dp[][]){\\n         if(x == 0)return 0;\\n         if(i > j || i >= n || j < 0 || x < 0){\\n             return 1000000;\\n         }\\n         if(dp[i][j] != -1)return dp[i][j];\\n\\n         int ans = 1000000;\\n         ans = Math.min(ans,1+helper(nums,x-nums[i],i+1,j,n,dp));\\n         ans = Math.min(ans,1+helper(nums,x-nums[j],i,j-1,n,dp));\\n         return dp[i][j] = ans;\\n     }\\n }\\n```\n```\\nclass Solution {\\n    public int minOperations(int [] nums,int x){\\n        int n = nums.length;\\n        int sum = 0;\\n        for(int i : nums)sum += i;\\n        int target = sum - x;\\n        int j = 0;\\n        int min = Integer.MIN_VALUE;\\n        sum = 0;\\n        for(int i = 0;i < n; i++){\\n            sum += nums[i];\\n            while(j <= i && sum > target){\\n                sum -= nums[j];\\n                j++;\\n            }\\n            if(sum == target){\\n                min = Math.max(min,i-j+1);\\n            }\\n        }\\n        if(min == Integer.MIN_VALUE)return -1;\\n        return n-min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136891,
                "title": "c-full-explanation-simple-sliding-window-why-dp-won-t-work-here-explanation",
                "content": "class Solution {\\npublic:\\n    \\n\\t// We can do this question with the help of DP concept of take from front and back and return minimum of the operation but in that case it will give TLE \\n\\t// and here we are not able to optimize due to high constraints 1<=x<=10^9.\\n\\t// That is why sliding window works here, So we find total sum and subtract x from it now we have to find the maximum window in which (totalSum-x) come \\n\\t// and satisfy so totalLength-maxWindow of (TotalSum-x) will give minimum operation in which we get x to become zero.\\n\\t// So this is the the approach i do here.\\n\\t//PLZ UPVOTE IF YOU LIKE THE POST :)\\n\\t\\n\\tint minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int t = 0;\\n        for(auto x:nums) t+=x;\\n        t-=x;\\n        if(t==0) return n;\\n        if(t<0) return -1;\\n        int i = 0,j = 0,sum = 0,c = -1;\\n        while(j<n){\\n            sum+=nums[j];\\n            while(sum>t){\\n                sum-=nums[i];\\n                i++;\\n            }\\n            if(sum==t){\\n                c = max(c,j-i+1);\\n            }\\n            j++;\\n        }\\n        return (c==-1)?-1:n-c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\t// We can do this question with the help of DP concept of take from front and back and return minimum of the operation but in that case it will give TLE \\n\\t// and here we are not able to optimize due to high constraints 1<=x<=10^9.\\n\\t// That is why sliding window works here, So we find total sum and subtract x from it now we have to find the maximum window in which (totalSum-x) come \\n\\t// and satisfy so totalLength-maxWindow of (TotalSum-x) will give minimum operation in which we get x to become zero.\\n\\t// So this is the the approach i do here.\\n\\t//PLZ UPVOTE IF YOU LIKE THE POST :)\\n\\t\\n\\tint minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int t = 0;\\n        for(auto x:nums) t+=x;\\n        t-=x;\\n        if(t==0) return n;\\n        if(t<0) return -1;\\n        int i = 0,j = 0,sum = 0,c = -1;\\n        while(j<n){\\n            sum+=nums[j];\\n            while(sum>t){\\n                sum-=nums[i];\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2136682,
                "title": "c-prefix-sum-hashmap-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        const int n = nums.size();\\n        int ans = INT_MAX, sum = 0;\\n        unordered_map<int,int> m;\\n        for(int i = n - 1;i >=0;i--) {\\n            sum += nums[i];\\n            m[sum] = i + 1;\\n            if(sum == x) ans = min(ans,n - i);\\n        }\\n        sum = 0;\\n        for(int i = 0;i<n;i++){\\n            sum += nums[i];\\n            if(sum == x) ans = min(ans,i + 1);\\n            if(m[x-sum] != 0 && m[x-sum] - 1> i) ans = min(ans,i + n - m[x - sum] + 2);\\n        }\\n        return ans == INT_MAX?-1:ans;\\n    }\\n};\\n```\\n### UPVOTE IF YOU LIKE",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        const int n = nums.size();\\n        int ans = INT_MAX, sum = 0;\\n        unordered_map<int,int> m;\\n        for(int i = n - 1;i >=0;i--) {\\n            sum += nums[i];\\n            m[sum] = i + 1;\\n            if(sum == x) ans = min(ans,n - i);\\n        }\\n        sum = 0;\\n        for(int i = 0;i<n;i++){\\n            sum += nums[i];\\n            if(sum == x) ans = min(ans,i + 1);\\n            if(m[x-sum] != 0 && m[x-sum] - 1> i) ans = min(ans,i + n - m[x - sum] + 2);\\n        }\\n        return ans == INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136561,
                "title": "python-prefix-sum-sliding-window-with-explanation",
                "content": "Detailed Explanation:\\n1. Idea: the aim of this question is to find the minimum operations to reduce `x` to 0, i.e. find the minimum number of elements from the start and end that can sum up to `x`. We can transform this problem to: **find the longest subarray in `nums` that sum to `goal`**, where `goal = sum(nums) - x`.\\n\\n2. Solution: use a silding window, both `left` and `right` edge start from index `0`. Store the `current_sum` in the current window. If the `current_sum > goal` we move the `left` edge one step to right. If the `current_sum = goal`, update the `max_length`.\\n\\n3. Note: this solution works because **in this problem all the numbers are positive** !\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        # find the longest subarray that sum to \\'goal\\'\\n        s = sum(nums)\\n        n = len(nums)\\n        goal = s - x\\n        max_length = -1\\n        left = 0\\n        current_sum = 0\\n\\n        for right, num in enumerate(nums):\\n            current_sum += num\\n            # if larger, move `left` to right\\n            while current_sum > goal and left <= right:\\n                current_sum -= nums[left]\\n                left += 1\\n            # check if equal\\n            if current_sum == goal:\\n                max_length = max(max_length, right-left+1)\\n\\n        return n - max_length if max_length != -1 else -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "Detailed Explanation:\\n1. Idea: the aim of this question is to find the minimum operations to reduce `x` to 0, i.e. find the minimum number of elements from the start and end that can sum up to `x`. We can transform this problem to: **find the longest subarray in `nums` that sum to `goal`**, where `goal = sum(nums) - x`.\\n\\n2. Solution: use a silding window, both `left` and `right` edge start from index `0`. Store the `current_sum` in the current window. If the `current_sum > goal` we move the `left` edge one step to right. If the `current_sum = goal`, update the `max_length`.\\n\\n3. Note: this solution works because **in this problem all the numbers are positive** !\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        # find the longest subarray that sum to \\'goal\\'\\n        s = sum(nums)\\n        n = len(nums)\\n        goal = s - x\\n        max_length = -1\\n        left = 0\\n        current_sum = 0\\n\\n        for right, num in enumerate(nums):\\n            current_sum += num\\n            # if larger, move `left` to right\\n            while current_sum > goal and left <= right:\\n                current_sum -= nums[left]\\n                left += 1\\n            # check if equal\\n            if current_sum == goal:\\n                max_length = max(max_length, right-left+1)\\n\\n        return n - max_length if max_length != -1 else -1",
                "codeTag": "Java"
            },
            {
                "id": 1017183,
                "title": "javascript-simple-prefix-sum-sliding-window-solution-w-explanation-beats-100-94",
                "content": "***Idea:***\\n\\nThis problem is tasking us to essentially find when the sum of the starting and ending subarrays of **nums** is equal to **x**. Put another way, it\\'s asking us to find when any subarray of consecutive elements in **nums** is equal to the sum of all elements in **nums** minus **x**.\\n```\\n               <-A->   <------ B ------>   <-C->\\n       nums = [1,  1,  1,  1,  1,  1,  1,  1,  1]\\n\\t   \\n\\t   if      sum(A) + sum(C) = x\\n\\t   then    x = sum(nums) - sum(B)\\n```\\nSo now we need to find any consecutive subarray of **nums** whose sum is equal to a specific value. Any time you\\'re talking about checking the sum of a consecutive subarray, it should naturally bring to mind the use of a **prefix sum array**.\\n\\nThe sum of any consecutive subarray, **i** to **j**, of **nums** can be defined as the sum of all elements of **nums** up to **j** minus the sum of all the elements of **nums** *before* **i**. This is aided by creating a prefix sum array containing the running sum of elements in **nums**.\\n```\\n\\t\\t\\t   <------ A ------>\\n               <-B->\\n\\t\\t\\t           <-- C -->\\n       nums = [1,  1,  1,  1,  1,  1,  1,  1,  1]\\n\\t\\t\\t\\t\\t   i       j\\n  prefixSum = [1,  2,  3,  4,  5,  6,  7,  8,  9]\\n\\t   \\n\\t   if      prefixSum[n] = sum(nums[0] to nums[n])\\n\\t   and     sum(A) = prefixSum[j]\\n\\t   and     sum(B) = prefixSum[i-1]\\n\\t   then    sum(C) = prefixSum[j] - prefixSum[i-1]\\n```\\n\\nUsing a prefix sum array, we can then use a **2-pointer** **sliding window** to evaluate which subarrays have the specified value and keep track of which one has the largest subarray size. The answer, if possible, will be its difference from **nums.length**.\\n\\nThe best result for the code below is **92ms / 50.2MB**.\\n\\n` `\\n***Implementation:***\\n\\nThe prefix sum array is simple to achieve; we just iterate through **nums** and make each **i**th element of the prefix sum array the sum of **nums[0]** through **nums[i]** by taking the previous value (**nums[i-1]**) and adding **nums[i]** to it. Since we don\\'t need the individual elements of **nums** after this, we can run the conversion in place.\\n\\n(***Note**: Normally in a prefix sum array you will want to add a leading **0** to the array as the equation for a subarray starting with **i = 0** will lead to an **nums[i-1]** value outside the range of **nums**. In this instance, however, we can handle the issue more efficiently later.*)\\n\\nOnce **nums** has been updated, the last element **nums[len-1]** will equal the total sum of **nums**. This means that we\\'ll be looking for a subarray of nums that sums to **nums[len-1] - x**, or **y**. If **y** is negative, then there exists no possibility for a solution, since all elements of **nums** are positive integers, so we can **return -1**. If **y** is **0**, then the only possible solution is the entire **nums** array, so we can **return len**.\\n\\nOtherwise, we can use **i** and **j** as two pointers to form a sliding window of **nums**. While we iterate, we should keep track of the size (**best**) of the largest successful subarray. If at any time during the iteration, **i** moves far enough that no remaining subarray can beat **best**, or if **nums[i]** is already larger than **x**, then we should force an end. Starting with **best = 0** means that **i** should move all the way to **len** if no matches are found.\\n\\nSince we\\'ll be using **nums[i]** a number of times, we can store it in **l**, representing the left endpoint value sum. Setting the initial value of **l** to **0** and only updating it to be based off **nums[i]** *after* the first iteration will allow us to avoid needing to **unshift()** a **0** onto the prefix sum array beforehand.\\n\\nThen, during each iteration, we\\'ll move **j** up as long as the subarray sum (**nums[j] - l**) is less than **y**. If the sliding window has stopped on a subarray that equals **y**, then we update **best** if necessary.\\n\\nSince **best** represents the largest subarray length, we actually want to **return len - best**, but if no match was ever found (**best > 0**), then we should **return -1** instead.\\n\\n` `\\n***Code:***\\n```\\nvar minOperations = function(nums, x) {\\n    let len = nums.length, best = 0\\n    for (let i = 1; i < len; i++) nums[i] += nums[i-1]\\n    let y = nums[len-1] - x\\n    if (y < 0) return -1\\n    if (y === 0) return len\\n    for (let i = -1, j = l = 0; i < len - best && l <= x; l = nums[++i]) {\\n        while (nums[j] - l < y) j++\\n        if (nums[j] - l === y) best = Math.max(best, j - i)\\n    }\\n    return best > 0 ? len - best : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n               <-A->   <------ B ------>   <-C->\\n       nums = [1,  1,  1,  1,  1,  1,  1,  1,  1]\\n\\t   \\n\\t   if      sum(A) + sum(C) = x\\n\\t   then    x = sum(nums) - sum(B)\\n```\n```\\n\\t\\t\\t   <------ A ------>\\n               <-B->\\n\\t\\t\\t           <-- C -->\\n       nums = [1,  1,  1,  1,  1,  1,  1,  1,  1]\\n\\t\\t\\t\\t\\t   i       j\\n  prefixSum = [1,  2,  3,  4,  5,  6,  7,  8,  9]\\n\\t   \\n\\t   if      prefixSum[n] = sum(nums[0] to nums[n])\\n\\t   and     sum(A) = prefixSum[j]\\n\\t   and     sum(B) = prefixSum[i-1]\\n\\t   then    sum(C) = prefixSum[j] - prefixSum[i-1]\\n```\n```\\nvar minOperations = function(nums, x) {\\n    let len = nums.length, best = 0\\n    for (let i = 1; i < len; i++) nums[i] += nums[i-1]\\n    let y = nums[len-1] - x\\n    if (y < 0) return -1\\n    if (y === 0) return len\\n    for (let i = -1, j = l = 0; i < len - best && l <= x; l = nums[++i]) {\\n        while (nums[j] - l < y) j++\\n        if (nums[j] - l === y) best = Math.max(best, j - i)\\n    }\\n    return best > 0 ? len - best : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016297,
                "title": "python-find-the-longest-window",
                "content": "Essentially we\\'re looking to remove the longest sequence of numbers so that what\\'s left is equal to `x`. \\nReformulating the problem this way it becomes a classic window sliding problem. \\nComplexity Time: O(N), Memory: O(1) \\n```\\ndef minOperations(self, nums: List[int], x: int) -> int:\\n\\tN = len(nums)\\n\\ttoremove = sum(nums) - x\\n\\tif toremove < 0: return -1\\n\\n\\tlongest_removal = -1\\n\\tleft = 0\\n\\tfor right in range(N):\\n\\t\\ttoremove -= nums[right]\\n\\t\\twhile toremove < 0:\\n\\t\\t\\ttoremove += nums[left]\\n\\t\\t\\tleft += 1\\n\\t\\tif toremove == 0:\\n\\t\\t\\tlongest_removal = max(longest_removal, right - left + 1)\\n\\n\\treturn N - longest_removal if longest_removal != -1 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\ndef minOperations(self, nums: List[int], x: int) -> int:\\n\\tN = len(nums)\\n\\ttoremove = sum(nums) - x\\n\\tif toremove < 0: return -1\\n\\n\\tlongest_removal = -1\\n\\tleft = 0\\n\\tfor right in range(N):\\n\\t\\ttoremove -= nums[right]\\n\\t\\twhile toremove < 0:\\n\\t\\t\\ttoremove += nums[left]\\n\\t\\t\\tleft += 1\\n\\t\\tif toremove == 0:\\n\\t\\t\\tlongest_removal = max(longest_removal, right - left + 1)\\n\\n\\treturn N - longest_removal if longest_removal != -1 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 936100,
                "title": "c-java-2-pointer-o-n-solutions",
                "content": "It is easy to observe that in order to find the shortest required operations that sum up to *x* is finding the longest subarray that sums up to *total - x*. \\n\\n**Approach 1 Find the longest subarray sum equals to a target value:**\\n\\n**C++**\\n```\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total = 0;\\n        for (int num : nums) {\\n            total += num;\\n        }\\n        int n = nums.size();\\n        int maxi = -1;\\n        int left = 0;\\n        int current = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            current += nums[right];  // sum([left ,..., right]) = total - x\\n            while (current > total - x && left <= right) {\\n                current -= nums[left];\\n                left += 1; / if larger, move to left\\n            }\\n            if (current == total - x) { // check if they are equal\\n                maxi = max(maxi, right - left + 1);\\n            }\\n        }\\n        return maxi != -1 ? n - maxi : -1;\\n    }\\n```\\n\\n**Java**\\n```\\n    public int minOperations(int[] nums, int x) {\\n        int total = 0;\\n        for (int num : nums) {\\n            total += num;\\n        }\\n        int n = nums.length;\\n        int maxi = -1;\\n        int left = 0;\\n        int current = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            current += nums[right]; // sum([left ,..., right]) = total - x\\n            while (current > total - x && left <= right) { \\n                current -= nums[left];\\n                left += 1; // if larger, move to left\\n            }\\n            if (current == total - x) { // check they are equal\\n                maxi = Math.max(maxi, right - left + 1);\\n            }\\n        }\\n        return maxi != -1 ? n - maxi : -1;\\n    }\\n```\\n\\n**Approach 2 Use 2-pointer technique directly:**\\n\\nWe can also solve this problem directly without a transition by \\n1. Sum up the *nums* array\\n2. Set 2 pointers *left* and *right* to 0. Initialize an int *cur* to represent the sum from nums[0] to nums[left-1] and from nums[right+1] to nums[last]. Initialize an int *min* to record the minimum length that sums up to x\\n3. While (right < nums.length) \\n\\t- Calculate *cur*.\\n\\t- If *cur* is smaller than *x*, move left to left.\\n\\t- If *cur* is equal to *x*, update the *min*.\\n\\n**C++**\\n```\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int current = 0;\\n        for (int num : nums) {\\n            current += num;\\n        }\\n        int n = nums.size();\\n        int mini = INT_MAX;\\n        int left = 0;\\n        for (int right = 0; right < n; right++) {\\n            current -= nums[right];\\n            while (current < x && left <= right) {\\n                current += nums[left];\\n                left += 1;\\n            }\\n            if (current == x) {\\n                mini = min(mini, (n - 1 - right) + left);\\n            }\\n        }\\n        return mini != INT_MAX ? mini : -1;\\n    }\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int current = 0;\\n        for (int num : nums) {\\n            current += num;\\n        }\\n        int n = nums.length;\\n        int mini = Integer.MAX_VALUE;\\n        int left = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            current -= nums[right];\\n            while (current < x && left <= right) {\\n                current += nums[left];\\n                left += 1;\\n            }\\n            if (current == x) {\\n                mini = Math.min(mini, (n-1-right)+left);\\n            }\\n        }\\n        return mini != Integer.MAX_VALUE ? mini : -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total = 0;\\n        for (int num : nums) {\\n            total += num;\\n        }\\n        int n = nums.size();\\n        int maxi = -1;\\n        int left = 0;\\n        int current = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            current += nums[right];  // sum([left ,..., right]) = total - x\\n            while (current > total - x && left <= right) {\\n                current -= nums[left];\\n                left += 1; / if larger, move to left\\n            }\\n            if (current == total - x) { // check if they are equal\\n                maxi = max(maxi, right - left + 1);\\n            }\\n        }\\n        return maxi != -1 ? n - maxi : -1;\\n    }\\n```\n```\\n    public int minOperations(int[] nums, int x) {\\n        int total = 0;\\n        for (int num : nums) {\\n            total += num;\\n        }\\n        int n = nums.length;\\n        int maxi = -1;\\n        int left = 0;\\n        int current = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            current += nums[right]; // sum([left ,..., right]) = total - x\\n            while (current > total - x && left <= right) { \\n                current -= nums[left];\\n                left += 1; // if larger, move to left\\n            }\\n            if (current == total - x) { // check they are equal\\n                maxi = Math.max(maxi, right - left + 1);\\n            }\\n        }\\n        return maxi != -1 ? n - maxi : -1;\\n    }\\n```\n```\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int current = 0;\\n        for (int num : nums) {\\n            current += num;\\n        }\\n        int n = nums.size();\\n        int mini = INT_MAX;\\n        int left = 0;\\n        for (int right = 0; right < n; right++) {\\n            current -= nums[right];\\n            while (current < x && left <= right) {\\n                current += nums[left];\\n                left += 1;\\n            }\\n            if (current == x) {\\n                mini = min(mini, (n - 1 - right) + left);\\n            }\\n        }\\n        return mini != INT_MAX ? mini : -1;\\n    }\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int current = 0;\\n        for (int num : nums) {\\n            current += num;\\n        }\\n        int n = nums.length;\\n        int mini = Integer.MAX_VALUE;\\n        int left = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            current -= nums[right];\\n            while (current < x && left <= right) {\\n                current += nums[left];\\n                left += 1;\\n            }\\n            if (current == x) {\\n                mini = Math.min(mini, (n-1-right)+left);\\n            }\\n        }\\n        return mini != Integer.MAX_VALUE ? mini : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445840,
                "title": "c-o-1-space-faster-than-97-contiguous-subarray-sum-unique-approach",
                "content": "**Explanantion**\\n* **Step 1** - Find the ***SUM*** of whole array. \\n* **Step 2** - Then, Subtract the given element from the total ***SUM***.\\n* **Step 3** - Now, All we have to do is take a left and right pointer traverse through the array and find Contiguous subarrays sum (i.e include all elements from left to right pointer in the sum ) that equal to our previous ***SUM*** that we calculated this can be easily done using if and else blocks. If curr_sum is less than ***SUM*** then add right element and increment right. if curr_sum is greater than the ***SUM*** then decrese left element and increment left. And if curr_sum == ***SUM*** then update ans =  min(ans, n - (right - left)).\\n* **Step 4** - If there is no Contiguous subarray whose sum equal to ***SUM*** that means it is not possible to make X from this subarray by picking element from left and right. So, return -1. else return ans\\n\\n**Complexity - O(N) Time | O(1) Space**\\n\\n**Code - C++**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int a:nums)\\n            sum += a; // Adding all elements from array \\n        sum -= x;  // Basically we have to find Contiguous elements which sum to this\\n\\t\\t\\n        int left = 0, right = 0;\\n        int curr_sum = 0, ans = INT_MAX;\\n        while(right <= n && left <= right){\\n            if(curr_sum == sum){\\n                ans = min(ans, n - (right - left));\\n                curr_sum -= nums[left];\\n                left++;\\n                continue;\\n            }\\n            if(curr_sum < sum){\\n                curr_sum += nums[right];\\n                right++;\\n            }else if(curr_sum > sum){\\n                curr_sum -= nums[left];\\n                left++;\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n\\n***Thanks for Reading, Upvote if you like it :)***",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for(int a:nums)\\n            sum += a; // Adding all elements from array \\n        sum -= x;  // Basically we have to find Contiguous elements which sum to this\\n\\t\\t\\n        int left = 0, right = 0;\\n        int curr_sum = 0, ans = INT_MAX;\\n        while(right <= n && left <= right){\\n            if(curr_sum == sum){\\n                ans = min(ans, n - (right - left));\\n                curr_sum -= nums[left];\\n                left++;\\n                continue;\\n            }\\n            if(curr_sum < sum){\\n                curr_sum += nums[right];\\n                right++;\\n            }else if(curr_sum > sum){\\n                curr_sum -= nums[left];\\n                left++;\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016364,
                "title": "simple-solution-by-finding-the-longest-array-with-a-target-in-java",
                "content": "Essentially, we need to find the longest array with a sum of - (sum(array) - x). If we do find this, this might either be - \\n1. Starting from the left end: In this case, We will have found the answer which has minimum length from right\\n2. Somewhere in the middle: Will be a valid answer since we can pick elements from either sides\\n3. Starting from right end: Similar to 1\\n\\nWe find such a longest array and the answer will be length(array) - length of longest array as found earlier\\n\\nCode in Java - \\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int k) {\\n        int target = -1 * k;\\n        for(int e: nums){\\n            target += e;\\n        }\\n        \\n        if(target == 0){\\n            return nums.length;\\n        }\\n        if(target < 0){\\n            return -1;\\n        }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        int m = -1;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum == target){\\n                m = i + 1;\\n            }\\n            if(!map.containsKey(sum)){\\n                map.put(sum, i);\\n            }\\n            if(map.containsKey(sum - target)){\\n                if(m < (i - map.get(sum - target))){\\n                    m = i - map.get(sum - target);\\n                }\\n            }\\n        }\\n        return m != -1 ? nums.length - m : m;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int k) {\\n        int target = -1 * k;\\n        for(int e: nums){\\n            target += e;\\n        }\\n        \\n        if(target == 0){\\n            return nums.length;\\n        }\\n        if(target < 0){\\n            return -1;\\n        }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        int m = -1;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum == target){\\n                m = i + 1;\\n            }\\n            if(!map.containsKey(sum)){\\n                map.put(sum, i);\\n            }\\n            if(map.containsKey(sum - target)){\\n                if(m < (i - map.get(sum - target))){\\n                    m = i - map.get(sum - target);\\n                }\\n            }\\n        }\\n        return m != -1 ? nums.length - m : m;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937138,
                "title": "python-clear-two-pointers-solution-with-video-explanation",
                "content": "Video with clear visualization and explanation:\\nhttps://youtu.be/kRHZdzYYn50\\n\\n\\nIntuition: Two Pointers\\n\\n\\n**Code**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target = sum(nums)-x\\n        n = len(nums)\\n\\n        if target < 0: return -1\\n        if target == 0: return n\\n        \\n        left = 0; cur_sum = 0; n_target = -1\\n        \\n        for i in range(n):\\n            if cur_sum < target:\\n                cur_sum += nums[i]\\n            while cur_sum >= target:\\n                if cur_sum == target:\\n                    n_target = max(n_target, i-left+1)\\n                cur_sum -= nums[left]\\n                left += 1\\n        \\n        return n-n_target if n_target != -1 else -1\\n```\\n\\nTime: O(n)\\nSpace: O(1)\\n\\nFeel free to subscribe to my channel. More LeetCoding videos coming up!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target = sum(nums)-x\\n        n = len(nums)\\n\\n        if target < 0: return -1\\n        if target == 0: return n\\n        \\n        left = 0; cur_sum = 0; n_target = -1\\n        \\n        for i in range(n):\\n            if cur_sum < target:\\n                cur_sum += nums[i]\\n            while cur_sum >= target:\\n                if cur_sum == target:\\n                    n_target = max(n_target, i-left+1)\\n                cur_sum -= nums[left]\\n                left += 1\\n        \\n        return n-n_target if n_target != -1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936057,
                "title": "c-prefix-sum-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        if(nums.size() == 1){\\n            if(x == nums[0])\\n                return 1;\\n            return -1;\\n        }\\n        if(nums[0] > x && nums[nums.size() -1] > x)\\n            return -1;\\n        \\n        vector<long long> presum(nums.size()+1,0);\\n        \\n        presum[0] = 0;\\n        for(int i=1;i<=nums.size();i++){\\n            presum[i] = presum[i-1] + nums[i-1];\\n        }\\n        int ans = nums.size()+1;\\n        \\n        long long end_sum = 0;\\n        int end_elements = 0;\\n        int j = nums.size()-1;\\n        while(j>=0){\\n            if(binary_search(presum.begin(),presum.end(),x-end_sum)){\\n                int id = lower_bound(presum.begin(),presum.end(),x-end_sum) - presum.begin();\\n                if(id+end_elements <= nums.size()){\\n                    ans = min(ans,id+end_elements);\\n                }\\n            }\\n            end_elements++;\\n            \\n            end_sum += nums[j--];\\n            \\n        }\\n       \\n        if(ans == nums.size()+1)\\n            return -1;\\n        else return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        if(nums.size() == 1){\\n            if(x == nums[0])\\n                return 1;\\n            return -1;\\n        }\\n        if(nums[0] > x && nums[nums.size() -1] > x)\\n            return -1;\\n        \\n        vector<long long> presum(nums.size()+1,0);\\n        \\n        presum[0] = 0;\\n        for(int i=1;i<=nums.size();i++){\\n            presum[i] = presum[i-1] + nums[i-1];\\n        }\\n        int ans = nums.size()+1;\\n        \\n        long long end_sum = 0;\\n        int end_elements = 0;\\n        int j = nums.size()-1;\\n        while(j>=0){\\n            if(binary_search(presum.begin(),presum.end(),x-end_sum)){\\n                int id = lower_bound(presum.begin(),presum.end(),x-end_sum) - presum.begin();\\n                if(id+end_elements <= nums.size()){\\n                    ans = min(ans,id+end_elements);\\n                }\\n            }\\n            end_elements++;\\n            \\n            end_sum += nums[j--];\\n            \\n        }\\n       \\n        if(ans == nums.size()+1)\\n            return -1;\\n        else return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935975,
                "title": "convert-to-calculate-longest-subarray-with-fixed-target-sum",
                "content": "Just convert to another question:\\nThe longest subarray with sum =  (sum of nums - x);\\n\\nThen the question is much easier. Just play the trick of calculating presum and store in map. \\nFor this type of question, please refer to leetcode 560:\\nhttps://leetcode.com/problems/subarray-sum-equals-k/\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        int target = sum - x;\\n\\t\\t\\n        // find the longest subarray that sums = target\\n        int presum = 0;\\n        int res = Integer.MIN_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1); // For the special case presum == target\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            presum += nums[i];\\n            if (!map.containsKey(presum)) map.put(presum, i); // Always store smallest index\\n            if (map.containsKey(presum - target)) {\\n                res = Math.max(res, i - map.get(presum - target));\\n            }\\n        }\\n        \\n        if (res == Integer.MIN_VALUE) return -1;\\n        return nums.length - res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        int target = sum - x;\\n\\t\\t\\n        // find the longest subarray that sums = target\\n        int presum = 0;\\n        int res = Integer.MIN_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1); // For the special case presum == target\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            presum += nums[i];\\n            if (!map.containsKey(presum)) map.put(presum, i); // Always store smallest index\\n            if (map.containsKey(presum - target)) {\\n                res = Math.max(res, i - map.get(presum - target));\\n            }\\n        }\\n        \\n        if (res == Integer.MIN_VALUE) return -1;\\n        return nums.length - res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935936,
                "title": "javascript-two-pointers-o-n",
                "content": "```\\nvar minOperations = function(nums, x) {\\n    let l = 0,\\n        r = nums.length-1,\\n        res = nums.length+1;\\n    \\n    let n = x;\\n    \\n    while (l <= r && n-nums[l] >= 0)\\n        n -= nums[l++];\\n    \\n    if (n === 0)\\n        res = l;\\n    \\n    while (l < r && l >= 0) {\\n        while (n-nums[r] >= 0)\\n            n -= nums[r--];\\n        \\n        if (n === 0)\\n            res = Math.min(res, l+nums.length-1-r);\\n        \\n        n += nums[--l];\\n    }\\n    \\n    return res === nums.length+1 ? -1 : res;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar minOperations = function(nums, x) {\\n    let l = 0,\\n        r = nums.length-1,\\n        res = nums.length+1;\\n    \\n    let n = x;\\n    \\n    while (l <= r && n-nums[l] >= 0)\\n        n -= nums[l++];\\n    \\n    if (n === 0)\\n        res = l;\\n    \\n    while (l < r && l >= 0) {\\n        while (n-nums[r] >= 0)\\n            n -= nums[r--];\\n        \\n        if (n === 0)\\n            res = Math.min(res, l+nums.length-1-r);\\n        \\n        n += nums[--l];\\n    }\\n    \\n    return res === nums.length+1 ? -1 : res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4072073,
                "title": "best-o-n-solution",
                "content": "# Approach\\nSliding Window Technique\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for (int i = 0; i < n; i++)\\n            sum += nums[i];\\n        sum -= x;\\n        if (sum == 0)\\n            return n;\\n        int start = 0, curSum = 0, len = 0;\\n        for (int end = 0; end < n; end++) {\\n            curSum += nums[end];\\n            while (start < n && curSum > sum) {\\n                curSum -= nums[start];\\n                start++;\\n            }\\n            if (curSum == sum)\\n                len = max (len, end - start + 1);\\n        }   \\n        if (!len) \\n            return -1;\\n        return n - len;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int sum = 0;\\n        for (int i = 0; i < n; i++)\\n            sum += nums[i];\\n        sum -= x;\\n        if (sum == 0)\\n            return n;\\n        int start = 0, curSum = 0, len = 0;\\n        for (int end = 0; end < n; end++) {\\n            curSum += nums[end];\\n            while (start < n && curSum > sum) {\\n                curSum -= nums[start];\\n                start++;\\n            }\\n            if (curSum == sum)\\n                len = max (len, end - start + 1);\\n        }   \\n        if (!len) \\n            return -1;\\n        return n - len;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139431,
                "title": "java-tc-100-beats-mc-95-beat-sliding-window",
                "content": "sum_total : totla sum of array.\\nwe need to find longest lenghted subarray which sums to (sum_total -x)\\n\\nwe can find the the largest lengthhed subarray using sliding window,\\nmove left pointer when the sum>=(required) otherwise keep on increasing right pointer\\n\\nAns. total_length - length of largest sub_array with sum as  (sum_total -x)\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int xx) {\\n        \\n        \\n        int x=0;\\n        for(int t:nums)\\n            x+=t;\\n        \\n        if(x==xx)\\n            return nums.length;\\n        \\n        x-=xx;\\n        \\n        int l=0;\\n        int sum=0;\\n        int ans=-1;\\n        \\n        \\n        // System.out.println(x);\\n        for(int r=0; r<nums.length;r++)\\n        {\\n            sum+=nums[r];\\n            // System.out.println(l+\"  \"+r+\"   \"+sum);\\n            \\n            while(sum>=x && l<=r)\\n            {\\n                if(sum==x)\\n                    ans=Math.max(ans, r-l+1);\\n                // System.out.println(\"in\"+ ans);\\n                sum-=nums[l++];\\n            }\\n        }\\n        \\n        if(ans==-1)\\n            return -1;\\n        return nums.length-ans;\\n        \\n    }\\n}\\n```\\nKindly upvote me if found helpful",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int xx) {\\n        \\n        \\n        int x=0;\\n        for(int t:nums)\\n            x+=t;\\n        \\n        if(x==xx)\\n            return nums.length;\\n        \\n        x-=xx;\\n        \\n        int l=0;\\n        int sum=0;\\n        int ans=-1;\\n        \\n        \\n        // System.out.println(x);\\n        for(int r=0; r<nums.length;r++)\\n        {\\n            sum+=nums[r];\\n            // System.out.println(l+\"  \"+r+\"   \"+sum);\\n            \\n            while(sum>=x && l<=r)\\n            {\\n                if(sum==x)\\n                    ans=Math.max(ans, r-l+1);\\n                // System.out.println(\"in\"+ ans);\\n                sum-=nums[l++];\\n            }\\n        }\\n        \\n        if(ans==-1)\\n            return -1;\\n        return nums.length-ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137920,
                "title": "c-easy-to-understand-prefix-sum-suffix-sum-binary-search-2-approaches",
                "content": "**Time Complexity O(NlogN)**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> pre(n,0);\\n        vector<int> suff(n,0);\\n        pre[0]=nums[0];\\n        suff[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suff[i]=suff[i+1]+nums[i];\\n        }\\n        int count=INT_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(suff[i]>x)\\n            {\\n                break;\\n            }\\n            if(suff[i]==x)\\n            {\\n                count=min(count,n-i);\\n            }\\n            else\\n            {\\n                int idx=lower_bound(pre.begin(),pre.end(),x-suff[i])-pre.begin();\\n                if(idx<i&&pre[idx]+suff[i]==x)\\n                {\\n                    count=min(count,idx+1+n-i);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre[i]>x)\\n            {\\n                break;\\n            }\\n            if(pre[i]==x)\\n            {\\n                count=min(count,i+1);\\n            }\\n        }\\n        return count==INT_MAX?-1:count;\\n    }\\n};\\n```\\n**Optimized Approach \\nTime Complexity O(N)**\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        int total=accumulate(nums.begin(),nums.end(),0);\\n        if(total==x)\\n        return n;\\n        if(x>total)\\n        return -1;\\n        unordered_map<int,int> mp;\\n        mp[0]=0;\\n        int target=total-x;\\n        int ans=INT_MIN;\\n        int curr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            curr+=nums[i];\\n            mp[curr]=i;\\n            \\n            if(curr==target)\\n            {\\n                ans=max(ans,i+1);\\n            }\\n            if(curr==(total-target))\\n            {\\n                ans=max(ans,n-i-1);\\n            }\\n            if(curr>target)\\n            {\\n                if(mp.find(curr-target)!=mp.end())\\n                {\\n                    ans=max(ans,i-mp[curr-target]);\\n                }\\n            }\\n        }\\n        return (ans==INT_MIN)?-1:(n-ans);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> pre(n,0);\\n        vector<int> suff(n,0);\\n        pre[0]=nums[0];\\n        suff[n-1]=nums[n-1];\\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suff[i]=suff[i+1]+nums[i];\\n        }\\n        int count=INT_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(suff[i]>x)\\n            {\\n                break;\\n            }\\n            if(suff[i]==x)\\n            {\\n                count=min(count,n-i);\\n            }\\n            else\\n            {\\n                int idx=lower_bound(pre.begin(),pre.end(),x-suff[i])-pre.begin();\\n                if(idx<i&&pre[idx]+suff[i]==x)\\n                {\\n                    count=min(count,idx+1+n-i);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre[i]>x)\\n            {\\n                break;\\n            }\\n            if(pre[i]==x)\\n            {\\n                count=min(count,i+1);\\n            }\\n        }\\n        return count==INT_MAX?-1:count;\\n    }\\n};\\n```\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        int total=accumulate(nums.begin(),nums.end(),0);\\n        if(total==x)\\n        return n;\\n        if(x>total)\\n        return -1;\\n        unordered_map<int,int> mp;\\n        mp[0]=0;\\n        int target=total-x;\\n        int ans=INT_MIN;\\n        int curr=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            curr+=nums[i];\\n            mp[curr]=i;\\n            \\n            if(curr==target)\\n            {\\n                ans=max(ans,i+1);\\n            }\\n            if(curr==(total-target))\\n            {\\n                ans=max(ans,n-i-1);\\n            }\\n            if(curr>target)\\n            {\\n                if(mp.find(curr-target)!=mp.end())\\n                {\\n                    ans=max(ans,i-mp[curr-target]);\\n                }\\n            }\\n        }\\n        return (ans==INT_MIN)?-1:(n-ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136963,
                "title": "c-solution-using-two-pointer",
                "content": "# **C++ Solution Using Two Pointer**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        int left=0,right=0;\\n        int sum=0;\\n        int ans=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n         \\n        cout<<sum;\\n        int cur=nums[0];\\n        while(left<n&&right<n){\\n            if(cur<sum-x){\\n                \\n                right++;\\n                if(right==n)break;\\n                cur+=nums[right];\\n            }\\n            if(cur>sum-x){\\n                \\n                cur-=nums[left];\\n                \\n                left++;\\n            }\\n            if(cur==sum-x){\\n                ans=max(ans,right-left+1);\\n                right++;\\n                if(right==n)break;\\n                cur+=nums[right];\\n            }\\n            // cout<<cur<<endl;\\n        }\\n        return ans==-1?-1:n-ans;\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        int left=0,right=0;\\n        int sum=0;\\n        int ans=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n        }\\n         \\n        cout<<sum;\\n        int cur=nums[0];\\n        while(left<n&&right<n){\\n            if(cur<sum-x){\\n                \\n                right++;\\n                if(right==n)break;\\n                cur+=nums[right];\\n            }\\n            if(cur>sum-x){\\n                \\n                cur-=nums[left];\\n                \\n                left++;\\n            }\\n            if(cur==sum-x){\\n                ans=max(ans,right-left+1);\\n                right++;\\n                if(right==n)break;\\n                cur+=nums[right];\\n            }\\n            // cout<<cur<<endl;\\n        }\\n        return ans==-1?-1:n-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2136939,
                "title": "c-o-n-easy-to-understand",
                "content": "To solve this problem first we need to calculate the maximum length of subarray with sum which is equal to difference of total sum and x. \\n\\n**Example:**\\n**nums** = [3,2,5,4,11,5]\\n**x** = 10\\n\\nTotal sum = 3 + 2 + 5 + 4 + 11 + 5 = 30\\nSum - x = 20\\n\\nLength of maximum subarray with sum = 20 is 3 as shown;\\n![image](https://assets.leetcode.com/users/images/cc41dccc-38e7-41bf-a129-e3909f1574d2_1654924475.3698084.png)\\n\\n\\nClearly we can say that the sum of remaining elements other than subarray is x. So we need to return the remaining length other than subarray.\\n\\nThat is we need to return 6 - 3 which is equal to 3.\\nSo the **output** for the above test case is 3.\\n\\n**C++ code**\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int l = 0;\\n        int sum = 0, res = 0, maxi = -1,n = nums.size();\\n        for(int i = 0;i<n;i++) // To calculate total sum\\n        {\\n            sum = sum + nums[i];\\n        }\\n        for(int i = 0;i<n;i++) // To calculate length of maximum subarray with \\'sum = total sum - x\\'\\n        {\\n            res = res + nums[i];\\n            while((l<n) && (sum - x < res))\\n            {\\n                res = res - nums[l];\\n                l++;\\n            }\\n            if(sum - res == x)\\n            {\\n                maxi = max(i - l + 1, maxi);\\n            }\\n        }\\n        if(maxi == -1)\\n        {\\n            return -1;\\n        }\\n        return n - maxi;\\n        \\n    }\\n};\\n```\\n\\n**Time complexity -** O(N)\\n**Space complexity -** O(1)\\n\\n**Please upvote if you liked it :)**\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int l = 0;\\n        int sum = 0, res = 0, maxi = -1,n = nums.size();\\n        for(int i = 0;i<n;i++) // To calculate total sum\\n        {\\n            sum = sum + nums[i];\\n        }\\n        for(int i = 0;i<n;i++) // To calculate length of maximum subarray with \\'sum = total sum - x\\'\\n        {\\n            res = res + nums[i];\\n            while((l<n) && (sum - x < res))\\n            {\\n                res = res - nums[l];\\n                l++;\\n            }\\n            if(sum - res == x)\\n            {\\n                maxi = max(i - l + 1, maxi);\\n            }\\n        }\\n        if(maxi == -1)\\n        {\\n            return -1;\\n        }\\n        return n - maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136773,
                "title": "cpp-easy-intuition-full-explanations-2-approaches",
                "content": "# **Approach 1 :- DP**\\nUsed the classic Top Down DP(Knapsack 0/1) along with memoization\\n***But it gives TLE*** . The constraints are large for test cases.\\n\\n**Time Complexity O(N^2).\\nSpace Complexity O(N^2).**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<int>&nums,int s,int e,int x,int count=0){\\n        if(x==0)return count;\\n        if(s>e){\\n            return INT_MAX; \\n        }\\n        if(dp[s][e]!=-1)return dp[s][e];\\n        int leftSide=solve(nums,s+1,e,x-nums[s] ,count+1);\\n        int rightSide=solve(nums,s,e-1,x-nums[e],count+1);\\n        \\n        return dp[s][e]=min(leftSide,rightSide);\\n        \\n    }\\n    int minOperations(vector<int>& nums, int x) {\\n        dp.resize(nums.size(),vector<int>(nums.size(),-1));\\n        int res=solve(nums,0,nums.size()-1,x);\\n        return res==INT_MAX?-1:res;\\n    }\\n}; \\n```\\n\\n# Approah 2 :- Sliding window\\nWhen we look at the question, it says we need the numbers from either left or right which should meet our target in minimum elements .\\nBut its kinda tough to keep a check on left and right sides. But what if we keep a check on the middle block which is.\\n(Sum of entire array ) - target = new_target\\n\\nnow we need to find the maximum elements which can make this new Target 0 . and return total number - this maximum number.\\n\\n**Time Complexity O(KN) where k is the maximum size of the sliding window\\nSpace Complexity O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x){ \\n        int res=-1,n=nums.size(), new_target=-x, left=0;\\n        \\n        for(auto i:nums)\\n            new_target+=i;\\n        \\n        if(new_target<0)return -1;\\n        \\n        for(int right=0;right<n;right++){\\n            new_target-=nums[right];\\n            while(new_target<0){\\n                new_target+=nums[left++];\\n            }\\n            if(new_target==0){\\n                res=max(res,right-left+1);\\n            }\\n        }\\n\\n        return n-res>n?-1:n-res;\\n    }\\n\\t//**If you find helpfull click upvote button **\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<int>&nums,int s,int e,int x,int count=0){\\n        if(x==0)return count;\\n        if(s>e){\\n            return INT_MAX; \\n        }\\n        if(dp[s][e]!=-1)return dp[s][e];\\n        int leftSide=solve(nums,s+1,e,x-nums[s] ,count+1);\\n        int rightSide=solve(nums,s,e-1,x-nums[e],count+1);\\n        \\n        return dp[s][e]=min(leftSide,rightSide);\\n        \\n    }\\n    int minOperations(vector<int>& nums, int x) {\\n        dp.resize(nums.size(),vector<int>(nums.size(),-1));\\n        int res=solve(nums,0,nums.size()-1,x);\\n        return res==INT_MAX?-1:res;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x){ \\n        int res=-1,n=nums.size(), new_target=-x, left=0;\\n        \\n        for(auto i:nums)\\n            new_target+=i;\\n        \\n        if(new_target<0)return -1;\\n        \\n        for(int right=0;right<n;right++){\\n            new_target-=nums[right];\\n            while(new_target<0){\\n                new_target+=nums[left++];\\n            }\\n            if(new_target==0){\\n                res=max(res,right-left+1);\\n            }\\n        }\\n\\n        return n-res>n?-1:n-res;\\n    }\\n\\t//**If you find helpfull click upvote button **\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136573,
                "title": "simple-java-solution-faster-than-95-37",
                "content": "Finding the minimum number of removing is equal to finding the maximum number of remaining.\\nSliding window can help us find the maximum number of remaining easily!\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int n = nums.length;\\n        \\n        int sum = 0;\\n        for (int i = 0; i < n; i++) \\n            sum += nums[i];\\n        int target = sum - x;\\n        \\n        if (target < 0)\\n            return -1;\\n        if (target == 0)\\n            return n;\\n        \\n        int left = 0, right = 0;\\n        int maximum = 0;\\n        while (right < n) {\\n            target -= nums[right++];\\n            \\n            while (target < 0)\\n                target += nums[left++];\\n            \\n            if (target == 0)\\n                maximum = Math.max(maximum, right - left);\\n        }\\n        \\n        return maximum == 0 ? -1 : nums.length - maximum;\\n    }\\n}\\n```\\n\\nHowever, when I first meet this question, I come up with a solution which use greedy and backtrack.\\nWhen remove the number (assume you have [a, ..., b]), choose the bigger one (assume a is bigger than b, so we choose a), if it doesn\\'t work, backtrack, choose the other one (b).\\nI think it\\'s a nice idea but it meets TLE, I also post this code below\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        LinkedList<Integer> removed = new LinkedList<>();\\n        return helper(nums, 0, nums.length - 1, x, removed) ? removed.size() : -1;\\n    }\\n    \\n    private boolean helper(int[] nums, int left, int right, int x, LinkedList<Integer> removed) {\\n        if (x == 0)\\n            return true;\\n        \\n        if (x < 0)\\n            return false;\\n        \\n        if (left > right)\\n            return false;\\n        \\n        if (nums[left] > x && nums[right] > x)\\n            return false;\\n        \\n        if (nums[left] >= nums[right]) { // greedy\\n            removed.add(nums[left]);\\n            if (helper(nums, left + 1, right, x - nums[left], removed))\\n                return true;\\n            removed.removeLast(); // backtrack\\n\\n            removed.add(nums[right]);\\n            if (helper(nums, left, right - 1, x - nums[right], removed))\\n                return true;\\n            removed.removeLast();\\n        } else {\\n            removed.add(nums[right]);\\n            if (helper(nums, left, right - 1, x - nums[right], removed))\\n                return true;\\n            removed.removeLast();\\n\\n            removed.add(nums[left]);\\n            if (helper(nums, left + 1, right, x - nums[left], removed))\\n                return true;\\n            removed.removeLast();\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int n = nums.length;\\n        \\n        int sum = 0;\\n        for (int i = 0; i < n; i++) \\n            sum += nums[i];\\n        int target = sum - x;\\n        \\n        if (target < 0)\\n            return -1;\\n        if (target == 0)\\n            return n;\\n        \\n        int left = 0, right = 0;\\n        int maximum = 0;\\n        while (right < n) {\\n            target -= nums[right++];\\n            \\n            while (target < 0)\\n                target += nums[left++];\\n            \\n            if (target == 0)\\n                maximum = Math.max(maximum, right - left);\\n        }\\n        \\n        return maximum == 0 ? -1 : nums.length - maximum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        LinkedList<Integer> removed = new LinkedList<>();\\n        return helper(nums, 0, nums.length - 1, x, removed) ? removed.size() : -1;\\n    }\\n    \\n    private boolean helper(int[] nums, int left, int right, int x, LinkedList<Integer> removed) {\\n        if (x == 0)\\n            return true;\\n        \\n        if (x < 0)\\n            return false;\\n        \\n        if (left > right)\\n            return false;\\n        \\n        if (nums[left] > x && nums[right] > x)\\n            return false;\\n        \\n        if (nums[left] >= nums[right]) { // greedy\\n            removed.add(nums[left]);\\n            if (helper(nums, left + 1, right, x - nums[left], removed))\\n                return true;\\n            removed.removeLast(); // backtrack\\n\\n            removed.add(nums[right]);\\n            if (helper(nums, left, right - 1, x - nums[right], removed))\\n                return true;\\n            removed.removeLast();\\n        } else {\\n            removed.add(nums[right]);\\n            if (helper(nums, left, right - 1, x - nums[right], removed))\\n                return true;\\n            removed.removeLast();\\n\\n            removed.add(nums[left]);\\n            if (helper(nums, left + 1, right, x - nums[left], removed))\\n                return true;\\n            removed.removeLast();\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443753,
                "title": "dp-top-down-and-sliding-window-solutions-in-c",
                "content": "**Approach 1**  **DP**\\nUsed the classic Top Down DP(**Knapsack 0/1**) along with memoization\\nBut it gives **TLE** . The constraints are large for test cases.\\n\\n**Time Complexity O(N^2)\\nSpace Complexity O(N^2)**\\n```\\n// Classic Knapsack 0/1 problem\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<int>&nums,int s,int e,int x,int count=0){\\n        if(x==0)return count;\\n        if(s>e){\\n            return INT_MAX; \\n        }\\n        if(dp[s][e]!=-1)return dp[s][e];\\n        int leftSide=solve(nums,s+1,e,x-nums[s] ,count+1);\\n        int rightSide=solve(nums,s,e-1,x-nums[e],count+1);\\n        \\n        return dp[s][e]=min(leftSide,rightSide);\\n        \\n    }\\n    int minOperations(vector<int>& nums, int x) {\\n        dp.resize(nums.size(),vector<int>(nums.size(),-1));\\n        int res=solve(nums,0,nums.size()-1,x);\\n        return res==INT_MAX?-1:res;\\n    }\\n}; \\n```\\n\\n**Approah 2** **Sliding window**\\n\\nWhen we look at the question, it says we need the numbers from either left or right which should meet our target in minimum elements .\\nBut its kinda tough to keep a check on left and right sides. But what if we keep a check on the middle block which is.\\n**(Sum of entire array ) - target = new_target**\\n \\n now we need to find the maximum elements which can make this new Target 0 . and return total number - this maximum number.\\n\\n**Time Complexity O(KN)  where k is the maximum size of the sliding window \\nSpace Complexity O(1)** \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x){ \\n        int res=-1,n=nums.size(), new_target=-x, left=0;\\n        \\n        for(auto i:nums)\\n            new_target+=i;\\n        \\n        if(new_target<0)return -1;\\n        \\n        for(int right=0;right<n;right++){\\n            new_target-=nums[right];\\n            while(new_target<0){\\n                new_target+=nums[left++];\\n            }\\n            if(new_target==0){\\n                res=max(res,right-left+1);\\n            }\\n        }\\n\\n        return n-res>n?-1:n-res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\n// Classic Knapsack 0/1 problem\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<int>&nums,int s,int e,int x,int count=0){\\n        if(x==0)return count;\\n        if(s>e){\\n            return INT_MAX; \\n        }\\n        if(dp[s][e]!=-1)return dp[s][e];\\n        int leftSide=solve(nums,s+1,e,x-nums[s] ,count+1);\\n        int rightSide=solve(nums,s,e-1,x-nums[e],count+1);\\n        \\n        return dp[s][e]=min(leftSide,rightSide);\\n        \\n    }\\n    int minOperations(vector<int>& nums, int x) {\\n        dp.resize(nums.size(),vector<int>(nums.size(),-1));\\n        int res=solve(nums,0,nums.size()-1,x);\\n        return res==INT_MAX?-1:res;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x){ \\n        int res=-1,n=nums.size(), new_target=-x, left=0;\\n        \\n        for(auto i:nums)\\n            new_target+=i;\\n        \\n        if(new_target<0)return -1;\\n        \\n        for(int right=0;right<n;right++){\\n            new_target-=nums[right];\\n            while(new_target<0){\\n                new_target+=nums[left++];\\n            }\\n            if(new_target==0){\\n                res=max(res,right-left+1);\\n            }\\n        }\\n\\n        return n-res>n?-1:n-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016310,
                "title": "minimum-operations-to-reduce-x-to-zero-c-easy-99-beat-hash-map",
                "content": "\\nAs we count the sum of the first l numbers, you need to find a complement (x - sum) number formed by numbers on the right. To do so, we can use a hashmap where we will store the rolling sum.\\nUpvote if you liked :)\\n```\\nint minOperations(vector<int>& nums, int x) {\\n    unordered_map<int, int> left;\\n    int res = INT_MAX;\\n    for (auto l = 0, sum = 0; l < nums.size() && sum <= x; ++l) {\\n        left[sum] = l;\\n        sum += nums[l];\\n    }\\n    for (int r = nums.size() - 1, sum = 0; r >= 0 && sum <= x; --r) {\\n        auto it = left.find(x - sum);\\n        if (it != end(left) && r + 1 >= it->second) {\\n            res = min(res, (int)nums.size() - r - 1 + it->second);\\n        }\\n        sum += nums[r];\\n    }\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minOperations(vector<int>& nums, int x) {\\n    unordered_map<int, int> left;\\n    int res = INT_MAX;\\n    for (auto l = 0, sum = 0; l < nums.size() && sum <= x; ++l) {\\n        left[sum] = l;\\n        sum += nums[l];\\n    }\\n    for (int r = nums.size() - 1, sum = 0; r >= 0 && sum <= x; --r) {\\n        auto it = left.find(x - sum);\\n        if (it != end(left) && r + 1 >= it->second) {\\n            res = min(res, (int)nums.size() - r - 1 + it->second);\\n        }\\n        sum += nums[r];\\n    }\\n    return res == INT_MAX ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067004,
                "title": "easy-solution-explanation-c-beat-98-9",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### Try to find maximum subarray that have the `sum == total_sum of array - x`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total_sum = 0;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            total_sum += nums[i];\\n        total_sum -= x;\\n\\n        int ans = INT_MAX;\\n        int sum = 0;\\n        int i = 0, j = 0;\\n        while(j < n){\\n            sum += nums[j];\\n            if(sum > total_sum)\\n                while(i <= j && sum > total_sum)\\n                    sum -= nums[i++];\\n\\n            if(sum == total_sum)\\n                ans = min(ans, n - (j - i) - 1);\\n            j++;\\n        }\\n\\n        return ans == INT_MAX ? -1 : ans;\\n\\n    }\\n};\\n```\\n![upvote_leetcode.jpeg](https://assets.leetcode.com/users/images/4124a7e8-fc44-4a6e-b6fb-d0fd2a082fa5_1695186483.0447855.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total_sum = 0;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n            total_sum += nums[i];\\n        total_sum -= x;\\n\\n        int ans = INT_MAX;\\n        int sum = 0;\\n        int i = 0, j = 0;\\n        while(j < n){\\n            sum += nums[j];\\n            if(sum > total_sum)\\n                while(i <= j && sum > total_sum)\\n                    sum -= nums[i++];\\n\\n            if(sum == total_sum)\\n                ans = min(ans, n - (j - i) - 1);\\n            j++;\\n        }\\n\\n        return ans == INT_MAX ? -1 : ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137819,
                "title": "c-minimum-operations-to-reduce-x-to-zero-2-approaches-with-explanation",
                "content": "**Approach 1**\\n\\t1. Maintain two cumulative sum `left` and `right` . Also check the edge cases (if x is present in the `left` or `right`)\\n\\t2. Go from start to end of `left` and check if remaining is present or not in the `right` one.\\n\\t3. `ans` will be sum of two indices.\\n\\n**Time:** `O(N log N)`\\n**Space:**  `O(N)`\\n**N** = Length of the array\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<int> left(n), right(n);\\n        left[0] = nums[0], right[0] = nums[n - 1];\\n        for(int i = 1, j = n - 2; i < n; i++, j--){\\n            left[i] = left[i - 1] + nums[i];\\n            right[i] = right[i - 1] + nums[j];\\n        }\\n        \\n        int pos = lower_bound(left.begin(), left.end(), x) - left.begin();\\n        int ans = INT_MAX;\\n        \\n        if(pos == 0){\\n            if(x == left[0]) ans = 1;\\n            else ans = INT_MAX;\\n        }\\n        else{\\n            if(pos < n && left[pos] == x) ans = pos + 1;\\n            else ans = INT_MAX;\\n        }\\n        \\n        pos = lower_bound(right.begin(), right.end(), x) - right.begin();\\n        \\n        if(pos == 0){\\n            if(x == right[0]) ans = 1;\\n        }\\n        else{\\n            if(pos < n && right[pos] == x) ans = min(ans, pos + 1);\\n        }\\n\\n        for(int i = 1; i <= n; i++){\\n            int rem = x - left[i - 1];\\n            if(rem <= 0) break;\\n            pos = lower_bound(right.begin(), right.end(), rem) - right.begin();\\n            if(pos == n) continue;\\n            if(left[i - 1] + right[pos] == x) ans = min(ans, i + pos + 1);\\n        }\\n        \\n        return ans > n ? -1 : ans;\\n    }\\n};\\n```\\nAfter some observations if the array is circular then this problem will be converted as **Find the maximum length subarray whose sum is** `x`. But the array is not circular and we need to find sum of `x`. If the sum is present then `totalsum - x` will be present also. And if we found this sum then the anser will be `length - max found length`. \\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int sum = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            sum += nums[i];\\n        }\\n        \\n        if(x > sum) return -1;\\n        \\n        int target = sum - x, left = 0;\\n        int ans = INT_MIN, currsum = 0;\\n        \\n        for(int right = 0; right < n; right++){\\n            currsum += nums[right];\\n            while(left < n && currsum - nums[left] >= target){                \\n                currsum -= nums[left++];\\n            }\\n            if(currsum == target) ans = max(ans, right - left + 1);\\n        }\\n\\n        if(ans < 0) return -1;\\n        return n - ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Binary Search",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<int> left(n), right(n);\\n        left[0] = nums[0], right[0] = nums[n - 1];\\n        for(int i = 1, j = n - 2; i < n; i++, j--){\\n            left[i] = left[i - 1] + nums[i];\\n            right[i] = right[i - 1] + nums[j];\\n        }\\n        \\n        int pos = lower_bound(left.begin(), left.end(), x) - left.begin();\\n        int ans = INT_MAX;\\n        \\n        if(pos == 0){\\n            if(x == left[0]) ans = 1;\\n            else ans = INT_MAX;\\n        }\\n        else{\\n            if(pos < n && left[pos] == x) ans = pos + 1;\\n            else ans = INT_MAX;\\n        }\\n        \\n        pos = lower_bound(right.begin(), right.end(), x) - right.begin();\\n        \\n        if(pos == 0){\\n            if(x == right[0]) ans = 1;\\n        }\\n        else{\\n            if(pos < n && right[pos] == x) ans = min(ans, pos + 1);\\n        }\\n\\n        for(int i = 1; i <= n; i++){\\n            int rem = x - left[i - 1];\\n            if(rem <= 0) break;\\n            pos = lower_bound(right.begin(), right.end(), rem) - right.begin();\\n            if(pos == n) continue;\\n            if(left[i - 1] + right[pos] == x) ans = min(ans, i + pos + 1);\\n        }\\n        \\n        return ans > n ? -1 : ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int sum = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            sum += nums[i];\\n        }\\n        \\n        if(x > sum) return -1;\\n        \\n        int target = sum - x, left = 0;\\n        int ans = INT_MIN, currsum = 0;\\n        \\n        for(int right = 0; right < n; right++){\\n            currsum += nums[right];\\n            while(left < n && currsum - nums[left] >= target){                \\n                currsum -= nums[left++];\\n            }\\n            if(currsum == target) ans = max(ans, right - left + 1);\\n        }\\n\\n        if(ans < 0) return -1;\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137399,
                "title": "kotlin-o-n-time-o-1-space",
                "content": "```\\n    fun minOperations(nums: IntArray, x: Int): Int {\\n        //find longest subarray sum to total_sum - x\\n        var target = nums.sum() - x; var sum = 0\\n        var l = 0; var ans = -1;\\n        for(r in 0 until nums.size)\\n        {\\n            sum += nums[r]\\n            while(l <= r && sum > target) //move left pointer\\n                sum -= nums[l++];\\n            if(target == sum)\\n                ans = max(ans, r - l + 1)\\n        }\\n        return if(ans == - 1) -1 else nums.size - ans\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun minOperations(nums: IntArray, x: Int): Int {\\n        //find longest subarray sum to total_sum - x\\n        var target = nums.sum() - x; var sum = 0\\n        var l = 0; var ans = -1;\\n        for(r in 0 until nums.size)\\n        {\\n            sum += nums[r]\\n            while(l <= r && sum > target) //move left pointer\\n                sum -= nums[l++];\\n            if(target == sum)\\n                ans = max(ans, r - l + 1)\\n        }\\n        return if(ans == - 1) -1 else nums.size - ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137299,
                "title": "binary-search-c-o-nlogn",
                "content": "First, I thought it\\'s dp but when I saw the constraint then i came to know that it\\'s not dp.\\nWhen we see closely, see the prefix[i] + suffix[j]==x then i + (n-j) is our answer.\\nI am giving the example:\\n[1,1,4,2,3] and x = 5\\npre = [0,1,2,6,8,11] //add 0 for simplicity\\nsuff = [11,10,9,5,3,0] \\n\\nIn this scenario there are two cases:\\npre[2] + suff[4] = 2 + 3 = 5 so, noOfOperation = 2 + (5-4) = 2 + 1 = 3\\npre[0] + suff[3] = 0 + 5 = 5 so, noOfOperation = 0 + (5-3) = 0 + 2 = 2\\n\\nNo other cases, which gives you pre[i] + suff[j] == x.\\ntherefore, minimum number of operation = min(3,2) = 2.\\n\\nIf you check in linear order it will give you **O(n^2)** time complexity.\\n\\nAssume we pick the jth suffix element and binary seach on prefix then we find out the index in log n time.\\nfor every suffix element, we do log n operation so, the time complexity is **O(n log n).**\\n\\nHere is my code:\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<long> pre(n+1,0);\\n        \\n        int noOfOperation = n+1;\\n        \\n        //calculate the prefixsum\\n        for(int i=0;i<n;i++){\\n            pre[i+1] = pre[i] + nums[i];\\n        }\\n        \\n        \\n        int suff = 0;\\n        \\n        for(int i=n;i>=0;i--){\\n            \\n            int s = 0, e = i;\\n            \\n            //apply binary search and find the x-suff index\\n            while(s<=e){\\n                \\n                int m = (s+e)>>1;\\n                \\n                if(pre[m]==x-suff){\\n                    noOfOperation = min(noOfOperation,m+(n-i));\\n                    break;\\n                }else if(pre[m]>x-suff){\\n                    e = m-1;\\n                }else\\n                    s = m+1;\\n            }  \\n            \\n            if(i-1>=0) suff += nums[i-1];\\n        }\\n        \\n        return noOfOperation==n+1?-1:noOfOperation;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<long> pre(n+1,0);\\n        \\n        int noOfOperation = n+1;\\n        \\n        //calculate the prefixsum\\n        for(int i=0;i<n;i++){\\n            pre[i+1] = pre[i] + nums[i];\\n        }\\n        \\n        \\n        int suff = 0;\\n        \\n        for(int i=n;i>=0;i--){\\n            \\n            int s = 0, e = i;\\n            \\n            //apply binary search and find the x-suff index\\n            while(s<=e){\\n                \\n                int m = (s+e)>>1;\\n                \\n                if(pre[m]==x-suff){\\n                    noOfOperation = min(noOfOperation,m+(n-i));\\n                    break;\\n                }else if(pre[m]>x-suff){\\n                    e = m-1;\\n                }else\\n                    s = m+1;\\n            }  \\n            \\n            if(i-1>=0) suff += nums[i-1];\\n        }\\n        \\n        return noOfOperation==n+1?-1:noOfOperation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137217,
                "title": "c-sliding-window-1658-minimum-operations-to-reduce-x-to-zero-easy",
                "content": "\\t// Here ans is the window size we have to maximize the window size\\n\\t// because more we maximize window size lesser the elements willl be remainig in nums\\n\\t// ans hence our no of operation will be reduced\\n\\t// Here we are checking for window of max size for sum=totalsum-x \\n\\t//so that sum of remainig  elements becomes x \\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums, int x) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tsum-=x;\\n\\t\\t\\tif(sum==0) return nums.size();\\n\\n\\t\\t\\tint i=0,j=0,s1=0;\\n\\t\\t\\twhile(j<nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\ts1+=nums[j];\\n\\t\\t\\t\\twhile(i<nums.size()&&s1>sum)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts1-=nums[i];\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1==sum){\\n\\t\\t\\t\\t\\tans=max(ans,j-i+1);\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans==0?-1:nums.size()-ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<int>& nums, int x) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tsum+=nums[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2136919,
                "title": "python-reverse-thinking-prefix-sum-hash-map-with-comments",
                "content": "When I first read this problem, I think I have seen it elsewhere. Then I realize that it\\'s pretty similar to *Leetcode 325 Maximum Size Subarray Sum Equals k*. \\n\\nTo get the minimum operations to reduce x to 0, we can get the longest length of subarray sum equals \"new\" target ```sum(nums) - x```. The answer will be ```len(nums)``` - ```longest```. Also, don\\'t forget to deal with the corner cases. \\n\\nI use prefix sum and hashmap to solve 325. Below is my code with comments. Feel free to ask if you have any questions!\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        # corner cases\\n        if x > sum(nums):\\n            return -1\\n        elif x == sum(nums):\\n            return len(nums)\\n        \\n        target = sum(nums) - x # \"new\" target\\n        longest = 0 # track the longest subarray sum equals target\\n        preSum = 0 # prefix sum\\n        hashMap = {} # hash map (prefix sum: index) \\n        \\n        for i, n in enumerate(nums):\\n            preSum += n\\n            \\n            # generate a hash map preSum -> i\\n            if preSum not in hashMap:\\n                hashMap[preSum] = i\\n            \\n            # when subarray sum equals target\\n            if preSum == target:\\n                longest = max(longest, i + 1)\\n            \\n            # when the difference between prefix sum and target is another prefix sum\\n            diff = preSum - target\\n            if diff in hashMap:\\n                longest = max(longest, i - hashMap.get(diff))\\n            \\n        if longest == 0: # corner case: NO subarray sum equals target\\n            return -1\\n        else:\\n            return len(nums) - longest\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```sum(nums) - x```\n```len(nums)```\n```longest```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        # corner cases\\n        if x > sum(nums):\\n            return -1\\n        elif x == sum(nums):\\n            return len(nums)\\n        \\n        target = sum(nums) - x # \"new\" target\\n        longest = 0 # track the longest subarray sum equals target\\n        preSum = 0 # prefix sum\\n        hashMap = {} # hash map (prefix sum: index) \\n        \\n        for i, n in enumerate(nums):\\n            preSum += n\\n            \\n            # generate a hash map preSum -> i\\n            if preSum not in hashMap:\\n                hashMap[preSum] = i\\n            \\n            # when subarray sum equals target\\n            if preSum == target:\\n                longest = max(longest, i + 1)\\n            \\n            # when the difference between prefix sum and target is another prefix sum\\n            diff = preSum - target\\n            if diff in hashMap:\\n                longest = max(longest, i - hashMap.get(diff))\\n            \\n        if longest == 0: # corner case: NO subarray sum equals target\\n            return -1\\n        else:\\n            return len(nums) - longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136845,
                "title": "c-easy-solution-sliding-window-explained-commented-solution",
                "content": "In this problem you have to find the sum of end points is equal to x and we have to minimize the number of endpoints\\n\\nSo sum of end points = sum of all elements - sum of subarray i.e. sum of window\\nand if we maximize the window the  number of end points will be minimum\\nso this is the basic idea\\n\\n| PLEASE UPVOTE IF YOU LIKE THE SOLUTION |\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int sum=0;\\n        int n=nums.size();\\n        int len=0;\\n        \\n//         calculate the sum of array\\n        for(int i:nums){\\n            sum+=i;\\n        }\\n//         if total sum is equal to x then return size of array \\n        if(sum==x)return n;\\n        \\n//         here we use sliding window algorithm\\n        int i=0,j=0;\\n        int preSum=0;\\n        while(j<n){\\n            preSum+=nums[j];\\n//             here (sum-preSum) represent sum of end points\\n//if (sum-preSum) i.e. the sum of end points is greater than x we have to increase the size of window\\n            if((sum-preSum)>x){\\n                j++;\\n            }\\n//             if we found sum of end points is equal to x then store this and check further if better solution is present or not\\n            else if((sum-preSum)==x){\\n                len=max((j-i+1),len);\\n                j++;\\n            }\\n//             if sum of end points less than x we have to shrink the window\\n            else{\\n                while(i<j && (sum-preSum)<x){\\n                    preSum-=nums[i];\\n                    i++;\\n                }\\n                if((sum-preSum)==x)\\n                    len=max((j-i+1),len);\\n                j++;\\n            }\\n        }\\n        \\n//         if len is not updated then answer is not possible\\n        if(len==0){\\n            return -1;\\n        }\\n        return n-len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int sum=0;\\n        int n=nums.size();\\n        int len=0;\\n        \\n//         calculate the sum of array\\n        for(int i:nums){\\n            sum+=i;\\n        }\\n//         if total sum is equal to x then return size of array \\n        if(sum==x)return n;\\n        \\n//         here we use sliding window algorithm\\n        int i=0,j=0;\\n        int preSum=0;\\n        while(j<n){\\n            preSum+=nums[j];\\n//             here (sum-preSum) represent sum of end points\\n//if (sum-preSum) i.e. the sum of end points is greater than x we have to increase the size of window\\n            if((sum-preSum)>x){\\n                j++;\\n            }\\n//             if we found sum of end points is equal to x then store this and check further if better solution is present or not\\n            else if((sum-preSum)==x){\\n                len=max((j-i+1),len);\\n                j++;\\n            }\\n//             if sum of end points less than x we have to shrink the window\\n            else{\\n                while(i<j && (sum-preSum)<x){\\n                    preSum-=nums[i];\\n                    i++;\\n                }\\n                if((sum-preSum)==x)\\n                    len=max((j-i+1),len);\\n                j++;\\n            }\\n        }\\n        \\n//         if len is not updated then answer is not possible\\n        if(len==0){\\n            return -1;\\n        }\\n        return n-len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140103,
                "title": "java-20-lines-of-code-o-n-time-and-constant-space-sliding-window-continuous-subarray",
                "content": "The idea here is to find **maximun length continuous subarray** which can give sum equals to **Target**.  Here, target is defined as:\\n**Target = (Sum of array elements - x)**\\n\\n```\\npublic int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for(int i=0; i<nums.length; i++){\\n            sum += nums[i];\\n        }\\n        int target = sum-x;\\n        \\n        int left = 0, right = 0;\\n        sum = 0;\\n        int len = 0;\\n        \\n\\t\\t// This check is required in case we\\'ve to remove all the elements from array when target is 0.\\n\\t\\tif(target == 0) return nums.length;\\n\\t\\t\\n\\t\\t// Sliding window \\n        while(right < nums.length){\\n            sum += nums[right];\\n            while(sum > target && left <= right){\\n                sum -= nums[left];\\n                left++;\\n            }\\n\\t\\t\\t\\n            if(sum==target){\\n                len = Math.max(len, right - left + 1);\\n            }\\n            right++;\\n        }\\n        \\n\\t\\t// If there is no Continuous subarray whose sum is equals to target, than return -1 \\n        if(len == 0) return -1;\\n\\t\\t\\n\\t\\t// len: Maximum window size which sums to target\\n\\t\\t// nums.length - len => Min elements needed to remove from array\\n        return nums.length - len;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for(int i=0; i<nums.length; i++){\\n            sum += nums[i];\\n        }\\n        int target = sum-x;\\n        \\n        int left = 0, right = 0;\\n        sum = 0;\\n        int len = 0;\\n        \\n\\t\\t// This check is required in case we\\'ve to remove all the elements from array when target is 0.\\n\\t\\tif(target == 0) return nums.length;\\n\\t\\t\\n\\t\\t// Sliding window \\n        while(right < nums.length){\\n            sum += nums[right];\\n            while(sum > target && left <= right){\\n                sum -= nums[left];\\n                left++;\\n            }\\n\\t\\t\\t\\n            if(sum==target){\\n                len = Math.max(len, right - left + 1);\\n            }\\n            right++;\\n        }\\n        \\n\\t\\t// If there is no Continuous subarray whose sum is equals to target, than return -1 \\n        if(len == 0) return -1;\\n\\t\\t\\n\\t\\t// len: Maximum window size which sums to target\\n\\t\\t// nums.length - len => Min elements needed to remove from array\\n        return nums.length - len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1017410,
                "title": "python-95-kadane-s-algorithm",
                "content": "template similar to  LC 209 [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)\\n\\n\\tdef minOperations(self, nums: List[int], x: int) -> int:\\n        \\n        l, curr_sum, n, target, ans = 0, 0, len(nums), sum(nums)-x, -1\\n\\n        if target < 0: return -1\\n        if target == 0: return n\\n        \\n        for r in range(n):\\n            curr_sum += nums[r]\\n            \\n            while curr_sum >= target and l <= r:\\n                if curr_sum == target:\\n                    ans = max(ans, r-l+1)\\n                curr_sum -= nums[l]\\n                l+=1\\n                \\n        return n - ans if ans != -1 else -1",
                "solutionTags": [],
                "code": "template similar to  LC 209 [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)\\n\\n\\tdef minOperations(self, nums: List[int], x: int) -> int:\\n        \\n        l, curr_sum, n, target, ans = 0, 0, len(nums), sum(nums)-x, -1\\n\\n        if target < 0: return -1\\n        if target == 0: return n\\n        \\n        for r in range(n):\\n            curr_sum += nums[r]\\n            \\n            while curr_sum >= target and l <= r:\\n                if curr_sum == target:\\n                    ans = max(ans, r-l+1)\\n                curr_sum -= nums[l]\\n                l+=1\\n                \\n        return n - ans if ans != -1 else -1",
                "codeTag": "Python3"
            },
            {
                "id": 1016836,
                "title": "java-prefix-sum-with-map-and-sliding-window-beats-100",
                "content": "We can only pick some elements from prefix of array and some elements from suffix of array that add up to ```x``` and we need the count of such elements to be minimum. Another way to look at this problem is that we need to find the maximum length subarray that add up to ```sum(nums) - x``` because this is the middle array that will be left.\\nThis is a standard problem which can be efficiently solved using prefix sum with map or sliding window techniques.\\n\\n**Prefix Sum + HashMap**\\n\\n```\\n// 59 ms. 60.22%\\npublic int minOperations(int[] nums, int x) {\\n    int target = -x;\\n    for(int num: nums) target += num;\\n    if(target == 0) return nums.length;\\n    if(target < 0) return -1;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    map.put(0, -1);\\n    int sum = 0, L = 0;\\n    for(int i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        L = Math.max(L, i - map.getOrDefault(sum - target, i));\\n        map.put(sum, i);\\n    }\\n    return L > 0 ? nums.length - L : -1;\\n}\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n**Sliding Window**\\n\\n```\\n// 3 ms. 100%\\npublic int minOperations(int[] nums, int x) {\\n    int target = -x;\\n    for(int num: nums) target += num;\\n    if(target == 0) return nums.length;\\n    if(target < 0) return -1;\\n    int left = 0, sum = 0, L = 0;\\n    for(int right = 0; right < nums.length; right++) {\\n        sum += nums[right];\\n        while(sum > target) {\\n            sum -= nums[left++];\\n        }\\n        if(sum == target) {\\n            L = Math.max(L, right - left + 1);\\n        }\\n    }\\n    return L > 0 ? nums.length - L : -1;\\n}\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```x```\n```sum(nums) - x```\n```\\n// 59 ms. 60.22%\\npublic int minOperations(int[] nums, int x) {\\n    int target = -x;\\n    for(int num: nums) target += num;\\n    if(target == 0) return nums.length;\\n    if(target < 0) return -1;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    map.put(0, -1);\\n    int sum = 0, L = 0;\\n    for(int i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        L = Math.max(L, i - map.getOrDefault(sum - target, i));\\n        map.put(sum, i);\\n    }\\n    return L > 0 ? nums.length - L : -1;\\n}\\n```\n```\\n// 3 ms. 100%\\npublic int minOperations(int[] nums, int x) {\\n    int target = -x;\\n    for(int num: nums) target += num;\\n    if(target == 0) return nums.length;\\n    if(target < 0) return -1;\\n    int left = 0, sum = 0, L = 0;\\n    for(int right = 0; right < nums.length; right++) {\\n        sum += nums[right];\\n        while(sum > target) {\\n            sum -= nums[left++];\\n        }\\n        if(sum == target) {\\n            L = Math.max(L, right - left + 1);\\n        }\\n    }\\n    return L > 0 ? nums.length - L : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016455,
                "title": "c-simple-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxSub(vector<int>& nums, int k) {\\n        int sum = 0, maxi = 0;\\n        unordered_map<int, int> m;\\n        \\n        for (int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            \\n            if (sum == k)\\n                maxi = i+1;\\n            \\n            if (m.find(sum) == m.end())\\n                m[sum] = i;\\n            \\n            if (m.find(sum - k) != m.end())\\n                maxi = max(maxi, i - m[sum-k]);\\n        }\\n        return maxi;\\n    }\\n    \\n    int minOperations(vector<int>& nums, int x) {\\n        if ((nums[0] > x) && (nums[nums.size()-1] > x))\\n            return -1;\\n        \\n        int sum = 0;\\n        for (auto a : nums)\\n            sum += a;\\n        \\n        if (sum == x) return nums.size();\\n        \\n        int res = findMaxSub(nums, sum-x);\\n        return res <= 0 ? -1 : nums.size() - res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxSub(vector<int>& nums, int k) {\\n        int sum = 0, maxi = 0;\\n        unordered_map<int, int> m;\\n        \\n        for (int i=0; i<nums.size(); i++) {\\n            sum += nums[i];\\n            \\n            if (sum == k)\\n                maxi = i+1;\\n            \\n            if (m.find(sum) == m.end())\\n                m[sum] = i;\\n            \\n            if (m.find(sum - k) != m.end())\\n                maxi = max(maxi, i - m[sum-k]);\\n        }\\n        return maxi;\\n    }\\n    \\n    int minOperations(vector<int>& nums, int x) {\\n        if ((nums[0] > x) && (nums[nums.size()-1] > x))\\n            return -1;\\n        \\n        int sum = 0;\\n        for (auto a : nums)\\n            sum += a;\\n        \\n        if (sum == x) return nums.size();\\n        \\n        int res = findMaxSub(nums, sum-x);\\n        return res <= 0 ? -1 : nums.size() - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936102,
                "title": "c-solution-using-map",
                "content": "In the first look this question give me the wibes of DP problem in which a person can use standered recurssion and memorization to get answer but the problem here is constrains which does not allow us to use recurssion with memorization.\\n\\nSo what come next so my next approch is to use prefix sum by using to arrays one is leftprefix sum and rightprefix sum but soon i realize that we can solve this problem without using left and right prefix sum.\\n\\nSo now i finaly think about unordered map with key as sum till index and value as number of element this sum covers.\\n\\'\\'\\'\\n\\n1 2 3 4 5 6 7  and target is 19\\n\\n7->1\\n6+7=13->2\\n5+6+7=18->3\\n4+5+6+7=22->4\\n3+4+5+6+7=25->5\\n2+3+4+5+6+7=27->6\\n1+2+3+4+5+6+7=28->7\\n\\nfinaly my map will look like\\n\\t{ [7,1], [13,2], [18,3], [22,4], [25,5], [27,6], [28,7] }\\n\\n\\'\\'\\'\\n\\n<iframe src=\"https://leetcode.com/playground/Wa8AeCvS/shared\" frameBorder=\"0\" width=\"1000\" height=\"700\"></iframe>\\n\\nThe intention behind this post is to help other \\nif you have any doubt in this solution you can comment down i will love to answer them\\nand I m new in giving solution and approch if i made any mistake plese comment down below \\n**Don\\'t forget to upvote if you like my solution**\\n**Happy coding**",
                "solutionTags": [],
                "code": "In the first look this question give me the wibes of DP problem in which a person can use standered recurssion and memorization to get answer but the problem here is constrains which does not allow us to use recurssion with memorization.\\n\\nSo what come next so my next approch is to use prefix sum by using to arrays one is leftprefix sum and rightprefix sum but soon i realize that we can solve this problem without using left and right prefix sum.\\n\\nSo now i finaly think about unordered map with key as sum till index and value as number of element this sum covers.\\n\\'\\'\\'\\n\\n1 2 3 4 5 6 7  and target is 19\\n\\n7->1\\n6+7=13->2\\n5+6+7=18->3\\n4+5+6+7=22->4\\n3+4+5+6+7=25->5\\n2+3+4+5+6+7=27->6\\n1+2+3+4+5+6+7=28->7\\n\\nfinaly my map will look like\\n\\t{ [7,1], [13,2], [18,3], [22,4], [25,5], [27,6], [28,7] }\\n\\n\\'\\'\\'\\n\\n<iframe src=\"https://leetcode.com/playground/Wa8AeCvS/shared\" frameBorder=\"0\" width=\"1000\" height=\"700\"></iframe>\\n\\nThe intention behind this post is to help other \\nif you have any doubt in this solution you can comment down i will love to answer them\\nand I m new in giving solution and approch if i made any mistake plese comment down below \\n**Don\\'t forget to upvote if you like my solution**\\n**Happy coding**",
                "codeTag": "Unknown"
            },
            {
                "id": 936031,
                "title": "python-o-n-time-o-1-memory-two-pointers-no-extra-tools",
                "content": "First of all, the order of operations does not matter: we just need to find left and right parts of the list that form x. Their cumulative length is the number of operations.\\n\\nTwo pointers - left and right. The left pointer points at the end of the left part of the list that is included in x, and the right pointer points at the end of the right part of the list (inclusive).\\n\\nInitially, the left part includes the whole list, and the right part includes nothing.\\n\\nNow, we move the pointers. If the sum of the left and the right parts exceed x (x minus these parts is less than zero), we move the left pointer to the left - we decrease the sum. If the sum of the left and right parts is less than x (x minus these parts is greater than zero), we move the right pointer to the left - we increase the sum.\\n\\nIf the sum is exactly x, we calculate the joint length of both parts and track its minimum.\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        \\n        if sum(nums)<x: return -1\\n        \\n        ans=math.inf\\n        ptr_l, ptr_r=len(nums)-1, len(nums) # Two pointers\\n        sum_parts = sum(nums) # Track the sum of the left/right parts - first, the left part is the whole list\\n        while ptr_l >= 0:\\n            if sum_parts >= x:  # If the sum of the left/right parts exceeds desired sum - decrease the left part\\n                sum_parts -= nums[ptr_l]\\n                ptr_l -= 1\\n            if sum_parts < x: # If the sum of the left/right parts is less than the desired sum - increase the right part\\n                ptr_r -= 1\\n                sum_parts += nums[ptr_r]\\n            if sum_parts == x: ans = min(ans, (ptr_l+1) + (len(nums)-ptr_r)) # If we are at the desired sum - keep track of the best total length of the parts\\n        return ans if ans <math.inf else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        \\n        if sum(nums)<x: return -1\\n        \\n        ans=math.inf\\n        ptr_l, ptr_r=len(nums)-1, len(nums) # Two pointers\\n        sum_parts = sum(nums) # Track the sum of the left/right parts - first, the left part is the whole list\\n        while ptr_l >= 0:\\n            if sum_parts >= x:  # If the sum of the left/right parts exceeds desired sum - decrease the left part\\n                sum_parts -= nums[ptr_l]\\n                ptr_l -= 1\\n            if sum_parts < x: # If the sum of the left/right parts is less than the desired sum - increase the right part\\n                ptr_r -= 1\\n                sum_parts += nums[ptr_r]\\n            if sum_parts == x: ans = min(ans, (ptr_l+1) + (len(nums)-ptr_r)) # If we are at the desired sum - keep track of the best total length of the parts\\n        return ans if ans <math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935983,
                "title": "python-o-n-sliding-window-passed-dp-o-n-2-tle",
                "content": "The first time I saw this problem, DP jumped into my mind and I spent 30min+ debugging big test cases. However it\\'s a O(n^2) solution/aka 10^10 in this case and it got TLE. On the other hand, sliding window just takes O(n). **The problem can be translated into:  find the longest subarray with sum = sum(nums) - x**\\n```\\n    def minOperations(self, nums, x):\\n        n = len(nums)\\n        if x < nums[0] and x < nums[-1] or x > sum(nums):\\n            return -1\\n        i, res = 0, -1\\n        target = sum(nums) - x\\n        for j in range(n):\\n            target -= nums[j]\\n            if target == 0:\\n                res = max(res, j - i + 1)\\n            while target < 0:\\n                target += nums[i]\\n                i += 1\\n                if target == 0:\\n                    res = max(res, j - i + 1)\\n        if res != -1:\\n            return n - res\\n        else:\\n            return -1\\n```\\n\\nTop down DFS + memo got TLE:\\n```\\n        n = len(nums)\\n        if x < nums[0] and x < nums[-1] or x > sum(nums):\\n            return -1\\n        memo = {}\\n        def dfs(i, j, target):\\n            # target is the sum we want from 2 ends\\n            # memo store the min operation we need for nums[i...j] with target = target\\n            if target < 0 or target > sum(nums[i:j + 1]):\\n                return float(\\'inf\\')\\n            if target == nums[i] or target == nums[j]:\\n                return 1\\n            if i == j:\\n                if nums[i] == target:\\n                    return 1\\n                return float(\\'inf\\')\\n\\n            if (i, j, target) in memo:\\n                return memo[(i, j, target)]\\n            \\n            tmp1, tmp2 = dfs(i, j - 1, target - nums[j]), dfs(i + 1, j, target - nums[i])\\n            ans = min(tmp1, tmp2) + 1\\n            # print(i, j, target, ans)\\n            memo[(i, j, target)] = ans\\n            return ans\\n\\n        \\n        res = dfs(0, n - 1, x)\\n        if res == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def minOperations(self, nums, x):\\n        n = len(nums)\\n        if x < nums[0] and x < nums[-1] or x > sum(nums):\\n            return -1\\n        i, res = 0, -1\\n        target = sum(nums) - x\\n        for j in range(n):\\n            target -= nums[j]\\n            if target == 0:\\n                res = max(res, j - i + 1)\\n            while target < 0:\\n                target += nums[i]\\n                i += 1\\n                if target == 0:\\n                    res = max(res, j - i + 1)\\n        if res != -1:\\n            return n - res\\n        else:\\n            return -1\\n```\n```\\n        n = len(nums)\\n        if x < nums[0] and x < nums[-1] or x > sum(nums):\\n            return -1\\n        memo = {}\\n        def dfs(i, j, target):\\n            # target is the sum we want from 2 ends\\n            # memo store the min operation we need for nums[i...j] with target = target\\n            if target < 0 or target > sum(nums[i:j + 1]):\\n                return float(\\'inf\\')\\n            if target == nums[i] or target == nums[j]:\\n                return 1\\n            if i == j:\\n                if nums[i] == target:\\n                    return 1\\n                return float(\\'inf\\')\\n\\n            if (i, j, target) in memo:\\n                return memo[(i, j, target)]\\n            \\n            tmp1, tmp2 = dfs(i, j - 1, target - nums[j]), dfs(i + 1, j, target - nums[i])\\n            ans = min(tmp1, tmp2) + 1\\n            # print(i, j, target, ans)\\n            memo[(i, j, target)] = ans\\n            return ans\\n\\n        \\n        res = dfs(0, n - 1, x)\\n        if res == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4067311,
                "title": "2-approaches-o-1-sc-clean-best-code",
                "content": "### Connect with me on LinkedIN : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n```\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) for Approach 1\\nO(1) for Approach 2\\n```\\n\\n# Code\\n## Please Upvote if u found it useful\\uD83E\\uDD17\\n# 1st Approach(Using PrefixSum + HashMap):-\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size(), minOper = n + 1, prefixSum = 0;\\n        unordered_map<int, int> mp;\\n        for(int i = 0 ; i < n ; i++){\\n            prefixSum += nums[i];\\n            if(prefixSum == x)\\n                minOper = i + 1;\\n            if(prefixSum > x)\\n                break;\\n            mp[prefixSum] = i + 1;\\n        }\\n        int suffixSum = 0;\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            suffixSum += nums[i];\\n            if(suffixSum == x)\\n                minOper = min(minOper, n - i);\\n            else if(suffixSum < x){\\n                if(mp.find(x - suffixSum) != mp.end())\\n                    minOper = min(minOper, n - i + mp[x - suffixSum]);\\n            }\\n            else\\n                break;\\n        }\\n        return (minOper != n + 1) ? minOper : -1;\\n    }\\n};\\n```\\n# 2nd Approach(Using Sliding Window):-\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size(), i = 0, j = 0, maxi = 0, total_sum = 0;\\n        for(auto it : nums)\\n            total_sum += it;\\n        if(total_sum < x)\\n            return -1;\\n        if(total_sum == x)\\n            return n;\\n        int req_sum = total_sum - x, curr_sum = 0;\\n        while(j < n){\\n            curr_sum += nums[j];\\n            while(curr_sum > req_sum)\\n                curr_sum -= nums[i++];\\n            if(curr_sum == req_sum)\\n                maxi = max(maxi, j - i + 1);\\n            j++;\\n        }\\n        return (maxi != 0) ? n - maxi : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) for Approach 1\\nO(1) for Approach 2\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size(), minOper = n + 1, prefixSum = 0;\\n        unordered_map<int, int> mp;\\n        for(int i = 0 ; i < n ; i++){\\n            prefixSum += nums[i];\\n            if(prefixSum == x)\\n                minOper = i + 1;\\n            if(prefixSum > x)\\n                break;\\n            mp[prefixSum] = i + 1;\\n        }\\n        int suffixSum = 0;\\n        for(int i = n - 1 ; i >= 0 ; i--){\\n            suffixSum += nums[i];\\n            if(suffixSum == x)\\n                minOper = min(minOper, n - i);\\n            else if(suffixSum < x){\\n                if(mp.find(x - suffixSum) != mp.end())\\n                    minOper = min(minOper, n - i + mp[x - suffixSum]);\\n            }\\n            else\\n                break;\\n        }\\n        return (minOper != n + 1) ? minOper : -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size(), i = 0, j = 0, maxi = 0, total_sum = 0;\\n        for(auto it : nums)\\n            total_sum += it;\\n        if(total_sum < x)\\n            return -1;\\n        if(total_sum == x)\\n            return n;\\n        int req_sum = total_sum - x, curr_sum = 0;\\n        while(j < n){\\n            curr_sum += nums[j];\\n            while(curr_sum > req_sum)\\n                curr_sum -= nums[i++];\\n            if(curr_sum == req_sum)\\n                maxi = max(maxi, j - i + 1);\\n            j++;\\n        }\\n        return (maxi != 0) ? n - maxi : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066776,
                "title": "today-s-potd-with-optimisation-100-acceptance-rate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to find a subarray with the maximum possible sum (equal to targetSum) within the given nums array. The goal is to minimize the number of operations to reduce x to 0. By calculating the maximum subarray length, we can determine the minimum number of operations required.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the targetSum by iterating through the nums array and subtract x from the sum of all elements. If targetSum is negative, it means there is no solution, so return -1.\\n\\n2. Initialize two pointers, left and right, both initially at the beginning of the array. Also, initialize currentSum and maxLength to 0 and -1, respectively.\\n\\n3. Iterate through the nums array using the right pointer. At each step, add the current element to currentSum.\\n\\n4. Check if currentSum is greater than targetSum. If it is, it means the current subarray sum is too large. In this case, move the left pointer to the right to reduce the subarray size until currentSum is less than or equal to targetSum.\\n\\n5. If currentSum becomes equal to targetSum, update maxLength to be the maximum of its current value and the length of the current subarray (right - left + 1).\\n\\n6. Repeat steps 3-5 until the right pointer reaches the end of the array.\\n\\n7. Finally, return n - maxLength as the minimum number of operations needed. If maxLength remains -1, return -1, indicating that n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the nums array twice: once to calculate targetSum and once to find the maximum subarray length. Each iteration takes O(n) time.\\nTherefore, the overall time complexity is O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the code uses a constant amount of extra space, regardless of the size of the input array nums.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int targetSum = 0;\\n        for (int num : nums) {\\n            targetSum += num;\\n        }\\n        targetSum -= x;\\n        if (targetSum < 0) return -1; // If x is greater than the sum of all elements, no solution exists.\\n\\n        int left = 0;\\n        int currentSum = 0;\\n        int maxLength = -1;\\n\\n        for (int right = 0; right < n; right++) {\\n            currentSum += nums[right];\\n\\n            while (currentSum > targetSum) {\\n                currentSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (currentSum == targetSum) {\\n                maxLength = max(maxLength, right - left + 1);\\n            }\\n        }\\n\\n        return (maxLength == -1) ? -1 : n - maxLength;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int targetSum = 0;\\n        for (int num : nums) {\\n            targetSum += num;\\n        }\\n        targetSum -= x;\\n        if (targetSum < 0) return -1; // If x is greater than the sum of all elements, no solution exists.\\n\\n        int left = 0;\\n        int currentSum = 0;\\n        int maxLength = -1;\\n\\n        for (int right = 0; right < n; right++) {\\n            currentSum += nums[right];\\n\\n            while (currentSum > targetSum) {\\n                currentSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (currentSum == targetSum) {\\n                maxLength = max(maxLength, right - left + 1);\\n            }\\n        }\\n\\n        return (maxLength == -1) ? -1 : n - maxLength;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066648,
                "title": "easy-sliding-window-technique",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n`minOperations` that takes a vector of integers nums and an integer x as input. The goal of this function is to find the minimum number of operations needed to make the sum of a contiguous subarray of nums equal to x. If it\\'s not possible to achieve the sum x, the function returns -1.\\n\\nHere\\'s an explanation of the approach used in this code:\\n\\n- Calculate the total sum of all elements in the nums vector and store it in the totsum variable.\\n\\n- Check if totsum is equal to x. If it is, return the size of the nums vector because the sum is already equal to x.\\n\\n- Calculate the difference between totsum and x and store it in the totsum variable. This represents the target sum we want to achieve by removing elements from the vector.\\n\\n- Initialize two pointers, s and e, both initially set to 0. These pointers represent the start and end of the current subarray we are considering.\\n\\n- Initialize variables sum and ans to 0. The sum variable will keep track of the sum of the current subarray, and ans will store the maximum length of a subarray with a sum equal to totsum.\\n\\n- Use a while loop with the e pointer to iterate through the elements of the nums vector.\\n\\n- Add the element at index e to the sum.\\n\\n- Use another while loop with the s pointer to adjust the subarray by removing elements from the beginning until sum is less than or equal to totsum.\\n\\n- Check if sum is equal to totsum. If it is, update ans with the maximum length of the subarray found so far (e - s + 1).\\n\\n- Increment the e pointer to consider the next element in the array.\\n\\n- Finally, return the result: if ans is still 0, return -1 (indicating that it\\'s not possible to achieve the sum x), otherwise, return nums.size() - ans, which represents the minimum number of operations needed to achieve the desired sum.\\n\\nThis code essentially uses a two-pointer sliding window approach to find the subarray with a sum equal to totsum, while keeping track of the maximum subarray length. If no such subarray is found, it returns -1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x)\\n    {\\n        int totsum=0;\\n        int s =0;int e =0;\\n        for(int i = 0 ;i<nums.size();i++)\\n        {\\n            totsum += nums[i];\\n        }\\n        if(totsum == x)\\n        return nums.size();\\n        totsum= totsum-x;\\n        int sum=0;\\n        int ans=0;\\n        while(e < nums.size())\\n        {\\n            sum += nums[e];\\n            while(s < e && sum >totsum)\\n            {\\n                sum -= nums[s++];\\n            }\\n            if(totsum == sum)\\n            {\\n                ans = max(ans,e-s+1);\\n            }\\n            e++;\\n        }  \\n        return ans == 0 ? -1: nums.size() - ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x)\\n    {\\n        int totsum=0;\\n        int s =0;int e =0;\\n        for(int i = 0 ;i<nums.size();i++)\\n        {\\n            totsum += nums[i];\\n        }\\n        if(totsum == x)\\n        return nums.size();\\n        totsum= totsum-x;\\n        int sum=0;\\n        int ans=0;\\n        while(e < nums.size())\\n        {\\n            sum += nums[e];\\n            while(s < e && sum >totsum)\\n            {\\n                sum -= nums[s++];\\n            }\\n            if(totsum == sum)\\n            {\\n                ans = max(ans,e-s+1);\\n            }\\n            e++;\\n        }  \\n        return ans == 0 ? -1: nums.size() - ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066630,
                "title": "very-easy-to-understand-solution-o-n-time-o-1-space",
                "content": "# Intuition\\nwe can take only elements which are present at corner i.e in starting and in last so we try to find window of (total sum of array - k) \\nso , n-k window, will contain sum == k. \\n\\n# Approach\\nhere, we are using sliding window approch to find the largest window of elments that contains (total sum of array - k) so the remaining corner parts will have the sum == k.\\n\\n# Complexity\\n- Time complexity:\\n<O(n)>\\n\\n- Space complexity:\\n<O(1)>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // PLEASE UPVOTE\\n        int  n = nums.size();\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int req = sum-x; \\n        if(req<0) return -1;\\n        int j = 0 ;\\n        int k = 0;\\n        int ans = -1e9;\\n        for(int i = 0 ;i< n ;i++){\\n            k+=nums[i];\\n            while(k>req){\\n                k-=nums[j];\\n                j++;\\n            }\\n            if(k==req){\\n                ans= max(ans,i-j+1);\\n            }\\n        }\\n        if(ans==-1e9) return -1;\\n        else return n- ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // PLEASE UPVOTE\\n        int  n = nums.size();\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        int req = sum-x; \\n        if(req<0) return -1;\\n        int j = 0 ;\\n        int k = 0;\\n        int ans = -1e9;\\n        for(int i = 0 ;i< n ;i++){\\n            k+=nums[i];\\n            while(k>req){\\n                k-=nums[j];\\n                j++;\\n            }\\n            if(k==req){\\n                ans= max(ans,i-j+1);\\n            }\\n        }\\n        if(ans==-1e9) return -1;\\n        else return n- ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066421,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n=len(nums)\\n        target=sum(nums)-x\\n        dp=[0]\\n        res=0\\n        for num in nums:\\n            res+=num\\n            dp.append(res)\\n        seen={v:i for i,v in enumerate(dp)}\\n        ans=-1\\n        for l_val,l_idx in seen.items():\\n            if l_val+target in seen:\\n                ans=max(seen[l_val+target]-l_idx,ans)\\n        if ans==-1:\\n            return ans\\n        else:\\n            return n-ans                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n=len(nums)\\n        target=sum(nums)-x\\n        dp=[0]\\n        res=0\\n        for num in nums:\\n            res+=num\\n            dp.append(res)\\n        seen={v:i for i,v in enumerate(dp)}\\n        ans=-1\\n        for l_val,l_idx in seen.items():\\n            if l_val+target in seen:\\n                ans=max(seen[l_val+target]-l_idx,ans)\\n        if ans==-1:\\n            return ans\\n        else:\\n            return n-ans                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725829,
                "title": "cpp-variation-max-len-window-with-target",
                "content": "```\\nint solve(vector<int>& nums, int target)\\n{\\n    // Initializing variables\\n    long long i = 0, j = 0, sum = 0, ans = INT_MIN, n = nums.size();\\n\\n    // Using a sliding window approach\\n    while (j < n)\\n    {\\n        sum += nums[j];  // Add the current element to the sum\\n\\n        if (sum == target) {\\n            ans = max(ans, j - i + 1);  // If the current sum matches the target, update the answer\\n        }\\n        else if (sum > target)\\n        {\\n            // If the current sum exceeds the target, move the left pointer (i) and decrease the sum\\n            while (sum > target)\\n            {\\n                sum -= nums[i];\\n                i++;\\n            }\\n\\n            if (sum == target) {\\n                ans = max(ans, j - i + 1);  // If the updated sum matches the target, update the answer\\n            }\\n        }\\n\\n        j++;  // Move the right pointer (j) to the next element\\n    }\\n\\n    return ans;  // Return the maximum length of subarray with sum equal to target\\n}\\n\\nint minOperations(vector<int>& nums, int x) {\\n    // Initializing variables\\n    long long total_sum = 0, n = nums.size();\\n\\n    // Calculate the total sum of the elements in nums\\n    for (auto x : nums)sli\\n        total_sum += x;\\n\\n    int target = total_sum - x;  // Calculate the target sum\\n\\n    if (target < 0)\\n        return -1;  // If the target is negative, it is not possible to obtain the target sum\\n\\n    if (target == 0)\\n        return n;  // If the target is zero, return the total number of elements\\n\\n    int window = solve(nums, target);  // Find the maximum length of subarray with sum equal to target\\n\\n    if (window == INT_MIN)\\n        return -1;  // If no subarray found with the target sum, return -1\\n\\n    return (n - window);  // Return the minimum number of operations required\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nint solve(vector<int>& nums, int target)\\n{\\n    // Initializing variables\\n    long long i = 0, j = 0, sum = 0, ans = INT_MIN, n = nums.size();\\n\\n    // Using a sliding window approach\\n    while (j < n)\\n    {\\n        sum += nums[j];  // Add the current element to the sum\\n\\n        if (sum == target) {\\n            ans = max(ans, j - i + 1);  // If the current sum matches the target, update the answer\\n        }\\n        else if (sum > target)\\n        {\\n            // If the current sum exceeds the target, move the left pointer (i) and decrease the sum\\n            while (sum > target)\\n            {\\n                sum -= nums[i];\\n                i++;\\n            }\\n\\n            if (sum == target) {\\n                ans = max(ans, j - i + 1);  // If the updated sum matches the target, update the answer\\n            }\\n        }\\n\\n        j++;  // Move the right pointer (j) to the next element\\n    }\\n\\n    return ans;  // Return the maximum length of subarray with sum equal to target\\n}\\n\\nint minOperations(vector<int>& nums, int x) {\\n    // Initializing variables\\n    long long total_sum = 0, n = nums.size();\\n\\n    // Calculate the total sum of the elements in nums\\n    for (auto x : nums)sli\\n        total_sum += x;\\n\\n    int target = total_sum - x;  // Calculate the target sum\\n\\n    if (target < 0)\\n        return -1;  // If the target is negative, it is not possible to obtain the target sum\\n\\n    if (target == 0)\\n        return n;  // If the target is zero, return the total number of elements\\n\\n    int window = solve(nums, target);  // Find the maximum length of subarray with sum equal to target\\n\\n    if (window == INT_MIN)\\n        return -1;  // If no subarray found with the target sum, return -1\\n\\n    return (n - window);  // Return the minimum number of operations required\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2215943,
                "title": "c-easy-sliding-window-solution-logical",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        if(sum < x){\\n            return -1; \\n        }\\n        \\n        if(sum == x){\\n            return nums.size();\\n        }\\n        \\n        int target = sum - x;\\n        int maxSize = 0; \\n        int currSum = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            currSum += nums[i];\\n            \\n            while(currSum > target){\\n                currSum -= nums[start];\\n                start++;\\n            }\\n            \\n            if(currSum == target){\\n                maxSize = max(maxSize, i-start+1);\\n            }\\n        }\\n        \\n        if(maxSize == 0){\\n            return -1;\\n        }\\n        else {\\n            return nums.size() - maxSize; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        \\n        if(sum < x){\\n            return -1; \\n        }\\n        \\n        if(sum == x){\\n            return nums.size();\\n        }\\n        \\n        int target = sum - x;\\n        int maxSize = 0; \\n        int currSum = 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            currSum += nums[i];\\n            \\n            while(currSum > target){\\n                currSum -= nums[start];\\n                start++;\\n            }\\n            \\n            if(currSum == target){\\n                maxSize = max(maxSize, i-start+1);\\n            }\\n        }\\n        \\n        if(maxSize == 0){\\n            return -1;\\n        }\\n        else {\\n            return nums.size() - maxSize; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137234,
                "title": "c-prefix-sum-dictionary",
                "content": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        long sum = 0;\\n        int max = -1;\\n        \\n        foreach (int num in nums) {\\n            sum += num;\\n        }\\n        \\n        long target = sum - x;\\n        Dictionary<long, int> dict = new Dictionary<long, int>();\\n        dict.Add(0, -1);\\n        sum = 0;\\n        \\n        for (int i = 0; i < nums.Length; i++) {\\n            sum += nums[i];\\n            dict.Add(sum, i);\\n            \\n            if (dict.ContainsKey(sum - target)) {\\n                max = Math.Max(max, i - dict[sum - target]);\\n            }\\n        }\\n        \\n        return (max == -1) ? -1 : nums.Length - max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        long sum = 0;\\n        int max = -1;\\n        \\n        foreach (int num in nums) {\\n            sum += num;\\n        }\\n        \\n        long target = sum - x;\\n        Dictionary<long, int> dict = new Dictionary<long, int>();\\n        dict.Add(0, -1);\\n        sum = 0;\\n        \\n        for (int i = 0; i < nums.Length; i++) {\\n            sum += nums[i];\\n            dict.Add(sum, i);\\n            \\n            if (dict.ContainsKey(sum - target)) {\\n                max = Math.Max(max, i - dict[sum - target]);\\n            }\\n        }\\n        \\n        return (max == -1) ? -1 : nums.Length - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137194,
                "title": "can-anybody-help-me-in-this-code-why-it-is-failing",
                "content": "**It is giving wrong answer in this test case**\\n[5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\\n565610\\n\\n```\\n  int minOperations(vector<int>& nums, int X) {\\n        \\n        \\n        int l=0;\\n        int h = nums.size()-1;\\n        int cnt=0;\\n        \\n        while(l<=h)\\n        {\\n            \\n            if(nums[l]>X) l++;\\n            if(nums[h]>X) h--;\\n            \\n          else if(X-nums[l] > X-nums[h])\\n          {\\n                X-=nums[h];\\n              h--;\\n              cnt++;\\n          }\\n            \\n            else\\n            {\\n                X-=nums[l];\\n                l++;\\n                cnt++;\\n            }\\n            \\n            \\n            \\n            \\n        }\\n        \\n        if(cnt!=0 and X==0)\\n        {\\n            return cnt;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n```\\n\\n**Thanks**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n  int minOperations(vector<int>& nums, int X) {\\n        \\n        \\n        int l=0;\\n        int h = nums.size()-1;\\n        int cnt=0;\\n        \\n        while(l<=h)\\n        {\\n            \\n            if(nums[l]>X) l++;\\n            if(nums[h]>X) h--;\\n            \\n          else if(X-nums[l] > X-nums[h])\\n          {\\n                X-=nums[h];\\n              h--;\\n              cnt++;\\n          }\\n            \\n            else\\n            {\\n                X-=nums[l];\\n                l++;\\n                cnt++;\\n            }\\n            \\n            \\n            \\n            \\n        }\\n        \\n        if(cnt!=0 and X==0)\\n        {\\n            return cnt;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2136961,
                "title": "javascript-js-solution-beats-100",
                "content": "JavaScript solution\\n\\n```\\nvar minOperations = function(nums, x) {\\n    const n = nums.length;\\n    const sum = nums.reduce((r, n) => r + n, 0);\\n    const target = sum - x;\\n\\n    let current = 0;\\n    let ans = -1;\\n    \\n    for (let l = 0, r = 0; r < n; r++) {\\n        current += nums[r];\\n        \\n        while (current > target) {\\n            current -= nums[l];\\n            l++;\\n        }\\n        \\n        if (current === target) {\\n            ans = Math.max(ans, r - l + 1);\\n        }\\n    }\\n\\n    return ans === -1 ? -1 : n - ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nvar minOperations = function(nums, x) {\\n    const n = nums.length;\\n    const sum = nums.reduce((r, n) => r + n, 0);\\n    const target = sum - x;\\n\\n    let current = 0;\\n    let ans = -1;\\n    \\n    for (let l = 0, r = 0; r < n; r++) {\\n        current += nums[r];\\n        \\n        while (current > target) {\\n            current -= nums[l];\\n            l++;\\n        }\\n        \\n        if (current === target) {\\n            ans = Math.max(ans, r - l + 1);\\n        }\\n    }\\n\\n    return ans === -1 ? -1 : n - ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062645,
                "title": "easy-cpp-prefix-sum-brute-force-partial-execute-top-down-timelimit-exceeded-explained",
                "content": "**Brute Force ( Which is not working for all cases ) using two pointer Approach**\\n\\n```\\nInitially I tought lets check from endings that by comparing two pointers left and right\\nbuy taking Maximum number and moving the pointer. It falis in the case of \\n\\n[3,1,1,4,4,1] k=5 here we can see as per logic it goes to select  initially 3 (i==0) as per\\ncases (nums[i]>=nums[j]) then it goes to select 1 and then again 1 which result \\nanswer 3 but correct answer is [4,1] but not [3,1,1] so I had seen other oproaches\\n```\\n\\n```\\n#define check(x) if(x==0){break;}\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int ans(0);\\n        int i(0),j(nums.size());\\n        while (i<j){\\n            if ( nums[j]>=nums[i] and nums[j]<=x ){\\n                j--;\\n                x-=nums[j];\\n                ans++;\\n            }\\n            \\n            check(x);\\n            \\n            if ( nums[i]>=nums[j] and nums[i]<=x ){\\n                j--;\\n                x-=nums[i];\\n                ans++;\\n            }\\n            i++;\\n            j--;\\n            check(x);\\n            \\n            \\n        }\\n        \\n        if(ans==0){\\n            return -1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**Using Prefix Sum Approach (highly recommend to do *Subarray Sum equals to k*)**\\n\\n```\\nHere  we are going to do same logic to find maximum subarray for totalsum-k which result our answer totallength-subarray\\n\\nfor example [3,1,1,4,4,1] k=5  there totalsum=14 so we are going to find 14-k=9 which uses same logic in Subarray sum for k(in the sense 14-k) logic \\n\\n```\\n\\n```\\n#define check(x) if(x==0){break;}\\n#define maxi(x,y) ((x>y)?x:y)\\n#define all(c) (c).begin(), (c).end()\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int sum(0);\\n        \\n        unordered_map<int,int> prefixsum;\\n\\n//      Here I had initalized prefixsum[0]=-1 beacuse to handle extreme cases as of left 0 index there will be no prefix sum in left side of array  \\n        prefixsum[0]=-1;\\n        \\n        int n(nums.size());\\n        \\n//         Extreme cases if last and first index is greater than x\\n        if( nums[0]>x and nums[n-1]>x )\\n            return -1;\\n        \\n        for( int i=0;i<n;i++ ){\\n            sum+=nums[i];\\n            prefixsum[sum]=i;\\n        }\\n        \\n//         if summ is less than x\\n        if( x>sum )\\n            return -1;\\n        \\n//         if sum is equal to x then no need to remove\\n        if( sum==x)\\n            return n;\\n        \\n        int presum=0;\\n        \\n        sum-=x;\\n        \\n        int longest(0);\\n        \\n        for( int i=0;i<n;i++ ){\\n            presum+=nums[i];\\n            \\n            if( prefixsum.count(presum-sum) ){\\n                \\n                longest=maxi(longest,i-prefixsum[presum-sum]);\\n            }\\n        }\\n        \\n//         if no sum is there just return -1 or return answer as we discussed\\n        return (longest==0)?-1:n-longest;\\n        \\n    }\\n};\\n```\\n\\n\\n**Top Down Approach ( which will take more time and show time limit exceeded ) but this will also solve problem**\\n\\n```\\nTop down dynamic approach will see all possible values and return answer\\n```\\n\\n```\\n#define check(x) if(x==0){break;}\\n#define maxi(x,y) ((x>y)?x:y)\\n#define mini(x,y) ((x<y)?x:y)\\n#define all(c) (c).begin(), (c).end()\\n\\nclass Solution {\\n    unordered_map<string,int> optimize;\\n    \\n    int topdown( vector<int>& nums, int x, int left, int right, int count){\\n        \\n        if( x==0 )   // sum found\\n            return count;\\n        \\n        if(x<0 or left>right )  // out of bounds\\n            return 1e6;\\n        \\n//         key is used to optimize tree inorder to avoid calculation of already calculated values\\n        string key= to_string(left)+\"*\"+to_string(right)+\"*\"+to_string(x);\\n        \\n//         check if already calculated tree\\n        if( optimize.count(key) )\\n            return optimize[key];\\n        \\n        int l = topdown( nums,x-nums[left],left+1,right,count+1);\\n        int r = topdown( nums,x-nums[right],left,right-1,count+1);\\n        \\n        \\n        return optimize[key]=min(l,r);\\n    }\\n    \\n    \\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n(nums.size());\\n        \\n        if(nums[0]>x and nums[n-1]>x)\\n            return -1;\\n        \\n        int sum(0);\\n        \\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        \\n        if( x>sum )\\n            return -1;\\n        \\n        if( x==sum )\\n            return n;\\n        \\n        int ans=topdown(nums,x,0,n-1,0);\\n        \\n        return ans>=1e6?-1:ans;\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nInitially I tought lets check from endings that by comparing two pointers left and right\\nbuy taking Maximum number and moving the pointer. It falis in the case of \\n\\n[3,1,1,4,4,1] k=5 here we can see as per logic it goes to select  initially 3 (i==0) as per\\ncases (nums[i]>=nums[j]) then it goes to select 1 and then again 1 which result \\nanswer 3 but correct answer is [4,1] but not [3,1,1] so I had seen other oproaches\\n```\n```\\n#define check(x) if(x==0){break;}\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int ans(0);\\n        int i(0),j(nums.size());\\n        while (i<j){\\n            if ( nums[j]>=nums[i] and nums[j]<=x ){\\n                j--;\\n                x-=nums[j];\\n                ans++;\\n            }\\n            \\n            check(x);\\n            \\n            if ( nums[i]>=nums[j] and nums[i]<=x ){\\n                j--;\\n                x-=nums[i];\\n                ans++;\\n            }\\n            i++;\\n            j--;\\n            check(x);\\n            \\n            \\n        }\\n        \\n        if(ans==0){\\n            return -1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nHere  we are going to do same logic to find maximum subarray for totalsum-k which result our answer totallength-subarray\\n\\nfor example [3,1,1,4,4,1] k=5  there totalsum=14 so we are going to find 14-k=9 which uses same logic in Subarray sum for k(in the sense 14-k) logic \\n\\n```\n```\\n#define check(x) if(x==0){break;}\\n#define maxi(x,y) ((x>y)?x:y)\\n#define all(c) (c).begin(), (c).end()\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int sum(0);\\n        \\n        unordered_map<int,int> prefixsum;\\n\\n//      Here I had initalized prefixsum[0]=-1 beacuse to handle extreme cases as of left 0 index there will be no prefix sum in left side of array  \\n        prefixsum[0]=-1;\\n        \\n        int n(nums.size());\\n        \\n//         Extreme cases if last and first index is greater than x\\n        if( nums[0]>x and nums[n-1]>x )\\n            return -1;\\n        \\n        for( int i=0;i<n;i++ ){\\n            sum+=nums[i];\\n            prefixsum[sum]=i;\\n        }\\n        \\n//         if summ is less than x\\n        if( x>sum )\\n            return -1;\\n        \\n//         if sum is equal to x then no need to remove\\n        if( sum==x)\\n            return n;\\n        \\n        int presum=0;\\n        \\n        sum-=x;\\n        \\n        int longest(0);\\n        \\n        for( int i=0;i<n;i++ ){\\n            presum+=nums[i];\\n            \\n            if( prefixsum.count(presum-sum) ){\\n                \\n                longest=maxi(longest,i-prefixsum[presum-sum]);\\n            }\\n        }\\n        \\n//         if no sum is there just return -1 or return answer as we discussed\\n        return (longest==0)?-1:n-longest;\\n        \\n    }\\n};\\n```\n```\\nTop down dynamic approach will see all possible values and return answer\\n```\n```\\n#define check(x) if(x==0){break;}\\n#define maxi(x,y) ((x>y)?x:y)\\n#define mini(x,y) ((x<y)?x:y)\\n#define all(c) (c).begin(), (c).end()\\n\\nclass Solution {\\n    unordered_map<string,int> optimize;\\n    \\n    int topdown( vector<int>& nums, int x, int left, int right, int count){\\n        \\n        if( x==0 )   // sum found\\n            return count;\\n        \\n        if(x<0 or left>right )  // out of bounds\\n            return 1e6;\\n        \\n//         key is used to optimize tree inorder to avoid calculation of already calculated values\\n        string key= to_string(left)+\"*\"+to_string(right)+\"*\"+to_string(x);\\n        \\n//         check if already calculated tree\\n        if( optimize.count(key) )\\n            return optimize[key];\\n        \\n        int l = topdown( nums,x-nums[left],left+1,right,count+1);\\n        int r = topdown( nums,x-nums[right],left,right-1,count+1);\\n        \\n        \\n        return optimize[key]=min(l,r);\\n    }\\n    \\n    \\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n(nums.size());\\n        \\n        if(nums[0]>x and nums[n-1]>x)\\n            return -1;\\n        \\n        int sum(0);\\n        \\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        \\n        if( x>sum )\\n            return -1;\\n        \\n        if( x==sum )\\n            return n;\\n        \\n        int ans=topdown(nums,x,0,n-1,0);\\n        \\n        return ans>=1e6?-1:ans;\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045072,
                "title": "simple-c-code-o-n-time-o-1-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int left = -1, right = n-1, tmp = x, store = INT_MAX;\\n        while(tmp > 0 && left < n-1)\\n        {\\n            left++;\\n            tmp -= nums[left];\\n        }\\n        if(tmp == 0)\\n        {\\n            store = left+1;\\n        }\\n        while(left < right)\\n        {\\n            if(tmp < 0 && left > -1)\\n            {\\n                tmp += nums[left];\\n                left--;\\n            }\\n            else if(tmp > 0 && right > -1)\\n            {\\n                tmp -= nums[right];\\n                right--;\\n            }\\n            else if(tmp == 0)\\n            {\\n                int calc = n-right+left;\\n                store = min(store,calc);\\n                if(left > -1)\\n                {\\n                    tmp += nums[left];\\n                    left--;\\n                }\\n                if(right > -1)\\n                {\\n                    tmp -= nums[right];\\n                    right--;   \\n                }\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(store == INT_MAX)\\n            store = -1;\\n        return store;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int left = -1, right = n-1, tmp = x, store = INT_MAX;\\n        while(tmp > 0 && left < n-1)\\n        {\\n            left++;\\n            tmp -= nums[left];\\n        }\\n        if(tmp == 0)\\n        {\\n            store = left+1;\\n        }\\n        while(left < right)\\n        {\\n            if(tmp < 0 && left > -1)\\n            {\\n                tmp += nums[left];\\n                left--;\\n            }\\n            else if(tmp > 0 && right > -1)\\n            {\\n                tmp -= nums[right];\\n                right--;\\n            }\\n            else if(tmp == 0)\\n            {\\n                int calc = n-right+left;\\n                store = min(store,calc);\\n                if(left > -1)\\n                {\\n                    tmp += nums[left];\\n                    left--;\\n                }\\n                if(right > -1)\\n                {\\n                    tmp -= nums[right];\\n                    right--;   \\n                }\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(store == INT_MAX)\\n            store = -1;\\n        return store;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815278,
                "title": "python-easy-to-read-and-understand",
                "content": "* Recursion:\\n```\\nclass Solution:\\n    def solve(self, nums, x, cnt):\\n        if x == 0:\\n            return cnt\\n        if len(nums) == 0:\\n            return float(\"inf\")\\n        x1 = self.solve(nums[1:], x-nums[0], cnt+1)\\n        x2 = self.solve(nums[:-1], x-nums[-1], cnt+1)\\n        return min(x1, x2)\\n    \\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        ans = self.solve(nums, x, 0)\\n        return -1 if ans == float(\"inf\") else ans\\n```\\n* Memoization\\n```\\nclass Solution:\\n    def solve(self, nums, x, cnt, d):\\n        if x == 0:\\n            return cnt\\n        if len(nums) == 0:\\n            return float(\"inf\")\\n        if (x, cnt) in d:\\n            return d[(x, cnt)]\\n        x1 = self.solve(nums[1:], x-nums[0], cnt+1, d)\\n        x2 = self.solve(nums[:-1], x-nums[-1], cnt+1, d)\\n        d[(x, cnt)] = min(x1, x2)\\n        return d[(x, cnt)]\\n    \\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        ans = self.solve(nums, x, 0, {})\\n        return -1 if ans == float(\"inf\") else ans\\n```\\n* Memoization\\n```\\nclass Solution:\\n    def solve(self, nums, i, j, x, cnt, d):\\n        if x == 0:\\n            return cnt\\n        if i > j:\\n            return float(\"inf\")\\n        if (i, j, x, cnt) in d:\\n            return d[(i, j, x, cnt)]\\n        x1 = self.solve(nums, i+1, j, x-nums[i], cnt+1, d)\\n        x2 = self.solve(nums, i, j-1, x-nums[j], cnt+1, d)\\n        d[(i, j, x, cnt)] = min(x1, x2)\\n        return d[(i, j, x, cnt)]\\n    \\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        ans = self.solve(nums, 0, len(nums)-1, x, 0, {})\\n        return -1 if ans == float(\"inf\") else ans",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, nums, x, cnt):\\n        if x == 0:\\n            return cnt\\n        if len(nums) == 0:\\n            return float(\"inf\")\\n        x1 = self.solve(nums[1:], x-nums[0], cnt+1)\\n        x2 = self.solve(nums[:-1], x-nums[-1], cnt+1)\\n        return min(x1, x2)\\n    \\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        ans = self.solve(nums, x, 0)\\n        return -1 if ans == float(\"inf\") else ans\\n```\n```\\nclass Solution:\\n    def solve(self, nums, x, cnt, d):\\n        if x == 0:\\n            return cnt\\n        if len(nums) == 0:\\n            return float(\"inf\")\\n        if (x, cnt) in d:\\n            return d[(x, cnt)]\\n        x1 = self.solve(nums[1:], x-nums[0], cnt+1, d)\\n        x2 = self.solve(nums[:-1], x-nums[-1], cnt+1, d)\\n        d[(x, cnt)] = min(x1, x2)\\n        return d[(x, cnt)]\\n    \\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        ans = self.solve(nums, x, 0, {})\\n        return -1 if ans == float(\"inf\") else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145652,
                "title": "two-python-solutions",
                "content": "* sliding window\\n\\nclass Solution:\\n\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        s = sum(nums)-x\\n        ans =float(\"inf\")\\n        left = right = 0\\n        curr = 0\\n        while(right<len(nums)): # for every left index, check whether there is any subarray that it sum is s\\n            curr+=nums[right]\\n            while(curr>s and left<=right):\\n                curr-=nums[left]\\n                left+=1\\n            if curr == s:\\n                ans = min(ans, len(nums)-(right-left+1))\\n            right+=1\\n        return ans if ans!=float(\"inf\") else -1\\n\\t\\t\\n\\t\\t\\n* using dictionary \\t\\t\\n\\t\\t\\nclass Solution:\\n\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        s = sum(nums)-x\\n        ans =float(\"inf\")\\n        d = {0:-1,}\\n        for i in range(len(nums)): # find the longest subarray that its sum is s\\n            nums[i]+=nums[i-1] if i!=0 else 0\\n            d[nums[i]] = i\\n            if nums[i]-s in d:\\n                ans = min(ans, len(nums)-(i-d[nums[i]-s]))\\n        return ans if ans!=float(\"inf\") else -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        s = sum(nums)-x\\n        ans =float(\"inf\")\\n        left = right = 0\\n        curr = 0\\n        while(right<len(nums)): # for every left index, check whether there is any subarray that it sum is s\\n            curr+=nums[right]\\n            while(curr>s and left<=right):\\n                curr-=nums[left]\\n                left+=1\\n            if curr == s:\\n                ans = min(ans, len(nums)-(right-left+1))\\n            right+=1\\n        return ans if ans!=float(\"inf\") else -1\\n\\t\\t\\n\\t\\t\\n* using dictionary \\t\\t\\n\\t\\t\\nclass Solution:\\n\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        s = sum(nums)-x\\n        ans =float(\"inf\")\\n        d = {0:-1,}",
                "codeTag": "Java"
            },
            {
                "id": 1058790,
                "title": "dfs-just-for-your-curiosity-tle",
                "content": "Just as the title mentioned. We can use the dfs approach, \\n\\n```\\nclass Solution {\\n    Integer[][][] dp;\\n    public int minOperations(int[] nums, int x) {\\n        dp = new Integer[nums.length][nums.length][x+1];\\n        int res =dfs(nums, x, 0, nums.length-1);\\n        return res==Integer.MAX_VALUE? -1: res;\\n    }\\n    public int dfs(int[] nums, int target, int l, int r){\\n        if(target == 0) return l + nums.length-r-1;\\n        if(target<0) return Integer.MAX_VALUE;\\n        if(l>r) return Integer.MAX_VALUE;\\n        if(dp[l][r][target]!= null) return dp[l][r][target];\\n\\n        int left = dfs(nums, target-nums[l], l+1, r);\\n        int right = dfs(nums, target-nums[r], l, r-1);\\n        dp[l][r][target] = Math.min(left, right);\\n        return Math.min(left, right);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Integer[][][] dp;\\n    public int minOperations(int[] nums, int x) {\\n        dp = new Integer[nums.length][nums.length][x+1];\\n        int res =dfs(nums, x, 0, nums.length-1);\\n        return res==Integer.MAX_VALUE? -1: res;\\n    }\\n    public int dfs(int[] nums, int target, int l, int r){\\n        if(target == 0) return l + nums.length-r-1;\\n        if(target<0) return Integer.MAX_VALUE;\\n        if(l>r) return Integer.MAX_VALUE;\\n        if(dp[l][r][target]!= null) return dp[l][r][target];\\n\\n        int left = dfs(nums, target-nums[l], l+1, r);\\n        int right = dfs(nums, target-nums[r], l, r-1);\\n        dp[l][r][target] = Math.min(left, right);\\n        return Math.min(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017299,
                "title": "minimum-operations-to-reduce-x-to-zero-c-finding-maximum-sub-array-99-beat",
                "content": "As stated by the first hint: \"Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\" \\n\\nThis code uses a sliding window to find the maximum subarray.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int l = 0;\\n        int r = 0;\\n        \\n        int total = 0; // total sum of array\\n        for (int n : nums) {\\n            total += n;\\n        }\\n        \\n        int goal = total - x; // sub-array sum that corresponds to solving the problem (prefix + suffix = x)\\n        \\n        int arrSum = 0; // sum of sub-array\\n        \\n        int minOps = INT_MAX;\\n        bool exists = false;\\n        \\n        while (l != nums.size() - 1) {\\n            if (arrSum == goal) {\\n                exists = true;\\n                if (nums.size() - (r - l) < minOps) minOps = nums.size() - (r - l);\\n                \\n                if (r < nums.size()) arrSum += nums[r++];\\n                else break;  \\n            }\\n            else if (arrSum < goal && r < nums.size()) arrSum += nums[r++];\\n            else if (arrSum > goal && l < nums.size()) arrSum -= nums[l++];\\n            else break;\\n        }\\n        \\n        if (exists) return minOps;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int l = 0;\\n        int r = 0;\\n        \\n        int total = 0; // total sum of array\\n        for (int n : nums) {\\n            total += n;\\n        }\\n        \\n        int goal = total - x; // sub-array sum that corresponds to solving the problem (prefix + suffix = x)\\n        \\n        int arrSum = 0; // sum of sub-array\\n        \\n        int minOps = INT_MAX;\\n        bool exists = false;\\n        \\n        while (l != nums.size() - 1) {\\n            if (arrSum == goal) {\\n                exists = true;\\n                if (nums.size() - (r - l) < minOps) minOps = nums.size() - (r - l);\\n                \\n                if (r < nums.size()) arrSum += nums[r++];\\n                else break;  \\n            }\\n            else if (arrSum < goal && r < nums.size()) arrSum += nums[r++];\\n            else if (arrSum > goal && l < nums.size()) arrSum -= nums[l++];\\n            else break;\\n        }\\n        \\n        if (exists) return minOps;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016764,
                "title": "a-few-solutions",
                "content": "**Daily Solutions 2022-06-11:**\\n\\nUse inversion.  Find the maximum length subarray `i..j` sliding window sum equal to the inverted target `T`, ie. the sum of the input array `A` minus `K` as the `best` candidate `cand`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minOperations(A: IntArray, K: Int): Int {\\n        var T = A.sum() - K\\n        if (T < 0)\\n            return -1\\n        var best = -1\\n        var N = A.size\\n        var i = 0\\n        var j = 0\\n        var t = 0\\n        while (j < N) {\\n            t += A[j++]\\n            while (T < t)\\n                t -= A[i++]\\n            if (T == t) {\\n                var cand = j - i\\n                best = Math.max(best, cand)\\n            }\\n        }\\n        return if (0 <= best) N - best else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (A, K, t = 0, best = -1) => {\\n    let T = _.sum(A) - K;\\n    if (T < 0)\\n        return -1;\\n    let N = A.length,\\n        i = 0,\\n        j = 0;\\n    while (j < N) {\\n        t += A[j++];\\n        while (T < t)\\n            t -= A[i++];\\n        if (T == t) {\\n            let cand = j - i;\\n            best = Math.max(best, cand);\\n        }\\n    }\\n    return 0 <= best ? N - best : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], K: int, t = 0, best = -1) -> int:\\n        T = sum(A) - K\\n        if T < 0:\\n            return -1\\n        N = len(A)\\n        i = 0\\n        j = 0\\n        while j < N:\\n            t += A[j]; j += 1\\n            while T < t:\\n                t -= A[i]; i += 1\\n            if T == t:\\n                cand = j - i\\n                best = max(best, cand)\\n        return N - best if 0 <= best else -1\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_operations(A: Vec<i32>, K: i32) -> i32 {\\n        let T = A.iter().sum::<i32>() - K;\\n        if T < 0 {\\n            return -1;\\n        }\\n        let mut best = -1;\\n        let N = A.len();\\n        let mut i = 0;\\n        let mut j = 0;\\n        let mut t = 0;\\n        while j < N {\\n            t += A[j]; j += 1;\\n            while T < t {\\n                t -= A[i]; i += 1;\\n            }\\n            if T == t {\\n                let cand = j - i;\\n                best = max(best, cand as i32);\\n            }\\n        }\\n        if 0 <= best { N as i32 - best } else { -1 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minOperations(VI& A, int K, int t = 0, int best = -1) {\\n        auto T = accumulate(A.begin(), A.end(), 0) - K;\\n        if (T < 0)\\n            return -1;\\n        int N = A.size(),\\n            i = 0,\\n            j = 0;\\n        while (j < N) {\\n            t += A[j++];\\n            while (T < t)\\n                t -= A[i++];\\n            if (T == t) {\\n                auto cand = j - i;\\n                best = max(best, cand);\\n            }\\n        }\\n        return 0 <= best ? N - best : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Legacy Solutions:**\\n\\nLet `N` be the cardinality of the input array `A`.  Since `N` can be at most `1e5`, we need to write an algorithm with near-linear asymptotic bound to avoid TLE (thus BFS/DFS are *not* candidates for this problem).  However, a sliding window can be used to find the longest \"middle\" subarray of `A` who\\'s sum can be excluded from the sum of `A` in an attempt to find the shortest length \"left/right\" subarrays of `A` with sum equal to the input `K`.  Let `T` be the target value for the \"middle\" subarray of `A` from `[i..j)`, ie. from `i` inclusive to `j` non-inclusive.  Then we can perform a linear scan of `A` to find the longest (ie. `best`) window length who\\'s sum `t` is equal to target `T`.\\n\\n![image](https://assets.leetcode.com/users/images/76f8775d-5734-4aa1-a0c8-f70ab8da50e9_1610645433.264774.png)\\n\\n**Examples:** these are \"snapshots in time\" of the linear scan of `A` when the `best` middle window `A[i..j)` to exclude has been found.  Notice the left subarray is empty for example 1, and also notice there does *not* exist a valid middle window for example 2.\\n\\n![image](https://assets.leetcode.com/users/images/dc01cbf6-1992-4661-8139-d01676a5f3e7_1610645450.3427644.png)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minOperations(A: IntArray, K: Int): Int {\\n        var best = 0\\n        var T = A.sum() - K\\n        var N = A.size\\n        if (T == 0)                            // \\uD83D\\uDC8E corner case: if sum(A) == K, then minimum is N\\n            return N\\n        var i = 0\\n        var j = 0\\n        var t = 0\\n        while (j < N) {\\n            while (i < j && T < t + A[j])      // \\u2B50\\uFE0F maintain invariant: sliding window total t does NOT exceed target T\\n                t -= A[i++]\\n            t += A[j++]\\n            if (t == T)\\n                best = Math.max(best, j - i)   // \\uD83D\\uDCB0 best \"middle\" subarray length [i..j), ie. from i inclusive to j non-inclusive\\n        }\\n        return if (0 < best) N - best else -1  // \\uD83C\\uDFAF minimum \"left/right\" subarray length == N - best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (A, K, best = 0) => {\\n    let T = _.sum(A) - K,\\n        N = A.length;\\n    if (!T)                                // \\uD83D\\uDC8E corner case: if sum(A) == K, then minimum is N\\n        return N;\\n    let i = 0,\\n        j = 0,\\n        t = 0;\\n    while (j < N) {\\n        while (i < j && T < t + A[j])      // \\u2B50\\uFE0F maintain invariant: sliding window total t does NOT exceed target T\\n            t -= A[i++];\\n        t += A[j++];\\n        if (t == T)\\n            best = Math.max(best, j - i);  // \\uD83D\\uDCB0 best \"middle\" subarray length [i..j), ie. from i inclusive to j non-inclusive\\n    }\\n    return best ? N - best : -1;           // \\uD83C\\uDFAF minimum \"left/right\" subarray length == N - best\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], K: int, best = 0) -> int:\\n        T = sum(A) - K\\n        N = len(A)\\n        if not T:                            # \\uD83D\\uDC8E corner case: if sum(A) == K, then minimum is N\\n            return N\\n        i = 0\\n        j = 0\\n        t = 0\\n        while j < N:\\n            while i < j and T < t + A[j]:    # \\u2B50\\uFE0F maintain invariant: sliding window total t does NOT exceed target T\\n                t -= A[i]; i += 1\\n            t += A[j]; j += 1\\n            if t == T:\\n                best = max(best, j - i)      # \\uD83D\\uDCB0 best \"middle\" subarray length [i..j), ie. from i inclusive to j non-inclusive\\n        return -1 if not best else N - best  # \\uD83C\\uDFAF minimum \"left/right\" subarray length == N - best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minOperations(VI& A, int K, int best = 0) {\\n        int T = accumulate(A.begin(), A.end(), 0) - K;\\n        int N = A.size();\\n        if (!T)                            // \\uD83D\\uDC8E corner case: if sum(A) == K, then minimum is N\\n            return N;\\n        auto i = 0,\\n             j = 0,\\n             t = 0;\\n        while (j < N) {\\n            while (i < j && T < t + A[j])  // \\u2B50\\uFE0F maintain invariant: sliding window total t does NOT exceed target T\\n                t -= A[i++];\\n            t += A[j++];\\n            if (t == T)\\n                best = max(best, j - i);   // \\uD83D\\uDCB0 best \"middle\" subarray length [i..j), ie. from i inclusive to j non-inclusive\\n        }\\n        return best ? N - best : -1;       // \\uD83C\\uDFAF minimum \"left/right\" subarray length == N - best\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minOperations(A: IntArray, K: Int): Int {\\n        var T = A.sum() - K\\n        if (T < 0)\\n            return -1\\n        var best = -1\\n        var N = A.size\\n        var i = 0\\n        var j = 0\\n        var t = 0\\n        while (j < N) {\\n            t += A[j++]\\n            while (T < t)\\n                t -= A[i++]\\n            if (T == t) {\\n                var cand = j - i\\n                best = Math.max(best, cand)\\n            }\\n        }\\n        return if (0 <= best) N - best else -1\\n    }\\n}\\n```\n```\\nlet minOperations = (A, K, t = 0, best = -1) => {\\n    let T = _.sum(A) - K;\\n    if (T < 0)\\n        return -1;\\n    let N = A.length,\\n        i = 0,\\n        j = 0;\\n    while (j < N) {\\n        t += A[j++];\\n        while (T < t)\\n            t -= A[i++];\\n        if (T == t) {\\n            let cand = j - i;\\n            best = Math.max(best, cand);\\n        }\\n    }\\n    return 0 <= best ? N - best : -1;\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], K: int, t = 0, best = -1) -> int:\\n        T = sum(A) - K\\n        if T < 0:\\n            return -1\\n        N = len(A)\\n        i = 0\\n        j = 0\\n        while j < N:\\n            t += A[j]; j += 1\\n            while T < t:\\n                t -= A[i]; i += 1\\n            if T == t:\\n                cand = j - i\\n                best = max(best, cand)\\n        return N - best if 0 <= best else -1\\n```\n```\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_operations(A: Vec<i32>, K: i32) -> i32 {\\n        let T = A.iter().sum::<i32>() - K;\\n        if T < 0 {\\n            return -1;\\n        }\\n        let mut best = -1;\\n        let N = A.len();\\n        let mut i = 0;\\n        let mut j = 0;\\n        let mut t = 0;\\n        while j < N {\\n            t += A[j]; j += 1;\\n            while T < t {\\n                t -= A[i]; i += 1;\\n            }\\n            if T == t {\\n                let cand = j - i;\\n                best = max(best, cand as i32);\\n            }\\n        }\\n        if 0 <= best { N as i32 - best } else { -1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minOperations(VI& A, int K, int t = 0, int best = -1) {\\n        auto T = accumulate(A.begin(), A.end(), 0) - K;\\n        if (T < 0)\\n            return -1;\\n        int N = A.size(),\\n            i = 0,\\n            j = 0;\\n        while (j < N) {\\n            t += A[j++];\\n            while (T < t)\\n                t -= A[i++];\\n            if (T == t) {\\n                auto cand = j - i;\\n                best = max(best, cand);\\n            }\\n        }\\n        return 0 <= best ? N - best : -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun minOperations(A: IntArray, K: Int): Int {\\n        var best = 0\\n        var T = A.sum() - K\\n        var N = A.size\\n        if (T == 0)                            // \\uD83D\\uDC8E corner case: if sum(A) == K, then minimum is N\\n            return N\\n        var i = 0\\n        var j = 0\\n        var t = 0\\n        while (j < N) {\\n            while (i < j && T < t + A[j])      // \\u2B50\\uFE0F maintain invariant: sliding window total t does NOT exceed target T\\n                t -= A[i++]\\n            t += A[j++]\\n            if (t == T)\\n                best = Math.max(best, j - i)   // \\uD83D\\uDCB0 best \"middle\" subarray length [i..j), ie. from i inclusive to j non-inclusive\\n        }\\n        return if (0 < best) N - best else -1  // \\uD83C\\uDFAF minimum \"left/right\" subarray length == N - best\\n    }\\n}\\n```\n```\\nlet minOperations = (A, K, best = 0) => {\\n    let T = _.sum(A) - K,\\n        N = A.length;\\n    if (!T)                                // \\uD83D\\uDC8E corner case: if sum(A) == K, then minimum is N\\n        return N;\\n    let i = 0,\\n        j = 0,\\n        t = 0;\\n    while (j < N) {\\n        while (i < j && T < t + A[j])      // \\u2B50\\uFE0F maintain invariant: sliding window total t does NOT exceed target T\\n            t -= A[i++];\\n        t += A[j++];\\n        if (t == T)\\n            best = Math.max(best, j - i);  // \\uD83D\\uDCB0 best \"middle\" subarray length [i..j), ie. from i inclusive to j non-inclusive\\n    }\\n    return best ? N - best : -1;           // \\uD83C\\uDFAF minimum \"left/right\" subarray length == N - best\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int], K: int, best = 0) -> int:\\n        T = sum(A) - K\\n        N = len(A)\\n        if not T:                            # \\uD83D\\uDC8E corner case: if sum(A) == K, then minimum is N\\n            return N\\n        i = 0\\n        j = 0\\n        t = 0\\n        while j < N:\\n            while i < j and T < t + A[j]:    # \\u2B50\\uFE0F maintain invariant: sliding window total t does NOT exceed target T\\n                t -= A[i]; i += 1\\n            t += A[j]; j += 1\\n            if t == T:\\n                best = max(best, j - i)      # \\uD83D\\uDCB0 best \"middle\" subarray length [i..j), ie. from i inclusive to j non-inclusive\\n        return -1 if not best else N - best  # \\uD83C\\uDFAF minimum \"left/right\" subarray length == N - best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minOperations(VI& A, int K, int best = 0) {\\n        int T = accumulate(A.begin(), A.end(), 0) - K;\\n        int N = A.size();\\n        if (!T)                            // \\uD83D\\uDC8E corner case: if sum(A) == K, then minimum is N\\n            return N;\\n        auto i = 0,\\n             j = 0,\\n             t = 0;\\n        while (j < N) {\\n            while (i < j && T < t + A[j])  // \\u2B50\\uFE0F maintain invariant: sliding window total t does NOT exceed target T\\n                t -= A[i++];\\n            t += A[j++];\\n            if (t == T)\\n                best = max(best, j - i);   // \\uD83D\\uDCB0 best \"middle\" subarray length [i..j), ie. from i inclusive to j non-inclusive\\n        }\\n        return best ? N - best : -1;       // \\uD83C\\uDFAF minimum \"left/right\" subarray length == N - best\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016733,
                "title": "c-solution-o-n-time-o-1-memory",
                "content": "**Logic:**\\nWe need to pick l elements from left and r elements from right such that the sum is equal to x subject to minimizing (l+r)\\n1) First of all pick elements from left till sum is less than x\\n2) Then keep on subtracting element from left and add element from right one by one based on condition:\\n```\\nif(sum >= x)\\n\\tsum -= a[l--];\\nif(sum < x)\\n\\tsum+= a[r--];\\n```\\n3) Check if at any moment if the sum is exactly equal to x then take minimum of the result.\\n\\n\\n**Complete Solution:**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a, int x) {\\n        int n = a.size();\\n        int i=0,c=0;\\n        while(i < n && c < x)\\n        {\\n            c += a[i++];\\n        }\\n        \\n        if(i == n)\\n        {\\n            return c == x ? n : -1;\\n        }\\n        \\n        int l = i-1;\\n        int r = n-1;\\n        int res = (c == x ? i : INT_MAX);\\n        while(r > l)\\n        {\\n            if(c >= x && l >= 0)\\n                c -= a[l--];\\n            if(c < x)\\n                c += a[r--];\\n            if(c == x)\\n            {\\n                res = min(res, l+n-r);\\n            }\\n            if(c >= x && l < 0) \\n                break;\\n        }\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nif(sum >= x)\\n\\tsum -= a[l--];\\nif(sum < x)\\n\\tsum+= a[r--];\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a, int x) {\\n        int n = a.size();\\n        int i=0,c=0;\\n        while(i < n && c < x)\\n        {\\n            c += a[i++];\\n        }\\n        \\n        if(i == n)\\n        {\\n            return c == x ? n : -1;\\n        }\\n        \\n        int l = i-1;\\n        int r = n-1;\\n        int res = (c == x ? i : INT_MAX);\\n        while(r > l)\\n        {\\n            if(c >= x && l >= 0)\\n                c -= a[l--];\\n            if(c < x)\\n                c += a[r--];\\n            if(c == x)\\n            {\\n                res = min(res, l+n-r);\\n            }\\n            if(c >= x && l < 0) \\n                break;\\n        }\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016719,
                "title": "javascript-prefix-sum-with-hashmap",
                "content": "Time: O(N)\\nSpace: O(N)\\n```javascript\\nvar minOperations = function(nums, x) {\\n    const sum = nums.reduce((acc, cur) => acc + cur, 0);\\n    const target = sum - x;\\n    const map = new Map([[0, -1]]);\\n    \\n    if(target < 0) return -1;\\n    if(!target) return nums.length;\\n    \\n    let prefixSum = 0, maxLen = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        prefixSum += nums[i];\\n        map.set(prefixSum, i);\\n        const startSum = prefixSum - target;\\n        if(map.has(startSum)) maxLen = Math.max(maxLen, i-map.get(startSum))\\n    }\\n    return maxLen === -Infinity ? -1 : nums.length-maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```javascript\\nvar minOperations = function(nums, x) {\\n    const sum = nums.reduce((acc, cur) => acc + cur, 0);\\n    const target = sum - x;\\n    const map = new Map([[0, -1]]);\\n    \\n    if(target < 0) return -1;\\n    if(!target) return nums.length;\\n    \\n    let prefixSum = 0, maxLen = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        prefixSum += nums[i];\\n        map.set(prefixSum, i);\\n        const startSum = prefixSum - target;\\n        if(map.has(startSum)) maxLen = Math.max(maxLen, i-map.get(startSum))\\n    }\\n    return maxLen === -Infinity ? -1 : nums.length-maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016664,
                "title": "javascript-clean-sliding-window-solution",
                "content": "Approach:\\nFind the longest subarray where: sum of subarray = sum of the array - x\\n\\nTime complexity: O(N)\\nSpace complexity: O(1)\\n```javascript\\nvar minOperations = function(nums, x) {\\n    const sum = nums.reduce((acc, cur) => acc + cur, 0);\\n    const target = sum - x;\\n    \\n    if(target < 0) return -1;\\n    if(!target) return nums.length;\\n    \\n    let start = 0, runningSum = 0, maxLen = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        runningSum += nums[i];\\n        while(runningSum > target) runningSum -= nums[start++];\\n        if(runningSum === target) maxLen = Math.max(maxLen, i-start+1);\\n    }\\n    return maxLen === -Infinity ? -1 : nums.length-maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```javascript\\nvar minOperations = function(nums, x) {\\n    const sum = nums.reduce((acc, cur) => acc + cur, 0);\\n    const target = sum - x;\\n    \\n    if(target < 0) return -1;\\n    if(!target) return nums.length;\\n    \\n    let start = 0, runningSum = 0, maxLen = -Infinity;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        runningSum += nums[i];\\n        while(runningSum > target) runningSum -= nums[start++];\\n        if(runningSum === target) maxLen = Math.max(maxLen, i-start+1);\\n    }\\n    return maxLen === -Infinity ? -1 : nums.length-maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016245,
                "title": "rust-o-n-cumulative-sums-hashmap-iterators",
                "content": "```rust\\nuse std::iter::once;\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>, x: i32) -> i32 {\\n        let forward: HashMap<_, _> = sums(nums.iter()).enumerate().map(|(i, s)| (s, i)).collect();\\n        let n = nums.len() as i32;\\n\\n        sums(nums.iter().rev()).enumerate().filter_map(|(i, s)|\\n            forward.get(&(x - s)).map(|&j| (i + j) as i32).filter(|&k| k <= n)\\n        ).min().unwrap_or(-1)\\n    }\\n}\\nfn sums<\\'a>(xs: impl Iterator<Item=&\\'a i32> + \\'a) -> impl Iterator<Item=i32> + \\'a {\\n    once(0).chain(xs.scan(0, |s, &x| {\\n        *s += x;\\n        Some(*s)\\n    }))\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```rust\\nuse std::iter::once;\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>, x: i32) -> i32 {\\n        let forward: HashMap<_, _> = sums(nums.iter()).enumerate().map(|(i, s)| (s, i)).collect();\\n        let n = nums.len() as i32;\\n\\n        sums(nums.iter().rev()).enumerate().filter_map(|(i, s)|\\n            forward.get(&(x - s)).map(|&j| (i + j) as i32).filter(|&k| k <= n)\\n        ).min().unwrap_or(-1)\\n    }\\n}\\nfn sums<\\'a>(xs: impl Iterator<Item=&\\'a i32> + \\'a) -> impl Iterator<Item=i32> + \\'a {\\n    once(0).chain(xs.scan(0, |s, &x| {\\n        *s += x;\\n        Some(*s)\\n    }))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016237,
                "title": "java-o-n-solution-with-prefix-sum-and-hashmap",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int len = nums.length;\\n        // only left;\\n        int min = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>(); \\n        int[] left_sum = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            if (i != 0) {\\n                left_sum[i] = left_sum[i-1] + nums[i];\\n            } else {\\n                left_sum[0] = nums[0];\\n            }\\n            if (left_sum[i] == x) {\\n                min = Math.min(min, i + 1);\\n            }\\n            map.put(left_sum[i], i + 1);\\n        }\\n        if (left_sum[len-1] < x) return -1;\\n        int[] right_sum = new int[len];\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (i != len - 1) {\\n                right_sum[i] = right_sum[i+1] + nums[i];\\n            } else {\\n                right_sum[i] = nums[len-1];\\n            }\\n            if (right_sum[i] == x) {\\n                min = Math.min(min, len - i);\\n            }\\n            if (map.containsKey(x - right_sum[i])) {\\n                min = Math.min(min, len - i + map.get(x - right_sum[i]));\\n            }\\n        }\\n        return (min == Integer.MAX_VALUE) ? -1 : min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int len = nums.length;\\n        // only left;\\n        int min = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>(); \\n        int[] left_sum = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            if (i != 0) {\\n                left_sum[i] = left_sum[i-1] + nums[i];\\n            } else {\\n                left_sum[0] = nums[0];\\n            }\\n            if (left_sum[i] == x) {\\n                min = Math.min(min, i + 1);\\n            }\\n            map.put(left_sum[i], i + 1);\\n        }\\n        if (left_sum[len-1] < x) return -1;\\n        int[] right_sum = new int[len];\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (i != len - 1) {\\n                right_sum[i] = right_sum[i+1] + nums[i];\\n            } else {\\n                right_sum[i] = nums[len-1];\\n            }\\n            if (right_sum[i] == x) {\\n                min = Math.min(min, len - i);\\n            }\\n            if (map.containsKey(x - right_sum[i])) {\\n                min = Math.min(min, len - i + map.get(x - right_sum[i]));\\n            }\\n        }\\n        return (min == Integer.MAX_VALUE) ? -1 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935985,
                "title": "still-getting-tle-recursion-memorization-solved-using-two-sum-java",
                "content": "Still getting TLE on this approach: \\n```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    public int minOperations(int[] nums, int x) {\\n        int min = recur(nums,x,0,nums.length-1);\\n        if(min==Integer.MAX_VALUE) return -1;\\n        else return min;\\n    }\\n    public int recur(int[] arr, int x, int i, int j){\\n        if(x==0){\\n            return 0;\\n        }\\n        if(i>j || x<0 ) return Integer.MAX_VALUE;;\\n        \\n        String key = i+\"-\"+j+\"-\"+x;\\n        \\n        if(map.containsKey(key)) return map.get(key);\\n        \\n        int  min = Math.min(recur(arr,x-arr[i],i+1,j), recur(arr,x-arr[j],i,j-1));\\n        \\n        if(min!= Integer.MAX_VALUE){\\n            min = min+1;\\n        }\\n        map.put(key,min);\\n        return min;\\n    }\\n}\\n```\\n\\n**Solved using simple two-sum problem approach \\n**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        \\n        int sum =0;\\n        \\n        for(int i=0;i<n && x>=sum;i++){\\n            sum +=nums[i];\\n            left[i] = sum;\\n        }\\n        sum = 0;\\n        for(int i=n-1;i>=0 && x>=sum;i--){\\n            sum +=nums[i];\\n            right[i] = sum;\\n        }\\n        \\n        //use two sum approach to find matching pair \\n        int dist = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,0);\\n        for(int i=0;i<n;i++){\\n            if(left[i]<=0) break;\\n            map.put(left[i],i+1);\\n            if(x-left[i]==0){\\n                dist = i+1;break;\\n            }\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(right[i]<0) break;\\n            if(map.containsKey(x-right[i]) && map.get(x-right[i])< i ){\\n                dist = Math.min(dist, map.get(x-right[i])+n-i);\\n            }\\n        }\\n        \\n        return dist!=Integer.MAX_VALUE?dist:-1;\\n        \\n        \\n        \\n    }\\n   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> map = new HashMap<>();\\n    public int minOperations(int[] nums, int x) {\\n        int min = recur(nums,x,0,nums.length-1);\\n        if(min==Integer.MAX_VALUE) return -1;\\n        else return min;\\n    }\\n    public int recur(int[] arr, int x, int i, int j){\\n        if(x==0){\\n            return 0;\\n        }\\n        if(i>j || x<0 ) return Integer.MAX_VALUE;;\\n        \\n        String key = i+\"-\"+j+\"-\"+x;\\n        \\n        if(map.containsKey(key)) return map.get(key);\\n        \\n        int  min = Math.min(recur(arr,x-arr[i],i+1,j), recur(arr,x-arr[j],i,j-1));\\n        \\n        if(min!= Integer.MAX_VALUE){\\n            min = min+1;\\n        }\\n        map.put(key,min);\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        \\n        int sum =0;\\n        \\n        for(int i=0;i<n && x>=sum;i++){\\n            sum +=nums[i];\\n            left[i] = sum;\\n        }\\n        sum = 0;\\n        for(int i=n-1;i>=0 && x>=sum;i--){\\n            sum +=nums[i];\\n            right[i] = sum;\\n        }\\n        \\n        //use two sum approach to find matching pair \\n        int dist = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,0);\\n        for(int i=0;i<n;i++){\\n            if(left[i]<=0) break;\\n            map.put(left[i],i+1);\\n            if(x-left[i]==0){\\n                dist = i+1;break;\\n            }\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(right[i]<0) break;\\n            if(map.containsKey(x-right[i]) && map.get(x-right[i])< i ){\\n                dist = Math.min(dist, map.get(x-right[i])+n-i);\\n            }\\n        }\\n        \\n        return dist!=Integer.MAX_VALUE?dist:-1;\\n        \\n        \\n        \\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069340,
                "title": "video-solution-explanation-with-drawings-in-depth-java-c",
                "content": "# Intuition, approach and complexity discussed in detail in video solution\\nhttps://youtu.be/QsRT1-t0wPQ\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int sz = nums.size();\\n        vector<int> prefSum(sz);\\n        \\n        for(int indx = 0; indx < sz; indx++){\\n            if(indx == 0) \\n                prefSum[indx] = nums[indx];\\n            else\\n                prefSum[indx] = nums[indx] + prefSum[indx -  1];\\n        }\\n        int suffixSum = 0, minOps = INT_MAX;\\n        \\n        for(int indx = sz - 1; indx > - 1; indx--){\\n            \\n            int target = x - suffixSum;\\n            \\n            if(target == 0){\\n                int rightOps = sz - 1 - indx;\\n                minOps = min(rightOps, minOps);\\n                continue;\\n            }\\n            \\n            int left = 0, right = indx;\\n            int leftDelIndx = -1;\\n            while(left <= right){\\n                int leftOpIndx = left + (right - left)/2;\\n                if(prefSum[leftOpIndx] == target){\\n                    leftDelIndx = leftOpIndx;\\n                    break;\\n                }\\n                else if(prefSum[leftOpIndx] < target){\\n                    left = leftOpIndx + 1;\\n                }\\n                else{\\n                    right = leftOpIndx - 1;\\n                }\\n            }\\n            \\n            if(leftDelIndx != -1){\\n                int rightOps = sz - 1 - indx;\\n                int leftOps = leftDelIndx + 1;\\n                minOps = min(leftOps + rightOps, minOps);\\n            }\\n            \\n            suffixSum += nums[indx];\\n        }\\n        \\n        return minOps == INT_MAX ? -1 : minOps;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sz = nums.length, prefSum[] =  new int[sz];\\n        for(int indx = 0; indx < sz; indx++){\\n           if(indx == 0) \\n            prefSum[indx] = nums[indx];\\n           else\\n            prefSum[indx] = nums[indx] + prefSum[indx -  1];\\n        }\\n\\n\\n        int suffixSum = 0, minOps = Integer.MAX_VALUE;\\n\\n        for(int indx = sz - 1; indx > - 1; indx--){\\n            int target = x - suffixSum;\\n            if(target == 0){\\n                int rightOps = sz - 1 - indx;\\n                minOps = Math.min(rightOps, minOps);\\n                continue;\\n            }\\n            int left = 0, right = indx;\\n            int leftDelIndx = -1;\\n            while(left <= right){\\n                int leftOpIndx = left + (right - left)/2;\\n                if(prefSum[leftOpIndx] == target){\\n                    leftDelIndx = leftOpIndx;\\n                    break;\\n                }else if(prefSum[leftOpIndx] < target){\\n                    left = leftOpIndx + 1;\\n                }else{\\n                    right = leftOpIndx - 1;\\n                }\\n            }\\n            if(leftDelIndx != -1){\\n                int rightOps = sz-1 - indx;\\n                int leftOps = leftDelIndx+1;\\n                minOps = Math.min(minOps, rightOps + leftOps);\\n            }\\n            suffixSum += nums[indx];\\n        }\\n        return minOps == Integer.MAX_VALUE ? -1 : minOps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int sz = nums.size();\\n        vector<int> prefSum(sz);\\n        \\n        for(int indx = 0; indx < sz; indx++){\\n            if(indx == 0) \\n                prefSum[indx] = nums[indx];\\n            else\\n                prefSum[indx] = nums[indx] + prefSum[indx -  1];\\n        }\\n        int suffixSum = 0, minOps = INT_MAX;\\n        \\n        for(int indx = sz - 1; indx > - 1; indx--){\\n            \\n            int target = x - suffixSum;\\n            \\n            if(target == 0){\\n                int rightOps = sz - 1 - indx;\\n                minOps = min(rightOps, minOps);\\n                continue;\\n            }\\n            \\n            int left = 0, right = indx;\\n            int leftDelIndx = -1;\\n            while(left <= right){\\n                int leftOpIndx = left + (right - left)/2;\\n                if(prefSum[leftOpIndx] == target){\\n                    leftDelIndx = leftOpIndx;\\n                    break;\\n                }\\n                else if(prefSum[leftOpIndx] < target){\\n                    left = leftOpIndx + 1;\\n                }\\n                else{\\n                    right = leftOpIndx - 1;\\n                }\\n            }\\n            \\n            if(leftDelIndx != -1){\\n                int rightOps = sz - 1 - indx;\\n                int leftOps = leftDelIndx + 1;\\n                minOps = min(leftOps + rightOps, minOps);\\n            }\\n            \\n            suffixSum += nums[indx];\\n        }\\n        \\n        return minOps == INT_MAX ? -1 : minOps;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sz = nums.length, prefSum[] =  new int[sz];\\n        for(int indx = 0; indx < sz; indx++){\\n           if(indx == 0) \\n            prefSum[indx] = nums[indx];\\n           else\\n            prefSum[indx] = nums[indx] + prefSum[indx -  1];\\n        }\\n\\n\\n        int suffixSum = 0, minOps = Integer.MAX_VALUE;\\n\\n        for(int indx = sz - 1; indx > - 1; indx--){\\n            int target = x - suffixSum;\\n            if(target == 0){\\n                int rightOps = sz - 1 - indx;\\n                minOps = Math.min(rightOps, minOps);\\n                continue;\\n            }\\n            int left = 0, right = indx;\\n            int leftDelIndx = -1;\\n            while(left <= right){\\n                int leftOpIndx = left + (right - left)/2;\\n                if(prefSum[leftOpIndx] == target){\\n                    leftDelIndx = leftOpIndx;\\n                    break;\\n                }else if(prefSum[leftOpIndx] < target){\\n                    left = leftOpIndx + 1;\\n                }else{\\n                    right = leftOpIndx - 1;\\n                }\\n            }\\n            if(leftDelIndx != -1){\\n                int rightOps = sz-1 - indx;\\n                int leftOps = leftDelIndx+1;\\n                minOps = Math.min(minOps, rightOps + leftOps);\\n            }\\n            suffixSum += nums[indx];\\n        }\\n        return minOps == Integer.MAX_VALUE ? -1 : minOps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068577,
                "title": "prefix-sum-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou basically wanna know whether it is possible to remove some elements from the beggining and some from the end (possibly zero) to create a sum of X.\\nThink of it as a `two sum` problem except the elements are to be picked from two seperate arrays instead of one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a prefix sum array.\\n- Create a suffix sum array.\\n- Now create two hasmaps to store the `prefix sum` till an index against the value of the index. Do the same thing for the `suffix sum`.\\n- Now, iterate the `prefix sum map` and check if in the `suffix sum map`, there exists an element with the value `x - it.first` (where it is the iterator on the `prefix sum map`). If there does, then `it.second + suffix sum map[x - it.first]` is a possible answer.\\n- *Another important thing to note is that if `prefix sum map[x]` or `suffix sum map[x]` exists, then that can also be a possible answer.*\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n       unordered_map<int, int> mps, mss;\\n       int ans = INT_MAX;\\n\\n       vector<int> ps, ss;\\n        ps.push_back(nums[0]);\\n        ss.push_back(nums[nums.size()-1]);\\n\\n       for(int i=1; i<nums.size(); i++){\\n           ps.push_back(ps[ps.size()-1] + nums[i]);\\n       }\\n\\n       for(int i=nums.size()-2; i>=0; i--){\\n           ss.push_back(ss[ss.size()-1] + nums[i]);\\n       }\\n\\n       for(int i=0; i<ps.size(); i++){\\n           mps[ps[i]] = i+1;\\n        //    cout<<\"mps[]\"<<ps[i]<<\"= \"<<mps[ps[i]]<<endl;\\n       }\\n\\n       for(int i=0; i<ss.size(); i++){\\n           mss[ss[i]] = i+1;\\n        //    cout<<\"mss[]\"<<ss[i]<<\"= \"<<mss[ss[i]]<<endl;\\n       }\\n\\n       for(auto it: mps){\\n           if(it.first==x){\\n               ans = min(ans, it.second);\\n               continue;\\n           }\\n           if(mss[x-it.first] && it.second+mss[x-it.first]<=nums.size()){\\n               ans = min(ans, it.second + mss[x-it.first]);\\n           }\\n       }\\n\\n       if(mss[x]) ans = min(ans, mss[x]);\\n\\n\\n       if(ans==INT_MAX) return -1;\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n       unordered_map<int, int> mps, mss;\\n       int ans = INT_MAX;\\n\\n       vector<int> ps, ss;\\n        ps.push_back(nums[0]);\\n        ss.push_back(nums[nums.size()-1]);\\n\\n       for(int i=1; i<nums.size(); i++){\\n           ps.push_back(ps[ps.size()-1] + nums[i]);\\n       }\\n\\n       for(int i=nums.size()-2; i>=0; i--){\\n           ss.push_back(ss[ss.size()-1] + nums[i]);\\n       }\\n\\n       for(int i=0; i<ps.size(); i++){\\n           mps[ps[i]] = i+1;\\n        //    cout<<\"mps[]\"<<ps[i]<<\"= \"<<mps[ps[i]]<<endl;\\n       }\\n\\n       for(int i=0; i<ss.size(); i++){\\n           mss[ss[i]] = i+1;\\n        //    cout<<\"mss[]\"<<ss[i]<<\"= \"<<mss[ss[i]]<<endl;\\n       }\\n\\n       for(auto it: mps){\\n           if(it.first==x){\\n               ans = min(ans, it.second);\\n               continue;\\n           }\\n           if(mss[x-it.first] && it.second+mss[x-it.first]<=nums.size()){\\n               ans = min(ans, it.second + mss[x-it.first]);\\n           }\\n       }\\n\\n       if(mss[x]) ans = min(ans, mss[x]);\\n\\n\\n       if(ans==INT_MAX) return -1;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4068466,
                "title": "minimum-operations-to-reduce-x-to-zero-c-solution",
                "content": "# Complexity\\n- Time Complexity : O(N)\\n\\n- Space Complexity : O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int totalSum = accumulate(begin(nums), end(nums), 0);\\n        int reqSum = totalSum-x;\\n        \\n        if(reqSum < 0) return -1;\\n        if(reqSum == 0) return nums.size();\\n        \\n        int sum = 0, start = 0, end = 0, res = 0, n = nums.size();\\n                \\n        while(end < nums.size()){\\n            sum += nums[end];\\n            \\n            while(sum > reqSum){\\n                sum -= nums[start];\\n                start++;\\n            }\\n            \\n            if(sum==reqSum) res = max(res, end-start+1);\\n            end++;\\n        }\\n        \\n        return res == 0 ? -1 : n-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int totalSum = accumulate(begin(nums), end(nums), 0);\\n        int reqSum = totalSum-x;\\n        \\n        if(reqSum < 0) return -1;\\n        if(reqSum == 0) return nums.size();\\n        \\n        int sum = 0, start = 0, end = 0, res = 0, n = nums.size();\\n                \\n        while(end < nums.size()){\\n            sum += nums[end];\\n            \\n            while(sum > reqSum){\\n                sum -= nums[start];\\n                start++;\\n            }\\n            \\n            if(sum==reqSum) res = max(res, end-start+1);\\n            end++;\\n        }\\n        \\n        return res == 0 ? -1 : n-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067586,
                "title": "hindi-me-jano-kaise-use-krenge-binary-search-sliding-window-and-prefix-sum-iss-question-me",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        //see humko min operation me x ko 0 tk reduce krna hai.\\n        //so, edge cases- if starting ele and last ele of nums is greater than x then it is impossible\\n        // to reduce x to zero and if total sum also greater than x then it is impossible\\n        \\n        //general case has three parts\\n        //1. just take elements from start and search lower bound and prefix will increase the complexity\\n        //2. just take elements from end and 3. just take element from start and end.\\n        \\n        int n=nums.size()-1;\\n        //edge case\\n        if(x<min(nums[0],nums[n]))return -1;\\n        \\n        vector<int>leftr(n+1),rightr(n+1);\\n        leftr[0]=nums[0],rightr[0]=nums[n];\\n        for(int i=1;i<=n;i++)leftr[i]=leftr[i-1]+nums[i];\\n        for(int i=n-1;i>=0;i--)rightr[n-i]=rightr[n-i-1]+nums[i];\\n        int ans=INT_MAX;\\n        //ele from start\\n        int a=lower_bound(leftr.begin(),leftr.end(),x)-leftr.begin();\\n        //ele from end\\n        int b=lower_bound(rightr.begin(),rightr.end(),x)-rightr.begin();\\n        //store min\\n        if(a!=n+1)if(leftr[a]==x)ans=min(ans,a+1);\\n        if(b!=n+1)if(rightr[b]==x)ans=min(ans,b+1);\\n        \\n        int j=0;\\n        //edge case -2\\n        if(rightr[n]<x)return -1;\\n        while(j<=n)\\n        {\\n            if(x<leftr[j])break;\\n            else\\n            {\\n                //general case-3\\n                int c=lower_bound(rightr.begin(),rightr.end(),x-leftr[j])-rightr.begin();\\n                if(c!=n+1)if(leftr[j]+rightr[c]==x)ans=min(c+1+j+1,ans);\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        //see humko min operation me x ko 0 tk reduce krna hai.\\n        //so, edge cases- if starting ele and last ele of nums is greater than x then it is impossible\\n        // to reduce x to zero and if total sum also greater than x then it is impossible\\n        \\n        //general case has three parts\\n        //1. just take elements from start and search lower bound and prefix will increase the complexity\\n        //2. just take elements from end and 3. just take element from start and end.\\n        \\n        int n=nums.size()-1;\\n        //edge case\\n        if(x<min(nums[0],nums[n]))return -1;\\n        \\n        vector<int>leftr(n+1),rightr(n+1);\\n        leftr[0]=nums[0],rightr[0]=nums[n];\\n        for(int i=1;i<=n;i++)leftr[i]=leftr[i-1]+nums[i];\\n        for(int i=n-1;i>=0;i--)rightr[n-i]=rightr[n-i-1]+nums[i];\\n        int ans=INT_MAX;\\n        //ele from start\\n        int a=lower_bound(leftr.begin(),leftr.end(),x)-leftr.begin();\\n        //ele from end\\n        int b=lower_bound(rightr.begin(),rightr.end(),x)-rightr.begin();\\n        //store min\\n        if(a!=n+1)if(leftr[a]==x)ans=min(ans,a+1);\\n        if(b!=n+1)if(rightr[b]==x)ans=min(ans,b+1);\\n        \\n        int j=0;\\n        //edge case -2\\n        if(rightr[n]<x)return -1;\\n        while(j<=n)\\n        {\\n            if(x<leftr[j])break;\\n            else\\n            {\\n                //general case-3\\n                int c=lower_bound(rightr.begin(),rightr.end(),x-leftr[j])-rightr.begin();\\n                if(c!=n+1)if(leftr[j]+rightr[c]==x)ans=min(c+1+j+1,ans);\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067525,
                "title": "java-two-pointers-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int n = nums.length;\\n        int target = Arrays.stream(nums).sum() - x;\\n\\n        if (target < 0) {\\n            return -1; // If the target is negative, it\\'s impossible to reach zero.\\n        }\\n\\n        int left = 0;\\n        int sum = 0;\\n        int minOperations = Integer.MAX_VALUE;\\n\\n        for (int right = 0; right < n; right++) {\\n            sum += nums[right];\\n\\n            while (sum > target) {\\n                sum -= nums[left];\\n                left++;\\n            }\\n\\n            if (sum == target) {\\n                minOperations = Math.min(minOperations, n - (right - left + 1));\\n            }\\n        }\\n\\n        return minOperations == Integer.MAX_VALUE ? -1 : minOperations;\\n    }\\n}\\n    \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int n = nums.length;\\n        int target = Arrays.stream(nums).sum() - x;\\n\\n        if (target < 0) {\\n            return -1; // If the target is negative, it\\'s impossible to reach zero.\\n        }\\n\\n        int left = 0;\\n        int sum = 0;\\n        int minOperations = Integer.MAX_VALUE;\\n\\n        for (int right = 0; right < n; right++) {\\n            sum += nums[right];\\n\\n            while (sum > target) {\\n                sum -= nums[left];\\n                left++;\\n            }\\n\\n            if (sum == target) {\\n                minOperations = Math.min(minOperations, n - (right - left + 1));\\n            }\\n        }\\n\\n        return minOperations == Integer.MAX_VALUE ? -1 : minOperations;\\n    }\\n}\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067455,
                "title": "easy-to-understand-2-basic-checks-enough-hope-for-youtw",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Step-1 -> Calculate input array sum\\nStep-2 -> Iterate input array and take currSum to 0 and maxLength to -1\\nStep-3 -> Use right for adding elements to currSum\\nStep-4 -> If currSum exceeds sum-x(target) use left for reducing currSum from left and increment it\\nStep-5 -> If currSum equals sum-x update maxLength with right-left+1\\nStep-6 -> If maxLength is still -1 return it else return input array length - maxLength*\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        // find sum of input array\\n        int sum = 0;\\n        for(int num:nums) sum += num;\\n\\n        // take maxLength as -1 and currSum as 0\\n        int maxLength = -1, currSum = 0;\\n\\n        // loop over input array\\n        // left for reducing from currSum & right for adding to currSum\\n        for(int left=0,right=0; right<nums.length; right++){\\n            currSum += nums[right];\\n            // what if currSum exceeds sum-x(target) reduce left\\n            while(left <= right && currSum > sum-x){\\n                currSum -= nums[left++];\\n            }\\n            // what if currSum equals sum-x(target) update maxLength\\n            if(currSum == sum-x){\\n                maxLength = Math.max(maxLength,right-left+1);\\n            }   \\n        }\\n        // edge cases has to be handled here\\n        return maxLength == -1 ? -1 : nums.length-maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        // find sum of input array\\n        int sum = 0;\\n        for(int num:nums) sum += num;\\n\\n        // take maxLength as -1 and currSum as 0\\n        int maxLength = -1, currSum = 0;\\n\\n        // loop over input array\\n        // left for reducing from currSum & right for adding to currSum\\n        for(int left=0,right=0; right<nums.length; right++){\\n            currSum += nums[right];\\n            // what if currSum exceeds sum-x(target) reduce left\\n            while(left <= right && currSum > sum-x){\\n                currSum -= nums[left++];\\n            }\\n            // what if currSum equals sum-x(target) update maxLength\\n            if(currSum == sum-x){\\n                maxLength = Math.max(maxLength,right-left+1);\\n            }   \\n        }\\n        // edge cases has to be handled here\\n        return maxLength == -1 ? -1 : nums.length-maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067328,
                "title": "simplest-solution-believe-in-you",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\nStep-1 -> Calculate the total sum of nums, Set maxLength = -1\\n          and currSum = 0\\nStep-2 -> Iterate over nums with left (l) and right (r) pointers\\n          until nums.length\\nStep-3 -> Add elements to currSum as r(for adding) moves forward.\\nStep-4 -> While currSum > sum - x (if currSum exceeds target reduce\\n          from left), adjust currSum (by reducing l) and move l\\nStep-5 -> If currSum equals sum - x, update maxLength.\\nStep-6 -> Return -1 if maxLength remains -1, else return \\n          nums.length - maxLength.\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        int maxLength = -1, currSum = 0;\\n        // Here l -> left r -> right\\n        for (int l=0, r=0; r<nums.length; r++) {\\n            currSum += nums[r];\\n            while (l <= r && currSum > sum - x) currSum -= nums[l++];\\n            if (currSum == sum - x) {\\n                maxLength = Math.max(maxLength, r-l+1);\\n            }\\n        }\\n        return maxLength == -1 ? -1 : nums.length - maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nStep-1 -> Calculate the total sum of nums, Set maxLength = -1\\n          and currSum = 0\\nStep-2 -> Iterate over nums with left (l) and right (r) pointers\\n          until nums.length\\nStep-3 -> Add elements to currSum as r(for adding) moves forward.\\nStep-4 -> While currSum > sum - x (if currSum exceeds target reduce\\n          from left), adjust currSum (by reducing l) and move l\\nStep-5 -> If currSum equals sum - x, update maxLength.\\nStep-6 -> Return -1 if maxLength remains -1, else return \\n          nums.length - maxLength.\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for (int num : nums) sum += num;\\n        int maxLength = -1, currSum = 0;\\n        // Here l -> left r -> right\\n        for (int l=0, r=0; r<nums.length; r++) {\\n            currSum += nums[r];\\n            while (l <= r && currSum > sum - x) currSum -= nums[l++];\\n            if (currSum == sum - x) {\\n                maxLength = Math.max(maxLength, r-l+1);\\n            }\\n        }\\n        return maxLength == -1 ? -1 : nums.length - maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067167,
                "title": "easy-and-simple-code-with-proper-explaination-for-daily-challenge-sliding-window",
                "content": "```\\n/*\\n         Motive:-\\n         now we need to find subarrays in which sum of subarray is equal to the value of sum\\n         \\n         Approach:-\\n         when we get maximum length of such subarray , we can say our answer would be arr.size()-max_length , since this remaining subarray would have sum exactly equal to x and would also have the minimum length\\n        \\n*/\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        \\n        // motive is to find maximum length of subarray of sum = (sum of array) - x\\n        \\n        int ArraySum = accumulate(nums.begin(),nums.end(),0);\\n        \\n        int sum = ArraySum - x;\\n        \\n        if(sum<0){\\n            return -1;\\n        }\\n        \\n        \\n        \\n        int max_len = -1;\\n        \\n        int ssf=0;\\n        \\n        for(int i=0,j=0;i<n;i++){\\n            if(ssf+nums[i]<=sum){\\n                ssf+=nums[i];\\n                \\n                if(ssf==sum){\\n                    max_len = max(max_len,i-j+1);\\n                }\\n            }\\n            else if(ssf+nums[i]>sum){\\n                ssf+=nums[i];\\n                \\n                while(ssf>sum)\\n                ssf-=nums[j++];\\n\\n                if(ssf==sum){\\n                    max_len = max(max_len,i-j+1);\\n                }\\n            }\\n        }\\n        \\n        if(max_len==-1){\\n            return -1;\\n        }\\n        else{\\n            return n - max_len;\\n        }\\n    }\\n};\\n```\\nPlease upvote if you like the solution , motivates me a lot",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n/*\\n         Motive:-\\n         now we need to find subarrays in which sum of subarray is equal to the value of sum\\n         \\n         Approach:-\\n         when we get maximum length of such subarray , we can say our answer would be arr.size()-max_length , since this remaining subarray would have sum exactly equal to x and would also have the minimum length\\n        \\n*/\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        \\n        // motive is to find maximum length of subarray of sum = (sum of array) - x\\n        \\n        int ArraySum = accumulate(nums.begin(),nums.end(),0);\\n        \\n        int sum = ArraySum - x;\\n        \\n        if(sum<0){\\n            return -1;\\n        }\\n        \\n        \\n        \\n        int max_len = -1;\\n        \\n        int ssf=0;\\n        \\n        for(int i=0,j=0;i<n;i++){\\n            if(ssf+nums[i]<=sum){\\n                ssf+=nums[i];\\n                \\n                if(ssf==sum){\\n                    max_len = max(max_len,i-j+1);\\n                }\\n            }\\n            else if(ssf+nums[i]>sum){\\n                ssf+=nums[i];\\n                \\n                while(ssf>sum)\\n                ssf-=nums[j++];\\n\\n                if(ssf==sum){\\n                    max_len = max(max_len,i-j+1);\\n                }\\n            }\\n        }\\n        \\n        if(max_len==-1){\\n            return -1;\\n        }\\n        else{\\n            return n - max_len;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066775,
                "title": "1658-minimum-operations-to-reduce-x-to-zero-daily-leetcode",
                "content": "Code:\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int target = 0;\\n        for (int i : nums) {\\n            target += i;\\n        }\\n        target -= x;\\n\\n        if (target < 0) {\\n            return -1;\\n        }\\n\\n        int left = 0;\\n        int curSum = 0;\\n        int maxSubLength = INT_MIN;\\n        int n = nums.size();\\n\\n        for (int right = 0; right < n; right++) {\\n            curSum += nums[right];\\n\\n            while (curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (curSum == target) {\\n                maxSubLength = std::max(maxSubLength, right - left + 1);\\n            }\\n        }\\n        return maxSubLength == INT_MIN ? -1 : n - maxSubLength;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int target = 0;\\n        for (int i : nums) {\\n            target += i;\\n        }\\n        target -= x;\\n\\n        if (target < 0) {\\n            return -1;\\n        }\\n\\n        int left = 0;\\n        int curSum = 0;\\n        int maxSubLength = INT_MIN;\\n        int n = nums.size();\\n\\n        for (int right = 0; right < n; right++) {\\n            curSum += nums[right];\\n\\n            while (curSum > target) {\\n                curSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (curSum == target) {\\n                maxSubLength = std::max(maxSubLength, right - left + 1);\\n            }\\n        }\\n        return maxSubLength == INT_MIN ? -1 : n - maxSubLength;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066520,
                "title": "c-solution-for-minimum-operations-to-reduce-x-to-zero-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the minimum number of operations to reduce a given sum \\u2018x\\u2019 by removing elements from either end of the array. The goal is to find the maximum subarray that sums up to nums.Sum() - x.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.\\tCalculate the total sum of the array (totalSum).\\n2.\\tFind the target sum by subtracting \\u2018x\\u2019 from totalSum.\\n3.\\tUse a sliding window approach to find the maximum subarray sum that equals the target sum.\\n4.\\tKeep track of the minimum length of subarray with the target sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is O(n) where n is the length of the input array \\u2018nums\\u2019. The algorithm iterates through the array once using a sliding window approach.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as we are using a constant amount of extra space, not dependent on the size of the input array. We only use a few integer variables to keep track of the window and the result.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        int targetSum = nums.Sum() - x;\\n\\n        if (targetSum < 0)\\n            return -1;\\n        \\n        int leftSum = 0, rightSum = 0;\\n        int minLength = int.MaxValue;\\n        int left = 0, right = 0;\\n\\n        while (right < nums.Length) {\\n            rightSum += nums[right];\\n            right++;\\n\\n            while (rightSum > targetSum && left < nums.Length) {\\n                rightSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (rightSum == targetSum)\\n                minLength = Math.Min(minLength, nums.Length - (right - left));\\n        }\\n\\n        return minLength == int.MaxValue ? -1 : minLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        int targetSum = nums.Sum() - x;\\n\\n        if (targetSum < 0)\\n            return -1;\\n        \\n        int leftSum = 0, rightSum = 0;\\n        int minLength = int.MaxValue;\\n        int left = 0, right = 0;\\n\\n        while (right < nums.Length) {\\n            rightSum += nums[right];\\n            right++;\\n\\n            while (rightSum > targetSum && left < nums.Length) {\\n                rightSum -= nums[left];\\n                left++;\\n            }\\n\\n            if (rightSum == targetSum)\\n                minLength = Math.Min(minLength, nums.Length - (right - left));\\n        }\\n\\n        return minLength == int.MaxValue ? -1 : minLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342773,
                "title": "c-java-python-use-largest-subarray-length-whose-sum-equals-k-sliding-window",
                "content": "We can easily solve this problem if we consider the following approach - \\n\\n**Minimum operations required to reduce x to zero = n - size of the longest subarray with sum equals sumNums - x**\\nwhere, \\nn = number of elements in nums\\nsumNums = sum of elements in nums\\n\\nIf you still don\\'t understand why this is correct, let me show you an example -\\n\\nnums = [3,2,20,1,1,3], x = 10, n = 6\\nsumNums = 30, \\nk = sumNums - x = 20\\nlargest subarray size with sum k in nums (lsa) = 1\\nHence, answer = n - lsa = 6 - 1 = 5 which is our desired output.\\n\\n*\\u2714 Time complexity: O(n)\\n\\u2714 Space complexity: O(1)*\\n\\nImplementations - \\n\\n\\u2611 C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // to find the minimum operations to reduce x to zero using elements in nums\\n        // we can use the result of the longest subarray with sum k inside nums where k = sum of elements - x\\n        int n = nums.size(), sum = 0;\\n        for(int num : nums) sum += num;\\n        \\n        int k = sum - x, currentSum = 0, longestSubArr = 0;\\n        if(k == 0) return n;\\n        // the 2 pointers we will use in this variable sliding window: i <= j\\n        int i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            currentSum += nums[j];\\n            if(currentSum > k)\\n                while(currentSum > k and i <= j) {\\n                    currentSum -= nums[i];\\n                    i++;\\n                }\\n            if(currentSum == k)\\n                longestSubArr = max(longestSubArr, j - i + 1);\\n        }\\n        // shortest subarray with sum = x is n - longest subarray with sum = sum - x\\n        return longestSubArr == 0 ? -1 : n - longestSubArr;\\n    }\\n};\\n```\\n\\n\\u2611 Python: \\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        sumArr, n = 0, len(nums)\\n        for num in nums: \\n            sumArr += num\\n        k, currentSum, longestSubArr, i = sumArr - x, 0, 0, 0\\n        if k == 0: return n\\n        for j in range(n):\\n            currentSum += nums[j]\\n            if currentSum > k:\\n                while currentSum > k and i <= j:\\n                    currentSum -= nums[i]\\n                    i += 1\\n            if currentSum == k:\\n                longestSubArr = max(longestSubArr, j - i + 1)\\n        if longestSubArr == 0: return -1\\n        return n - longestSubArr\\n```\\n\\n\\u2611 Java:\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        // to find the minimum operations to reduce x to zero using elements in nums\\n        // we can use the result of the longest subarray with sum k inside nums where k = sum of elements - x\\n        int n = nums.length, sum = 0;\\n        for(int num : nums) sum += num;\\n        \\n        int k = sum - x, currentSum = 0, longestSubArr = 0;\\n        if(k == 0) return n;\\n        // the 2 pointers we will use in this variable sliding window: i <= j\\n        int i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            currentSum += nums[j];\\n            if(currentSum > k)\\n                while(currentSum > k && i <= j) {\\n                    currentSum -= nums[i];\\n                    i++;\\n                }\\n            if(currentSum == k)\\n                longestSubArr = Math.max(longestSubArr, j - i + 1);\\n        }\\n        // shortest subarray with sum = x is n - longest subarray with sum = sum - x\\n        return longestSubArr == 0 ? -1 : n - longestSubArr;\\n    }\\n}\\n```\\n\\n\\uD83D\\uDCAF Thanks for reading.\\nAn upvote would be appreciated!  ^_^",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // to find the minimum operations to reduce x to zero using elements in nums\\n        // we can use the result of the longest subarray with sum k inside nums where k = sum of elements - x\\n        int n = nums.size(), sum = 0;\\n        for(int num : nums) sum += num;\\n        \\n        int k = sum - x, currentSum = 0, longestSubArr = 0;\\n        if(k == 0) return n;\\n        // the 2 pointers we will use in this variable sliding window: i <= j\\n        int i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            currentSum += nums[j];\\n            if(currentSum > k)\\n                while(currentSum > k and i <= j) {\\n                    currentSum -= nums[i];\\n                    i++;\\n                }\\n            if(currentSum == k)\\n                longestSubArr = max(longestSubArr, j - i + 1);\\n        }\\n        // shortest subarray with sum = x is n - longest subarray with sum = sum - x\\n        return longestSubArr == 0 ? -1 : n - longestSubArr;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        sumArr, n = 0, len(nums)\\n        for num in nums: \\n            sumArr += num\\n        k, currentSum, longestSubArr, i = sumArr - x, 0, 0, 0\\n        if k == 0: return n\\n        for j in range(n):\\n            currentSum += nums[j]\\n            if currentSum > k:\\n                while currentSum > k and i <= j:\\n                    currentSum -= nums[i]\\n                    i += 1\\n            if currentSum == k:\\n                longestSubArr = max(longestSubArr, j - i + 1)\\n        if longestSubArr == 0: return -1\\n        return n - longestSubArr\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        // to find the minimum operations to reduce x to zero using elements in nums\\n        // we can use the result of the longest subarray with sum k inside nums where k = sum of elements - x\\n        int n = nums.length, sum = 0;\\n        for(int num : nums) sum += num;\\n        \\n        int k = sum - x, currentSum = 0, longestSubArr = 0;\\n        if(k == 0) return n;\\n        // the 2 pointers we will use in this variable sliding window: i <= j\\n        int i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            currentSum += nums[j];\\n            if(currentSum > k)\\n                while(currentSum > k && i <= j) {\\n                    currentSum -= nums[i];\\n                    i++;\\n                }\\n            if(currentSum == k)\\n                longestSubArr = Math.max(longestSubArr, j - i + 1);\\n        }\\n        // shortest subarray with sum = x is n - longest subarray with sum = sum - x\\n        return longestSubArr == 0 ? -1 : n - longestSubArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139718,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] n, int x){\\n        int s=-x;\\n        for(int i:n)\\n        {\\n            s+=i;\\n        }\\n        int k=n.length;\\n        if(s==0)\\n            return k;\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        int r=Integer.MIN_VALUE;\\n        int p=0;\\n        nm.put(0,-1);\\n        for(int i=0;i<k;i++)\\n        {\\n            p=p+n[i];\\n            if(nm.containsKey(p-s))\\n                r=Math.max(r,i-nm.get(p-s));\\n            nm.put(p,i);\\n        }\\n        return r==Integer.MIN_VALUE ? -1 : k-r;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int minOperations(int[] n, int x){\\n        int s=-x;\\n        for(int i:n)\\n        {\\n            s+=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2138126,
                "title": "c-prefix-sum-hashmap-o-n-solution-with-comments",
                "content": "**dry run the soln to get the clear picture.**\\n\\n***Code with explanation:**\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        //x is a value which will be substracted from left and right side of the array, and this x value should be extrcated using minimum number of elements \\n\\t\\t//in nums. After removing x value from the left and right side, a subarray will be left in the middle having targetSum = totalSum - x;  //11-5 =6\\n    \\n        //so our task is to find this largest subarray with having sum = 6 because we need minimum elements to make value x;\\n        \\n        //step-1: Find targetSum = totalSum - x;\\n        // nums = 1 1 4 2 3, x= 5 \\n        int totalSum = 0;\\n        for(auto it: nums)\\n            totalSum += it; //11\\n        \\n        int targetSum = totalSum - x;   //11-5 = 6\\n        \\n        \\n        //step-2: Find largest subarray having targetSum //6\\n        \\n        //make prefix sum array of nums\\n        //store index of each prefix sum value\\n        vector<int> prefixSum;\\n        unordered_map<int, int> mpp;\\n        mpp[0] = -1;\\n        \\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            prefixSum.push_back(sum);\\n            mpp[prefixSum[i]] = i;\\n        }\\n                    \\n        //prefixSum = 1 2 6 8 11\\n        //            0 1 2 3 4\\n        \\n        //iterate in prefixSum vector from the back using j pointer. to find targetSum will use mpp\\n        //prefixSum[j] - targetSum = i; //8-6 = 2;\\n        //now find this i value in map\\n        int len = -1;\\n        for(int j= prefixSum.size()-1; j>=0; j--){\\n            if(mpp.find(prefixSum[j] - targetSum) != mpp.end()){  //mpp[8- 6] = mpp[2] exist in map\\n                len = max(len, mpp[prefixSum[j]] - mpp[prefixSum[j]- targetSum]);    //mpp[8]- mpp[2] = 3-1 = 2\\n                cout<< nums[j]<<endl;\\n            }\\n        }\\n        \\n        //elements selected for x= total elements - elementd used for subarray(having maximum length with targetSum)\\n        if(len != -1)\\n            return nums.size()-len;\\n        return -1;\\n    }\\n};\\n```\\n**TC = O(N)\\nSC= O(N)**\\n\\n`Please do upvote if you like the solution:)`",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        //x is a value which will be substracted from left and right side of the array, and this x value should be extrcated using minimum number of elements \\n\\t\\t//in nums. After removing x value from the left and right side, a subarray will be left in the middle having targetSum = totalSum - x;  //11-5 =6\\n    \\n        //so our task is to find this largest subarray with having sum = 6 because we need minimum elements to make value x;\\n        \\n        //step-1: Find targetSum = totalSum - x;\\n        // nums = 1 1 4 2 3, x= 5 \\n        int totalSum = 0;\\n        for(auto it: nums)\\n            totalSum += it; //11\\n        \\n        int targetSum = totalSum - x;   //11-5 = 6\\n        \\n        \\n        //step-2: Find largest subarray having targetSum //6\\n        \\n        //make prefix sum array of nums\\n        //store index of each prefix sum value\\n        vector<int> prefixSum;\\n        unordered_map<int, int> mpp;\\n        mpp[0] = -1;\\n        \\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum += nums[i];\\n            prefixSum.push_back(sum);\\n            mpp[prefixSum[i]] = i;\\n        }\\n                    \\n        //prefixSum = 1 2 6 8 11\\n        //            0 1 2 3 4\\n        \\n        //iterate in prefixSum vector from the back using j pointer. to find targetSum will use mpp\\n        //prefixSum[j] - targetSum = i; //8-6 = 2;\\n        //now find this i value in map\\n        int len = -1;\\n        for(int j= prefixSum.size()-1; j>=0; j--){\\n            if(mpp.find(prefixSum[j] - targetSum) != mpp.end()){  //mpp[8- 6] = mpp[2] exist in map\\n                len = max(len, mpp[prefixSum[j]] - mpp[prefixSum[j]- targetSum]);    //mpp[8]- mpp[2] = 3-1 = 2\\n                cout<< nums[j]<<endl;\\n            }\\n        }\\n        \\n        //elements selected for x= total elements - elementd used for subarray(having maximum length with targetSum)\\n        if(len != -1)\\n            return nums.size()-len;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2137813,
                "title": "easy-c-sol-prefix-sum-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        int sum = 0;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            mp[sum] = i;\\n        }\\n        \\n        if(x>sum){\\n            return -1;\\n        }\\n        mp[0] = 0;\\n        \\n        int longest = 0;\\n        sum -= x;\\n        \\n        int val = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            val += nums[i];\\n            if(mp.count(val-sum)){\\n                \\n                if(val-sum == 0){\\n                    longest = max(longest,i-mp[val-sum]+1);\\n                }else{\\n                    longest = max(longest,i-mp[val-sum]);\\n                }   \\n            }\\n        }\\n        return longest == 0?(sum == 0?n:-1):n-longest;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        int sum = 0;\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            mp[sum] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2137625,
                "title": "easy-to-understand-o-n-time-c",
                "content": "The Basic Idea I tried to implement here was to , Instead to popping elements from either side of the array we can find a subarray whose sum is equal to (total_sum_of_array - x) . \\nAfter finding this subarray we can directly return our answer as total_size_of_array- length of subarray found .\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int sum=0;\\n\\t\\t// Calculating Total sum of our given Array\\n        for(int i:nums)\\n            sum+=i;\\n\\t\\t\\n\\t\\t// Substracting X from our total sum to get a target sum for our sub-array\\n        sum=sum-x;\\n\\t\\t// Basic Edge Cases \\n        if(sum==0)\\n            return nums.size();\\n        if(sum<0)\\n            return -1;\\n        \\n        int low=0;int high=0;int cursum=0;\\n        int ans=-1;\\n\\t\\t// Finding the length of Subarray whose sum = Target_Sum\\n        while(high<nums.size()){\\n            cursum+=nums[high];\\n            while(cursum>sum){\\n                cursum-=nums[low++];\\n            }\\n            if(cursum==sum)\\n                ans=max(ans,high-low+1);\\n            high++;\\n        }\\n\\t\\t\\n        if(ans==-1)\\n            return -1;\\n        return nums.size()-ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        int sum=0;\\n\\t\\t// Calculating Total sum of our given Array\\n        for(int i:nums)\\n            sum+=i;\\n\\t\\t\\n\\t\\t// Substracting X from our total sum to get a target sum for our sub-array\\n        sum=sum-x;\\n\\t\\t// Basic Edge Cases \\n        if(sum==0)\\n            return nums.size();\\n        if(sum<0)\\n            return -1;\\n        \\n        int low=0;int high=0;int cursum=0;\\n        int ans=-1;\\n\\t\\t// Finding the length of Subarray whose sum = Target_Sum\\n        while(high<nums.size()){\\n            cursum+=nums[high];\\n            while(cursum>sum){\\n                cursum-=nums[low++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2137239,
                "title": "minimum-operations-to-reduce-x-to-zero-java-two-pointer-approach",
                "content": "#### **Minimum Operations to Reduce X to Zero**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int total = 0;\\n        for (int num: nums) {\\n            total += num;\\n        }\\n        if (total < x) return -1;\\n        \\n        // We find longest subarray with sum = total - x\\n        total = total - x;\\n        int i = 0, j = 0, sum = 0, ans = -1, n = nums.length;\\n        while (i < n) {\\n            sum = sum + nums[i];\\n            if (sum == total) {\\n                ans = Math.max(ans, i - j + 1);\\n            } else if (sum > total) {\\n                while (j <= i && sum > total) {\\n                    sum = sum - nums[j];\\n                    j++;\\n                }\\n                if (sum == total) {\\n                    ans = Math.max(ans, i - j + 1);\\n                }\\n            }\\n            i++;\\n        }\\n        if (ans == -1) return -1;\\n        return nums.length - ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int total = 0;\\n        for (int num: nums) {\\n            total += num;\\n        }\\n        if (total < x) return -1;\\n        \\n        // We find longest subarray with sum = total - x\\n        total = total - x;\\n        int i = 0, j = 0, sum = 0, ans = -1, n = nums.length;\\n        while (i < n) {\\n            sum = sum + nums[i];\\n            if (sum == total) {\\n                ans = Math.max(ans, i - j + 1);\\n            } else if (sum > total) {\\n                while (j <= i && sum > total) {\\n                    sum = sum - nums[j];\\n                    j++;\\n                }\\n                if (sum == total) {\\n                    ans = Math.max(ans, i - j + 1);\\n                }\\n            }\\n            i++;\\n        }\\n        if (ans == -1) return -1;\\n        return nums.length - ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137205,
                "title": "c-o-n-solution-sliding-window",
                "content": "We\\'ll use greedy approach with reverse approach, instead of finding operation, we will find the maximum length subarray whose sum is equal to sum - x, then we will get the remaining array which will be left after all the operations. We can find the operations by subtracting length of this subarray from nums.len(). \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int i=0,j=0;\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        if(x > sum) return -1;\\n        if(x == sum) return n;\\n        sum = sum - x;\\n        int temp =0;\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            temp += nums[j];\\n            if(temp == sum) \\n            {\\n                ans = max(ans,j-i+1);\\n            }\\n            if(temp > sum){\\n                while(temp > sum)\\n                {\\n                    temp -= nums[i];\\n                    i++;\\n                }\\n                if(temp == sum)\\n                {\\n                    ans = max(ans,j-i+1);\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans == 0) return -1;\\n        return n-ans;\\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        int i=0,j=0;\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        if(x > sum) return -1;\\n        if(x == sum) return n;\\n        sum = sum - x;\\n        int temp =0;\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            temp += nums[j];\\n            if(temp == sum) \\n            {\\n                ans = max(ans,j-i+1);\\n            }\\n            if(temp > sum){\\n                while(temp > sum)\\n                {\\n                    temp -= nums[i];\\n                    i++;\\n                }\\n                if(temp == sum)\\n                {\\n                    ans = max(ans,j-i+1);\\n                }\\n            }\\n            j++;\\n        }\\n        if(ans == 0) return -1;\\n        return n-ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137176,
                "title": "simple-and-easy-c-solution-using-two-sum-approach",
                "content": "int sum = accumulate(begin(nums), end(nums), 0);\\n    int l = 0, r = 0, res = INT_MAX, sz = nums.size();\\n    while (l <= r)\\n        if (sum >= x) {\\n            if (sum == x)\\n                res = min(res, l + sz - r);\\n            if (r < sz)\\n                sum -= nums[r++];\\n            else\\n                break;\\n        }\\n        else\\n            sum += nums[l++];\\n    return res == INT_MAX ? -1 : res;",
                "solutionTags": [],
                "code": "int sum = accumulate(begin(nums), end(nums), 0);\\n    int l = 0, r = 0, res = INT_MAX, sz = nums.size();\\n    while (l <= r)\\n        if (sum >= x) {\\n            if (sum == x)\\n                res = min(res, l + sz - r);\\n            if (r < sz)\\n                sum -= nums[r++];\\n            else\\n                break;\\n        }\\n        else\\n            sum += nums[l++];\\n    return res == INT_MAX ? -1 : res;",
                "codeTag": "Unknown"
            },
            {
                "id": 2137138,
                "title": "python-solution",
                "content": "\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        \\n        l,s = len(nums), sum(nums)\\n        r = s-x   \\n        \\n        if r==0: return l\\n        \\n        d = {0:-1}\\n        ll = ss = 0\\n        \\n        for i,e in enumerate(nums):\\n            ss += e\\n            if ss-r in d:\\n                ll = max(ll, i-d[ss-r])\\n            if ss not in d:\\n                d[ss] = i\\n            \\n        return [l-ll, -1][ll==0]\\n\\t\\t\\n##### Please UPVOTE my solution if you like it. Thanks",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        \\n        l,s = len(nums), sum(nums)\\n        r = s-x   \\n        \\n        if r==0: return l\\n        \\n        d = {0:-1}\\n        ll = ss = 0\\n        \\n        for i,e in enumerate(nums):\\n            ss += e\\n            if ss-r in d:\\n                ll = max(ll, i-d[ss-r])\\n            if ss not in d:\\n                d[ss] = i\\n            \\n        return [l-ll, -1][ll==0]\\n\\t\\t\\n##### Please UPVOTE my solution if you like it. Thanks",
                "codeTag": "Python3"
            },
            {
                "id": 2137118,
                "title": "a-thought-of-two-sum-two-pointer-binary-search-python",
                "content": "Make two list left and right, means add all elements from left/right, and it will become a monotonic list, means strictly increase( because nums[i] >= 1). \\nSo we can find **two sum** from left and right list.\\n```\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        left = [0] * n\\n        right = [0] * n\\n        left[0] = nums[0]\\n        for i in range(1,n):\\n            left[i] = left[i-1] + nums[i]\\n        nums = nums[::-1]\\n        right[0] = nums[0]\\n        for i in range(1,n):\\n            right[i] = right[i-1] + nums[i]\\n            \\n        res = n+1\\n        \\n        a = bisect.bisect_left(left,x)\\n        \\n        if a != n:\\n            \\n            if left[a] == x:\\n                res = min(res,a+1)\\n        \\n        b = bisect.bisect_left(right,x)\\n        \\n        if b != n:\\n            \\n            if right[b] == x:\\n                res = min(res,b+1)\\n        \\n        \\n        l, r = 0, n-1\\n        \\n        while l+r <= n :\\n            if l>=n or r<0:      #######\\n\\t\\t\\t\\tbreak            #  those lines \\n            if left[l]>= x:      #  are used  to \\n                break            #  reduce time,\\n            if right[r]>=x:      #  to fast exit loops or \\n                r -= 1           # let r get to possible place fast\\n                continue         ########\\n            if left[l] + right[r] == x:\\n                res = min(res,l+1+r+1)\\n                l += 1\\n                r -= 1\\n            elif left[l] + right[r] > x:\\n                r -= 1\\n            elif left[l] + right[r] < x:\\n                l += 1\\n        if res == n+1:\\n            return -1\\n        return res\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        left = [0] * n\\n        right = [0] * n\\n        left[0] = nums[0]\\n        for i in range(1,n):\\n            left[i] = left[i-1] + nums[i]\\n        nums = nums[::-1]\\n        right[0] = nums[0]\\n        for i in range(1,n):\\n            right[i] = right[i-1] + nums[i]\\n            \\n        res = n+1\\n        \\n        a = bisect.bisect_left(left,x)\\n        \\n        if a != n:\\n            \\n            if left[a] == x:\\n                res = min(res,a+1)\\n        \\n        b = bisect.bisect_left(right,x)\\n        \\n        if b != n:\\n            \\n            if right[b] == x:\\n                res = min(res,b+1)\\n        \\n        \\n        l, r = 0, n-1\\n        \\n        while l+r <= n :\\n            if l>=n or r<0:      #######\\n\\t\\t\\t\\tbreak            #  those lines \\n            if left[l]>= x:      #  are used  to \\n                break            #  reduce time,\\n            if right[r]>=x:      #  to fast exit loops or \\n                r -= 1           # let r get to possible place fast\\n                continue         ########\\n            if left[l] + right[r] == x:\\n                res = min(res,l+1+r+1)\\n                l += 1\\n                r -= 1\\n            elif left[l] + right[r] > x:\\n                r -= 1\\n            elif left[l] + right[r] < x:\\n                l += 1\\n        if res == n+1:\\n            return -1\\n        return res\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137043,
                "title": "python3-prefix-and-suffix-sum-binary-search-clean-explained",
                "content": "Idea is to create prefix and suffix sum arrays.\\n\\nSince prefix sum is always in sorted order (because all numbers in our nums are greater than 0), we can take advantage of binary search.\\n\\nFor every value in suffix sum, we can check whether it\\'s counter part (target - suffix_sum[i]) exists for some index j in prefix_sum. If yes, we can try to minimize our answer.\\n\\n\\n```\\ndef binary_search(arr, left, right, target):\\n    while left <= right:\\n        mid = (left + right) >> 1\\n        \\n        value = arr[mid]\\n        if value == target:\\n            return mid\\n    \\n        elif value < target:\\n            left = mid + 1\\n        \\n        else:\\n            right = mid - 1\\n        \\n    return -1\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n\\n        prefix_sum = [0] * length\\n        suffix_sum = [0] * length\\n        \\n        prefix_sum[0] = nums[0]\\n        \\n        for index in range(1, length):\\n            prefix_sum[index] += prefix_sum[index-1] + nums[index]\\n        \\n        suffix_sum[-1] = nums[-1]\\n        \\n        for index in range(length-2, -1, -1):\\n            suffix_sum[index] = suffix_sum[index+1] + nums[index]\\n        \\n        answer = math.inf\\n\\n        if target in prefix_sum: answer = min(answer, prefix_sum.index(target)+1)\\n        if target in suffix_sum: answer = min(answer, length - suffix_sum.index(target))\\n            \\n        for suffix_index in range(length-1, -1, -1):\\n            suffix_value = suffix_sum[suffix_index]\\n            prefix_index = binary_search(prefix_sum, 0, length-1, target-suffix_value)\\n\\n            if prefix_index != -1 and prefix_index < suffix_index:\\n                current = (prefix_index+1) + (length-suffix_index) # prefix_index + 1 because arrays are 0 indexed\\n                answer = min(answer, current)\\n        \\n        return answer if answer != math.inf else -1\\n```\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\ndef binary_search(arr, left, right, target):\\n    while left <= right:\\n        mid = (left + right) >> 1\\n        \\n        value = arr[mid]\\n        if value == target:\\n            return mid\\n    \\n        elif value < target:\\n            left = mid + 1\\n        \\n        else:\\n            right = mid - 1\\n        \\n    return -1\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n\\n        prefix_sum = [0] * length\\n        suffix_sum = [0] * length\\n        \\n        prefix_sum[0] = nums[0]\\n        \\n        for index in range(1, length):\\n            prefix_sum[index] += prefix_sum[index-1] + nums[index]\\n        \\n        suffix_sum[-1] = nums[-1]\\n        \\n        for index in range(length-2, -1, -1):\\n            suffix_sum[index] = suffix_sum[index+1] + nums[index]\\n        \\n        answer = math.inf\\n\\n        if target in prefix_sum: answer = min(answer, prefix_sum.index(target)+1)\\n        if target in suffix_sum: answer = min(answer, length - suffix_sum.index(target))\\n            \\n        for suffix_index in range(length-1, -1, -1):\\n            suffix_value = suffix_sum[suffix_index]\\n            prefix_index = binary_search(prefix_sum, 0, length-1, target-suffix_value)\\n\\n            if prefix_index != -1 and prefix_index < suffix_index:\\n                current = (prefix_index+1) + (length-suffix_index) # prefix_index + 1 because arrays are 0 indexed\\n                answer = min(answer, current)\\n        \\n        return answer if answer != math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136863,
                "title": "python-3-simple-sliding-window-solution-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        targetSum = sum(nums) - x\\n        if targetSum <= 0:\\n            return -1 if targetSum < 0 else len(nums)\\n        \\n        largestWindow = -1\\n        curSum = 0\\n        left = 0\\n        \\n        for right, num in enumerate(nums):\\n            curSum += num\\n            while curSum > targetSum:\\n                curSum -= nums[left]\\n                left += 1\\n                \\n            if curSum == targetSum:\\n                largestWindow = max(largestWindow, right - left + 1)\\n        \\n        return len(nums) - largestWindow if largestWindow != -1 else -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        targetSum = sum(nums) - x\\n        if targetSum <= 0:\\n            return -1 if targetSum < 0 else len(nums)\\n        \\n        largestWindow = -1\\n        curSum = 0\\n        left = 0\\n        \\n        for right, num in enumerate(nums):\\n            curSum += num\\n            while curSum > targetSum:\\n                curSum -= nums[left]\\n                left += 1\\n                \\n            if curSum == targetSum:\\n                largestWindow = max(largestWindow, right - left + 1)\\n        \\n        return len(nums) - largestWindow if largestWindow != -1 else -1",
                "codeTag": "Java"
            },
            {
                "id": 2136766,
                "title": "simple-sliding-window-approach-o-n-time-o-1-space-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for(int i=0; i<nums.length; i++) sum += nums[i];\\n        int target = sum-x;\\n        int left = 0, right = 0;\\n        sum = 0;\\n        int len = 0;\\n\\t\\tif(target == 0) return nums.length;\\n        while(right < nums.length){\\n            sum += nums[right];\\n            while(sum > target && left <= right){\\n                sum -= nums[left];\\n                left++;\\n            }\\n            if(sum==target) len = Math.max(len, right - left + 1);\\n            right++;\\n        }\\n        if(len == 0) return -1;\\n        return nums.length - len;\\n    }\\n}",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for(int i=0; i<nums.length; i++) sum += nums[i];\\n        int target = sum-x;\\n        int left = 0, right = 0;\\n        sum = 0;\\n        int len = 0;\\n\\t\\tif(target == 0) return nums.length;\\n        while(right < nums.length){\\n            sum += nums[right];\\n            while(sum > target && left <= right){\\n                sum -= nums[left];\\n                left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2136591,
                "title": "java-easy-solution-using-map",
                "content": "class Solution {\\n   public int minOperations(int[] nums, int x) {\\n    int target = -x;\\n    for(int num: nums) target += num;\\n    if(target == 0) return nums.length;\\n    if(target < 0) return -1;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    map.put(0, -1);\\n    int sum = 0, L = 0;\\n    for(int i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        L = Math.max(L, i - map.getOrDefault(sum - target, i));\\n        map.put(sum, i);\\n    }\\n    return L > 0 ? nums.length - L : -1;\\n\\n\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   public int minOperations(int[] nums, int x) {\\n    int target = -x;\\n    for(int num: nums) target += num;\\n    if(target == 0) return nums.length;\\n    if(target < 0) return -1;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    map.put(0, -1);\\n    int sum = 0, L = 0;\\n    for(int i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        L = Math.max(L, i - map.getOrDefault(sum - target, i));\\n        map.put(sum, i);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2136577,
                "title": "c-solution-faster-than-70",
                "content": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        int tar = nums.Sum();\\n        tar -=x;\\n        \\n        if(tar==0)\\n        {\\n            return nums.Length;\\n        }\\n        else if (tar<0)     //Sum of the array should greater than our target\\n        {\\n            return -1;\\n        }\\n        \\n        int res = Int32.MinValue;\\n        int sum = 0;   //sum number use in iteration\\n        int s = 0;     //s = start\\n        \\n        for(int e = 0;e<nums.Length;e++)  // e = end\\n        {\\n            sum += nums[e];\\n            while (s <= e && sum > tar) {\\n              sum -= nums[s];\\n              s++;\\n            }\\n\\n            if (sum == tar) {\\n              res = Math.Max(res, e-s+1);\\n            }\\n        }\\n        \\n        return res == Int32.MinValue ? -1 : nums.Length - res;\\n    }\\n}\\n```\\n\\n**See more LeetCode Solutions - [Zyrastory - Code and Food Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums, int x) {\\n        int tar = nums.Sum();\\n        tar -=x;\\n        \\n        if(tar==0)\\n        {\\n            return nums.Length;\\n        }\\n        else if (tar<0)     //Sum of the array should greater than our target\\n        {\\n            return -1;\\n        }\\n        \\n        int res = Int32.MinValue;\\n        int sum = 0;   //sum number use in iteration\\n        int s = 0;     //s = start\\n        \\n        for(int e = 0;e<nums.Length;e++)  // e = end\\n        {\\n            sum += nums[e];\\n            while (s <= e && sum > tar) {\\n              sum -= nums[s];\\n              s++;\\n            }\\n\\n            if (sum == tar) {\\n              res = Math.Max(res, e-s+1);\\n            }\\n        }\\n        \\n        return res == Int32.MinValue ? -1 : nums.Length - res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120021,
                "title": "cpp-faster-then-100",
                "content": "```\\n**If u understand then upvote**\\nint minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        if(nums[0]>x && nums[n-1]>x) return -1;\\n        if(nums[0]==x ||nums[n-1]==x) return 1;\\n        \\n        int mn=INT_MAX;\\n        \\n        int i=0,j=n-1;\\n        int sum=0;\\n        while(sum<x && i<n) sum+=nums[i++];\\n        \\n        if(sum==x) mn=min(mn,i);\\n        while(i<=j && i>0)\\n        {\\n            if(sum>=x)\\n                sum-=nums[--i];\\n            else\\n                sum+=nums[j--];\\n            \\n            if(sum==x) mn=min(mn,i+n-j-1);\\n        }\\n        \\n        while(j>=i && sum<x) sum+=nums[j--];\\n        if(sum==x) mn=min(mn,i+n-j-1);\\n        \\n        if(mn==INT_MAX) return -1;\\n        return mn;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n**If u understand then upvote**\\nint minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        if(nums[0]>x && nums[n-1]>x) return -1;\\n        if(nums[0]==x ||nums[n-1]==x) return 1;\\n        \\n        int mn=INT_MAX;\\n        \\n        int i=0,j=n-1;\\n        int sum=0;\\n        while(sum<x && i<n) sum+=nums[i++];\\n        \\n        if(sum==x) mn=min(mn,i);\\n        while(i<=j && i>0)\\n        {\\n            if(sum>=x)\\n                sum-=nums[--i];\\n            else\\n                sum+=nums[j--];\\n            \\n            if(sum==x) mn=min(mn,i+n-j-1);\\n        }\\n        \\n        while(j>=i && sum<x) sum+=nums[j--];\\n        if(sum==x) mn=min(mn,i+n-j-1);\\n        \\n        if(mn==INT_MAX) return -1;\\n        return mn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1827520,
                "title": "c-sliding-window-explanation",
                "content": "The question here asks to minimize the operations to reduce X to zero by taking elements from either side. Let us take total sum of the array be totalSum. If X is reduced from either side, means remaining array will have sum equal to totalSum-X. As operations has to be minimized, so this question is equivalent to finding maximum size subarray having sum as totalSum-X.\\n```\\n int minOperations(vector<int>& arr, int x) \\n    {\\n        int n=arr.size();\\n        int res=INT_MIN;\\n        int totalSum=0, sum=0, j=0;\\n        \\n        for(auto i:arr) totalSum+=i;\\n        \\n        int target=totalSum-x;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            sum+=arr[i];\\n            if(sum>target)\\n            {\\n                while(sum>target&&j<=i)\\n                {\\n                    sum-=arr[j];\\n                    j++;\\n                }\\n            }\\n            if(sum==target)\\n                res=max(res, i-j+1);\\n        }\\n        \\n        return res==INT_MIN?-1:n-res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n int minOperations(vector<int>& arr, int x) \\n    {\\n        int n=arr.size();\\n        int res=INT_MIN;\\n        int totalSum=0, sum=0, j=0;\\n        \\n        for(auto i:arr) totalSum+=i;\\n        \\n        int target=totalSum-x;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            sum+=arr[i];\\n            if(sum>target)\\n            {\\n                while(sum>target&&j<=i)\\n                {\\n                    sum-=arr[j];\\n                    j++;\\n                }\\n            }\\n            if(sum==target)\\n                res=max(res, i-j+1);\\n        }\\n        \\n        return res==INT_MIN?-1:n-res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1817266,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        k = sum(nums)-x\\n        if sum(nums) == x:\\n            return len(nums)\\n        \\n        d = {0: -1}\\n        ans, sums = 0, 0\\n        for i in range(n):\\n            sums += nums[i]\\n            if sums-k in d:\\n                ans = max(ans, i-d[sums-k])\\n            d[sums] = i\\n        \\n        return -1 if ans == 0 else n-ans",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        k = sum(nums)-x\\n        if sum(nums) == x:\\n            return len(nums)\\n        \\n        d = {0: -1}",
                "codeTag": "Java"
            },
            {
                "id": 1681403,
                "title": "java-sliding-window-beats-90",
                "content": "This question is similar to LC1423! \\nPlease upvote if you find it useful! Or leave comments or suggestions below. I will try my best to answer them! \\nThank you!\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        \\n        if (x == sum) return nums.length; \\n        \\n        int maxLen = 0, left = 0, right = 0, target = sum - x;\\n        int windowSum = 0;\\n        \\n        while (right < nums.length) {\\n            int rightNum = nums[right++];\\n            windowSum += rightNum;\\n            \\n            while (left < right && windowSum > target) {\\n                int leftNum = nums[left++];\\n                windowSum -= leftNum;\\n            }\\n            \\n            if (windowSum == target) maxLen = Math.max(maxLen, right - left);\\n        }\\n        \\n        return maxLen == 0 ? -1 : nums.length - maxLen;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n        \\n        if (x == sum) return nums.length; \\n        \\n        int maxLen = 0, left = 0, right = 0, target = sum - x;\\n        int windowSum = 0;\\n        \\n        while (right < nums.length) {\\n            int rightNum = nums[right++];\\n            windowSum += rightNum;\\n            \\n            while (left < right && windowSum > target) {\\n                int leftNum = nums[left++];\\n                windowSum -= leftNum;\\n            }\\n            \\n            if (windowSum == target) maxLen = Math.max(maxLen, right - left);\\n        }\\n        \\n        return maxLen == 0 ? -1 : nums.length - maxLen;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609093,
                "title": "c-sliding-window-152-ms-faster-than-81-40-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\nint minOperations(vector& nums, int x) {\\nint totalsum = 0,sum = 0;\\nfor(int i = 0; i< nums.size(); i++)\\n{\\ntotalsum = totalsum+nums[i];\\n}\\nint k = totalsum - x;\\nif(k < 0) return -1;\\nint res = INT_MIN;\\nint i = 0, j = 0;\\n\\n    while(j < nums.size())\\n    {\\n        sum = sum+nums[j];\\n        if(sum > k)\\n        {\\n            while(sum > k)\\n            {\\n                sum = sum-nums[i];\\n                i++;\\n            }\\n        }\\n        if(sum == k)\\n        {\\n            res = max(res, j-i+1);\\n        }\\n        j++;\\n    }\\n    if(res == INT_MIN)\\n        return -1;\\n    else\\n        return nums.size()-res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint minOperations(vector& nums, int x) {\\nint totalsum = 0,sum = 0;\\nfor(int i = 0; i< nums.size(); i++)\\n{\\ntotalsum = totalsum+nums[i];\\n}\\nint k = totalsum - x;\\nif(k < 0) return -1;\\nint res = INT_MIN;\\nint i = 0, j = 0;\\n\\n    while(j < nums.size())\\n    {\\n        sum = sum+nums[j];\\n        if(sum > k)\\n        {\\n            while(sum > k)\\n            {\\n                sum = sum-nums[i];\\n                i++;\\n            }\\n        }\\n        if(sum == k)\\n        {\\n            res = max(res, j-i+1);\\n        }\\n        j++;\\n    }\\n    if(res == INT_MIN)\\n        return -1;\\n    else\\n        return nums.size()-res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586979,
                "title": "1658-minimum-operations-to-reduce-x-to-zero-c-o-n-solution-sliding-window-with-some-maths",
                "content": "On my first go, i implemented the recursive solution(even though i knew the constraints but still to have a solution up and running with recursion). Ofcourse, I got TLE. Then i thought of memoization but couldn\\'t be possible due to large constraints. Then used map but still only 40 cases passed.\\n\\n# RECURSIVE (MEMOIZED CODE)\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,int> map;\\n    \\n    int helper(vector<int>& nums,int n,int index,int x){\\n        if(x==0){\\n            return 0;\\n        }\\n        if(x<0){\\n            return -1;\\n        }\\n        if(index==n){\\n            return -1;\\n        }\\n        string s = to_string(index) + \" \" + to_string(n) + \" \" + to_string(x);\\n        if(map.find(s)!=map.end()){\\n            return map[s];\\n        }\\n        int ans1 = helper(nums,n,index+1,x-nums[index]);\\n        int ans2 = helper(nums,n-1,index,x-nums[n-1]);\\n        \\n        if(ans1==-1 && ans2==-1){\\n            return map[s] = -1;\\n        }\\n        if(ans1==-1){\\n            return map[s] = 1+ans2;\\n        }\\n        if(ans2==-1){\\n            return map[s] = 1+ans1;\\n        }\\n        return map[s] = 1 + min(ans1,ans2);\\n    }\\n    \\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        map.clear();\\n        return helper(nums,n,0,x);\\n    }\\n};\\n```\\n\\nThen i came to the main part of thinking of O(n) or maybe O(nlogn) solution. We can\\'t really sort the array nor I came up with any idea of using set/map, I made up in my mind to think of a O(n) solution. \\n\\nNow what I really learnt from recursive solution was that we were dealing with kind of subsets(not all but selective ones, we were working with subsets only.). So, I thought why not find a way of having sub-arrays. That way if we need to find a subarray with given target-sum, we can somehow apply maps or we can use sliding window(as far as non-negative numbers are there). So after dry running few test cases, I came up with a solution of sliding window to get the end points of the subarray with given target sum. But here what I did was I made a double sized array and copied it 2 times in the same given order. Now think of it seriously. Now as I have an array 2 times , so in a way I have a circular version of my array. Now as given in the question, we are dealing with the elements present at the ends, now we only need to work with subarrays as now our both the ends are connected and now if our answer exists, we only need to deal with subarrays only. This was the most important step and most of the task was over. \\nNow take for eg, we have array like [3,2,20,1,1,3] and x=10. Our answer is actually 5 i.e. including 0,1,3,4,5 indexed elements. Now going by my approach, the modified array is:\\n[3,2,20,1,1,3,3,2,20,1,1,3].\\nHere see carefully our both ends are connected and so we only need to deal with the subarrays as we can see 3,4,5,6,7 are the indices for our answer. Don\\'t think of how we will get our final solution. We will see that. So i proved my point for that we only need to deal with subarrays only and not subsets anymore.\\n\\nNow how to get our final solution. See there are 2 cases. \\n1) If our subarray is present in the single part(1st/2nd) : The meaning of this is that our output subarray is either in range [0 to n-1] or [n to 2n - 1]\\n2) If our output subarray is present in different parts which actually means we are actually choosing different sides to get our answer(if we take into consideration what the question actually wants)\\n\\nSo if our sum==x then if end-start+1 > n , we can simply return as this means we are taking more elements that what are actual **n sized array contained, we can\\'t take more elements than what original array has.**\\n\\nNow if start==0 || end==n-1 || start==n || end==2n-1, then we can simply have our answer as end-start+1. This is so as if consider start==0, then we are sure our subarray has to end before n i.e. end can be maximum n-1. So we can do this. and same goes for other cases as they all complement each other in one way or another. **My point here actually is that our subarray lies in a single part only(1st case).** \\n\\nelse if start<n && end>=n we will have our ans as (n-start) + (end-n+1). This is the most important case. Now this is actually our 2nd case in which subarray lies in 2 different parts. So see there is a big big catch. Our joining line is actually from index n-1 to n. So here see as our start is less than n. That means we are removing elements from the back of the original array(the n sized array given in ques) and so our answer is n-start(elements removed) and end>=n which means we are removing elements from the starting of the original n sized array given in the ques and so we add end-n+1 to it which are actually no of elements removed from the starting of array and so our ans for this case is\\n=No of elements removed from the end of n sized original array + no of elements removed from the starting of the n sized og given array i.e. = (n-start) + (end-n+1)\\n\\nNow apart from this there is no case possible as our subarray length can\\'t exceed n and if we are getting any, we are discarding it. Every other case where the 1st case condition is not holding gets covered in the second case most probably as for getting our answer either of the end points of the subarray need to be the end-points(as if for eg start=1 end=3 and n=6), then what we are saying that we removed 1,2,3 indexed elements which means we skipped 0,4,5 indexed which is not possible and so we don\\'t need to take care of those cases.\\n\\nIt was really hard to describe in words and i hope I did well.. Below is the code:\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> arr;\\n        for(int i=0;i<2*n;i++){\\n            arr.push_back(nums[i%n]);\\n        }\\n        int ans=INT_MAX;\\n        int size=arr.size();\\n        int curr_sum = arr[0], start = 0, i;\\n        for (i = 1; i <= size; i++) {\\n            while (curr_sum > x && start < i - 1) {\\n                curr_sum = curr_sum - arr[start];\\n                start++;\\n            }\\n\\n            if (curr_sum == x) {\\n                int end=i-1;\\n                if(end-start+1 > n){\\n                    continue;\\n                }\\n                int temp=INT_MAX;\\n                if(start==0 || start==n || end==n-1 || end==size-1){\\n                    temp=end-start+1;\\n                }\\n                else if(start<n && end>=n) {\\n                    temp = (n-start) + (end-n+1);\\n                }\\n                ans=min(ans,temp);\\n            }\\n\\n            if (i < size)\\n                curr_sum = curr_sum + arr[i];\\n        }\\n        return ans == INT_MAX ? -1:ans;\\n    }\\n};\\n```\\n\\nDo upvote if you liked the explanation and the approach. Feel free to ask in comments :)",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,int> map;\\n    \\n    int helper(vector<int>& nums,int n,int index,int x){\\n        if(x==0){\\n            return 0;\\n        }\\n        if(x<0){\\n            return -1;\\n        }\\n        if(index==n){\\n            return -1;\\n        }\\n        string s = to_string(index) + \" \" + to_string(n) + \" \" + to_string(x);\\n        if(map.find(s)!=map.end()){\\n            return map[s];\\n        }\\n        int ans1 = helper(nums,n,index+1,x-nums[index]);\\n        int ans2 = helper(nums,n-1,index,x-nums[n-1]);\\n        \\n        if(ans1==-1 && ans2==-1){\\n            return map[s] = -1;\\n        }\\n        if(ans1==-1){\\n            return map[s] = 1+ans2;\\n        }\\n        if(ans2==-1){\\n            return map[s] = 1+ans1;\\n        }\\n        return map[s] = 1 + min(ans1,ans2);\\n    }\\n    \\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        map.clear();\\n        return helper(nums,n,0,x);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> arr;\\n        for(int i=0;i<2*n;i++){\\n            arr.push_back(nums[i%n]);\\n        }\\n        int ans=INT_MAX;\\n        int size=arr.size();\\n        int curr_sum = arr[0], start = 0, i;\\n        for (i = 1; i <= size; i++) {\\n            while (curr_sum > x && start < i - 1) {\\n                curr_sum = curr_sum - arr[start];\\n                start++;\\n            }\\n\\n            if (curr_sum == x) {\\n                int end=i-1;\\n                if(end-start+1 > n){\\n                    continue;\\n                }\\n                int temp=INT_MAX;\\n                if(start==0 || start==n || end==n-1 || end==size-1){\\n                    temp=end-start+1;\\n                }\\n                else if(start<n && end>=n) {\\n                    temp = (n-start) + (end-n+1);\\n                }\\n                ans=min(ans,temp);\\n            }\\n\\n            if (i < size)\\n                curr_sum = curr_sum + arr[i];\\n        }\\n        return ans == INT_MAX ? -1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405214,
                "title": "c-clean-code-with-easiest-explanation",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        //This question can also be visualized as the maxlength subarray with summation equals to (total_sum of the array-x)\\n        \\n    /*\\n    \\n    As an example we can observe that [3,2,20,1,1,3]  x=10.\\n    \\n    Now according to question we should determine the minimum number of elements that we can remove from the both end.\\n    \\n    That means if we are able to find the maxLen subarray with sum equals to (tot_sum-x) then automatically we get the required answer.\\n    \\n    Example 1:- [1,1,4,2,3]  ,  x=5\\n    ----------\\n    Now tot_sum=(1+1+4+2+3)=11 , target_sum=(tot_sum-x)==(11-5)==6\\n    Maximum Length subarray with sum 6 is [1,1,4]  after rempving them the number of existing elements is our answer.\\n    \\n    \\n    Example 2:- [5,6,7,8,9] ,  x=4\\n    ----------\\n    Now tot_sum=(5+6+7+8+9)=35 ,target_sum=(tot_sum-x)==(35-4)==31 \\n    Basically there are no subarray with sum equals to 31 , so we have to return -1\\n    \\n    */\\n    \\n        \\n        map<int,int>mp;\\n        \\n        int maxLen=INT_MIN;\\n        \\n        int n=nums.size();\\n        \\n        int tot_sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            tot_sum+=nums[i];\\n            \\n        }\\n        \\n        int target=(tot_sum-x);\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            sum+=nums[i];\\n            \\n            if(sum==target){\\n                maxLen=max(maxLen,i+1);\\n            }\\n            \\n            if(mp.find(sum)==mp.end()){\\n                mp[sum]=i;\\n            }\\n            \\n            if(mp.find(sum-target)!=mp.end()){\\n                maxLen=max(maxLen,i-mp[sum-target]);\\n            }\\n            \\n        }\\n        \\n        if(maxLen==INT_MIN){\\n            return -1;\\n        }\\n        \\n        else{\\n            return (n-maxLen);\\n        }\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        \\n        //This question can also be visualized as the maxlength subarray with summation equals to (total_sum of the array-x)\\n        \\n    /*\\n    \\n    As an example we can observe that [3,2,20,1,1,3]  x=10.\\n    \\n    Now according to question we should determine the minimum number of elements that we can remove from the both end.\\n    \\n    That means if we are able to find the maxLen subarray with sum equals to (tot_sum-x) then automatically we get the required answer.\\n    \\n    Example 1:- [1,1,4,2,3]  ,  x=5\\n    ----------\\n    Now tot_sum=(1+1+4+2+3)=11 , target_sum=(tot_sum-x)==(11-5)==6\\n    Maximum Length subarray with sum 6 is [1,1,4]  after rempving them the number of existing elements is our answer.\\n    \\n    \\n    Example 2:- [5,6,7,8,9] ,  x=4\\n    ----------\\n    Now tot_sum=(5+6+7+8+9)=35 ,target_sum=(tot_sum-x)==(35-4)==31 \\n    Basically there are no subarray with sum equals to 31 , so we have to return -1\\n    \\n    */\\n    \\n        \\n        map<int,int>mp;\\n        \\n        int maxLen=INT_MIN;\\n        \\n        int n=nums.size();\\n        \\n        int tot_sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            tot_sum+=nums[i];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1404543,
                "title": "c-faster-than-100-different-from-other-approaches-intuitive-linear-time-constant-space",
                "content": "##### **Intuition** : Starting from the left end of the array, keep on subtracting elements from x till x becomes \\u2264 0. If x == 0, record this to be a possible answer. Now, we will revert back the changes we made to x from the left and at the same time make changes from the right. So we will add to x the latest element we subtracted from it from the left and then we will begin subtracting the elements from the right till x > 0 and if after some subtractions, x become 0, then we will compare the current number of operations with the minimum number of operations performed so far and record it be an answer if it is \\u2264 the current answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) \\n    {\\n        int l = 0, r = nums.size() - 1, ans = INT_MAX;\\n        \\n        while(l < nums.size() and x - nums[l] > 0)\\n            x -= nums[l++];\\n        \\n        if(x > 0 and l == nums.size())\\n            return -1;\\n        \\n        x -= nums[l];\\n        \\n        if(x == 0)\\n            ans = l + 1;\\n        \\n        \\n        while(l >= 0)\\n        {\\n            if(l >= 0)\\n                x += nums[l--];\\n            \\n            while(r > l and x > 0)\\n                x -= nums[r--];\\n            \\n            if(x == 0)\\n                ans = min(ans, 1 + l + (int)nums.size() - r - 1);  \\n        \\n        }        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) \\n    {\\n        int l = 0, r = nums.size() - 1, ans = INT_MAX;\\n        \\n        while(l < nums.size() and x - nums[l] > 0)\\n            x -= nums[l++];\\n        \\n        if(x > 0 and l == nums.size())\\n            return -1;\\n        \\n        x -= nums[l];\\n        \\n        if(x == 0)\\n            ans = l + 1;\\n        \\n        \\n        while(l >= 0)\\n        {\\n            if(l >= 0)\\n                x += nums[l--];\\n            \\n            while(r > l and x > 0)\\n                x -= nums[r--];\\n            \\n            if(x == 0)\\n                ans = min(ans, 1 + l + (int)nums.size() - r - 1);  \\n        \\n        }        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315830,
                "title": "c-simple-solution-sliding-window-98-faster",
                "content": "**Explanation:\\nThis problem is equivalent to finding longest subarray whose sum is (total sum of all elements of array - X)**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int su=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            su+=nums[i];\\n        }\\n        int sum=su-x,maxlen=-1,cursum=0,i=0,j=0;\\n        if(sum==0){\\n            return n;\\n        }\\n        while(j<n){\\n            cursum+=nums[j++];\\n            while(i<j && cursum>sum){\\n                cursum-=nums[i++];\\n            }\\n            if(cursum==sum){\\n                maxlen=max(maxlen,j-i);\\n            }\\n        }\\n        if(maxlen==-1){\\n            return -1;\\n        }\\n        return n-maxlen;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int su=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            su+=nums[i];\\n        }\\n        int sum=su-x,maxlen=-1,cursum=0,i=0,j=0;\\n        if(sum==0){\\n            return n;\\n        }\\n        while(j<n){\\n            cursum+=nums[j++];\\n            while(i<j && cursum>sum){\\n                cursum-=nums[i++];\\n            }\\n            if(cursum==sum){\\n                maxlen=max(maxlen,j-i);\\n            }\\n        }\\n        if(maxlen==-1){\\n            return -1;\\n        }\\n        return n-maxlen;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289402,
                "title": "simple-11-line-js-solution",
                "content": "---\\n# Simple Sliding Window Solution\\n---\\n* Sliding Window Technique\\n* Runtime: **100ms** Faster than **91.11%** of JavaScrtipt submissions\\n---\\n![image](https://assets.leetcode.com/users/images/3be828b7-3a53-4472-bb24-91dfed452193_1624346866.5461795.png)\\n\\n---\\n```\\nconst add = numbers => numbers.reduce((x, y) => x + y)\\n\\nvar minOperations = function(nums, x) {\\n    const total = add(nums)     \\n    if(total - x < 0) return -1\\n    let left = 0, sum = 0, max = -Infinity    \\n    \\n    for (let right = 0; right < nums.length; right++) {\\n        sum += nums[right]\\n        while (sum > total-x) sum -= nums[left++]\\n        max = sum === total - x ? Math.max(max, right - left + 1) : max\\n    }    \\n    \\n    return max === -Infinity ? -1 : nums.length - max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nconst add = numbers => numbers.reduce((x, y) => x + y)\\n\\nvar minOperations = function(nums, x) {\\n    const total = add(nums)     \\n    if(total - x < 0) return -1\\n    let left = 0, sum = 0, max = -Infinity    \\n    \\n    for (let right = 0; right < nums.length; right++) {\\n        sum += nums[right]\\n        while (sum > total-x) sum -= nums[left++]\\n        max = sum === total - x ? Math.max(max, right - left + 1) : max\\n    }    \\n    \\n    return max === -Infinity ? -1 : nums.length - max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254433,
                "title": "c-longest-subarray-with-sum-k-concept-easy-to-understand-with-comments",
                "content": "We were asked to reduce X -> 0 by using only first and last element of array, and with each operation, our array was being updated. We can observe this question in the following way :\\n  1. Assume our array be like [a, b, ..........x, y, z] and assume that X can be reduced to 0 with [a,b,x,y,z], then we can say that a+b+x+y+z = X. Since we need to minimize the number of [a,b,x,y,z], we can do so by maximizing the remaining subarray. ie by maximizing the length of [c+d+.....v+w], we can minimize the length of [a,b,x,y,z]\\n  2. We also know that [a+b+c+d+.......w+x+y+z] (ie sum of array) is SUM. Thus we can say that sum of [c+d+......v+w] = SUM - X. \\n  \\n  Now we have both, the array, and the sum of the subarray we need to maximize. Thus we can now apply the Longest Subarray Method to get the length of that subarray. Once we have that, we return Total_Length - SubArray_Length\\n  \\n  \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // We need to find Longest subarray with sum = total_sum - x\\n        // Using the prefix sum method to find the subarray size.\\n        vector <int> prefix;\\n        int temp_sum = 0;\\n        for(auto u : nums){\\n            temp_sum += u;\\n            prefix.push_back(temp_sum);\\n        }\\n        int sum = prefix.back();\\n        sum -= x;\\n        \\n        // If the sum of the subarray we need to find is zero, that simply means there is no subarray\\n        // because 1<=nums[i]<=10000\\n        if(sum == 0)\\n            return nums.size();\\n        \\n        // We store the prefix sum as key with its index as value\\n        map <int, int> mp;\\n        \\n        int len = -1;       // To store the length of Longest subarray\\n        /*\\n        Each time we encounter a subarray with sum \\'k\\'(from index 0 to i) or a subarray with \\n        sum \\'prefix[i] - k\\'(from index of \\'prefix[i]-k\\' to i), we compare it with current value \\n        of len and update len accordingly.\\n        */\\n        for(int i = 0; i<prefix.size(); i++){\\n            if(prefix[i] == sum)\\n                len = i+1;\\n            if(mp.find(prefix[i]-sum) != mp.end()){\\n                int temp_len =  i+1 - mp[prefix[i]-sum];\\n                if(temp_len > len)\\n                    len = temp_len;\\n            }\\n    \\n            mp[prefix[i]] = i+1;\\n        }\\n        // If len remains -1, that means we did not find any subarray with subA_sum == sum\\n        if(len == -1)\\n            return -1;\\n\\n        return nums.size() - len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // We need to find Longest subarray with sum = total_sum - x\\n        // Using the prefix sum method to find the subarray size.\\n        vector <int> prefix;\\n        int temp_sum = 0;\\n        for(auto u : nums){\\n            temp_sum += u;\\n            prefix.push_back(temp_sum);\\n        }\\n        int sum = prefix.back();\\n        sum -= x;\\n        \\n        // If the sum of the subarray we need to find is zero, that simply means there is no subarray\\n        // because 1<=nums[i]<=10000\\n        if(sum == 0)\\n            return nums.size();\\n        \\n        // We store the prefix sum as key with its index as value\\n        map <int, int> mp;\\n        \\n        int len = -1;       // To store the length of Longest subarray\\n        /*\\n        Each time we encounter a subarray with sum \\'k\\'(from index 0 to i) or a subarray with \\n        sum \\'prefix[i] - k\\'(from index of \\'prefix[i]-k\\' to i), we compare it with current value \\n        of len and update len accordingly.\\n        */\\n        for(int i = 0; i<prefix.size(); i++){\\n            if(prefix[i] == sum)\\n                len = i+1;\\n            if(mp.find(prefix[i]-sum) != mp.end()){\\n                int temp_len =  i+1 - mp[prefix[i]-sum];\\n                if(temp_len > len)\\n                    len = temp_len;\\n            }\\n    \\n            mp[prefix[i]] = i+1;\\n        }\\n        // If len remains -1, that means we did not find any subarray with subA_sum == sum\\n        if(len == -1)\\n            return -1;\\n\\n        return nums.size() - len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222046,
                "title": "easy-c-soln-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    //find maximum subarray with sum =total sum-x\\n    int minOperations(vector<int>& nums, int x) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        if(sum==x)return nums.size();\\n        int i=0,j=0;\\n        int tar=sum-x,temp=0;\\n        int res=-1;\\n        while(i<nums.size()){\\n            temp+=nums[i];\\n            cout<<temp<<\"  \";\\n            while(j<i && temp>tar){\\n                temp-=nums[j];\\n                j++;\\n            }\\n            if(temp==tar)res=max(res,i-j+1);\\n            i++;\\n        }\\n        cout<<res;\\n        return res==-1?-1:nums.size()-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //find maximum subarray with sum =total sum-x\\n    int minOperations(vector<int>& nums, int x) {\\n        int sum=accumulate(nums.begin(),nums.end(),0);\\n        if(sum==x)return nums.size();\\n        int i=0,j=0;\\n        int tar=sum-x,temp=0;\\n        int res=-1;\\n        while(i<nums.size()){\\n            temp+=nums[i];\\n            cout<<temp<<\"  \";\\n            while(j<i && temp>tar){\\n                temp-=nums[j];\\n                j++;\\n            }\\n            if(temp==tar)res=max(res,i-j+1);\\n            i++;\\n        }\\n        cout<<res;\\n        return res==-1?-1:nums.size()-res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1019467,
                "title": "c-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n       \\n       int sum=0;\\n        for(auto i:nums)sum+=i;\\n        sum-=x;\\n        if(sum<0)return -1;\\n        if(sum==0)return nums.size();\\n        int start=0,len=-1,val=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(val<sum){\\n                val+=nums[i];\\n            }\\n            while(val>=sum){\\n                if(val==sum){\\n                    len=max(len,i-start+1);\\n                }\\n                val-=nums[start++];\\n            }\\n        }\\n        \\n        return len==-1?-1:nums.size()-len;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n       \\n       int sum=0;\\n        for(auto i:nums)sum+=i;\\n        sum-=x;\\n        if(sum<0)return -1;\\n        if(sum==0)return nums.size();\\n        int start=0,len=-1,val=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(val<sum){\\n                val+=nums[i];\\n            }\\n            while(val>=sum){\\n                if(val==sum){\\n                    len=max(len,i-start+1);\\n                }\\n                val-=nums[start++];\\n            }\\n        }\\n        \\n        return len==-1?-1:nums.size()-len;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017753,
                "title": "python-3-obverse-sliding-window-time-o-l-r-space-o-1",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        ret = inf; s = 0; j = -1\\n        for i, n in enumerate(nums):\\n            s += n\\n            if s > x: break\\n        else:\\n            return i-j if s == x else -1\\n\\n        while i >= 0:\\n            s -= nums[i]; i -= 1\\n            while s < x:\\n                s += nums[j]; j -= 1\\n            if s == x: ret = min(ret, i-j)\\n            \\n        return ret if ret < inf else -1\\n```\\n\\n- Think **straight**. It requires less time complexity.\\n- Find minimum number ```i``` of left elements with sum >= x. So we get a starting window completly on the left side. It is inefficient to sum all elements.\\n- Iteretively slide the window. While the window has left shoulder remove one deepest left element and add zero or more elements ```j``` from the right side. \\n- If window sum is equal to x then check if it is minimum.\\n- Time complexity is ```O(l+r)```, ```l``` and ```r``` are leftmost and rightmost window length. In worst case it is ```O(n)```. Space complexity is ```O(1)```.",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        ret = inf; s = 0; j = -1\\n        for i, n in enumerate(nums):\\n            s += n\\n            if s > x: break\\n        else:\\n            return i-j if s == x else -1\\n\\n        while i >= 0:\\n            s -= nums[i]; i -= 1\\n            while s < x:\\n                s += nums[j]; j -= 1\\n            if s == x: ret = min(ret, i-j)\\n            \\n        return ret if ret < inf else -1\\n```\n```i```\n```j```\n```O(l+r)```\n```l```\n```r```\n```O(n)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1016909,
                "title": "c-reverse-thinking-one-success-and-failure",
                "content": "Approach: 2-pointer indirectly[1]:\\nWhat is the maximum size of middle zone with sum equals total_sum - x\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total = 0;\\n        for (int num : nums)  total += num;        \\n        int n = nums.size();\\n        int maxi = -1;\\n        int left = 0;\\n        int current = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            // sum([left ,..., right]) = total - x\\n            current += nums[right];\\n            // if larger, move `left` to left\\n            while (current > total - x && left <= right) {\\n                current -= nums[left];\\n                left += 1;\\n            }\\n            // check if equal\\n            if (current == total - x) {\\n                maxi = max(maxi, right - left + 1);\\n            }\\n        }\\n        return maxi != -1 ? n - maxi : -1;\\n    }\\n};\\n```\\n\\nApproach 2: DFS: Wrong. Need debug and help.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        return dfs(nums, x, 0, nums.size() - 1);        \\n    }\\n    \\nprivate:\\n    int dfs(vector<int>& nums, int x, int l, int r) {\\n        const int n = r - l + 1;\\n        if(n < 1 || nums[l] > x && nums[r] > x || x < 0) return -1;\\n        if(x == 0) return n - (r - l + 1);\\n        int left = dfs(nums, x - nums[l], l+1, r);\\n        int right = dfs(nums, x - nums[r], l, r-1);\\n        if(left == -1 && right == -1) return -1;\\n        else if(left == -1) return right + n - (r -l + 1);\\n        else if(right == -1) return left + n - (r -l + 1);\\n        else return min(left, right) + 1;        \\n    }\\n};\\n```\\nReference:\\n[1] https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int total = 0;\\n        for (int num : nums)  total += num;        \\n        int n = nums.size();\\n        int maxi = -1;\\n        int left = 0;\\n        int current = 0;\\n\\n        for (int right = 0; right < n; right++) {\\n            // sum([left ,..., right]) = total - x\\n            current += nums[right];\\n            // if larger, move `left` to left\\n            while (current > total - x && left <= right) {\\n                current -= nums[left];\\n                left += 1;\\n            }\\n            // check if equal\\n            if (current == total - x) {\\n                maxi = max(maxi, right - left + 1);\\n            }\\n        }\\n        return maxi != -1 ? n - maxi : -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        return dfs(nums, x, 0, nums.size() - 1);        \\n    }\\n    \\nprivate:\\n    int dfs(vector<int>& nums, int x, int l, int r) {\\n        const int n = r - l + 1;\\n        if(n < 1 || nums[l] > x && nums[r] > x || x < 0) return -1;\\n        if(x == 0) return n - (r - l + 1);\\n        int left = dfs(nums, x - nums[l], l+1, r);\\n        int right = dfs(nums, x - nums[r], l, r-1);\\n        if(left == -1 && right == -1) return -1;\\n        else if(left == -1) return right + n - (r -l + 1);\\n        else if(right == -1) return left + n - (r -l + 1);\\n        else return min(left, right) + 1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016732,
                "title": "c-beating-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // example \\n        // [1,1,4,2,3] , x=5\\n        // target = sum(nums)-x, which is => 6 in this case \\n        // we will try to find longest subarray with given target\\n        // max length with target is 3 [1,1,4]\\n        // our ans is nums.size()-3 => 2\\n        \\n        int target=-x;\\n        for(int i:nums)\\n        {\\n            target+=i;\\n        }\\n        if(target<0)\\n            return -1;\\n        int j=0;\\n        int sum=0;\\n        int ans=INT_MIN;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i]; \\n            while(sum>target)\\n            {\\n                sum-=nums[j];\\n                j++;\\n            }\\n            if(sum==target)\\n            {\\n                ans=max(ans,i-j+1);\\n            }\\n        }\\n        return ans==INT_MIN?-1:n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        // example \\n        // [1,1,4,2,3] , x=5\\n        // target = sum(nums)-x, which is => 6 in this case \\n        // we will try to find longest subarray with given target\\n        // max length with target is 3 [1,1,4]\\n        // our ans is nums.size()-3 => 2\\n        \\n        int target=-x;\\n        for(int i:nums)\\n        {\\n            target+=i;\\n        }\\n        if(target<0)\\n            return -1;\\n        int j=0;\\n        int sum=0;\\n        int ans=INT_MIN;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i]; \\n            while(sum>target)\\n            {\\n                sum-=nums[j];\\n                j++;\\n            }\\n            if(sum==target)\\n            {\\n                ans=max(ans,i-j+1);\\n            }\\n        }\\n        return ans==INT_MIN?-1:n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016615,
                "title": "java-c-binary-search-hashmap-to-sliding-window-intuition",
                "content": "# Brute Force\\n\\nIf we were to try brute force, we would perform a running sum from left to right. In each iteration of the running sum, we would try to find the corresponding sum adding up to x by running another running sum from right to left. \\n\\nThis way would be O(N^2) time complexity, O(1) space complexity.\\n\\n---\\n\\n<br>\\n\\n# Binary Search\\n\\n* The intuition is that, we require extra information to reduce the time complexity. \\n* If I already has the prefix sum array from left to right beforehand, then while performing a running sum from right to left, I can query the prefix sum array for the value required to add up to x in O(log N) time using binary search due to the fact that **prefix sum will be strictly increasing - sorted**.\\n* The overall time complexity will be then O(N log N), but extra space of O(N)\\n\\n#### Java\\n\\n```java\\npublic int minOperations(int[] nums, int x) {\\n\\tfinal int len = nums.length;\\n\\tint cumulative = 0;\\n\\n\\t//\\tCreation of Prefix Sum Array\\n\\tint[] prefixSum = new int[len + 1];\\n\\tfor (int i = 0; i < len; ++i)\\n\\t\\tprefixSum[i+1] = nums[i] + prefixSum[i];\\n\\n\\t//\\tIf we only pop from left side.\\n\\tint res = binarySearch(prefixSum, x);\\n\\n\\t//\\tStart summing from the right side\\n\\tfor (int i = 1; i <= len; ++i) {\\n\\t\\tcumulative += nums[len - i];\\n\\n\\t\\tint search = binarySearch(prefixSum, x - cumulative);\\n\\t\\t//\\tInvalid when: 1. Not found 2. Required range overlap with right subarray\\n\\t\\tif (search == Integer.MAX_VALUE || search >= len-i ) continue;\\n\\t\\t//\\tOtherwise a valid value! Record\\n\\t\\tres = Math.min(res, i + search);\\n\\t}\\n\\n\\treturn res == Integer.MAX_VALUE? -1: res;\\n}\\n\\nprivate int binarySearch(int[] prefixSum, int val) {\\n\\tint left = 0, right = prefixSum.length - 1;\\n\\n\\twhile (left < right) {\\n\\t\\tint mid = left + (right - left) / 2;\\n\\t\\tif (prefixSum[mid] < val) \\n\\t\\t\\tleft = mid + 1;\\n\\t\\telse\\n\\t\\t\\tright = mid;\\n\\t}\\n\\n\\treturn prefixSum[left] == val? left: Integer.MAX_VALUE;\\t//\\tReturns INF if not found\\n}\\n```\\n\\n#### CPP\\n\\n```cpp\\nint minOperations(vector<int>& nums, int x) {\\n\\tconst int len = nums.size();\\n\\tint cumulative = 0;\\n\\n\\t//\\tCreation of Prefix Sum Array\\n\\tvector<int> prefixSum(len + 1, 0);\\n\\tfor (int i = 0; i < len; ++i)\\n\\t\\tprefixSum[i + 1] = nums[i] + prefixSum[i];\\n\\n\\t//\\tIf we only pop from left side.\\n\\tint res = binarySearch(prefixSum, x);\\n\\n\\t//\\tStart summing from the right side\\n\\tfor (int i = 1; i <= len; ++i) {\\n\\t\\tcumulative += nums[len - i];\\n\\n\\t\\tint search = binarySearch(prefixSum, x - cumulative);\\n\\t\\t//\\tInvalid when: 1. Not found 2. Required range overlap with right subarray\\n\\t\\tif (search == INT32_MAX || search > len - i) continue;\\n\\t\\t//\\tOtherwise a valid value! Record\\n\\t\\tres = min(res, i + search);\\n\\t}\\n\\n\\treturn res == INT32_MAX ? -1 : res;\\n}\\n\\nint binarySearch(vector<int>& prefixSum, int val) {\\n\\tint left = 0, right = prefixSum.size() - 1;\\n\\n\\twhile (left < right) {\\n\\t\\tint mid = left + (right - left) / 2;\\n\\t\\tif (prefixSum[mid] < val)\\n\\t\\t\\tleft = mid + 1;\\n\\t\\telse\\n\\t\\t\\tright = mid;\\n\\t}\\n\\n\\treturn prefixSum[left] == val ? left : INT32_MAX;\\n}\\n```\\n\\n<br>\\n\\n# Binary Search to HashMap\\n\\n* In binary search, at the end of the search, if the value at left pointer is not equal to the desired search value, it will return a invalid flag to indicate the value is not found.\\n* Then, realize that instead of searching for a specific value in prefix sum array using binary search, why not store all possible prefix sums into the HashMap where the length of the subarray is the value?\\n* This way time complexity is further reduced to O(N) but still same space complexity of O(N)\\n\\n<br>\\n\\n# Two pointers, Sliding window\\n\\n* The intuition is, when performing running sum, the sum must be strictly increasing. The required counterpart to sum up to x must be strictly decreasing then.\\n\\n* This idea came across when I am thinking about a Stack solution storing the prefix sums\\n* Perform running sum from left to right. Running sum is stored in `lSum`. If `lSum` matches `x`, record the length. Sum until the end of array.\\n* We would have two pointers `lPt` and `rPt`. `lPt` point at the tail of the left part of array. `rPt` will point at the head of the right side of array. After the above running sum, `lPt` will be at the end of array since we essentially summed everything from index 0 to n-1.\\n* Then, we would start another running sum from right to left. In each iteration, we will run a loop to retract the range of left array covered if needed:\\n\\t* If left pointer overlap with right pointer - Eg `leftPt` at n-1 and `rPt` also at n-1 when the running sum just started\\n\\t* If the sum covered by left array is too large, that is `lSum > x - rSum` \\n\\n* Once retracting process is done, it is either the `lSum` is less than or equal to the required value to add up to x, or `lPt` had hit index -1 (Left array exhausted)\\n* Check if `lSum` is now having the required value or not. If yes, record the length of left and right array combined.\\n\\n#### Java\\n\\n```java\\npublic int minOperations(int[] nums, int x) {\\n\\tfinal int len = nums.length;\\n\\tint res = Integer.MAX_VALUE;\\n\\tint lSum = 0, lPt = len-1;\\n\\n\\t//\\tFill up to the right first\\n\\tfor (int i = 0; i < len; ++i) {\\n\\t\\tlSum += nums[i];\\n\\t\\tif (lSum == x) res = i+1;\\n\\t}\\n\\n\\tint rSum = 0; \\n\\t//\\tFilling up to the left, while attempting to search left cumulative.\\n\\tfor (int i = len - 1; i >= 0; --i) {\\n\\t\\trSum += nums[i];\\n\\n\\t\\t//\\tIf left pointer overlaps, or left sum is still exceeding, retract\\n\\t\\twhile (lPt == i || (lPt >= 0 && lSum > x - rSum) ) {\\n\\t\\t\\tlSum -= nums[lPt];\\n\\t\\t\\t--lPt;\\n\\t\\t}\\n\\n\\t\\t//\\tCheck leftsum\\n\\t\\tif (lSum == x - rSum )\\n\\t\\t\\tres = Math.min(res, lPt + 1 + len - i);\\n\\t}\\n\\n\\treturn res == Integer.MAX_VALUE? -1: res;\\n}\\n```\\n\\n#### C++\\n\\n```cpp\\nint minOperations(vector<int>& nums, int x) {\\n\\tconst int len = nums.size();\\n\\tint res = INT32_MAX;\\n\\tint lSum = 0, lPt = len - 1;\\n\\n\\t//\\tFill up to the right first\\n\\tfor (int i = 0; i < len; ++i) {\\n\\t\\tlSum += nums[i];\\n\\t\\tif (lSum == x) res = i + 1;\\n\\t}\\n\\n\\tint rSum = 0;\\n\\t//\\tFilling up to the left, while attempting to search left cumulative.\\n\\tfor (int i = len - 1; i >= 0; --i) {\\n\\t\\trSum += nums[i];\\n\\n\\t\\t//\\tIf left pointer overlaps, or left sum is greater than required value\\n\\t\\twhile (lPt == i || (lPt >= 0 && lSum > x - rSum)) {\\n\\t\\t\\tlSum -= nums[lPt];\\n\\t\\t\\t--lPt;\\n\\t\\t}\\n\\n\\t\\t//\\tCheck leftSum\\n\\t\\tif (lSum == x - rSum)\\n\\t\\t\\tres = min(res, lPt + 1 + len - i);\\n\\t}\\n\\n\\treturn res == INT32_MAX ? -1 : res;\\n}\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```java\\npublic int minOperations(int[] nums, int x) {\\n\\tfinal int len = nums.length;\\n\\tint cumulative = 0;\\n\\n\\t//\\tCreation of Prefix Sum Array\\n\\tint[] prefixSum = new int[len + 1];\\n\\tfor (int i = 0; i < len; ++i)\\n\\t\\tprefixSum[i+1] = nums[i] + prefixSum[i];\\n\\n\\t//\\tIf we only pop from left side.\\n\\tint res = binarySearch(prefixSum, x);\\n\\n\\t//\\tStart summing from the right side\\n\\tfor (int i = 1; i <= len; ++i) {\\n\\t\\tcumulative += nums[len - i];\\n\\n\\t\\tint search = binarySearch(prefixSum, x - cumulative);\\n\\t\\t//\\tInvalid when: 1. Not found 2. Required range overlap with right subarray\\n\\t\\tif (search == Integer.MAX_VALUE || search >= len-i ) continue;\\n\\t\\t//\\tOtherwise a valid value! Record\\n\\t\\tres = Math.min(res, i + search);\\n\\t}\\n\\n\\treturn res == Integer.MAX_VALUE? -1: res;\\n}\\n\\nprivate int binarySearch(int[] prefixSum, int val) {\\n\\tint left = 0, right = prefixSum.length - 1;\\n\\n\\twhile (left < right) {\\n\\t\\tint mid = left + (right - left) / 2;\\n\\t\\tif (prefixSum[mid] < val) \\n\\t\\t\\tleft = mid + 1;\\n\\t\\telse\\n\\t\\t\\tright = mid;\\n\\t}\\n\\n\\treturn prefixSum[left] == val? left: Integer.MAX_VALUE;\\t//\\tReturns INF if not found\\n}\\n```\n```cpp\\nint minOperations(vector<int>& nums, int x) {\\n\\tconst int len = nums.size();\\n\\tint cumulative = 0;\\n\\n\\t//\\tCreation of Prefix Sum Array\\n\\tvector<int> prefixSum(len + 1, 0);\\n\\tfor (int i = 0; i < len; ++i)\\n\\t\\tprefixSum[i + 1] = nums[i] + prefixSum[i];\\n\\n\\t//\\tIf we only pop from left side.\\n\\tint res = binarySearch(prefixSum, x);\\n\\n\\t//\\tStart summing from the right side\\n\\tfor (int i = 1; i <= len; ++i) {\\n\\t\\tcumulative += nums[len - i];\\n\\n\\t\\tint search = binarySearch(prefixSum, x - cumulative);\\n\\t\\t//\\tInvalid when: 1. Not found 2. Required range overlap with right subarray\\n\\t\\tif (search == INT32_MAX || search > len - i) continue;\\n\\t\\t//\\tOtherwise a valid value! Record\\n\\t\\tres = min(res, i + search);\\n\\t}\\n\\n\\treturn res == INT32_MAX ? -1 : res;\\n}\\n\\nint binarySearch(vector<int>& prefixSum, int val) {\\n\\tint left = 0, right = prefixSum.size() - 1;\\n\\n\\twhile (left < right) {\\n\\t\\tint mid = left + (right - left) / 2;\\n\\t\\tif (prefixSum[mid] < val)\\n\\t\\t\\tleft = mid + 1;\\n\\t\\telse\\n\\t\\t\\tright = mid;\\n\\t}\\n\\n\\treturn prefixSum[left] == val ? left : INT32_MAX;\\n}\\n```\n```java\\npublic int minOperations(int[] nums, int x) {\\n\\tfinal int len = nums.length;\\n\\tint res = Integer.MAX_VALUE;\\n\\tint lSum = 0, lPt = len-1;\\n\\n\\t//\\tFill up to the right first\\n\\tfor (int i = 0; i < len; ++i) {\\n\\t\\tlSum += nums[i];\\n\\t\\tif (lSum == x) res = i+1;\\n\\t}\\n\\n\\tint rSum = 0; \\n\\t//\\tFilling up to the left, while attempting to search left cumulative.\\n\\tfor (int i = len - 1; i >= 0; --i) {\\n\\t\\trSum += nums[i];\\n\\n\\t\\t//\\tIf left pointer overlaps, or left sum is still exceeding, retract\\n\\t\\twhile (lPt == i || (lPt >= 0 && lSum > x - rSum) ) {\\n\\t\\t\\tlSum -= nums[lPt];\\n\\t\\t\\t--lPt;\\n\\t\\t}\\n\\n\\t\\t//\\tCheck leftsum\\n\\t\\tif (lSum == x - rSum )\\n\\t\\t\\tres = Math.min(res, lPt + 1 + len - i);\\n\\t}\\n\\n\\treturn res == Integer.MAX_VALUE? -1: res;\\n}\\n```\n```cpp\\nint minOperations(vector<int>& nums, int x) {\\n\\tconst int len = nums.size();\\n\\tint res = INT32_MAX;\\n\\tint lSum = 0, lPt = len - 1;\\n\\n\\t//\\tFill up to the right first\\n\\tfor (int i = 0; i < len; ++i) {\\n\\t\\tlSum += nums[i];\\n\\t\\tif (lSum == x) res = i + 1;\\n\\t}\\n\\n\\tint rSum = 0;\\n\\t//\\tFilling up to the left, while attempting to search left cumulative.\\n\\tfor (int i = len - 1; i >= 0; --i) {\\n\\t\\trSum += nums[i];\\n\\n\\t\\t//\\tIf left pointer overlaps, or left sum is greater than required value\\n\\t\\twhile (lPt == i || (lPt >= 0 && lSum > x - rSum)) {\\n\\t\\t\\tlSum -= nums[lPt];\\n\\t\\t\\t--lPt;\\n\\t\\t}\\n\\n\\t\\t//\\tCheck leftSum\\n\\t\\tif (lSum == x - rSum)\\n\\t\\t\\tres = min(res, lPt + 1 + len - i);\\n\\t}\\n\\n\\treturn res == INT32_MAX ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016422,
                "title": "java-solution-using-prefix-sum",
                "content": "```\\n\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int totalSum = 0;\\n        for(int ele:nums)\\n        {\\n            totalSum += ele;\\n        }\\n        \\n        int target = totalSum - x;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        \\n        int maxLenSubArray = -1;\\n        int prefixSum = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prefixSum += nums[i];\\n            map.put(prefixSum,i);\\n            \\n            if(map.containsKey(prefixSum - target))\\n            {\\n                int currSubArrayLen = i - map.get(prefixSum-target);\\n                maxLenSubArray = Math.max(currSubArrayLen, maxLenSubArray);\\n            }\\n        }\\n        if(maxLenSubArray==-1)\\n            return maxLenSubArray;\\n        \\n        return nums.length-maxLenSubArray;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int totalSum = 0;\\n        for(int ele:nums)\\n        {\\n            totalSum += ele;\\n        }\\n        \\n        int target = totalSum - x;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        \\n        int maxLenSubArray = -1;\\n        int prefixSum = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prefixSum += nums[i];\\n            map.put(prefixSum,i);\\n            \\n            if(map.containsKey(prefixSum - target))\\n            {\\n                int currSubArrayLen = i - map.get(prefixSum-target);\\n                maxLenSubArray = Math.max(currSubArrayLen, maxLenSubArray);\\n            }\\n        }\\n        if(maxLenSubArray==-1)\\n            return maxLenSubArray;\\n        \\n        return nums.length-maxLenSubArray;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004978,
                "title": "simple-c-solution-with-comments",
                "content": "```\\n// Runtime: 692 ms, faster than 48.90% of C++ online submissions for Minimum Operations to Reduce X to Zero.\\n// Memory Usage: 144.7 MB, less than 45.55% of C++ online submissions for Minimum Operations to Reduce X to Zero.\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A, int x) {\\n        // there are 3 possibilities \\n            // 1. we take elements from left side only\\n            // 2. we take elements from right side only\\n            // 3. we take elements from both left and right side \\n        \\n        int ans=INT_MAX,s=0; \\n        unordered_map<int,int>m;\\n        for(int i=0;i<A.size();++i)   // sum with left elements only\\n        {\\n            s+=A[i];\\n            if(s==x)\\n            {\\n                ans=i+1;    // because numbers are positive so sum in increasing\\n                break;\\n            }\\n            if(s>x) break;  \\n            m[s]=i+1;\\n        }\\n        s=0;\\n        for(int i=A.size()-1;i>=0;--i)        // now we see if cases 2 or 3 are possible or not\\n        {\\n            s+=A[i];\\n            if(s==x)                          // sum with right elements only\\n            {\\n                ans=min(ans,(int)A.size()-i);\\n            }\\n            if(m.count(x-s))                  // sum with both left and right elements\\n            {\\n                if(m[x-s]<i)                  // ensuring that indicies dont overlap \\n                    ans=min(ans,m[x-s]+(int)A.size()-i);\\n            }\\n            if(s>x) break;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Runtime: 692 ms, faster than 48.90% of C++ online submissions for Minimum Operations to Reduce X to Zero.\\n// Memory Usage: 144.7 MB, less than 45.55% of C++ online submissions for Minimum Operations to Reduce X to Zero.\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A, int x) {\\n        // there are 3 possibilities \\n            // 1. we take elements from left side only\\n            // 2. we take elements from right side only\\n            // 3. we take elements from both left and right side \\n        \\n        int ans=INT_MAX,s=0; \\n        unordered_map<int,int>m;\\n        for(int i=0;i<A.size();++i)   // sum with left elements only\\n        {\\n            s+=A[i];\\n            if(s==x)\\n            {\\n                ans=i+1;    // because numbers are positive so sum in increasing\\n                break;\\n            }\\n            if(s>x) break;  \\n            m[s]=i+1;\\n        }\\n        s=0;\\n        for(int i=A.size()-1;i>=0;--i)        // now we see if cases 2 or 3 are possible or not\\n        {\\n            s+=A[i];\\n            if(s==x)                          // sum with right elements only\\n            {\\n                ans=min(ans,(int)A.size()-i);\\n            }\\n            if(m.count(x-s))                  // sum with both left and right elements\\n            {\\n                if(m[x-s]<i)                  // ensuring that indicies dont overlap \\n                    ans=min(ans,m[x-s]+(int)A.size()-i);\\n            }\\n            if(s>x) break;\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978265,
                "title": "87-93-faster-all-3-sliding-window-dp-top-down-recursive-approaches",
                "content": "![image](https://assets.leetcode.com/users/images/98b6a1cb-021d-443c-8628-854324e27703_1608414872.0739396.png)\\n```\\npublic class Solution {\\n    // Time O(n) || Space O(1)\\n    public int MinOperations(int[] nums, int x) {\\n        int start=0,last=0,maxLen = -1, currWindowSum = 0, total = 0;;\\n        for(int i=0;i<nums.Length;i++) total+=nums[i];\\n        \\n        while(last < nums.Length)\\n        {\\n            currWindowSum += nums[last];\\n            while(currWindowSum > total - x && start <= last)\\n                currWindowSum -= nums[start++];\\n            if(currWindowSum == total-x)\\n                maxLen = Math.Max(maxLen,last-start+1);\\n            last++;\\n        }\\n        return maxLen != -1 ? nums.Length - maxLen : -1;\\n        //bool foundZero = false;\\n        //return ReduceToZero(nums,0,nums.Length-1,x, ref foundZero);\\n        //return MinOperationsToReduceToZero_DP(nums, 0, nums.Length - 1, x, ref foundZero, new Dictionary<string, int>(nums.Length));\\n    }\\n    /*\\n    // Recursive Approach // TLE\\n    public static int ReduceToZero(int[] nums, int start, int last, int sumLeft, ref bool is0)\\n    {\\n        if(sumLeft==0)\\n        { is0 = true; return 0; }\\n        \\n        if(start>last || sumLeft < 0)\\n            return -1;\\n        \\n        int stepsReqL = int.MaxValue, stepsReqR = int.MaxValue;\\n        bool got0Left=false, got0Right=false;\\n        \\n        stepsReqL = ReduceToZero(nums,start+1,last,sumLeft-nums[start],ref got0Left);\\n        stepsReqR = ReduceToZero(nums,start,last-1,sumLeft-nums[last],ref got0Right);\\n        \\n        // if we got zero either by removing from left or right side num\\n        if(got0Left || got0Right)\\n        {\\n            is0 = true;\\n            // if we got zero from both left or right ends\\n            if(got0Left && got0Right)\\n                return 1 + Math.Min(stepsReqL,stepsReqR);\\n            else\\n                return 1 + (got0Left ? stepsReqL : stepsReqR);\\n        }\\n        return -1;\\n    }\\n    \\n    // DP Top-Down Approach\\n    public static int MinOperationsToReduceToZero_DP(int[] nums, int start, int last, int sumLeft, ref bool is0, Dictionary<string,int> cache)\\n    {\\n        if (sumLeft == 0)\\n        { is0 = true; return 0; }\\n\\n        if (start > last || sumLeft < 0)\\n            return -1;\\n\\n        string key = start + \",\" + last;\\n        if (cache.ContainsKey(key))\\n        {\\n            if (cache[key] != -1) is0 = true; \\n            return cache[key];\\n        }\\n\\n        int stepsReqL = int.MaxValue, stepsReqR = int.MaxValue, value = -1;\\n        bool got0Left = false, got0Right = false;\\n\\n        stepsReqL = MinOperationsToReduceToZero_DP(nums, start + 1, last, sumLeft - nums[start], ref got0Left, cache);\\n        stepsReqR = MinOperationsToReduceToZero_DP(nums, start, last - 1, sumLeft - nums[last], ref got0Right, cache);\\n\\n        if (got0Left || got0Right)                                  // if we got zero either by removing from left or right side num\\n            if (got0Left && got0Right)\\n                value = 1 + Math.Min(stepsReqL, stepsReqR);        // if we got zero from both left or right ends, assign min steps of two\\n            else\\n                value = 1 + (got0Left ? stepsReqL : stepsReqR);     // assign steps from where we got zero\\n\\n        if (value != -1)\\n            is0 = true;\\n\\n        cache.Add(key, value);\\n        return value;\\n    }\\n    */\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    // Time O(n) || Space O(1)\\n    public int MinOperations(int[] nums, int x) {\\n        int start=0,last=0,maxLen = -1, currWindowSum = 0, total = 0;;\\n        for(int i=0;i<nums.Length;i++) total+=nums[i];\\n        \\n        while(last < nums.Length)\\n        {\\n            currWindowSum += nums[last];\\n            while(currWindowSum > total - x && start <= last)\\n                currWindowSum -= nums[start++];\\n            if(currWindowSum == total-x)\\n                maxLen = Math.Max(maxLen,last-start+1);\\n            last++;\\n        }\\n        return maxLen != -1 ? nums.Length - maxLen : -1;\\n        //bool foundZero = false;\\n        //return ReduceToZero(nums,0,nums.Length-1,x, ref foundZero);\\n        //return MinOperationsToReduceToZero_DP(nums, 0, nums.Length - 1, x, ref foundZero, new Dictionary<string, int>(nums.Length));\\n    }\\n    /*\\n    // Recursive Approach // TLE\\n    public static int ReduceToZero(int[] nums, int start, int last, int sumLeft, ref bool is0)\\n    {\\n        if(sumLeft==0)\\n        { is0 = true; return 0; }\\n        \\n        if(start>last || sumLeft < 0)\\n            return -1;\\n        \\n        int stepsReqL = int.MaxValue, stepsReqR = int.MaxValue;\\n        bool got0Left=false, got0Right=false;\\n        \\n        stepsReqL = ReduceToZero(nums,start+1,last,sumLeft-nums[start],ref got0Left);\\n        stepsReqR = ReduceToZero(nums,start,last-1,sumLeft-nums[last],ref got0Right);\\n        \\n        // if we got zero either by removing from left or right side num\\n        if(got0Left || got0Right)\\n        {\\n            is0 = true;\\n            // if we got zero from both left or right ends\\n            if(got0Left && got0Right)\\n                return 1 + Math.Min(stepsReqL,stepsReqR);\\n            else\\n                return 1 + (got0Left ? stepsReqL : stepsReqR);\\n        }\\n        return -1;\\n    }\\n    \\n    // DP Top-Down Approach\\n    public static int MinOperationsToReduceToZero_DP(int[] nums, int start, int last, int sumLeft, ref bool is0, Dictionary<string,int> cache)\\n    {\\n        if (sumLeft == 0)\\n        { is0 = true; return 0; }\\n\\n        if (start > last || sumLeft < 0)\\n            return -1;\\n\\n        string key = start + \",\" + last;\\n        if (cache.ContainsKey(key))\\n        {\\n            if (cache[key] != -1) is0 = true; \\n            return cache[key];\\n        }\\n\\n        int stepsReqL = int.MaxValue, stepsReqR = int.MaxValue, value = -1;\\n        bool got0Left = false, got0Right = false;\\n\\n        stepsReqL = MinOperationsToReduceToZero_DP(nums, start + 1, last, sumLeft - nums[start], ref got0Left, cache);\\n        stepsReqR = MinOperationsToReduceToZero_DP(nums, start, last - 1, sumLeft - nums[last], ref got0Right, cache);\\n\\n        if (got0Left || got0Right)                                  // if we got zero either by removing from left or right side num\\n            if (got0Left && got0Right)\\n                value = 1 + Math.Min(stepsReqL, stepsReqR);        // if we got zero from both left or right ends, assign min steps of two\\n            else\\n                value = 1 + (got0Left ? stepsReqL : stepsReqR);     // assign steps from where we got zero\\n\\n        if (value != -1)\\n            is0 = true;\\n\\n        cache.Add(key, value);\\n        return value;\\n    }\\n    */\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965669,
                "title": "simple-solution",
                "content": "```class Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target = sum(nums) - x\\n        if target < 0: return \"-1\"\\n        if target == 0: return len(nums)\\n\\n        left = 0\\n        cur_sum = 0\\n        finded_target_length = -1\\n\\n        for i in range(len(nums)):\\n            if cur_sum < target:\\n                cur_sum = cur_sum + nums[i]\\n            while cur_sum >= target:\\n                if cur_sum == target:\\n                    finded_target_length = max(finded_target_length, i - left + 1)\\n                cur_sum = cur_sum - nums[left]\\n                left += 1\\n        return len(nums) - finded_target_length if finded_target_length != -1 else -1```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        target = sum(nums) - x\\n        if target < 0: return \"-1\"\\n        if target == 0: return len(nums)\\n\\n        left = 0\\n        cur_sum = 0\\n        finded_target_length = -1\\n\\n        for i in range(len(nums)):\\n            if cur_sum < target:\\n                cur_sum = cur_sum + nums[i]\\n            while cur_sum >= target:\\n                if cur_sum == target:\\n                    finded_target_length = max(finded_target_length, i - left + 1)\\n                cur_sum = cur_sum - nums[left]\\n                left += 1\\n        return len(nums) - finded_target_length if finded_target_length != -1 else -1```",
                "codeTag": "Java"
            },
            {
                "id": 959902,
                "title": "java-solution-with-two-pointers-and-binary-search",
                "content": "This problem can be solved by both two pointers and binary search. There are only 3 ways in which we can reduce x to 0\\n1. Use elements only from left of array i.e., no elements from right\\n2. Use elements only from right of array i.e., no elements from left\\n3. Use few elements from left and few elements from right\\n\\n**Two pointers:**\\nWhen we subtract x from sum of all elements in the array (**sum - x**), result is sum of all elements which we want to keep after reducing x to 0. If we can find a continuous subarray which gives us **sum - x**, then sum of all the remaining elements is x. So, it takes (length of array) -  (length of sub array with sum equals to **sum - x**)\\n\\n```\\n public int minOperations(int[] nums, int x) {\\n        int l = nums.length, ans = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int i : nums){\\n            sum += i;\\n        }\\n        int k = sum - x;\\n        sum = 0;\\n        int jsum = 0;\\n        for(int i = 0, j = -1; i < l; i++){\\n            sum += nums[i];\\n            while(j < i && sum - jsum > k){\\n                jsum += nums[++j];\\n            }\\n            if(sum - jsum == k) ans = Math.min(ans, l - i + j);\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n```\\n\\n**Binary Search:**\\nFind the prefix sum of all elements and store in array. Now from right to left for each position **i**, find cumulative sum and use binary search to find the remaining sum i.e., **sum - cumsum** in the subarray  (0, i). At each position **i**, we can calcuate min of all\\n```\\npublic int minOperations(int[] nums, int x) {\\n        int l = nums.length, ans = Integer.MAX_VALUE;\\n        int[] sum = new int[nums.length];\\n        sum[0] = nums[0];\\n        for(int i = 1; i < l; i++){\\n            sum[i] = sum[i - 1] + nums[i]; \\n        }\\n        //is entire sum equals x, then one way is to use all elements\\n        int li = Arrays.binarySearch(sum, 0 , l , x);\\n        if(li >= 0) ans = Math.min(ans, li + 1);\\n        //from end to start, subtract sum from x and search for remaining in sum array\\n        for(int i = l - 1; i >= 0; i--){\\n            x -= nums[i];\\n            if(x == 0) {\\n                ans = Math.min(ans, l - i);\\n                break;\\n            }\\n            else if(x < 0) break;\\n            else{\\n                int index = Arrays.binarySearch(sum, 0, i, x);\\n                if(index < 0) continue;\\n                ans = Math.min(ans, l - i + index + 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int minOperations(int[] nums, int x) {\\n        int l = nums.length, ans = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int i : nums){\\n            sum += i;\\n        }\\n        int k = sum - x;\\n        sum = 0;\\n        int jsum = 0;\\n        for(int i = 0, j = -1; i < l; i++){\\n            sum += nums[i];\\n            while(j < i && sum - jsum > k){\\n                jsum += nums[++j];\\n            }\\n            if(sum - jsum == k) ans = Math.min(ans, l - i + j);\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n```\n```\\npublic int minOperations(int[] nums, int x) {\\n        int l = nums.length, ans = Integer.MAX_VALUE;\\n        int[] sum = new int[nums.length];\\n        sum[0] = nums[0];\\n        for(int i = 1; i < l; i++){\\n            sum[i] = sum[i - 1] + nums[i]; \\n        }\\n        //is entire sum equals x, then one way is to use all elements\\n        int li = Arrays.binarySearch(sum, 0 , l , x);\\n        if(li >= 0) ans = Math.min(ans, li + 1);\\n        //from end to start, subtract sum from x and search for remaining in sum array\\n        for(int i = l - 1; i >= 0; i--){\\n            x -= nums[i];\\n            if(x == 0) {\\n                ans = Math.min(ans, l - i);\\n                break;\\n            }\\n            else if(x < 0) break;\\n            else{\\n                int index = Arrays.binarySearch(sum, 0, i, x);\\n                if(index < 0) continue;\\n                ans = Math.min(ans, l - i + index + 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942517,
                "title": "simple-hashmap-solution-in-c-with-explanation",
                "content": "//here we can use the concept of maximum length subarray of sum equals to K \\n// EXPLANATION: if the sum of our array is lets say Z then if we find the the longest subarray of sum Z-X then we \\n// left with sum equals to X with minimum no of elements and that is the required answer :)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        if(nums.size()==0)\\n        {\\n            return 0;\\n        }\\n        unordered_map<int,int> ma;\\n        int sum1=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum1+=nums[i];\\n        }\\n        if(sum1==x)\\n        {\\n            return nums.size();\\n        }\\n        int dif=sum1-x;\\n        int sum=0,ans=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n            if(sum-dif==0)\\n            {\\n                int p=(nums.size()-(i+1));\\n                ans=min(ans,p);\\n                //ans=min(1,0);\\n            }\\n            else if(ma.find(sum-dif)!=ma.end())\\n            {\\n               int p=nums.size()-(i-(ma[sum-dif]));\\n               ans=min(ans,p);\\n            }\\n            else\\n            {\\n                ma.insert({sum,i});\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return ans;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        if(nums.size()==0)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 937104,
                "title": "java-explanation-and-similar-questions",
                "content": "**Intution**\\n1. This sum asks us to find a minimum length subarray (from left end and right end) which equals the traget sum X\\n2. A small tweak here is, instead we find the maximum length subarray in the given input array whose sum equals (total elements sum - X).\\n3. So the question boils down the the following sum: https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/\\n\\n\\n```\\npublic int minOperations(int[] nums, int x) {\\n        int totalSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            totalSum += nums[i];\\n        }\\n        if (totalSum == x) {\\n            return nums.length;\\n        }\\n\\t\\t\\n        int targetSum = totalSum - x;\\n        int length = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        \\n        map.put(0, -1);\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            // This check is not reqd as all the elts are positive, so sum wont repeat again.\\n            //map.putIfAbsent(sum, i);\\n            map.put(sum, i);\\n            if (map.containsKey(sum - targetSum)) {                \\n                length = Math.max(length, i - map.get(sum - targetSum));\\n            }            \\n        }        \\n        return length == 0 ? -1 : nums.length - length;        \\n    }\\n```\\n\\nT(n): O(n), S(n): O(n)\\n\\nSimilar problems which helps you understand the prefix sum concept in a better way:\\n\\n1. https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/ \\n1. https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/\\n1. https://leetcode.com/problems/maximum-sum-circular-subarray/\\n1.  https://leetcode.com/problems/minimum-size-subarray-sum/\\n1.  https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/\\n1.  https://leetcode.com/problems/subarray-sum-equals-k/description/",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums, int x) {\\n        int totalSum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            totalSum += nums[i];\\n        }\\n        if (totalSum == x) {\\n            return nums.length;\\n        }\\n\\t\\t\\n        int targetSum = totalSum - x;\\n        int length = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        \\n        map.put(0, -1);\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            // This check is not reqd as all the elts are positive, so sum wont repeat again.\\n            //map.putIfAbsent(sum, i);\\n            map.put(sum, i);\\n            if (map.containsKey(sum - targetSum)) {                \\n                length = Math.max(length, i - map.get(sum - targetSum));\\n            }            \\n        }        \\n        return length == 0 ? -1 : nums.length - length;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936448,
                "title": "c-o-n-cumulative-sum-idea",
                "content": "Suppose *sum* is the summation of all values of my array.\\nSo I have to find out a subarray whose summation is (*sum* - *x*).\\n\\nHere is the code \\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        \\n        int sum = 0;\\n        for(auto v : nums) {\\n            sum += v;\\n        }\\n        int rest = sum - x;\\n        int cs = 0;\\n        int ans = INT_MAX;\\n        int j = 0;\\n        for(int i = 0; i < n; i++) {\\n            if (j <= i) {\\n                j = i;\\n                cs = 0;\\n            }\\n            for(; j < n && cs < rest; j++) {\\n                cs = cs + nums[j];\\n            }\\n            if (cs == rest) {\\n                ans = min(ans, n - (j-i));\\n            }\\n            cs -= nums[i];\\n        }\\n        if (ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        \\n        int sum = 0;\\n        for(auto v : nums) {\\n            sum += v;\\n        }\\n        int rest = sum - x;\\n        int cs = 0;\\n        int ans = INT_MAX;\\n        int j = 0;\\n        for(int i = 0; i < n; i++) {\\n            if (j <= i) {\\n                j = i;\\n                cs = 0;\\n            }\\n            for(; j < n && cs < rest; j++) {\\n                cs = cs + nums[j];\\n            }\\n            if (cs == rest) {\\n                ans = min(ans, n - (j-i));\\n            }\\n            cs -= nums[i];\\n        }\\n        if (ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936428,
                "title": "java-two-pointers-solution-with-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int left = 0, right = nums.length - 1, sum = 0, answer = -1;\\n        \\n        while (left <= right && sum < x) {\\n            sum += nums[left++];\\n        }\\n        \\n        while (left >= 0) {\\n            if (sum == x) {\\n                int operations = left + nums.length - right - 1;\\n                \\n                if (answer == -1 || answer > operations) {\\n                    answer = operations;\\n                }\\n            }\\n            \\n            if (sum >= x) {\\n                if (left == 0) break;\\n                sum -= nums[--left];\\n            } else {\\n                if (left >= right) break;\\n                sum += nums[right--];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int left = 0, right = nums.length - 1, sum = 0, answer = -1;\\n        \\n        while (left <= right && sum < x) {\\n            sum += nums[left++];\\n        }\\n        \\n        while (left >= 0) {\\n            if (sum == x) {\\n                int operations = left + nums.length - right - 1;\\n                \\n                if (answer == -1 || answer > operations) {\\n                    answer = operations;\\n                }\\n            }\\n            \\n            if (sum >= x) {\\n                if (left == 0) break;\\n                sum -= nums[--left];\\n            } else {\\n                if (left >= right) break;\\n                sum += nums[right--];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936379,
                "title": "java-sliding-window",
                "content": "Lesson learned hard way after loosing multiple penalties trying to optmise my DP solution in conetxt: \\nThe moment you see find mininum /maximum , do not jump into DP solution\\nGive first pass to things like Greedy, Sliding window etc ...\\nAlso think whther a question can be transformed into some other variant of question \\n```\\nclass Solution {\\n     \\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for (int num : nums)\\n            sum+= num;\\n        if(sum == x)\\n            return nums.length;\\n        int targetsum = sum-x;\\n        int start = 0;\\n        int end= 0;\\n        int maxLen = -1;\\n        int windowSum =0;\\n        while (end < nums.length){\\n            if(nums[end] > targetsum){\\n                int ind = end+1;\\n                start = ind;\\n                end = ind;\\n                continue;\\n            }\\n            //move end by 1\\n            if(windowSum + nums[end] < targetsum){\\n                windowSum = windowSum+ nums[end];\\n                end++;\\n                continue;\\n            }\\n            if(windowSum + nums[end] == targetsum){\\n                windowSum = windowSum + nums[end];\\n                maxLen = Math.max(maxLen, end-start+1);\\n                windowSum = windowSum -nums[start];\\n                //move end and start by 1\\n                start++;\\n                end++;\\n                continue;\\n            }\\n            //advacne start untill windowsum is less than targetsum\\n            if(windowSum + nums[end] > targetsum){\\n                windowSum = windowSum + nums[end];\\n                while (windowSum > targetsum){\\n                    windowSum = windowSum- nums[start];\\n                    start++;\\n                }\\n                windowSum = windowSum-nums[end];\\n            }\\n        }\\n        if(maxLen == -1)\\n            return -1;\\n        return nums.length-maxLen;\\n    }\\n\\n   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     \\n    public int minOperations(int[] nums, int x) {\\n        int sum = 0;\\n        for (int num : nums)\\n            sum+= num;\\n        if(sum == x)\\n            return nums.length;\\n        int targetsum = sum-x;\\n        int start = 0;\\n        int end= 0;\\n        int maxLen = -1;\\n        int windowSum =0;\\n        while (end < nums.length){\\n            if(nums[end] > targetsum){\\n                int ind = end+1;\\n                start = ind;\\n                end = ind;\\n                continue;\\n            }\\n            //move end by 1\\n            if(windowSum + nums[end] < targetsum){\\n                windowSum = windowSum+ nums[end];\\n                end++;\\n                continue;\\n            }\\n            if(windowSum + nums[end] == targetsum){\\n                windowSum = windowSum + nums[end];\\n                maxLen = Math.max(maxLen, end-start+1);\\n                windowSum = windowSum -nums[start];\\n                //move end and start by 1\\n                start++;\\n                end++;\\n                continue;\\n            }\\n            //advacne start untill windowsum is less than targetsum\\n            if(windowSum + nums[end] > targetsum){\\n                windowSum = windowSum + nums[end];\\n                while (windowSum > targetsum){\\n                    windowSum = windowSum- nums[start];\\n                    start++;\\n                }\\n                windowSum = windowSum-nums[end];\\n            }\\n        }\\n        if(maxLen == -1)\\n            return -1;\\n        return nums.length-maxLen;\\n    }\\n\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936179,
                "title": "easy-to-understand-java-o-n",
                "content": "\\n    public int minOperations(int[] nums, int x) {\\n        Map<Integer, Integer> sumToNumberOfOperation = getMap(nums);\\n\\t\\t\\n        int min = Integer.MAX_VALUE;\\n        if (sumToNumberOfOperation.containsKey(x)) {\\n            min = sumToNumberOfOperation.get(x);\\n        }\\n\\t\\t\\n        int sum = 0;\\n        int counter = 0;\\t\\t\\n        for (int i = nums.length-1; i >=0; --i) {\\n            ++counter;\\n            sum += nums[i];\\n            if (sum == x && min > counter) {\\n                min = counter;\\n                continue;\\n            }\\n\\t\\t\\t\\n            Integer numberOfOperation = sumToNumberOfOperation.get(x - sum);\\n            if (numberOfOperation == null) {\\n                continue;\\n            }\\n\\t\\t\\t\\n            int totalOperations = counter + numberOfOperation;\\n            if (totalOperations <= nums.length && min > totalOperations) {\\n                min = totalOperations;\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n\\n    private Map<Integer, Integer> getMap(int[] nums) {\\n        Map<Integer, Integer> sumToNumberOfOperation= new HashMap<>();\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n\\t\\t\\tsumToNumberOfOperation.put(sum, i + 1);            \\n        }\\n        return sumToNumberOfOperation;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int minOperations(int[] nums, int x) {\\n        Map<Integer, Integer> sumToNumberOfOperation = getMap(nums);\\n\\t\\t\\n        int min = Integer.MAX_VALUE;\\n        if (sumToNumberOfOperation.containsKey(x)) {\\n            min = sumToNumberOfOperation.get(x);\\n        }\\n\\t\\t\\n        int sum = 0;\\n        int counter = 0;\\t\\t\\n        for (int i = nums.length-1; i >=0; --i) {\\n            ++counter;\\n            sum += nums[i];\\n            if (sum == x && min > counter) {\\n                min = counter;\\n                continue;\\n            }\\n\\t\\t\\t\\n            Integer numberOfOperation = sumToNumberOfOperation.get(x - sum);\\n            if (numberOfOperation == null) {\\n                continue;\\n            }\\n\\t\\t\\t\\n            int totalOperations = counter + numberOfOperation;\\n            if (totalOperations <= nums.length && min > totalOperations) {\\n                min = totalOperations;\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n\\n    private Map<Integer, Integer> getMap(int[] nums) {\\n        Map<Integer, Integer> sumToNumberOfOperation= new HashMap<>();\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n\\t\\t\\tsumToNumberOfOperation.put(sum, i + 1);            \\n        }\\n        return sumToNumberOfOperation;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 936012,
                "title": "short-python-sliding-window",
                "content": "We want the largest window so that the sum of the numbers left out is \\'x\\'\\n```\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        S = sum(nums)\\n        left = right = curr = 0\\n        ans = -1\\n        while right<len(nums):\\n            curr += nums[right]\\n            right+=1\\n            while left<len(nums) and curr>S-x:\\n                curr-=nums[left]\\n                left+=1\\n            if curr == S-x:\\n                ans = max(ans,right-left)\\n                \\n        return len(nums) - ans if ans!=-1 else ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        S = sum(nums)\\n        left = right = curr = 0\\n        ans = -1\\n        while right<len(nums):\\n            curr += nums[right]\\n            right+=1\\n            while left<len(nums) and curr>S-x:\\n                curr-=nums[left]\\n                left+=1\\n            if curr == S-x:\\n                ans = max(ans,right-left)\\n                \\n        return len(nums) - ans if ans!=-1 else ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4082330,
                "title": "beats-99-3-approaches-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet the minimum operations to reduce x to 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Memoization:** Take the element from first half or take from second half if target is met return minimum.\\n2. **Prefix-Suffix Sum:** For a valid `x`, there should exist a `suffixSum`(sum from right end) and a `prefixSum`(sum from left end) such that `prefixSum + suffixSum = x`.\\n3. **Two Pointer:** If we get the length of maximum subarray say maxLen,for which `sum = total sum of array - x` then `total length of array - maxLen` will give the desired output. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Approach 1(Gives MLE):**\\n```\\nclass Solution {\\npublic:\\n    int minOp(vector<int>& nums, int i, int j, int x, vector<vector<int>>& memo) {\\n        if (x == 0) return 0;\\n        if (x < 0 || i > j) return 1e9;\\n        \\n        if (memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n        \\n        int first = 1 + minOp(nums, i + 1, j, x - nums[i], memo);\\n        int last = 1 + minOp(nums, i, j - 1, x - nums[j], memo);\\n        \\n        memo[i][j] = min(first, last);\\n        return memo[i][j];\\n    }\\n    \\n    int minOperations(vector<int>& nums, int x) {\\n        int i = 0;\\n        int j = nums.size() - 1;\\n        \\n        vector<vector<int>> memo(nums.size(), vector<int>(nums.size(), -1));\\n        \\n        int ans = minOp(nums, i, j, x, memo);\\n        return ans >= 1e9 ? -1 : ans;\\n\\n\\n    }  \\n};\\n\\n```\\n\\n**Approach 2:**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        ios_base::sync_with_stdio(false);\\n        unordered_map<int, int> prefix;\\n        unordered_map<int, int> suffix;\\n\\n        prefix[0] = -1;\\n        suffix[0] = nums.size();\\n\\n        int preSum = 0;\\n        for(int i  = 0; i < nums.size(); i++)\\n        {\\n            preSum += nums[i];\\n            if(preSum > x) break;\\n            prefix[preSum] = i;\\n        }\\n\\n        int suffSum = 0;\\n        for(int i = nums.size()-1; i >= 0; i--)\\n        {\\n            suffSum += nums[i];\\n            if(suffSum > x) break;\\n            suffix[suffSum] = i;\\n        }\\n\\n        int ans = INT_MAX;\\n        for(auto pre : prefix)\\n        {\\n            auto suf = suffix.find(x-pre.first);\\n            if(suf != suffix.end() && suf->second > pre.second)\\n            {\\n                int leftOps = pre.second + 1;\\n                int rightOps = nums.size() - suf->second;\\n                ans = min(ans, leftOps + rightOps);\\n            }\\n        }\\n        return ans != INT_MAX ? ans : -1;\\n    }\\n};\\n```\\n\\n**Approach 3:**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        ios_base::sync_with_stdio(false);\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0);\\n        if(totalSum == x) return nums.size();\\n        if(totalSum < x) return -1;\\n\\n        int target = totalSum - x;\\n\\n        int l = 0, r = 0, sum = 0, ans = 0;\\n        while(r < nums.size())\\n        {\\n            sum += nums[r];\\n            while(l < r && sum > target)\\n            {\\n                sum -= nums[l];\\n                l++;\\n            }\\n            if(sum == target)\\n                ans = max(ans, r-l+1);\\n            r++;\\n        }\\n        return ans == 0 ? -1 : nums.size()-ans;\\n    }\\n};\\n```\\n\\n**Can you help me by commenting down the Time and Space complexities for each approach?**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Memoization",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOp(vector<int>& nums, int i, int j, int x, vector<vector<int>>& memo) {\\n        if (x == 0) return 0;\\n        if (x < 0 || i > j) return 1e9;\\n        \\n        if (memo[i][j] != -1) {\\n            return memo[i][j];\\n        }\\n        \\n        int first = 1 + minOp(nums, i + 1, j, x - nums[i], memo);\\n        int last = 1 + minOp(nums, i, j - 1, x - nums[j], memo);\\n        \\n        memo[i][j] = min(first, last);\\n        return memo[i][j];\\n    }\\n    \\n    int minOperations(vector<int>& nums, int x) {\\n        int i = 0;\\n        int j = nums.size() - 1;\\n        \\n        vector<vector<int>> memo(nums.size(), vector<int>(nums.size(), -1));\\n        \\n        int ans = minOp(nums, i, j, x, memo);\\n        return ans >= 1e9 ? -1 : ans;\\n\\n\\n    }  \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        ios_base::sync_with_stdio(false);\\n        unordered_map<int, int> prefix;\\n        unordered_map<int, int> suffix;\\n\\n        prefix[0] = -1;\\n        suffix[0] = nums.size();\\n\\n        int preSum = 0;\\n        for(int i  = 0; i < nums.size(); i++)\\n        {\\n            preSum += nums[i];\\n            if(preSum > x) break;\\n            prefix[preSum] = i;\\n        }\\n\\n        int suffSum = 0;\\n        for(int i = nums.size()-1; i >= 0; i--)\\n        {\\n            suffSum += nums[i];\\n            if(suffSum > x) break;\\n            suffix[suffSum] = i;\\n        }\\n\\n        int ans = INT_MAX;\\n        for(auto pre : prefix)\\n        {\\n            auto suf = suffix.find(x-pre.first);\\n            if(suf != suffix.end() && suf->second > pre.second)\\n            {\\n                int leftOps = pre.second + 1;\\n                int rightOps = nums.size() - suf->second;\\n                ans = min(ans, leftOps + rightOps);\\n            }\\n        }\\n        return ans != INT_MAX ? ans : -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums, int x) {\\n        ios_base::sync_with_stdio(false);\\n        int totalSum = accumulate(nums.begin(), nums.end(), 0);\\n        if(totalSum == x) return nums.size();\\n        if(totalSum < x) return -1;\\n\\n        int target = totalSum - x;\\n\\n        int l = 0, r = 0, sum = 0, ans = 0;\\n        while(r < nums.size())\\n        {\\n            sum += nums[r];\\n            while(l < r && sum > target)\\n            {\\n                sum -= nums[l];\\n                l++;\\n            }\\n            if(sum == target)\\n                ans = max(ans, r-l+1);\\n            r++;\\n        }\\n        return ans == 0 ? -1 : nums.size()-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069423,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int res = -1;\\n        int sum = 0;\\n        for(int n : nums){\\n            sum += n;\\n        }\\n        if(sum == x){\\n            return nums.length;\\n        }\\n        int s = 0;\\n        int sidx = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            s += nums[i];\\n            while(sidx < i && sum - s < x){\\n                s -= nums[sidx++];\\n            }\\n            if(sum - s == x){\\n                res = Math.max(res, i - sidx + 1);\\n            }\\n        }\\n        if(res == -1){\\n            return res;\\n        }\\n        return nums.length - res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int res = -1;\\n        int sum = 0;\\n        for(int n : nums){\\n            sum += n;\\n        }\\n        if(sum == x){\\n            return nums.length;\\n        }\\n        int s = 0;\\n        int sidx = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            s += nums[i];\\n            while(sidx < i && sum - s < x){\\n                s -= nums[sidx++];\\n            }\\n            if(sum - s == x){\\n                res = Math.max(res, i - sidx + 1);\\n            }\\n        }\\n        if(res == -1){\\n            return res;\\n        }\\n        return nums.length - res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069141,
                "title": "java-using-a-sliding-window-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n         int n = nums.length;\\n        int targetSum = 0;\\n        \\n        for (int num : nums) {\\n            targetSum += num;\\n        }\\n        \\n        int windowSum = targetSum - x;\\n        \\n        if (windowSum < 0) {\\n            return -1; // It\\'s not possible to reach x.\\n        }\\n        \\n        int minLength = Integer.MAX_VALUE;\\n        int left = 0;\\n        int currentSum = 0;\\n        \\n        for (int right = 0; right < n; right++) {\\n            currentSum += nums[right];\\n            \\n            while (currentSum > windowSum) {\\n                currentSum -= nums[left];\\n                left++;\\n            }\\n            \\n            if (currentSum == windowSum) {\\n                minLength = Math.min(minLength, n - (right - left + 1));\\n            }\\n        }\\n        \\n        return minLength == Integer.MAX_VALUE ? -1 : minLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n         int n = nums.length;\\n        int targetSum = 0;\\n        \\n        for (int num : nums) {\\n            targetSum += num;\\n        }\\n        \\n        int windowSum = targetSum - x;\\n        \\n        if (windowSum < 0) {\\n            return -1; // It\\'s not possible to reach x.\\n        }\\n        \\n        int minLength = Integer.MAX_VALUE;\\n        int left = 0;\\n        int currentSum = 0;\\n        \\n        for (int right = 0; right < n; right++) {\\n            currentSum += nums[right];\\n            \\n            while (currentSum > windowSum) {\\n                currentSum -= nums[left];\\n                left++;\\n            }\\n            \\n            if (currentSum == windowSum) {\\n                minLength = Math.min(minLength, n - (right - left + 1));\\n            }\\n        }\\n        \\n        return minLength == Integer.MAX_VALUE ? -1 : minLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069098,
                "title": "easy-python-two-pointers-minimum-operations-to-reduce-x-to-zero",
                "content": "[see the successfully Accepted Submition](https://leetcode.com/submissions/detail/1054631962/)\\n\\n```\\nclass Solution(object):\\n    def minOperations(self, nums, x):\\n        \\n        total_sum = sum(nums)\\n        max_length = -1\\n        curr_sum = 0\\n        count_left = 0\\n\\n        for right_pointer in range(len(nums)):\\n            curr_sum += nums[right_pointer]\\n            while count_left <= right_pointer and curr_sum > total_sum - x:\\n                curr_sum -= nums[count_left]\\n                count_left += 1\\n            if curr_sum == total_sum - x:\\n                max_length = max(max_length, right_pointer - count_left + 1)\\n\\n        return -1 if max_length == -1 else len(nums) - max_length\\n```\\n\\n**Intuition** | **Two Pointers**\\n\\n1) First, we calculate the total sum of all elements in the nums list using the `sum()` function and then store it in the total_sum variable.\\n\\t\\n```\\n        total_sum = sum(nums)\\n```\\nAfter that, we nitialize the `max_length` variable to `-1`. This variable will be used to keep track of the maximum length of subarray with the desired sum.\\n```\\n        max_length = -1\\n```\\nWe initialize the `curr_sum` variable to `0`. This variable will be used to keep track of the current sum of elements in the subarray.\\n```\\n        curr_sum = 0\\n```\\nAt the same time, we initialize the `count_left` variable to `0` which represents the left pointer of the subarray.\\n```\\n        count_left = 0\\n```\\nThis for loop iterates over the indices of the nums list from `0` to `len(nums) - 1`, representing the right pointer of the subarray.\\n```\\n        for right_pointer in range(len(nums)):\\n```\\n6) Then, we add the `current element` at index r to the curr_sum, effectively expanding the subarray to the right.\\n```\\n            curr_sum += nums[right_pointer]\\n```\\n\\n7) In the next step, we appy `while` loop whcih continue  as long as the left pointer `count_left` is less than or equal to the right pointer `right_pointer`, and the current sum `curr_sum` is greater than the target value total_sum -` x`.\\n\\t\\n```\\n            while count_left <= right_pointer and curr_sum > total_sum - x:\\n```\\n\\t\\t\\t\\n 8) In the loop, we subtract the element at the left pointer `count_left` from the curr_sum and moves the left pointer one step to the right by incrementing `count_left`.\\n```\\n                curr_sum -= nums[count_left]\\n```\\n\\n 9) At the same time, in the loop, we increment `count_left` inside the while loop effectively shrinks the subarray from the left until the condition `curr_sum <= total_sum - x` is met.\\n\\t\\n```\\n                count_left += 1\\n```\\n10) After the while loop exits, we check if the current sum `curr_sum` is equal to the target value `total_sum - x`. \\n\\t\\n```\\n            if curr_sum == total_sum - x:\\n```\\n11) If the condition in the previous line is true, we calculate the length of the subarray from the left pointer `count_left` to the right pointer `right_pointer` and updates maxLength with the maximum length encountered so far.\\n\\t\\n```\\n                max_length = max(max_length, right_pointer - count_left + 1)\\n```\\n12) Finally, we return` -1 if maxLength remains -1`, indicating that no subarray with the desired sum was found. Otherwise, we returns `len(nums) - maxLength`, which represents the minimum number of operations needed to obtain the desired sum `x` by removing elements from the original array.\\n\\t\\n```\\n        return -1 if max_length == -1 else len(nums) - max_length\\n```  \\n\\n\\n![image](https://assets.leetcode.com/users/images/80e344af-e15d-4439-bda8-8370e1e15dbe_1695224076.9711716.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, nums, x):\\n        \\n        total_sum = sum(nums)\\n        max_length = -1\\n        curr_sum = 0\\n        count_left = 0\\n\\n        for right_pointer in range(len(nums)):\\n            curr_sum += nums[right_pointer]\\n            while count_left <= right_pointer and curr_sum > total_sum - x:\\n                curr_sum -= nums[count_left]\\n                count_left += 1\\n            if curr_sum == total_sum - x:\\n                max_length = max(max_length, right_pointer - count_left + 1)\\n\\n        return -1 if max_length == -1 else len(nums) - max_length\\n```\n```\\n        total_sum = sum(nums)\\n```\n```\\n        max_length = -1\\n```\n```\\n        curr_sum = 0\\n```\n```\\n        count_left = 0\\n```\n```\\n        for right_pointer in range(len(nums)):\\n```\n```\\n            curr_sum += nums[right_pointer]\\n```\n```\\n            while count_left <= right_pointer and curr_sum > total_sum - x:\\n```\n```\\n                curr_sum -= nums[count_left]\\n```\n```\\n                count_left += 1\\n```\n```\\n            if curr_sum == total_sum - x:\\n```\n```\\n                max_length = max(max_length, right_pointer - count_left + 1)\\n```\n```\\n        return -1 if max_length == -1 else len(nums) - max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068958,
                "title": "most-easiest-solution-in-java-minimum-operations-to-reduce-x-to-zero",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(x)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int n = nums.length;\\n        int sum = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum = sum + nums[i];\\n            map.put(sum,i);\\n        }\\n\\n        if(sum < x)\\n        {\\n            return -1;\\n        }\\n\\n        int target = sum - x;\\n        int longest = Integer.MIN_VALUE;\\n        sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum = sum + nums[i];\\n            if(map.containsKey(sum - target))\\n            {\\n                longest = Math.max(longest , i - map.get(sum - target));\\n            }\\n        }\\n\\n        return longest == Integer.MIN_VALUE ? -1 : n - longest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums, int x) {\\n        int n = nums.length;\\n        int sum = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum = sum + nums[i];\\n            map.put(sum,i);\\n        }\\n\\n        if(sum < x)\\n        {\\n            return -1;\\n        }\\n\\n        int target = sum - x;\\n        int longest = Integer.MIN_VALUE;\\n        sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum = sum + nums[i];\\n            if(map.containsKey(sum - target))\\n            {\\n                longest = Math.max(longest , i - map.get(sum - target));\\n            }\\n        }\\n\\n        return longest == Integer.MIN_VALUE ? -1 : n - longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2065105,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065211,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1826838,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1958077,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065174,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1785904,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1566452,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065108,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1803836,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065419,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065105,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065211,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1826838,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1958077,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065174,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1785904,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1566452,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065108,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 1803836,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065419,
                "content": [
                    {
                        "username": "bhati25",
                        "content": "<strong>I solve most of the problems using brute force and I fear that what if my interviewer ask for an optimized version</strong>\\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*-EcY1mOZ_fDmCFizJvsMkg.jpeg\" width=\"200\" height=\"300\" />"
                    },
                    {
                        "username": "bhati25",
                        "content": "[@shakthisri](/shakthisri) its a meme to lighten your mood!! Happy Leetcoding ✌️"
                    },
                    {
                        "username": "shakthisri",
                        "content": "ur profile doesnt look so though"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThis although seems like a basic `dp` problem, can\\'t be solve by it due to the `constraints`.\\n\\nThe trick here is to think in `reverse`. We need a subarray of maximum length whose sum is `TotalSum - x`. As we remove `minimum` no of elements from left and right to get a sum of `x`, we will be left with a subarray of `maximum length` having sum of `TotalSum-x`.\\n\\nSo, now it\\'s a `sliding window` problem, Cheers!"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "[@Anon_Nobody](/Anon_Nobody) dynamic window size. Size of window depends on the sum of elements in the window.  "
                    },
                    {
                        "username": "Anon_Nobody",
                        "content": "But how are we going to select the window size?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "thnks man for the new intution"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "[@Jonathan_patta](/Jonathan_patta) Oh I see. I understand now, thanks a lot! "
                    },
                    {
                        "username": "Jonathan_patta",
                        "content": "[@Ishika_07](/Ishika_07) I am no expert but with dp I am getting n^2 complexity, and for the worst case it would go to 10^5 * 10^5 = 10^10 operations  which would be too high(should be in the range of 10^5-10^7, to not get tle), so the time complexity for the solution has to be better than that.  "
                    },
                    {
                        "username": "harshabeta14",
                        "content": "wow never thought of that !!!!!!!!!!"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@Shubham Raj](/Shubham_Raj22/) +1"
                    },
                    {
                        "username": "Ishika_07",
                        "content": "Hi! I would really appreciate if you could explain how to know from constraints if dp can be used or not? "
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "dfs with memo doesnt work in this"
                    },
                    {
                        "username": "Destravna",
                        "content": "I solved it with dp(got TLE) but I don\\'t think I could have ever come up with subarray solution even if try my entire life."
                    },
                    {
                        "username": "0x415374",
                        "content": "Yeeah, got me aswell..."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "just do more and u find most of these question requires hashMap + prefix sum"
                    },
                    {
                        "username": "mstuebs",
                        "content": "Don't submit without testing the edge cases. Try these testcases:\n```\n[3914]\n3913\n[2431]\n2432\n[8576]\n8576\n[10,1,10,10,10]\n40\n```\nhttps://github.com/mquintus/l33tcode-testcase-generator/blob/main/README.md"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "thanks man, you saved me from submitting approx 4 wrong answers"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "This the best problem I\\'ve ever seen in my entire life!"
                    },
                    {
                        "username": "siamsplash5",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thank you. I had solved this problem with a bit complex but nice observation earlier which made me comment on such a thing (though I had 2400+ solves on other online judges on that time). Today I\\'ve solved with more easier and normal approach and feeling dumb to see that old comment :3"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Till Feb 03, 2023, you solved around 40-50 questions max on LC, so makes sense. You have a long journey ahead bro, best of luck!"
                    },
                    {
                        "username": "user5400vw",
                        "content": "can\\'t tell if serious..."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers (Indirectly)\n\n  \n**Approach 2:** Two Pointers (Directly)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "what about the constraint for 1 <= nums[i] <= 10^4 is changed to allow nums[i] being negative?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "I think dp should only be the option then."
                    },
                    {
                        "username": "hero080",
                        "content": "Then we have to use hash map solution (keep the smallest index for each prefix so far).\\n\\nAnyway for this problem we have a solution more efficient than normal sliding window:\\nhttps://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4066492/sublinear-o-min-l-n-o-1-most-efficient-solution-ultimate-optimization/"
                    },
                    {
                        "username": "om_golhani",
                        "content": "A very good problem!\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Think in reverse; instead of finding the minimum prefix + suffix, find the maximum subarray.\\n\\nFinding the maximum subarray is standard and can be done greedily.\\n\\nif helpful upvote\\n"
                    }
                ]
            },
            {
                "id": 2065447,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 2065726,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 2065340,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 2065144,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 1574611,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 1675077,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 2065297,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 2065251,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 1989241,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 2068934,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint:\\nmaximum length  of subarray whose sum is sum(nums)-x"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@ASMIT-SRIVASTAVA](/ASMIT-SRIVASTAVA) it is related to subarray so no sort\\n"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "passed 43/94 cases\\n\\n\\nint len=-1;\\n        Arrays.sort(nums);\\n        //find len of subarr having sum =x as sum-x==0\\n        int currsum=0;\\n        int i=nums.length-1;\\n        int j=nums.length-1;\\n        int count=0;\\n        while(j>=0)\\n        {\\n            currsum +=nums[j];\\n            count++;\\n            if(currsum>x)\\n            {\\n                 currsum -=nums[j];\\n                 count--;\\n            }\\n            if(currsum==x) return count;\\n\\n            j--;\\n\\n        }\\n        return -1;\\n"
                    },
                    {
                        "username": "JOSCHLINER",
                        "content": "Remember testcase 93: \\n[1,1], 3"
                    },
                    {
                        "username": "xcyuan",
                        "content": "[@kashwini337](/kashwini337) Therefore return -1 in this case."
                    },
                    {
                        "username": "kashwini337",
                        "content": "how is it possible to get 3 from [1,1]??"
                    },
                    {
                        "username": "psionl0",
                        "content": "Straight out recursion won\\'t work because of TLE. Recursion + memoization won\\'t work because a 10^5 by 10^5 dp matrix takes up too much memory."
                    },
                    {
                        "username": "aitachii",
                        "content": "`Time Limit Exceeded`\\n`Memory Limit Exceeded`\\nThis is gonna take a while..."
                    },
                    {
                        "username": "user5801QN",
                        "content": "![image](https://assets.leetcode.com/users/images/0f0f7a70-d614-4978-a479-1c1786f2b4f4_1605983811.4684162.png)\\n\\nThe input X is larger than the sum of all the elements so how can we have X coming to 0?. Shoulnd\\'t the output be -1 only?"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "[@n124345679976](/n124345679976) Nice observation!"
                    },
                    {
                        "username": "n124345679976",
                        "content": "You sum up the array in the wrong way. You use `k` to iterate from 0 to n-1 but sum up with index `i`. (Line 12: sum = sum + nums[i])\\nCan you sum up it with index `k` again?"
                    },
                    {
                        "username": "Gautam_G",
                        "content": "their might be some glitch because in mine solution I too have returned -1 when sum of all numbers is greater than X and it passed all tests"
                    },
                    {
                        "username": "dogemaster05",
                        "content": " `Hello world!`\\nO(1)"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "What kinda black magic is this"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how?"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Tried solving using DP, got TLE.\\n\\nThen looked at the Hint. Nice problem!"
                    },
                    {
                        "username": "abhijeetrane121",
                        "content": "Can we solve it using two pointer approach??\\n"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "If you consider the sliding window as a 2-pointer approach, then yes :)"
                    },
                    {
                        "username": "ASMIT-SRIVASTAVA",
                        "content": "[@benayac](/benayac) i have applied 2 pointer approach and passed 15/94 cases\\n\\n\\nint left=0;\\n        int right=nums.length-1;\\n        int count=0;\\n        while(left<right)\\n        {\\n            if(nums[left]<=nums[right])\\n            {\\n                if(nums[right]<=x)\\n                {\\n                    x=x-nums[right];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                right--;\\n            }\\n            if(nums[left]>nums[right])\\n            {\\n                if(nums[left]<=x)\\n                {\\n                    x=x-nums[left];\\n                    count++;\\n                    if(x==0) return count;\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        if(count==0) return -1;\\n        return count;"
                    },
                    {
                        "username": "benayac",
                        "content": "guessed this also, but since the array is unordered so imo two pointer approach doesn\\'t really work well here"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "Nice sum. The main challenge is to convert it from a DP perspective a sliding window perspective. However, DP not working here should be quite intuitive given the constraints. "
                    },
                    {
                        "username": "Ashish1205",
                        "content": "[@VasudevaK](/VasudevaK) here dp will give O(n2) for that only till 10^3 constraints will work but here it is given 10^5"
                    },
                    {
                        "username": "VasudevaK",
                        "content": "What are general constraints for dp problem?"
                    },
                    {
                        "username": "minh-tn-hust",
                        "content": "Using prefix and suffix sum to solve this problem is a quite good idea!"
                    }
                ]
            },
            {
                "id": 2067297,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2067291,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066403,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066377,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066366,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066257,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066180,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066101,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066098,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066094,
                "content": [
                    {
                        "username": "layyy",
                        "content": "edge test cases are the real deal"
                    },
                    {
                        "username": "user8619cx",
                        "content": "5 edge cases, 4 wrong submissions. Remember to test it guys, dont be like me"
                    },
                    {
                        "username": "Kathy99",
                        "content": "I solved the problem using DP only to realize DP solution will time out"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "i wrote gibberish, and got 30/96 passes, i\\'ll consider that as accepted"
                    },
                    {
                        "username": "vvviktor",
                        "content": "Had a terrible time sliding this window..."
                    },
                    {
                        "username": "borjaf696",
                        "content": "I did not like this one... the solution for a medium problem should be dp + memo but in this case you get TLE... the actual solution it is tricky and probably more a happy day than actual knowledge"
                    },
                    {
                        "username": "Limon020",
                        "content": "Problem is actually very similar to 2sum the way I did it, really good question"
                    },
                    {
                        "username": "huntxr",
                        "content": "Hint: Try using all the subarrays with sum = sum(nums) - x and whichever returns the most numbers."
                    },
                    {
                        "username": "chiragmittal19",
                        "content": "Great problem!\nIf sum of numbers on edges is x, then sum of numbers between edges must be total sum - x. To minimize the edges, center needs to be maximised.\nSo essentially, this is a max subarray with sum k problem.\nBut that's not it! This problem still has one last trick(edge case) up its sleeve ;)"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Took me several hours to understand, very sad."
                    }
                ]
            },
            {
                "id": 2066067,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065974,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065877,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065736,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065719,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065707,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065642,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065638,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065539,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065512,
                "content": [
                    {
                        "username": "cymus",
                        "content": "My code works in onlinegdb compiler, but not in leetcode. I see that the issue is with negative integers? It's not the first time leetcode has trouble. I have \n`int right = -1;\nwhile (right < nums.size() - 1)\n{ ... }`\nAnd the loop isn't entered even once.\n\nNow I've changed it, so it doesn't use negative integers and it still works perfectly outside of leetcode and here I get Char 34: runtime error."
                    },
                    {
                        "username": "A7harva",
                        "content": "DP bait \\uD83D\\uDE02"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "```\nTLE\nnums = [1241,8769,9151,3211,2314,8007,3713,5835,2176,8227,5251,9229,904,1899,5513,7878,8663,3804,2685,3501,1204,9742,2578,8849,1120,4687,5902,9929,6769,8171,5150,1343,9619,3973,3273,6427,47,8701,2741,7402,1412,2223,8152,805,6726,9128,2794,7137,6725,4279,7200,5582,9583,7443,6573,7221,1423,4859,2608,3772,7437,2581,975,3893,9172,3,3113,2978,9300,6029,4958,229,4630,653,1421,5512,5392,7287,8643,4495,2640,8047,7268,3878,6010,8070,7560,8931,76,6502,5952,4871,5986,4935,3015,8263,7497,8153,384,1136]\nx = 894887480\n\nnums = [5207,5594,477,6938,8010,7606,2356,6349,3970,751,5997,6114,9903,3859,6900,7722,2378,1996,8902,228,4461,90,7321,7893,4879,9987,1146,8177,1073,7254,5088,402,4266,6443,3084,1403,5357,2565,3470,3639,9468,8932,3119,5839,8008,2712,2735,825,4236,3703,2711,530,9630,1521,2174,5027,4833,3483,445,8300,3194,8784,279,3097,1491,9864,4992,6164,2043,5364,9192,9649,9944,7230,7224,585,3722,5628,4833,8379,3967,5649,2554,5828,4331,3547,7847,5433,3394,4968,9983,3540,9224,6216,9665,8070,31,3555,4198,2626,9553,9724,4503,1951,9980,3975,6025,8928,2952,911,3674,6620,3745,6548,4985,5206,5777,1908,6029,2322,2626,2188,5639]\nx = 565610\n\nimp Test case [1,1] x = 3\n```"
                    },
                    {
                        "username": "SG-C",
                        "content": "this is not a medium problem this is good problem"
                    },
                    {
                        "username": "ankit1478",
                        "content": "Use sidling Window  \nuse this approach sum of all arr[i] - target;\ninstead of direct finding target\n\n\nfor code https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4068137/using-sliding-window-approaches-o-1-sc/"
                    },
                    {
                        "username": "ankit_sharmao_o",
                        "content": "Use this test case if you are using sliding window, because it is only case where my code stuck.\\n[8828,9581,49,9818,9974,9869,9991,10000,10000,10000,9999,9993,9904,8819,1231,6309]\\nx=134365"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Good one"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "The difficulty is totally inaccurate."
                    },
                    {
                        "username": "Harshil-Gupta",
                        "content": "Input:\nnums = [1,1]\nx = 3\n\nWhy is the expected outcome 3?\nShouldn't the answer be -1?\nKindly help me out if I understood the question correctly or not?\n\nMy thoughts while reaching the answer: \nStarting from left (index 0)\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>3-1=>2\n\nnums = [1] after removing element 1\nnum[0] = 1;\n1 is subtracted from x, therefore, x=>x-1=>2-1=>1\n\nNow after removing 1 element\nnums = []\n\nBut my x is still 1, so answer returned should be -1,\nbut it is showing correct answer as 3.\n\n\n"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "I liked the problem very much and its very interesting to do with optimized solution "
                    }
                ]
            },
            {
                "id": 2065424,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 2065411,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 2065383,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 2065353,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 2065332,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 2065323,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 2065265,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 2065252,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 1929358,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            },
            {
                "id": 1828742,
                "content": [
                    {
                        "username": "nikhilverma_",
                        "content": "edge case wasted 40 mins of my life :("
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "I used hash table, prefix sum , suffix sum and [explained with visualization here](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067121/easiest-solution-with-explanation-and-annotations/)"
                    },
                    {
                        "username": "mg2002",
                        "content": "How do this question if question\\'s constraint were different like when negative numbers are also present???"
                    },
                    {
                        "username": "mg2002",
                        "content": "One approach that comes to my mind is to use hash map which stores the suffix of nums array and minimum number of elements from back required to achieve that sum. Then we can iterate from 0 to n, and correspondingly calculate the prefix sum, and find whether there exit a key in the hash map which is equal to (x-pre[i])...if it exits then take ans=min(ans, i+dp[x-pre[i]])....is this approach correct??"
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "Approach:-\\nSo we find the maximum subarray with sum= (total_sum-x).This is because on observing we see that after removing the correct suffix and prefix, we are left with the subarray with sum=total_sum-x."
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "Hint: Use two pointers approach"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "Simple logic use prefix sum from one side (either from left or right)"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "What will be the time complexity of the approach with i and j variables in a recursive function where we add i+1 th element and j-1 th element and then check for the answer, and would this approach work ? Where i and j start from 0 and n"
                    },
                    {
                        "username": "KedarKK1",
                        "content": "🛑🔴 DP - Help Needed\n\n**Create 2-d list of lists (vector of vector). \n1st row contains nums elements in reverse order. \n1st column contains nums elements in forward order.\ndp[i][j] shows sum of elements from ith from starting and jth from end.**\n\n```python []\nclass Solution:\n    def minOperations(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[0 for i in range(n+1)] for j in range(n+1)]\n        for i in range(1,n+1): # for initializing dp[i][0] in forward order and dp[0][i] in reverse manner\n            dp[i][0] = nums[i-1]\n            dp[0][i] = nums[-(i)]\n\n        ans = 10 ** 5\n        print(dp)\n        # for adding previous elements to curr, \n        # to calculate if deleting top i rows or last j rows, \n        # gives what sum\n        for i in range(1, n+1): \n            dp[i][0] += dp[i-1][0]\n            dp[0][i] += dp[0][i-1]\n        print(dp)\n        # i, j for calculating sum when first i and last j rows are deleted\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                # if(i-1 >= 0):\n                #     dp[i][j] += dp[i-1][j]\n                # if(j-1 >= 0):\n                #     dp[i][j] += dp[i][j-1]\n                # if(dp[i][j] == x):\n                #     ans = min(ans, ((i) + (n - j)))\n                #     print(\"i j\", (i), (n - j))\n                dp[i][j] += (dp[i-1][j] + dp[i][j-1])\n        for i in range(n+1):\n            for j in range(n+1):\n                # for calculating ans, if we deleted first i elements\n                if(i == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, j)\n                # for calculating ans, if we deleted first j elements\n                if(j == 0 and dp[i][j] == x):\n                    print(\"i j\", (i), (j))\n                    ans = min(ans, i)\n                # for calculating ans, if we deleted first i & last j elements\n                if(j != 0 and i != 0 and dp[i][j] == x):\n                    ans = min(ans, i + n - j)\n                    print(\"i n-j\", (i), (n - j))\n        print(dp)\n        print(ans)\n        return -1 if ans == 10 ** 5 else ans\n```\n\n\n# Approach\nuse dp[i][j] = dp[i-1][j] + dp[i][j-1], match with x return minimum of ((i+1) + (n - (j + 1)))\n\nPlease help me rectify the mistake. "
                    },
                    {
                        "username": "hridoyalhasan059",
                        "content": "nums=[6016,5483,541,4325,8149,3515,7865,2209,9623,9763,4052,6540,2123,2074,765,7520,4941,5290,5868,6150,6006,6077,2856,7826,9119]\\nx=31841\\n\\nhow the answer is 6? I didn\\'t find any combination that are match 6. can you guys help?"
                    },
                    {
                        "username": "ganesh_8897903",
                        "content": "i am also getting same\\n"
                    },
                    {
                        "username": "Abu_Kalam",
                        "content": "22722, 7826, 6016, 5483, 2856, 541 == 0"
                    },
                    {
                        "username": "longpaladin",
                        "content": "there is a particular testcase where my solution works but it doesn\\'t allow me to pass because my output is not the same as the testcase"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimize the Difference Between Target and Chosen Elements",
        "question_content": "<p>You are given an <code>m x n</code> integer matrix <code>mat</code> and an integer <code>target</code>.</p>\n\n<p>Choose one integer from <strong>each row</strong> in the matrix such that the <strong>absolute difference</strong> between <code>target</code> and the <strong>sum</strong> of the chosen elements is <strong>minimized</strong>.</p>\n\n<p>Return <em>the <strong>minimum absolute difference</strong></em>.</p>\n\n<p>The <strong>absolute difference</strong> between two numbers <code>a</code> and <code>b</code> is the absolute value of <code>a - b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1.png\" style=\"width: 181px; height: 181px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> One possible choice is to:\n- Choose 1 from the first row.\n- Choose 5 from the second row.\n- Choose 7 from the third row.\nThe sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1-1.png\" style=\"width: 61px; height: 181px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1],[2],[3]], target = 100\n<strong>Output:</strong> 94\n<strong>Explanation:</strong> The best possible choice is to:\n- Choose 1 from the first row.\n- Choose 2 from the second row.\n- Choose 3 from the third row.\nThe sum of the chosen elements is 6, and the absolute difference is 94.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/03/matrix1-3.png\" style=\"width: 301px; height: 61px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1,2,9,8,7]], target = 6\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The best choice is to choose 7 from the first row.\nThe absolute difference is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 70</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 70</code></li>\n\t<li><code>1 &lt;= target &lt;= 800</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1418602,
                "title": "python-4-lines-solution-explained",
                "content": "The idea is that our numbers are very small: `mat[i][j] <= 70`, and also `m, n <= 70`. It means, tha final sum of all numbers can be no more than `70**2`.\\n\\nSo, we can do almost bruteforce solution: iterate over rows and keep in `nums` all possible sums we get so far.\\n\\n#### Complexity\\nEach time we have in `nums` no more than `70**2` elements and we travere it not more than `70` rows, each of which have no more than `70` elements so final complexity is `O(n^4)`, where `n = 70`. Then we need to find closes element to target which is just `O(n^3)`. Space complexity is `O(n^3)`. It was **AC** during contest for me, however now it gives TLE.\\n\\n```python\\nclass Solution:\\n    def minimizeTheDifference(self, mat, target):\\n        nums = {0}\\n        for row in mat:\\n            nums = {x + i for x in row for i in nums}\\n        \\n        return min(abs(target - x) for x in nums)\\n```\\n\\n#### Solution 2\\nWe can optimize solutoin, taking into account that we need to look around `target`. That is if minimal sum of all numbers is more than target, we do no have choice: we need to take it. In the opposite case no need to go higher than `2*target - possible_min`\\n\\n#### Complexity\\nTime complexity is `O(target * n^2)` now, space is `O(target)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimizeTheDifference(self, mat, target):\\n        possible_min = sum(min(row) for row in mat)\\n        if possible_min > target: return possible_min - target\\n        \\n        nums = {0}\\n        for row in mat:\\n            nums = {x + i for x in row for i in nums if x + i <= 2*target - possible_min}\\n        \\n        return min(abs(target - x) for x in nums)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimizeTheDifference(self, mat, target):\\n        nums = {0}\\n        for row in mat:\\n            nums = {x + i for x in row for i in nums}\\n        \\n        return min(abs(target - x) for x in nums)\\n```\n```python\\nclass Solution:\\n    def minimizeTheDifference(self, mat, target):\\n        possible_min = sum(min(row) for row in mat)\\n        if possible_min > target: return possible_min - target\\n        \\n        nums = {0}\\n        for row in mat:\\n            nums = {x + i for x in row for i in nums if x + i <= 2*target - possible_min}\\n        \\n        return min(abs(target - x) for x in nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418757,
                "title": "dp-pruning-4sum-ii-and-all-sums",
                "content": "#### Approach 1: DP + Pruning\\n\\nThe sum of the entire matrix cannot be larger than 70 * 70. We can use this fact for memoisation.\\n\\nNow, to achieve good runtime (the code below is ~80 ms), we need to sort each row and remove duplicates. \\n- This way, we can stop after the running sum exceeds the target.\\n\\n> Update. Test cases are week, and thanks [sandyleo26](https://leetcode.com/sandyleo26/), [louisfghbvc](https://leetcode.com/louisfghbvc/) and [nate17](https://leetcode.com/nate17/) for examples. The original pruning was too complicated and did not pass stronger test cases.\\n\\n**C++**\\n```cpp\\nint dp[71][70 * 70 + 1] = {[0 ... 70][0 ... 70 * 70] = INT_MAX};\\nint dfs(vector<set<int>>& m, int i, int sum, int target) {\\n    if (i >= m.size())\\n        return abs(sum - target);\\n    if (dp[i][sum] == INT_MAX)\\n        for (auto it = begin(m[i]); it != end(m[i]); ++it) {\\n            dp[i][sum] = min(dp[i][sum], dfs(m, i + 1, sum + *it, target));\\n            if (dp[i][sum] == 0 || sum + *it > target)\\n                break;\\n        }\\n    return dp[i][sum];\\n}\\nint minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n    vector<set<int>> m;\\n    for (auto &row : mat)\\n        m.push_back(set<int>(begin(row), end(row)));\\n    return dfs(m, 0, 0, target);\\n}\\n```\\n\\n#### Approach 2: 4Sum II\\nThis problem is similar to [4Sum II](https://leetcode.com/problems/4sum-ii/), with the difference that we need to return the closest sum, not necessarily the exact one.\\n\\nFor that approach, we collect sums for upper and lower parts of the matrix independently. Then, we go through the first set of sums, and binary search for a compliment in the second set of sums. See an example code [here](https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/discuss/1418651/c++-bitset.-meh.../1057516).\\n\\n#### Approach 3: All Sums\\nAgain, since the max sum is limited to 70 * 70, we could compute all possible sums and then search for the closest one.\\n\\nUsing a hash set in C++, however, is too slow (TLE). So I am using a bit array, and tracking max element so far to not to scan all 70 * 70 elements every time.\\n\\n**C++**\\n```cpp\\nint minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n    bool bt[70 * 70 + 1] = {};\\n    int max_e = 0, res = INT_MAX;\\n    for (auto & row : mat) {\\n        bool bt1[70 * 70 + 1] = {};\\n        int max_e1 = 0;\\n        for (auto i : unordered_set(begin(row), end(row))) {\\n            for (int j = 0; j <= max_e; ++j)\\n                if (j == max_e || bt[j]) {\\n                    bt1[i + j] = true;\\n                    max_e1 = max(max_e1, i + j);\\n                }\\n        }\\n        swap(bt, bt1);\\n        max_e = max_e1;\\n    }\\n    for (int i = 0; i <= 70 * 70; ++i) {\\n        if (bt[i])\\n            res = min(res, abs(i - target));\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[71][70 * 70 + 1] = {[0 ... 70][0 ... 70 * 70] = INT_MAX};\\nint dfs(vector<set<int>>& m, int i, int sum, int target) {\\n    if (i >= m.size())\\n        return abs(sum - target);\\n    if (dp[i][sum] == INT_MAX)\\n        for (auto it = begin(m[i]); it != end(m[i]); ++it) {\\n            dp[i][sum] = min(dp[i][sum], dfs(m, i + 1, sum + *it, target));\\n            if (dp[i][sum] == 0 || sum + *it > target)\\n                break;\\n        }\\n    return dp[i][sum];\\n}\\nint minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n    vector<set<int>> m;\\n    for (auto &row : mat)\\n        m.push_back(set<int>(begin(row), end(row)));\\n    return dfs(m, 0, 0, target);\\n}\\n```\n```cpp\\nint minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n    bool bt[70 * 70 + 1] = {};\\n    int max_e = 0, res = INT_MAX;\\n    for (auto & row : mat) {\\n        bool bt1[70 * 70 + 1] = {};\\n        int max_e1 = 0;\\n        for (auto i : unordered_set(begin(row), end(row))) {\\n            for (int j = 0; j <= max_e; ++j)\\n                if (j == max_e || bt[j]) {\\n                    bt1[i + j] = true;\\n                    max_e1 = max(max_e1, i + j);\\n                }\\n        }\\n        swap(bt, bt1);\\n        max_e = max_e1;\\n    }\\n    for (int i = 0; i <= 70 * 70; ++i) {\\n        if (bt[i])\\n            res = min(res, abs(i - target));\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1418651,
                "title": "c-bitset-meh",
                "content": "p is the bitset from 0 to 5000 (big enough) if the bit `i` is set, which means `i` can be the sum result by far, and do it row by row. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<5000> p(1);\\n        for (auto& r : mat) {\\n            bitset<5000> tmp;\\n            for (auto& i : r) {\\n                tmp = tmp | (p << i);\\n            }\\n            swap(p,tmp);\\n        }\\n        int res = 10000;\\n        for (int i = 0; i < 5000; ++i) {\\n            if (p[i]) res = min(res, abs(i - target));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<5000> p(1);\\n        for (auto& r : mat) {\\n            bitset<5000> tmp;\\n            for (auto& i : r) {\\n                tmp = tmp | (p << i);\\n            }\\n            swap(p,tmp);\\n        }\\n        int res = 10000;\\n        for (int i = 0; i < 5000; ++i) {\\n            if (p[i]) res = min(res, abs(i - target));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418894,
                "title": "c-solution-using-dp-and-memoization",
                "content": "[https://leetcode.com/problems/cherry-pickup/](http://)\\n similar problem\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[8000][71];\\n    int n,m;\\n    int find(vector<vector<int>>&mat,int r,int sum,int &target)\\n    {\\n        if(r>=n)\\n        {\\n            return abs(sum-target);\\n        }\\n        if(dp[sum][r]!=-1)\\n        {\\n            return dp[sum][r];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans=min(ans,find(mat,r+1,sum+mat[r][i],target));\\n            if(ans==0)\\n            {\\n                break;\\n            }\\n        }\\n        return dp[sum][r]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[8000][71];\\n    int n,m;\\n    int find(vector<vector<int>>&mat,int r,int sum,int &target)\\n    {\\n        if(r>=n)\\n        {\\n            return abs(sum-target);\\n        }\\n        if(dp[sum][r]!=-1)\\n        {\\n            return dp[sum][r];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans=min(ans,find(mat,r+1,sum+mat[r][i],target));\\n            if(ans==0)\\n            {\\n                break;\\n            }\\n        }\\n        return dp[sum][r]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418817,
                "title": "java-dp-memoization",
                "content": "Straightforward memoization solution\\n\\n\\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        Integer[][] dp = new Integer[mat.length][5001];\\n        return minDiff(mat, 0, target,0, dp);\\n    }\\n    \\n    public int minDiff(int[][] mat,int index,int target, int val, Integer[][] dp){\\n        if(index == mat.length){\\n            return Math.abs(val - target);\\n        }\\n        if(dp[index][val] != null){\\n            return dp[index][val];\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < mat[0].length; i++){\\n            res = Math.min(res, minDiff(mat, index + 1, target, val + mat[index][i], dp));\\n        }\\n        \\n        return dp[index][val] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        Integer[][] dp = new Integer[mat.length][5001];\\n        return minDiff(mat, 0, target,0, dp);\\n    }\\n    \\n    public int minDiff(int[][] mat,int index,int target, int val, Integer[][] dp){\\n        if(index == mat.length){\\n            return Math.abs(val - target);\\n        }\\n        if(dp[index][val] != null){\\n            return dp[index][val];\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0; i < mat[0].length; i++){\\n            res = Math.min(res, minDiff(mat, index + 1, target, val + mat[index][i], dp));\\n        }\\n        \\n        return dp[index][val] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455794,
                "title": "thought-process-c-dp-memoization-explanation",
                "content": "**If this helped you in anyway, please consider giving an UPVOTE**\\n\\n**Intution :**\\n\\n* Looking at the constraints we can surely think of a brute force approach, which we can later optimize. \\n* Now, in the question we are asked to pick a element from each row and find the total sum. Then, out of all possible combinations, we have to return the one whose absolute difference with target is minimum. \\n\\t* i.e abs(target - sum) is minimum\\n\\t* Also, sum can be *greater than or less than* target\\n\\nLets see what we need to find. In these type of problems where we need to find all the possible combinations, try to solve it recusively by formulating a **recursive formula**. \\n\\n\\tminAbsoluteDiff = min({all possbile sums}) -> there can be n^m possible sums.\\n\\t\\nSo, we need to start picking every element for each row and add it to current path sum, and get the sum. And recursively call for next row along with path sum.\\n\\t\\n\\t\\tsolve(mat, idx+1, sum+mat[idx][j], target)\\n \\n\\t\\nIn the end (base case) when we reach `(i == n)`, simply return absolute difference of target with sum. \\n\\nAlso, we need to memoize. It is simple, we just take a dp table. Since here sum and idx(index) are the 2 changing states. So we take `dp[][]`.\\n\\n# Code:\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dp[72][5000];\\n    int solve(vector<vector<int>>& mat, int row, int sum, const int& target)\\n    {\\n\\t\\t// Base condition\\n        if(row == m)\\n        {\\n            return abs(sum - target);\\n        }\\n        \\n\\t\\t// Check if already calculated\\n        if(dp[row][sum] != -1) return dp[row][sum];\\n        \\n        int minDiff = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            minDiff = min(minDiff, solve(mat, row+1, sum+mat[row][i], target));\\n        }\\n        return dp[row][sum] = minDiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(mat, 0, 0, target);;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dp[72][5000];\\n    int solve(vector<vector<int>>& mat, int row, int sum, const int& target)\\n    {\\n\\t\\t// Base condition\\n        if(row == m)\\n        {\\n            return abs(sum - target);\\n        }\\n        \\n\\t\\t// Check if already calculated\\n        if(dp[row][sum] != -1) return dp[row][sum];\\n        \\n        int minDiff = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            minDiff = min(minDiff, solve(mat, row+1, sum+mat[row][i], target));\\n        }\\n        return dp[row][sum] = minDiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(mat, 0, 0, target);;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418634,
                "title": "100-efficient-pruning-memoization-dynamic-programming-explanation",
                "content": "**Explanation:**\\n\\n\\nPlease note following important observations from question,\\n1. We must choose exactly one element from each row\\n2. Minimize the diff between target and the sum of all chosen elements\\n\\nApproach (and how to solve TLE)\\n\\nNow, the general idea is to explore all possibilities, however, that\\'ll be very hug (~70^70). Hence, the immediate thought is to apply dynamic programmic. The subproblems can be modelled as,\\n\\n`findMinAbsDiff(i,prevSum)` -> returns the minimum abs diff with target, given that we\\'re currently at row i and the sum of chosen numbers for row 0 to i-1 is `prevSum`\\n\\nHence, we can use a `dp[i][prevSum]` array for memoization. However, the answer will still not get accepted due to the nature of input test cases provided.\\n\\nSo, to optimize further you can leverage the fact the minimum possible answer for any input is `0`. Hence, if we get `0` absolute difference then we don\\'t need to explore further, we stop and prune further explorations to save cost.\\n\\n**Additional Note:** I\\'ve also sorted the array prior to actual exploration code to make pruning more efficient, based on the observation of the test constraints, as the target sum is much smaller compared to the sum of max values of the rows. However, that\\'s not neccesary. \\n\\n**Code:**\\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        \\n        # store the mxn size of the matrix\\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n        dp = defaultdict(defaultdict)\\n        \\n        # Sorting each row of the array for more efficient pruning\\n        # Note:this purely based on the observation on problem constraints (although interesting :))\\n        for i in range(m):\\n            mat[i] = sorted(mat[i])\\n        \\n        # returns minimum absolute starting from from row i to n-1 for the target\\n        globalMin = float(\"inf\")\\n        def findMinAbsDiff(i,prevSum):\\n            nonlocal globalMin\\n            if i == m:\\n                globalMin = min(globalMin, abs(prevSum-target))\\n                return abs(prevSum-target)\\n            \\n            # pruning step 1\\n            # because the array is increasing & prevSum & target will always be positive\\n            if prevSum-target > globalMin:\\n                return float(\"inf\")\\n            \\n            \\n            if (i in dp) and (prevSum in dp[i]):\\n                return dp[i][prevSum]\\n            \\n            minDiff = float(\"inf\")\\n            # for each candidate select that and backtrack\\n            for j in range(n):\\n                diff = findMinAbsDiff(i+1, prevSum+mat[i][j])\\n                # pruning step 2 - break if we found minDiff 0 --> VERY CRTICIAL\\n                if diff == 0:\\n                    minDiff = 0\\n                    break\\n                minDiff = min(minDiff, diff)\\n            \\n            dp[i][prevSum] = minDiff\\n            return minDiff\\n        \\n        return findMinAbsDiff(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        \\n        # store the mxn size of the matrix\\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n        dp = defaultdict(defaultdict)\\n        \\n        # Sorting each row of the array for more efficient pruning\\n        # Note:this purely based on the observation on problem constraints (although interesting :))\\n        for i in range(m):\\n            mat[i] = sorted(mat[i])\\n        \\n        # returns minimum absolute starting from from row i to n-1 for the target\\n        globalMin = float(\"inf\")\\n        def findMinAbsDiff(i,prevSum):\\n            nonlocal globalMin\\n            if i == m:\\n                globalMin = min(globalMin, abs(prevSum-target))\\n                return abs(prevSum-target)\\n            \\n            # pruning step 1\\n            # because the array is increasing & prevSum & target will always be positive\\n            if prevSum-target > globalMin:\\n                return float(\"inf\")\\n            \\n            \\n            if (i in dp) and (prevSum in dp[i]):\\n                return dp[i][prevSum]\\n            \\n            minDiff = float(\"inf\")\\n            # for each candidate select that and backtrack\\n            for j in range(n):\\n                diff = findMinAbsDiff(i+1, prevSum+mat[i][j])\\n                # pruning step 2 - break if we found minDiff 0 --> VERY CRTICIAL\\n                if diff == 0:\\n                    minDiff = 0\\n                    break\\n                minDiff = min(minDiff, diff)\\n            \\n            dp[i][prevSum] = minDiff\\n            return minDiff\\n        \\n        return findMinAbsDiff(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418749,
                "title": "from-tles-to-getting-accepted-c",
                "content": "**Brute Force**\\nThe Brute Force Way of doing it is exploring all cells from each row and passing our decisions downwards.\\n\\n***Base Case***\\nWhat if you have only 1 row ? then you choose the cell which gives minimum difference with target\\n\\nBut this is going to get TLE:\\n\\n\\n**Observation**\\n\\nNext step to a recursive code is to see if there are any repeated calls which can be stored.\\n\\nSo if we reach ith row with a sum=s which we had come earlier as well then decisions are going to be same here onwards. So we can create a 2D dp table of size  ( rows * (all possible sums) ).\\n\\nNow what is the range of all possible sums ? we are choosing 1 element from each row and there are 70 rows and each element can have a max value of 70 so took max value of all possible sums = **(71x71)**\\n\\n\\n**Another Observation:**:\\nWe can eliminate same valued cells from each row as having multiple of them is not giving any new path.\\n\\n\\n\\n**Top Down Recursive Code With Memoisation**:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\tint min_diff(vector<vector<int>> & mat,int row,int curr,int target,vector<vector<int>> & dp){\\n\\n\\t\\tint rows=mat.size();\\n\\t\\tint cols=mat[row].size();\\n\\n\\t\\t  // if know the answer for this already simply return \\n\\t\\t  if(dp[row][curr]!=-1){\\n\\t\\t\\treturn dp[row][curr];\\n\\t\\t}\\n\\n\\t\\t// only one row left so take the one which gives minimum difference with target\\n\\t\\tif(row==rows-1){\\n\\n\\t\\t\\tint diff=INT_MAX;\\n\\t\\t\\tfor(int col=0;col<cols;col++){\\n\\t\\t\\t\\tint cd=abs(target-(curr+mat[row][col]));\\n\\t\\t\\t\\tdiff=min(diff,cd);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// remember the result\\n\\t\\t\\tdp[row][curr]=diff;\\n\\t\\t\\treturn diff;\\n\\t\\t}\\n\\n\\t\\tint bdiff=INT_MAX;\\n\\t\\tfor(int col=0;col<cols;col++){\\n\\t\\t\\t// pass on the choice to next row\\n\\t\\t\\tint cdiff=min_diff(mat,row+1,curr+mat[row][col],target,dp);\\n\\t\\t\\t// update if we get a better choice \\n\\t\\t\\tbdiff=min(bdiff,cdiff);\\n\\n\\t\\t\\t// we can\\'t have a better choice then this so stop here\\n\\t\\t\\tif(bdiff==0){\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tdp[row][curr]=bdiff;\\n\\t\\treturn bdiff;\\n\\t}\\n\\n\\tint minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n\\n\\tint rows=mat.size();\\n\\tint cols=mat[0].size();\\n\\n\\t// grid with each row having unique values\\n\\tvector<vector<int>> grid;\\n\\n\\tfor(int row=0;row<rows;row++){\\n\\t\\tunordered_map <int,bool> unique; \\n\\t\\tfor(int col=0;col<cols;col++){\\n\\t\\t\\tunique[mat[row][col]]=true;\\n\\t\\t}\\n\\n\\t\\tvector<int> cr;\\n\\t\\tfor(auto elem:unique){\\n\\t\\t\\tcr.push_back(elem.first);\\n\\t\\t}\\n\\n\\t\\tgrid.push_back(cr);\\n\\t}\\n\\n\\tvector<vector<int>> dp(rows,vector<int>(5041,-1));\\n\\tint ans=min_diff(grid,0,0,target,dp);\\n\\treturn ans;\\n\\t}\\n};\\n```\\n\\nTime Complexity -> **O(rows * columns * (all possible sums))**\\nSpace Complxity -> **O(rows * (all possible sums))**\\n\\nI hope this was helpful!\\nIf there are any suggestions or optimisations do tell. If this helped somehow do consider upvoting :) .",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\tint min_diff(vector<vector<int>> & mat,int row,int curr,int target,vector<vector<int>> & dp){\\n\\n\\t\\tint rows=mat.size();\\n\\t\\tint cols=mat[row].size();\\n\\n\\t\\t  // if know the answer for this already simply return \\n\\t\\t  if(dp[row][curr]!=-1){\\n\\t\\t\\treturn dp[row][curr];\\n\\t\\t}\\n\\n\\t\\t// only one row left so take the one which gives minimum difference with target\\n\\t\\tif(row==rows-1){\\n\\n\\t\\t\\tint diff=INT_MAX;\\n\\t\\t\\tfor(int col=0;col<cols;col++){\\n\\t\\t\\t\\tint cd=abs(target-(curr+mat[row][col]));\\n\\t\\t\\t\\tdiff=min(diff,cd);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// remember the result\\n\\t\\t\\tdp[row][curr]=diff;\\n\\t\\t\\treturn diff;\\n\\t\\t}\\n\\n\\t\\tint bdiff=INT_MAX;\\n\\t\\tfor(int col=0;col<cols;col++){\\n\\t\\t\\t// pass on the choice to next row\\n\\t\\t\\tint cdiff=min_diff(mat,row+1,curr+mat[row][col],target,dp);\\n\\t\\t\\t// update if we get a better choice \\n\\t\\t\\tbdiff=min(bdiff,cdiff);\\n\\n\\t\\t\\t// we can\\'t have a better choice then this so stop here\\n\\t\\t\\tif(bdiff==0){\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tdp[row][curr]=bdiff;\\n\\t\\treturn bdiff;\\n\\t}\\n\\n\\tint minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n\\n\\tint rows=mat.size();\\n\\tint cols=mat[0].size();\\n\\n\\t// grid with each row having unique values\\n\\tvector<vector<int>> grid;\\n\\n\\tfor(int row=0;row<rows;row++){\\n\\t\\tunordered_map <int,bool> unique; \\n\\t\\tfor(int col=0;col<cols;col++){\\n\\t\\t\\tunique[mat[row][col]]=true;\\n\\t\\t}\\n\\n\\t\\tvector<int> cr;\\n\\t\\tfor(auto elem:unique){\\n\\t\\t\\tcr.push_back(elem.first);\\n\\t\\t}\\n\\n\\t\\tgrid.push_back(cr);\\n\\t}\\n\\n\\tvector<vector<int>> dp(rows,vector<int>(5041,-1));\\n\\tint ans=min_diff(grid,0,0,target,dp);\\n\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418666,
                "title": "python-set",
                "content": "```python\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        R, C = len(mat), len(mat[0])\\n        \\n        S = set(mat[0])\\n        for r in range(1, R):\\n            NS = set()\\n            for x in set(mat[r]):\\n                for y in S:\\n                    NS.add(x + y)\\n            S = NS\\n        \\n        return min(abs(x - target) for x in S)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        R, C = len(mat), len(mat[0])\\n        \\n        S = set(mat[0])\\n        for r in range(1, R):\\n            NS = set()\\n            for x in set(mat[r]):\\n                for y in S:\\n                    NS.add(x + y)\\n            S = NS\\n        \\n        return min(abs(x - target) for x in S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418747,
                "title": "easy-to-understand-java-solution-with-explanation",
                "content": "Sharing easy to understand solution using 2 sets.\\n\\nIdea:\\n1) **Brute Force (TLE):** Create 2 sets (1 representing all the possible sums up to but not including the current row, 1 representing all the possible sums up to and including the current row). Iterate matrix row by row, for each element in set, column by column, and add each element to each possible sub-sum so far. Save all the possible sums to a new set and set the current to the new set at the end of a row. At the end, look in all the possible sums to find the closest one to target.\\n2) **Optimization:**  You actually don\\'t need all the possible sums at each row, you really only need all sums up to the smallest sum that is greater or equal to target. So a small optimization is to remove all the sums that are greater than the smallest sum greater or equal to target.\\n3) **Analysis:** Time Complexity: `O(target * m * n)`, Space Complexity: `O(target + n)`\\n\\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        Set<Integer> s_curr = new HashSet<>();\\n        Set<Integer> s_new = new HashSet<>();\\n        s_curr.add(0);\\n        for (int i = 0; i < mat.length; i++) {\\n          s_new = new HashSet<>();\\n          for (Integer v : s_curr) {\\n            for (int j = 0; j < mat[i].length; ++j)\\n                s_new.add(v + mat[i][j]);\\n          }\\n            \\n          // Remove all elements greater than the smallest element greater than target\\n          int min_over = Integer.MAX_VALUE;\\n          for (Integer v : s_new) {\\n            if (v >= target) min_over = Math.min(min_over, v);\\n          }\\n          s_curr = new HashSet();\\n          for (Integer v : s_new) {\\n            if (v <= min_over) s_curr.add(v);\\n          }\\n        }\\n        int min_diff = Integer.MAX_VALUE;\\n        for(Integer v : s_curr){\\n            int curr_diff = Math.abs(v - target);\\n            min_diff = Math.min(curr_diff, min_diff);\\n        }\\n        return min_diff;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        Set<Integer> s_curr = new HashSet<>();\\n        Set<Integer> s_new = new HashSet<>();\\n        s_curr.add(0);\\n        for (int i = 0; i < mat.length; i++) {\\n          s_new = new HashSet<>();\\n          for (Integer v : s_curr) {\\n            for (int j = 0; j < mat[i].length; ++j)\\n                s_new.add(v + mat[i][j]);\\n          }\\n            \\n          // Remove all elements greater than the smallest element greater than target\\n          int min_over = Integer.MAX_VALUE;\\n          for (Integer v : s_new) {\\n            if (v >= target) min_over = Math.min(min_over, v);\\n          }\\n          s_curr = new HashSet();\\n          for (Integer v : s_new) {\\n            if (v <= min_over) s_curr.add(v);\\n          }\\n        }\\n        int min_diff = Integer.MAX_VALUE;\\n        for(Integer v : s_curr){\\n            int curr_diff = Math.abs(v - target);\\n            min_diff = Math.min(curr_diff, min_diff);\\n        }\\n        return min_diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418614,
                "title": "java-dp-code-with-proper-comments-and-explanation",
                "content": "We can simply iterate over all the possible cases and memoise the already taken path to avoid repetitive calculation.\\nDp with states as current row and sum till now would do it.\\n```\\n int ans = Integer.MAX_VALUE;\\n    boolean[][] dp;  // For memoisation\\n    void func(int[][] mat , int r, int sum, int t){    // where dp states are current row and the sum achieved yet.\\n        if(dp[r][sum]) return; // If the same row has already been visited with the same sum no need to further process.\\n        if(r==mat.length-1){ // base case for the last row.\\n            for(int i=0;i<mat[0].length;i++){\\n            ans=Math.min(ans,Math.abs(sum+mat[r][i]-t));\\n            }\\n            dp[r][sum]=true;  // processing done, so mark in the dp table\\n            return;\\n        }\\n        for(int i=0;i<mat[0].length;i++){    // Iterating over every possibility\\n            func(mat,r+1,sum+mat[r][i],t);\\n        }\\n        dp[r][sum]=true; //// processing done, so mark in the dp table\\n    }\\n    public int minimizeTheDifference(int[][] mat, int t) {\\n        dp = new boolean[mat.length][5000];\\n        func(mat,0,0,t);\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "We can simply iterate over all the possible cases and memoise the already taken path to avoid repetitive calculation.\\nDp with states as current row and sum till now would do it.\\n```\\n int ans = Integer.MAX_VALUE;\\n    boolean[][] dp;  // For memoisation\\n    void func(int[][] mat , int r, int sum, int t){    // where dp states are current row and the sum achieved yet.\\n        if(dp[r][sum]) return; // If the same row has already been visited with the same sum no need to further process.\\n        if(r==mat.length-1){ // base case for the last row.\\n            for(int i=0;i<mat[0].length;i++){\\n            ans=Math.min(ans,Math.abs(sum+mat[r][i]-t));\\n            }\\n            dp[r][sum]=true;  // processing done, so mark in the dp table\\n            return;\\n        }\\n        for(int i=0;i<mat[0].length;i++){    // Iterating over every possibility\\n            func(mat,r+1,sum+mat[r][i],t);\\n        }\\n        dp[r][sum]=true; //// processing done, so mark in the dp table\\n    }\\n    public int minimizeTheDifference(int[][] mat, int t) {\\n        dp = new boolean[mat.length][5000];\\n        func(mat,0,0,t);\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1420631,
                "title": "simple-c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int pq[10000][100];\\n    int helper(vector<vector<int>>&mat,int row,int sum,int target)\\n    {   \\n        if(row >= mat.size())\\n            return abs(sum-target);\\n        if(pq[sum][row] != -1)\\n            return pq[sum][row];\\n       int ans = INT_MAX;\\n        for(int i = 0;i<mat[row].size();i++)\\n        {\\n            ans = min(ans,helper(mat,row+1,sum+mat[row][i],target));\\n        }\\n        return pq[sum][row] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n         memset(pq,-1,sizeof(pq));\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        return helper(mat,0,0,target);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int pq[10000][100];\\n    int helper(vector<vector<int>>&mat,int row,int sum,int target)\\n    {   \\n        if(row >= mat.size())\\n            return abs(sum-target);\\n        if(pq[sum][row] != -1)\\n            return pq[sum][row];\\n       int ans = INT_MAX;\\n        for(int i = 0;i<mat[row].size();i++)\\n        {\\n            ans = min(ans,helper(mat,row+1,sum+mat[row][i],target));\\n        }\\n        return pq[sum][row] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n         memset(pq,-1,sizeof(pq));\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        return helper(mat,0,0,target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418753,
                "title": "python-set-and-early-stop-2700ms",
                "content": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        possibleSum = set([0])\\n        for m in mat:\\n            temp = set()\\n            for y in possibleSum:\\n                for x in sorted(set(m)):\\n                    temp.add(x+y)\\n                    if x+y>target:\\n                        break\\n            possibleSum = temp\\n        return min(abs(s-target) for s in possibleSum)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        possibleSum = set([0])\\n        for m in mat:\\n            temp = set()\\n            for y in possibleSum:\\n                for x in sorted(set(m)):\\n                    temp.add(x+y)\\n                    if x+y>target:\\n                        break\\n            possibleSum = temp\\n        return min(abs(s-target) for s in possibleSum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418706,
                "title": "simple-c-recursion-memo",
                "content": "This solution was accepted earlier.\\nAccepted:\\n![image](https://assets.leetcode.com/users/images/1142deb7-90af-4830-b69a-dba21cffbf0d_1629606425.2784035.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int t[5001][71];\\n    int row, col;\\n    \\n    int find(vector<vector<int>>& mat, int row, int sum, int& target)\\n    {\\n        if(row <= 0)\\n            return abs(sum-target);\\n        \\n       if(t[sum][row]!=-1)\\n           return t[sum][row];\\n        \\n        int minDiff = INT_MAX;\\n        for(int j=0; j<col; j++)\\n        {\\n            minDiff = min(minDiff, find(mat, row-1, sum+mat[row-1][j], target));\\n        }\\n        return t[sum][row] = minDiff;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(t,-1,sizeof(t));\\n        row = mat.size();\\n        col = mat[0].size();\\n        return find(mat, row, 0, target);\\n        \\n    }\\n};\\n```\\n\\n/*\\nNow, the solution gives TLE as new test cases have been added. I will be updating this with an accepted approach. Thanks @user77777 for letting me know the latest update.\\n*/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[5001][71];\\n    int row, col;\\n    \\n    int find(vector<vector<int>>& mat, int row, int sum, int& target)\\n    {\\n        if(row <= 0)\\n            return abs(sum-target);\\n        \\n       if(t[sum][row]!=-1)\\n           return t[sum][row];\\n        \\n        int minDiff = INT_MAX;\\n        for(int j=0; j<col; j++)\\n        {\\n            minDiff = min(minDiff, find(mat, row-1, sum+mat[row-1][j], target));\\n        }\\n        return t[sum][row] = minDiff;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(t,-1,sizeof(t));\\n        row = mat.size();\\n        col = mat[0].size();\\n        return find(mat, row, 0, target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177436,
                "title": "python-3-4-lines-sets-t-m-87-47",
                "content": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\n        mat = [set(row) for row in mat]\\n        \\n        rSet = set(mat.pop())\\n\\n        for row in mat: rSet = {m+n for m in row for n in rSet}\\n        \\n        return min(abs(n - target) for n in rSet)\\n\\n```\\n[https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/submissions/863630229/](http://)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\n        mat = [set(row) for row in mat]\\n        \\n        rSet = set(mat.pop())\\n\\n        for row in mat: rSet = {m+n for m in row for n in rSet}\\n        \\n        return min(abs(n - target) for n in rSet)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418807,
                "title": "python-dp-using-cache",
                "content": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        m = len(mat)\\n        \\n        for i in range(m):\\n            mat[i] = set(mat[i]) # remove duplicates\\n                \\n        self.min_diff = inf\\n                \\n        @cache\\n        def search(i, s):\\n            if target + self.min_diff < s: # sum is too big\\n                return inf\\n            if i == m:\\n                return abs(target-s)\\n            \\n            row = mat[i]\\n            min_diff = inf\\n            for num in row:\\n                min_diff = min(min_diff, search(i+1, s + num))\\n                \\n            self.min_diff = min(self.min_diff, min_diff)\\n                \\n            return min_diff\\n        \\n        return search(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        m = len(mat)\\n        \\n        for i in range(m):\\n            mat[i] = set(mat[i]) # remove duplicates\\n                \\n        self.min_diff = inf\\n                \\n        @cache\\n        def search(i, s):\\n            if target + self.min_diff < s: # sum is too big\\n                return inf\\n            if i == m:\\n                return abs(target-s)\\n            \\n            row = mat[i]\\n            min_diff = inf\\n            for num in row:\\n                min_diff = min(min_diff, search(i+1, s + num))\\n                \\n            self.min_diff = min(self.min_diff, min_diff)\\n                \\n            return min_diff\\n        \\n        return search(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418700,
                "title": "simple-c-bottom-up-approach-o-n-m-target",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int m, n;\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        m = mat.size();\\n        n = mat[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(target+1, INT_MAX));\\n        \\n        // dp[i][j] ans for upto ith row and j target val\\n        \\n        for(int j=0; j<=target; j++) dp[0][j] = j;\\n        \\n        for(int i=1; i<=m; i++){\\n            for(int j=0; j <= target; j++){\\n                for(int k=0; k<n; k++){\\n                    if(j >= mat[i-1][k]) dp[i][j] = min(dp[i][j], dp[i-1][j - mat[i-1][k]]);\\n                    else dp[i][j] = min(dp[i][j], (mat[i-1][k] - j) + dp[i-1][0]);\\n                }\\n            }\\n        }\\n        \\n        int ans = dp[m][target];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int m, n;\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        m = mat.size();\\n        n = mat[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(target+1, INT_MAX));\\n        \\n        // dp[i][j] ans for upto ith row and j target val\\n        \\n        for(int j=0; j<=target; j++) dp[0][j] = j;\\n        \\n        for(int i=1; i<=m; i++){\\n            for(int j=0; j <= target; j++){\\n                for(int k=0; k<n; k++){\\n                    if(j >= mat[i-1][k]) dp[i][j] = min(dp[i][j], dp[i-1][j - mat[i-1][k]]);\\n                    else dp[i][j] = min(dp[i][j], (mat[i-1][k] - j) + dp[i-1][0]);\\n                }\\n            }\\n        }\\n        \\n        int ans = dp[m][target];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418693,
                "title": "java-short-and-concise-dp-memoize-solution",
                "content": "Logic : Create a 2-D dp array with dimesions row*(max sum possible) . Traverse through each path possible from first row to last row taking one element form each row . \\n\\n```\\nclass Solution {\\n\\n    int[][] dp;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp=new int[mat.length][4901];\\n        for(int i=0;i<mat.length;i++) Arrays.fill(dp[i],-1);\\n        return dfs(mat,0,target,0);\\n    }\\n    public int dfs(int[][] mat,int index,int target,int sum){\\n        if(index==mat.length){\\n            return Math.abs(sum-target);\\n        }\\n        if(dp[index][sum]!=-1) return dp[index][sum];\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<mat[0].length;i++){\\n            ans=Math.min(ans,dfs(mat,index+1,target,sum+mat[index][i]));\\n        }\\n        dp[index][sum]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[][] dp;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp=new int[mat.length][4901];\\n        for(int i=0;i<mat.length;i++) Arrays.fill(dp[i],-1);\\n        return dfs(mat,0,target,0);\\n    }\\n    public int dfs(int[][] mat,int index,int target,int sum){\\n        if(index==mat.length){\\n            return Math.abs(sum-target);\\n        }\\n        if(dp[index][sum]!=-1) return dp[index][sum];\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<mat[0].length;i++){\\n            ans=Math.min(ans,dfs(mat,index+1,target,sum+mat[index][i]));\\n        }\\n        dp[index][sum]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112744,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dp[70*70+1][70];\\n    int dfs(vector<vector<int>>& mat, int r, int sum, int target)\\n    {\\n        if(r>=m)\\n        return abs(sum-target);\\n        if(dp[sum][r]!=-1)\\n        return dp[sum][r];\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans, dfs(mat, r+1, sum+mat[r][i], target));\\n            if(ans==0)\\n            break;\\n        }\\n        return dp[sum][r]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        m=mat.size();\\n        n=mat[0].size();\\n        return dfs(mat, 0, 0, target);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dp[70*70+1][70];\\n    int dfs(vector<vector<int>>& mat, int r, int sum, int target)\\n    {\\n        if(r>=m)\\n        return abs(sum-target);\\n        if(dp[sum][r]!=-1)\\n        return dp[sum][r];\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans, dfs(mat, r+1, sum+mat[r][i], target));\\n            if(ans==0)\\n            break;\\n        }\\n        return dp[sum][r]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        m=mat.size();\\n        n=mat[0].size();\\n        return dfs(mat, 0, 0, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418765,
                "title": "python3-fast-fourier-transform-o-sum-log-sum-m",
                "content": "Using FFT for faster Sumset, works only for small bounded values(in this question sum cannot exceed 4900).\\n```\\nfrom numpy.fft import rfft, irfft\\nclass Solution:\\n    \\n    \\n    def fftrealpolymul(self,arr_a, arr_b):  #fft based real-valued polynomial multiplication\\n        L = len(arr_a) + len(arr_b)\\n        a_f = rfft(arr_a, L)\\n        b_f = rfft(arr_b, L)\\n        return irfft(a_f * b_f,L)\\n\\n    def convolve_rows_between(self,mat,low,high):\\n        if low == high:\\n            res = [0]*71\\n            for num in mat[low]:\\n                res[num] = 1\\n            return res\\n        mid = (low+high)//2\\n        upper_half = self.convolve_rows_between(mat,low,mid)\\n        lower_half = self.convolve_rows_between(mat,mid+1,high)\\n        multiplied_result = self.fftrealpolymul(upper_half,lower_half)\\n        mask_list = [min(1,round(num)) for num in multiplied_result]\\n        return mask_list\\n    \\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n   \\n        possible_sums = self.convolve_rows_between(mat,0,len(mat)-1)\\n        minDiff = 100000\\n        for i in range(len(possible_sums)):\\n            if possible_sums[i]!=0:\\n                minDiff = min(minDiff,abs(i-target))\\n            \\n        return minDiff\\n```",
                "solutionTags": [],
                "code": "```\\nfrom numpy.fft import rfft, irfft\\nclass Solution:\\n    \\n    \\n    def fftrealpolymul(self,arr_a, arr_b):  #fft based real-valued polynomial multiplication\\n        L = len(arr_a) + len(arr_b)\\n        a_f = rfft(arr_a, L)\\n        b_f = rfft(arr_b, L)\\n        return irfft(a_f * b_f,L)\\n\\n    def convolve_rows_between(self,mat,low,high):\\n        if low == high:\\n            res = [0]*71\\n            for num in mat[low]:\\n                res[num] = 1\\n            return res\\n        mid = (low+high)//2\\n        upper_half = self.convolve_rows_between(mat,low,mid)\\n        lower_half = self.convolve_rows_between(mat,mid+1,high)\\n        multiplied_result = self.fftrealpolymul(upper_half,lower_half)\\n        mask_list = [min(1,round(num)) for num in multiplied_result]\\n        return mask_list\\n    \\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n   \\n        possible_sums = self.convolve_rows_between(mat,0,len(mat)-1)\\n        minDiff = 100000\\n        for i in range(len(possible_sums)):\\n            if possible_sums[i]!=0:\\n                minDiff = min(minDiff,abs(i-target))\\n            \\n        return minDiff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418674,
                "title": "dp-memoization-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[71][5701];\\n    int mindif(vector<vector<int>>& mat,int ind,int sum){\\n      if(ind==mat.size())return abs(sum);\\n        \\n        if(dp[ind][4900+sum]!=-1) return dp[ind][4900+sum];\\n        int res=INT_MAX;\\n        for(int i=0;i<mat[0].size();i++){\\n        res=min(res,mindif(mat,ind+1,sum-mat[ind][i]));\\n        }\\n        \\n        return dp[ind][4900+sum]=res;\\n    }\\n  \\n    int minimizeTheDifference(vector<vector<int>>& Mat, int t) {\\n        int n=Mat.size(),m=Mat[0].size();\\n        \\n        if(n==1&&m==1)return abs(Mat[0][0]-t);\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=5700;j++){\\n        dp[i][j]=-1; \\n            }       }\\n        \\n       int ans=mindif(Mat,0,t);\\n \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nQ: Why are we using 4900+sum?\\nans: Actually min value of sum can be -4900+1,when each element of mat is 70 , max 70 row can exist and min value of traget is 1. So,min value of 4900+sum is always a +ve number .If we are not using this then -ve index of dp will give runtime error.\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[71][5701];\\n    int mindif(vector<vector<int>>& mat,int ind,int sum){\\n      if(ind==mat.size())return abs(sum);\\n        \\n        if(dp[ind][4900+sum]!=-1) return dp[ind][4900+sum];\\n        int res=INT_MAX;\\n        for(int i=0;i<mat[0].size();i++){\\n        res=min(res,mindif(mat,ind+1,sum-mat[ind][i]));\\n        }\\n        \\n        return dp[ind][4900+sum]=res;\\n    }\\n  \\n    int minimizeTheDifference(vector<vector<int>>& Mat, int t) {\\n        int n=Mat.size(),m=Mat[0].size();\\n        \\n        if(n==1&&m==1)return abs(Mat[0][0]-t);\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=5700;j++){\\n        dp[i][j]=-1; \\n            }       }\\n        \\n       int ans=mindif(Mat,0,t);\\n \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108433,
                "title": "c-using-bitset-in-o-1-space",
                "content": "# Intuition\\n->1st observation is that sum <= 70 * 70 \\n->2nd obserbation is that to reduce space complexity (solution with dp have same complexity of O(5000*71)) we have to use something that can tell in linear time that if this sum is possible or not. so bitset<> is best for that \\n\\n# Approach\\n1. First row values mat[0][j] can be possible sums so will set the bit of possible sum on that index (eg. mat[0][0] = 4 so possible_sum = 00......00100)\\n2. iterate on each element of every row \\n3. intialize bitset<>on_that_row = possibel_sum(bitset from previous row)\\n4. now left shift operation:  (prev << mat[i][j]). this will left shift the bitset<> previous row it same like addition of two number\\n(eg. bitst<>prev = 00......0010100 means upto previous row sum = 2 and sum = 4 are possibe now let mat[next_row][0] = 2 so will left shift two times the previous row bitset so on_that_row = 0000...01010000 means on this row possible sums = 4 and sum = 6) ,now for all sum will do OR operation\\n5. now again for each row update the possible_sum by on_that_row.\\n6. now just check set bit in  possible_sum and check for result.\\n\\n\\nIf u have any doubt feel free to ask in comments section, hope u liked the solution.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n\\n        int m = mat.size(), n = mat.front().size(), cs = 5000, res = cs;\\n        bitset<5000> possible_sum;\\n        for(int i=0; i<n; ++i) possible_sum[mat[0][i]] = 1;\\n        for(int i=1; i<m; ++i) {\\n            bitset<5000> pre = possible_sum, on_that_row;\\n            for(int j=0; j<n; ++j) {\\n                on_that_row |= (pre << mat[i][j]);\\n            }\\n            possible_sum = on_that_row;\\n        }\\n        for(int i=0; i<cs; ++i) {\\n            if(possible_sum[i]) res = min(res, abs(i-target));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n\\n        int m = mat.size(), n = mat.front().size(), cs = 5000, res = cs;\\n        bitset<5000> possible_sum;\\n        for(int i=0; i<n; ++i) possible_sum[mat[0][i]] = 1;\\n        for(int i=1; i<m; ++i) {\\n            bitset<5000> pre = possible_sum, on_that_row;\\n            for(int j=0; j<n; ++j) {\\n                on_that_row |= (pre << mat[i][j]);\\n            }\\n            possible_sum = on_that_row;\\n        }\\n        for(int i=0; i<cs; ++i) {\\n            if(possible_sum[i]) res = min(res, abs(i-target));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704838,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[4901][71];\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        //int fun(vector<vector<int>>&mat,int &target,int sum,int row);\\n        memset(dp,-1,sizeof(dp));\\n        int row=0;\\n        int sum=0;\\n        return fun(mat,target,sum,row);\\n    }\\n    int fun(vector<vector<int>>&mat,int &target,int sum,int row)\\n    {\\n        if(row >= mat.size())\\n        {\\n           return abs(target-sum);\\t\\n        }\\n\\n        if(dp[sum][row]!=-1)\\n            return dp[sum][row];\\n\\n        int ans=INT_MAX;   //final ans that we will return   //ans-->9\\n        for(int i=0;i<mat[row].size();i++)\\n        {\\n           ans=min(ans,fun(mat,target,sum+mat[row][i],row+1));\\n           if(ans==0)\\n           {\\n              return dp[sum][row]=ans;\\n           }\\n        }\\n        return dp[sum][row]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[4901][71];\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        //int fun(vector<vector<int>>&mat,int &target,int sum,int row);\\n        memset(dp,-1,sizeof(dp));\\n        int row=0;\\n        int sum=0;\\n        return fun(mat,target,sum,row);\\n    }\\n    int fun(vector<vector<int>>&mat,int &target,int sum,int row)\\n    {\\n        if(row >= mat.size())\\n        {\\n           return abs(target-sum);\\t\\n        }\\n\\n        if(dp[sum][row]!=-1)\\n            return dp[sum][row];\\n\\n        int ans=INT_MAX;   //final ans that we will return   //ans-->9\\n        for(int i=0;i<mat[row].size();i++)\\n        {\\n           ans=min(ans,fun(mat,target,sum+mat[row][i],row+1));\\n           if(ans==0)\\n           {\\n              return dp[sum][row]=ans;\\n           }\\n        }\\n        return dp[sum][row]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376786,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int ans = INT_MAX;\\n    void dfs(int x, int s, vector<vector<int>> &dp, vector<vector<int>>& mat, int target, int n, int m)\\n    {\\n        if(s-ans >= target) return;\\n        if(dp[x][s] != -1) return;\\n        if(x == n)\\n        {\\n            //cout << s << \" \";\\n            ans = min(ans, abs(target-s));\\n            \\n            dp[x][s] = 1;\\n            return;\\n        }\\n        else\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                dfs(x+1, s + mat[x][j], dp, mat, target, n, m);\\n            }\\n            dp[x][s] = 1;\\n        }\\n        return;\\n    }\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> dp(n+1, vector<int> (4000, -1));\\n        dfs(0, 0, dp, mat, target, n, m);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int ans = INT_MAX;\\n    void dfs(int x, int s, vector<vector<int>> &dp, vector<vector<int>>& mat, int target, int n, int m)\\n    {\\n        if(s-ans >= target) return;\\n        if(dp[x][s] != -1) return;\\n        if(x == n)\\n        {\\n            //cout << s << \" \";\\n            ans = min(ans, abs(target-s));\\n            \\n            dp[x][s] = 1;\\n            return;\\n        }\\n        else\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                dfs(x+1, s + mat[x][j], dp, mat, target, n, m);\\n            }\\n            dp[x][s] = 1;\\n        }\\n        return;\\n    }\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> dp(n+1, vector<int> (4000, -1));\\n        dfs(0, 0, dp, mat, target, n, m);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2107993,
                "title": "java-dp-clean-code",
                "content": "```\\nclass Solution {\\n    \\n    int min = Integer.MAX_VALUE;\\n\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        final int maxM = 70;\\n        final int maxN = 70;\\n        boolean[][] dp = new boolean[mat.length][(maxM * maxN) + 1];\\n        helper(mat, target, dp, 0, 0);   \\n        return min;\\n    }\\n    \\n    private void helper(int[][] mat, int target, boolean[][] dp, int row, int sum) {\\n        \\n        if (row == mat.length) {\\n            min = Math.min(min, Math.abs(target-sum));\\n            return;\\n        }\\n        \\n        if (dp[row][sum]) return;\\n        \\n        for (int i=0; i<mat[0].length; i++) {\\n            helper(mat, target, dp, row+1, sum + mat[row][i]);\\n        }\\n        \\n        dp[row][sum] = true;\\n    }\\n}",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int min = Integer.MAX_VALUE;\\n\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        final int maxM = 70;\\n        final int maxN = 70;\\n        boolean[][] dp = new boolean[mat.length][(maxM * maxN) + 1];\\n        helper(mat, target, dp, 0, 0);   \\n        return min;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1904480,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n,m,goal;\\n    \\n    int dp[71][4905];\\n    vector<int> v;\\n    \\n    int solve(vector<vector<int>>& mat,int i,int sum)\\n    {\\n        if(i>=n) \\n        {\\n            //picking element from each row and taking abs diff of all possible path.\\n            return abs(sum-goal);\\n        }\\n        \\n        //since sum>=goal,so from ith row till last we will only pick min element from each bcz          \\n\\t\\t//adding other element only increase abs diff as all element are +ve. so add all min             \\n\\t\\t//element from ith till last row and take abs diff.\\n        if(sum>=goal) return abs(sum+v[i]-goal);\\n        \\n        if(dp[i][sum]!=-1) return dp[i][sum]; \\n        \\n        int ans=INT_MAX;\\n         \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,solve(mat,i+1,sum+mat[i][j]));\\n        }\\n        \\n        return dp[i][sum]=ans;\\n    }\\n    \\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        n=mat.size(),m=mat[0].size();\\n        goal=target;\\n          \\n        for(auto &x:mat)\\n        {\\n            v.push_back(*min_element(begin(x),end(x)));//stores min element of each row\\n        }\\n        \\n        //v[i] now stores sum of min element of each row from i till last row\\n        for(int i=n-2;i>=0;i--) v[i]+=v[i+1];\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(mat,0,0);\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n,m,goal;\\n    \\n    int dp[71][4905];\\n    vector<int> v;\\n    \\n    int solve(vector<vector<int>>& mat,int i,int sum)\\n    {\\n        if(i>=n) \\n        {\\n            //picking element from each row and taking abs diff of all possible path.\\n            return abs(sum-goal);\\n        }\\n        \\n        //since sum>=goal,so from ith row till last we will only pick min element from each bcz          \\n\\t\\t//adding other element only increase abs diff as all element are +ve. so add all min             \\n\\t\\t//element from ith till last row and take abs diff.\\n        if(sum>=goal) return abs(sum+v[i]-goal);\\n        \\n        if(dp[i][sum]!=-1) return dp[i][sum]; \\n        \\n        int ans=INT_MAX;\\n         \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,solve(mat,i+1,sum+mat[i][j]));\\n        }\\n        \\n        return dp[i][sum]=ans;\\n    }\\n    \\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        n=mat.size(),m=mat[0].size();\\n        goal=target;\\n          \\n        for(auto &x:mat)\\n        {\\n            v.push_back(*min_element(begin(x),end(x)));//stores min element of each row\\n        }\\n        \\n        //v[i] now stores sum of min element of each row from i till last row\\n        for(int i=n-2;i>=0;i--) v[i]+=v[i+1];\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(mat,0,0);\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756402,
                "title": "easy-c-sol-using-dp",
                "content": "The question states that we need to pick one element from each row , such that \\nthe absolute differnce b/w the sum  and target is minimized. In other words, their sum should be close to target.\\n\\nSimple approach is try all possible combinatoins /paths, return the minimum value of abs(target-sum).\\nHere , our result does not depend upon which column we are landing in. It depends upon the row to be traversed , and the target remaining / or say sum of chosen values upto that row.\\n\\nSo , let f(row, sum) be a function, which determines the total sum of chosen elements (one from each row) upto row th row from last row.\\n\\nf(row, sum)= min of( f(row-1, sum\\'), f(row-1, sum\\'\\').........)\\n![image](https://assets.leetcode.com/users/images/1912072e-f0da-4494-9345-afbfdc10c49a_1644347575.3780317.jpeg)\\n\\nThe above diagram shows that we ahve overlapping subprobelms , hence optimization can be done using dp.\\n\\n**Base case**- When row becomes 0 , that means we have included values from all rows to sum , hence we will return absolute difference of sum and target.\\n\\n**Points to remember**- Since the dp array , has row of mat as its row , so max size of row can be m+1, but the columns of dp array is sum , and the maximum value of sum can be 70*70 , hence we will initialise dp[m][4900+1]\\n\\n\\n```\\nint minDiff(int row,int n, vector<vector<int>>&mat, int target,int sum,vector<vector<int>>&dp){\\n    if(row==0)return dp[0][sum]=abs(target-sum);\\n    \\n    if(dp[row][sum]!=-1)return dp[row][sum];\\n    int diff=INT_MAX;\\n    for(int i=0;i<n;i++){\\n        int curr=minDiff(row-1,n,mat,target,sum+mat[row-1][i],dp);\\n        if(curr==0)return dp[row][sum]=0;\\n        diff=min(diff,curr);\\n    }\\n    return dp[row][sum]=diff;\\n} \\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n \\n        int m=mat.size();\\n        int n=mat[0].size();\\n        \\n        vector<vector<int>>dp(m+1,vector<int>(4900+2,-1));\\n        int sum=0;\\n        return minDiff(m,n,mat,target,sum,dp);\\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n \\n        int m=mat.size();\\n        int n=mat[0].size();\\n        \\n        vector<vector<int>>dp(m+1,vector<int>(4900+2,-1));\\n        int sum=0;\\n        return minDiff(m,n,mat,target,sum,dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1571346,
                "title": "python-bruteforce-with-memo",
                "content": "The bruteforce solution here is just to calculate all possible sums and then find the best that gives minium absolut difference with `target`. \\n\\nIf we start iterating all possible combinations of elements in columns, that algorithm would take O(m^n) time. So we are trying to optimize it by iterating the matrix from the bottom (*PS.: Not necessery to go from bottom to up*) and storing partial sums from the current row to the last row in the set `allSum`. Every time we move to the higher row, we iterate over that row, and for each element iterate over all partial sums in the set and add it to that sums. Because `allSum` is a set, the repeated values will disapear and we will not need to iterate over the same values. But anyway, in worst case we are going to have space and time complexity O(m^n).\\n\\nTime: **O(m^n)**\\nSpace: **O(m^n)**\\n\\nRuntime: 12868 ms, faster than **6.67%** of Python online submissions for Minimize the Difference Between Target and Chosen Elements.\\nMemory Usage: 14.5 MB, less than **10.00%** of Python online submissions for Minimize the Difference Between Target and Chosen Elements.\\n\\n```\\nclass Solution(object):\\n    def minimizeTheDifference(self, mat, target):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        n, m = len(mat), len(mat[0])\\n        \\n        # find all possible sums\\n\\t\\t# at the start it\\'s just a last row of the matrix\\n        allSum = set(mat[n - 1])\\n        \\n        if n > 1: \\n            for i in range(n-2, -1, -1): # iterate from the last row to the first\\n                rowSums = set()\\n                \\n                for j in range(0, m): # iterate over all elements in the row\\n                    rowSums.update([mat[i][j] + sum for sum in allSum])\\n                \\n                allSum = rowSums\\n                \\n        # find absolute min\\n        minAbs = float(\"inf\")\\n        \\n        for sum in allSum:\\n            absDif = abs(sum - target)\\n            if (absDif < minAbs):\\n                minAbs = absDif\\n        \\n        return minAbs\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimizeTheDifference(self, mat, target):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        n, m = len(mat), len(mat[0])\\n        \\n        # find all possible sums\\n\\t\\t# at the start it\\'s just a last row of the matrix\\n        allSum = set(mat[n - 1])\\n        \\n        if n > 1: \\n            for i in range(n-2, -1, -1): # iterate from the last row to the first\\n                rowSums = set()\\n                \\n                for j in range(0, m): # iterate over all elements in the row\\n                    rowSums.update([mat[i][j] + sum for sum in allSum])\\n                \\n                allSum = rowSums\\n                \\n        # find absolute min\\n        minAbs = float(\"inf\")\\n        \\n        for sum in allSum:\\n            absDif = abs(sum - target)\\n            if (absDif < minAbs):\\n                minAbs = absDif\\n        \\n        return minAbs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460025,
                "title": "56-ms-faster-than-98-23-of-java-dfs-memo-solution",
                "content": "Time:  n*(mlogm + m) + 2^(n*m)\\nSpace: n* target\\n\\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        //1. Prepare process\\n        int remain = target;\\n        for (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tArrays.sort(mat[i]); //1) sort each row\\n            \\n            int minValue = mat[i][0];\\n            remain -= minValue; //2) let remain=sum(min value per row)\\n            for (int j = 0; j < mat[i].length; j++) {\\n                mat[i][j] -= minValue; //3) rebase row so that can be used in dfs directly\\n            }\\n        }\\n        \\n        if (remain <= 0) {//stop when target <= sum of the min value in each row\\n            return Math.abs(remain);\\n        }\\n        \\n\\t\\t//2. Cached version DFS\\n        //1) Cache calcuated result to avoid Time Limit Exceeded error\\n\\t\\t//2) Saving space by using remain instead of target\\n        Integer[/*row*/][/*remain*/] memo = new Integer[mat.length][remain + 1];\\n        \\n        return dfs(0, remain, memo, mat);\\n    }\\n    \\n    private int dfs(int row, int remain, Integer[][] memo, int[][] mat) {\\n        if (row >= mat.length || remain <= 0) {\\n            return Math.abs(remain);\\n        }\\n        \\n        if (memo[row][remain] != null) {\\n            return memo[row][remain];\\n        }\\n        \\n        int min = Math.abs(remain);\\n        \\n\\t\\t//Take one item from current row then join with the rest of table\\n        //Start col from 0 means take the 1st column value\\n        for (int col = 0; col < mat[0].length; col++) {\\n            min = Math.min(min, dfs(row + 1, remain - mat[row][col], memo, mat));\\n            \\n\\t\\t\\tif (min == 0) {\\n                return 0; //early return\\n            }\\n            \\n            //skipping duplicate columns based on the already sorted row\\n            if (col > 0 && mat[row][col] == mat[row][col - 1]) {\\n                continue; \\n            }\\n        }\\n        \\n        return memo[row][remain] = min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        //1. Prepare process\\n        int remain = target;\\n        for (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tArrays.sort(mat[i]); //1) sort each row\\n            \\n            int minValue = mat[i][0];\\n            remain -= minValue; //2) let remain=sum(min value per row)\\n            for (int j = 0; j < mat[i].length; j++) {\\n                mat[i][j] -= minValue; //3) rebase row so that can be used in dfs directly\\n            }\\n        }\\n        \\n        if (remain <= 0) {//stop when target <= sum of the min value in each row\\n            return Math.abs(remain);\\n        }\\n        \\n\\t\\t//2. Cached version DFS\\n        //1) Cache calcuated result to avoid Time Limit Exceeded error\\n\\t\\t//2) Saving space by using remain instead of target\\n        Integer[/*row*/][/*remain*/] memo = new Integer[mat.length][remain + 1];\\n        \\n        return dfs(0, remain, memo, mat);\\n    }\\n    \\n    private int dfs(int row, int remain, Integer[][] memo, int[][] mat) {\\n        if (row >= mat.length || remain <= 0) {\\n            return Math.abs(remain);\\n        }\\n        \\n        if (memo[row][remain] != null) {\\n            return memo[row][remain];\\n        }\\n        \\n        int min = Math.abs(remain);\\n        \\n\\t\\t//Take one item from current row then join with the rest of table\\n        //Start col from 0 means take the 1st column value\\n        for (int col = 0; col < mat[0].length; col++) {\\n            min = Math.min(min, dfs(row + 1, remain - mat[row][col], memo, mat));\\n            \\n\\t\\t\\tif (min == 0) {\\n                return 0; //early return\\n            }\\n            \\n            //skipping duplicate columns based on the already sorted row\\n            if (col > 0 && mat[row][col] == mat[row][col - 1]) {\\n                continue; \\n            }\\n        }\\n        \\n        return memo[row][remain] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421239,
                "title": "100-efficient-simple-recursion-memoization",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int recc(vector<vector<int>>& mat, int sum,int n,vector<vector<int>>&m){\\n        if(n==0){\\n            return abs(sum);\\n        }\\n         if(sum<=0){\\n            return INT_MAX;\\n        }\\n        if(m[n][sum]!=-1){\\n            return m[n][sum];\\n        }\\n         int ans=INT_MAX;\\n        for(int i=0;i<mat[n-1].size();i++){\\n            ans=min(ans,recc(mat,sum-mat[n-1][i],n-1,m));\\n        }\\n        return m[n][sum]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int t) {\\n        int maxs=0,mins=0;\\n        for(int i=0;i<mat.size();i++){\\n            int mx=INT_MIN,mn=INT_MAX;\\n            for(int j=0;j<mat[0].size();j++){\\n                mx=max(mx,mat[i][j]);\\n                mn=min(mn,mat[i][j]);\\n            }\\n            maxs+=mx;\\n            mins+=mn;\\n        }\\n        if(t<=mins){\\n            return mins-t;\\n        }\\n        if(t>=maxs){\\n            return t-maxs;\\n        }\\n       vector<vector<int>>m(mat.size()+1,vector<int>(t+1,-1));\\n        return recc(mat,t,mat.size(),m);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int recc(vector<vector<int>>& mat, int sum,int n,vector<vector<int>>&m){\\n        if(n==0){\\n            return abs(sum);\\n        }\\n         if(sum<=0){\\n            return INT_MAX;\\n        }\\n        if(m[n][sum]!=-1){\\n            return m[n][sum];\\n        }\\n         int ans=INT_MAX;\\n        for(int i=0;i<mat[n-1].size();i++){\\n            ans=min(ans,recc(mat,sum-mat[n-1][i],n-1,m));\\n        }\\n        return m[n][sum]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int t) {\\n        int maxs=0,mins=0;\\n        for(int i=0;i<mat.size();i++){\\n            int mx=INT_MIN,mn=INT_MAX;\\n            for(int j=0;j<mat[0].size();j++){\\n                mx=max(mx,mat[i][j]);\\n                mn=min(mn,mat[i][j]);\\n            }\\n            maxs+=mx;\\n            mins+=mn;\\n        }\\n        if(t<=mins){\\n            return mins-t;\\n        }\\n        if(t>=maxs){\\n            return t-maxs;\\n        }\\n       vector<vector<int>>m(mat.size()+1,vector<int>(t+1,-1));\\n        return recc(mat,t,mat.size(),m);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420179,
                "title": "c-0-1-knapsack-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n      int m = mat.size();\\n\\n      int MAX_SUM = 70 * 70;\\n      vector<vector<bool>> dp(m, vector<bool>(MAX_SUM + 1));\\n\\n      for (auto num : mat[0]) {\\n        dp[0][num] = true;\\n      }\\n\\n      for (int i = 0; i < m - 1; i++) {\\n        vector<int>& nextRow = mat[i + 1];\\n        unordered_set<int> s (nextRow.begin(), nextRow.end());\\n        for (int w = 0; w <= MAX_SUM; w++) {\\n          if (dp[i][w]) {\\n            for (auto num : s) {\\n              if (w + num <= MAX_SUM) {\\n                dp[i + 1][w + num] = dp[i][w];\\n              }\\n            }  \\n          }\\n        }\\n      }\\n\\n      int bestDiff = 1e9 + 7;\\n\\n      for (int w = 0; w <= MAX_SUM; w++) {\\n        bool possible = dp[m - 1][w];\\n        if (possible) {\\n          int diff = abs(target - w);\\n          if (diff < bestDiff) {\\n            bestDiff = diff;\\n          }\\n        }\\n      }\\n      return bestDiff;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n      int m = mat.size();\\n\\n      int MAX_SUM = 70 * 70;\\n      vector<vector<bool>> dp(m, vector<bool>(MAX_SUM + 1));\\n\\n      for (auto num : mat[0]) {\\n        dp[0][num] = true;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1419332,
                "title": "c-simple-o-m-n-target-dp-solution",
                "content": "Here is yet another tribute to my idol @lee215\\n\\nIntuition:\\n1. Think of it similar to 0-1 knapsack problem. Here, the difference is that you have to choose one column in every row in this case and you have to choose an element.\\n \\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        vector<int> dp(target + 1);\\n        int m = mat.size(), n = mat[0].size();\\n        \\n\\t\\t// base case: If number of rows is zero, target is your min abs diff.\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = i;\\n        }\\n        \\n        for (int k = 0; k < m; k++) {\\n            for (int i = target; i > 0; i--) {\\n                dp[i] = numeric_limits<int>::max();\\n                for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\t// for every column, if value <= i, min abs diff after choosing value will\\n\\t\\t\\t\\t\\t// be min(min abs diff of last row with target (i - value), min abs diff found\\n\\t\\t\\t\\t\\t// till now), otherwise it will be (value - i) + min abs diff of last row with target 0. \\n\\t\\t\\t\\t\\t// This is done to ensure that the abs diff is minimum. \\n                    dp[i] = min(dp[i], mat[k][j] <= i ? dp[i - mat[k][j]] : (mat[k][j] - i + dp[0]));\\n                }\\n            }\\n\\t\\t\\t// This is handled separately to handle integer overflow for (mat[k][j] - i + dp[0])\\n            dp[0] = dp[1] + 1;\\n        }\\n        \\n        return dp[target];\\n    }\\n};\\n```\\n\\n**Time and Space Complexity:**\\nSimilar to 0-1 knapsack problem (which can be solved in O(n * k) time, O(k) space complexity), This can be solved in **O(m * n * target)** time, **O(k)** space.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        vector<int> dp(target + 1);\\n        int m = mat.size(), n = mat[0].size();\\n        \\n\\t\\t// base case: If number of rows is zero, target is your min abs diff.\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = i;\\n        }\\n        \\n        for (int k = 0; k < m; k++) {\\n            for (int i = target; i > 0; i--) {\\n                dp[i] = numeric_limits<int>::max();\\n                for (int j = 0; j < n; j++) {\\n\\t\\t\\t\\t\\t// for every column, if value <= i, min abs diff after choosing value will\\n\\t\\t\\t\\t\\t// be min(min abs diff of last row with target (i - value), min abs diff found\\n\\t\\t\\t\\t\\t// till now), otherwise it will be (value - i) + min abs diff of last row with target 0. \\n\\t\\t\\t\\t\\t// This is done to ensure that the abs diff is minimum. \\n                    dp[i] = min(dp[i], mat[k][j] <= i ? dp[i - mat[k][j]] : (mat[k][j] - i + dp[0]));\\n                }\\n            }\\n\\t\\t\\t// This is handled separately to handle integer overflow for (mat[k][j] - i + dp[0])\\n            dp[0] = dp[1] + 1;\\n        }\\n        \\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419205,
                "title": "easy-well-commented-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[5001][71];\\n    int mini = INT_MAX;\\n    int find(vector<vector<int>>& mat,int i,int sum,int tar)\\n    {\\n\\t\\tif(dp[sum][i]!=-1)   return dp[sum][i];\\n\\t\\t//Base Case\\n\\t\\t//When we consume all the rows , update the min answer till now.\\n        if(i>=mat.size()){\\n            mini = min(mini,abs(sum-tar));\\n            return dp[sum][i] = abs(sum-tar);\\n        }\\n\\t\\t//For early exit:\\n\\t\\t//if sum has already exceeded target, then going forward, this difference \\n\\t\\t//is always going to increase only ,as all elements are positive and if the current \\n\\t\\t//difference is already greater than mini, then this can\\'t be our potential answer:\\n\\t\\t//So, stop right there:\\n        if(tar<sum && abs(sum-tar)>mini){\\n            return dp[sum][i] = 5000;\\n        }\\n        \\n\\t\\t//Trying out all the combination selecting one element from each row\\n        int ans=INT_MAX;\\n        for(int j=0;j<mat[i].size();j++)\\n        {\\n\\t\\t//since every row is sorted , so if we encounter the same element on a row again , \\n\\t\\t// it will ultimately give the same result as previous one, so it won\\'t be of any use\\n\\t\\t//to us, so we skip it\\n            if(j!=0 && mat[i][j]==mat[i][j-1])  continue;\\n            ans=min(ans,find(mat,i+1,sum+mat[i][j],tar));\\n        }\\n        return dp[sum][i]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//Make the matrix rowwise sorted\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n        return find(mat,0,0,target);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5001][71];\\n    int mini = INT_MAX;\\n    int find(vector<vector<int>>& mat,int i,int sum,int tar)\\n    {\\n\\t\\tif(dp[sum][i]!=-1)   return dp[sum][i];\\n\\t\\t//Base Case\\n\\t\\t//When we consume all the rows , update the min answer till now.\\n        if(i>=mat.size()){\\n            mini = min(mini,abs(sum-tar));\\n            return dp[sum][i] = abs(sum-tar);\\n        }\\n\\t\\t//For early exit:\\n\\t\\t//if sum has already exceeded target, then going forward, this difference \\n\\t\\t//is always going to increase only ,as all elements are positive and if the current \\n\\t\\t//difference is already greater than mini, then this can\\'t be our potential answer:\\n\\t\\t//So, stop right there:\\n        if(tar<sum && abs(sum-tar)>mini){\\n            return dp[sum][i] = 5000;\\n        }\\n        \\n\\t\\t//Trying out all the combination selecting one element from each row\\n        int ans=INT_MAX;\\n        for(int j=0;j<mat[i].size();j++)\\n        {\\n\\t\\t//since every row is sorted , so if we encounter the same element on a row again , \\n\\t\\t// it will ultimately give the same result as previous one, so it won\\'t be of any use\\n\\t\\t//to us, so we skip it\\n            if(j!=0 && mat[i][j]==mat[i][j-1])  continue;\\n            ans=min(ans,find(mat,i+1,sum+mat[i][j],tar));\\n        }\\n        return dp[sum][i]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t//Make the matrix rowwise sorted\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n        return find(mat,0,0,target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418731,
                "title": "dp-70-70-800",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefix[80] = {0};\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        vector<vector<int>> vec(mat.size(),vector<int>(800,INT_MAX));\\n        for(int i = mat.size()-1;i >= 0;i--)\\n        {\\n            int a = INT_MAX;\\n            for(int j = 0;j < mat[0].size();j++)\\n            a = min(a,mat[i][j]);\\n            prefix[i] = prefix[i+1]+a;\\n        }\\n        return abs(solve(mat,target,0,0,vec));\\n    }\\n    int solve(vector<vector<int>>& mat,int target,int index,int sum,vector<vector<int>>& vec)\\n    {\\n        int diff = INT_MAX;\\n        if(index == mat.size())\\n        return target-sum;\\n        if(sum >= target)\\n        return target-sum-prefix[index];\\n        if(vec[index][sum]!=INT_MAX)\\n        return vec[index][sum];\\n        for(int j = 0;j < mat[0].size();j++){\\n            int a = solve(mat,target,index+1,sum+mat[index][j],vec);\\n            if(abs(diff) > abs(a))\\n            diff = a;\\n        }\\n        return vec[index][sum] = diff;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefix[80] = {0};\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        vector<vector<int>> vec(mat.size(),vector<int>(800,INT_MAX));\\n        for(int i = mat.size()-1;i >= 0;i--)\\n        {\\n            int a = INT_MAX;\\n            for(int j = 0;j < mat[0].size();j++)\\n            a = min(a,mat[i][j]);\\n            prefix[i] = prefix[i+1]+a;\\n        }\\n        return abs(solve(mat,target,0,0,vec));\\n    }\\n    int solve(vector<vector<int>>& mat,int target,int index,int sum,vector<vector<int>>& vec)\\n    {\\n        int diff = INT_MAX;\\n        if(index == mat.size())\\n        return target-sum;\\n        if(sum >= target)\\n        return target-sum-prefix[index];\\n        if(vec[index][sum]!=INT_MAX)\\n        return vec[index][sum];\\n        for(int j = 0;j < mat[0].size();j++){\\n            int a = solve(mat,target,index+1,sum+mat[index][j],vec);\\n            if(abs(diff) > abs(a))\\n            diff = a;\\n        }\\n        return vec[index][sum] = diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418709,
                "title": "java-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    boolean[][] dp;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp = new boolean[mat.length][5000];\\n        backTrack(0,mat, target, 0);\\n        return min;\\n    }\\n    \\n    public void backTrack(int row, int[][] mat, int target, int currSum ) {\\n        if(row==mat.length) {\\n            if(Math.abs(target-currSum)<min)\\n                min = Math.abs(target-currSum);\\n            return;\\n        }\\n        \\n        for(int i=0; i<mat[0].length; i++) {\\n            int sumNow = currSum+mat[row][i];\\n            if(dp[row][sumNow])\\n                continue;\\n            dp[row][sumNow] = true;\\n            backTrack(row+1, mat, target, sumNow);\\n        }\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    boolean[][] dp;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp = new boolean[mat.length][5000];\\n        backTrack(0,mat, target, 0);\\n        return min;\\n    }\\n    \\n    public void backTrack(int row, int[][] mat, int target, int currSum ) {\\n        if(row==mat.length) {\\n            if(Math.abs(target-currSum)<min)\\n                min = Math.abs(target-currSum);\\n            return;\\n        }\\n        \\n        for(int i=0; i<mat[0].length; i++) {\\n            int sumNow = currSum+mat[row][i];\\n            if(dp[row][sumNow])\\n                continue;\\n            dp[row][sumNow] = true;\\n            backTrack(row+1, mat, target, sumNow);\\n        }\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1418683,
                "title": "c-straightforward-hash-set-solution",
                "content": "All possible sums are in the range [1, 4900], so we can pre-calculate them.\\nAn optimization is for all sums > 800, only keep the smallest.\\n```C++\\nclass Solution {\\npublic:\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_set<int> s = {};\\n        s.insert(0);\\n        for (int i = 0; i < m; i++) {\\n            unordered_set<int> small = {};\\n            int large = INT_MAX;\\n            for (auto a: s) {\\n                for (auto b : mat[i]) {\\n                    int v = a + b;\\n                    if (v <= target) {\\n                        small.insert(v);\\n                    } else {\\n                        large = min(large, v);\\n                    }\\n                }\\n            }\\n            s = small;\\n            if (large != INT_MAX) {\\n                s.insert(large);\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for (auto a : s) {\\n            res = min(res, abs(target - a));\\n        }\\n        \\n        return res;\\n            \\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_set<int> s = {};\\n        s.insert(0);\\n        for (int i = 0; i < m; i++) {\\n            unordered_set<int> small = {};\\n            int large = INT_MAX;\\n            for (auto a: s) {\\n                for (auto b : mat[i]) {\\n                    int v = a + b;\\n                    if (v <= target) {\\n                        small.insert(v);\\n                    } else {\\n                        large = min(large, v);\\n                    }\\n                }\\n            }\\n            s = small;\\n            if (large != INT_MAX) {\\n                s.insert(large);\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for (auto a : s) {\\n            res = min(res, abs(target - a));\\n        }\\n        \\n        return res;\\n            \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418655,
                "title": "python3-simple-dfs-solution-with-optimizations",
                "content": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH: DFS ##\\n        result = float(\\'inf\\')\\n        cache = set()\\n        def dfs(row, res):\\n            nonlocal result\\n            \\n            if (row, res) in cache:\\n                return\\n\\n            # optimization\\n            if result == 0:\\n                return\\n            \\n            if row == len(mat):\\n                result = min(result, abs(target - res))\\n                return\\n            \\n            for i in range(0, len(mat[row])):\\n                dfs(row + 1, res + mat[row][i])\\n            \\n\\t\\t\\t# optimation\\n            cache.add((row, res))\\n        \\n        for i in range(0, len(mat)):\\n            # optimation\\n            mat[i] = list(set(mat[i]))\\n        \\n        dfs(0, 0)\\n        return result\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH: DFS ##\\n        result = float(\\'inf\\')\\n        cache = set()\\n        def dfs(row, res):\\n            nonlocal result\\n            \\n            if (row, res) in cache:\\n                return\\n\\n            # optimization\\n            if result == 0:\\n                return\\n            \\n            if row == len(mat):\\n                result = min(result, abs(target - res))\\n                return\\n            \\n            for i in range(0, len(mat[row])):\\n                dfs(row + 1, res + mat[row][i])\\n            \\n\\t\\t\\t# optimation\\n            cache.add((row, res))\\n        \\n        for i in range(0, len(mat)):\\n            # optimation\\n            mat[i] = list(set(mat[i]))\\n        \\n        dfs(0, 0)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418613,
                "title": "simple-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[5001][71];\\n    int find(vector<vector<int>>& mat,int n,int sum,int tar)\\n    {\\n        if(n<=0)\\n            return abs(sum-tar);\\n       if(dp[sum][n]!=-1)return dp[sum][n];\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<mat[n-1].size();j++)\\n        {\\n            ans=min(ans,find(mat,n-1,sum+mat[n-1][j],tar));\\n        }\\n        return dp[sum][n]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(mat,mat.size(),0,target);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5001][71];\\n    int find(vector<vector<int>>& mat,int n,int sum,int tar)\\n    {\\n        if(n<=0)\\n            return abs(sum-tar);\\n       if(dp[sum][n]!=-1)return dp[sum][n];\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<mat[n-1].size();j++)\\n        {\\n            ans=min(ans,find(mat,n-1,sum+mat[n-1][j],tar));\\n        }\\n        return dp[sum][n]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(mat,mat.size(),0,target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418611,
                "title": "simple-java-solution-memoization",
                "content": "Well its simple backtracking with memoization. Comments in the code are self explanatory!\\n\\nclass Solution {\\n\\n    int abs;  //global variabls to keep minimum abs value\\n    int[][] dp; // whenever we arrive at a particular row we need to see if we had previously arrived on this row with same sum.\\n    public void recFunc(int[][] a, int sum, int row, int target){\\n        if(row>=a.length){\\n            abs=Math.min(abs, Math.abs(target-sum));\\n            return;\\n        }        \\n        if(dp[row][sum]==1) // we have arrived this row before with the same sum value, and calculated resultant abs min value. \\n            return;\\n        for(int j=0;j<a[0].length;j++){\\n            recFunc(a, sum+a[row][j], row+1, target);\\n            \\n        }\\n        dp[row][sum]=1;  // mark that we arrives at \"row\" with \"sum\", and have calucated resultant min abs value. \\n    }\\n    \\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        abs=Integer.MAX_VALUE;\\n        dp=new int[mat.length][50000];\\n        recFunc(mat, 0, 0, target);\\n        return abs;\\n    }\\n}\\n\\nCheers!",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\n    int abs;  //global variabls to keep minimum abs value\\n    int[][] dp; // whenever we arrive at a particular row we need to see if we had previously arrived on this row with same sum.\\n    public void recFunc(int[][] a, int sum, int row, int target){\\n        if(row>=a.length){\\n            abs=Math.min(abs, Math.abs(target-sum));\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3640091,
                "title": "bit-manipulation-bitset-meet-in-the-middle-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPoints to Notice:-\\n\\nQuestion 1755 - [https://leetcode.com/problems/closest-subsequence-sum/]()\\nQuestion 2035 - [https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/]()\\n\\nIn these two questions, MEET IN THE MIDDLE techniques were used and not Dp because sum could be negative and it is not feasible to represent negative sum in dp indices [Although what if we try shifting the nums vector and try!! Could be tried].\\n\\nSo we used Meet in the middle concept.\\nBut here, we can see the constraints and notice sum, will never be negative and we can apply Dp.\\n\\nWe do not worry if there are multiple ways to reach an index with an particular previous sum, we are not counting number of ways, so we can count it as overlapping subproblem and continue solving using DP.\\n\\nWith Dp, comes an auxillary stack space.\\nSO trying Bitmanipulation technique, which is very interesting using Bitset\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaximum possible sum of the grid is 70*70 i.e. 4900. We still create a bitset of 5000 size.\\n\\nSo bitset<10>bt means $0 0 0 0 0 0 0 0 0 0$ bits and if i do bt[0] will tell be about the 0th bit. \\n\\nSo if at some point bistet<10> bt = 0 0 0 0 0 0 1 1 1 0. So, now bt[2] will give 1.\\n\\nIn our question, our idea is to use bitset to tell which sums are possible.\\nIf sum x is possible we make bit[x] as 1.\\n\\nNow, question is how to find all possible x. We can find is using Recurssion only. Yes but using bit techniques it is also possible.\\n\\nFirst we put the first row in our final bitset. So now we know which sums are possible. \\n\\nFor example if first row is [3,4,8] so not bt[3]==bt[4]==bt[8]==1.\\n\\nNow for every remainning row, we run it on a loop\\nlet\\'s say we are at $i^{th}$ row and the previoud bitset we got is $bt$.\\n\\nWe make two temp bitset such as $prev = bt$ && a new bitset nxt.\\n\\nNow for every element in the $i^{th}$ row , we shift the prev to left by that element.\\n\\nFor example the value is 5. We shift prev bitset by 5 and update the next bitset by keep taking OR with shifted prev.\\n\\nSo if prev == 0 0 0 0 0 0 1 1 1 0 0 1 0 0 1\\nNow it means we have already encountered sum = $0,3,6,7,8$.\\nNow if we get mat[i][j]=5. It means next is 5. So now we add it to all elements of prev and update. Or we can just left shift by 5. \\n\\nprev <<5 becomes = 0 0 0 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 0 0\\n\\nSo it means the encountered sum = $5,8,11,12,13$\\n\\nNow we keep taking OR and in the end of $i^{th}$ row we update the bt with nxt as nxt stored the permutations \\n\\nIn the end, if the $i^{th}$ is 1, it means we have encountered i sum. So we can check.\\n\\n\\n\\nOne of the big reasons we are using this is because the sum is very less and bitset can be used.\\n\\nIf question asked us to find all sum of all subsets in a nums, we can apply same approach in that question too. Insert 0 in bitset and keep taking or with left shifted bitset with that nums[0] onwards. But in these the sum possible becomes $10^9$. So it becomes infeasible.\\nWe can do this in this question.\\n\\n[https://leetcode.com/problems/partition-equal-subset-sum/description/]()\\n\\n \\n\\n# Complexity\\n- Time complexity: Final TC - $O(n)$ + $O(maxSUM)*[1+2*m+m*n]$\\n- Or - $m*n*maxsum$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(max_sum)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>&mat, int target) \\n    {\\n        std::ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n        cout.tie(NULL);\\n       \\n        \\n        int m = mat.size();\\n        int n = mat[0].size(); \\n        bitset<5000>bt; \\n        for(int i =0;i<n;i++) bt[mat[0][i]]=1; // O(n) \\n        for(int i =1;i<m;i++) // O(m) \\n        {\\n            bitset<5000>prev = bt; // O(max_sum) \\n            bitset<5000>nxt; \\n            for(int j =0;j<n;j++) //O(n)\\n            {\\n                nxt = nxt | (prev<<mat[i][j]); // O(max_sum)\\n            }\\n            bt = nxt; // O(max_sum) \\n        }\\n        int ans=INT_MAX; \\n        for(int i =0;i<(5000);i++) // O(max_sum) \\n        {\\n            if(bt[i]) \\n            {\\n                ans=min(ans, abs(i-target)); \\n            }\\n        }\\n        return ans; \\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>&mat, int target) \\n    {\\n        std::ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n        cout.tie(NULL);\\n       \\n        \\n        int m = mat.size();\\n        int n = mat[0].size(); \\n        bitset<5000>bt; \\n        for(int i =0;i<n;i++) bt[mat[0][i]]=1; // O(n) \\n        for(int i =1;i<m;i++) // O(m) \\n        {\\n            bitset<5000>prev = bt; // O(max_sum) \\n            bitset<5000>nxt; \\n            for(int j =0;j<n;j++) //O(n)\\n            {\\n                nxt = nxt | (prev<<mat[i][j]); // O(max_sum)\\n            }\\n            bt = nxt; // O(max_sum) \\n        }\\n        int ans=INT_MAX; \\n        for(int i =0;i<(5000);i++) // O(max_sum) \\n        {\\n            if(bt[i]) \\n            {\\n                ans=min(ans, abs(i-target)); \\n            }\\n        }\\n        return ans; \\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3339367,
                "title": "100-working-solution-in-java-dp-memoization",
                "content": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int t) {\\n        int m= mat.length;\\n        int[][] dp= new int[m][5001];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<5001; j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(mat,dp,0,t,0);\\n    }\\n    \\n    public int solve(int[][] mat, int[][] dp, int ind, int t, int val){\\n        if(ind==mat.length){\\n            return Math.abs(t-val);\\n        }\\n        \\n        if(dp[ind][val]!=-1){\\n            return dp[ind][val];\\n        }\\n        \\n        int min= (int)(1e9);\\n        for(int i=0; i<mat[0].length; i++){\\n            min= Math.min(min, solve(mat,dp,ind+1,t,val+mat[ind][i]));\\n        }\\n        \\n        return dp[ind][val]= min;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int minimizeTheDifference(int[][] mat, int t) {\\n        int m= mat.length;\\n        int[][] dp= new int[m][5001];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<5001; j++){\\n                dp[i][j]=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2516965,
                "title": "cleanest-intuitative-approach",
                "content": "```\\n    int solve(int i, vector<vector<int>>& m, int target, int sum, vector<vector<int>> &dp)\\n    {\\n        if(i == m.size())\\n            return abs(sum-target);\\n        \\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n        \\n        int ans = INT_MAX;\\n        for(int j=0;j<m[0].size();j++)\\n        {\\n            ans = min(ans, solve(i+1, m, target, sum+m[i][j], dp));\\n            if(ans == 0)\\n                return 0;\\n        }\\n        return dp[i][sum] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& m, int target) {\\n        int sum = 0;\\n        for(int i=0;i<m.size();i++)\\n        {\\n            int mx = INT_MIN;\\n            for(int j=0;j<m[0].size();j++)\\n                mx = max(mx, m[i][j]);\\n            sum += mx;\\n        }\\n        vector<vector<int>> dp(m.size(), vector<int>(sum+1, -1));\\n        return solve(0, m, target, 0, dp);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    int solve(int i, vector<vector<int>>& m, int target, int sum, vector<vector<int>> &dp)\\n    {\\n        if(i == m.size())\\n            return abs(sum-target);\\n        \\n        if(dp[i][sum]!=-1)\\n            return dp[i][sum];\\n        \\n        int ans = INT_MAX;\\n        for(int j=0;j<m[0].size();j++)\\n        {\\n            ans = min(ans, solve(i+1, m, target, sum+m[i][j], dp));\\n            if(ans == 0)\\n                return 0;\\n        }\\n        return dp[i][sum] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& m, int target) {\\n        int sum = 0;\\n        for(int i=0;i<m.size();i++)\\n        {\\n            int mx = INT_MIN;\\n            for(int j=0;j<m[0].size();j++)\\n                mx = max(mx, m[i][j]);\\n            sum += mx;\\n        }\\n        vector<vector<int>> dp(m.size(), vector<int>(sum+1, -1));\\n        return solve(0, m, target, 0, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403072,
                "title": "java-recursive-dp",
                "content": "```\\n\\n\\tint ans=Integer.MAX_VALUE;\\n    Integer[][] dp=null;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp=new Integer[mat.length][71*71];\\n        ans=Integer.MAX_VALUE;\\n        dfs(0,mat,target,0);\\n        return ans;\\n    }\\n    void dfs(int row,int mat[][],int t,int sum){\\n        if(row==mat.length){\\n            ans=Math.min(Math.abs(t-sum),ans);\\n            return;\\n        }\\n        if(dp[row][sum]!=null) return;\\n        for(int i=0;i<mat[0].length;i++){\\n            dfs(row+1,mat,t,sum+mat[row][i]);\\n        }\\n        dp[row][sum]=1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\n\\tint ans=Integer.MAX_VALUE;\\n    Integer[][] dp=null;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp=new Integer[mat.length][71*71];\\n        ans=Integer.MAX_VALUE;\\n        dfs(0,mat,target,0);\\n        return ans;\\n    }\\n    void dfs(int row,int mat[][],int t,int sum){\\n        if(row==mat.length){\\n            ans=Math.min(Math.abs(t-sum),ans);\\n            return;\\n        }\\n        if(dp[row][sum]!=null) return;\\n        for(int i=0;i<mat[0].length;i++){\\n            dfs(row+1,mat,t,sum+mat[row][i]);\\n        }\\n        dp[row][sum]=1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345513,
                "title": "85-tc-and-84-sc-easy-python-solution",
                "content": "```\\ndef minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\tm = len(mat)\\n\\tfor i in range(m):\\n\\t\\tmat[i].sort()\\n\\tq = set([0])\\n\\tfor i in range(m):\\n\\t\\ttemp = set()\\n\\t\\tfor num1 in q:\\n\\t\\t\\tfor num2 in mat[i]:\\n\\t\\t\\t\\ttemp.add(num1+num2)\\n\\t\\t\\t\\tif(num1+num2 > target):\\n\\t\\t\\t\\t\\tbreak\\n\\t\\tq = temp\\n\\tq = sorted(list(q))\\n\\ti = bisect_right(q, target)\\n\\tif(i == len(q)):\\n\\t\\treturn target - q[-1]\\n\\tif(i == 0):\\n\\t\\treturn q[0] - target\\n\\treturn min(target-q[i-1], q[i]-target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\tm = len(mat)\\n\\tfor i in range(m):\\n\\t\\tmat[i].sort()\\n\\tq = set([0])\\n\\tfor i in range(m):\\n\\t\\ttemp = set()\\n\\t\\tfor num1 in q:\\n\\t\\t\\tfor num2 in mat[i]:\\n\\t\\t\\t\\ttemp.add(num1+num2)\\n\\t\\t\\t\\tif(num1+num2 > target):\\n\\t\\t\\t\\t\\tbreak\\n\\t\\tq = temp\\n\\tq = sorted(list(q))\\n\\ti = bisect_right(q, target)\\n\\tif(i == len(q)):\\n\\t\\treturn target - q[-1]\\n\\tif(i == 0):\\n\\t\\treturn q[0] - target\\n\\treturn min(target-q[i-1], q[i]-target)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2286035,
                "title": "java-recursive-tle-memoization-accepted-easy",
                "content": "**RECURSIVE(TLE)**\\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n      int min=Integer.MAX_VALUE;  \\n      int n=mat.length;\\n      int m=mat[0].length;\\n    \\n      for(int i=0;i<m;i++){\\n          min=Math.min(min,solve(mat,0,0,i,n,m,target));\\n         // System.out.println(solve(mat,0,0,i,n,m,target));\\n      }  \\n       return min; \\n    }\\n   public int solve(int mat[][],int sum,int i,int j,int n,int m,int target){\\n       if(i==n)\\n           return Math.abs(sum-target);\\n       int ans=Integer.MAX_VALUE;\\n       for(int k=0;k<m;k++)\\n       {\\n           ans=Math.min(ans,solve(mat,sum+mat[i][k],i+1,k,n,m,target));\\n       }\\n         return ans;               \\n   }\\n}\\n```\\n\\n**MEMOIZATION(ACCEPTED)**\\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n      int min=Integer.MAX_VALUE;  \\n      int n=mat.length;\\n      int m=mat[0].length;\\n      int dp[][]=new int[71][71*71];\\n      for(int i[]:dp)\\n          Arrays.fill(i,-1);\\n      for(int i=0;i<m;i++){\\n          min=Math.min(min,solve(mat,0,0,i,n,m,target,dp));\\n         // System.out.println(solve(mat,0,0,i,n,m,target));\\n      }  \\n       return min; \\n    }\\n   public int solve(int mat[][],int sum,int i,int j,int n,int m,int target,int dp[][]){\\n       if(i==n)\\n           return Math.abs(sum-target);\\n       if(dp[i][sum]!=-1)\\n           return dp[i][sum];\\n       int ans=Integer.MAX_VALUE;\\n       for(int k=0;k<m;k++)\\n       {\\n           ans=Math.min(ans,solve(mat,sum+mat[i][k],i+1,k,n,m,target,dp));\\n       }\\n         return dp[i][sum]=ans;               \\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n      int min=Integer.MAX_VALUE;  \\n      int n=mat.length;\\n      int m=mat[0].length;\\n    \\n      for(int i=0;i<m;i++){\\n          min=Math.min(min,solve(mat,0,0,i,n,m,target));\\n         // System.out.println(solve(mat,0,0,i,n,m,target));\\n      }  \\n       return min; \\n    }\\n   public int solve(int mat[][],int sum,int i,int j,int n,int m,int target){\\n       if(i==n)\\n           return Math.abs(sum-target);\\n       int ans=Integer.MAX_VALUE;\\n       for(int k=0;k<m;k++)\\n       {\\n           ans=Math.min(ans,solve(mat,sum+mat[i][k],i+1,k,n,m,target));\\n       }\\n         return ans;               \\n   }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n      int min=Integer.MAX_VALUE;  \\n      int n=mat.length;\\n      int m=mat[0].length;\\n      int dp[][]=new int[71][71*71];\\n      for(int i[]:dp)\\n          Arrays.fill(i,-1);\\n      for(int i=0;i<m;i++){\\n          min=Math.min(min,solve(mat,0,0,i,n,m,target,dp));\\n         // System.out.println(solve(mat,0,0,i,n,m,target));\\n      }  \\n       return min; \\n    }\\n   public int solve(int mat[][],int sum,int i,int j,int n,int m,int target,int dp[][]){\\n       if(i==n)\\n           return Math.abs(sum-target);\\n       if(dp[i][sum]!=-1)\\n           return dp[i][sum];\\n       int ans=Integer.MAX_VALUE;\\n       for(int k=0;k<m;k++)\\n       {\\n           ans=Math.min(ans,solve(mat,sum+mat[i][k],i+1,k,n,m,target,dp));\\n       }\\n         return dp[i][sum]=ans;               \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157009,
                "title": "fully-optimized-dp-top-down-approach",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int ans=INT_MAX;\\n    int helper(int i,int sum,int &n,vector<vector<int>>&dp,vector<vector<int>>&mat,int &target)\\n    {\\n        if(i==n)\\n        {\\n            ans=min(ans,abs(target-sum));\\n            return abs(target-sum);\\n        }\\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        \\n        if(sum-target>ans)return INT_MAX;\\n        \\n        int min_diff=INT_MAX;\\n        \\n        for(int j=0;j<mat[0].size();j++)\\n        {\\n            min_diff=min(min_diff,helper(i+1,sum+mat[i][j],n,dp,mat,target));\\n            if(min_diff==0)return dp[i][sum]=min_diff;\\n        }\\n        return dp[i][sum]=min_diff;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        int n=mat.size();\\n        vector<vector<int>>dp(n,vector<int>(5000,-1));\\n        return helper(0,0,n,dp,mat,target);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int ans=INT_MAX;\\n    int helper(int i,int sum,int &n,vector<vector<int>>&dp,vector<vector<int>>&mat,int &target)\\n    {\\n        if(i==n)\\n        {\\n            ans=min(ans,abs(target-sum));\\n            return abs(target-sum);\\n        }\\n        if(dp[i][sum]!=-1)return dp[i][sum];\\n        \\n        if(sum-target>ans)return INT_MAX;\\n        \\n        int min_diff=INT_MAX;\\n        \\n        for(int j=0;j<mat[0].size();j++)\\n        {\\n            min_diff=min(min_diff,helper(i+1,sum+mat[i][j],n,dp,mat,target));\\n            if(min_diff==0)return dp[i][sum]=min_diff;\\n        }\\n        return dp[i][sum]=min_diff;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        int n=mat.size();\\n        vector<vector<int>>dp(n,vector<int>(5000,-1));\\n        return helper(0,0,n,dp,mat,target);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003050,
                "title": "scala",
                "content": "```\\nimport scala.util.chaining.scalaUtilChainingOps\\n\\nobject Solution {\\n  def minimizeTheDifference(mat: Array[Array[Int]], target: Int): Int = mat\\n    .foldLeft(Set(0), Option.empty[Int]) {\\n      case lessThanTarget -> noLessThanTarget -> row => lessThanTarget\\n        .iterator\\n        .concat(noLessThanTarget)\\n        .flatMap(sum => row.iterator.map(sum + _))\\n        .partition(_ < target)\\n        .pipe { case lessThanTarget -> noLessThanTarget => lessThanTarget.toSet -> noLessThanTarget.minOption }\\n    }\\n    .pipe {\\n      case lessThanTarget -> noLessThanTarget => lessThanTarget\\n        .iterator\\n        .concat(noLessThanTarget)\\n        .map(_ - target)\\n        .map(math.abs)\\n        .min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.util.chaining.scalaUtilChainingOps\\n\\nobject Solution {\\n  def minimizeTheDifference(mat: Array[Array[Int]], target: Int): Int = mat\\n    .foldLeft(Set(0), Option.empty[Int]) {\\n      case lessThanTarget -> noLessThanTarget -> row => lessThanTarget\\n        .iterator\\n        .concat(noLessThanTarget)\\n        .flatMap(sum => row.iterator.map(sum + _))\\n        .partition(_ < target)\\n        .pipe { case lessThanTarget -> noLessThanTarget => lessThanTarget.toSet -> noLessThanTarget.minOption }\\n    }\\n    .pipe {\\n      case lessThanTarget -> noLessThanTarget => lessThanTarget\\n        .iterator\\n        .concat(noLessThanTarget)\\n        .map(_ - target)\\n        .map(math.abs)\\n        .min\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1981740,
                "title": "javascript-solution-top-down-dp-approach",
                "content": "```\\nvar minimizeTheDifference = function(mat, target) {\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    \\n    const m = mat.length;\\n    const n = mat[0].length;\\n    \\n    const memo = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        memo[i] = new Array(4901).fill(MAX);\\n    }\\n    \\n    return topDown(0, 0);\\n    \\n    function topDown(row, sum) {\\n        if (row === m) return Math.abs(target - sum);\\n        if (memo[row][sum] != MAX) return memo[row][sum];\\n        \\n        let min = MAX;\\n        \\n        mat[row].sort((a, b) => a - b); \\n        \\n        const set = new Set(mat[row]);\\n       \\n        for (const num of set) {\\n           const res = topDown(row + 1, sum + num);\\n            \\n           if (res > min) break;\\n           min = res;\\n        }\\n        \\n        memo[row][sum] = min;\\n        \\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minimizeTheDifference = function(mat, target) {\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    \\n    const m = mat.length;\\n    const n = mat[0].length;\\n    \\n    const memo = [];\\n    \\n    for (let i = 0; i < m; ++i) {\\n        memo[i] = new Array(4901).fill(MAX);\\n    }\\n    \\n    return topDown(0, 0);\\n    \\n    function topDown(row, sum) {\\n        if (row === m) return Math.abs(target - sum);\\n        if (memo[row][sum] != MAX) return memo[row][sum];\\n        \\n        let min = MAX;\\n        \\n        mat[row].sort((a, b) => a - b); \\n        \\n        const set = new Set(mat[row]);\\n       \\n        for (const num of set) {\\n           const res = topDown(row + 1, sum + num);\\n            \\n           if (res > min) break;\\n           min = res;\\n        }\\n        \\n        memo[row][sum] = min;\\n        \\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969538,
                "title": "java-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int[][] dp;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int n = mat.length , m = mat[0].length;\\n        \\n        dp = new int[n][5000];\\n        for(int i = 0 ; i< n ; i++){\\n            for(int j = 0 ; j < 5000 ; j++){\\n                dp[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        return solve(mat , 0 , 0 , target , n , m);\\n    }\\n    \\n    int solve(int[][] arr , int i , int curr , int target , int n , int m){\\n        if(i == n){\\n            return Math.abs(target - curr);\\n        }\\n        \\n        if(dp[i][curr] != Integer.MAX_VALUE) return dp[i][curr];\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int k = 0 ; k < m ; k++){\\n            min = Math.min(min , solve(arr , i+1 ,curr + arr[i][k] , target , n , m));    \\n        }\\n        \\n        return dp[i][curr] = min;\\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int[][] dp;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int n = mat.length , m = mat[0].length;\\n        \\n        dp = new int[n][5000];\\n        for(int i = 0 ; i< n ; i++){\\n            for(int j = 0 ; j < 5000 ; j++){\\n                dp[i][j] = Integer.MAX_VALUE;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1886678,
                "title": "python-faster-than-93-96-little-explanation",
                "content": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\t\\t# initialise set of attainable numbers using the first row\\n        arr = set(mat[0])\\n        \\n\\t\\t# from the second row onwards\\n\\t\\t# we add every number in arr with every number in the row\\n        for row in mat[1:]:\\n            arr1 = set()\\n            for num1 in row:\\n                for num2 in arr:\\n                    arr1.add(num1 + num2)\\n            \\n\\t\\t\\t# if there are 1 or more number bigger than target, we only need to keep the smallest one\\n\\t\\t\\t# because the larger numbers are considered further from target, and will only get even further as we move towards the bottom\\n            minMax = float(\\'inf\\')\\n            for num in arr1:\\n                if num > target:\\n                    minMax = min(minMax, num)\\n            arr = set()\\n            for num in arr1:\\n                if num <= minMax:\\n                    arr.add(num)\\n\\t\\t\\n\\t\\t# find the smallest distance between each number in the attainable array and the target\\n        distance = float(\\'inf\\')\\n        for num in arr:\\n            if abs(target - num) < distance:\\n                distance = abs(target - num)\\n        \\n        return distance\\n```\\nRuntime: 2392 ms (faster than 93.96%)\\nMemory: 14.3 MB (less than 85.71%)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\t\\t# initialise set of attainable numbers using the first row\\n        arr = set(mat[0])\\n        \\n\\t\\t# from the second row onwards\\n\\t\\t# we add every number in arr with every number in the row\\n        for row in mat[1:]:\\n            arr1 = set()\\n            for num1 in row:\\n                for num2 in arr:\\n                    arr1.add(num1 + num2)\\n            \\n\\t\\t\\t# if there are 1 or more number bigger than target, we only need to keep the smallest one\\n\\t\\t\\t# because the larger numbers are considered further from target, and will only get even further as we move towards the bottom\\n            minMax = float(\\'inf\\')\\n            for num in arr1:\\n                if num > target:\\n                    minMax = min(minMax, num)\\n            arr = set()\\n            for num in arr1:\\n                if num <= minMax:\\n                    arr.add(num)\\n\\t\\t\\n\\t\\t# find the smallest distance between each number in the attainable array and the target\\n        distance = float(\\'inf\\')\\n        for num in arr:\\n            if abs(target - num) < distance:\\n                distance = abs(target - num)\\n        \\n        return distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597930,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        bool v[801][2] = {0};\\n        v[0][0] = 1;\\n        int mt = 1000000;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            mt = mt + (*min_element(mat[i].begin(),mat[i].end()));\\n            for(int k=0; k<=target; k++)\\n            {\\n                if (v[k][0])\\n                {\\n                    for(int j=0; j<m; j++)\\n                    {\\n                        if (mat[i][j] + k <= target)\\n                            v[mat[i][j] + k][1] = true;\\n                        else\\n                            mt = min(mt, mat[i][j] + k);\\n                    }\\n                }\\n            }\\n            for(int i=0; i<=target; i++) \\n            {\\n                v[i][0] = v[i][1];\\n                v[i][1] = false;\\n            }\\n        }\\n        int ans = mt - target; \\n        for(int i=0; i<=target; i++)  \\n        {\\n            if (v[i][0])\\n                ans = min(ans, target-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        bool v[801][2] = {0};\\n        v[0][0] = 1;\\n        int mt = 1000000;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            mt = mt + (*min_element(mat[i].begin(),mat[i].end()));\\n            for(int k=0; k<=target; k++)\\n            {\\n                if (v[k][0])\\n                {\\n                    for(int j=0; j<m; j++)\\n                    {\\n                        if (mat[i][j] + k <= target)\\n                            v[mat[i][j] + k][1] = true;\\n                        else\\n                            mt = min(mt, mat[i][j] + k);\\n                    }\\n                }\\n            }\\n            for(int i=0; i<=target; i++) \\n            {\\n                v[i][0] = v[i][1];\\n                v[i][1] = false;\\n            }\\n        }\\n        int ans = mt - target; \\n        for(int i=0; i<=target; i++)  \\n        {\\n            if (v[i][0])\\n                ans = min(ans, target-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538331,
                "title": "c-solution-using-dp",
                "content": "```\\n  int dp[5001][71];\\n    int minimizeTheDifference(vector<vector<int>>& mat,int target) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=mat.size();\\n        return findmat(mat,0,0,target);\\n    }\\n    int findmat(vector<vector<int>>&mat,int i,int sum,int &target){\\n        if(i>=mat.size()){\\n            return abs(sum-target);\\n        }\\n        if(dp[sum][i]!=-1){\\n            return dp[sum][i];\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0;j<mat[i].size();j++){\\n            ans=min(ans,findmat(mat,i+1,sum+mat[i][j],target));\\n        }\\n        return dp[sum][i]=ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n  int dp[5001][71];\\n    int minimizeTheDifference(vector<vector<int>>& mat,int target) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=mat.size();\\n        return findmat(mat,0,0,target);\\n    }\\n    int findmat(vector<vector<int>>&mat,int i,int sum,int &target){\\n        if(i>=mat.size()){\\n            return abs(sum-target);\\n        }\\n        if(dp[sum][i]!=-1){\\n            return dp[sum][i];\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0;j<mat[i].size();j++){\\n            ans=min(ans,findmat(mat,i+1,sum+mat[i][j],target));\\n        }\\n        return dp[sum][i]=ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1531544,
                "title": "c-top-down-with-pruning-dp-memoization",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[5000][71]; \\n    int n, m, target; \\n    vector<vector<int>> mat;\\n    int res = INT_MAX; \\n    int memo(int row, int currSum){\\n        if(row == n){\\n            res = min(res , abs(currSum-target)); \\n            return abs(currSum-target); \\n        }\\n        if(dp[currSum][row] != -1) return dp[currSum][row] ; \\n        if((currSum-target) > res) return 1e9; \\n        \\n        int res = INT_MAX; \\n        for(int j=0; j<m; j++){\\n            res = min(res, memo(row+1, currSum+mat[row][j])); \\n        }\\n        \\n        return dp[currSum][row] = res ; \\n        \\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        n = mat.size(), m = mat[0].size(); \\n        this->target = target; \\n        this->mat = mat; \\n        memset(dp, -1,sizeof(dp));\\n        memo(0, 0);\\n        return  res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5000][71]; \\n    int n, m, target; \\n    vector<vector<int>> mat;\\n    int res = INT_MAX; \\n    int memo(int row, int currSum){\\n        if(row == n){\\n            res = min(res , abs(currSum-target)); \\n            return abs(currSum-target); \\n        }\\n        if(dp[currSum][row] != -1) return dp[currSum][row] ; \\n        if((currSum-target) > res) return 1e9; \\n        \\n        int res = INT_MAX; \\n        for(int j=0; j<m; j++){\\n            res = min(res, memo(row+1, currSum+mat[row][j])); \\n        }\\n        \\n        return dp[currSum][row] = res ; \\n        \\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        n = mat.size(), m = mat[0].size(); \\n        this->target = target; \\n        this->mat = mat; \\n        memset(dp, -1,sizeof(dp));\\n        memo(0, 0);\\n        return  res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442241,
                "title": "python-dp-solution-with-prunning-beats-80",
                "content": "At each row, dp[i] is a list of unique sums we can obtain considering rows up to and including i.\\n`dp[i] = set(d+el for el in row for d in dp[i-1])`\\n\\nNotice the following: for each element `el` of row, if we `d+el >= target` for some `d` in `dp[i-1]` , there is no need to consider values of `dp[i-1]` that are greater than `d`. This is because all elements of `mat` are positive, and including solutions that are larger than `target` at row `i` can only increase the absolute difference when including subsequent rows. In this case, `d+el` could still be part of the optiomal solution, so we include it.\\n\\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        diff = [0]\\n\\n        for row in mat:\\n            new_diff = set()\\n            for el in row:\\n                for d in diff:\\n                    new_diff.add(d+el)\\n                    if d+el >= target:\\n                        break\\n            diff = list(new_diff)\\n            diff.sort()\\n        \\n        ret = None\\n        for d in diff:\\n            abs_diff = abs(target-d)\\n            if ret is None:\\n                ret = abs_diff\\n            ret = min(ret, abs_diff)\\n        \\n        return ret  \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        diff = [0]\\n\\n        for row in mat:\\n            new_diff = set()\\n            for el in row:\\n                for d in diff:\\n                    new_diff.add(d+el)\\n                    if d+el >= target:\\n                        break\\n            diff = list(new_diff)\\n            diff.sort()\\n        \\n        ret = None\\n        for d in diff:\\n            abs_diff = abs(target-d)\\n            if ret is None:\\n                ret = abs_diff\\n            ret = min(ret, abs_diff)\\n        \\n        return ret  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439348,
                "title": "two-solutions-iterative-dp-and-dfs-with-memo",
                "content": "For iterative dp, at each row we update all possible sum of values we can get. \\nFor example, if we at row r, we want to see what sum of values we have at row r-1,\\nand we can append mat numbers at row r to sum of values end at row r - 1 to form new\\nsum of values\\n\\ndp[i] means if value i can be formed at current row\\n```class Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int maxVal = 70 * mat.length;\\n        boolean[] dp = new boolean[maxVal + 1];\\n        dp[0] = true;\\n        for (int r = 0; r < mat.length; r++) {\\n            boolean[] dp2 = new boolean[maxVal + 1];\\n            for (int c = 0; c < mat[0].length; c++) {\\n                for (int val = mat[r][c]; val <= maxVal; val ++) {\\n                    dp2[val] = dp2[val] || dp[val - mat[r][c]];\\n                }\\n            }\\n            dp = dp2;\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int val = 0; val <= maxVal; val++) {\\n            if (dp[val]) {\\n                res = Math.min(res, Math.abs(target - val));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\nSecond method is DFS with memo. Hight level idea of memo is always find and model depulication.\\nDeplicate here is: at a sepcific row, we have a same accumulative sum via different dfs path. So this \\ndifferent dfs path lead to a same condition. \\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int[][] memo = new int[mat.length][4901];\\n        for (int[] arr : memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return dfs(mat, 0, 0, target, memo);\\n    }\\n    \\n    private int dfs(int[][] mat, int index, int val, int target, int[][] memo) {\\n        if (index == mat.length) {\\n            return Math.abs(val - target);\\n        }\\n        if (memo[index][val] != -1) {\\n            return memo[index][val];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int c = 0; c < mat[0].length; c++) {\\n            res = Math.min(res, dfs(mat,index + 1, val + mat[index][c], target, memo));\\n        }\\n        memo[index][val] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int maxVal = 70 * mat.length;\\n        boolean[] dp = new boolean[maxVal + 1];\\n        dp[0] = true;\\n        for (int r = 0; r < mat.length; r++) {\\n            boolean[] dp2 = new boolean[maxVal + 1];\\n            for (int c = 0; c < mat[0].length; c++) {\\n                for (int val = mat[r][c]; val <= maxVal; val ++) {\\n                    dp2[val] = dp2[val] || dp[val - mat[r][c]];\\n                }\\n            }\\n            dp = dp2;\\n        }\\n        \\n        int res = Integer.MAX_VALUE;\\n        for (int val = 0; val <= maxVal; val++) {\\n            if (dp[val]) {\\n                res = Math.min(res, Math.abs(target - val));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int[][] memo = new int[mat.length][4901];\\n        for (int[] arr : memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return dfs(mat, 0, 0, target, memo);\\n    }\\n    \\n    private int dfs(int[][] mat, int index, int val, int target, int[][] memo) {\\n        if (index == mat.length) {\\n            return Math.abs(val - target);\\n        }\\n        if (memo[index][val] != -1) {\\n            return memo[index][val];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int c = 0; c < mat[0].length; c++) {\\n            res = Math.min(res, dfs(mat,index + 1, val + mat[index][c], target, memo));\\n        }\\n        memo[index][val] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427925,
                "title": "my-java-solution-using-memoization",
                "content": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        if (mat == null || mat.length == 0 || target < 0)\\n            return -1;\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        // 70 * 70\\n        // [index][available sum]\\n        Integer [][] memo = new Integer [row][70 * 70 + 1];\\n        return minimumPossible(mat, target, 0, 0, memo);\\n    }\\n    \\n    public int minimumPossible(int [][] mat, int target, int currentRowIndex, int currentSum, Integer [][] memo) {\\n        if (currentRowIndex == mat.length) {\\n            return Math.abs(currentSum - target);\\n        }\\n        if (memo[currentRowIndex][currentSum] != null) {\\n            return memo[currentRowIndex][currentSum];\\n        } \\n        int eachRowResult = Integer.MAX_VALUE;\\n        for (int colIndex = 0; colIndex < mat[0].length; colIndex++) {\\n            eachRowResult = Math.min(eachRowResult, minimumPossible(mat, target, currentRowIndex + 1, currentSum + mat[currentRowIndex][colIndex], memo));\\n        }\\n        return memo[currentRowIndex][currentSum] = eachRowResult;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        if (mat == null || mat.length == 0 || target < 0)\\n            return -1;\\n        int row = mat.length;\\n        int col = mat[0].length;\\n        // 70 * 70\\n        // [index][available sum]\\n        Integer [][] memo = new Integer [row][70 * 70 + 1];\\n        return minimumPossible(mat, target, 0, 0, memo);\\n    }\\n    \\n    public int minimumPossible(int [][] mat, int target, int currentRowIndex, int currentSum, Integer [][] memo) {\\n        if (currentRowIndex == mat.length) {\\n            return Math.abs(currentSum - target);\\n        }\\n        if (memo[currentRowIndex][currentSum] != null) {\\n            return memo[currentRowIndex][currentSum];\\n        } \\n        int eachRowResult = Integer.MAX_VALUE;\\n        for (int colIndex = 0; colIndex < mat[0].length; colIndex++) {\\n            eachRowResult = Math.min(eachRowResult, minimumPossible(mat, target, currentRowIndex + 1, currentSum + mat[currentRowIndex][colIndex], memo));\\n        }\\n        return memo[currentRowIndex][currentSum] = eachRowResult;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424224,
                "title": "c-1981-minimize-the-difference-between-target-and-chosen-elements",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<5000> bits(1); \\n        for (auto& row : mat) {\\n            bitset<5000> temp; \\n            for (auto& x : row) temp |= (bits << x); \\n            bits = temp; \\n        }\\n        \\n        for (int x = 0; ; ++x) \\n            if (bits[target+x] || (x <= target && bits[target-x])) return x; \\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<5000> bits(1); \\n        for (auto& row : mat) {\\n            bitset<5000> temp; \\n            for (auto& x : row) temp |= (bits << x); \\n            bits = temp; \\n        }\\n        \\n        for (int x = 0; ; ++x) \\n            if (bits[target+x] || (x <= target && bits[target-x])) return x; \\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420801,
                "title": "c-dp-memoization",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /*\\n    Over here we are given that the size of the input array won\\'t exceed 70. We want to get the sum using each posiible combination. But we won\\'t calculate the sum that is already compyed for a give row. \\n    */\\n    //this is how we initialize an array in a range with some specified value.\\n    //Also we like to take a buffer size with one extra space.\\n    int cache[71][70*70 + 1] = {[0 ... 70][0 ... 70*70] = -1};\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        //In order to optimize our computation we can store the matrix in a set. That way we won\\'t have to deal with the duplicate entries. \\n        vector<set<int>> matrix;\\n        for(auto &row : mat)\\n        {\\n            matrix.push_back(set<int>(row.begin(), row.end()));\\n        }\\n        \\n        return findMinSum(matrix, 0, 0, target);\\n    }\\n    \\n    int findMinSum(vector<set<int>>& mat, int row, int sum, int target)\\n    {\\n        if(row >= mat.size())\\n        {\\n            return abs(target-sum);\\n        }\\n        \\n        if(cache[row][sum] != -1)\\n            return cache[row][sum];\\n        \\n        int ans  = INT_MAX;\\n        //We need to iterate over each row and since row is a set, we need an iterator.\\n        for(auto it = mat[row].begin(); it!=mat[row].end(); it++)\\n        {\\n            ans = min(ans, findMinSum(mat, row+1, sum + *it, target));\\n            \\n            //we can further optimize out algorithm here with this check.\\n            //\\n            if(cache[row][sum] == 0 || sum + *it > target)\\n                break;\\n        }\\n        \\n        return cache[row][sum] = ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /*\\n    Over here we are given that the size of the input array won\\'t exceed 70. We want to get the sum using each posiible combination. But we won\\'t calculate the sum that is already compyed for a give row. \\n    */\\n    //this is how we initialize an array in a range with some specified value.\\n    //Also we like to take a buffer size with one extra space.\\n    int cache[71][70*70 + 1] = {[0 ... 70][0 ... 70*70] = -1};\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        //In order to optimize our computation we can store the matrix in a set. That way we won\\'t have to deal with the duplicate entries. \\n        vector<set<int>> matrix;\\n        for(auto &row : mat)\\n        {\\n            matrix.push_back(set<int>(row.begin(), row.end()));\\n        }\\n        \\n        return findMinSum(matrix, 0, 0, target);\\n    }\\n    \\n    int findMinSum(vector<set<int>>& mat, int row, int sum, int target)\\n    {\\n        if(row >= mat.size())\\n        {\\n            return abs(target-sum);\\n        }\\n        \\n        if(cache[row][sum] != -1)\\n            return cache[row][sum];\\n        \\n        int ans  = INT_MAX;\\n        //We need to iterate over each row and since row is a set, we need an iterator.\\n        for(auto it = mat[row].begin(); it!=mat[row].end(); it++)\\n        {\\n            ans = min(ans, findMinSum(mat, row+1, sum + *it, target));\\n            \\n            //we can further optimize out algorithm here with this check.\\n            //\\n            if(cache[row][sum] == 0 || sum + *it > target)\\n                break;\\n        }\\n        \\n        return cache[row][sum] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420220,
                "title": "c-bitset-with-explanations-76ms-faster-than-100",
                "content": "Bitset could be a good choic to this question:\\n1. the sums are in a relative small range (<5000);\\n2. use the index of the bitset to represent the possible sum;\\n3. use the bit shift operation to greatly reduce the time complexity. Only one shift operation can be equivalent to add a number to all the sums stored in the bitset.\\n\\nMore explanations can be found [https://algorithm-notes-allinone.blogspot.com/2021/08/leetcode-1981-minimize-difference.html](http://),\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size(), n = mat.front().size(), cs = 5000, res = cs;\\n        bitset<5000> bt;\\n        for(int i=0; i<n; ++i) bt[mat[0][i]] = 1;\\n        for(int i=1; i<m; ++i) {\\n            bitset<5000> pre = bt, nxt;\\n            for(int j=0; j<n; ++j) {\\n                nxt |= pre << mat[i][j];\\n            }\\n            bt = nxt;\\n        }\\n        for(int i=0; i<cs; ++i) {\\n            if(bt[i]) res = min(res, abs(i-target));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size(), n = mat.front().size(), cs = 5000, res = cs;\\n        bitset<5000> bt;\\n        for(int i=0; i<n; ++i) bt[mat[0][i]] = 1;\\n        for(int i=1; i<m; ++i) {\\n            bitset<5000> pre = bt, nxt;\\n            for(int j=0; j<n; ++j) {\\n                nxt |= pre << mat[i][j];\\n            }\\n            bt = nxt;\\n        }\\n        for(int i=0; i<cs; ++i) {\\n            if(bt[i]) res = min(res, abs(i-target));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419679,
                "title": "python-optimized-brute-force-in-o-target-n-n-time-and-o-target-space-explained",
                "content": "If you try to solve this with Brute-force, the run time would be O(n^n), and you would always get TLE.\\n\\nMy optimization is still to add the nums row by row, however, use a set call \"to_visit\" to track the \"valid\" numbers that can be brought to the next row. The valid number will be **all nums smaller than the target** plus **the smallest number that is larger than the target.** The logic is as follows:\\n\\n1. Every smaller number in the to_visit set plus the numbers in the next row may be closer to your target.\\n2. The smallest larger number could be the only candidate that will be close to the target after the operation with the next row.\\n\\nUsing the example \\n\\n[[1,2,3],[4,5,6],[7,8,9]]\\n13\\n\\nwhat you get each time in to_visit will be\\n{1, 2, 3}\\n{5, 6, 7, 8, 9}\\n{12, 13, 14} (you can get 15,16,17,18, but they are not the smallest larger num, so you can disgard them, we only keep 14 here)\\n\\nOnce you finsh iteration through the matrix, you can find the closest value in the last to_visit set with time of O(target), in the worst case.\\n\\nI guess...Overall time complexity O(target * n * n) ), \\nas the worst case scenario what you need to add to the to_vist would be target * n numbers, and you may need to repeat it for n times.\\n\\nOverall space complexity O(target), \\nas you only need to maintain the to_visit set, which has worst case size of the target + 1\\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        to_visit = {0}\\n        for row in mat:\\n            larger_val = math.inf\\n            temp = to_visit.copy()\\n            to_visit = set()\\n            for num in set(row):    \\n                for item in temp:\\n                    if num + item <= target:\\n                        to_visit.add(num + item)\\n                    else:\\n                        larger_val = min(larger_val, num + item)\\n            if larger_val != math.inf:\\n                to_visit.add(larger_val)\\n            ans = math.inf\\n        for i in to_visit:\\n            ans = min(abs(target - i),ans)\\n        return ans\\n    \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        to_visit = {0}\\n        for row in mat:\\n            larger_val = math.inf\\n            temp = to_visit.copy()\\n            to_visit = set()\\n            for num in set(row):    \\n                for item in temp:\\n                    if num + item <= target:\\n                        to_visit.add(num + item)\\n                    else:\\n                        larger_val = min(larger_val, num + item)\\n            if larger_val != math.inf:\\n                to_visit.add(larger_val)\\n            ans = math.inf\\n        for i in to_visit:\\n            ans = min(abs(target - i),ans)\\n        return ans\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419228,
                "title": "c-dp-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        int m=mat.size(),n=mat[0].size();\\n        int dp[m][target+2];\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<=target;j++)\\n                dp[i][j]=-1;\\n        for(int i=0;i<m;i++)dp[i][target+1]=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mat[0][i]<=target)dp[0][mat[0][i]]=mat[0][i];\\n            else dp[0][target+1]=min(dp[0][target+1],mat[0][i]);      \\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                for(int k=0;k<=target+1;k++)\\n                {\\n                    if(dp[i-1][k]==-1||dp[i-1][k]==INT_MAX)continue;\\n                    if(k+mat[i][j]>target)\\n                    {\\n                        if(k<=target)dp[i][target+1]=min(dp[i][target+1],k+mat[i][j]);\\n                        else dp[i][target+1]=min(dp[i][target+1],dp[i-1][k]+mat[i][j]);\\n                    }else dp[i][k+mat[i][j]]=k+mat[i][j];\\n                }\\n        int ans=INT_MAX;\\n        for(int i=0;i<=target+1;i++)\\n            if(dp[m-1][i]!=-1)ans=min(ans,abs(target-dp[m-1][i]));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        int m=mat.size(),n=mat[0].size();\\n        int dp[m][target+2];\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<=target;j++)\\n                dp[i][j]=-1;\\n        for(int i=0;i<m;i++)dp[i][target+1]=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mat[0][i]<=target)dp[0][mat[0][i]]=mat[0][i];\\n            else dp[0][target+1]=min(dp[0][target+1],mat[0][i]);      \\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                for(int k=0;k<=target+1;k++)\\n                {\\n                    if(dp[i-1][k]==-1||dp[i-1][k]==INT_MAX)continue;\\n                    if(k+mat[i][j]>target)\\n                    {\\n                        if(k<=target)dp[i][target+1]=min(dp[i][target+1],k+mat[i][j]);\\n                        else dp[i][target+1]=min(dp[i][target+1],dp[i-1][k]+mat[i][j]);\\n                    }else dp[i][k+mat[i][j]]=k+mat[i][j];\\n                }\\n        int ans=INT_MAX;\\n        for(int i=0;i<=target+1;i++)\\n            if(dp[m-1][i]!=-1)ans=min(ans,abs(target-dp[m-1][i]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419153,
                "title": "c-dp-solution-with-explanation",
                "content": "* Actually, we need to find a range of sum on which we can apply DP.\\n* So find the sum of smallest element(let say s) from each row. If this sum is greater than or equal to the target`(s>=target)`, then no other better solution exists and `abs(target-s)` will be our answer.\\n\\tFor eg. Let the sum we got from smaller elements is 450 and target is 400. All the other sum in the matrix will be greater than 450 and hence the absolute difference will increase.\\n* If s < target, then we have to find a range on which we can apply DP. The `lower bound of this range will definitely be s`. `The upper bound will be target + abs(target-s)`. Above this, we will not be getting a better answer.\\n* So the last step is to run a loop on this range and we will find that the particular sum exist or not in the matrix using DP.\\n\\n```\\nclass Solution {\\n    int dp[71][3001];\\n\\t// DP to find a particular sum exist or not \\n    bool helper(int sum,int m,int n,vector<vector<int>>& mat){\\n        if(m==0 && sum==0){\\n            return true;\\n        }\\n        if(m==0 || sum<0){\\n            return false;\\n        }\\n        if(dp[m][sum]!=-1){\\n            return dp[m][sum];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mat[m-1][i]>sum) continue;\\n            bool check = helper(sum-mat[m-1][i],m-1,n,mat);\\n            if(check){\\n                return dp[m][sum]=true;    \\n            } \\n        }\\n        return dp[m][sum]=false;\\n    }\\n\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof dp);\\n        int ans=INT_MAX;\\n        int s=0,m =mat.size(),n=mat[0].size();\\n\\t\\t// Finding sum of smallest element from each row\\n        for(int i =0;i<m;i++){\\n            int y=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                y=min(y,mat[i][j]);\\n            }\\n            s+=y;\\n        }\\n        if(s>=target){\\n            return abs(s-target);\\n        }\\n        int x = abs(s-target); // Upper limit\\n\\t\\t// Running loop over the range\\n        for(int i=s;i<target+x;i++){\\n            if(helper(i,m,n,mat)){\\n                ans=min(ans,abs(target-i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Hit Upvote if you like :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dp[71][3001];\\n\\t// DP to find a particular sum exist or not \\n    bool helper(int sum,int m,int n,vector<vector<int>>& mat){\\n        if(m==0 && sum==0){\\n            return true;\\n        }\\n        if(m==0 || sum<0){\\n            return false;\\n        }\\n        if(dp[m][sum]!=-1){\\n            return dp[m][sum];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mat[m-1][i]>sum) continue;\\n            bool check = helper(sum-mat[m-1][i],m-1,n,mat);\\n            if(check){\\n                return dp[m][sum]=true;    \\n            } \\n        }\\n        return dp[m][sum]=false;\\n    }\\n\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof dp);\\n        int ans=INT_MAX;\\n        int s=0,m =mat.size(),n=mat[0].size();\\n\\t\\t// Finding sum of smallest element from each row\\n        for(int i =0;i<m;i++){\\n            int y=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                y=min(y,mat[i][j]);\\n            }\\n            s+=y;\\n        }\\n        if(s>=target){\\n            return abs(s-target);\\n        }\\n        int x = abs(s-target); // Upper limit\\n\\t\\t// Running loop over the range\\n        for(int i=s;i<target+x;i++){\\n            if(helper(i,m,n,mat)){\\n                ans=min(ans,abs(target-i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419056,
                "title": "java-use-hashset-at-every-row-to-find-every-possible-value",
                "content": "```\\n\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        HashSet<Integer>set=new HashSet();\\n        int m=mat.length, n=mat[0].length;\\n        \\n        // get every value in the row\\n        for(int j=0; j<n; j++){\\n            set.add(mat[0][j]);\\n        }\\n        \\n        for(int i=1; i<m; i++){\\n            HashSet<Integer>newSet=new HashSet();\\n            HashSet<Integer>row=new HashSet();\\n            \\n            // get every value in the row\\n            for(int j=0; j<n; j++){\\n                row.add(mat[i][j]);\\n            }\\n            \\n            for(int k: set){\\n                for(int r: row){\\n                    // get every value so far \\n                    newSet.add(r+k);\\n                }\\n            }\\n            set=new HashSet(newSet);\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n                \\n        for(int i: set){\\n            min=Math.min(min, Math.abs(target-i));\\n        }\\n        \\n        return min;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        HashSet<Integer>set=new HashSet();\\n        int m=mat.length, n=mat[0].length;\\n        \\n        // get every value in the row\\n        for(int j=0; j<n; j++){\\n            set.add(mat[0][j]);\\n        }\\n        \\n        for(int i=1; i<m; i++){\\n            HashSet<Integer>newSet=new HashSet();\\n            HashSet<Integer>row=new HashSet();\\n            \\n            // get every value in the row\\n            for(int j=0; j<n; j++){\\n                row.add(mat[i][j]);\\n            }\\n            \\n            for(int k: set){\\n                for(int r: row){\\n                    // get every value so far \\n                    newSet.add(r+k);\\n                }\\n            }\\n            set=new HashSet(newSet);\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n                \\n        for(int i: set){\\n            min=Math.min(min, Math.abs(target-i));\\n        }\\n        \\n        return min;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419037,
                "title": "c-bitset-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<5000> b, b1; \\n        b.set(0);\\n        for (auto &v : mat) {\\n            for (auto a : v)\\n                b1 |= b << a;\\n            swap(b, b1);\\n            b1.reset();\\n        }\\n        int ans = INT_MAX;\\n        for (int i = 0; i < 5000; i++) \\n            if (b[i]) ans = min(ans, abs(i - target));\\n\\t\\treturn ans;\\n\\t\\t\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<5000> b, b1; \\n        b.set(0);\\n        for (auto &v : mat) {\\n            for (auto a : v)\\n                b1 |= b << a;\\n            swap(b, b1);\\n            b1.reset();\\n        }\\n        int ans = INT_MAX;\\n        for (int i = 0; i < 5000; i++) \\n            if (b[i]) ans = min(ans, abs(i - target));\\n\\t\\treturn ans;\\n\\t\\t\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418775,
                "title": "c",
                "content": "Runtime: 1417 ms\\nMemory Usage: 29.8 MB\\n```\\npublic class Solution {\\n    public int MinimizeTheDifference(int[][] mat, int target) {\\n        HashSet<int> crnt = new HashSet<int>();\\n        HashSet<int> prev = new HashSet<int>();\\n        HashSet<int> temp;\\n        \\n        int next = int.MaxValue;\\n        \\n        for(int i=0; i< mat[0].Length; i++)\\n        {\\n            if (mat[0][i] >= target) \\n            { \\n                next = Math.Min(next, mat[0][i]); // keep smallest bigger number\\n            }\\n            else\\n            {\\n                crnt.Add(mat[0][i]); // add all smaller\\n            }\\n        }\\n        \\n        int prevNext = next;\\n        for(int i=1; i < mat.Length; i++)\\n        {\\n            prevNext = next;  \\n            next = int.MaxValue;\\n            \\n            temp = prev;\\n            prev = crnt;\\n            crnt = temp;\\n            crnt.Clear();\\n            \\n            for(int j=0; j < mat[i].Length; j++)\\n            {\\n                if (prevNext + mat[i][j] >= target)\\n                {\\n                   next = Math.Min(next, prevNext + mat[i][j]);\\n                }\\n                foreach(int val in prev)\\n                {\\n                    if (val + mat[i][j] >= target)\\n                    {\\n                       next = Math.Min(next, val + mat[i][j]); \\n                    }\\n                    else\\n                    {\\n                        crnt.Add(val + mat[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int result = next - target;\\n        \\n        foreach(int val in crnt)\\n        {\\n            if (Math.Abs(val - target) < result) { result = Math.Abs(val - target); }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinimizeTheDifference(int[][] mat, int target) {\\n        HashSet<int> crnt = new HashSet<int>();\\n        HashSet<int> prev = new HashSet<int>();\\n        HashSet<int> temp;\\n        \\n        int next = int.MaxValue;\\n        \\n        for(int i=0; i< mat[0].Length; i++)\\n        {\\n            if (mat[0][i] >= target) \\n            { \\n                next = Math.Min(next, mat[0][i]); // keep smallest bigger number\\n            }\\n            else\\n            {\\n                crnt.Add(mat[0][i]); // add all smaller\\n            }\\n        }\\n        \\n        int prevNext = next;\\n        for(int i=1; i < mat.Length; i++)\\n        {\\n            prevNext = next;  \\n            next = int.MaxValue;\\n            \\n            temp = prev;\\n            prev = crnt;\\n            crnt = temp;\\n            crnt.Clear();\\n            \\n            for(int j=0; j < mat[i].Length; j++)\\n            {\\n                if (prevNext + mat[i][j] >= target)\\n                {\\n                   next = Math.Min(next, prevNext + mat[i][j]);\\n                }\\n                foreach(int val in prev)\\n                {\\n                    if (val + mat[i][j] >= target)\\n                    {\\n                       next = Math.Min(next, val + mat[i][j]); \\n                    }\\n                    else\\n                    {\\n                        crnt.Add(val + mat[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int result = next - target;\\n        \\n        foreach(int val in crnt)\\n        {\\n            if (Math.Abs(val - target) < result) { result = Math.Abs(val - target); }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418761,
                "title": "java-easy-solution",
                "content": "```\\n private int min;  \\n    private int[][] visited; \\n    public void solve(int[][] a, int sum, int row, int target){\\n        if(row>=a.length){\\n            min=Math.min(min, Math.abs(target-sum));\\n            return;\\n        }        \\n        if(visited[row][sum] == 1) \\n            return;\\n        for(int j=0; j<a[0].length; j++){\\n            solve(a, sum+a[row][j], row+1, target);\\n\\n        }\\n        visited[row][sum] = 1;  \\n    }\\n\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        min = Integer.MAX_VALUE;\\n        visited = new int[mat.length][10000];\\n        solve(mat, 0, 0, target);\\n        return min;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n private int min;  \\n    private int[][] visited; \\n    public void solve(int[][] a, int sum, int row, int target){\\n        if(row>=a.length){\\n            min=Math.min(min, Math.abs(target-sum));\\n            return;\\n        }        \\n        if(visited[row][sum] == 1) \\n            return;\\n        for(int j=0; j<a[0].length; j++){\\n            solve(a, sum+a[row][j], row+1, target);\\n\\n        }\\n        visited[row][sum] = 1;  \\n    }\\n\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        min = Integer.MAX_VALUE;\\n        visited = new int[mat.length][10000];\\n        solve(mat, 0, 0, target);\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1418740,
                "title": "java-dp-solution-with-greedy",
                "content": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int min_sum = 0;\\n        for (int[] row : mat) {\\n            int min = Integer.MAX_VALUE;\\n            for (int num : row) {\\n                min = Math.min(num, min);\\n            }\\n            min_sum += min;\\n        }\\n        int threshold = Math.abs(min_sum - target);\\n\\n        Set<Integer> lastRow = new HashSet<>();\\n        lastRow.add(target);\\n        for (int[] row : mat) {\\n            boolean[] array = new boolean[71];\\n            for (int num : row) {\\n                array[num] = true;\\n            }\\n            Set<Integer> curRow = new HashSet<>();\\n            for (int i = 1; i <= 70; i++) {\\n                if (array[i]) {\\n                    for (int val : lastRow) {\\n                        if (val - i < -target) continue;\\n                        curRow.add(val - i);\\n                    }\\n                }\\n            }\\n            lastRow = curRow;\\n        }\\n        int res = threshold;\\n        for (int val : lastRow) {\\n            res = Math.min(res, Math.abs(val));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int min_sum = 0;\\n        for (int[] row : mat) {\\n            int min = Integer.MAX_VALUE;\\n            for (int num : row) {\\n                min = Math.min(num, min);\\n            }\\n            min_sum += min;\\n        }\\n        int threshold = Math.abs(min_sum - target);\\n\\n        Set<Integer> lastRow = new HashSet<>();\\n        lastRow.add(target);\\n        for (int[] row : mat) {\\n            boolean[] array = new boolean[71];\\n            for (int num : row) {\\n                array[num] = true;\\n            }\\n            Set<Integer> curRow = new HashSet<>();\\n            for (int i = 1; i <= 70; i++) {\\n                if (array[i]) {\\n                    for (int val : lastRow) {\\n                        if (val - i < -target) continue;\\n                        curRow.add(val - i);\\n                    }\\n                }\\n            }\\n            lastRow = curRow;\\n        }\\n        int res = threshold;\\n        for (int val : lastRow) {\\n            res = Math.min(res, Math.abs(val));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418729,
                "title": "answer-giving-tle-please-tell-the-error-like-i-am-unable-to-figure-it-out",
                "content": "typedef long long int ll;\\nclass Solution {\\npublic:\\n    ll minimizeTheDifference(vector<vector<int>>& mat, ll target) \\n\\t{\\n\\t\\tll n=mat.size(),m=mat[0].size();\\n        if(n==0||m==0)\\n        {\\n            return target;\\n        }\\n        vector<vector<ll>>dp(n+5,vector<ll>(5000,0));\\n        for(ll i=0;i<=n;i++)\\n        {\\n            for(ll j=0;j<=4900;j++)\\n            dp[i][j]=0;\\n        }\\n        ll x=-1;\\n        for(ll i=0;i<n;i++)\\n        {\\n            for(ll j=0;j<m;j++)\\n            {\\n                if(i==0)\\n                {\\n                    dp[i][mat[i][j]]=1;\\n                }\\n                else\\n                {\\n                    for(ll k=1;k<=4900;k++)\\n                    {\\n\\t\\t\\t\\t\\t\\tif(dp[i-1][k]==1)\\n                        {\\n                            if(k+mat[i][j]<=4900)\\n                            dp[i][k+mat[i][j]]=1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        ll ns=0;\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll mini=70;\\n            for(ll j=0;j<m;j++)\\n            {\\n                mini=min(mini,(ll)mat[i][j]);\\n            }\\n            ns+=mini;\\n        }\\n        ll ans=llabs(ns-target);\\n        for(ll i=1;i<=4900;i++)\\n        {\\n            if(dp[n-1][i]==1)\\n            {\\n                ans=min(ans,llabs(target-i));\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ll minimizeTheDifference(vector<vector<int>>& mat, ll target) \\n\\t{\\n\\t\\tll n=mat.size(),m=mat[0].size();\\n        if(n==0||m==0)\\n        {\\n            return target;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1418635,
                "title": "javascript-dynamic-programming",
                "content": "```javascript\\n/**\\n * Collect all the possible sums but keep only one sum that is greater than the target\\n */\\nvar minimizeTheDifference = function(mat, target) {\\n    let possibleSums = new Set(mat[0]);\\n    for (let row = 1; row < mat.length; row++) {\\n        const nextPossibleSums = new Set();\\n        let min = Infinity;\\n        for (let col = 0; col < mat[row].length; col++) {\\n            for (const num of possibleSums) {\\n                const sum = num + mat[row][col];\\n                // if sum is smaller than the min then it could be the best sum\\n                if (sum < min) {\\n                    nextPossibleSums.add(sum);\\n                    // if the sum is greater than or equal to the target and\\n                    // less than the min we know the previous min can not be\\n                    // a better sum so we can delete it from the possible sums\\n                    if (sum >= target) {\\n                        nextPossibleSums.delete(min);\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        possibleSums = nextPossibleSums;\\n    }\\n    for (let i = 0; i < Infinity; i++) {\\n        if (possibleSums.has(target + i) || possibleSums.has(target - i)) {\\n            return i;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * Collect all the possible sums but keep only one sum that is greater than the target\\n */\\nvar minimizeTheDifference = function(mat, target) {\\n    let possibleSums = new Set(mat[0]);\\n    for (let row = 1; row < mat.length; row++) {\\n        const nextPossibleSums = new Set();\\n        let min = Infinity;\\n        for (let col = 0; col < mat[row].length; col++) {\\n            for (const num of possibleSums) {\\n                const sum = num + mat[row][col];\\n                // if sum is smaller than the min then it could be the best sum\\n                if (sum < min) {\\n                    nextPossibleSums.add(sum);\\n                    // if the sum is greater than or equal to the target and\\n                    // less than the min we know the previous min can not be\\n                    // a better sum so we can delete it from the possible sums\\n                    if (sum >= target) {\\n                        nextPossibleSums.delete(min);\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        possibleSums = nextPossibleSums;\\n    }\\n    for (let i = 0; i < Infinity; i++) {\\n        if (possibleSums.has(target + i) || possibleSums.has(target - i)) {\\n            return i;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003388,
                "title": "java-easy-dp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        Integer[][] dp = new Integer[mat.length][10000];\\n        return solve(0, mat, target, 0, dp);\\n    }\\n    private int solve(int row, int[][] mat, int target, int sum, Integer[][] dp){\\n        if(row==mat.length){\\n            return Math.abs(target-sum);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        if(dp[row][sum]!=null){\\n            return dp[row][sum];\\n        }\\n        for(int col=0; col<mat[0].length; col++){\\n            ans = Math.min(ans,solve(row+1, mat, target, sum+mat[row][col], dp));\\n        }\\n        return dp[row][sum]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        Integer[][] dp = new Integer[mat.length][10000];\\n        return solve(0, mat, target, 0, dp);\\n    }\\n    private int solve(int row, int[][] mat, int target, int sum, Integer[][] dp){\\n        if(row==mat.length){\\n            return Math.abs(target-sum);\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        if(dp[row][sum]!=null){\\n            return dp[row][sum];\\n        }\\n        for(int col=0; col<mat[0].length; col++){\\n            ans = Math.min(ans,solve(row+1, mat, target, sum+mat[row][col], dp));\\n        }\\n        return dp[row][sum]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985324,
                "title": "java",
                "content": "\\n# Code\\n```\\n// DP\\nclass Solution {\\n\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\n        int[][] dp = new int[m + 1][4970 + 1]; \\n\\n        for (int i = m; i >= 0; i--) {\\n            for (int j = 4900; j >= 0; j--) {\\n                if (i == m) {\\n                    dp[i][j] = Math.abs(j - target);\\n                    continue;\\n                }\\n                int min = 100000000;\\n                for (int c = 0; c < n; c++) {\\n                    int o = dp[i + 1][j + mat[i][c]];\\n                    min = Math.min(min, o);\\n                }\\n\\n                dp[i][j] = min;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// DP\\nclass Solution {\\n\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\n        int[][] dp = new int[m + 1][4970 + 1]; \\n\\n        for (int i = m; i >= 0; i--) {\\n            for (int j = 4900; j >= 0; j--) {\\n                if (i == m) {\\n                    dp[i][j] = Math.abs(j - target);\\n                    continue;\\n                }\\n                int min = 100000000;\\n                for (int c = 0; c < n; c++) {\\n                    int o = dp[i + 1][j + mat[i][c]];\\n                    min = Math.min(min, o);\\n                }\\n\\n                dp[i][j] = min;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973582,
                "title": "java-340ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int minMaxNum = Integer.MAX_VALUE;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        \\n        // Map<Integer, Integer>[] dp = new HashMap[mat.length];\\n        // for(int i = 0; i < mat.length; i++){\\n        //     Map<Integer, Integer> temp = new HashMap<>();\\n        //     dp[i] = temp;\\n        // }\\n        int[][] dp = new int[mat.length][5001];\\n        for(int[] d: dp){\\n            Arrays.fill(d, -1);\\n        }\\n        \\n        return helper(mat, 0, 0, 0, target, dp);\\n    }\\n\\n\\n    private int helper(int[][] mat, int curr, int prev, int idx, int target, int[][] dp){\\n        if(idx < mat.length && curr > minMaxNum){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(idx == mat.length){\\n            if(curr > target){\\n                minMaxNum = Math.min(minMaxNum, curr);\\n            }\\n            return Math.abs(curr - target);\\n        }\\n        if(dp[idx][curr] != -1){\\n            return dp[idx][curr];\\n        }\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i = 0; i < mat[0].length; i++){\\n            minDiff = Math.min(helper(mat, curr + mat[idx][i], curr, idx + 1, target, dp), minDiff);\\n            dp[idx][curr] = minDiff;\\n        }\\n\\n        return minDiff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int minMaxNum = Integer.MAX_VALUE;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        \\n        // Map<Integer, Integer>[] dp = new HashMap[mat.length];\\n        // for(int i = 0; i < mat.length; i++){\\n        //     Map<Integer, Integer> temp = new HashMap<>();\\n        //     dp[i] = temp;\\n        // }\\n        int[][] dp = new int[mat.length][5001];\\n        for(int[] d: dp){\\n            Arrays.fill(d, -1);\\n        }\\n        \\n        return helper(mat, 0, 0, 0, target, dp);\\n    }\\n\\n\\n    private int helper(int[][] mat, int curr, int prev, int idx, int target, int[][] dp){\\n        if(idx < mat.length && curr > minMaxNum){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(idx == mat.length){\\n            if(curr > target){\\n                minMaxNum = Math.min(minMaxNum, curr);\\n            }\\n            return Math.abs(curr - target);\\n        }\\n        if(dp[idx][curr] != -1){\\n            return dp[idx][curr];\\n        }\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i = 0; i < mat[0].length; i++){\\n            minDiff = Math.min(helper(mat, curr + mat[idx][i], curr, idx + 1, target, dp), minDiff);\\n            dp[idx][curr] = minDiff;\\n        }\\n\\n        return minDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927756,
                "title": "knapsack-template-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int t[71][5000];\\n    int solve(int i,int m,int n,vector<vector<int>>& mat,int sum, int &target)\\n    {\\n    \\n        if (i==m)\\n        {\\n            return abs(target-sum);\\n        }\\n        if (t[i][sum]!=-1)\\n          return t[i][sum];\\n        int result=INT_MAX;\\n        for (int k=0;k<n;k++)\\n        {\\n            result=min(result,solve(i+1,m,n,mat,sum+mat[i][k],target));\\n        }\\n        return t[i][sum]=result;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        memset(t,-1,sizeof(t));\\n        return solve(0,m,n,mat,0,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[71][5000];\\n    int solve(int i,int m,int n,vector<vector<int>>& mat,int sum, int &target)\\n    {\\n    \\n        if (i==m)\\n        {\\n            return abs(target-sum);\\n        }\\n        if (t[i][sum]!=-1)\\n          return t[i][sum];\\n        int result=INT_MAX;\\n        for (int k=0;k<n;k++)\\n        {\\n            result=min(result,solve(i+1,m,n,mat,sum+mat[i][k],target));\\n        }\\n        return t[i][sum]=result;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        memset(t,-1,sizeof(t));\\n        return solve(0,m,n,mat,0,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837346,
                "title": "memoization-solution-91-faster-c-java-solution",
                "content": "\\n# Code\\n\\n**Java**\\n```\\nclass Solution {\\n    public int [][] dp;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int n=mat.length,m=mat[0].length;\\n        dp=new int[n+1][5000];\\n        for(int [] a:dp) Arrays.fill(a,-1);\\n        return solve(target,0,0,mat,n,m);\\n    }\\n    public int solve(int target,int sum,int row,int [][] mat,int n,int m){\\n        if(row>=n){\\n            return Math.abs(sum-target);\\n        }\\n        if(dp[row][sum]!=-1) return dp[row][sum];\\n        int ans=Integer.MAX_VALUE;\\n        for(int col=0;col<m;col++){\\n            ans=Math.min(ans,solve(target,sum+mat[row][col],row+1,mat,n,m));\\n        }\\n        return dp[row][sum]=ans;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n\\n    int minimizeTheDifference(std::vector<std::vector<int>>& mat, int target) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        dp.resize(n + 1, std::vector<int>(5000, -1));\\n        return solve(target, 0, 0, mat, n, m);\\n    }\\n\\n    int solve(int target, int sum, int row, std::vector<std::vector<int>>& mat, int n, int m) {\\n        if (row >= n) {\\n            return std::abs(sum - target);\\n        }\\n        if (dp[row][sum] != -1) return dp[row][sum];\\n        int ans = INT_MAX;\\n        for (int col = 0; col < m; col++) {\\n            ans = std::min(ans, solve(target, sum + mat[row][col], row + 1, mat, n, m));\\n        }\\n        return dp[row][sum] = ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int [][] dp;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int n=mat.length,m=mat[0].length;\\n        dp=new int[n+1][5000];\\n        for(int [] a:dp) Arrays.fill(a,-1);\\n        return solve(target,0,0,mat,n,m);\\n    }\\n    public int solve(int target,int sum,int row,int [][] mat,int n,int m){\\n        if(row>=n){\\n            return Math.abs(sum-target);\\n        }\\n        if(dp[row][sum]!=-1) return dp[row][sum];\\n        int ans=Integer.MAX_VALUE;\\n        for(int col=0;col<m;col++){\\n            ans=Math.min(ans,solve(target,sum+mat[row][col],row+1,mat,n,m));\\n        }\\n        return dp[row][sum]=ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minimizeTheDifference(std::vector<std::vector<int>>& mat, int target) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        dp.resize(n + 1, std::vector<int>(5000, -1));\\n        return solve(target, 0, 0, mat, n, m);\\n    }\\n\\n    int solve(int target, int sum, int row, std::vector<std::vector<int>>& mat, int n, int m) {\\n        if (row >= n) {\\n            return std::abs(sum - target);\\n        }\\n        if (dp[row][sum] != -1) return dp[row][sum];\\n        int ans = INT_MAX;\\n        for (int col = 0; col < m; col++) {\\n            ans = std::min(ans, solve(target, sum + mat[row][col], row + 1, mat, n, m));\\n        }\\n        return dp[row][sum] = ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815255,
                "title": "javascript-1981-minimize-the-difference-between-target-and-chosen-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n```\\nmatrix is given  (g)\\nmany rows\\nand each row has values\\n\\nfrom top to bottom\\npassing through all columns\\nfind the sum\\n\\nonce all sums are accumulated in Set\\ntake the closest of all sums to target & return it\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nvar minimizeTheDifference = function (g, target) {\\n  let prevSet = new Set([0]) // top to bottom   sum the path   prevSet\\n\\n  for (let row of g) { // each row\\n    let set = new Set()\\n    for (let val of row) { // each column value\\n      for (let sum of prevSet) {\\n        set.add(val + sum) // sum of this row values to all previous sums of all rows above\\n      }\\n    }\\n    prevSet = set\\n  }\\n\\n  let min = Infinity\\n  for (let sum of prevSet) {\\n    // which sum is closest to target, take that min distance\\n    min = Math.min(min, Math.abs(target - sum))\\n  }\\n  return min\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nmatrix is given  (g)\\nmany rows\\nand each row has values\\n\\nfrom top to bottom\\npassing through all columns\\nfind the sum\\n\\nonce all sums are accumulated in Set\\ntake the closest of all sums to target & return it\\n```\n```\\nvar minimizeTheDifference = function (g, target) {\\n  let prevSet = new Set([0]) // top to bottom   sum the path   prevSet\\n\\n  for (let row of g) { // each row\\n    let set = new Set()\\n    for (let val of row) { // each column value\\n      for (let sum of prevSet) {\\n        set.add(val + sum) // sum of this row values to all previous sums of all rows above\\n      }\\n    }\\n    prevSet = set\\n  }\\n\\n  let min = Infinity\\n  for (let sum of prevSet) {\\n    // which sum is closest to target, take that min distance\\n    min = Math.min(min, Math.abs(target - sum))\\n  }\\n  return min\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805729,
                "title": "easy-dp-c-recursive-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each row, we have cols number or choices to choose.\\nWe pick that element and the go to the next row.\\nAl last row just check with target.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int target;\\n    int dp[71][5000]; \\n    int solve(int row, int sum, vector<vector<int>>& mat){\\n        if(row == n){\\n            return abs(sum - target);\\n        }\\n        if(dp[row][sum] != -1) return dp[row][sum];\\n        int ans = 1e9;\\n        for(int j = 0; j < m; ++j){\\n            ans = min(ans, solve(row+1, sum+mat[row][j], mat));\\n        }\\n        return dp[row][sum] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int t) {\\n        n = mat.size();\\n        m = mat[0].size();\\n        target = t;\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0, mat);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int target;\\n    int dp[71][5000]; \\n    int solve(int row, int sum, vector<vector<int>>& mat){\\n        if(row == n){\\n            return abs(sum - target);\\n        }\\n        if(dp[row][sum] != -1) return dp[row][sum];\\n        int ans = 1e9;\\n        for(int j = 0; j < m; ++j){\\n            ans = min(ans, solve(row+1, sum+mat[row][j], mat));\\n        }\\n        return dp[row][sum] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int t) {\\n        n = mat.size();\\n        m = mat[0].size();\\n        target = t;\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0, mat);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633182,
                "title": "c-easy-concise-explanation",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\n    // we declare the 2-D dp because sum and row changes in recursion according to given constraints\\n    //  max sum can be possible is 70*70 and max no of row can be possible is 71\\n\\n    int dp[5001][71];\\n    \\n    int solve(int row, int sum, vector<vector<int>> &a, int tar)\\n    {\\n        if (row == a.size()) // If we reach at  last row\\n        {\\n            return abs(sum - tar);\\n        }\\n\\n        // If we previously find dp[][] value then simple return that value\\n\\n        if (dp[sum][row] != -1)\\n        {\\n            return dp[sum][row];\\n        }\\n\\n        int min_diff = INT_MAX;\\n\\n        for (int j = 0; j < a[0].size(); j++)\\n        {            \\n                        // \\n            min_diff = min(min_diff, solve(row + 1, sum + a[row][j], a, tar));\\n        }\\n\\n        return dp[sum][row] = min_diff;\\n\\n    }\\n    int minimizeTheDifference(vector<vector<int>> &a, int tar)\\n    {\\n        int n = a.size(), m = a[0].size();\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return solve(0, 0, a, tar);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\n    // we declare the 2-D dp because sum and row changes in recursion according to given constraints\\n    //  max sum can be possible is 70*70 and max no of row can be possible is 71\\n\\n    int dp[5001][71];\\n    \\n    int solve(int row, int sum, vector<vector<int>> &a, int tar)\\n    {\\n        if (row == a.size()) // If we reach at  last row\\n        {\\n            return abs(sum - tar);\\n        }\\n\\n        // If we previously find dp[][] value then simple return that value\\n\\n        if (dp[sum][row] != -1)\\n        {\\n            return dp[sum][row];\\n        }\\n\\n        int min_diff = INT_MAX;\\n\\n        for (int j = 0; j < a[0].size(); j++)\\n        {            \\n                        // \\n            min_diff = min(min_diff, solve(row + 1, sum + a[row][j], a, tar));\\n        }\\n\\n        return dp[sum][row] = min_diff;\\n\\n    }\\n    int minimizeTheDifference(vector<vector<int>> &a, int tar)\\n    {\\n        int n = a.size(), m = a[0].size();\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return solve(0, 0, a, tar);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601389,
                "title": "meet-in-the-middle-technique",
                "content": "```\\nimport bisect\\n\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        m = len(mat)\\n        upsums = {0}\\n        downsums = {0}\\n        for i in range(m // 2):\\n            upsums = {x + el for el in mat[i] for x in upsums}\\n        for i in range(m // 2, m):\\n            downsums = {x + el for el in mat[i] for x in downsums}\\n        downsums = sorted(downsums)\\n        n = len(downsums)\\n        res = float(\\'inf\\')\\n        for s in upsums:\\n            i = bisect.bisect_left(downsums, target - s)\\n            if i < n:\\n                res = min(res, abs(s + downsums[i] - target))\\n            if i > 0:\\n                res = min(res, abs(s + downsums[i - 1] - target))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        m = len(mat)\\n        upsums = {0}\\n        downsums = {0}\\n        for i in range(m // 2):\\n            upsums = {x + el for el in mat[i] for x in upsums}\\n        for i in range(m // 2, m):\\n            downsums = {x + el for el in mat[i] for x in downsums}\\n        downsums = sorted(downsums)\\n        n = len(downsums)\\n        res = float(\\'inf\\')\\n        for s in upsums:\\n            i = bisect.bisect_left(downsums, target - s)\\n            if i < n:\\n                res = min(res, abs(s + downsums[i] - target))\\n            if i > 0:\\n                res = min(res, abs(s + downsums[i - 1] - target))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553050,
                "title": "simple-recursion-memoization-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[100][10000];\\n\\n    int helper(int i, int j, int m, int n, vector<vector<int>>& mat, int target){\\n\\n        if(i>=m) return abs(j-target);\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int sum = INT_MAX;\\n        for(int k=0;k<n;k++){\\n            sum = min(sum, helper(i+1,j+mat[i][k],m,n,mat,target));\\n        }\\n        return dp[i][j] = sum;\\n\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size(), n = mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,m,n,mat,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[100][10000];\\n\\n    int helper(int i, int j, int m, int n, vector<vector<int>>& mat, int target){\\n\\n        if(i>=m) return abs(j-target);\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int sum = INT_MAX;\\n        for(int k=0;k<n;k++){\\n            sum = min(sum, helper(i+1,j+mat[i][k],m,n,mat,target));\\n        }\\n        return dp[i][j] = sum;\\n\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size(), n = mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,m,n,mat,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473291,
                "title": "c-hashset",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size(), n = mat[0].size(), ans = INT_MAX;\\n        unordered_set<int> Set;\\n        Set.insert(0);\\n        for(int i = 0; i < m; i++) {\\n            unordered_set<int> temp;\\n            int minVal = INT_MAX;\\n            for(int val: Set) {\\n                for(int j = 0; j < n; j++) {\\n                    minVal = min(minVal, val + mat[i][j]);\\n                    temp.insert(val + mat[i][j]);  \\n                }\\n            }\\n            Set.clear();\\n            for(int val: temp) {\\n                if(abs(target - val) > abs(target - minVal)) continue;\\n                Set.insert(val);\\n            }\\n        }\\n        for(int val: Set) {\\n            ans = min(ans, abs(target - val));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size(), n = mat[0].size(), ans = INT_MAX;\\n        unordered_set<int> Set;\\n        Set.insert(0);\\n        for(int i = 0; i < m; i++) {\\n            unordered_set<int> temp;\\n            int minVal = INT_MAX;\\n            for(int val: Set) {\\n                for(int j = 0; j < n; j++) {\\n                    minVal = min(minVal, val + mat[i][j]);\\n                    temp.insert(val + mat[i][j]);  \\n                }\\n            }\\n            Set.clear();\\n            for(int val: temp) {\\n                if(abs(target - val) > abs(target - minVal)) continue;\\n                Set.insert(val);\\n            }\\n        }\\n        for(int val: Set) {\\n            ans = min(ans, abs(target - val));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422063,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer dp[][];\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp=new Integer[mat.length][70*70];\\n        return mc(mat,target,0,0);\\n    }\\n    public int mc(int[][]mat,int target,int sum,int i){\\nif(i==mat.length)\\nreturn Math.abs(target-sum);\\nint ans=Integer.MAX_VALUE;\\nif(dp[i][sum]!=null)\\nreturn dp[i][sum];\\n\\n        for(int j=0;j<mat[0].length;j++){\\n            ans=Math.min(mc(mat,target,sum+mat[i][j],i+1),ans);\\n        }\\n         return dp[i][sum]=ans;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp=new Integer[mat.length][70*70];\\n        return mc(mat,target,0,0);\\n    }\\n    public int mc(int[][]mat,int target,int sum,int i){\\nif(i==mat.length)\\nreturn Math.abs(target-sum);\\nint ans=Integer.MAX_VALUE;\\nif(dp[i][sum]!=null)\\nreturn dp[i][sum];\\n\\n        for(int j=0;j<mat[0].length;j++){\\n            ans=Math.min(mc(mat,target,sum+mat[i][j],i+1),ans);\\n        }\\n         return dp[i][sum]=ans;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404956,
                "title": "c-and-python-solutions-c-beats-100-in-space-and-time",
                "content": "# Intuition\\nStore all the possible sums in a set!\\nSets are perfect for checking existence/membership.\\n\\n# Approach\\nAgain, we only need to store all the sums. Better yet, we can break it into sub-problems, and instead use a set, say, `prev`, to store the sums **of a given row**. Then, sum the values stored in the `prev` set with each value in the current row. This will create one new set for each column item in the current row, which is fixed by the matrix. After this, we just join these new sets. This way we will have all the possible sums for the current row. Then we can repeat the process. This is very simple and straightforward to do in Python. But we can also implement a crazy-fast C solution. I will share with you both.\\n\\nSince the Python solution is simple and readable it needs no explanation. We will then detail and explain the C solution here.\\nThe approach is also to use sets. But in a different way: we represent them as maps. We first get ourselves a set of all possible sums, which is the `key` in our map. The possible sums range from 0 to $n$ x $max(a_{ij})$ = 70 x 70 = 4900, not necessarily inclusive, but this is an upper-bound. These are our keys. An item/sum `key` is mapped to either 1 or 0, representing its belonging in the set. This can be represented as a single sequence of bits! The `key` is simply the position in the bit sequence.\\n```\\n  values :  010001010\\n  keys   :  012345678\\n```\\n\\nIn this example, 1, 5 and 7 are the possible sums.\\nWe need a 4901-bits-long sequence of bits to represent all possible sums, since the maximum sum in 4900, inclusive. To add an element `value` to all elements in the set, we only need to **shift the keys**:\\n```\\nAdding 3...\\n  values :     010001010 or\\n            000010001010\\n  keys   :  0123456789ab\\n```\\n\\nSo here comes the cool part about using bits: beyond being hyper efficient in space, using bits, they are also crazy efficient in time! All we need to do to, say, to add an element `value` to all previous sum elements in `prev` is to do a bit shift! Remember, we only need to **shift the keys** in our map. The belonging of a given sum is not affected by a shift.\\n\\nWith C++\\'s bitset we can jump straight to solving the problem.\\nThe hard part in C is that we have no such functionality. So we need to actually code the bit shift functionality ourselves. Remember, there is no data type/structure in C with more than 64 bits to do bit-shifting with, much less 4901 bits... So we must work with an array, and define our own custom \"bit-shifting\" operation for it. Well, I suppose it won\\'t be nearly as efficient as a low-level bit shift, obviously, but I presume it will still be very good! Let\\'s trust the C compiler.\\n\\nThe C code uses exactly half the space of the C++ code (6.9MB vs 13.9 MB) and is about 60% slower on time than the C++ solution (185ms vs 115ms). The system says\\n`Sorry, there are not enough accepted submissions to show data\\n` with a \"Beats 100%\" on both Space and Time, dunno why. Is that maybe for C submissions only?\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2m^2)$$ in Python, $$O(n^2m * max(a_{ij}))$$ in C.\\nWe must iterate over each element in the matrix and add it to the sum list. The complexity of adding each element in a column to each of the current sum sets in Python is $O(m)$, since we have $m$ elements in a column. This makes the final complexity $O(mn^2)$. But in C the complexity of adding each value to the previous set is $O(n*max(a_{ij}))$, since we are shifting all the possible sums. We could say this is constant, since the number of possible sums, $n*max(a_{ij})$, is actually set to 4901. A simple bit shift over a set-size bit sequence is technically $O(1)$.\\nAnyway, moving on, we have to join each of the sets that are generated with the `prev` set and each column element. Joining $m$ sets of size $O(nm)$ each is $O(nm^2)$. Doing this for each row we get as final complexity $O(n^2m^2)$. For the C code we get effectively the same, or $O(1)$ if you consider 4901 a constant.\\n\\n- Space complexity:\\n$$O(nm)$$\\nIn Python, we have $m$ choices for each row, so the number of combinations is $O(m^n)$. In the worst case all the sums are different and we get this space complexity. But remember, all the sums are contained withing the interval between $0$ and $O(n*max(a_{ij}))$, making the space complexity actually $O(n*max(a_{ij}))$ in the worst case.\\nThe same is true for C, but the space complexity in C is again actually $O(1)$ since the memory is fixed at compile-time instead of at runtime in C. Interesting, right?\\n\\n# Code\\nPython\\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        prev_sums = {0}\\n        for row in mat:\\n            next_sums = set()\\n            for curr_sum in prev_sums:\\n                for el in row:\\n                    next_sums.add(el + curr_sum)\\n            prev_sums = next_sums\\n        return min({abs(target - curr_sum) for curr_sum in prev_sums})       \\n```\\nWe could reduce the number of lines in this Python code even further using list comprehension, but this solution has greater readability...\\nC\\n```\\n#include <stdbool.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <stdio.h>\\n\\n#define MAX_DIM 70\\n#define MAX_VAL 70\\n#define TYPE_SIZE 32\\n#define BYTE_SIZE 8\\n\\n#define BITSLOT(i) ((i) / TYPE_SIZE)\\n#define BITMASK(i) (((unsigned int)1) << ((i) % TYPE_SIZE))\\n#define BITTEST(a, i) ((((a)[BITSLOT(i)] & BITMASK(i))) != 0)\\n\\n#define BITS_MASK_SIZE 4091\\n#define ARR_LENGTH (BITS_MASK_SIZE - 1) / TYPE_SIZE + 1\\n#define SIZE_IN_BITS BITS_MASK_SIZE / BYTE_SIZE\\n\\nvoid display_hexarray(unsigned int* arr){\\n\\tprintf(\"\\\\nHexArray:\\\\n\");\\n\\tfor(unsigned int i = 0; i < ARR_LENGTH; i++){\\n\\t\\tprintf(\"%x, \", arr[i]);\\n\\t}\\n\\tprintf(\"\\\\n\");\\n}\\n\\nvoid bitwise_or_inplace(unsigned int* outArray, unsigned int* arg){\\n    for(unsigned int i = 0; i < ARR_LENGTH; i++){\\n        outArray[i] |= arg[i];\\n    }\\n}\\nvoid bitwise_shift_left(unsigned int* array, unsigned int shift){\\n\\tif(shift == 0){\\n\\t\\treturn;\\n\\t}\\n\\t//display_hexarray(array);\\n\\tunsigned int index_shift = shift / TYPE_SIZE;\\n\\tunsigned int bits_shift = shift % TYPE_SIZE;\\n\\tif(index_shift >= ARR_LENGTH) {\\n\\t\\tindex_shift = ARR_LENGTH;\\n\\t\\tbits_shift = 0;\\n\\t}\\n\\tif(bits_shift == 0){\\n\\t\\tfor(unsigned int i = ARR_LENGTH - 1; i >= index_shift; --i) {\\n\\t\\t\\tarray[i] = array[i - index_shift];\\n\\t\\t}\\n\\t\\tfor(unsigned int i = 0; i < index_shift; ++i) {\\n\\t\\t\\tarray[i] = 0;\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tfor(unsigned int i = ARR_LENGTH - 1; i > index_shift; --i) {\\n\\t\\tarray[i] = array[i - index_shift] << bits_shift;\\n\\t\\tarray[i] |= array[i - index_shift-1] >> TYPE_SIZE - bits_shift;\\n\\t}\\n\\tarray[index_shift] = array[0] << bits_shift;\\n\\tif(index_shift <= 0) return;\\n\\tfor(unsigned int i = 0; i < index_shift; i++) {\\n\\t\\tarray[i] = 0;\\n\\t}\\n}\\n\\nint minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n\\tunsigned int min, max;\\n\\tmax = matSize * matColSize[0] * MAX_VAL;\\n\\tmin = target + max;\\n\\n\\t// This is basically a map. Each key maps to 0 or 1.\\n\\t// This mapping represents a set!\\n\\t// If an element is present in the set, the bit value is set to 1.\\n\\t// A simple shift then represents an addition over all elements in the set!\\n\\tunsigned int previousSet[ARR_LENGTH];\\n\\tmemset(previousSet, 0, SIZE_IN_BITS);\\n\\tpreviousSet[0] = 0x01;\\n\\t//display_hexarray(previousSet);\\n\\n\\tfor(unsigned int i=0; i < matSize; i++){\\n\\t\\t//printf(\"\\\\nNEXT COLUMN\\\\n\");\\n\\t\\t//display_hexarray(previousSet);\\n\\n\\t\\t// New empty map of values\\n\\t\\tunsigned int currentSet[ARR_LENGTH];\\n\\t\\tmemset(currentSet, 0, SIZE_IN_BITS);\\n\\n\\t\\tfor(unsigned int j=0; j < *matColSize; j++){\\n\\t\\t\\tunsigned int currValue = mat[i][j];\\n\\n\\t\\t\\t// Temporary array to store shift\\n\\t\\t\\t// Stores intially a copy of the previous set\\n\\t\\t\\tunsigned int tmp[ARR_LENGTH];\\n\\t\\t\\tmemcpy(tmp, previousSet, SIZE_IN_BITS);\\n\\t\\t//display_hexarray(tmp);\\n\\n\\t\\t\\t//printf(\"\\\\nVal: %i\\\\n\", currValue);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t\\t// Add current value to all elements in \"temp\"\\n\\t\\t\\tbitwise_shift_left(tmp, currValue);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t\\t// Join tmp into currentSet\\n\\t\\t\\tbitwise_or_inplace(currentSet, tmp);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t}\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\tmemcpy(previousSet, currentSet, SIZE_IN_BITS);\\n\\t}\\n\\tfor(unsigned int currSum=0; currSum < BITS_MASK_SIZE; currSum++){\\n\\t\\t// Current Sum is present!\\n\\t\\tif(BITTEST(previousSet, currSum)){\\n\\t\\t\\t//printf(\"%i, \", currSum);\\n\\t\\t\\tunsigned int dist = abs(target - currSum);\\n\\t\\t\\tif(dist < min){\\n\\t\\t\\t\\tmin = dist;\\n\\t\\t\\t}\\n\\t\\t\\tif(min == 0) return 0;\\n\\t\\t}\\n\\t}\\n\\treturn min;\\n}\\n```\\nAlso, here is the C++ code that inspired me try writing the solution in C. I\\'m honestly impressed my clumsy array-bit-shifting operation actually surpassed it...\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int maxSum = 70 * mat.size();\\n\\n        // This is basically a map. Each key maps to 0 or 1.\\n        // This mapping represents a set!\\n        // If an element is present in the set, the bit value is set to 1.\\n        // A simple shift then represents an addition over all elements in the set!\\n        bitset<4901> previousSet;\\n        // 0 only is present in the set\\n        previousSet[0] = 1;\\n        for(vector<int> row : mat){\\n            bitset<4901> currentSet;\\n            for(int value : row){\\n                // Add value to each element in the set\\n                // Remember, the values are represented by the keys that map to 1\\n                bitset<4901> incrementedSet = previousSet << value;\\n\\n                // Join the two sets\\n                currentSet = currentSet | incrementedSet;\\n            }\\n            previousSet = currentSet;\\n        }\\n        int minimum = abs(maxSum + target);\\n        for (int currSum = 0; currSum < 4901; ++currSum) {\\n            // Element currSum is in the set!\\n            if (previousSet[currSum]) {\\n                int distance = abs(currSum - target);\\n                minimum = min(minimum, distance);\\n            }\\n        }\\n        return minimum;\\n    }\\n};\\nint main(){\\n\\tSolution().minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n}\\n```\\n\\nFor anyone who says C is easy to code, this took me 3 days of suffering through compile-time and runtime errors, being totally honest. Python took me a few minutes... But I got the damn \"Beats 100%\" in both Space and Time, so maybe that was worth the effort haha.",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n  values :  010001010\\n  keys   :  012345678\\n```\n```\\nAdding 3...\\n  values :     010001010 or\\n            000010001010\\n  keys   :  0123456789ab\\n```\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        prev_sums = {0}\\n        for row in mat:\\n            next_sums = set()\\n            for curr_sum in prev_sums:\\n                for el in row:\\n                    next_sums.add(el + curr_sum)\\n            prev_sums = next_sums\\n        return min({abs(target - curr_sum) for curr_sum in prev_sums})       \\n```\n```\\n#include <stdbool.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <stdio.h>\\n\\n#define MAX_DIM 70\\n#define MAX_VAL 70\\n#define TYPE_SIZE 32\\n#define BYTE_SIZE 8\\n\\n#define BITSLOT(i) ((i) / TYPE_SIZE)\\n#define BITMASK(i) (((unsigned int)1) << ((i) % TYPE_SIZE))\\n#define BITTEST(a, i) ((((a)[BITSLOT(i)] & BITMASK(i))) != 0)\\n\\n#define BITS_MASK_SIZE 4091\\n#define ARR_LENGTH (BITS_MASK_SIZE - 1) / TYPE_SIZE + 1\\n#define SIZE_IN_BITS BITS_MASK_SIZE / BYTE_SIZE\\n\\nvoid display_hexarray(unsigned int* arr){\\n\\tprintf(\"\\\\nHexArray:\\\\n\");\\n\\tfor(unsigned int i = 0; i < ARR_LENGTH; i++){\\n\\t\\tprintf(\"%x, \", arr[i]);\\n\\t}\\n\\tprintf(\"\\\\n\");\\n}\\n\\nvoid bitwise_or_inplace(unsigned int* outArray, unsigned int* arg){\\n    for(unsigned int i = 0; i < ARR_LENGTH; i++){\\n        outArray[i] |= arg[i];\\n    }\\n}\\nvoid bitwise_shift_left(unsigned int* array, unsigned int shift){\\n\\tif(shift == 0){\\n\\t\\treturn;\\n\\t}\\n\\t//display_hexarray(array);\\n\\tunsigned int index_shift = shift / TYPE_SIZE;\\n\\tunsigned int bits_shift = shift % TYPE_SIZE;\\n\\tif(index_shift >= ARR_LENGTH) {\\n\\t\\tindex_shift = ARR_LENGTH;\\n\\t\\tbits_shift = 0;\\n\\t}\\n\\tif(bits_shift == 0){\\n\\t\\tfor(unsigned int i = ARR_LENGTH - 1; i >= index_shift; --i) {\\n\\t\\t\\tarray[i] = array[i - index_shift];\\n\\t\\t}\\n\\t\\tfor(unsigned int i = 0; i < index_shift; ++i) {\\n\\t\\t\\tarray[i] = 0;\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\tfor(unsigned int i = ARR_LENGTH - 1; i > index_shift; --i) {\\n\\t\\tarray[i] = array[i - index_shift] << bits_shift;\\n\\t\\tarray[i] |= array[i - index_shift-1] >> TYPE_SIZE - bits_shift;\\n\\t}\\n\\tarray[index_shift] = array[0] << bits_shift;\\n\\tif(index_shift <= 0) return;\\n\\tfor(unsigned int i = 0; i < index_shift; i++) {\\n\\t\\tarray[i] = 0;\\n\\t}\\n}\\n\\nint minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n\\tunsigned int min, max;\\n\\tmax = matSize * matColSize[0] * MAX_VAL;\\n\\tmin = target + max;\\n\\n\\t// This is basically a map. Each key maps to 0 or 1.\\n\\t// This mapping represents a set!\\n\\t// If an element is present in the set, the bit value is set to 1.\\n\\t// A simple shift then represents an addition over all elements in the set!\\n\\tunsigned int previousSet[ARR_LENGTH];\\n\\tmemset(previousSet, 0, SIZE_IN_BITS);\\n\\tpreviousSet[0] = 0x01;\\n\\t//display_hexarray(previousSet);\\n\\n\\tfor(unsigned int i=0; i < matSize; i++){\\n\\t\\t//printf(\"\\\\nNEXT COLUMN\\\\n\");\\n\\t\\t//display_hexarray(previousSet);\\n\\n\\t\\t// New empty map of values\\n\\t\\tunsigned int currentSet[ARR_LENGTH];\\n\\t\\tmemset(currentSet, 0, SIZE_IN_BITS);\\n\\n\\t\\tfor(unsigned int j=0; j < *matColSize; j++){\\n\\t\\t\\tunsigned int currValue = mat[i][j];\\n\\n\\t\\t\\t// Temporary array to store shift\\n\\t\\t\\t// Stores intially a copy of the previous set\\n\\t\\t\\tunsigned int tmp[ARR_LENGTH];\\n\\t\\t\\tmemcpy(tmp, previousSet, SIZE_IN_BITS);\\n\\t\\t//display_hexarray(tmp);\\n\\n\\t\\t\\t//printf(\"\\\\nVal: %i\\\\n\", currValue);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t\\t// Add current value to all elements in \"temp\"\\n\\t\\t\\tbitwise_shift_left(tmp, currValue);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t\\t// Join tmp into currentSet\\n\\t\\t\\tbitwise_or_inplace(currentSet, tmp);\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\t}\\n\\t\\t//display_hexarray(currentSet);\\n\\t\\tmemcpy(previousSet, currentSet, SIZE_IN_BITS);\\n\\t}\\n\\tfor(unsigned int currSum=0; currSum < BITS_MASK_SIZE; currSum++){\\n\\t\\t// Current Sum is present!\\n\\t\\tif(BITTEST(previousSet, currSum)){\\n\\t\\t\\t//printf(\"%i, \", currSum);\\n\\t\\t\\tunsigned int dist = abs(target - currSum);\\n\\t\\t\\tif(dist < min){\\n\\t\\t\\t\\tmin = dist;\\n\\t\\t\\t}\\n\\t\\t\\tif(min == 0) return 0;\\n\\t\\t}\\n\\t}\\n\\treturn min;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int maxSum = 70 * mat.size();\\n\\n        // This is basically a map. Each key maps to 0 or 1.\\n        // This mapping represents a set!\\n        // If an element is present in the set, the bit value is set to 1.\\n        // A simple shift then represents an addition over all elements in the set!\\n        bitset<4901> previousSet;\\n        // 0 only is present in the set\\n        previousSet[0] = 1;\\n        for(vector<int> row : mat){\\n            bitset<4901> currentSet;\\n            for(int value : row){\\n                // Add value to each element in the set\\n                // Remember, the values are represented by the keys that map to 1\\n                bitset<4901> incrementedSet = previousSet << value;\\n\\n                // Join the two sets\\n                currentSet = currentSet | incrementedSet;\\n            }\\n            previousSet = currentSet;\\n        }\\n        int minimum = abs(maxSum + target);\\n        for (int currSum = 0; currSum < 4901; ++currSum) {\\n            // Element currSum is in the set!\\n            if (previousSet[currSum]) {\\n                int distance = abs(currSum - target);\\n                minimum = min(minimum, distance);\\n            }\\n        }\\n        return minimum;\\n    }\\n};\\nint main(){\\n\\tSolution().minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3402748,
                "title": "c-dp-recursion-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int dp[71][4901];\\n    int solve(int x,int cSum,vector<vector<int>>& mat,int tar)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        if(x==n)\\n        {\\n            return abs(tar-cSum);\\n        }\\n        if(dp[x][cSum]!=-1)\\n        return dp[x][cSum];\\n        int ans = INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans = min(ans,solve(x+1,cSum+mat[x][i],mat,tar));\\n        }\\n        return dp[x][cSum] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,mat,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    int dp[71][4901];\\n    int solve(int x,int cSum,vector<vector<int>>& mat,int tar)\\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        if(x==n)\\n        {\\n            return abs(tar-cSum);\\n        }\\n        if(dp[x][cSum]!=-1)\\n        return dp[x][cSum];\\n        int ans = INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans = min(ans,solve(x+1,cSum+mat[x][i],mat,tar));\\n        }\\n        return dp[x][cSum] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,mat,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351771,
                "title": "help-getting-wa-for-same-logic-in-python-which-works-in-c",
                "content": "Python:  Getting wrong answer\\n```python\\nclass Solution:\\n    def __init__(self):\\n        self.inf = 10000000000\\n        self.dp = [[self.inf] * 4901] * 71\\n        \\n    def solve(self, row: int, curr_sum: int) -> int:\\n        if row == len(self.mat):\\n            return abs(curr_sum - self.target)\\n        \\n        if self.dp[row][curr_sum] != self.inf:\\n            return self.dp[row][curr_sum]\\n        \\n        diff = self.inf\\n        for val in self.mat[row]:\\n            diff = min(diff, self.solve(row + 1, curr_sum + val))\\n        \\n        self.dp[row][curr_sum] = diff\\n        return self.dp[row][curr_sum]\\n            \\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        self.mat, self.target = mat, target\\n        return self.solve(0, 0)\\n```\\nC++ : Getting accepted!\\n```cpp\\nclass Solution {\\npublic:\\n    int dp[71][4901];\\n    int solve(int row, int curr_sum, int target, vector<vector<int>>& mat) {\\n        if (row == mat.size()) {\\n            return abs(curr_sum - target);\\n        }\\n        \\n        if (dp[row][curr_sum] != INT_MAX) {\\n            return dp[row][curr_sum];\\n        }\\n        \\n        int diff = INT_MAX;\\n        for (int val : mat[row]) {\\n            diff = min(diff, solve(row + 1, curr_sum + val, target, mat));\\n        }\\n        \\n        return dp[row][curr_sum] = diff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        fill(&dp[0][0], &dp[0][0] + 71 * 4901, INT_MAX);\\n        return solve(0, 0, target, mat);\\n    }\\n};\\n```\\n\\nExample test case :\\n```\\n[[7,8,9,4,8,5,8,9],[9,6,8,8,6,10,9,8],[8,4,6,3,10,5,8,5],[5,9,9,9,9,10,10,7],[5,4,8,9,6,10,2,6],[1,4,2,1,10,1,5,10]]\\n21\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.inf = 10000000000\\n        self.dp = [[self.inf] * 4901] * 71\\n        \\n    def solve(self, row: int, curr_sum: int) -> int:\\n        if row == len(self.mat):\\n            return abs(curr_sum - self.target)\\n        \\n        if self.dp[row][curr_sum] != self.inf:\\n            return self.dp[row][curr_sum]\\n        \\n        diff = self.inf\\n        for val in self.mat[row]:\\n            diff = min(diff, self.solve(row + 1, curr_sum + val))\\n        \\n        self.dp[row][curr_sum] = diff\\n        return self.dp[row][curr_sum]\\n            \\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        self.mat, self.target = mat, target\\n        return self.solve(0, 0)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int dp[71][4901];\\n    int solve(int row, int curr_sum, int target, vector<vector<int>>& mat) {\\n        if (row == mat.size()) {\\n            return abs(curr_sum - target);\\n        }\\n        \\n        if (dp[row][curr_sum] != INT_MAX) {\\n            return dp[row][curr_sum];\\n        }\\n        \\n        int diff = INT_MAX;\\n        for (int val : mat[row]) {\\n            diff = min(diff, solve(row + 1, curr_sum + val, target, mat));\\n        }\\n        \\n        return dp[row][curr_sum] = diff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        fill(&dp[0][0], &dp[0][0] + 71 * 4901, INT_MAX);\\n        return solve(0, 0, target, mat);\\n    }\\n};\\n```\n```\\n[[7,8,9,4,8,5,8,9],[9,6,8,8,6,10,9,8],[8,4,6,3,10,5,8,5],[5,9,9,9,9,10,10,7],[5,4,8,9,6,10,2,6],[1,4,2,1,10,1,5,10]]\\n21\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351746,
                "title": "solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int dp[71][4901];\\n    int solve(int row, int curr_sum, int target, vector<vector<int>>& mat) {\\n        if (row == mat.size()) {\\n            return abs(curr_sum - target);\\n        }\\n        \\n        if (dp[row][curr_sum] != INT_MAX) {\\n            return dp[row][curr_sum];\\n        }\\n        \\n        int diff = INT_MAX;\\n        for (int val : mat[row]) {\\n            diff = min(diff, solve(row + 1, curr_sum + val, target, mat));\\n        }\\n        \\n        return dp[row][curr_sum] = diff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        fill(&dp[0][0], &dp[0][0] + 71 * 4901, INT_MAX);  // max value of sum can be 4900\\n        return solve(0, 0, target, mat);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int dp[71][4901];\\n    int solve(int row, int curr_sum, int target, vector<vector<int>>& mat) {\\n        if (row == mat.size()) {\\n            return abs(curr_sum - target);\\n        }\\n        \\n        if (dp[row][curr_sum] != INT_MAX) {\\n            return dp[row][curr_sum];\\n        }\\n        \\n        int diff = INT_MAX;\\n        for (int val : mat[row]) {\\n            diff = min(diff, solve(row + 1, curr_sum + val, target, mat));\\n        }\\n        \\n        return dp[row][curr_sum] = diff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        fill(&dp[0][0], &dp[0][0] + 71 * 4901, INT_MAX);  // max value of sum can be 4900\\n        return solve(0, 0, target, mat);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338917,
                "title": "rust-bottom-up-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimize_the_difference(mat: Vec<Vec<i32>>, target: i32) -> i32 {\\n        let mut dp = vec![vec![false; 5000]; mat.len() + 1];\\n        dp[0][0] = true;\\n        for i in 0..mat.len() {\\n            for j in 0..mat[0].len() {\\n                for k in 0..dp[i].len() {\\n                    if dp[i][k] {\\n                        dp[i + 1][k + mat[i][j] as usize] = true;\\n                    }\\n                }\\n            }\\n        }\\n        let mut min_diff = i32::MAX;\\n        for i in 0..5000 {\\n            if dp[mat.len()][i] {\\n                min_diff = min_diff.min((target - i as i32).abs())\\n            }\\n        }\\n        min_diff       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_the_difference(mat: Vec<Vec<i32>>, target: i32) -> i32 {\\n        let mut dp = vec![vec![false; 5000]; mat.len() + 1];\\n        dp[0][0] = true;\\n        for i in 0..mat.len() {\\n            for j in 0..mat[0].len() {\\n                for k in 0..dp[i].len() {\\n                    if dp[i][k] {\\n                        dp[i + 1][k + mat[i][j] as usize] = true;\\n                    }\\n                }\\n            }\\n        }\\n        let mut min_diff = i32::MAX;\\n        for i in 0..5000 {\\n            if dp[mat.len()][i] {\\n                min_diff = min_diff.min((target - i as i32).abs())\\n            }\\n        }\\n        min_diff       \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3317082,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[71][5000];\\n    int helper(vector<vector<int>>& mat, int target,int sum,int row)\\n    {\\n        if(row>=mat.size())\\n        {\\n            return abs(target-sum);\\n        }\\n        \\n        if(memo[row][sum]!=-1)\\n            return memo[row][sum];\\n        \\n        int res=INT_MAX;\\n        for(int i=0;i<mat[0].size();i++)\\n        {\\n            int val = helper(mat,target,sum+mat[row][i],row+1);\\n            res = min(res,val);\\n            if(res==0)\\n                break;\\n        }\\n        \\n        return memo[row][sum]=res;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(memo,-1,sizeof(memo));\\n        return helper(mat,target,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[71][5000];\\n    int helper(vector<vector<int>>& mat, int target,int sum,int row)\\n    {\\n        if(row>=mat.size())\\n        {\\n            return abs(target-sum);\\n        }\\n        \\n        if(memo[row][sum]!=-1)\\n            return memo[row][sum];\\n        \\n        int res=INT_MAX;\\n        for(int i=0;i<mat[0].size();i++)\\n        {\\n            int val = helper(mat,target,sum+mat[row][i],row+1);\\n            res = min(res,val);\\n            if(res==0)\\n                break;\\n        }\\n        \\n        return memo[row][sum]=res;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(memo,-1,sizeof(memo));\\n        return helper(mat,target,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182468,
                "title": "python-simple-using-sets-beats-99-memory",
                "content": "```\\ndef minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        pool = set(mat[0])\\n        large = float(\\'inf\\')\\n        for i in range(1, len(mat)):\\n            rowSet=set()\\n            for j in range(len(mat[0])):\\n                for ele in pool:\\n                    tot = ele+mat[i][j]\\n                    if tot >= target:\\n                        if tot < large:\\n                            large = tot\\n                    else:\\n                        rowSet.add(ele+mat[i][j])\\n            pool=rowSet\\n            rowSet.add(large)\\n            large = float(\\'inf\\')\\n        arr = sorted(pool)\\n        for i,n in enumerate(arr):\\n            if n >= target:\\n                return min(abs(n-target), abs(arr[i-1]-target))\\n        return target - arr[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        pool = set(mat[0])\\n        large = float(\\'inf\\')\\n        for i in range(1, len(mat)):\\n            rowSet=set()\\n            for j in range(len(mat[0])):\\n                for ele in pool:\\n                    tot = ele+mat[i][j]\\n                    if tot >= target:\\n                        if tot < large:\\n                            large = tot\\n                    else:\\n                        rowSet.add(ele+mat[i][j])\\n            pool=rowSet\\n            rowSet.add(large)\\n            large = float(\\'inf\\')\\n        arr = sorted(pool)\\n        for i,n in enumerate(arr):\\n            if n >= target:\\n                return min(abs(n-target), abs(arr[i-1]-target))\\n        return target - arr[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3175349,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\nint rec(int i,vector<vector<int>>& mat, int target,vector<vector<int>>&dp)\\n{\\n    if (i==n-1)\\n    {\\n        int ans=1e7;\\n        for (auto &val: mat[i])\\n        {\\n            ans=min(ans,abs(target-val));\\n            if (ans==0) break;\\n        }\\n        return dp[i][target+20000]=ans;\\n    }\\n    if (dp[i][20000+target]!=-1) return dp[i][20000+target];\\n    int ans=1e7;\\n    for (auto &val : mat[i])\\n    {\\n       ans=min(ans,rec(i+1,mat,target-val,dp));\\n       if (ans==0) break;\\n    }\\n    return dp[i][20000+target]=ans;\\n}\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        n=mat.size();\\n        m=mat[0].size();\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        } // sorting the matrix to avoid tle(this was a help from solutions)\\n        vector<vector<int>>dp(n,vector<int>(target+1+20000,-1));\\n        return rec(0,mat,target,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\nint rec(int i,vector<vector<int>>& mat, int target,vector<vector<int>>&dp)\\n{\\n    if (i==n-1)\\n    {\\n        int ans=1e7;\\n        for (auto &val: mat[i])\\n        {\\n            ans=min(ans,abs(target-val));\\n            if (ans==0) break;\\n        }\\n        return dp[i][target+20000]=ans;\\n    }\\n    if (dp[i][20000+target]!=-1) return dp[i][20000+target];\\n    int ans=1e7;\\n    for (auto &val : mat[i])\\n    {\\n       ans=min(ans,rec(i+1,mat,target-val,dp));\\n       if (ans==0) break;\\n    }\\n    return dp[i][20000+target]=ans;\\n}\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        n=mat.size();\\n        m=mat[0].size();\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        } // sorting the matrix to avoid tle(this was a help from solutions)\\n        vector<vector<int>>dp(n,vector<int>(target+1+20000,-1));\\n        return rec(0,mat,target,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049374,
                "title": "c",
                "content": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n    int m = matSize ;\\n    int n = *matColSize ;\\n    for(int i = 0; i < m; i++){\\n        qsort(mat[i], n, sizeof(int), cmp) ;\\n    }\\n    bool* exist = calloc((target+1), sizeof(bool)) ;\\n    \\n    int* set = malloc((target+1) * sizeof(int)) ;\\n    int* tmp = malloc((target+1) * sizeof(int)) ;\\n    int s_idx = 0, t_idx = 0 ;\\n    int great = INT_MAX ;\\n    for(int i = 0; i < n; i++){\\n        if(i > 0 && mat[0][i] == mat[0][i-1])\\n            continue;\\n        if( mat[0][i] > target ){\\n            great = fmin(great, mat[0][i]) ;\\n            continue ;\\n        }\\n        if( exist[ mat[0][i] ] == true )\\n            continue ;\\n        exist[ mat[0][i]] = true ;\\n        set[s_idx] = mat[0][i] ;\\n        s_idx++;\\n    }\\n    \\n    if(great != INT_MAX){\\n        set[s_idx] = great ;\\n        s_idx++;\\n    }\\n\\n    for(int i = 1; i < m; i++){\\n        exist = calloc((target + 1), sizeof(bool)) ;\\n        great = INT_MAX;\\n        t_idx = 0;\\n        for(int j = 0; j < n; j++){\\n            if(j > 0 && mat[i][j] == mat[i][j-1])\\n                continue;\\n            for(int k = 0; k < s_idx; k++){\\n                int capacity = set[k] + mat[i][j] ;\\n                if( capacity > target ){\\n                    great = fmin(great, capacity ) ;\\n                    continue;\\n                }\\n                if(exist[capacity] == true)\\n                    continue;\\n                exist[capacity] = true;\\n                tmp[t_idx] = capacity; \\n                t_idx++;\\n            }       \\n        }\\n\\n        if(great != INT_MAX){\\n            tmp[t_idx] = great ;\\n            t_idx++;\\n        }\\n        //swap : have to do this\\n        int* T = tmp;\\n        tmp = set;\\n        set = T;\\n        s_idx = t_idx;\\n    }\\n\\n    int ans = INT_MAX;\\n    for(int i = 0; i < s_idx; i++){\\n        ans = fmin(ans, abs( target - set[i] )) ;\\n    }\\n    free(exist);\\n    free(set);\\n    free(tmp);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n    int m = matSize ;\\n    int n = *matColSize ;\\n    for(int i = 0; i < m; i++){\\n        qsort(mat[i], n, sizeof(int), cmp) ;\\n    }\\n    bool* exist = calloc((target+1), sizeof(bool)) ;\\n    \\n    int* set = malloc((target+1) * sizeof(int)) ;\\n    int* tmp = malloc((target+1) * sizeof(int)) ;\\n    int s_idx = 0, t_idx = 0 ;\\n    int great = INT_MAX ;\\n    for(int i = 0; i < n; i++){\\n        if(i > 0 && mat[0][i] == mat[0][i-1])\\n            continue;\\n        if( mat[0][i] > target ){\\n            great = fmin(great, mat[0][i]) ;\\n            continue ;\\n        }\\n        if( exist[ mat[0][i] ] == true )\\n            continue ;\\n        exist[ mat[0][i]] = true ;\\n        set[s_idx] = mat[0][i] ;\\n        s_idx++;\\n    }\\n    \\n    if(great != INT_MAX){\\n        set[s_idx] = great ;\\n        s_idx++;\\n    }\\n\\n    for(int i = 1; i < m; i++){\\n        exist = calloc((target + 1), sizeof(bool)) ;\\n        great = INT_MAX;\\n        t_idx = 0;\\n        for(int j = 0; j < n; j++){\\n            if(j > 0 && mat[i][j] == mat[i][j-1])\\n                continue;\\n            for(int k = 0; k < s_idx; k++){\\n                int capacity = set[k] + mat[i][j] ;\\n                if( capacity > target ){\\n                    great = fmin(great, capacity ) ;\\n                    continue;\\n                }\\n                if(exist[capacity] == true)\\n                    continue;\\n                exist[capacity] = true;\\n                tmp[t_idx] = capacity; \\n                t_idx++;\\n            }       \\n        }\\n\\n        if(great != INT_MAX){\\n            tmp[t_idx] = great ;\\n            t_idx++;\\n        }\\n        //swap : have to do this\\n        int* T = tmp;\\n        tmp = set;\\n        set = T;\\n        s_idx = t_idx;\\n    }\\n\\n    int ans = INT_MAX;\\n    for(int i = 0; i < s_idx; i++){\\n        ans = fmin(ans, abs( target - set[i] )) ;\\n    }\\n    free(exist);\\n    free(set);\\n    free(tmp);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031014,
                "title": "python-bruteforce",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        min_possible = sum(min(row) for row in mat)\\n        if min_possible >= target: return min_possible - target\\n        curs = {0}\\n        for row in mat:\\n            curs = {x + y for x in row for y in curs if x + y <= 2*target}\\n        return min(abs(target - x) for x in curs)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        min_possible = sum(min(row) for row in mat)\\n        if min_possible >= target: return min_possible - target\\n        curs = {0}\\n        for row in mat:\\n            curs = {x + y for x in row for y in curs if x + y <= 2*target}\\n        return min(abs(target - x) for x in curs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007018,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer dp[][];\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp=new Integer[mat.length][70*70];\\n        return mc(mat,target,0,0);\\n    }\\n    public int mc(int[][]mat,int target,int sum,int i){\\nif(i==mat.length)\\nreturn Math.abs(target-sum);\\nint ans=Integer.MAX_VALUE;\\nif(dp[i][sum]!=null)\\nreturn dp[i][sum];\\n\\n        for(int j=0;j<mat[0].length;j++){\\n            ans=Math.min(mc(mat,target,sum+mat[i][j],i+1),ans);\\n        }\\n         return dp[i][sum]=ans;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        dp=new Integer[mat.length][70*70];\\n        return mc(mat,target,0,0);\\n    }\\n    public int mc(int[][]mat,int target,int sum,int i){\\nif(i==mat.length)\\nreturn Math.abs(target-sum);\\nint ans=Integer.MAX_VALUE;\\nif(dp[i][sum]!=null)\\nreturn dp[i][sum];\\n\\n        for(int j=0;j<mat[0].length;j++){\\n            ans=Math.min(mc(mat,target,sum+mat[i][j],i+1),ans);\\n        }\\n         return dp[i][sum]=ans;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952431,
                "title": "c-bitset-solution-beats-99-for-time-and-space",
                "content": "Since `m, n <= 70` and `mat[i][j] <= 70`, we can use a bitset with size 4900 to represent all possible sum of one elements from each row.\\n\\n`prev` stores all the last-step possible sum, while move the whole set by `mat[i][j]` position to represent all the states of adding this element, and we concatenate all combinations to `next` by using bitset\\'s `|=` operator.\\n\\nTime complexity: $$O(n^3)$$\\nSpace complexity: $$O(n^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<4900> prev, next;\\n        int m = mat.size(), n = mat[0].size();\\n        for (int i = 0; i < n; i++) {\\n            prev[mat[0][i]] = 1;\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                next |= prev << mat[i][j];\\n            }\\n            prev = next;\\n            next.reset();\\n        }\\n        int ans = INT_MAX;\\n        for (int i = 0; i <= 4900; i++) {\\n            if (prev[i]) {\\n                ans = min(ans, abs(i - target));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<4900> prev, next;\\n        int m = mat.size(), n = mat[0].size();\\n        for (int i = 0; i < n; i++) {\\n            prev[mat[0][i]] = 1;\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                next |= prev << mat[i][j];\\n            }\\n            prev = next;\\n            next.reset();\\n        }\\n        int ans = INT_MAX;\\n        for (int i = 0; i <= 4900; i++) {\\n            if (prev[i]) {\\n                ans = min(ans, abs(i - target));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938490,
                "title": "c-dp-recursion-memoization",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, vector<vector<int>> &mat, int target, int idx, int curr_sum)\\n    {\\n        int n = mat.size(), m = mat[0].size();\\n        if(dp[idx][curr_sum]!=-1)return dp[idx][curr_sum];\\n        if(idx == n)return dp[idx][curr_sum] = abs(curr_sum - target);\\n        int ans = INT_MAX;\\n        for(int i=0;i<m;i++)ans = min(ans, solve(dp, mat, target, idx+1, curr_sum + mat[idx][i]));\\n        return dp[idx][curr_sum]= ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target){\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> dp(n+1, vector<int> (70*70 + 1, -1));\\n        return solve(dp,mat, target, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, vector<vector<int>> &mat, int target, int idx, int curr_sum)\\n    {\\n        int n = mat.size(), m = mat[0].size();\\n        if(dp[idx][curr_sum]!=-1)return dp[idx][curr_sum];\\n        if(idx == n)return dp[idx][curr_sum] = abs(curr_sum - target);\\n        int ans = INT_MAX;\\n        for(int i=0;i<m;i++)ans = min(ans, solve(dp, mat, target, idx+1, curr_sum + mat[idx][i]));\\n        return dp[idx][curr_sum]= ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target){\\n        int n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> dp(n+1, vector<int> (70*70 + 1, -1));\\n        return solve(dp,mat, target, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818283,
                "title": "dynamic-programming",
                "content": "```\\nclass Solution {\\n    int target;\\n    int dp[4901][71];\\npublic:\\n    int rec(vector<vector<int>>& a, int sum, int ind, int n, int m){\\n        if(ind==n){\\n            return abs(sum-target);\\n        }\\n        if(dp[sum][ind]!=-1) return dp[sum][ind];\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans, rec(a, sum+a[ind][i], ind+1, n, m));\\n            if(ans==0) return 0;\\n        }\\n        dp[sum][ind]=ans;\\n        return ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& a, int x) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        for(int i=0;i<4901;i++){\\n            for(int j=0;j<71;j++) dp[i][j]=-1;\\n        }\\n        target=x;\\n        return rec(a,0,0,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int target;\\n    int dp[4901][71];\\npublic:\\n    int rec(vector<vector<int>>& a, int sum, int ind, int n, int m){\\n        if(ind==n){\\n            return abs(sum-target);\\n        }\\n        if(dp[sum][ind]!=-1) return dp[sum][ind];\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans, rec(a, sum+a[ind][i], ind+1, n, m));\\n            if(ans==0) return 0;\\n        }\\n        dp[sum][ind]=ans;\\n        return ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& a, int x) {\\n        int n=a.size();\\n        int m=a[0].size();\\n        for(int i=0;i<4901;i++){\\n            for(int j=0;j<71;j++) dp[i][j]=-1;\\n        }\\n        target=x;\\n        return rec(a,0,0,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802805,
                "title": "no-tle",
                "content": "```\\nclass Solution {\\nprivate:\\n    int helper(int r, int sum, vector<vector<int>>& mat, int target, vector<vector<int>>& dp){\\n        if(r == mat.size())\\n            return abs(sum - target);\\n        \\n        if(dp[r][sum] != -1)\\n            return dp[r][sum];\\n        \\n        int ans = INT_MAX;\\n        for(int i = 0; i < mat[0].size(); i++){\\n            int temp = helper(r + 1, sum + mat[r][i], mat, target, dp);\\n            if(ans==0)\\n                break;\\n            ans = min(ans, temp);\\n        }\\n        return dp[r][sum] = ans;\\n    }\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n = mat.size();\\n        vector<vector<int>> dp(n, vector<int>(4901, -1));\\n        // sort the matrix it will avoid TLE\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n        return helper(0, 0, mat, target, dp);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int r, int sum, vector<vector<int>>& mat, int target, vector<vector<int>>& dp){\\n        if(r == mat.size())\\n            return abs(sum - target);\\n        \\n        if(dp[r][sum] != -1)\\n            return dp[r][sum];\\n        \\n        int ans = INT_MAX;\\n        for(int i = 0; i < mat[0].size(); i++){\\n            int temp = helper(r + 1, sum + mat[r][i], mat, target, dp);\\n            if(ans==0)\\n                break;\\n            ans = min(ans, temp);\\n        }\\n        return dp[r][sum] = ans;\\n    }\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n = mat.size();\\n        vector<vector<int>> dp(n, vector<int>(4901, -1));\\n        // sort the matrix it will avoid TLE\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n        return helper(0, 0, mat, target, dp);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755564,
                "title": "knapsack-dp-tc-o-m-n-target-most-optimal",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        // we can solve this question using dynamic programming and greedy strategy\\n        // this problem is kinda like knapsack dp with some major modifications\\n        // the main trick is to handle the edge cases\\n\\n        int m=mat.size(), n=mat[0].size();\\n\\n        // precompute the smallest element in each row\\n        vector<int> row_min(m);\\n\\n        for(int i=0; i<m; i++) {\\n            row_min[i] = mat[i][0];\\n\\n            for(int j=1; j<n; j++) {\\n                row_min[i] = min(row_min[i], mat[i][j]);\\n            }\\n        }\\n\\n        vector<vector<int>> memo(m, vector<int>(target+1, -1));\\n\\n        function<int(int,int)> solve = [&](int i, int target) {\\n            if(i == m) return abs(target);\\n            if(target < 0) {\\n                // since the target is less than 0, adding larger elements will only increase the absolute difference\\n                // hence, for the remaining rows, choose the smallest elements and compute the difference\\n                // we are greedily choosing the smaller values for the remaining rows....\\n                int remaining_sum = accumulate(row_min.begin()+i, row_min.end(), 0);\\n                return abs(target-remaining_sum);\\n            }            \\n            if(memo[i][target] != -1) return memo[i][target];\\n\\n            int result = INT_MAX;\\n\\n            // try all the elements in the current row as any of them may lead to the optimal solution\\n            for(int j=0; j<n; j++) {\\n                result = min(result, solve(i+1, target-mat[i][j]));\\n            }\\n\\n            return memo[i][target] = result;\\n        };\\n\\n        return solve(0, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        // we can solve this question using dynamic programming and greedy strategy\\n        // this problem is kinda like knapsack dp with some major modifications\\n        // the main trick is to handle the edge cases\\n\\n        int m=mat.size(), n=mat[0].size();\\n\\n        // precompute the smallest element in each row\\n        vector<int> row_min(m);\\n\\n        for(int i=0; i<m; i++) {\\n            row_min[i] = mat[i][0];\\n\\n            for(int j=1; j<n; j++) {\\n                row_min[i] = min(row_min[i], mat[i][j]);\\n            }\\n        }\\n\\n        vector<vector<int>> memo(m, vector<int>(target+1, -1));\\n\\n        function<int(int,int)> solve = [&](int i, int target) {\\n            if(i == m) return abs(target);\\n            if(target < 0) {\\n                // since the target is less than 0, adding larger elements will only increase the absolute difference\\n                // hence, for the remaining rows, choose the smallest elements and compute the difference\\n                // we are greedily choosing the smaller values for the remaining rows....\\n                int remaining_sum = accumulate(row_min.begin()+i, row_min.end(), 0);\\n                return abs(target-remaining_sum);\\n            }            \\n            if(memo[i][target] != -1) return memo[i][target];\\n\\n            int result = INT_MAX;\\n\\n            // try all the elements in the current row as any of them may lead to the optimal solution\\n            for(int j=0; j<n; j++) {\\n                result = min(result, solve(i+1, target-mat[i][j]));\\n            }\\n\\n            return memo[i][target] = result;\\n        };\\n\\n        return solve(0, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751500,
                "title": "c-clean-code-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int dp[8000][71];\\n    int n,m;\\n    int find(vector<vector<int>>&mat,int r,int sum,int &target)\\n    {\\n        if(r>=n)\\n        {\\n            return abs(sum-target);\\n        }\\n        if(dp[sum][r]!=-1)\\n        {\\n            return dp[sum][r];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans=min(ans,find(mat,r+1,sum+mat[r][i],target));\\n            if(ans==0)\\n            {\\n                break;\\n            }\\n        }\\n        return dp[sum][r]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,target);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[8000][71];\\n    int n,m;\\n    int find(vector<vector<int>>&mat,int r,int sum,int &target)\\n    {\\n        if(r>=n)\\n        {\\n            return abs(sum-target);\\n        }\\n        if(dp[sum][r]!=-1)\\n        {\\n            return dp[sum][r];\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n            ans=min(ans,find(mat,r+1,sum+mat[r][i],target));\\n            if(ans==0)\\n            {\\n                break;\\n            }\\n        }\\n        return dp[sum][r]=ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,target);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742072,
                "title": "c-a-little-cheesy-solution-to-get-ac",
                "content": "Vectors are slow so convert everything to arrays and make them global to speed things up. Beats 70%.\\n\\n```\\nclass Solution {\\npublic:\\n    int memo[4901][70]; // sum, row\\n    int arr[71][71] = {};\\n    int ROWS;\\n    int COLS;\\n    int dfs(int i, int target, int sum){\\n        if(i >= ROWS) return abs(sum-target);\\n        if(memo[sum][i] != -1) return memo[sum][i];\\n        int ans = 10e8;\\n        for(int j = 0; j < COLS; j++) ans = min(ans, dfs(i+1, target, sum+arr[i][j]));\\n        return memo[sum][i] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(memo, -1, sizeof memo);\\n        ROWS = mat.size();\\n        COLS = mat[0].size();\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[0].size(); j++) arr[i][j] = mat[i][j];\\n        }\\n        return dfs(0, target, 0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int memo[4901][70]; // sum, row\\n    int arr[71][71] = {}",
                "codeTag": "Java"
            },
            {
                "id": 2702641,
                "title": "java-pure-dp-method",
                "content": "```\\n        int[][] dp = new int[mat.length + 1][5000];\\n        for (int i = 0; i < dp.length; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        }\\n        for (int i = 0; i < 5000; i++) {\\n            dp[mat.length][i] = Math.abs(i - target);\\n        }\\n        for (int i = mat.length - 1; i >= 0; i--) {\\n            int r = Integer.MAX_VALUE;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                for (int k = 0; k < 5000; k++) {\\n                    int t = k + mat[i][j];\\n                    if (t >= 5000) {\\n                        break;\\n                    }\\n                    dp[i][k] = Math.min(dp[i][k], dp[i + 1][t]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n```",
                "solutionTags": [],
                "code": "```\\n        int[][] dp = new int[mat.length + 1][5000];\\n        for (int i = 0; i < dp.length; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        }\\n        for (int i = 0; i < 5000; i++) {\\n            dp[mat.length][i] = Math.abs(i - target);\\n        }\\n        for (int i = mat.length - 1; i >= 0; i--) {\\n            int r = Integer.MAX_VALUE;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                for (int k = 0; k < 5000; k++) {\\n                    int t = k + mat[i][j];\\n                    if (t >= 5000) {\\n                        break;\\n                    }\\n                    dp[i][k] = Math.min(dp[i][k], dp[i + 1][t]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683169,
                "title": "python-solution-faster-93",
                "content": "\\tclass Solution:\\n\\t\\tdef minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\t\\t\\tR, C = len(mat), len(mat[0])\\n\\n\\t\\t\\tS = set(mat[0])\\n\\t\\t\\tfor r in range(1, R):\\n\\t\\t\\t\\tNS = set()\\n\\t\\t\\t\\tfor x in set(mat[r]):\\n\\t\\t\\t\\t\\tfor y in S:\\n\\t\\t\\t\\t\\t\\tNS.add(x + y)\\n\\t\\t\\t\\tS = NS\\n\\n\\t\\t\\treturn min(abs(x - target) for x in S)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\t\\t\\tR, C = len(mat), len(mat[0])\\n\\n\\t\\t\\tS = set(mat[0])\\n\\t\\t\\tfor r in range(1, R):\\n\\t\\t\\t\\tNS = set()\\n\\t\\t\\t\\tfor x in set(mat[r]):\\n\\t\\t\\t\\t\\tfor y in S:\\n\\t\\t\\t\\t\\t\\tNS.add(x + y)\\n\\t\\t\\t\\tS = NS\\n\\n\\t\\t\\treturn min(abs(x - target) for x in S)",
                "codeTag": "Java"
            },
            {
                "id": 2639174,
                "title": "tc-100-bitset-tc-85-dp-pruning-explained-python",
                "content": "**Python**\\n```\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        #there are (no_cols)^(no_rows) ways of choosing elements, 70^70 is too large\\n        m = len(mat); n = len(mat[0])\\n        \\n        #DP Approach: TC:85% 4000ms\\n        for i in range(m):\\n            mat[i] = sorted(mat[i])\\n        \\n        @lru_cache(None)\\n        def dp(row, target):\\n            if target < 0:#since target < 0, choose the smallest remaining elements\\n                return sum([mat[i][0] for i in range(row, m)])\\n            if row == m:\\n                return 0\\n            \\n            c_best = inf\\n            for col in range(n):\\n                s = dp(row + 1, target - mat[row][col])\\n                if abs(s + mat[row][col] - target) < abs(c_best - target):\\n                    c_best = s + mat[row][col]\\n                    if c_best == target: return c_best #if target is found, no need to search further\\n            \\n            return c_best\\n        \\n        return abs(dp(0, target) - target)\\n\\n        \\n        #Bit set approach\\n        #TC:100%, 185ms\\n        \\n        #store all possibe sums u can in a mask\\n        #since max(mat[i][j]) = 70, 70*70=4900 bits which is not that large, so storing in mask is possible\\n        \\n        mask = 1 #mask represents all the prev sums stored,\\n        #mask = 1, means prev_sum contains 0, mask = 10111 means prev_sum contains 4,2,1,0\\n\\n        for row in mat:\\n            next_mask = 0\\n            for num in row:\\n                #u can pair all prev sums with num\\n                next_mask |= (mask << num)\\n            mask = next_mask\\n        #start from min deviation of 0, if not found go to 1, if not found go to 2, ans so on....\\n        for deviation in count():\\n            for num in (target - deviation, target + deviation):\\n                if num >= 0 and mask & (1 << num):\\n                    return deviation\\n```\\n**C++ DP TC:85% 736ms**\\n```\\n    vector<vector<int>> dp{70, vector<int>(4901, -1)};\\n    int dfs(int row, int c_target, int& m, int& n, vector<vector<int>>& mat){\\n        if (row == m){\\n            return 0;\\n        }\\n        if (c_target < 0){\\n            int c_sum = 0;\\n            for (int i = row; i<m; i++){\\n                c_sum += mat[i][0];\\n            }\\n            return c_sum;\\n        }\\n        \\n        if (dp[row][c_target] != -1){\\n            return dp[row][c_target];\\n        }\\n        \\n        dp[row][c_target] = 4900;\\n        for (int j = 0; j < n; j++){\\n            int s = dfs(row + 1, c_target - mat[row][j], m, n, mat);\\n            if (abs(s + mat[row][j] - c_target) < abs(dp[row][c_target] - c_target)){\\n                dp[row][c_target] = s + mat[row][j];\\n                if (dp[row][c_target] == c_target) return c_target;\\n            }\\n        }\\n        return dp[row][c_target];\\n\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size(); int n = mat[0].size();\\n        \\n        for(int row = 0; row < m; row++){\\n            sort(mat[row].begin(), mat[row].end());\\n        }\\n        \\n        return abs(dfs(0, target, m, n, mat) - target);\\n        \\n    }\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        #there are (no_cols)^(no_rows) ways of choosing elements, 70^70 is too large\\n        m = len(mat); n = len(mat[0])\\n        \\n        #DP Approach: TC:85% 4000ms\\n        for i in range(m):\\n            mat[i] = sorted(mat[i])\\n        \\n        @lru_cache(None)\\n        def dp(row, target):\\n            if target < 0:#since target < 0, choose the smallest remaining elements\\n                return sum([mat[i][0] for i in range(row, m)])\\n            if row == m:\\n                return 0\\n            \\n            c_best = inf\\n            for col in range(n):\\n                s = dp(row + 1, target - mat[row][col])\\n                if abs(s + mat[row][col] - target) < abs(c_best - target):\\n                    c_best = s + mat[row][col]\\n                    if c_best == target: return c_best #if target is found, no need to search further\\n            \\n            return c_best\\n        \\n        return abs(dp(0, target) - target)\\n\\n        \\n        #Bit set approach\\n        #TC:100%, 185ms\\n        \\n        #store all possibe sums u can in a mask\\n        #since max(mat[i][j]) = 70, 70*70=4900 bits which is not that large, so storing in mask is possible\\n        \\n        mask = 1 #mask represents all the prev sums stored,\\n        #mask = 1, means prev_sum contains 0, mask = 10111 means prev_sum contains 4,2,1,0\\n\\n        for row in mat:\\n            next_mask = 0\\n            for num in row:\\n                #u can pair all prev sums with num\\n                next_mask |= (mask << num)\\n            mask = next_mask\\n        #start from min deviation of 0, if not found go to 1, if not found go to 2, ans so on....\\n        for deviation in count():\\n            for num in (target - deviation, target + deviation):\\n                if num >= 0 and mask & (1 << num):\\n                    return deviation\\n```\n```\\n    vector<vector<int>> dp{70, vector<int>(4901, -1)};\\n    int dfs(int row, int c_target, int& m, int& n, vector<vector<int>>& mat){\\n        if (row == m){\\n            return 0;\\n        }\\n        if (c_target < 0){\\n            int c_sum = 0;\\n            for (int i = row; i<m; i++){\\n                c_sum += mat[i][0];\\n            }\\n            return c_sum;\\n        }\\n        \\n        if (dp[row][c_target] != -1){\\n            return dp[row][c_target];\\n        }\\n        \\n        dp[row][c_target] = 4900;\\n        for (int j = 0; j < n; j++){\\n            int s = dfs(row + 1, c_target - mat[row][j], m, n, mat);\\n            if (abs(s + mat[row][j] - c_target) < abs(dp[row][c_target] - c_target)){\\n                dp[row][c_target] = s + mat[row][j];\\n                if (dp[row][c_target] == c_target) return c_target;\\n            }\\n        }\\n        return dp[row][c_target];\\n\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size(); int n = mat[0].size();\\n        \\n        for(int row = 0; row < m; row++){\\n            sort(mat[row].begin(), mat[row].end());\\n        }\\n        \\n        return abs(dfs(0, target, m, n, mat) - target);\\n        \\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2636044,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[71][5000];\\n    \\n    int solve(int i,int sum,vector<vector<int>>& mat, int target){\\n        if(i>=mat.size()) return abs(sum-target);\\n        if(dp[i][sum]!=-1) return dp[i][sum];\\n        \\n        int mindiff = INT_MAX;\\n        for(int j = 0;j<mat[0].size();j++){\\n            mindiff = min(mindiff,solve(i+1,sum+mat[i][j],mat,target));\\n            if(mindiff==0) return dp[i][sum] = 0;\\n        }\\n        return dp[i][sum] = mindiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,mat,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[71][5000];\\n    \\n    int solve(int i,int sum,vector<vector<int>>& mat, int target){\\n        if(i>=mat.size()) return abs(sum-target);\\n        if(dp[i][sum]!=-1) return dp[i][sum];\\n        \\n        int mindiff = INT_MAX;\\n        for(int j = 0;j<mat[0].size();j++){\\n            mindiff = min(mindiff,solve(i+1,sum+mat[i][j],mat,target));\\n            if(mindiff==0) return dp[i][sum] = 0;\\n        }\\n        return dp[i][sum] = mindiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,mat,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601021,
                "title": "simple-intuitive-dynamic-programming-solution-using-c-map-pair-int-int-int",
                "content": "This solution is easy to understand but is accepted, not TLE. You can improve it in several ways:\\n\\n- using unordered_map<pair<int, int>, int>: tested, 40% faster (ask me how if you find any issue on using pairs and unordered_maps)\\n- using a vector of unordered_map<int, int>: tested, 40% faster\\n- using a pre-allocated fixed 2D grid: tested, 80% faster but requres ruge memory\\n- removing duplicates in rows\\n- using the trick of shift left and bitset<4901> class: incredible fast `O(N*M)` solution\\n```\\n    int dfs_distance(vector<vector<int>>& mat, int target, int row_index, int acc, map<pair<int, int>, int> &memory) {\\n        \\n        if (row_index == mat.size())\\n            return abs(acc - target);\\n        \\n        pair<int,int> key = make_pair(row_index, acc);\\n        \\n        if (memory.find(key) != memory.end()) //using the cached value\\n            return memory[key];\\n        \\n        vector<int> &row = mat[row_index];\\n        int diff = INT_MAX;\\n        for (int i = 0, S = row.size(); i < S; ++i) {\\n            int v = row[i];\\n            int current_diff = dfs_distance(mat, target, row_index + 1, acc + v, memory);\\n            diff = min(diff, current_diff);\\n            if (diff == 0 || acc + v > target)\\n                break;\\n        }\\n        \\n        memory[key] = diff;\\n        \\n        return diff;\\n    }\\n\\n    int DP(vector<vector<int>>& mat, int target) {\\n\\n        for (vector<int> &row : mat) {\\n            sort(row.begin(), row.end());\\n        }\\n\\n        int rows = mat.size();\\n        map<pair<int, int>, int> memory;\\n        \\n        return dfs_distance(mat, target, 0, 0, memory);\\n\\n    }\\n\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        return DP(mat, target);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int dfs_distance(vector<vector<int>>& mat, int target, int row_index, int acc, map<pair<int, int>, int> &memory) {\\n        \\n        if (row_index == mat.size())\\n            return abs(acc - target);\\n        \\n        pair<int,int> key = make_pair(row_index, acc);\\n        \\n        if (memory.find(key) != memory.end()) //using the cached value\\n            return memory[key];\\n        \\n        vector<int> &row = mat[row_index];\\n        int diff = INT_MAX;\\n        for (int i = 0, S = row.size(); i < S; ++i) {\\n            int v = row[i];\\n            int current_diff = dfs_distance(mat, target, row_index + 1, acc + v, memory);\\n            diff = min(diff, current_diff);\\n            if (diff == 0 || acc + v > target)\\n                break;\\n        }\\n        \\n        memory[key] = diff;\\n        \\n        return diff;\\n    }\\n\\n    int DP(vector<vector<int>>& mat, int target) {\\n\\n        for (vector<int> &row : mat) {\\n            sort(row.begin(), row.end());\\n        }\\n\\n        int rows = mat.size();\\n        map<pair<int, int>, int> memory;\\n        \\n        return dfs_distance(mat, target, 0, 0, memory);\\n\\n    }\\n\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        return DP(mat, target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587191,
                "title": "java-memoized-short-solution",
                "content": "class Solution {\\n    \\n    private int helper(int row, int cols, int[][] mat, int target, int sum,int[][] dp){\\n        if(row==-1)\\n            return Math.abs(sum-target);\\n        if(dp[row][sum]!= -1)\\n            return dp[row][sum];\\n        int min = (int) 1e8;\\n        for(int i=0;i<cols;i++){\\n            int val = helper(row-1,cols,mat,target,sum+mat[row][i],dp);\\n            min = Math.min(val,min);\\n        }\\n        return dp[row][sum]=min;\\n        \\n    }\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[][] dp = new int[m][9999];\\n        for(int[] row: dp)\\n            Arrays.fill(row,-1);\\n        return helper(m-1,n,mat,target,0,dp);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\n    private int helper(int row, int cols, int[][] mat, int target, int sum,int[][] dp){\\n        if(row==-1)\\n            return Math.abs(sum-target);\\n        if(dp[row][sum]!= -1)\\n            return dp[row][sum];\\n        int min = (int) 1e8;\\n        for(int i=0;i<cols;i++){\\n            int val = helper(row-1,cols,mat,target,sum+mat[row][i],dp);\\n            min = Math.min(val,min);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2579528,
                "title": "iterative-dfs-c",
                "content": "```\\n1. Start by taking 0 as our sum and push it in queue.\\n2. Now consider a row as a whole level and iterate the row.\\n3. Prevsum will be the front element of queue.\\n4. While iterating update our currsum as prevsum + curr element.\\n5.  Now if this is smaller than target then push it to our queue.\\n6. Else we need to keep the smallest element greater than target as pushing greater will not benefit us.\\n7. Now at the end of the row push the smallest greater element in queue.\\n8. After all the rows are done. We have all the sums possible in our queue. Check the min diff.\\n```\\n```\\ntypedef vector<vector<int>> v2i;\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n = mat.size(), m = mat[0].size();\\n        queue<int> q; q.push(0);\\n        int currSum, currRowMinSum;\\n        int row = 0;\\n        v2i rowSum(n, vector<int>(4900,0));\\n        rowSum[0][0] = 1;\\n        while(!q.empty() && row < n){\\n            int sz = q.size();\\n            currRowMinSum = 4900;\\n            while(sz--){\\n                int prevSum = q.front(); q.pop();\\n                for(int col=0; col<m; col++){\\n                    currSum = prevSum + mat[row][col];\\n                    if(!rowSum[row][currSum]){\\n                        rowSum[row][currSum] = 1;\\n                        if(currSum <= target) q.push(currSum);\\n                        else if(currSum < currRowMinSum){\\n                            currRowMinSum = currSum;\\n                        }\\n                    }\\n                }\\n            }\\n            if(currRowMinSum != 4900) q.push(currRowMinSum);\\n            row++;\\n        }\\n        int mn = 4900;\\n        while(!q.empty()){\\n            mn = min(mn, abs(target-q.front()));\\n            if(mn == 0) return 0;\\n            q.pop();\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n1. Start by taking 0 as our sum and push it in queue.\\n2. Now consider a row as a whole level and iterate the row.\\n3. Prevsum will be the front element of queue.\\n4. While iterating update our currsum as prevsum + curr element.\\n5.  Now if this is smaller than target then push it to our queue.\\n6. Else we need to keep the smallest element greater than target as pushing greater will not benefit us.\\n7. Now at the end of the row push the smallest greater element in queue.\\n8. After all the rows are done. We have all the sums possible in our queue. Check the min diff.\\n```\n```\\ntypedef vector<vector<int>> v2i;\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n = mat.size(), m = mat[0].size();\\n        queue<int> q; q.push(0);\\n        int currSum, currRowMinSum;\\n        int row = 0;\\n        v2i rowSum(n, vector<int>(4900,0));\\n        rowSum[0][0] = 1;\\n        while(!q.empty() && row < n){\\n            int sz = q.size();\\n            currRowMinSum = 4900;\\n            while(sz--){\\n                int prevSum = q.front(); q.pop();\\n                for(int col=0; col<m; col++){\\n                    currSum = prevSum + mat[row][col];\\n                    if(!rowSum[row][currSum]){\\n                        rowSum[row][currSum] = 1;\\n                        if(currSum <= target) q.push(currSum);\\n                        else if(currSum < currRowMinSum){\\n                            currRowMinSum = currSum;\\n                        }\\n                    }\\n                }\\n            }\\n            if(currRowMinSum != 4900) q.push(currRowMinSum);\\n            row++;\\n        }\\n        int mn = 4900;\\n        while(!q.empty()){\\n            mn = min(mn, abs(target-q.front()));\\n            if(mn == 0) return 0;\\n            q.pop();\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558094,
                "title": "kotlin-dp-fastest",
                "content": "```\\nclass Solution {\\n    private val minDiff = mutableMapOf<Int, Int>()\\n    \\n    fun minimizeTheDifference(mat: Array<IntArray>, target: Int): Int {\\n        return getMinDiff(mat, 0, target)\\n    }\\n    \\n    fun getMinDiff(mat: Array<IntArray>, firstRow: Int, target: Int): Int {\\n        var cached = minDiff[firstRow * 1000 + target]\\n        if (cached == null) {\\n            var min = Int.MAX_VALUE\\n            for(value in mat[firstRow]) {\\n                val diff = if (firstRow >= mat.size - 1) {\\n                    Math.abs(target - value)\\n                } else if (target - value < 0) {\\n                    getMinDiff(mat, firstRow + 1, 0) - (target - value)\\n                } else {\\n                    getMinDiff(mat, firstRow + 1, target - value)\\n                }\\n\\n                min = Math.min(min, diff)\\n            }\\n            cached = min\\n            minDiff[firstRow * 1000 + target] = min\\n        }\\n        \\n        return cached\\n    }\\n}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    private val minDiff = mutableMapOf<Int, Int>()\\n    \\n    fun minimizeTheDifference(mat: Array<IntArray>, target: Int): Int {\\n        return getMinDiff(mat, 0, target)\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2473143,
                "title": "sumset-python",
                "content": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        rows,cols=len(mat),len(mat[0])\\n        # nm=[[70 for i in range(70)]for j in  range(70)]\\n        # print(nm)\\n        sumset=set()\\n        sumset.add(0)\\n        smallest=0\\n        for r in range(rows):\\n            smallest+=min(mat[r])\\n            \\n        if smallest>=target:\\n            # print(\"ho\")\\n            return smallest-target\\n        for r in range(rows):\\n            k=set()\\n            for c in range(cols):\\n                for i in sumset:\\n                    if i+mat[r][c]<=2*target-smallest:\\n                        \\n                        k.add(i+mat[r][c])\\n                    \\n            sumset=k\\n            \\n        return min(abs(target-i) for i in sumset)\\n            \\n        # print(sumset)\\n        # res=inf\\n        # for i in sumset:\\n        #     h=abs(target-i)\\n        #     res=min(res,h)\\n        # return res\\n        \\n                    \\n                # if mat[]\\n                \\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        rows,cols=len(mat),len(mat[0])\\n        # nm=[[70 for i in range(70)]for j in  range(70)]\\n        # print(nm)\\n        sumset=set()\\n        sumset.add(0)\\n        smallest=0\\n        for r in range(rows):\\n            smallest+=min(mat[r])\\n            \\n        if smallest>=target:\\n            # print(\"ho\")\\n            return smallest-target\\n        for r in range(rows):\\n            k=set()\\n            for c in range(cols):\\n                for i in sumset:\\n                    if i+mat[r][c]<=2*target-smallest:\\n                        \\n                        k.add(i+mat[r][c])\\n                    \\n            sumset=k\\n            \\n        return min(abs(target-i) for i in sumset)\\n            \\n        # print(sumset)\\n        # res=inf\\n        # for i in sumset:\\n        #     h=abs(target-i)\\n        #     res=min(res,h)\\n        # return res\\n        \\n                    \\n                # if mat[]\\n                \\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460634,
                "title": "60-c-solution",
                "content": "Just Recursively Iterate through each possible combination, memoize it!\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[5000][71];\\n    int rows,cols;\\n    int helper(vector<vector<int>>& mat,int& target,int r,int sum){\\n        if(r == rows){\\n            return abs(sum - target);\\n        }\\n        \\n        if(dp[sum][r] != -1){\\n            return dp[sum][r];\\n        }\\n        int minDiff = INT_MAX;\\n        for(int j = 0;j<cols;j++){\\n            minDiff = min(minDiff,helper(mat,target,r+1,sum+mat[r][j]));\\n        }\\n        \\n        return dp[sum][r] = minDiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        rows =  mat.size();\\n        cols = mat[0].size();\\n        memset(dp,-1,sizeof dp);\\n        // vector<vector<int>> dp(9000,vector<int>(rows,-1));\\n        \\n        return helper(mat,target,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5000][71];\\n    int rows,cols;\\n    int helper(vector<vector<int>>& mat,int& target,int r,int sum){\\n        if(r == rows){\\n            return abs(sum - target);\\n        }\\n        \\n        if(dp[sum][r] != -1){\\n            return dp[sum][r];\\n        }\\n        int minDiff = INT_MAX;\\n        for(int j = 0;j<cols;j++){\\n            minDiff = min(minDiff,helper(mat,target,r+1,sum+mat[r][j]));\\n        }\\n        \\n        return dp[sum][r] = minDiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        rows =  mat.size();\\n        cols = mat[0].size();\\n        memset(dp,-1,sizeof dp);\\n        // vector<vector<int>> dp(9000,vector<int>(rows,-1));\\n        \\n        return helper(mat,target,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441504,
                "title": "rust-simple-naive-dp-solution",
                "content": "```\\nimpl Solution {\\n    pub fn minimize_the_difference(mat: Vec<Vec<i32>>, target: i32) -> i32 {\\n        let n = mat.len();\\n        let m = mat[0].len();\\n        let max = 70*70;\\n\\n        let mut dp = vec![vec![false; max+1 as usize]; n+1];\\n\\n        dp[0][0] = true;\\n\\n        for i in 0..n {\\n            for j in 0..m {\\n                for k in 0..max+1 {\\n                    if dp[i][k] {\\n                        dp[i+1][k + mat[i][j] as usize] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        let result = dp[n].iter().enumerate().filter(|x| *x.1).map(|x| (target - x.0 as i32).abs()).min().unwrap();\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimize_the_difference(mat: Vec<Vec<i32>>, target: i32) -> i32 {\\n        let n = mat.len();\\n        let m = mat[0].len();\\n        let max = 70*70;\\n\\n        let mut dp = vec![vec![false; max+1 as usize]; n+1];\\n\\n        dp[0][0] = true;\\n\\n        for i in 0..n {\\n            for j in 0..m {\\n                for k in 0..max+1 {\\n                    if dp[i][k] {\\n                        dp[i+1][k + mat[i][j] as usize] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        let result = dp[n].iter().enumerate().filter(|x| *x.1).map(|x| (target - x.0 as i32).abs()).min().unwrap();\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2440013,
                "title": "easy-dp-solution-asked-in-amazon",
                "content": "You will be wondering why i took the dp values as 80 and 4902...\\n\\nAnswer :- It is because int the constraint it is given the maximun number of rows can be upto 70 so for safety purpose i took it as 80 and also suppose if we have a tota of 70 rows and each row has same value as 70 so the total sum will become 70X70 which is 4900 so again for safety purpose i took it as 4902.\\n```\\nclass Solution {\\npublic:\\n    int dp[80][4902];\\n    int solve(int row, vector<vector<int>> &mat, int &target, int sum, int &m, int &n) {\\n        if(row==m) {\\n            int ab = abs(target-sum);\\n            // ans = min(ans,ab);\\n            return ab;\\n        }\\n        if(dp[row][sum]!=-1) return dp[row][sum];\\n        int ans = INT_MAX;\\n        for(int col=0;col<n;col++) {\\n            ans = min(ans,solve(row+1,mat,target,sum+mat[row][col],m,n));\\n        }\\n        \\n        return dp[row][sum] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,mat,target,0,m,n);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[80][4902];\\n    int solve(int row, vector<vector<int>> &mat, int &target, int sum, int &m, int &n) {\\n        if(row==m) {\\n            int ab = abs(target-sum);\\n            // ans = min(ans,ab);\\n            return ab;\\n        }\\n        if(dp[row][sum]!=-1) return dp[row][sum];\\n        int ans = INT_MAX;\\n        for(int col=0;col<n;col++) {\\n            ans = min(ans,solve(row+1,mat,target,sum+mat[row][col],m,n));\\n        }\\n        \\n        return dp[row][sum] = ans;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,mat,target,0,m,n);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404528,
                "title": "passed-test-failed-when-submit-why",
                "content": "I passed the test case \\n[[1],[2],[3]]\\n100\\nthe output in Run Test is 94 which got correct answer.\\nBut when I Submit, the output became 0, and got Wrong Answer.\\n\\nWhy?\\n```\\n#define MAX_LEVEL 70\\n#define MAX_RESULT 4900\\n#define MAX_TARGET 800\\nstatic int  g_minDiff = MAX_RESULT + MAX_TARGET +1 ;\\nint cal_sum(int level,int rows,int cols,int currSum, int** mat, int target, int *r)\\n{\\n    int *row = mat[level] ;\\n    int i=0;\\n    int sum = currSum ;\\n    //int minDiff = MAX_RESULT + MAX_TARGET + 1 ;\\n    // printf(\"n:%d *r:%d r:%p\\\\n\",level,*r,r) ;\\n    for ( i = 0 ;i < cols ; i ++) {\\n        int minDiff = MAX_RESULT +MAX_TARGET +1 ;\\n        int diff = MAX_RESULT +MAX_TARGET ;\\n        sum = currSum + row[i] ;\\n        //printf(\"sum(%d,%d):%d\\\\n\",level,i,sum) ;\\n        /*\\n        if ( SUM_TABLE[level][sum] > 0 ) {\\n            SUM_TABLE[level][sum]\\n        }\\n        */\\n        if ( level < rows-1 ) {\\n            cal_sum(level+1,rows,cols,sum,mat,target,r) ;\\n            //printf(\"*r(n:%d):%d\\\\n\",level,*r) ;\\n        }\\n        else {            \\n            diff = abs(target - sum);\\n            if ( diff < minDiff ) {\\n                minDiff = diff ;\\n                *r = minDiff ;\\n                //printf(\"minDiff:%d\\\\n\",minDiff);\\n            }\\n            if (g_minDiff > diff) {\\n                g_minDiff = diff ;\\n            }\\n        }\\n    }\\n    //printf(\"g_minDiff(n:%d):%d\\\\n\",level,g_minDiff) ;\\n    *r = g_minDiff ;\\n    return g_minDiff ;\\n}\\n\\nint minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n    int rows = matSize ;\\n    int cols = *matColSize ;\\n    int ret = -1 ;\\n    int r = cal_sum(0,rows,cols,0,mat,target,&ret) ;\\n    //printf(\"&ret:%p\\\\n\",&ret) ;\\n    //printf(\"r:%d ret:%d\\\\n\",r,ret) ;\\n    return ret ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define MAX_LEVEL 70\\n#define MAX_RESULT 4900\\n#define MAX_TARGET 800\\nstatic int  g_minDiff = MAX_RESULT + MAX_TARGET +1 ;\\nint cal_sum(int level,int rows,int cols,int currSum, int** mat, int target, int *r)\\n{\\n    int *row = mat[level] ;\\n    int i=0;\\n    int sum = currSum ;\\n    //int minDiff = MAX_RESULT + MAX_TARGET + 1 ;\\n    // printf(\"n:%d *r:%d r:%p\\\\n\",level,*r,r) ;\\n    for ( i = 0 ;i < cols ; i ++) {\\n        int minDiff = MAX_RESULT +MAX_TARGET +1 ;\\n        int diff = MAX_RESULT +MAX_TARGET ;\\n        sum = currSum + row[i] ;\\n        //printf(\"sum(%d,%d):%d\\\\n\",level,i,sum) ;\\n        /*\\n        if ( SUM_TABLE[level][sum] > 0 ) {\\n            SUM_TABLE[level][sum]\\n        }\\n        */\\n        if ( level < rows-1 ) {\\n            cal_sum(level+1,rows,cols,sum,mat,target,r) ;\\n            //printf(\"*r(n:%d):%d\\\\n\",level,*r) ;\\n        }\\n        else {            \\n            diff = abs(target - sum);\\n            if ( diff < minDiff ) {\\n                minDiff = diff ;\\n                *r = minDiff ;\\n                //printf(\"minDiff:%d\\\\n\",minDiff);\\n            }\\n            if (g_minDiff > diff) {\\n                g_minDiff = diff ;\\n            }\\n        }\\n    }\\n    //printf(\"g_minDiff(n:%d):%d\\\\n\",level,g_minDiff) ;\\n    *r = g_minDiff ;\\n    return g_minDiff ;\\n}\\n\\nint minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n    int rows = matSize ;\\n    int cols = *matColSize ;\\n    int ret = -1 ;\\n    int r = cal_sum(0,rows,cols,0,mat,target,&ret) ;\\n    //printf(\"&ret:%p\\\\n\",&ret) ;\\n    //printf(\"r:%d ret:%d\\\\n\",r,ret) ;\\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345711,
                "title": "python-3-using-leetcode-given-hints",
                "content": "\\tclass Solution:\\n\\t\\tdef minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\t\\t\\trows = len(mat)\\n\\t\\t\\told_hash_set = set({0})\\n\\n\\t\\t\\tfor i in range(rows):\\n\\t\\t\\t\\thash_set = set()\\n\\t\\t\\t\\tmax_val = None\\n\\t\\t\\t\\tfor elem in old_hash_set:\\n\\t\\t\\t\\t\\tfor row_val in sorted(mat[i]):\\n\\t\\t\\t\\t\\t\\tif max_val is not None and elem + row_val >= max_val:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\t\\tif max_val is None and elem + row_val >= target:\\n\\t\\t\\t\\t\\t\\t\\tmax_val = elem + row_val\\n\\t\\t\\t\\t\\t\\t\\thash_set.add(max_val)\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\thash_set.add(elem+row_val)\\n\\t\\t\\t\\told_hash_set = hash_set\\n\\n\\t\\t\\tmin_dif = float(\\'inf\\')\\n\\n\\t\\t\\tfor elem in old_hash_set:\\n\\t\\t\\t\\tif min_dif > abs(target-elem):\\n\\t\\t\\t\\t\\tmin_dif = abs(target-elem)\\n\\n\\t\\t\\treturn min_dif",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n\\t\\t\\trows = len(mat)\\n\\t\\t\\told_hash_set = set({0}",
                "codeTag": "Java"
            },
            {
                "id": 2335468,
                "title": "python-52-faster-pruning-on-all-possible-values-of-sum-based-on-hints",
                "content": "```\\n/*\\n    approach:\\n    The sum of chosen elements will not be too large. \\n    Consider using a hash set to record all possible sums while iterating each row.\\n    \\n    Instead of keeping track of all possible sums, since in each row, \\n    we are adding positive numbers, only keep those that can be a candidate, \\n    not exceeding the target by too much.\\n*/\\n```\\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        old_hash_set = set({0})\\n        \\n        for i in range(m):\\n            hash_set = set()\\n            max_val = None\\n            \\n            for elem in old_hash_set:\\n                row_sorted = sorted(mat[i])\\n                for row_val in row_sorted:\\n                    if max_val is None and elem + row_val >= target:\\n                        max_val = elem + row_val\\n                        hash_set.add(elem+row_val)\\n                    elif max_val is not None and elem + row_val >= max_val:\\n                        # we can ignore this number, since it\\'s difference with target \\n                        # will always be more\\n                        continue\\n                    else:\\n                        hash_set.add(elem+row_val)\\n            old_hash_set = hash_set\\n            \\n        min_diff = float(\\'inf\\')\\n        for elem in hash_set:\\n            if abs(elem - target) < min_diff:\\n                min_diff = abs(elem - target)\\n        return min_diff\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n/*\\n    approach:\\n    The sum of chosen elements will not be too large. \\n    Consider using a hash set to record all possible sums while iterating each row.\\n    \\n    Instead of keeping track of all possible sums, since in each row, \\n    we are adding positive numbers, only keep those that can be a candidate, \\n    not exceeding the target by too much.\\n*/\\n```\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        m = len(mat)\\n        n = len(mat[0])\\n        old_hash_set = set({0})\\n        \\n        for i in range(m):\\n            hash_set = set()\\n            max_val = None\\n            \\n            for elem in old_hash_set:\\n                row_sorted = sorted(mat[i])\\n                for row_val in row_sorted:\\n                    if max_val is None and elem + row_val >= target:\\n                        max_val = elem + row_val\\n                        hash_set.add(elem+row_val)\\n                    elif max_val is not None and elem + row_val >= max_val:\\n                        # we can ignore this number, since it\\'s difference with target \\n                        # will always be more\\n                        continue\\n                    else:\\n                        hash_set.add(elem+row_val)\\n            old_hash_set = hash_set\\n            \\n        min_diff = float(\\'inf\\')\\n        for elem in hash_set:\\n            if abs(elem - target) < min_diff:\\n                min_diff = abs(elem - target)\\n        return min_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335260,
                "title": "java-memoization",
                "content": "```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int min = Integer.MAX_VALUE;\\n        memo = new Integer[10000][mat.length];\\n        for(int i=0;i<mat[0].length;i++){\\n            min=Math.min(min,minimize(mat,target,mat[0][i],1));\\n        }\\n        return min;\\n    }\\n    \\n    public int minimize(int[][] mat,int target,int sum, int row){\\n        if(row==mat.length){\\n            return Math.abs(sum-target);\\n        }\\n        if(memo[sum][row]!=null)\\n            return memo[sum][row];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<mat[0].length;i++){\\n            min=Math.min(min,minimize(mat,target,sum+mat[row][i],row+1));\\n        }\\n        memo[sum][row]=min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int min = Integer.MAX_VALUE;\\n        memo = new Integer[10000][mat.length];\\n        for(int i=0;i<mat[0].length;i++){\\n            min=Math.min(min,minimize(mat,target,mat[0][i],1));\\n        }\\n        return min;\\n    }\\n    \\n    public int minimize(int[][] mat,int target,int sum, int row){\\n        if(row==mat.length){\\n            return Math.abs(sum-target);\\n        }\\n        if(memo[sum][row]!=null)\\n            return memo[sum][row];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<mat[0].length;i++){\\n            min=Math.min(min,minimize(mat,target,sum+mat[row][i],row+1));\\n        }\\n        memo[sum][row]=min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317948,
                "title": "java-dp-pruning-sorting",
                "content": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        \\n        int m = mat.length, n = mat[0].length;\\n        \\n        Integer[][] dp = new Integer[m][5001];\\n        \\n        for(int[] g : mat){\\n            Arrays.sort(g);\\n        }\\n        int min = helper(mat, 0, target, 0, dp);\\n        return min;\\n    }\\n    \\n    public int helper(int[][] mat, int row, int target, int current, Integer[][] dp){\\n        if(row == mat.length){\\n            return Math.abs(target - current);\\n        }\\n        \\n        if(dp[row][current] != null)\\n            return dp[row][current];\\n        \\n        int min = Integer.MAX_VALUE; \\n        for(int i = 0 ; i < mat[0].length && min != 0; i++){\\n            min = Math.min(min, helper(mat, row + 1, target, current + mat[row][i], dp));\\n        }\\n        return dp[row][current] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        \\n        int m = mat.length, n = mat[0].length;\\n        \\n        Integer[][] dp = new Integer[m][5001];\\n        \\n        for(int[] g : mat){\\n            Arrays.sort(g);\\n        }\\n        int min = helper(mat, 0, target, 0, dp);\\n        return min;\\n    }\\n    \\n    public int helper(int[][] mat, int row, int target, int current, Integer[][] dp){\\n        if(row == mat.length){\\n            return Math.abs(target - current);\\n        }\\n        \\n        if(dp[row][current] != null)\\n            return dp[row][current];\\n        \\n        int min = Integer.MAX_VALUE; \\n        for(int i = 0 ; i < mat[0].length && min != 0; i++){\\n            min = Math.min(min, helper(mat, row + 1, target, current + mat[row][i], dp));\\n        }\\n        return dp[row][current] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311715,
                "title": "easy-c-memoized",
                "content": "```\\nint dp[71][4901];\\n    int solve(vector<vector<int>> &arr,int target,int sum=0,int row=0)\\n    {\\n        if(row==arr.size())\\n            return abs(target-sum);\\n        \\n        if(dp[row][sum]!=-1)\\n            return dp[row][sum];\\n        \\n        int ans=INT_MAX;\\n        for(int col=0;col<arr[0].size();col++)\\n        {\\n            int temp=solve(arr,target,sum+arr[row][col],row+1);\\n            ans=min(temp,ans);\\n        }\\n        \\n        return dp[row][sum]=ans;\\n            \\n    }\\n        \\n    int minimizeTheDifference(vector<vector<int>>& arr, int target) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        return solve(arr,target);\\n    }",
                "solutionTags": [],
                "code": "```\\nint dp[71][4901];\\n    int solve(vector<vector<int>> &arr,int target,int sum=0,int row=0)\\n    {\\n        if(row==arr.size())\\n            return abs(target-sum);\\n        \\n        if(dp[row][sum]!=-1)\\n            return dp[row][sum];\\n        \\n        int ans=INT_MAX;\\n        for(int col=0;col<arr[0].size();col++)\\n        {\\n            int temp=solve(arr,target,sum+arr[row][col],row+1);\\n            ans=min(temp,ans);\\n        }\\n        \\n        return dp[row][sum]=ans;\\n            \\n    }\\n        \\n    int minimizeTheDifference(vector<vector<int>>& arr, int target) {\\n        \\n        memset(dp,-1,sizeof dp);\\n        return solve(arr,target);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2304558,
                "title": "java-simple-solution",
                "content": "Here the intution is simple. For each row we run a dfs with a dp and if it gives a minimal value then Integer.MAX_VALUE we just update it\\n\\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        ArrayList<TreeSet<Integer>> list=new ArrayList<>();\\n        int row=mat.length;\\n        int col=mat[0].length;\\n        Integer[][] dp=new Integer[row+1][70*70+1];\\n        for(int i=0;i<row;i++){\\n            TreeSet<Integer> set=new TreeSet<>();\\n            for(int j=0;j<col;j++){\\n                set.add(mat[i][j]);\\n            }\\n            \\n            list.add(set);\\n        }\\n        // System.out.println(dp);\\n        return dfs(list,target,0,0,dp);\\n        // return 0;\\n    }\\n    \\n    public int dfs(ArrayList<TreeSet<Integer>> list,int target,int sum,int index,Integer[][] dp){\\n        if(index==list.size()){\\n            return Math.abs(target-sum);\\n        }\\n        \\n        if(dp[index][sum]!=null){\\n            return dp[index][sum];\\n        }\\n        int res=Integer.MAX_VALUE;\\n        for(int n:list.get(index)){\\n            int diff=dfs(list,target,sum+n,index+1,dp);\\n            res=Math.min(res,diff);\\n            if(diff==0 ){\\n                break;\\n            }\\n        }\\n        return dp[index][sum]=res;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        ArrayList<TreeSet<Integer>> list=new ArrayList<>();\\n        int row=mat.length;\\n        int col=mat[0].length;\\n        Integer[][] dp=new Integer[row+1][70*70+1];\\n        for(int i=0;i<row;i++){\\n            TreeSet<Integer> set=new TreeSet<>();\\n            for(int j=0;j<col;j++){\\n                set.add(mat[i][j]);\\n            }\\n            \\n            list.add(set);\\n        }\\n        // System.out.println(dp);\\n        return dfs(list,target,0,0,dp);\\n        // return 0;\\n    }\\n    \\n    public int dfs(ArrayList<TreeSet<Integer>> list,int target,int sum,int index,Integer[][] dp){\\n        if(index==list.size()){\\n            return Math.abs(target-sum);\\n        }\\n        \\n        if(dp[index][sum]!=null){\\n            return dp[index][sum];\\n        }\\n        int res=Integer.MAX_VALUE;\\n        for(int n:list.get(index)){\\n            int diff=dfs(list,target,sum+n,index+1,dp);\\n            res=Math.min(res,diff);\\n            if(diff==0 ){\\n                break;\\n            }\\n        }\\n        return dp[index][sum]=res;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277084,
                "title": "top-down-approch-with-tips-for-how-to-attack-on-dp-problems",
                "content": "/* first of all think what is worst case to finding answer(brute force) now after finding brute force approch u need to think that what paramater is can be useful if that is pre calculated in this q that is sum and for any\\nproblem only  parameter will define dp state and transition ,so u need to find this parameter, and then that is quit easy to implimant( leap of faith !!!) */\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[71][5001];\\n    int mx=INT_MAX;\\n    int solve(vector<vector<int>>& mat, int target,int sm,int row)\\n    {\\n        if(row>=n)\\n        {\\n          return abs(target-sm);\\n        }\\n        if(dp[row][sm]!=-1)\\n        {\\n            return dp[row][sm];\\n         }\\n        int mn =INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n          mn= min(mn,solve(mat,target,sm+mat[row][i],row+1));\\n        }\\n        return  dp[row][sm]=mn;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        n= mat.size();\\n        m= mat[0].size();\\n        for(int i=0;i<n+1;i++)\\n        {\\n            for(int j=0;j<=5000;j++)\\n            {\\n                dp[i][j]=-1;\\n             }\\n        }\\n      return  solve(mat,target,0,0);\\n\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int n,m;\\n    int dp[71][5001];\\n    int mx=INT_MAX;\\n    int solve(vector<vector<int>>& mat, int target,int sm,int row)\\n    {\\n        if(row>=n)\\n        {\\n          return abs(target-sm);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2264748,
                "title": "c-dp-with-pruning",
                "content": "```\\nclass Solution {\\npublic:\\n    const int offset = 5000;\\n    int dfs(int r, int diff, vector<vector<int>>& mat, vector<vector<int> >& dp) {\\n        if(r == mat.size()) return abs(diff);\\n        if(dp[r][diff + offset] != INT_MAX) return dp[r][diff + offset];\\n        \\n        int ans = INT_MAX;\\n        if(diff > 0) {\\n            for(int c=0; c<mat[0].size(); c++) {\\n                int sub = dfs(r+1, diff - mat[r][c], mat, dp);\\n                ans = min(ans, sub);\\n            }\\n        } else {\\n\\t\\t    // At row r, the sum of selected numbers from row 0 till r-1 is already equal or greater than target.\\n\\t\\t\\t// From row r, we simply pick the smallest number of each row.\\n            int minnum = mat[r][0];\\n            for(int c=0; c<mat[0].size(); c++) minnum = min(minnum, mat[r][c]);\\n            ans = dfs(r+1, diff - minnum, mat, dp);\\n        }\\n        dp[r][diff+offset] = ans;\\n        return ans;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size();\\n        vector<vector<int> > dp(m, vector<int>(target + offset + 1, INT_MAX));\\n        \\n        return dfs(0, target, mat, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int offset = 5000;\\n    int dfs(int r, int diff, vector<vector<int>>& mat, vector<vector<int> >& dp) {\\n        if(r == mat.size()) return abs(diff);\\n        if(dp[r][diff + offset] != INT_MAX) return dp[r][diff + offset];\\n        \\n        int ans = INT_MAX;\\n        if(diff > 0) {\\n            for(int c=0; c<mat[0].size(); c++) {\\n                int sub = dfs(r+1, diff - mat[r][c], mat, dp);\\n                ans = min(ans, sub);\\n            }\\n        } else {\\n\\t\\t    // At row r, the sum of selected numbers from row 0 till r-1 is already equal or greater than target.\\n\\t\\t\\t// From row r, we simply pick the smallest number of each row.\\n            int minnum = mat[r][0];\\n            for(int c=0; c<mat[0].size(); c++) minnum = min(minnum, mat[r][c]);\\n            ans = dfs(r+1, diff - minnum, mat, dp);\\n        }\\n        dp[r][diff+offset] = ans;\\n        return ans;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int m = mat.size();\\n        vector<vector<int> > dp(m, vector<int>(target + offset + 1, INT_MAX));\\n        \\n        return dfs(0, target, mat, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260835,
                "title": "java-dp-top-down-pruning",
                "content": "```\\n\\nclass Solution {\\n     int ans = Integer.MAX_VALUE;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        // Sort each of the columns for Prunning\\n        for(int[] cols: mat) {\\n            Arrays.sort(cols);\\n        }\\n        boolean[][] visited = new boolean[n][4900];\\n        backtrack(mat, target, visited, 0, 0);\\n        return ans;\\n    }\\n    public void backtrack(int[][] mat, int target, boolean[][] visited, int row, int pathSum) {\\n        if(row == mat.length) {\\n            ans = Math.min(Math.abs(target-pathSum), ans);\\n            return;\\n        }\\n        if(visited[row][pathSum])\\n            return;\\n        for(int j=0; j< mat[0].length; j++) {\\n            backtrack(mat, target, visited, row+1, pathSum+mat[row][j]);\\n            // Pruning:\\n            // we don\\'t need to travel other paths of pathSum+mat[row][j] is already greater than the target because this won\\'t give us the min absolute diffrent now\\n            if(pathSum+mat[row][j] > target)\\n                break;\\n        }\\n        visited[row][pathSum] = true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n     int ans = Integer.MAX_VALUE;\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        // Sort each of the columns for Prunning\\n        for(int[] cols: mat) {\\n            Arrays.sort(cols);\\n        }\\n        boolean[][] visited = new boolean[n][4900];\\n        backtrack(mat, target, visited, 0, 0);\\n        return ans;\\n    }\\n    public void backtrack(int[][] mat, int target, boolean[][] visited, int row, int pathSum) {\\n        if(row == mat.length) {\\n            ans = Math.min(Math.abs(target-pathSum), ans);\\n            return;\\n        }\\n        if(visited[row][pathSum])\\n            return;\\n        for(int j=0; j< mat[0].length; j++) {\\n            backtrack(mat, target, visited, row+1, pathSum+mat[row][j]);\\n            // Pruning:\\n            // we don\\'t need to travel other paths of pathSum+mat[row][j] is already greater than the target because this won\\'t give us the min absolute diffrent now\\n            if(pathSum+mat[row][j] > target)\\n                break;\\n        }\\n        visited[row][pathSum] = true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201696,
                "title": "scala-functional-with-comments",
                "content": "```\\nobject Solution {\\n    def minimizeTheDifference(mat: Array[Array[Int]], target: Int): Int = {\\n\\t\\tif(mat.length == 0) {\\n\\t\\t  return target\\n\\t\\t}\\n\\t\\tmat.map(_.min).sum match {\\n\\t\\t  // min sum greater than target\\n\\t\\t  case possibleMin if possibleMin > target => possibleMin - target\\n\\t\\t  case possibleMin =>\\n\\t\\t\\t// calculate all possible sums\\n\\t\\t\\t// sum should be <= 2 * target - possibleMin\\n\\t\\t\\t//\\n\\t\\t\\t// explanation:\\n\\t\\t\\t// sum < target + bestDifferenceSoFar\\n\\t\\t\\t// bestDifferenceSoFar = possibleMin - target\\n\\t\\t\\t// sum < target + (target - possibleMin)\\n\\t\\t\\t// sum < 2 * target - possibleMin\\n\\t\\t\\tmat.foldLeft(Set.empty[Int]) {\\n\\t\\t\\t  case (possibleSums, line) if possibleSums.isEmpty => line.toSet[Int]\\n\\t\\t\\t  case (possibleSums, line) =>\\n\\t\\t\\t\\tline.toSet[Int].flatMap {\\n\\t\\t\\t\\t  newValue =>\\n\\t\\t\\t\\t\\tpossibleSums.collect {\\n\\t\\t\\t\\t\\t  case oldValue if newValue + oldValue <= 2 * target + possibleMin =>\\n\\t\\t\\t\\t\\t\\tnewValue + oldValue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t.partition(_ < target) match {\\n\\t\\t\\t\\t  case (smaller, bigger) if bigger.isEmpty => smaller\\n\\t\\t\\t\\t  // for sums bigger than target we can explore only smallest sums\\n\\t\\t\\t\\t  // because all other options will have bigger difference\\n\\t\\t\\t\\t  case (smaller, bigger) => smaller ++ Set(bigger.min)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t  // possible to short it to .map(v => (target - v).abs).min\\n\\t\\t\\t  // but it will use more memory and can lead to \"Memory Limit Exceeded\"\\n\\t\\t\\t  .foldLeft(-1) {\\n\\t\\t\\t\\t// start with -1 as min and replace it with any first diff\\n\\t\\t\\t\\tcase (min, v) if min == -1 => (target - v).abs\\n\\t\\t\\t\\t// search for better option\\n\\t\\t\\t\\tcase (min, v) if (target - v).abs < min => (target - v).abs\\n\\t\\t\\t\\t// or use old min\\n\\t\\t\\t\\tcase (min, v) => min\\n\\t\\t\\t  }\\n\\t\\t}\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def minimizeTheDifference(mat: Array[Array[Int]], target: Int): Int = {\\n\\t\\tif(mat.length == 0) {\\n\\t\\t  return target\\n\\t\\t}\\n\\t\\tmat.map(_.min).sum match {\\n\\t\\t  // min sum greater than target\\n\\t\\t  case possibleMin if possibleMin > target => possibleMin - target\\n\\t\\t  case possibleMin =>\\n\\t\\t\\t// calculate all possible sums\\n\\t\\t\\t// sum should be <= 2 * target - possibleMin\\n\\t\\t\\t//\\n\\t\\t\\t// explanation:\\n\\t\\t\\t// sum < target + bestDifferenceSoFar\\n\\t\\t\\t// bestDifferenceSoFar = possibleMin - target\\n\\t\\t\\t// sum < target + (target - possibleMin)\\n\\t\\t\\t// sum < 2 * target - possibleMin\\n\\t\\t\\tmat.foldLeft(Set.empty[Int]) {\\n\\t\\t\\t  case (possibleSums, line) if possibleSums.isEmpty => line.toSet[Int]\\n\\t\\t\\t  case (possibleSums, line) =>\\n\\t\\t\\t\\tline.toSet[Int].flatMap {\\n\\t\\t\\t\\t  newValue =>\\n\\t\\t\\t\\t\\tpossibleSums.collect {\\n\\t\\t\\t\\t\\t  case oldValue if newValue + oldValue <= 2 * target + possibleMin =>\\n\\t\\t\\t\\t\\t\\tnewValue + oldValue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t.partition(_ < target) match {\\n\\t\\t\\t\\t  case (smaller, bigger) if bigger.isEmpty => smaller\\n\\t\\t\\t\\t  // for sums bigger than target we can explore only smallest sums\\n\\t\\t\\t\\t  // because all other options will have bigger difference\\n\\t\\t\\t\\t  case (smaller, bigger) => smaller ++ Set(bigger.min)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t  // possible to short it to .map(v => (target - v).abs).min\\n\\t\\t\\t  // but it will use more memory and can lead to \"Memory Limit Exceeded\"\\n\\t\\t\\t  .foldLeft(-1) {\\n\\t\\t\\t\\t// start with -1 as min and replace it with any first diff\\n\\t\\t\\t\\tcase (min, v) if min == -1 => (target - v).abs\\n\\t\\t\\t\\t// search for better option\\n\\t\\t\\t\\tcase (min, v) if (target - v).abs < min => (target - v).abs\\n\\t\\t\\t\\t// or use old min\\n\\t\\t\\t\\tcase (min, v) => min\\n\\t\\t\\t  }\\n\\t\\t}\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2176892,
                "title": "c-solution-merging-rows-and-simplifying",
                "content": "The data this problem uses has a lot of duplicate numbers.  The twin hashset exploits this by essentially creating a new row from two other rows over and over, then removing any items so large as to not be helpful.  The final composite row is such that each item is a sum of one item from each row.  The final solution is to just pick the one that matches closest.\\n\\nIt is hard to give a number on efficiency here.  I\\'ve seen as faster than 70% of C# tests..  Either way the efficiency is widely dependent on having a lot of data words with the same values.\\n\\nSo, basically this is an interesting solution for an apparently overlly contrived set of data..\\n\\n```\\nusing System.Runtime.CompilerServices;\\n\\npublic class Solution \\n{\\n    private HashSet<int> setA = new HashSet<int>();\\n    private HashSet<int> setB = new HashSet<int>();\\n    private int rows;\\n    private int target;\\n    private int [][] mat;   \\n    \\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\\n    private int Abs(int i)\\n    {\\n        if (i<0) return -1*i;\\n        return i;\\n    }\\n    \\n    // Takes in setA and updates setB\\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\\n    private void OneFromTwo(int[]b)\\n    {\\n        this.setB.Clear();\\n        foreach(var a_ in this.setA)\\n        {\\n            int firstExceedance = 0;\\n            for(int j=0;j<b.Length;j++)\\n            {\\n                int x = a_+b[j];\\n                //First exceedance here is a fairly weak filter, since there is no ordering.\\n                if (x >= target && firstExceedance==0)\\n                {\\n                    firstExceedance=x;\\n                }\\n                if (x <= firstExceedance || firstExceedance==0)\\n                {\\n                    this.setB.Add(x);\\n                }\\n            }\\n        }\\n    }\\n    \\n    //Takes in setB and updates setA\\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\\n    private void FilterSetToRemoveObviouslyBadChoices()\\n    {\\n        this.setA.Clear();\\n        foreach(var v in this.setB.OrderBy(v => v))\\n        {\\n            this.setA.Add(v);\\n            if (v >= target)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    public int MinimizeTheDifference(int[][] mat, int target) \\n    {\\n        this.target = target;\\n        this.mat = mat;\\n        this.rows = mat.Length;        \\n        foreach(var v in mat[0])\\n        {\\n            this.setA.Add(v);\\n        }\\n        var ansSet = this.setA;\\n        if (rows > 1)\\n        {\\n            for(int i=1;i<rows;i++)\\n            {\\n                OneFromTwo(mat[i]);\\n                FilterSetToRemoveObviouslyBadChoices();\\n            }\\n            ansSet = this.setB;\\n        }\\n        int best = int.MaxValue; \\n        foreach(var b_ in ansSet)\\n        {\\n            int val = Abs(b_-target);\\n            if (val < best)\\n            {\\n                best=val;\\n            }\\n        }\\n        return best;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Runtime.CompilerServices;\\n\\npublic class Solution \\n{\\n    private HashSet<int> setA = new HashSet<int>();\\n    private HashSet<int> setB = new HashSet<int>();\\n    private int rows;\\n    private int target;\\n    private int [][] mat;   \\n    \\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\\n    private int Abs(int i)\\n    {\\n        if (i<0) return -1*i;\\n        return i;\\n    }\\n    \\n    // Takes in setA and updates setB\\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\\n    private void OneFromTwo(int[]b)\\n    {\\n        this.setB.Clear();\\n        foreach(var a_ in this.setA)\\n        {\\n            int firstExceedance = 0;\\n            for(int j=0;j<b.Length;j++)\\n            {\\n                int x = a_+b[j];\\n                //First exceedance here is a fairly weak filter, since there is no ordering.\\n                if (x >= target && firstExceedance==0)\\n                {\\n                    firstExceedance=x;\\n                }\\n                if (x <= firstExceedance || firstExceedance==0)\\n                {\\n                    this.setB.Add(x);\\n                }\\n            }\\n        }\\n    }\\n    \\n    //Takes in setB and updates setA\\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\\n    private void FilterSetToRemoveObviouslyBadChoices()\\n    {\\n        this.setA.Clear();\\n        foreach(var v in this.setB.OrderBy(v => v))\\n        {\\n            this.setA.Add(v);\\n            if (v >= target)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    public int MinimizeTheDifference(int[][] mat, int target) \\n    {\\n        this.target = target;\\n        this.mat = mat;\\n        this.rows = mat.Length;        \\n        foreach(var v in mat[0])\\n        {\\n            this.setA.Add(v);\\n        }\\n        var ansSet = this.setA;\\n        if (rows > 1)\\n        {\\n            for(int i=1;i<rows;i++)\\n            {\\n                OneFromTwo(mat[i]);\\n                FilterSetToRemoveObviouslyBadChoices();\\n            }\\n            ansSet = this.setB;\\n        }\\n        int best = int.MaxValue; \\n        foreach(var b_ in ansSet)\\n        {\\n            int val = Abs(b_-target);\\n            if (val < best)\\n            {\\n                best=val;\\n            }\\n        }\\n        return best;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164915,
                "title": "java-o-m-n-2-2d-dp",
                "content": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            Arrays.sort(mat[i]);\\n        }\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        boolean[][] dp = new boolean[m][4901];\\n        int ret = Integer.MAX_VALUE;\\n        \\n       \\n        int sum = mat[0][n-1];\\n        \\n        for (int k = 0; k < n; k++) {\\n            dp[0][mat[0][k]] = true;\\n        }\\n        \\n        \\n        for (int i = 1; i< m; i++) {\\n            sum += mat[i][n-1];\\n            \\n            for (int j = 0; j <= sum; j++) { \\n               \\n                for (int k = 0; k < n; k++) {\\n                    if (j >= mat[i][k]) dp[i][j] = dp[i-1][j-mat[i][k]];\\n                    else break;\\n                    \\n                    if (dp[i][j]) break;\\n                }\\n               \\n            }\\n        }\\n        \\n        \\n        for (int j = 0; j <= 4900; j++) {\\n            if (dp[m-1][j]) ret = Math.min(ret, Math.abs(j-target));\\n        }\\n        return ret;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        \\n        for (int i = 0; i < mat.length; i++) {\\n            Arrays.sort(mat[i]);\\n        }\\n        \\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        boolean[][] dp = new boolean[m][4901];\\n        int ret = Integer.MAX_VALUE;\\n        \\n       \\n        int sum = mat[0][n-1];\\n        \\n        for (int k = 0; k < n; k++) {\\n            dp[0][mat[0][k]] = true;\\n        }\\n        \\n        \\n        for (int i = 1; i< m; i++) {\\n            sum += mat[i][n-1];\\n            \\n            for (int j = 0; j <= sum; j++) { \\n               \\n                for (int k = 0; k < n; k++) {\\n                    if (j >= mat[i][k]) dp[i][j] = dp[i-1][j-mat[i][k]];\\n                    else break;\\n                    \\n                    if (dp[i][j]) break;\\n                }\\n               \\n            }\\n        }\\n        \\n        \\n        for (int j = 0; j <= 4900; j++) {\\n            if (dp[m-1][j]) ret = Math.min(ret, Math.abs(j-target));\\n        }\\n        return ret;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147171,
                "title": "cam-anyone-have-idea-what-is-time-complexity-of-this-code",
                "content": "class Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        HashSet<Integer> hs=new HashSet();\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int x:mat[0])hs.add(x);\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n            \\n        for(int i=1;i<m;i++){\\n           HashSet<Integer> temp=new HashSet();\\n            for(int j=0;j<n;j++){\\n                for(int x:hs){\\n                    temp.add(x+mat[i][j]);\\n                }\\n            }\\n           hs=new HashSet(temp);\\n            \\n        }\\n        \\n        for(int x:hs){\\n            ans=Math.min(ans,Math.abs(x-target));\\n        }\\n        return ans;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        HashSet<Integer> hs=new HashSet();\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int x:mat[0])hs.add(x);\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n            \\n        for(int i=1;i<m;i++){\\n           HashSet<Integer> temp=new HashSet();\\n            for(int j=0;j<n;j++){\\n                for(int x:hs){\\n                    temp.add(x+mat[i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2060617,
                "title": "c-bitmap-100",
                "content": "```\\n#define N 5000\\n#define ARR_SIZE (N >> 5)+1\\nint bitmap_col_sum[ARR_SIZE];\\nint bitmap_tmp[ARR_SIZE];\\nint bitmap_update[ARR_SIZE];\\nbool get(int *bitmap, int x) { return bitmap[x >> 5] & (UINT32_C(1) << (x & 31)); }\\nvoid bit_or(int *bitmap,int *bitmap_tmp)\\n{\\n    for(int i=0;i<ARR_SIZE;i++) bitmap[i]|=bitmap_tmp[i];\\n}\\nvoid bit_equal(int *bitmap,int *bitmap_tmp)\\n{\\n    for(int i=0;i<ARR_SIZE;i++) bitmap[i]=bitmap_tmp[i];\\n}\\nvoid bit_add(int *bitmap, int x)\\n{\\n    int tmp[ARR_SIZE];\\n    memset(tmp,0,sizeof(tmp));\\n    int div=x/32, rem=x%32;\\n    for(int i=ARR_SIZE-1;i>=0;i--)\\n    {\\n        if(bitmap[i])\\n        {\\n            if(rem==0)\\n            {\\n                tmp[i+div]|=(unsigned int)bitmap[i];\\n            }\\n            else\\n            {\\n                tmp[i+div+1]|=(unsigned int)bitmap[i]>>(32-rem);\\n                tmp[i+div]|=(unsigned int)bitmap[i]<<rem;\\n            }\\n        }\\n    }\\n    bit_equal(bitmap,tmp);\\n}\\nint minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n    memset(bitmap_update,0,sizeof(bitmap_update));\\n    bitmap_update[0]=1;\\n    for(int i=0;i<matSize;i++)\\n    {\\n        memset(bitmap_col_sum,0,sizeof(bitmap_col_sum));\\n        for(int j=0;j<*matColSize;j++)\\n        {\\n            bit_equal(bitmap_tmp,bitmap_update);\\n            bit_add(bitmap_tmp,*(*(mat+i)+j));\\n            bit_or(bitmap_col_sum,bitmap_tmp);\\n        }\\n        bit_equal(bitmap_update,bitmap_col_sum);\\n    }\\n    int target_high=target,target_low=target-1;\\n    while(1)\\n    {\\n        if(get(bitmap_update,target_high))return target_high-target;\\n        if(target_low>=0)\\n        {\\n            if(get(bitmap_update,target_low))return target-target_low;\\n            target_low--;\\n        }\\n        target_high++;\\n    }\\n    return 0;\\n}\\n```\\nIf you have any suggestions, please leave a comment.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n#define N 5000\\n#define ARR_SIZE (N >> 5)+1\\nint bitmap_col_sum[ARR_SIZE];\\nint bitmap_tmp[ARR_SIZE];\\nint bitmap_update[ARR_SIZE];\\nbool get(int *bitmap, int x) { return bitmap[x >> 5] & (UINT32_C(1) << (x & 31)); }\\nvoid bit_or(int *bitmap,int *bitmap_tmp)\\n{\\n    for(int i=0;i<ARR_SIZE;i++) bitmap[i]|=bitmap_tmp[i];\\n}\\nvoid bit_equal(int *bitmap,int *bitmap_tmp)\\n{\\n    for(int i=0;i<ARR_SIZE;i++) bitmap[i]=bitmap_tmp[i];\\n}\\nvoid bit_add(int *bitmap, int x)\\n{\\n    int tmp[ARR_SIZE];\\n    memset(tmp,0,sizeof(tmp));\\n    int div=x/32, rem=x%32;\\n    for(int i=ARR_SIZE-1;i>=0;i--)\\n    {\\n        if(bitmap[i])\\n        {\\n            if(rem==0)\\n            {\\n                tmp[i+div]|=(unsigned int)bitmap[i];\\n            }\\n            else\\n            {\\n                tmp[i+div+1]|=(unsigned int)bitmap[i]>>(32-rem);\\n                tmp[i+div]|=(unsigned int)bitmap[i]<<rem;\\n            }\\n        }\\n    }\\n    bit_equal(bitmap,tmp);\\n}\\nint minimizeTheDifference(int** mat, int matSize, int* matColSize, int target){\\n    memset(bitmap_update,0,sizeof(bitmap_update));\\n    bitmap_update[0]=1;\\n    for(int i=0;i<matSize;i++)\\n    {\\n        memset(bitmap_col_sum,0,sizeof(bitmap_col_sum));\\n        for(int j=0;j<*matColSize;j++)\\n        {\\n            bit_equal(bitmap_tmp,bitmap_update);\\n            bit_add(bitmap_tmp,*(*(mat+i)+j));\\n            bit_or(bitmap_col_sum,bitmap_tmp);\\n        }\\n        bit_equal(bitmap_update,bitmap_col_sum);\\n    }\\n    int target_high=target,target_low=target-1;\\n    while(1)\\n    {\\n        if(get(bitmap_update,target_high))return target_high-target;\\n        if(target_low>=0)\\n        {\\n            if(get(bitmap_update,target_low))return target-target_low;\\n            target_low--;\\n        }\\n        target_high++;\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2016556,
                "title": "question-for-max-sum-as-5000",
                "content": "Everyone is saying that - max sum of this array is 70*70. How??\\n\\nThe condition in question says - \\n\\nm,n <= 70, so max size of matrix is 70 * 70. \\nmat[i] <= 70, so max value of any element is 70. \\n\\nSo, sum can be - 70+70+70+....... (mn items)\\n=> sum = 70 * (mn)\\n=> sum = 70 * 70 * 70. \\n\\nI think as our target is only 800, may be limit of 5000 in matrix is working.",
                "solutionTags": [],
                "code": "Everyone is saying that - max sum of this array is 70*70. How??\\n\\nThe condition in question says - \\n\\nm,n <= 70, so max size of matrix is 70 * 70. \\nmat[i] <= 70, so max value of any element is 70. \\n\\nSo, sum can be - 70+70+70+....... (mn items)\\n=> sum = 70 * (mn)\\n=> sum = 70 * 70 * 70. \\n\\nI think as our target is only 800, may be limit of 5000 in matrix is working.",
                "codeTag": "Unknown"
            },
            {
                "id": 2005123,
                "title": "java-solution-with-set",
                "content": "For each row it generates set of values and continue with this set of values. \\n```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        \\n        if(mat.length == 0){\\n            return target;\\n        }\\n        \\n        HashSet<Integer> currentSet = new HashSet<>();\\n        HashSet<Integer> tempSet;\\n        \\n        for(int i = 0; i < mat[0].length; i++){\\n            currentSet.add(mat[0][i]);\\n        }\\n        \\n        int currentMaxForTarget;\\n        for(int r = 1; r < mat.length; r++){\\n            tempSet =  new HashSet<>();\\n            currentMaxForTarget = Integer.MAX_VALUE;\\n            for(int c = 0; c < mat[0].length; c++){\\n                for(int a : currentSet){\\n                    int t = mat[r][c] + a;\\n                    if(currentMaxForTarget >= target && t >= target && t < currentMaxForTarget){\\n                        currentMaxForTarget = t;\\n                    }\\n\\t\\t\\t\\t\\t//If t is bigger than currentMaxForTarget which is bigger than target, do not add it to set.\\n                    if(t <= currentMaxForTarget){\\n                        tempSet.add(t);\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currentSet = tempSet;\\n        }\\n        \\n\\t\\t//find minimum difference\\n        int min = Integer.MAX_VALUE;    \\n        for(int i : currentSet){\\n            min = Math.min(min, Math.abs(target - i));\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        \\n        if(mat.length == 0){\\n            return target;\\n        }\\n        \\n        HashSet<Integer> currentSet = new HashSet<>();\\n        HashSet<Integer> tempSet;\\n        \\n        for(int i = 0; i < mat[0].length; i++){\\n            currentSet.add(mat[0][i]);\\n        }\\n        \\n        int currentMaxForTarget;\\n        for(int r = 1; r < mat.length; r++){\\n            tempSet =  new HashSet<>();\\n            currentMaxForTarget = Integer.MAX_VALUE;\\n            for(int c = 0; c < mat[0].length; c++){\\n                for(int a : currentSet){\\n                    int t = mat[r][c] + a;\\n                    if(currentMaxForTarget >= target && t >= target && t < currentMaxForTarget){\\n                        currentMaxForTarget = t;\\n                    }\\n\\t\\t\\t\\t\\t//If t is bigger than currentMaxForTarget which is bigger than target, do not add it to set.\\n                    if(t <= currentMaxForTarget){\\n                        tempSet.add(t);\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currentSet = tempSet;\\n        }\\n        \\n\\t\\t//find minimum difference\\n        int min = Integer.MAX_VALUE;    \\n        for(int i : currentSet){\\n            min = Math.min(min, Math.abs(target - i));\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983886,
                "title": "c-tle-python-ac-why-these-things-are-not-fixed",
                "content": "AC Python Code \\n```\\nclass Solution(object):\\n    def minimizeTheDifference(self, mat, target):\\n        possible_min = sum(min(row) for row in mat)\\n        if possible_min > target: return possible_min - target\\n        \\n        nums = {0}\\n        for row in mat:\\n            t = set()\\n            for x in row:\\n                for i in nums:\\n                    if x + i <= 2*target - possible_min:\\n                        t.add(x + i)\\n            nums = t ; \\n        \\n        return min(abs(target - x) for x in nums)\\n```\\n\\nTLE C++ Code\\n```\\n#define all(a) begin(a) , end(a)\\n\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        int posmin = 0 ; \\n        for(auto &row : mat) \\n            posmin += *min_element(all(row)) ;\\n        \\n        if(posmin > target) return posmin - target ; \\n        \\n        unordered_set<int> s = {0} ; \\n        for(auto &row : mat){\\n            unordered_set<int> t ; \\n            for(auto &e : s) for(auto &x : row) \\n                if(x + e < 2*target - posmin) t.insert(x + e) ;\\n            s = t ; \\n        }\\n        \\n        int ans = target - posmin ;\\n        for(auto &x : s) ans = min(ans , abs(target - x)) ; \\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimizeTheDifference(self, mat, target):\\n        possible_min = sum(min(row) for row in mat)\\n        if possible_min > target: return possible_min - target\\n        \\n        nums = {0}\\n        for row in mat:\\n            t = set()\\n            for x in row:\\n                for i in nums:\\n                    if x + i <= 2*target - possible_min:\\n                        t.add(x + i)\\n            nums = t ; \\n        \\n        return min(abs(target - x) for x in nums)\\n```\n```\\n#define all(a) begin(a) , end(a)\\n\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        int posmin = 0 ; \\n        for(auto &row : mat) \\n            posmin += *min_element(all(row)) ;\\n        \\n        if(posmin > target) return posmin - target ; \\n        \\n        unordered_set<int> s = {0} ; \\n        for(auto &row : mat){\\n            unordered_set<int> t ; \\n            for(auto &e : s) for(auto &x : row) \\n                if(x + e < 2*target - posmin) t.insert(x + e) ;\\n            s = t ; \\n        }\\n        \\n        int ans = target - posmin ;\\n        for(auto &x : s) ans = min(ans , abs(target - x)) ; \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976638,
                "title": "book-keeping",
                "content": "```\\n// credits to votrubac\\nclass Solution {\\npublic:\\n    \\n    int dp[71][70 * 70 + 1] = {[0 ... 70][0 ... 70 * 70] = INT_MAX};\\n    int dfs(vector<set<int>>& m, int i, int sum, int target) {\\n        if (i >= m.size())\\n            return abs(sum - target);\\n    \\n        if (dp[i][sum] == INT_MAX)\\n            for (auto it = begin(m[i]); it != end(m[i]); ++it) {\\n                dp[i][sum] = min(dp[i][sum], dfs(m, i + 1, sum + *it, target));\\n                if (dp[i][sum] == 0 || sum + *it > target)\\n                    break;\\n        }\\n        return dp[i][sum];\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        vector<set<int>> m;\\n        for (auto &row : mat)\\n            m.push_back(set<int>(begin(row), end(row)));\\n        return dfs(m, 0, 0, target);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// credits to votrubac\\nclass Solution {\\npublic:\\n    \\n    int dp[71][70 * 70 + 1] = {[0 ... 70][0 ... 70 * 70] = INT_MAX};\\n    int dfs(vector<set<int>>& m, int i, int sum, int target) {\\n        if (i >= m.size())\\n            return abs(sum - target);\\n    \\n        if (dp[i][sum] == INT_MAX)\\n            for (auto it = begin(m[i]); it != end(m[i]); ++it) {\\n                dp[i][sum] = min(dp[i][sum], dfs(m, i + 1, sum + *it, target));\\n                if (dp[i][sum] == 0 || sum + *it > target)\\n                    break;\\n        }\\n        return dp[i][sum];\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        vector<set<int>> m;\\n        for (auto &row : mat)\\n            m.push_back(set<int>(begin(row), end(row)));\\n        return dfs(m, 0, 0, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924893,
                "title": "java-91-speed-recursion",
                "content": "total sum is at most 4900, and there are at most 70 rows, so time complexity is around 4900*70, which is doable.\\n\\nStrategy is as follows: If we enter a row with the sum that we\\'ve explored before, we exit immediately as it won\\'t produce new outcome.\\n\\nAfterwards, we do a BFS from target to find the closest sum achievable.\\n```Java\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int n = mat[0].length, m = mat.length;\\n        boolean[][] seen = new boolean[m][m * 70 + 1];\\n        dfs(0, mat, 0, seen); // DFS to mark all possible sums\\n        for (int i = 0; true; i++){ // BFS to find the answer.\\n            for (int j = 0, sign = 1; j < 2; j++, sign *= -1){\\n                int k = target - i * sign;\\n                if (k >= 0 && k <= m * 70 && seen[m - 1][k])\\n                    return i;\\n            }\\n        }\\n    }\\n\\n    private void dfs(int i, int[][] mat, int sum, boolean[][] seen){\\n        if (i == mat.length)\\n            return;\\n\\n        for (int j = 0; j < mat[i].length; j++){\\n            if (!seen[i][sum + mat[i][j]]){\\n                seen[i][sum + mat[i][j]] = true;\\n                dfs(i + 1, mat, sum + mat[i][j], seen);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int n = mat[0].length, m = mat.length;\\n        boolean[][] seen = new boolean[m][m * 70 + 1];\\n        dfs(0, mat, 0, seen); // DFS to mark all possible sums\\n        for (int i = 0; true; i++){ // BFS to find the answer.\\n            for (int j = 0, sign = 1; j < 2; j++, sign *= -1){\\n                int k = target - i * sign;\\n                if (k >= 0 && k <= m * 70 && seen[m - 1][k])\\n                    return i;\\n            }\\n        }\\n    }\\n\\n    private void dfs(int i, int[][] mat, int sum, boolean[][] seen){\\n        if (i == mat.length)\\n            return;\\n\\n        for (int j = 0; j < mat[i].length; j++){\\n            if (!seen[i][sum + mat[i][j]]){\\n                seen[i][sum + mat[i][j]] = true;\\n                dfs(i + 1, mat, sum + mat[i][j], seen);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893921,
                "title": "dp-memoization",
                "content": "class Solution {\\npublic:\\n     int dp[71][5000];\\n     void funct(vector<vector<int>>& mat,int n,int m,int target,int &ans,int k,int sum)\\n     {\\n        if(dp[k][sum]!=-1)\\n        return;\\n        dp[k][sum]=1; \\n        if(k==n)\\n        {\\n         ans=min(ans,abs(target-sum));\\n         return;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n         funct(mat,n,m,target,ans,k+1,sum+mat[k][i]);  \\n        }\\n     }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n        funct(mat,n,m,target,ans,0,0);  \\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n     int dp[71][5000];\\n     void funct(vector<vector<int>>& mat,int n,int m,int target,int &ans,int k,int sum)\\n     {\\n        if(dp[k][sum]!=-1)\\n        return;\\n        dp[k][sum]=1; \\n        if(k==n)\\n        {\\n         ans=min(ans,abs(target-sum));\\n         return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1875816,
                "title": "c-dp-dfs-memo-pruning",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& nums,vector<vector<int>> &dp, int target,int in,int sum){\\n        if(in>=nums.size()) return abs(sum-target); // if reach end of the matrix, return the abs diff\\n        if(dp[in][sum]!=-1) return dp[in][sum];  // if this state is already been processed, return the result of this state.\\n        int re = INT_MAX;\\n        if(sum>target){  // if sum is already greater the target, than to minimise the abs diff, its better to pick minimum elements from further row now\\n            auto t = *min_element(nums[in].begin(),nums[in].end());\\n            return dp[in][sum] = dfs(nums,dp,target,in+1,sum+t);\\n        }\\n        for(int i = 0; i<nums[0].size();++i){  // try every index form in\\'th row and find the minimum abs difference\\n            re = min(re,dfs(nums,dp,target,in+1,sum+nums[in][i]));\\n        }\\n        return dp[in][sum] = re;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        vector<vector<int>> dp(mat.size(),vector<int>(5005,-1));\\n        return dfs(mat,dp,target,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& nums,vector<vector<int>> &dp, int target,int in,int sum){\\n        if(in>=nums.size()) return abs(sum-target); // if reach end of the matrix, return the abs diff\\n        if(dp[in][sum]!=-1) return dp[in][sum];  // if this state is already been processed, return the result of this state.\\n        int re = INT_MAX;\\n        if(sum>target){  // if sum is already greater the target, than to minimise the abs diff, its better to pick minimum elements from further row now\\n            auto t = *min_element(nums[in].begin(),nums[in].end());\\n            return dp[in][sum] = dfs(nums,dp,target,in+1,sum+t);\\n        }\\n        for(int i = 0; i<nums[0].size();++i){  // try every index form in\\'th row and find the minimum abs difference\\n            re = min(re,dfs(nums,dp,target,in+1,sum+nums[in][i]));\\n        }\\n        return dp[in][sum] = re;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        vector<vector<int>> dp(mat.size(),vector<int>(5005,-1));\\n        return dfs(mat,dp,target,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868499,
                "title": "intutive-very-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        queue=[mat[0][i] for i in range(len(mat[0]))]\\n        currentmin=float(\\'inf\\')\\n        row=1\\n        while(row<len(mat)):\\n            temp=set()\\n            minval=min(mat[row])\\n            for oldval in queue:\\n                if oldval>=target:\\n                    temp.add(oldval+minval)\\n                else:\\n                    for val in mat[row]:\\n                        temp.add(val+oldval)\\n            queue=temp\\n            row+=1\\n        minval=float(\\'inf\\')\\n        for val in queue:\\n            minval=min(minval,abs(val-target))\\n        return minval\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        queue=[mat[0][i] for i in range(len(mat[0]))]\\n        currentmin=float(\\'inf\\')\\n        row=1\\n        while(row<len(mat)):\\n            temp=set()\\n            minval=min(mat[row])\\n            for oldval in queue:\\n                if oldval>=target:\\n                    temp.add(oldval+minval)\\n                else:\\n                    for val in mat[row]:\\n                        temp.add(val+oldval)\\n            queue=temp\\n            row+=1\\n        minval=float(\\'inf\\')\\n        for val in queue:\\n            minval=min(minval,abs(val-target))\\n        return minval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847998,
                "title": "2-methods-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dp[72][5000];\\n    int solve(vector<vector<int>>& mat, int row, int sum, const int& target)\\n    {\\n\\t\\t// Base condition\\n        if(row >= m)\\n        {\\n            return abs(sum - target);\\n        }\\n        \\n\\t\\t// Check if already calculated\\n        if(dp[row][sum] != -1) return dp[row][sum];\\n        \\n        int minDiff = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            minDiff = min(minDiff, solve(mat, row+1, sum+mat[row][i], target));\\n        }\\n        return dp[row][sum] = minDiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(mat, 0, 0, target);;\\n    }\\n};\\n/** Method 2\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<4901>p(1);\\n        for (auto row : mat) {\\n            bitset<4901>pp;\\n            for(auto i:row){\\n                pp|=(p<<i);\\n            }\\n            swap(p,pp);\\n        }\\n \\n \\n        int res = INT_MAX;\\n        for (int i = 0; i < 4901;i++) {\\n            if (p[i])res=min(res, abs(i - target));\\n        }\\n        return res;\\n    }\\n};\\n**/\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dp[72][5000];\\n    int solve(vector<vector<int>>& mat, int row, int sum, const int& target)\\n    {\\n\\t\\t// Base condition\\n        if(row >= m)\\n        {\\n            return abs(sum - target);\\n        }\\n        \\n\\t\\t// Check if already calculated\\n        if(dp[row][sum] != -1) return dp[row][sum];\\n        \\n        int minDiff = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            minDiff = min(minDiff, solve(mat, row+1, sum+mat[row][i], target));\\n        }\\n        return dp[row][sum] = minDiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(mat, 0, 0, target);;\\n    }\\n};\\n/** Method 2\\nclass Solution {\\npublic:\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        bitset<4901>p(1);\\n        for (auto row : mat) {\\n            bitset<4901>pp;\\n            for(auto i:row){\\n                pp|=(p<<i);\\n            }\\n            swap(p,pp);\\n        }\\n \\n \\n        int res = INT_MAX;\\n        for (int i = 0; i < 4901;i++) {\\n            if (p[i])res=min(res, abs(i - target));\\n        }\\n        return res;\\n    }\\n};\\n**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823174,
                "title": "c-dp-pruning-120ms",
                "content": "```\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int minSum = 0;\\n        for (auto& v:mat){\\n            set<int> st(v.begin(), v.end());\\n            v = vector<int>(st.begin(), st.end());\\n            minSum += v[0];\\n        }\\n        \\n        if(minSum >= target)\\n            return minSum - target;        \\n        \\n        const int N = target*2 - minSum + 1;\\n        int has[5000] = {false};\\n        has[0] = true;\\n        for (const auto& v:mat){\\n            for (int i = N-1; i>=0; i--){\\n                if (!has[i]) continue;\\n                has[i] = false;\\n                for (auto x:v){\\n                    if(i+x >= N) break;\\n                    has[i+x] = true;\\n                } \\n            }\\n        }\\n        int res = N;\\n        for (int i = minSum; i < N; i++) \\n            if (has[i]) res = min(res, abs(i-target));\\n\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        int minSum = 0;\\n        for (auto& v:mat){\\n            set<int> st(v.begin(), v.end());\\n            v = vector<int>(st.begin(), st.end());\\n            minSum += v[0];\\n        }\\n        \\n        if(minSum >= target)\\n            return minSum - target;        \\n        \\n        const int N = target*2 - minSum + 1;\\n        int has[5000] = {false};\\n        has[0] = true;\\n        for (const auto& v:mat){\\n            for (int i = N-1; i>=0; i--){\\n                if (!has[i]) continue;\\n                has[i] = false;\\n                for (auto x:v){\\n                    if(i+x >= N) break;\\n                    has[i+x] = true;\\n                } \\n            }\\n        }\\n        int res = N;\\n        for (int i = minSum; i < N; i++) \\n            if (has[i]) res = min(res, abs(i-target));\\n\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1822687,
                "title": "c-bottom-up-o-m-n-800",
                "content": "```\\n\\nint minimizeTheDifference(vector<vector<int>>& mt, int target) {\\n        int n = mt.size(), m = mt[0].size();\\n\\t\\tfor (int i = 0; i < n; i++) sort(mt[i].begin(), mt[i].end());\\n\\t\\tconst int inf = 1e9;\\n\\t\\tvector<vector<int>> dp(n, vector<int>(target + 1, inf));\\n\\t\\tdp[0][0] = mt[0][0];\\n\\t\\tfor (int i = 1; i < n; i++) dp[i][0] = mt[i][0] + dp[i - 1][0];\\n\\t\\tfor (int t = 1; t <= target; t++) {\\n\\t\\t\\tdp[0][t] = mt[0][0];\\n\\t\\t\\tfor (int j = 1; j < m; j++) {\\n\\t\\t\\t\\tif (abs(t - mt[0][j]) < abs(t - dp[0][t]))\\n\\t\\t\\t\\t\\tdp[0][t] = mt[0][j];\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tdp[i][t] = dp[i][t - 1];\\n\\t\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\t\\tint cur = mt[i][j] + dp[i - 1][max(0, t - mt[i][j])];\\n\\t\\t\\t\\t\\tif (abs(cur - t) < abs(dp[i][t] - t))\\n\\t\\t\\t\\t\\t\\tdp[i][t] = cur;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn abs(dp[n - 1][target] - target);\\n    }\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint minimizeTheDifference(vector<vector<int>>& mt, int target) {\\n        int n = mt.size(), m = mt[0].size();\\n\\t\\tfor (int i = 0; i < n; i++) sort(mt[i].begin(), mt[i].end());\\n\\t\\tconst int inf = 1e9;\\n\\t\\tvector<vector<int>> dp(n, vector<int>(target + 1, inf));\\n\\t\\tdp[0][0] = mt[0][0];\\n\\t\\tfor (int i = 1; i < n; i++) dp[i][0] = mt[i][0] + dp[i - 1][0];\\n\\t\\tfor (int t = 1; t <= target; t++) {\\n\\t\\t\\tdp[0][t] = mt[0][0];\\n\\t\\t\\tfor (int j = 1; j < m; j++) {\\n\\t\\t\\t\\tif (abs(t - mt[0][j]) < abs(t - dp[0][t]))\\n\\t\\t\\t\\t\\tdp[0][t] = mt[0][j];\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tdp[i][t] = dp[i][t - 1];\\n\\t\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\t\\tint cur = mt[i][j] + dp[i - 1][max(0, t - mt[i][j])];\\n\\t\\t\\t\\t\\tif (abs(cur - t) < abs(dp[i][t] - t))\\n\\t\\t\\t\\t\\t\\tdp[i][t] = cur;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn abs(dp[n - 1][target] - target);\\n    }\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796911,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1daca118-d4f3-442e-b20a-98cfb90ba368_1645726902.1581254.png)\\n\\n    def minimizeTheDifference1(self, mat, target):\\n        nums = {0}\\n        [nums := {x + sx for x in row for sx in nums} for row in mat]\\n        return min(abs(target - x) for x in nums)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/1daca118-d4f3-442e-b20a-98cfb90ba368_1645726902.1581254.png)\\n\\n    def minimizeTheDifference1(self, mat, target):\\n        nums = {0}\\n        [nums := {x + sx for x in row for sx in nums} for row in mat]\\n        return min(abs(target - x) for x in nums)",
                "codeTag": "Python3"
            },
            {
                "id": 1767087,
                "title": "minimize-the-difference-between-target-and-chosen-elements",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[72][5000];\\n    int n,m;\\n    \\n    int dfs(vector<vector<int>>& mat,int row,int sm,int target){\\n        \\n        //  base case\\n        if(row==n){\\n            return abs(sm-target);\\n        }\\n        \\n        if(dp[row][sm]!=-1) return dp[row][sm];\\n        int min_diff=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            min_diff=min(min_diff,dfs(mat,row+1,sm+mat[row][i],target));\\n            if(min_diff==0) break;\\n        }\\n        \\n        return dp[row][sm]=min_diff;\\n        \\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        n=mat.size();\\n        m=mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(mat,0,0,target);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[72][5000];\\n    int n,m;\\n    \\n    int dfs(vector<vector<int>>& mat,int row,int sm,int target){\\n        \\n        //  base case\\n        if(row==n){\\n            return abs(sm-target);\\n        }\\n        \\n        if(dp[row][sm]!=-1) return dp[row][sm];\\n        int min_diff=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            min_diff=min(min_diff,dfs(mat,row+1,sm+mat[row][i],target));\\n            if(min_diff==0) break;\\n        }\\n        \\n        return dp[row][sm]=min_diff;\\n        \\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        \\n        n=mat.size();\\n        m=mat[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(mat,0,0,target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751850,
                "title": "no-tle-simple-approach",
                "content": "```\\nclass Solution {\\n   public:\\n    int m, n;\\n    int dp[72][5000];\\n    int solve(vector<vector<int>>& mat, int row, int sum, const int& target)\\n    {\\n\\t\\t// Base condition\\n        if(row == m)\\n        {\\n            return abs(sum - target);\\n        }\\n        \\n\\t\\t// Check if already calculated\\n        if(dp[row][sum] != -1) return dp[row][sum];\\n        \\n        int minDiff = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            minDiff = min(minDiff, solve(mat, row+1, sum+mat[row][i], target));\\n            if(minDiff == 0)    break;\\n        }\\n        return dp[row][sum] = minDiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(mat, 0, 0, target);;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int m, n;\\n    int dp[72][5000];\\n    int solve(vector<vector<int>>& mat, int row, int sum, const int& target)\\n    {\\n\\t\\t// Base condition\\n        if(row == m)\\n        {\\n            return abs(sum - target);\\n        }\\n        \\n\\t\\t// Check if already calculated\\n        if(dp[row][sum] != -1) return dp[row][sum];\\n        \\n        int minDiff = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            minDiff = min(minDiff, solve(mat, row+1, sum+mat[row][i], target));\\n            if(minDiff == 0)    break;\\n        }\\n        return dp[row][sum] = minDiff;\\n    }\\n    \\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        m = mat.size();\\n        n = mat[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(mat, 0, 0, target);;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738900,
                "title": "python-3-binary-search-after-sorting-each-row",
                "content": "\\n```\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        \\n        nR,nC = len(mat),len(mat[0])\\n        if nC==1:            return abs(target - sum(r[0] for r in mat))\\n        \\n        listMin,listMax = [0]*nR,[0]*nR\\n        for i,row in enumerate(mat):\\n            row.sort()\\n            listMin[i], listMax[i] = row[0], row[-1]\\n\\n        listMin = list(accumulate(listMin[nR-1:0:-1]))[::-1] + [0]\\n        listMax = list(accumulate(listMax[nR-1:0:-1]))[::-1] + [0]\\n        \\n        retS = {0}\\n        for i in range(nR):\\n            retSN = set()\\n            for n in retS:\\n                l = bisect_left(mat[i],target-listMax[i]-n)\\n                r = bisect_right(mat[i],target-listMin[i]-n)\\n                retSN.update( set(n+nn for nn in mat[i][max(0,l-1):r+1]) )\\n            retS = retSN\\n        return min( abs(target-n) for n in retS )\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        \\n        nR,nC = len(mat),len(mat[0])\\n        if nC==1:            return abs(target - sum(r[0] for r in mat))\\n        \\n        listMin,listMax = [0]*nR,[0]*nR\\n        for i,row in enumerate(mat):\\n            row.sort()\\n            listMin[i], listMax[i] = row[0], row[-1]\\n\\n        listMin = list(accumulate(listMin[nR-1:0:-1]))[::-1] + [0]\\n        listMax = list(accumulate(listMax[nR-1:0:-1]))[::-1] + [0]\\n        \\n        retS = {0}\\n        for i in range(nR):\\n            retSN = set()\\n            for n in retS:\\n                l = bisect_left(mat[i],target-listMax[i]-n)\\n                r = bisect_right(mat[i],target-listMin[i]-n)\\n                retSN.update( set(n+nn for nn in mat[i][max(0,l-1):r+1]) )\\n            retS = retSN\\n        return min( abs(target-n) for n in retS )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1726258,
                "title": "golang-brute",
                "content": "```\\nfunc minimizeTheDifference(mat [][]int, target int) int {\\n    m := len(mat)\\n    n := len(mat[0])\\n    a := make([]bool, 4901)\\n    a[0] = true\\n    for i := 0; i < m; i++ {\\n        b := make([]bool, 4901)\\n        for j := 0; j < n; j++ {\\n            for k, v := range a {\\n                if v && k + mat[i][j] >= 1 && k + mat[i][j] <= 4900 {\\n                    b[k + mat[i][j]] = true\\n                }     \\n            } \\n        }\\n        a = b\\n    }\\n    res := math.MaxInt64\\n    for k, v := range a {\\n        if v {\\n            res = min(res, abs(target - k))\\n        }\\n    }\\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a > 0 {\\n        return a\\n    }\\n    return -a\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimizeTheDifference(mat [][]int, target int) int {\\n    m := len(mat)\\n    n := len(mat[0])\\n    a := make([]bool, 4901)\\n    a[0] = true\\n    for i := 0; i < m; i++ {\\n        b := make([]bool, 4901)\\n        for j := 0; j < n; j++ {\\n            for k, v := range a {\\n                if v && k + mat[i][j] >= 1 && k + mat[i][j] <= 4900 {\\n                    b[k + mat[i][j]] = true\\n                }     \\n            } \\n        }\\n        a = b\\n    }\\n    res := math.MaxInt64\\n    for k, v := range a {\\n        if v {\\n            res = min(res, abs(target - k))\\n        }\\n    }\\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a > 0 {\\n        return a\\n    }\\n    return -a\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1717254,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mn=INT_MAX;\\n    bool dp[71][5000];\\n    void dfs(vector<vector<int>>& mat,int i,int &target,int cur){\\n        if(cur-mn>=target || i>mat.size() || (dp[i][cur])) return;\\n        if(i==mat.size())mn=min(mn,abs(target-cur));\\n        else{            \\n            for(int j=0;j<mat[0].size();j++)\\n                dfs(mat,i+1,target,cur+mat[i][j]);            \\n        }\\n        dp[i][cur]=true;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,false,sizeof(dp));\\n        dfs(mat,0,target,0);\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mn=INT_MAX;\\n    bool dp[71][5000];\\n    void dfs(vector<vector<int>>& mat,int i,int &target,int cur){\\n        if(cur-mn>=target || i>mat.size() || (dp[i][cur])) return;\\n        if(i==mat.size())mn=min(mn,abs(target-cur));\\n        else{            \\n            for(int j=0;j<mat[0].size();j++)\\n                dfs(mat,i+1,target,cur+mat[i][j]);            \\n        }\\n        dp[i][cur]=true;\\n    }\\n    int minimizeTheDifference(vector<vector<int>>& mat, int target) {\\n        memset(dp,false,sizeof(dp));\\n        dfs(mat,0,target,0);\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672928,
                "title": "simple-java-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int m=mat.length,n=mat[0].length;\\n        Integer[][] dp=new Integer[m+1][10000];\\n        return rec(mat,0,m,n,target,0,dp);\\n    }\\n    int rec(int[][] mat,int idx,int m,int n,int target,int sum,Integer dp[][])\\n    {\\n        if(idx==m)\\n        {\\n            return Math.abs(target-sum);\\n        }\\n        if(dp[idx][sum]!=null)\\n            return dp[idx][sum];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(rec(mat,idx+1,m,n,target,mat[idx][i]+sum,dp),min);\\n        }\\n        return dp[idx][sum]=min;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimizeTheDifference(int[][] mat, int target) {\\n        int m=mat.length,n=mat[0].length;\\n        Integer[][] dp=new Integer[m+1][10000];\\n        return rec(mat,0,m,n,target,0,dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1640111,
                "title": "ruby-working-solution-using-knapsack-approach-without-tle",
                "content": "Time complexity: O(target\\\\*m\\\\*n)\\nSpace complexity: O(target)\\n```ruby\\ndef minimize_the_difference(mat, target)\\n    curr_targets = Array.new(target+1){false}\\n    prev_targets = Array.new(target+1){false}\\n    upper_bound = 1.0/0\\n    prev_targets[0] = true\\n    mat.length.times do |i|\\n       upper_bound += mat[i].min\\n       prev_targets.each_index do |t_i|\\n           next unless prev_targets[t_i]\\n           \\n           mat[i].each_index do |j|\\n               if mat[i][j] + t_i <= target\\n                   curr_targets[mat[i][j] + t_i] = true\\n               elsif upper_bound > mat[i][j] + t_i\\n                   upper_bound = mat[i][j] + t_i\\n               end\\n           end\\n       end\\n        \\n       prev_targets = curr_targets\\n       curr_targets = Array.new(target+1){false}\\n    end\\n\\n    up_diff = upper_bound - target\\n\\n    target.downto(0) do |t|\\n        return target - t if prev_targets[t] && target - t < up_diff\\n    end\\n    return up_diff\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef minimize_the_difference(mat, target)\\n    curr_targets = Array.new(target+1){false}\\n    prev_targets = Array.new(target+1){false}\\n    upper_bound = 1.0/0\\n    prev_targets[0] = true\\n    mat.length.times do |i|\\n       upper_bound += mat[i].min\\n       prev_targets.each_index do |t_i|\\n           next unless prev_targets[t_i]\\n           \\n           mat[i].each_index do |j|\\n               if mat[i][j] + t_i <= target\\n                   curr_targets[mat[i][j] + t_i] = true\\n               elsif upper_bound > mat[i][j] + t_i\\n                   upper_bound = mat[i][j] + t_i\\n               end\\n           end\\n       end\\n        \\n       prev_targets = curr_targets\\n       curr_targets = Array.new(target+1){false}\\n    end\\n\\n    up_diff = upper_bound - target\\n\\n    target.downto(0) do |t|\\n        return target - t if prev_targets[t] && target - t < up_diff\\n    end\\n    return up_diff\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1625987,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MinimizeTheDifference(int[][] mat, int target) {\\n        \\n        if(mat == null || mat.Length == 0)\\n            return Int32.MaxValue;\\n        \\n        HashSet<int> set = new HashSet<int>(new int[]{0});\\n        int m = mat.Length, n = mat[0].Length, minDiff = Int32.MaxValue;\\n        \\n        for(int i = 0; i < m ;i++)\\n        {\\n            HashSet<int> tmp = new HashSet<int>();    \\n            int minMax = Int32.MaxValue; // track the miminal sum that is greater than target  \\n            \\n            for(int j = 0; j < n; j++)\\n            {  \\n                foreach(var sum in set)\\n                {\\n                    int currSum = sum + mat[i][j];\\n                    \\n                    if(currSum > target)\\n                        minMax = Math.Min(minMax, currSum);\\n                    else\\n                        tmp.Add(currSum);\\n                    \\n                    if(i == m - 1)\\n                        minDiff = Math.Min(Math.Abs(sum + mat[i][j] - target), minDiff);   \\n                }\\n            }\\n            \\n            if(minMax != Int32.MaxValue)\\n                tmp.Add(minMax);   \\n            \\n            if(i < m - 1)\\n                set = tmp;\\n        }\\n\\n        return minDiff;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinimizeTheDifference(int[][] mat, int target) {\\n        \\n        if(mat == null || mat.Length == 0)\\n            return Int32.MaxValue;\\n        \\n        HashSet<int> set = new HashSet<int>(new int[]{0});\\n        int m = mat.Length, n = mat[0].Length, minDiff = Int32.MaxValue;\\n        \\n        for(int i = 0; i < m ;i++)\\n        {\\n            HashSet<int> tmp = new HashSet<int>();    \\n            int minMax = Int32.MaxValue; // track the miminal sum that is greater than target  \\n            \\n            for(int j = 0; j < n; j++)\\n            {  \\n                foreach(var sum in set)\\n                {\\n                    int currSum = sum + mat[i][j];\\n                    \\n                    if(currSum > target)\\n                        minMax = Math.Min(minMax, currSum);\\n                    else\\n                        tmp.Add(currSum);\\n                    \\n                    if(i == m - 1)\\n                        minDiff = Math.Min(Math.Abs(sum + mat[i][j] - target), minDiff);   \\n                }\\n            }\\n            \\n            if(minMax != Int32.MaxValue)\\n                tmp.Add(minMax);   \\n            \\n            if(i < m - 1)\\n                set = tmp;\\n        }\\n\\n        return minDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624186,
                "title": "python-subset-sum",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        if (min_possible_sum := sum(map(min, mat))) > target:\\n            return min_possible_sum - target\\n\\n        max_to_look = target + (target - min_possible_sum)\\n\\n        set_of_sums = {0}\\n\\n        for r in mat:\\n            set_of_sums = {s for e in r for n in set_of_sums if (s := e + n) <= max_to_look}\\n\\n        return min(abs(target - s) for s in set_of_sums)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        if (min_possible_sum := sum(map(min, mat))) > target:\\n            return min_possible_sum - target\\n\\n        max_to_look = target + (target - min_possible_sum)\\n\\n        set_of_sums = {0}\\n\\n        for r in mat:\\n            set_of_sums = {s for e in r for n in set_of_sums if (s := e + n) <= max_to_look}\\n\\n        return min(abs(target - s) for s in set_of_sums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532770,
                "title": "golang-solution",
                "content": "```go\\nfunc minimizeTheDifference(mat [][]int, target int) int {\\n\\tbaseSummary := 0\\n\\tmagic := make([][]int, len(mat))\\n\\tfor ri, rows := range mat {\\n\\t\\tsort.Ints(rows)\\n\\t\\tbaseSummary += rows[0]\\n\\t\\tfor i := 1; i < len(rows); i++ {\\n\\t\\t\\tif rows[i] != rows[i-1] {\\n\\t\\t\\t\\tmagic[ri] = append(magic[ri], rows[i]-rows[0])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tminDifference := abs(target - baseSummary)\\n\\tif baseSummary >= target {\\n\\t\\treturn minDifference\\n\\t}\\n\\thash := make(map[int]bool, 871)\\n\\thash[baseSummary] = true\\n\\tfor _, tires := range magic {\\n\\t\\tmore := make([]int, 0)\\n\\t\\tfor _, tryValue := range tires {\\n\\t\\t\\tfor basic := range hash {\\n\\t\\t\\t\\tif basic+tryValue > 870 {\\n\\t\\t\\t\\t\\t// iteration order is NOT dependent on any sorted criterion\\n\\t\\t\\t\\t\\t// we should continue, not break\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif hash[basic+tryValue] == false {\\n\\t\\t\\t\\t\\t// we can\\'t modify map during iteration\\n\\t\\t\\t\\t\\t// push back to more, insert into map after tires\\n\\t\\t\\t\\t\\tmore = append(more, basic+tryValue)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif basic+tryValue == target {\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor _, mv := range more {\\n\\t\\t\\thash[mv] = true\\n\\t\\t}\\n\\t}\\n\\tfor k := range hash {\\n\\t\\tif curDifference := abs(target - k); curDifference < minDifference {\\n\\t\\t\\tminDifference = curDifference\\n\\t\\t}\\n\\t}\\n\\treturn minDifference\\n}\\n\\nfunc abs(v int) int {\\n\\tif v > 0 {\\n\\t\\treturn v\\n\\t}\\n\\treturn v * -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minimizeTheDifference(mat [][]int, target int) int {\\n\\tbaseSummary := 0\\n\\tmagic := make([][]int, len(mat))\\n\\tfor ri, rows := range mat {\\n\\t\\tsort.Ints(rows)\\n\\t\\tbaseSummary += rows[0]\\n\\t\\tfor i := 1; i < len(rows); i++ {\\n\\t\\t\\tif rows[i] != rows[i-1] {\\n\\t\\t\\t\\tmagic[ri] = append(magic[ri], rows[i]-rows[0])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tminDifference := abs(target - baseSummary)\\n\\tif baseSummary >= target {\\n\\t\\treturn minDifference\\n\\t}\\n\\thash := make(map[int]bool, 871)\\n\\thash[baseSummary] = true\\n\\tfor _, tires := range magic {\\n\\t\\tmore := make([]int, 0)\\n\\t\\tfor _, tryValue := range tires {\\n\\t\\t\\tfor basic := range hash {\\n\\t\\t\\t\\tif basic+tryValue > 870 {\\n\\t\\t\\t\\t\\t// iteration order is NOT dependent on any sorted criterion\\n\\t\\t\\t\\t\\t// we should continue, not break\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif hash[basic+tryValue] == false {\\n\\t\\t\\t\\t\\t// we can\\'t modify map during iteration\\n\\t\\t\\t\\t\\t// push back to more, insert into map after tires\\n\\t\\t\\t\\t\\tmore = append(more, basic+tryValue)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif basic+tryValue == target {\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor _, mv := range more {\\n\\t\\t\\thash[mv] = true\\n\\t\\t}\\n\\t}\\n\\tfor k := range hash {\\n\\t\\tif curDifference := abs(target - k); curDifference < minDifference {\\n\\t\\t\\tminDifference = curDifference\\n\\t\\t}\\n\\t}\\n\\treturn minDifference\\n}\\n\\nfunc abs(v int) int {\\n\\tif v > 0 {\\n\\t\\treturn v\\n\\t}\\n\\treturn v * -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532736,
                "title": "set-and-bitset-python-solution",
                "content": "1/ Set ADT Brute Force (can be time limited)\\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        m = len(mat)\\n        sums = set(mat[0])\\n        for i in range(1, m):\\n            tmp_set = set()\\n            for x in sums:\\n                for y in set(mat[i]):\\n                    tmp_set.add(x + y)\\n            sums = tmp_set\\n        return min(abs(s - target) for s in sums)\\n```\\n2 / Bit manipulation\\nThe solution below is from:\\nhttps://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/discuss/1418933/Python-Using-integer-instead-of-set-or-dict\\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        reachable_sum = 1\\n        for row in mat:\\n            c = 0\\n            for el in row:\\n                c |= (reachable_sum << el)\\n            reachable_sum = c\\n            print(f\"reachable_sum is {reachable_sum}\")\\n            \\n        min_diff = float(\"+inf\")\\n        idx = 0\\n        print(f\"reachable: {reachable_sum}; idx: {idx}\")\\n        while reachable_sum:\\n            print(f\"reachable_sum: {reachable_sum}, idx: {idx}, bool: {reachable_sum & 1}\")\\n            if reachable_sum & 1:\\n                min_diff = min(min_diff, abs(target - idx))\\n            idx += 1\\n            reachable_sum >>= 1\\n            print(f\"min_diff: {min_diff}\")\\n        return min_diff\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        m = len(mat)\\n        sums = set(mat[0])\\n        for i in range(1, m):\\n            tmp_set = set()\\n            for x in sums:\\n                for y in set(mat[i]):\\n                    tmp_set.add(x + y)\\n            sums = tmp_set\\n        return min(abs(s - target) for s in sums)\\n```\n```\\nclass Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        reachable_sum = 1\\n        for row in mat:\\n            c = 0\\n            for el in row:\\n                c |= (reachable_sum << el)\\n            reachable_sum = c\\n            print(f\"reachable_sum is {reachable_sum}\")\\n            \\n        min_diff = float(\"+inf\")\\n        idx = 0\\n        print(f\"reachable: {reachable_sum}; idx: {idx}\")\\n        while reachable_sum:\\n            print(f\"reachable_sum: {reachable_sum}, idx: {idx}, bool: {reachable_sum & 1}\")\\n            if reachable_sum & 1:\\n                min_diff = min(min_diff, abs(target - idx))\\n            idx += 1\\n            reachable_sum >>= 1\\n            print(f\"min_diff: {min_diff}\")\\n        return min_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526732,
                "title": "kotlin-dp-solution-runtime-faster-than-75-00-memory-usage-less-than-95-00",
                "content": "```\\nimport kotlin.math.abs\\nimport kotlin.math.min\\n\\nclass Solution {\\n    private var m = 0\\n    private var n = 0\\n    private lateinit var mat: Array<IntArray>\\n    /**\\n     * 1st dimen index: index of starting row\\n     * map\\'s:\\n     *  - key: new target\\n     *  - value: minimizeTheDifference\\n     * */\\n    private lateinit var ansMaps: Array<MutableMap<Int, Int>>\\n    \\n\\n    fun minimizeTheDifference(mat: Array<IntArray>, target: Int): Int {\\n        m = mat.size\\n        n = mat.first().size\\n\\n        ansMaps = Array(m) { HashMap<Int, Int>() }\\n        this.mat = mat\\n\\n        // sort each row\\n        mat.forEach { it.sort() }\\n\\n        val firstColSum = mat.sumBy { it.first() }\\n\\n        return when {\\n            m == 1 -> mat.first().findMinAbs(target)\\n            n == 1 -> abs(firstColSum - target)\\n            target <= firstColSum -> firstColSum - target\\n            else -> {\\n                fillAnsMaps(0, target)\\n            }\\n        }\\n    }\\n\\n    private fun fillAnsMaps(rowIndex: Int, target: Int): Int {\\n        val ansMap = ansMaps[rowIndex]\\n\\n        if (!ansMap.containsKey(target)) {\\n            val row = mat[rowIndex]\\n            var ans = Int.MAX_VALUE\\n            if (rowIndex == mat.lastIndex) {\\n                ans = row.findMinAbs(target)\\n            } else {\\n                val nextRowIndex = rowIndex + 1\\n                val remainingRowCount = m - rowIndex\\n                when {\\n                    target <= remainingRowCount -> {\\n                        ans = min(ans, fillAnsMaps(nextRowIndex, target - row.first()))\\n                    }\\n                    target >= remainingRowCount * 70 -> {\\n                        ans = min(ans, fillAnsMaps(nextRowIndex, target - row.last()))\\n                    }\\n                    else -> {\\n                        row.forEach { cell ->\\n                            ans = min(ans, fillAnsMaps(nextRowIndex, target - cell))\\n                        }\\n                    }\\n                }\\n            }\\n            ansMap[target] = ans\\n        }\\n\\n        return ansMap[target]!!\\n    }\\n\\n    /** @receiver sorted, size >= 2 */\\n    private fun IntArray.findMinAbs(target: Int): Int {\\n        return when {\\n            size == 2 -> kotlin.math.min(abs(this[0] - target), abs(this[1] - target))\\n            target <= first() -> abs(target - first())\\n            target >= last() -> abs(target - last())\\n            else -> {\\n                // binary search\\n                var startIndex = 0\\n                var endIndex = lastIndex\\n\\n                while (endIndex - startIndex >= 2) {\\n                    val midIndex = (startIndex + endIndex) / 2\\n                    val midValue = this[midIndex]\\n                    when {\\n                        midValue == target -> return 0\\n                        midValue < target -> startIndex = midIndex\\n                        target < midValue -> endIndex = midIndex\\n                    }\\n                }\\n\\n                kotlin.math.min(abs(this[startIndex] - target), abs(this[endIndex] - target))\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport kotlin.math.abs\\nimport kotlin.math.min\\n\\nclass Solution {\\n    private var m = 0\\n    private var n = 0\\n    private lateinit var mat: Array<IntArray>\\n    /**\\n     * 1st dimen index: index of starting row\\n     * map\\'s:\\n     *  - key: new target\\n     *  - value: minimizeTheDifference\\n     * */\\n    private lateinit var ansMaps: Array<MutableMap<Int, Int>>\\n    \\n\\n    fun minimizeTheDifference(mat: Array<IntArray>, target: Int): Int {\\n        m = mat.size\\n        n = mat.first().size\\n\\n        ansMaps = Array(m) { HashMap<Int, Int>() }\\n        this.mat = mat\\n\\n        // sort each row\\n        mat.forEach { it.sort() }\\n\\n        val firstColSum = mat.sumBy { it.first() }\\n\\n        return when {\\n            m == 1 -> mat.first().findMinAbs(target)\\n            n == 1 -> abs(firstColSum - target)\\n            target <= firstColSum -> firstColSum - target\\n            else -> {\\n                fillAnsMaps(0, target)\\n            }\\n        }\\n    }\\n\\n    private fun fillAnsMaps(rowIndex: Int, target: Int): Int {\\n        val ansMap = ansMaps[rowIndex]\\n\\n        if (!ansMap.containsKey(target)) {\\n            val row = mat[rowIndex]\\n            var ans = Int.MAX_VALUE\\n            if (rowIndex == mat.lastIndex) {\\n                ans = row.findMinAbs(target)\\n            } else {\\n                val nextRowIndex = rowIndex + 1\\n                val remainingRowCount = m - rowIndex\\n                when {\\n                    target <= remainingRowCount -> {\\n                        ans = min(ans, fillAnsMaps(nextRowIndex, target - row.first()))\\n                    }\\n                    target >= remainingRowCount * 70 -> {\\n                        ans = min(ans, fillAnsMaps(nextRowIndex, target - row.last()))\\n                    }\\n                    else -> {\\n                        row.forEach { cell ->\\n                            ans = min(ans, fillAnsMaps(nextRowIndex, target - cell))\\n                        }\\n                    }\\n                }\\n            }\\n            ansMap[target] = ans\\n        }\\n\\n        return ansMap[target]!!\\n    }\\n\\n    /** @receiver sorted, size >= 2 */\\n    private fun IntArray.findMinAbs(target: Int): Int {\\n        return when {\\n            size == 2 -> kotlin.math.min(abs(this[0] - target), abs(this[1] - target))\\n            target <= first() -> abs(target - first())\\n            target >= last() -> abs(target - last())\\n            else -> {\\n                // binary search\\n                var startIndex = 0\\n                var endIndex = lastIndex\\n\\n                while (endIndex - startIndex >= 2) {\\n                    val midIndex = (startIndex + endIndex) / 2\\n                    val midValue = this[midIndex]\\n                    when {\\n                        midValue == target -> return 0\\n                        midValue < target -> startIndex = midIndex\\n                        target < midValue -> endIndex = midIndex\\n                    }\\n                }\\n\\n                kotlin.math.min(abs(this[startIndex] - target), abs(this[endIndex] - target))\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570559,
                "content": [
                    {
                        "username": "yogita_upadhyay",
                        "content": "How and why to use memorization for this problem?\\n\\nBelow is the recursion tree for the matrix given in left, where each level represents possible sums till that row from the start row.  Nodes in blue are duplicates because their subtrees are going to be  same.\\n\\nJust keep track of whether you have already seen the same sum at same  level or not using `memo[row][sum]`, if yes, don\\'t go down, this is it.\\n\\n![image](https://assets.leetcode.com/users/images/ab339abb-55a6-4408-a2aa-30258861c204_1629619124.6412592.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "ryuk18",
                        "content": "I liked how Leetcode wanted us to understand the BitSet solution to this problem by giving a TLE for DP solution with all 81/81 Test cases passing."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "does it giving \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    }
                ]
            },
            {
                "id": 1570572,
                "content": [
                    {
                        "username": "yogita_upadhyay",
                        "content": "How and why to use memorization for this problem?\\n\\nBelow is the recursion tree for the matrix given in left, where each level represents possible sums till that row from the start row.  Nodes in blue are duplicates because their subtrees are going to be  same.\\n\\nJust keep track of whether you have already seen the same sum at same  level or not using `memo[row][sum]`, if yes, don\\'t go down, this is it.\\n\\n![image](https://assets.leetcode.com/users/images/ab339abb-55a6-4408-a2aa-30258861c204_1629619124.6412592.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "ryuk18",
                        "content": "I liked how Leetcode wanted us to understand the BitSet solution to this problem by giving a TLE for DP solution with all 81/81 Test cases passing."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "does it giving \\n[0.013s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    }
                ]
            }
        ]
    }
]