[
    {
        "title": "Coloring A Border",
        "question_content": "You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.\nTwo squares are called adjacent if they are next to each other in any of the 4 directions.\nTwo squares belong to the same connected component if they have the same color and they are adjacent.\nThe border of a connected component is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column).\nYou should color the border of the connected component that contains the square grid[row][col] with color.\nReturn the final grid.\n&nbsp;\nExample 1:\nInput: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\nOutput: [[3,3],[3,2]]\nExample 2:\nInput: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\nOutput: [[1,3,3],[2,3,3]]\nExample 3:\nInput: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\nOutput: [[2,2,2],[2,1,2],[2,2,2]]\n&nbsp;\nConstraints:\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 50\n\t1 <= grid[i][j], color <= 1000\n\t0 <= row < m\n\t0 <= col < n",
        "solutions": [
            {
                "id": 282847,
                "title": "c-with-picture-dfs",
                "content": "From an initial point, perform DFS and flip the cell color to negative to track visited cells.\\n\\nAfter DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.\\n\\nIn the end, cells with the negative color are on the border. Change their color to the target color.\\n![image](https://assets.leetcode.com/users/votrubac/image_1556425139.png)\\n```\\nvoid dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282839,
                "title": "python-bfs-and-dfs",
                "content": "**Python, DFS:**\\n\\nSuggested by @IvanaGyro, we can color the border inside the DFS.\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]):\\n                return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4:\\n                grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\\n\\n**Python, BFS:**\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else:\\n                    border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]):\\n                return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4:\\n                grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else:\\n                    border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 284935,
                "title": "java-dfs-easy-to-understand",
                "content": "The primary intuition is to do a DFS from the starting cell and find all the cells of the oldColor that needs to be changed. We mark these cells with a negative value of the oldColor. Once this is done, we need to find out which among those cells lies interior and which lies exterior. Interior cells have all 4 neighboring cells(top, bottom, left and right) to have either the oldColor value or -oldColor value. Make these interior cells positive again. Once we have processed this for all necessary nodes from the starting cell, we will get a grid containing negative cells that denote the boundary. We need to sweep through the entire grid and change these negative values to the new color.\\n\\n* Check for existence of null or empty grid and return null if so.\\n* Store the color of starting cell grid[r0][c0] in oldColor.\\n* Initiate a DFS from starting cell.\\n* Check if the current cell lies out of bounds off the grid or if current cell does not have the same color as starting cell and return if so.\\n* Otherwise, change the current cell\\'s color to a negative value for us to remember that we have processed this cell.\\n* Do a DFS for all neighboring points that are up, down, left and right from current cell.\\n* Once DFS returns back for the current cell after processing all directions from it, change the current cell\\'s color back to positive value if you find that the current cell lies within adjacent cells top, bottom, left and right with the same value.\\n* Once the entire DFS has been processed, we now have a grid containing negative values representing the border which needs to be recolored to the new color.\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid == null || grid.length == 0)\\n            return null;\\n        int oldColor = grid[r0][c0];\\n        dfs(grid, r0, c0, oldColor);\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    public void dfs(int[][] grid, int i, int j, int oldColor) {\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != oldColor) \\n            return;\\n        grid[i][j] = -oldColor;\\n        dfs(grid, i+1, j, oldColor);\\n        dfs(grid, i-1, j, oldColor);\\n        dfs(grid, i, j+1, oldColor);\\n        dfs(grid, i, j-1, oldColor);\\n        if(i > 0 && j > 0 && i < grid.length-1 && j < grid[0].length-1\\n           && oldColor == Math.abs(grid[i+1][j])\\n           && oldColor == Math.abs(grid[i-1][j])\\n           && oldColor == Math.abs(grid[i][j+1])\\n           && oldColor == Math.abs(grid[i][j-1]))\\n            grid[i][j] = oldColor;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid == null || grid.length == 0)\\n            return null;\\n        int oldColor = grid[r0][c0];\\n        dfs(grid, r0, c0, oldColor);\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    public void dfs(int[][] grid, int i, int j, int oldColor) {\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != oldColor) \\n            return;\\n        grid[i][j] = -oldColor;\\n        dfs(grid, i+1, j, oldColor);\\n        dfs(grid, i-1, j, oldColor);\\n        dfs(grid, i, j+1, oldColor);\\n        dfs(grid, i, j-1, oldColor);\\n        if(i > 0 && j > 0 && i < grid.length-1 && j < grid[0].length-1\\n           && oldColor == Math.abs(grid[i+1][j])\\n           && oldColor == Math.abs(grid[i-1][j])\\n           && oldColor == Math.abs(grid[i][j+1])\\n           && oldColor == Math.abs(grid[i][j-1]))\\n            grid[i][j] = oldColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693958,
                "title": "java-recursive-dfs-beats-100-time-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[r0][c0]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid, r0, c0, grid[r0][c0], visited, color, n, m);\\n        \\n        return grid;\\n        \\n    }\\n    \\n    public void dfs(int[][] grid, int i, int j, int col, boolean[][] visited, int target, int n, int m){\\n        \\n        if (i>n-1 || i<0 || j>m-1 || j<0 || grid[i][j]!=col || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n        \\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=col || grid[i-1][j]!=col || grid[i][j-1]!=col || grid[i][j+1]!=col)\\n            border = true;\\n        \\n        dfs(grid, i+1, j, col, visited, target, n, m);\\n        dfs(grid, i-1, j, col, visited, target, n, m);\\n        dfs(grid, i, j+1, col, visited, target, n, m);\\n        dfs(grid, i, j-1, col, visited, target, n, m);\\n        \\n        if (border)\\n            grid[i][j] = target;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[r0][c0]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid, r0, c0, grid[r0][c0], visited, color, n, m);\\n        \\n        return grid;\\n        \\n    }\\n    \\n    public void dfs(int[][] grid, int i, int j, int col, boolean[][] visited, int target, int n, int m){\\n        \\n        if (i>n-1 || i<0 || j>m-1 || j<0 || grid[i][j]!=col || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n        \\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=col || grid[i-1][j]!=col || grid[i][j-1]!=col || grid[i][j+1]!=col)\\n            border = true;\\n        \\n        dfs(grid, i+1, j, col, visited, target, n, m);\\n        dfs(grid, i-1, j, col, visited, target, n, m);\\n        dfs(grid, i, j+1, col, visited, target, n, m);\\n        dfs(grid, i, j-1, col, visited, target, n, m);\\n        \\n        if (border)\\n            grid[i][j] = target;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283262,
                "title": "java-python-3-bfs-and-dfs-codes-w-brief-explanation-and-analysis",
                "content": "**Method 1**:\\n\\n**BFS**\\n\\n1. Let m = grid.length, n = grid[0].length, use the number \\nfrom 0 to m * n - 1 to identify the cells to avoid duplicates;\\ne.g., grid[x][y]\\'s cell number is x * n + y; \\n2. put the initial cell [r0, c0] into the Queue then poll it out,\\nthen check if it is on the grid bounday; If yes, color the cell;\\n3. Traverse the cell\\'s 4 neighbors: \\na) if its neighbor is of different color, the cell is on the \\ncomponent border; \\nb) if same color, put the neighbor into Queue;\\n4. repeat the above 2 and 3 till Queue is empty.\\n\\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int clr = grid[r0][c0], m = grid.length, n = grid[0].length;\\n        Set<Integer> component = new HashSet<>(); // put the cell number into Set to avoid visiting again.\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{ r0, c0 }); // add initial cell.\\n        component.add(r0 * n + c0); // add initial cell number.\\n        while (!q.isEmpty()) { // BFS starts.\\n            int r = q.peek()[0], c = q.poll()[1];\\n            if (r == 0 || r == m - 1 || c == 0 || c == n - 1) { grid[r][c] = color; } // on grid boundary.\\n            for (int k = 0; k < 4; ++k) { // travers its 4 neighbors.\\n                int i = r + d[k], j = c + d[k + 1]; // neighbor coordinates.\\n                if (i >= 0 && i < m && j >= 0 && j < n && !component.contains(i * n + j)) { // not visited before.\\n                    if (grid[i][j] == clr) { // its neighbor is of same color, put it into Queue. \\n                        component.add(i * n + j); // avoid visiting again.\\n                        q.offer(new int[]{ i, j }); // put it into Queue. \\n                    }else { // its neighbor is of different color, hence it is on component boundary.\\n                        grid[r][c] = color; \\n                    }\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n```\\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n         m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n        bfs, component = collections.deque([(r0, c0)]), {(r0, c0)}\\n        while bfs:\\n            r, c = bfs.popleft()\\n            if r * c * (r - m + 1) * (c - n + 1) == 0:\\n                grid[r][c] = color\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n and (i, j) not in component:\\n                    if grid[i][j] == clr:\\n                        component.add((i, j))\\n                        bfs.append((i, j))\\n                    else:    \\n                        grid[r][c] = color\\n        return grid\\n```\\n\\n----\\n\\n**Method 2**: \\n\\n**DFS**\\n\\nUse DFS to explore the cell (r0, c0)\\'s component, and negate the visited cell, traverse its 4 neighbors. After the traversal, change back from the negative if the component cell belongs to inner part.\\n\\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        negateBorder(grid, r0, c0, grid[r0][c0]);\\n        for (int[] g : grid) {\\n            for (int i = 0; i < g.length; ++i) {\\n                if (g[i] < 0) { g[i] = color; }\\n            }\\n        }\\n        return grid;\\n    }\\n    private void negateBorder(int[][] grid, int r, int c, int clr) {\\n        grid[r][c] = -clr; // mark as visited.\\n        int cnt = 0; // use to count grid[r][c]\\'s component neighbors (same color as it).\\n        for (int k = 0; k < 4; ++k) { // traverse 4 neighbors.\\n            int i = r + d[k], j = c + d[k + 1]; // neighbor\\'s coordinates.\\n            if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || Math.abs(grid[i][j]) != clr) { continue; } // out of grid or not same component.\\n            ++cnt; // only if the 4 neighbors of grid[r][c] are all have same color as it, it belongs to inner part.\\n            if (grid[i][j] == clr) { negateBorder(grid, i, j, clr); } // recurse with respect to unvisited component neighbor.\\n        }\\n        if (cnt == 4) { grid[r][c] = clr; } // inner part, change back.\\n    }\\n```\\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n\\n        def negateBorder(r, c):\\n            grid[r][c], cnt = -clr, 0\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n:\\n                    cnt +=  abs(grid[i][j]) == clr\\n                    if grid[i][j] == clr:\\n                        negateBorder(i, j)\\n            if cnt == 4:\\n                grid[r][c] = clr\\n                \\n        negateBorder(r0, c0)\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if cell < 0:\\n                    grid[r][c] = color\\n        return grid\\n```\\n\\n**Analysis for both BFS and DFS:**\\nEach cell at most visited `4` times, therefore\\n\\nTime & space: `O(m * n)`, where `m = grid.length, n = grid[0].length.`",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int clr = grid[r0][c0], m = grid.length, n = grid[0].length;\\n        Set<Integer> component = new HashSet<>(); // put the cell number into Set to avoid visiting again.\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{ r0, c0 }); // add initial cell.\\n        component.add(r0 * n + c0); // add initial cell number.\\n        while (!q.isEmpty()) { // BFS starts.\\n            int r = q.peek()[0], c = q.poll()[1];\\n            if (r == 0 || r == m - 1 || c == 0 || c == n - 1) { grid[r][c] = color; } // on grid boundary.\\n            for (int k = 0; k < 4; ++k) { // travers its 4 neighbors.\\n                int i = r + d[k], j = c + d[k + 1]; // neighbor coordinates.\\n                if (i >= 0 && i < m && j >= 0 && j < n && !component.contains(i * n + j)) { // not visited before.\\n                    if (grid[i][j] == clr) { // its neighbor is of same color, put it into Queue. \\n                        component.add(i * n + j); // avoid visiting again.\\n                        q.offer(new int[]{ i, j }); // put it into Queue. \\n                    }else { // its neighbor is of different color, hence it is on component boundary.\\n                        grid[r][c] = color; \\n                    }\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n```\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n         m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n        bfs, component = collections.deque([(r0, c0)]), {(r0, c0)}\\n        while bfs:\\n            r, c = bfs.popleft()\\n            if r * c * (r - m + 1) * (c - n + 1) == 0:\\n                grid[r][c] = color\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n and (i, j) not in component:\\n                    if grid[i][j] == clr:\\n                        component.add((i, j))\\n                        bfs.append((i, j))\\n                    else:    \\n                        grid[r][c] = color\\n        return grid\\n```\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        negateBorder(grid, r0, c0, grid[r0][c0]);\\n        for (int[] g : grid) {\\n            for (int i = 0; i < g.length; ++i) {\\n                if (g[i] < 0) { g[i] = color; }\\n            }\\n        }\\n        return grid;\\n    }\\n    private void negateBorder(int[][] grid, int r, int c, int clr) {\\n        grid[r][c] = -clr; // mark as visited.\\n        int cnt = 0; // use to count grid[r][c]\\'s component neighbors (same color as it).\\n        for (int k = 0; k < 4; ++k) { // traverse 4 neighbors.\\n            int i = r + d[k], j = c + d[k + 1]; // neighbor\\'s coordinates.\\n            if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || Math.abs(grid[i][j]) != clr) { continue; } // out of grid or not same component.\\n            ++cnt; // only if the 4 neighbors of grid[r][c] are all have same color as it, it belongs to inner part.\\n            if (grid[i][j] == clr) { negateBorder(grid, i, j, clr); } // recurse with respect to unvisited component neighbor.\\n        }\\n        if (cnt == 4) { grid[r][c] = clr; } // inner part, change back.\\n    }\\n```\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n\\n        def negateBorder(r, c):\\n            grid[r][c], cnt = -clr, 0\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n:\\n                    cnt +=  abs(grid[i][j]) == clr\\n                    if grid[i][j] == clr:\\n                        negateBorder(i, j)\\n            if cnt == 4:\\n                grid[r][c] = clr\\n                \\n        negateBorder(r0, c0)\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if cell < 0:\\n                    grid[r][c] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 283084,
                "title": "confusing-problem-statement-resolved",
                "content": "What does this mean? \\n\\n> The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\n\\nAlso, I did not get how the `2` on the bottom left in the below example did not change? \\n\\n> [1,2,2]\\n[2,3,2]\\n\\nExpected Output:\\n\\n> [1, 3, 3]\\n[2, 3, 3]\\n\\nIn the above picture, `2` is on the bottom left which was untouched but it does satisfy `or on the boundary of the grid (the first or last row or column).` requirement. Why was it not changed to `3`?\\n\\n**CONFUSION RESOLVED:**\\n\\n* Basically, connected component means all the cells which have the same color as `(r0,c0)` whom you can reach with a `single` DFS or BFS starting from `(r0,c0)`. \\n\\n* You color a cell(**when reached from DFS or BFS**) which have the same color who is either at the border, meaning, first row or last row or first column or last column **OR** if that cell has `at least ` 1 different neighbour(meaning having different color).\\n\\n* **Note that**  I could have used `-1` as one of the ways of marking cells in my below code, but I rather find it silly because what if negative number coloring was allowed(LeetCode should add this as a follow up,lol) ? Best way I found was to use a boolean array for marking cells and safely coloring them. \\n\\nMy Solution:\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid,r0,c0,grid[r0][c0],color,grid.length,grid[0].length,visited);        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid,int row,int col,int color,int new_color,int rows,int cols,boolean[][] visited){\\n       if(!isValid(row,col,rows,cols) || visited[row][col] || grid[row][col] != color){\\n            return;\\n       }\\n     \\n        visited[row][col] = true;\\n        \\n        if(row == 0 || col == 0 || row == rows-1 || col == cols-1 || differentComponentNeighbours(grid,row,col,rows,cols,visited,color)){\\n            grid[row][col] = new_color;\\n        }\\n        \\n        dfs(grid,row-1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row+1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col-1,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col+1,color,new_color,rows,cols,visited);\\n    }\\n    \\n    private boolean differentComponentNeighbours(int[][] grid,int row,int col,int rows,int cols,boolean[][] visited,int color){\\n        if(isValid(row-1,col,rows,cols) && !visited[row-1][col] && grid[row-1][col] != color) return true;\\n        if(isValid(row+1,col,rows,cols) && !visited[row+1][col] && grid[row+1][col] != color) return true;\\n        if(isValid(row,col-1,rows,cols) && !visited[row][col-1] && grid[row][col-1] != color) return true;\\n        if(isValid(row,col+1,rows,cols) && !visited[row][col+1] && grid[row][col+1] != color) return true;\\n        return false;\\n    }\\n    \\n    private boolean isValid(int row,int col,int rows,int cols){\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid,r0,c0,grid[r0][c0],color,grid.length,grid[0].length,visited);        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid,int row,int col,int color,int new_color,int rows,int cols,boolean[][] visited){\\n       if(!isValid(row,col,rows,cols) || visited[row][col] || grid[row][col] != color){\\n            return;\\n       }\\n     \\n        visited[row][col] = true;\\n        \\n        if(row == 0 || col == 0 || row == rows-1 || col == cols-1 || differentComponentNeighbours(grid,row,col,rows,cols,visited,color)){\\n            grid[row][col] = new_color;\\n        }\\n        \\n        dfs(grid,row-1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row+1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col-1,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col+1,color,new_color,rows,cols,visited);\\n    }\\n    \\n    private boolean differentComponentNeighbours(int[][] grid,int row,int col,int rows,int cols,boolean[][] visited,int color){\\n        if(isValid(row-1,col,rows,cols) && !visited[row-1][col] && grid[row-1][col] != color) return true;\\n        if(isValid(row+1,col,rows,cols) && !visited[row+1][col] && grid[row+1][col] != color) return true;\\n        if(isValid(row,col-1,rows,cols) && !visited[row][col-1] && grid[row][col-1] != color) return true;\\n        if(isValid(row,col+1,rows,cols) && !visited[row][col+1] && grid[row][col+1] != color) return true;\\n        return false;\\n    }\\n    \\n    private boolean isValid(int row,int col,int rows,int cols){\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783380,
                "title": "expalanation-of-the-problem-statement",
                "content": "consider the 2nd example: ```grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3```\\nthe grid would look like this:\\n![image](https://assets.leetcode.com/users/images/b81e1f42-f919-4a54-9507-9ff6077c2e25_1597042429.4147203.png)\\nNow, the given location is ``` r0 = 0, c0 = 1``` which is the 2nd cell in first row. So, the component would be:\\n![image](https://assets.leetcode.com/users/images/4a571c93-2af4-4f7f-8768-363158557ab9_1597042643.770675.png)\\nNow, coming to the color changing part\\n**change the color of the cell at ```(0, 1)```** because  by the definition of the border\\n```The border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component```\\n1.  it is part of the component\\n2.  it is 4-directionally adjacent to a square not in the component (below it there a cell with color 3, and on the left there is cell with color 1, so, it meets the criteria)\\n![image](https://assets.leetcode.com/users/images/796bde1c-f034-40f1-a463-8b3421543db5_1597045011.3280766.png)\\n\\n\\nNow, **change the color of the cell at ```(0, 2)```**.\\nIt is not 4-directionally adjacent to a square not in the component (it does not have neighbour whose color is different from itself) **but it is on the border of the grid** (i.e., the first or last row or column of the grid). So, we have to change its color.\\n![image](https://assets.leetcode.com/users/images/f3449341-bf34-4ef5-b30d-d54e0d838a39_1597045067.3039854.png)\\n\\nNow, coming to last cell of our component ```(1,2)```, it follows both the criteria\\n1. it is on the border\\n2. it has a neighbour which does not belong to the component and different from itself.\\nSo, we have to change its color.\\n![image](https://assets.leetcode.com/users/images/6ec7d7f8-3fd3-49bf-819e-9ee13a64c31d_1597045304.0051892.png)\\n\\nTherefore, the output is: ```[[1, 3, 3], [2, 3, 3]]```\\n**Why didnt we change the color of cell at ```(1,0)```?**\\nit follows both the criteria, but **it doesnt belong to the component**\\nThis is my understanding of the problem. I stuggled quite a bit to understand the problem statement and I just want to make it simple to understand for others too.\\ncorrect me if I did mistake.",
                "solutionTags": [],
                "code": "```grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3```\n``` r0 = 0, c0 = 1```\n```(0, 1)```\n```The border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component```\n```(0, 2)```\n```(1,2)```\n```[[1, 3, 3], [2, 3, 3]]```\n```(1,0)```",
                "codeTag": "Unknown"
            },
            {
                "id": 282876,
                "title": "concise-dfs-c",
                "content": "\\tclass Solution {\\n\\t\\tvoid dfs(vector<vector<int>>& grid, int r, int c, int color) {\\n\\t\\t\\tif(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] != color)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tgrid[r][c] = INT_MAX;\\n\\n\\t\\t\\tdfs(grid, r + 1, c, color);\\n\\t\\t\\tdfs(grid, r - 1, c, color);\\n\\t\\t\\tdfs(grid, r, c + 1, color);\\n\\t\\t\\tdfs(grid, r, c - 1, color);\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n\\t\\t\\tint rows, cols;\\n\\n\\t\\t\\tif((rows = grid.size()) == 0 || (cols = grid[0].size()) == 0)\\n\\t\\t\\t\\treturn {};\\n\\n\\t\\t\\tvector<vector<int>> temp = grid;\\n\\t\\t\\tdfs(temp, r0, c0, grid[r0][c0]);\\n\\n\\t\\t\\tfor(int i = 0; i < rows; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < cols; j++) {\\n\\t\\t\\t\\t\\tif(i == 0 || j == 0 || i == rows - 1 || j == cols - 1) {\\n\\t\\t\\t\\t\\t\\tif(temp[i][j] == INT_MAX)\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = color;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif((temp[i][j]) == INT_MAX and \\n\\t\\t\\t\\t\\t\\t   ((temp[i - 1][j] != INT_MAX) || (temp[i + 1][j] != INT_MAX) ||\\n\\t\\t\\t\\t\\t\\t\\t(temp[i][j - 1] != INT_MAX) || (temp[i][j + 1] != INT_MAX)))\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = color;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn grid;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tvoid dfs(vector<vector<int>>& grid, int r, int c, int color) {\\n\\t\\t\\tif(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] != color)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tgrid[r][c] = INT_MAX;\\n\\n\\t\\t\\tdfs(grid, r + 1, c, color);\\n\\t\\t\\tdfs(grid, r - 1, c, color);\\n\\t\\t\\tdfs(grid, r, c + 1, color);\\n\\t\\t\\tdfs(grid, r, c - 1, color);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1372161,
                "title": "beginner-friendly-c-dfs-16ms-78-22",
                "content": "* Easy to understand? must upvote! \\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    bool isVisited[51][51];\\n    vector<vector<int>> result;\\n    int ROW, COL, COLOR;\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j){\\n        if((i>=0 and i<ROW) and (j>=0 and j<COL) and (grid[i][j] == COLOR) and (!isVisited[i][j]))\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isBorder(vector<vector<int>>& grid, int i, int j){\\n        if(i == 0 || i == ROW-1 || j == 0 || j == COL-1)\\n            return true;\\n        if(grid[i][j+1] != COLOR || grid[i][j-1] != COLOR || grid[i+1][j] != COLOR || grid[i-1][j] != COLOR)\\n            return true;\\n        return false;\\n    }\\n    \\n    void DFS(vector<vector<int>>& grid, int i, int j, int color){\\n        isVisited[i][j] = true;\\n        if(isBorder(grid, i, j))\\n            result[i][j] = color;\\n        if(isValid(grid, i, j+1)){\\n            DFS(grid, i, j+1, color);\\n        }\\n        if(isValid(grid, i, j-1)){\\n            DFS(grid, i, j-1, color);\\n        }\\n        if(isValid(grid, i+1, j)){\\n            DFS(grid, i+1, j, color);\\n        }\\n        if(isValid(grid, i-1, j)){\\n            DFS(grid, i-1, j, color);\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        memset(isVisited, false, sizeof isVisited);\\n        ROW = grid.size(); COL = grid[0].size(); COLOR = grid[r0][c0];\\n        result.resize(ROW, vector<int>(COL));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++)\\n                result[i][j] = grid[i][j];\\n        }\\n        DFS(grid, r0, c0, color);\\n        return result;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVisited[51][51];\\n    vector<vector<int>> result;\\n    int ROW, COL, COLOR;\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j){\\n        if((i>=0 and i<ROW) and (j>=0 and j<COL) and (grid[i][j] == COLOR) and (!isVisited[i][j]))\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isBorder(vector<vector<int>>& grid, int i, int j){\\n        if(i == 0 || i == ROW-1 || j == 0 || j == COL-1)\\n            return true;\\n        if(grid[i][j+1] != COLOR || grid[i][j-1] != COLOR || grid[i+1][j] != COLOR || grid[i-1][j] != COLOR)\\n            return true;\\n        return false;\\n    }\\n    \\n    void DFS(vector<vector<int>>& grid, int i, int j, int color){\\n        isVisited[i][j] = true;\\n        if(isBorder(grid, i, j))\\n            result[i][j] = color;\\n        if(isValid(grid, i, j+1)){\\n            DFS(grid, i, j+1, color);\\n        }\\n        if(isValid(grid, i, j-1)){\\n            DFS(grid, i, j-1, color);\\n        }\\n        if(isValid(grid, i+1, j)){\\n            DFS(grid, i+1, j, color);\\n        }\\n        if(isValid(grid, i-1, j)){\\n            DFS(grid, i-1, j, color);\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        memset(isVisited, false, sizeof isVisited);\\n        ROW = grid.size(); COL = grid[0].size(); COLOR = grid[r0][c0];\\n        result.resize(ROW, vector<int>(COL));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++)\\n                result[i][j] = grid[i][j];\\n        }\\n        DFS(grid, r0, c0, color);\\n        return result;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282884,
                "title": "java-dfs-simple-easy-to-understand-solution-used-more-space-to-make-it-simple",
                "content": "First copying the input grid (`grid`) to output grid(`result`). After this do DFS on `grid` from start point, after visiting all neighbours, mark current point with given color(on `result` grid, input `grid` is not modified at all) if and only if it is in border of the grid OR border of the component (`isBorder`)\\n\\n```\\nprivate int[][] grid;\\n\\n    private int[][] result;\\n\\n    private int R;\\n\\n    private int C;\\n\\n    private boolean[][] visited;\\n\\n    private int finalColor;\\n\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        this.grid = grid;\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n\\n        visited = new boolean[R][C];\\n        finalColor = color;\\n\\n        result = new int[R][C];\\n        for (int r=0; r<R;r++) {\\n            for (int c=0;c<C;c++) {\\n                result[r][c] = grid[r][c];\\n            }\\n        }\\n        dfs(r0,c0, grid[r0][c0]);\\n        return result;\\n    }\\n\\n    private void dfs(int r, int c, int targetColor) {\\n        if (r >= R || r < 0 || c >= C || c < 0)\\n            return;\\n        if (grid[r][c] != targetColor)\\n            return;\\n        if (visited[r][c])\\n            return;\\n\\n        visited[r][c] = true;\\n        dfs(r, c-1, targetColor);\\n        dfs(r, c+1, targetColor);\\n        dfs(r-1, c, targetColor);\\n        dfs(r+1, c, targetColor);\\n\\n        if (isBorder(r,c, targetColor))\\n            result[r][c] = finalColor;\\n    }\\n\\n    private boolean isBorder(int r, int c, int targetColor) {\\n        if (r == R - 1 || c == C - 1 || r == 0 || c == 0)\\n            return true;\\n        int left = grid[r][c-1];\\n        int right = grid[r][c+1];\\n        int top = grid[r-1][c];\\n        int bottom = grid[r+1][c];\\n\\n        if (left != targetColor || right != targetColor || top != targetColor || bottom != targetColor)\\n            return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nprivate int[][] grid;\\n\\n    private int[][] result;\\n\\n    private int R;\\n\\n    private int C;\\n\\n    private boolean[][] visited;\\n\\n    private int finalColor;\\n\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        this.grid = grid;\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n\\n        visited = new boolean[R][C];\\n        finalColor = color;\\n\\n        result = new int[R][C];\\n        for (int r=0; r<R;r++) {\\n            for (int c=0;c<C;c++) {\\n                result[r][c] = grid[r][c];\\n            }\\n        }\\n        dfs(r0,c0, grid[r0][c0]);\\n        return result;\\n    }\\n\\n    private void dfs(int r, int c, int targetColor) {\\n        if (r >= R || r < 0 || c >= C || c < 0)\\n            return;\\n        if (grid[r][c] != targetColor)\\n            return;\\n        if (visited[r][c])\\n            return;\\n\\n        visited[r][c] = true;\\n        dfs(r, c-1, targetColor);\\n        dfs(r, c+1, targetColor);\\n        dfs(r-1, c, targetColor);\\n        dfs(r+1, c, targetColor);\\n\\n        if (isBorder(r,c, targetColor))\\n            result[r][c] = finalColor;\\n    }\\n\\n    private boolean isBorder(int r, int c, int targetColor) {\\n        if (r == R - 1 || c == C - 1 || r == 0 || c == 0)\\n            return true;\\n        int left = grid[r][c-1];\\n        int right = grid[r][c+1];\\n        int top = grid[r-1][c];\\n        int bottom = grid[r+1][c];\\n\\n        if (left != targetColor || right != targetColor || top != targetColor || bottom != targetColor)\\n            return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406166,
                "title": "java-neat-easy-dfs-solution",
                "content": "Just save the border in an additional list and then update the grid. Very simple idea.\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        List<int[]> border = new ArrayList<int[]>();\\n        dfs(grid, r0, c0, grid[r0][c0], border, new boolean[grid.length][grid[0].length]);\\n        \\n        for (int[] coord : border) {\\n            int i = coord[0], j = coord[1];\\n            grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int targetColor, List<int[]> border, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] != targetColor) return;\\n        \\n        visited[i][j] = true;\\n        if (isBorder(grid, i, j, targetColor)) { border.add(new int[]{i, j}); }\\n        \\n        dfs(grid, i+1, j, targetColor, border, visited);\\n        dfs(grid, i-1, j, targetColor, border, visited);\\n        dfs(grid, i, j+1, targetColor, border, visited);\\n        dfs(grid, i, j-1, targetColor, border, visited);\\n    }\\n    \\n    private boolean isBorder(int[][] grid, int i, int j, int targetColor) {\\n        if (i == 0 || j == 0 || i == grid.length - 1 || j == grid[0].length - 1) return true;\\n        return grid[i-1][j] != targetColor || grid[i+1][j] != targetColor || grid[i][j-1] != targetColor || grid[i][j+1] != targetColor;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        List<int[]> border = new ArrayList<int[]>();\\n        dfs(grid, r0, c0, grid[r0][c0], border, new boolean[grid.length][grid[0].length]);\\n        \\n        for (int[] coord : border) {\\n            int i = coord[0], j = coord[1];\\n            grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int targetColor, List<int[]> border, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] != targetColor) return;\\n        \\n        visited[i][j] = true;\\n        if (isBorder(grid, i, j, targetColor)) { border.add(new int[]{i, j}); }\\n        \\n        dfs(grid, i+1, j, targetColor, border, visited);\\n        dfs(grid, i-1, j, targetColor, border, visited);\\n        dfs(grid, i, j+1, targetColor, border, visited);\\n        dfs(grid, i, j-1, targetColor, border, visited);\\n    }\\n    \\n    private boolean isBorder(int[][] grid, int i, int j, int targetColor) {\\n        if (i == 0 || j == 0 || i == grid.length - 1 || j == grid[0].length - 1) return true;\\n        return grid[i-1][j] != targetColor || grid[i+1][j] != targetColor || grid[i][j-1] != targetColor || grid[i][j+1] != targetColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274806,
                "title": "java-0ms-dfs-faster-than-100",
                "content": "class Solution {\\n    \\n    \\n    boolean visited[][];\\n    int col;\\n    int colorr;\\n    \\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        //basically we will to the given node and appy dfs\\n        //while applying dfs we will count the number of calls \\n        //jis bhi node se 4 calls lagi hongi usse change nhi krna hai\\n        //baki sab ko color se paint krdo\\n        col=grid[r0][c0];\\n        colorr=color;\\n        visited=new boolean[grid.length][grid[0].length];\\n        dfs(r0,c0,grid);\\n        return grid;\\n    }\\n    \\n    \\n    public void dfs(int i,int j,int[][]grid){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length){\\n            return;\\n        }\\n        int count=0;\\n        visited[i][j]=true;\\n        grid[i][j]=colorr;\\n        \\n        if(i+1<grid.length && (grid[i+1][j]==col || visited[i+1][j])){\\n            count++;\\n            if(!visited[i+1][j])\\n            dfs(i+1,j,grid);\\n        }\\n        if(i-1>=0 && (grid[i-1][j]==col || visited[i-1][j])){\\n            count++;\\n            if(!visited[i-1][j])\\n            dfs(i-1,j,grid);\\n        }\\n        if(j+1<grid[0].length && (grid[i][j+1]==col || visited[i][j+1])){\\n            count++;\\n            if(!visited[i][j+1])\\n            dfs(i,j+1,grid);\\n        }\\n        if(j-1>=0 && (grid[i][j-1]==col || visited[i][j-1])){\\n            count++;\\n            if(!visited[i][j-1])\\n            dfs(i,j-1,grid);\\n        }\\n        if(count==4){\\n            grid[i][j]=col;\\n        }\\n\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    \\n    \\n    boolean visited[][];\\n    int col;\\n    int colorr;\\n    \\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        //basically we will to the given node and appy dfs\\n        //while applying dfs we will count the number of calls \\n        //jis bhi node se 4 calls lagi hongi usse change nhi krna hai\\n        //baki sab ko color se paint krdo\\n        col=grid[r0][c0];\\n        colorr=color;\\n        visited=new boolean[grid.length][grid[0].length];\\n        dfs(r0,c0,grid);\\n        return grid;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 700750,
                "title": "easy-understandable-using-flip-coloring-beats-100-in-both-space-and-time",
                "content": "Approach : Flip the colors by making it negative check if the given square satisfy the condition of boundary element or not, All the flipped squares will give connected components\\n```\\nclass Solution {\\n    int color_;\\n    public boolean isValid(int i,int j,int row,int col){\\n        return i>=0 && i<row && j>=0 && j<col;\\n    }\\n    public boolean nonBoundary(int [][]grid,int i,int j,int color){\\n        return color == Math.abs(grid[i-1][j]) && color == Math.abs(grid[i][j-1]) && color == Math.abs(grid[i+1][j]) && color == Math.abs(grid[i][j+1]);\\n    }\\n    public void dfs(int [][]grid,int startcolor,int i,int j){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(!isValid(i,j,m,n) || grid[i][j]!=startcolor) return;\\n        grid[i][j] = -startcolor;\\n        dfs(grid,startcolor,i+1,j);\\n        dfs(grid,startcolor,i,j+1);\\n        dfs(grid,startcolor,i,j-1);\\n        dfs(grid,startcolor,i-1,j);\\n        if(i>0 && i<m-1 && j>0 && j<n-1){\\n            if(nonBoundary(grid,i,j,startcolor)){\\n                grid[i][j] = startcolor;\\n            }\\n        }\\n        \\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int startcolor = grid[r0][c0];\\n        color_ = color;\\n        dfs(grid,startcolor,r0,c0);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]<0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int color_;\\n    public boolean isValid(int i,int j,int row,int col){\\n        return i>=0 && i<row && j>=0 && j<col;\\n    }\\n    public boolean nonBoundary(int [][]grid,int i,int j,int color){\\n        return color == Math.abs(grid[i-1][j]) && color == Math.abs(grid[i][j-1]) && color == Math.abs(grid[i+1][j]) && color == Math.abs(grid[i][j+1]);\\n    }\\n    public void dfs(int [][]grid,int startcolor,int i,int j){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(!isValid(i,j,m,n) || grid[i][j]!=startcolor) return;\\n        grid[i][j] = -startcolor;\\n        dfs(grid,startcolor,i+1,j);\\n        dfs(grid,startcolor,i,j+1);\\n        dfs(grid,startcolor,i,j-1);\\n        dfs(grid,startcolor,i-1,j);\\n        if(i>0 && i<m-1 && j>0 && j<n-1){\\n            if(nonBoundary(grid,i,j,startcolor)){\\n                grid[i][j] = startcolor;\\n            }\\n        }\\n        \\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int startcolor = grid[r0][c0];\\n        color_ = color;\\n        dfs(grid,startcolor,r0,c0);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]<0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478469,
                "title": "is-this-test-case-correct",
                "content": "When I submitted my code, it said that the following case did not work. How is the expected solution correct according to the problem description?\\n\\n```\\nInput:\\n[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]\\n1\\n3\\n1\\nOutput:\\n[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]\\nExpected:\\n[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]\\n```\\n```\\n                  ^\\n```\\n\\nThat \"2\" is my problem.",
                "solutionTags": [],
                "code": "```\\nInput:\\n[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]\\n1\\n3\\n1\\nOutput:\\n[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]\\nExpected:\\n[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]\\n```\n```\\n                  ^\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282844,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<int>> &grid, vector<vector<bool>> &colored, int r0, int c0, int color, int connected_col, vector<vector<bool>> &visit) {\\n        if(r0 < 0 or r0 >= grid.size() or c0 < 0 or c0 >= grid[0].size() or grid[r0][c0] != connected_col)\\n            return true;\\n        \\n        if(visit[r0][c0])\\n            return false;\\n        \\n        visit[r0][c0] = true;\\n        if(dfs(grid, colored, r0-1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0+1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0-1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0+1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        if(grid.size() == 0)\\n            return {};\\n        \\n        vector<vector<bool>> colored(grid.size(), vector<bool>(grid[0].size(), false));\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\\n        \\n        dfs(grid, colored, r0, c0, color, grid[r0][c0], visited);\\n        \\n        for(int i = 0; i < colored.size(); i++) {\\n            for(int j = 0; j < colored[0].size(); j++)\\n                if(colored[i][j])\\n                    grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<int>> &grid, vector<vector<bool>> &colored, int r0, int c0, int color, int connected_col, vector<vector<bool>> &visit) {\\n        if(r0 < 0 or r0 >= grid.size() or c0 < 0 or c0 >= grid[0].size() or grid[r0][c0] != connected_col)\\n            return true;\\n        \\n        if(visit[r0][c0])\\n            return false;\\n        \\n        visit[r0][c0] = true;\\n        if(dfs(grid, colored, r0-1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0+1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0-1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0+1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        if(grid.size() == 0)\\n            return {};\\n        \\n        vector<vector<bool>> colored(grid.size(), vector<bool>(grid[0].size(), false));\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\\n        \\n        dfs(grid, colored, r0, c0, color, grid[r0][c0], visited);\\n        \\n        for(int i = 0; i < colored.size(); i++) {\\n            for(int j = 0; j < colored[0].size(); j++)\\n                if(colored[i][j])\\n                    grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686098,
                "title": "detailed-explanation-with-pictures",
                "content": "` Suppose given `\\n![paint1.png](https://assets.leetcode.com/users/images/81a9c04e-3300-4a5b-aec8-23d2d6fd965d_1687797247.1981645.png)\\n\\n``` \\nAll the neighbour(4 directions) of grid[1][3] including neighbours of the neighbours of \\ngrid[1][3]\\n```\\n![paint1.png](https://assets.leetcode.com/users/images/d6939f0f-dce2-4b2b-b292-e4f49b5e8ef0_1687797844.4885716.png)\\n\\n```\\nNow you have to go through the all of those grid[1][3]\\'s neighbours and change the color of \\nthose cells which are on the border(cell whose 4 direction cells values are not equal to\\n that cell value)\\n```\\n```\\nLet\\'s look at the cell grid[1][2].\\n```\\n![mainnnnnn.png](https://assets.leetcode.com/users/images/06cc3008-5f1c-4c29-bfc1-e346b3f523fc_1687799040.5686803.png)\\n\\n```\\nHere only the upper neighbour(green marked) is not same as grid[1][2] (purple marked).\\nSo grid[1][2] is on the border and thus we color it to 1.\\n```\\n```\\nFor grid[1][1] : \\n```\\n![main2.png](https://assets.leetcode.com/users/images/d6da1151-583a-4811-968a-a1bd0bbf4aa5_1687799443.3790708.png)\\n\\n```\\nFor grid[1][1](purple marked) all it\\'s neighbour has the same value as grid[1][1] has, means\\nthis cell is not on the border and that\\'s why we won\\'t color it to 1.\\n```\\n```\\nFinal Output : (red = previous color, blue = new color)\\n```\\n![soll.png](https://assets.leetcode.com/users/images/f6b3551f-c996-4945-bbb8-348d2fe8ed1d_1687800180.4796717.png)\\n\\n\\n### My Solution Explanation :\\n```\\nIf you want to run the dfs and change the border cell to new color in the dfs it would\\nbe huge messy : \\n```\\n![leo.png](https://assets.leetcode.com/users/images/880985b8-14b1-4027-bb6a-04631a3d1743_1687804434.6937025.png)\\n\\n```\\nIf I change the color of grid[1][3] and grid[1][2] at the same time in dfs function, then \\nfor grid[1][1] (purple marked) it\\'s right neighbour(grid[1][2]) is 1 and grid[1][1] will be \\ncolored to 1 as it\\'s all neighbours value are not same as grid[1][1] BUT grid[1][1] can\\'t be\\ncolored to 1 as in the Q it\\'s all neighbour has the same value as its.\\n```\\n```\\nInstead I made a boolean array of the same size as grid and marked all the neighbours of \\ngrid[row][col] as 1 in dfs(). Now I can easily traverse the \\'visited\\' array and change the \\nborder cells of \\'grid\\' to \\'color\\'.\\n```\\n![OPP.png](https://assets.leetcode.com/users/images/c52babc0-2983-4496-860b-21f4ac018440_1687806180.8875253.png)\\n\\n```\\nTo check if the current cell (grid[r][c]) is on the border or not :\\n\\n1. If the cell is on the first or the last row as \\'CELLS ON THE FIRST ROW MISSING UPPER \\n   NEIGHBOUR\\' AND \\'LAST ROW BOTTOM NEIGHBOUR\\'.\\n2. If the cell is on the first colomn(missing left neighbour) or the last colomn(missing right \\n   neighbour)\\n3. If the cell in the middle, then check if all the neighbour has 1 in the \\'visited\\' array, \\n   because if one of them is 0 means it\\'s a border cell. \\n\\n   NO NEED TO CHECK IF THE CELL (WHOSE NEIGHBOURS HAS 1 OR NOT) HAS ALSO 1 BECAUSE UNLESS THAT \\n   CELL HAD NOT 1 WE WOULDN\\'T BE CHECKING IF ALL ITS NEIGHBOURS AS 1 OR NOT.    \\n```\\n\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> diff = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // left up right down\\n    \\n    bool on_border_or_neighbours_not_equal(vector<vector<bool>>& visited, int r, int c){\\n        if(r == 0 || r == visited.size()-1 || c == 0 || c == visited[0].size()-1) // on border conditions\\n            return true;\\n        int left = visited[r][c-1], up = visited[r-1][c], right = visited[r][c+1], down = visited[r+1][c];\\n        return left != 1 || up != 1 || right != 1 || down != 1; // at least one neighbour is different conditions\\n    }\\n    \\n    void create_border(vector<vector<int>>& grid, vector<vector<bool>> &visited, int newcolor)\\n    {\\n        for(int r=0; r<visited.size(); r++)\\n        {\\n            for(int c=0; c<visited[0].size(); c++)\\n                if(visited[r][c] == 1 && on_border_or_neighbours_not_equal(visited, r, c))\\n                    grid[r][c] = newcolor;\\n        }\\n    }\\n\\n    void dfs(vector<vector<int>>& grid, int r, int c, int oldcolor, vector<vector<bool>> &visited)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || visited[r][c] == 1 || grid[r][c] != oldcolor)\\n            return;\\n        visited[r][c] = 1;\\n        for(const auto &d : diff)\\n            dfs(grid, r+d[0], c+d[1], oldcolor, visited);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        dfs(grid, row, col, grid[row][col], visited);\\n        create_border(grid, visited, color);\\n        return grid;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        ROW, COL, oldcolor = len(grid), len(grid[0]), grid[row][col]\\n        visited = [ [0 for _ in range(COL)] for _ in range(ROW) ]\\n\\n        def dfs(r:int, c:int):\\n            if r<0 or r>=ROW or c<0 or c>=COL or visited[r][c] == 1 or grid[r][c] != oldcolor :\\n                return\\n            visited[r][c] = 1\\n            [ dfs(r+x, c+y) for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)) ]\\n        \\n        def on_border_or_neighbours_not_equal(r:int, c:int) -> bool:\\n            if r == 0 or r == ROW-1 or c == 0 or c == COL-1 : # on border\\n                return True\\n            left, up, right, down = visited[r][c-1], visited[r-1][c], visited[r][c+1], visited[r+1][c]\\n            return left != 1 or up != 1 or right != 1 or down != 1 # min 1 neighbour is different or not\\n        \\n        def create_border():\\n            for r in range(ROW):\\n                for c in range(COL):\\n                    if visited[r][c] == 1 and on_border_or_neighbours_not_equal(r, c):\\n                        grid[r][c] = color\\n\\n        dfs(row, col)\\n        create_border()\\n        return grid\\n```\\n```\\nTime  complexity : O(m*n)\\nSpace complexity : O(m*n)\\n```\\n### It took me plenty time to explain everything. If the post was useful to you, an upvote will really make me happy. Thank you for reading it till the end.",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` \\nAll the neighbour(4 directions) of grid[1][3] including neighbours of the neighbours of \\ngrid[1][3]\\n```\n```\\nNow you have to go through the all of those grid[1][3]\\'s neighbours and change the color of \\nthose cells which are on the border(cell whose 4 direction cells values are not equal to\\n that cell value)\\n```\n```\\nLet\\'s look at the cell grid[1][2].\\n```\n```\\nHere only the upper neighbour(green marked) is not same as grid[1][2] (purple marked).\\nSo grid[1][2] is on the border and thus we color it to 1.\\n```\n```\\nFor grid[1][1] : \\n```\n```\\nFor grid[1][1](purple marked) all it\\'s neighbour has the same value as grid[1][1] has, means\\nthis cell is not on the border and that\\'s why we won\\'t color it to 1.\\n```\n```\\nFinal Output : (red = previous color, blue = new color)\\n```\n```\\nIf you want to run the dfs and change the border cell to new color in the dfs it would\\nbe huge messy : \\n```\n```\\nIf I change the color of grid[1][3] and grid[1][2] at the same time in dfs function, then \\nfor grid[1][1] (purple marked) it\\'s right neighbour(grid[1][2]) is 1 and grid[1][1] will be \\ncolored to 1 as it\\'s all neighbours value are not same as grid[1][1] BUT grid[1][1] can\\'t be\\ncolored to 1 as in the Q it\\'s all neighbour has the same value as its.\\n```\n```\\nInstead I made a boolean array of the same size as grid and marked all the neighbours of \\ngrid[row][col] as 1 in dfs(). Now I can easily traverse the \\'visited\\' array and change the \\nborder cells of \\'grid\\' to \\'color\\'.\\n```\n```\\nTo check if the current cell (grid[r][c]) is on the border or not :\\n\\n1. If the cell is on the first or the last row as \\'CELLS ON THE FIRST ROW MISSING UPPER \\n   NEIGHBOUR\\' AND \\'LAST ROW BOTTOM NEIGHBOUR\\'.\\n2. If the cell is on the first colomn(missing left neighbour) or the last colomn(missing right \\n   neighbour)\\n3. If the cell in the middle, then check if all the neighbour has 1 in the \\'visited\\' array, \\n   because if one of them is 0 means it\\'s a border cell. \\n\\n   NO NEED TO CHECK IF THE CELL (WHOSE NEIGHBOURS HAS 1 OR NOT) HAS ALSO 1 BECAUSE UNLESS THAT \\n   CELL HAD NOT 1 WE WOULDN\\'T BE CHECKING IF ALL ITS NEIGHBOURS AS 1 OR NOT.    \\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> diff = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // left up right down\\n    \\n    bool on_border_or_neighbours_not_equal(vector<vector<bool>>& visited, int r, int c){\\n        if(r == 0 || r == visited.size()-1 || c == 0 || c == visited[0].size()-1) // on border conditions\\n            return true;\\n        int left = visited[r][c-1], up = visited[r-1][c], right = visited[r][c+1], down = visited[r+1][c];\\n        return left != 1 || up != 1 || right != 1 || down != 1; // at least one neighbour is different conditions\\n    }\\n    \\n    void create_border(vector<vector<int>>& grid, vector<vector<bool>> &visited, int newcolor)\\n    {\\n        for(int r=0; r<visited.size(); r++)\\n        {\\n            for(int c=0; c<visited[0].size(); c++)\\n                if(visited[r][c] == 1 && on_border_or_neighbours_not_equal(visited, r, c))\\n                    grid[r][c] = newcolor;\\n        }\\n    }\\n\\n    void dfs(vector<vector<int>>& grid, int r, int c, int oldcolor, vector<vector<bool>> &visited)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || visited[r][c] == 1 || grid[r][c] != oldcolor)\\n            return;\\n        visited[r][c] = 1;\\n        for(const auto &d : diff)\\n            dfs(grid, r+d[0], c+d[1], oldcolor, visited);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        dfs(grid, row, col, grid[row][col], visited);\\n        create_border(grid, visited, color);\\n        return grid;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        ROW, COL, oldcolor = len(grid), len(grid[0]), grid[row][col]\\n        visited = [ [0 for _ in range(COL)] for _ in range(ROW) ]\\n\\n        def dfs(r:int, c:int):\\n            if r<0 or r>=ROW or c<0 or c>=COL or visited[r][c] == 1 or grid[r][c] != oldcolor :\\n                return\\n            visited[r][c] = 1\\n            [ dfs(r+x, c+y) for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)) ]\\n        \\n        def on_border_or_neighbours_not_equal(r:int, c:int) -> bool:\\n            if r == 0 or r == ROW-1 or c == 0 or c == COL-1 : # on border\\n                return True\\n            left, up, right, down = visited[r][c-1], visited[r-1][c], visited[r][c+1], visited[r+1][c]\\n            return left != 1 or up != 1 or right != 1 or down != 1 # min 1 neighbour is different or not\\n        \\n        def create_border():\\n            for r in range(ROW):\\n                for c in range(COL):\\n                    if visited[r][c] == 1 and on_border_or_neighbours_not_equal(r, c):\\n                        grid[r][c] = color\\n\\n        dfs(row, col)\\n        create_border()\\n        return grid\\n```\n```\\nTime  complexity : O(m*n)\\nSpace complexity : O(m*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595163,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283803,
                "title": "java-dfs-based-solution-with-explanation-simple-to-understand",
                "content": "\\n# Thought process:\\n\\nRun Depth First Search algorithm to find the connected component where (r0, c0) is part of that connected component.\\nOutput of DFS run is visited[][] array where elements that are part of connected component are marked as 1. Rest of the elements are 0.\\n\\n# Only boundary logic is left:\\n\\nTraverse through visited[][] array:\\n\\nIf visited element (visited[][] == 1) is surrounded by all visited nodes (if all neighbors are visited), then keep its color as old. This is case of an internal element.\\n\\nElse give new color since it\\'s a boundary element.\\n    \\n    private boolean isSafe(int[][] grid, int x, int y, int initialColor, int[][] visited)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n    \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return ((visited[x][y] == 0) && (grid[x][y] == initialColor));\\n    }\\n\\t\\n    private void DFS(int[][] grid, int r, int c, int initialColor, int color, int[][] visited)\\n    {\\n        visited[r][c] = 1;\\n        \\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = r + row[k];\\n            y = c + column[k];\\n            \\n            if(isSafe(grid, x, y, initialColor, visited))\\n            {\\n                DFS(grid, x, y, initialColor, color, visited);\\n            }\\n        }\\n        \\n    }\\n    \\n    private boolean isVisitedAndSafe(int x, int y, int[][] visited)\\n    {\\n        int n = visited.length;\\n        int m = visited[0].length;\\n        \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return visited[x][y] == 1;\\n    }\\n    \\n    private boolean isBorder(int i, int j, int[][] visited)\\n    {\\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int count = 0;\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = i + row[k];\\n            y = j + column[k];\\n            \\n            if(isVisitedAndSafe(x, y, visited))\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        if(count == 4)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private int[][] DFSUtil(int[][] grid, int r, int c, int color)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] visited = new int[n][m]; //initialized as 0\\n        int initialColor = grid[r][c];\\n        \\n        DFS(grid, r, c, initialColor, color, visited);\\n        \\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                {\\n                    if(isBorder(i, j, visited))\\n                        grid[i][j] = color;\\n                }\\n            }\\n        \\n        return grid;\\n        \\n    }\\n\\t\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        return DFSUtil(grid, r0,c0,color);\\n    }",
                "solutionTags": [],
                "code": "\\n# Thought process:\\n\\nRun Depth First Search algorithm to find the connected component where (r0, c0) is part of that connected component.\\nOutput of DFS run is visited[][] array where elements that are part of connected component are marked as 1. Rest of the elements are 0.\\n\\n# Only boundary logic is left:\\n\\nTraverse through visited[][] array:\\n\\nIf visited element (visited[][] == 1) is surrounded by all visited nodes (if all neighbors are visited), then keep its color as old. This is case of an internal element.\\n\\nElse give new color since it\\'s a boundary element.\\n    \\n    private boolean isSafe(int[][] grid, int x, int y, int initialColor, int[][] visited)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n    \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return ((visited[x][y] == 0) && (grid[x][y] == initialColor));\\n    }\\n\\t\\n    private void DFS(int[][] grid, int r, int c, int initialColor, int color, int[][] visited)\\n    {\\n        visited[r][c] = 1;\\n        \\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = r + row[k];\\n            y = c + column[k];\\n            \\n            if(isSafe(grid, x, y, initialColor, visited))\\n            {\\n                DFS(grid, x, y, initialColor, color, visited);\\n            }\\n        }\\n        \\n    }\\n    \\n    private boolean isVisitedAndSafe(int x, int y, int[][] visited)\\n    {\\n        int n = visited.length;\\n        int m = visited[0].length;\\n        \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return visited[x][y] == 1;\\n    }\\n    \\n    private boolean isBorder(int i, int j, int[][] visited)\\n    {\\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int count = 0;\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = i + row[k];\\n            y = j + column[k];\\n            \\n            if(isVisitedAndSafe(x, y, visited))\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        if(count == 4)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private int[][] DFSUtil(int[][] grid, int r, int c, int color)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] visited = new int[n][m]; //initialized as 0\\n        int initialColor = grid[r][c];\\n        \\n        DFS(grid, r, c, initialColor, color, visited);\\n        \\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                {\\n                    if(isBorder(i, j, visited))\\n                        grid[i][j] = color;\\n                }\\n            }\\n        \\n        return grid;\\n        \\n    }\\n\\t\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        return DFSUtil(grid, r0,c0,color);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 282960,
                "title": "easy-java-iterative-solution-using-stack",
                "content": "```class Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{r0, c0});\\n        int origin = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        while (!stack.isEmpty()) {\\n            int[] t = stack.pop();\\n            int r = t[0];\\n            int c = t[1];\\n            if (!visited[r][c]) {\\n                if (r == 0 || r == m-1 || c == 0 || c == n-1 || (grid[r-1][c] != origin && grid[r-1][c] != -1) || \\n                   (grid[r+1][c] != origin && grid[r+1][c] != -1) || (grid[r][c-1] != origin && grid[r][c-1] != -1) || \\n                    (grid[r][c+1] != origin && grid[r][c+1] != -1)) \\n                    grid[r][c] = -1; \\n                \\n                visited[r][c] = true;\\n                if (r - 1 >= 0 && origin == grid[r-1][c]) {\\n                    stack.push(new int[]{r-1, c});\\n                }\\n                \\n                if (r + 1 < m && origin == grid[r+1][c]) {\\n                    stack.push(new int[]{r+1, c});\\n                }\\n                \\n                if (c - 1 >= 0 && origin == grid[r][c-1]) {\\n                    stack.push(new int[]{r, c-1});\\n                }\\n                \\n                if (c + 1 < n && origin == grid[r][c+1]) {\\n                    stack.push(new int[]{r, c+1});\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == -1) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{r0, c0}",
                "codeTag": "Java"
            },
            {
                "id": 282871,
                "title": "java-dfs-for-2-times-kinda-long-but-easy-to-understand",
                "content": "First DFS to paint the connect component to -1, then the second DFS to paint the inside square to -2, and the border square to -3. Return the grid by changing -3 squre to color and -2 squre to original color\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int originalColor = grid[r0][c0];\\n        dfs(r0, c0, grid, originalColor);\\n        dfs2(r0, c0, grid);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == -3) {\\n                    grid[i][j] = color;\\n                }\\n                if (grid[i][j] == -2) {\\n                    grid[i][j] = originalColor;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    void dfs(int r, int c, int[][] grid, int color) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != color) {\\n            return;\\n        }\\n        grid[r][c] = -1;\\n        dfs(r-1, c, grid, color);\\n        dfs(r+1, c, grid, color);\\n        dfs(r, c-1, grid, color);\\n        dfs(r, c+1, grid, color);\\n    }\\n    \\n    void dfs2(int r, int c, int[][] grid) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != -1) {\\n            return;\\n        }\\n        grid[r][c] = -3;\\n        if (r-1<0 || r+1==grid.length || c-1<0 || c+1==grid[0].length) {\\n            // do nothing\\n        } else if ((grid[r-1][c] == -1 || grid[r-1][c] == -3 || grid[r-1][c] == -2) \\n                   && (grid[r+1][c] == -1 || grid[r+1][c] == -3 || grid[r+1][c] == -2)\\n                   && (grid[r][c-1] == -1 || grid[r][c-1] == -3 || grid[r][c-1] == -2)\\n                   && (grid[r][c+1] == -1 || grid[r][c+1] == -3 || grid[r][c+1] == -2)) {\\n            grid[r][c] = -2;\\n        }\\n        dfs2(r-1, c, grid);\\n        dfs2(r+1, c, grid);\\n        dfs2(r, c-1, grid);\\n        dfs2(r, c+1, grid);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int originalColor = grid[r0][c0];\\n        dfs(r0, c0, grid, originalColor);\\n        dfs2(r0, c0, grid);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == -3) {\\n                    grid[i][j] = color;\\n                }\\n                if (grid[i][j] == -2) {\\n                    grid[i][j] = originalColor;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    void dfs(int r, int c, int[][] grid, int color) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != color) {\\n            return;\\n        }\\n        grid[r][c] = -1;\\n        dfs(r-1, c, grid, color);\\n        dfs(r+1, c, grid, color);\\n        dfs(r, c-1, grid, color);\\n        dfs(r, c+1, grid, color);\\n    }\\n    \\n    void dfs2(int r, int c, int[][] grid) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != -1) {\\n            return;\\n        }\\n        grid[r][c] = -3;\\n        if (r-1<0 || r+1==grid.length || c-1<0 || c+1==grid[0].length) {\\n            // do nothing\\n        } else if ((grid[r-1][c] == -1 || grid[r-1][c] == -3 || grid[r-1][c] == -2) \\n                   && (grid[r+1][c] == -1 || grid[r+1][c] == -3 || grid[r+1][c] == -2)\\n                   && (grid[r][c-1] == -1 || grid[r][c-1] == -3 || grid[r][c-1] == -2)\\n                   && (grid[r][c+1] == -1 || grid[r][c+1] == -3 || grid[r][c+1] == -2)) {\\n            grid[r][c] = -2;\\n        }\\n        dfs2(r-1, c, grid);\\n        dfs2(r+1, c, grid);\\n        dfs2(r, c-1, grid);\\n        dfs2(r, c+1, grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373784,
                "title": "c-bfs-beats-86-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to get the connected component and then identify the border cells of the connected component.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Run BFS two times\\n- First BFS : Get all the cells which have the same color as the [row, col] given. This will be the connected component of interest\\n- Second BFS : Identify which cells from the first BFS are on the border of the connected component. If the color of the child is different than parent, it means parent is a border cell. Similarly, if the parent itself is on the border of the grid, it is a border cell. Change the color of these border cells\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(r*c)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(r*c)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        queue<pair<int, int>> v;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        vector<vector<int>> move{{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n        q.push(make_pair(row, col));\\n        int og = grid[row][col];\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            v.push(node);\\n            vis[node.first][node.second] = true;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                vis[rn][rc] = true;\\n\\n                if(grid[rn][rc]== og)\\n                    q.push(make_pair(rn, rc));\\n\\n            }\\n        }\\n\\n        vis.clear();\\n        vis.resize(r, vector<bool>(c, false));\\n        while(!v.empty()){\\n            auto node = v.front();\\n            v.pop();\\n\\n            vis[node.first][node.second] = true;\\n            if(node.first == 0 || node.second == 0 || node.first == r -1 || node.second == c-1){\\n                grid[node.first][node.second] = color;\\n                continue;\\n            }\\n\\n            bool border = false;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                if(grid[rn][rc] != og){\\n                    border = true;\\n                    break;\\n                }\\n            }\\n            if(border){\\n                grid[node.first][node.second] = color;\\n            }\\n                \\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        queue<pair<int, int>> v;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        vector<vector<int>> move{{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n        q.push(make_pair(row, col));\\n        int og = grid[row][col];\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            v.push(node);\\n            vis[node.first][node.second] = true;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                vis[rn][rc] = true;\\n\\n                if(grid[rn][rc]== og)\\n                    q.push(make_pair(rn, rc));\\n\\n            }\\n        }\\n\\n        vis.clear();\\n        vis.resize(r, vector<bool>(c, false));\\n        while(!v.empty()){\\n            auto node = v.front();\\n            v.pop();\\n\\n            vis[node.first][node.second] = true;\\n            if(node.first == 0 || node.second == 0 || node.first == r -1 || node.second == c-1){\\n                grid[node.first][node.second] = color;\\n                continue;\\n            }\\n\\n            bool border = false;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                if(grid[rn][rc] != og){\\n                    border = true;\\n                    break;\\n                }\\n            }\\n            if(border){\\n                grid[node.first][node.second] = color;\\n            }\\n                \\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039802,
                "title": "bfs-beats-99-easy-to-understand",
                "content": "Question is poorly articulated so I\\'ll try to explain a bit.\\nAdjacency - Two squares are adjacent id they are in one of the four (up, down, left, right) directions of each other.\\nConnected Component - A connected component is a set of squares which are adjacent to at least one of the squares in the connected component and carry the same color\\nBoundary - A square is said to be a boundary square of a connected component if it\\'s either adjacent to a square of different color or is a boundary square of our grid i.e a square of first or last row or column.\\n\\nNow the question asks us to paint the boundary of the said connected component with a particular given color.\\n\\n**Solution-**\\nNow the solution to it is pretty easy, you traverse the whole conncted component and change the color of each square whose all 4 adjacent sides does not contain the original color.\\n\\n**Simple readable code with the said logic-**\\n\\n\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        change = []\\n        \\n        queue = [[row, col]]\\n        q = 1 \\n        \\n        ori = grid[row][col]\\n        \\n        vis = [[0]*n for i in range(m)]\\n        vis[row][col] = 1 \\n        \\n        while q > 0:\\n            r, c = queue.pop(0)\\n            q -= 1\\n            \\n            sides = 0\\n            \\n            if r-1 >= 0:\\n                if grid[r-1][c] == ori:\\n                    sides += 1\\n                if not vis[r-1][c]:\\n                    vis[r-1][c] = 1 \\n                    if grid[r-1][c] == ori:\\n                        queue.append([r-1, c])\\n                        q += 1        \\n                    \\n            if c-1 >= 0:\\n                if grid[r][c-1] == ori:\\n                    sides += 1\\n                if not vis[r][c-1]:\\n                    vis[r][c-1] = 1 \\n                    if grid[r][c-1] == ori:\\n                        queue.append([r, c-1])\\n                        q += 1       \\n            \\n            if r+1 < m:\\n                if grid[r+1][c] == ori:\\n                    sides += 1\\n                if not vis[r+1][c]:\\n                    vis[r+1][c] = 1 \\n                    if grid[r+1][c] == ori:\\n                        queue.append([r+1, c])\\n                        q += 1 \\n          \\n            if c+1 < n:\\n                if grid[r][c+1] == ori:\\n                    sides += 1\\n                if not vis[r][c+1]:\\n                    vis[r][c+1] = 1 \\n                    if grid[r][c+1] == ori:\\n                        queue.append([r, c+1])\\n                        q += 1 \\n                             \\n            if sides != 4:\\n                change.append([r, c])\\n                \\n        for r, c in change:\\n            grid[r][c] = color \\n            \\n        return grid",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "Question is poorly articulated so I\\'ll try to explain a bit.\\nAdjacency - Two squares are adjacent id they are in one of the four (up, down, left, right) directions of each other.\\nConnected Component - A connected component is a set of squares which are adjacent to at least one of the squares in the connected component and carry the same color\\nBoundary - A square is said to be a boundary square of a connected component if it\\'s either adjacent to a square of different color or is a boundary square of our grid i.e a square of first or last row or column.\\n\\nNow the question asks us to paint the boundary of the said connected component with a particular given color.\\n\\n**Solution-**\\nNow the solution to it is pretty easy, you traverse the whole conncted component and change the color of each square whose all 4 adjacent sides does not contain the original color.\\n\\n**Simple readable code with the said logic-**\\n\\n\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        change = []\\n        \\n        queue = [[row, col]]\\n        q = 1 \\n        \\n        ori = grid[row][col]\\n        \\n        vis = [[0]*n for i in range(m)]\\n        vis[row][col] = 1 \\n        \\n        while q > 0:\\n            r, c = queue.pop(0)\\n            q -= 1\\n            \\n            sides = 0\\n            \\n            if r-1 >= 0:\\n                if grid[r-1][c] == ori:\\n                    sides += 1\\n                if not vis[r-1][c]:\\n                    vis[r-1][c] = 1 \\n                    if grid[r-1][c] == ori:\\n                        queue.append([r-1, c])\\n                        q += 1        \\n                    \\n            if c-1 >= 0:\\n                if grid[r][c-1] == ori:\\n                    sides += 1\\n                if not vis[r][c-1]:\\n                    vis[r][c-1] = 1 \\n                    if grid[r][c-1] == ori:\\n                        queue.append([r, c-1])\\n                        q += 1       \\n            \\n            if r+1 < m:\\n                if grid[r+1][c] == ori:\\n                    sides += 1\\n                if not vis[r+1][c]:\\n                    vis[r+1][c] = 1 \\n                    if grid[r+1][c] == ori:\\n                        queue.append([r+1, c])\\n                        q += 1 \\n          \\n            if c+1 < n:\\n                if grid[r][c+1] == ori:\\n                    sides += 1\\n                if not vis[r][c+1]:\\n                    vis[r][c+1] = 1 \\n                    if grid[r][c+1] == ori:\\n                        queue.append([r, c+1])\\n                        q += 1 \\n                             \\n            if sides != 4:\\n                change.append([r, c])\\n                \\n        for r, c in change:\\n            grid[r][c] = color \\n            \\n        return grid",
                "codeTag": "Java"
            },
            {
                "id": 2769023,
                "title": "c-easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972116,
                "title": "java-dfs-faster-than-100-do-checkout-for-explanation",
                "content": "**Do vote up if you like it :)**\\n \\nMake a DFS call on all connected rcColor (given rowColColor), check all your nbrs, if \"all of them\" is rcColor then you are not a boundary cell and you are not supposed to be colored with color, so keep a mark of that cell(say 1e9), and if \"all of the nbrs is not\" rcColor then you are a boundary Cell.\\n\\nNow, after you come out of DFS call, your boundary cells are all marked with -rcColor and withinBoundary cells are marked with 1e9, so change them accordingly.\\n```\\nclass Solution {\\n    \\n    public int n, m;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int rcColor = grid[row][col];\\n        dfs(row, col, rcColor, grid, dir);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == -rcColor) grid[i][j] = color; // Boundary cell, so mark with color\\n                else if(grid[i][j] == (int)1e9) grid[i][j] = rcColor; // Within boundary cell, so mark with rcColor(original)\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public void dfs(int x, int y, int rcColor, int[][] grid, int[][] dir) {\\n        \\n        grid[x][y] = -rcColor; // visited\\n        int count = 0;\\n        for(int d = 0; d < dir.length; d++) {\\n            int r = x + dir[d][0];\\n            int c = y + dir[d][1];\\n            \\n            if(r >= 0 && r < n && c >= 0 && c < m) {\\n                if(Math.abs(grid[r][c]) == rcColor || grid[r][c] == (int)1e9) count++; // -rcColor, rcColor, 1e9 are same nbrs \\n                if(grid[r][c] == rcColor) { // call on unvisited nbr which is of rcColor\\n                    dfs(r, c, rcColor, grid, dir);\\n                }\\n            }\\n        }\\n        \\n        // Acc. to question if all 4 direction is rcColor, then it is not a boundary cell\\n        // So, mark yourself as 1e9 because if you mark it with rcColor then,\\n        // when you return from this cell, then another cell can call on this cell, considering it unvisited,\\n        // since we are making calls on all connected rcColor cell\\n        if(count == 4) grid[x][y] = (int)1e9; // to keep it visited && a mark for within boundary cell\\n    }\\n    \\n}\\n```\\n-------------------------------------------------------------",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int n, m;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int rcColor = grid[row][col];\\n        dfs(row, col, rcColor, grid, dir);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == -rcColor) grid[i][j] = color; // Boundary cell, so mark with color\\n                else if(grid[i][j] == (int)1e9) grid[i][j] = rcColor; // Within boundary cell, so mark with rcColor(original)\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public void dfs(int x, int y, int rcColor, int[][] grid, int[][] dir) {\\n        \\n        grid[x][y] = -rcColor; // visited\\n        int count = 0;\\n        for(int d = 0; d < dir.length; d++) {\\n            int r = x + dir[d][0];\\n            int c = y + dir[d][1];\\n            \\n            if(r >= 0 && r < n && c >= 0 && c < m) {\\n                if(Math.abs(grid[r][c]) == rcColor || grid[r][c] == (int)1e9) count++; // -rcColor, rcColor, 1e9 are same nbrs \\n                if(grid[r][c] == rcColor) { // call on unvisited nbr which is of rcColor\\n                    dfs(r, c, rcColor, grid, dir);\\n                }\\n            }\\n        }\\n        \\n        // Acc. to question if all 4 direction is rcColor, then it is not a boundary cell\\n        // So, mark yourself as 1e9 because if you mark it with rcColor then,\\n        // when you return from this cell, then another cell can call on this cell, considering it unvisited,\\n        // since we are making calls on all connected rcColor cell\\n        if(count == 4) grid[x][y] = (int)1e9; // to keep it visited && a mark for within boundary cell\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418437,
                "title": "javascript-solution-w-comments",
                "content": "```\\n/**\\n * Color the cells which belong to same connected component of the starting cell\\n * that doesn\\'t have 4 valid adjacent cells with the same value as that of grid[row][col].\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 96 ms, faster than 66.67% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 41.9 MB, less than 100.00% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder1 = function (grid, row, col, color) {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst visited = new Set();\\n\\tconst pixel = grid[row][col];\\n\\n\\tconst traverse = (x, y) => {\\n\\t\\tconst key = `${x}, ${y}`;\\n\\n\\t\\tif (visited.has(key)) return 1;\\n\\n\\t\\tif (x < 0 || x === grid.length) return 0;\\n\\t\\tif (y < 0 || y === grid[0].length) return 0;\\n\\t\\tif (grid[x][y] !== pixel) return 0;\\n\\n\\t\\tvisited.add(key);\\n\\n\\t\\tlet invalid = 1;\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\tinvalid *= traverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// if all 4 adjacents are the same, don\\'t change\\n\\t\\t// if any of the adjacent are different, change color\\n\\t\\tif (invalid) return 1;\\n\\t\\telse grid[x][y] = color;\\n\\n\\t\\treturn 1;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\treturn grid;\\n};\\n\\n/**\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 73 ms, faster than 100.00% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 46.5 MB, less than 45.83% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder = (grid, row, col, color) => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst pixel = grid[row][col];\\n\\n\\t// find borders and mark visited: -pixel\\n\\tconst traverse = (x, y) => {\\n\\t\\tif (x < 0 || x >= grid.length) return;\\n\\t\\tif (y < 0 || y >= grid[0].length) return;\\n\\t\\tif (grid[x][y] !== pixel) return;\\n\\n\\t\\tgrid[x][y] = -pixel; // mark visited\\n\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\ttraverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// check if all adjacents have same color\\n\\t\\tconst invalid = directions.every(([dx, dy]) => {\\n\\t\\t\\t// check if valid x AND y boundary\\n\\t\\t\\tconst validX = x > 0 && x < grid.length - 1;\\n\\t\\t\\tconst validY = y > 0 && y < grid[0].length - 1;\\n\\n\\t\\t\\tif (validX && validY) {\\n\\t\\t\\t\\tconst adjacent = grid[x + dx][y + dy];\\n\\n\\t\\t\\t\\treturn pixel === Math.abs(adjacent);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// revert color if all adjacents are same color\\n\\t\\tif (invalid) grid[x][y] = pixel;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\n\\t// find marked borders and overwrite with new color\\n\\tfor (let r = 0; r < grid.length; ++r)\\n\\t\\tfor (let c = 0; c < grid[r].length; ++c) {\\n\\t\\t\\tconst cv = grid[r][c];\\n\\n\\t\\t\\tif (cv < 0) grid[r][c] = color;\\n\\t\\t}\\n\\n\\treturn grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Color the cells which belong to same connected component of the starting cell\\n * that doesn\\'t have 4 valid adjacent cells with the same value as that of grid[row][col].\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 96 ms, faster than 66.67% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 41.9 MB, less than 100.00% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder1 = function (grid, row, col, color) {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst visited = new Set();\\n\\tconst pixel = grid[row][col];\\n\\n\\tconst traverse = (x, y) => {\\n\\t\\tconst key = `${x}, ${y}`;\\n\\n\\t\\tif (visited.has(key)) return 1;\\n\\n\\t\\tif (x < 0 || x === grid.length) return 0;\\n\\t\\tif (y < 0 || y === grid[0].length) return 0;\\n\\t\\tif (grid[x][y] !== pixel) return 0;\\n\\n\\t\\tvisited.add(key);\\n\\n\\t\\tlet invalid = 1;\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\tinvalid *= traverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// if all 4 adjacents are the same, don\\'t change\\n\\t\\t// if any of the adjacent are different, change color\\n\\t\\tif (invalid) return 1;\\n\\t\\telse grid[x][y] = color;\\n\\n\\t\\treturn 1;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\treturn grid;\\n};\\n\\n/**\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 73 ms, faster than 100.00% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 46.5 MB, less than 45.83% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder = (grid, row, col, color) => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst pixel = grid[row][col];\\n\\n\\t// find borders and mark visited: -pixel\\n\\tconst traverse = (x, y) => {\\n\\t\\tif (x < 0 || x >= grid.length) return;\\n\\t\\tif (y < 0 || y >= grid[0].length) return;\\n\\t\\tif (grid[x][y] !== pixel) return;\\n\\n\\t\\tgrid[x][y] = -pixel; // mark visited\\n\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\ttraverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// check if all adjacents have same color\\n\\t\\tconst invalid = directions.every(([dx, dy]) => {\\n\\t\\t\\t// check if valid x AND y boundary\\n\\t\\t\\tconst validX = x > 0 && x < grid.length - 1;\\n\\t\\t\\tconst validY = y > 0 && y < grid[0].length - 1;\\n\\n\\t\\t\\tif (validX && validY) {\\n\\t\\t\\t\\tconst adjacent = grid[x + dx][y + dy];\\n\\n\\t\\t\\t\\treturn pixel === Math.abs(adjacent);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// revert color if all adjacents are same color\\n\\t\\tif (invalid) grid[x][y] = pixel;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\n\\t// find marked borders and overwrite with new color\\n\\tfor (let r = 0; r < grid.length; ++r)\\n\\t\\tfor (let c = 0; c < grid[r].length; ++c) {\\n\\t\\t\\tconst cv = grid[r][c];\\n\\n\\t\\t\\tif (cv < 0) grid[r][c] = color;\\n\\t\\t}\\n\\n\\treturn grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352828,
                "title": "simple-c-solution-explained-with-comments-and-picture",
                "content": "**This may help to understand the question in more better way**\\n\\n![image](https://assets.leetcode.com/users/images/07c3479b-f0e0-464b-adda-e45f2aaada92_1626872351.374051.png)\\n\\nThanks to @votrubac for the above [image](https://leetcode.com/problems/coloring-a-border/discuss/282847/C%2B%2B-with-picture-DFS)\\n\\n**CODE : **\\n\\n```\\n//all 4 directions\\nint dr[4] = {1,0,0,-1};\\nint dc[4] = {0,1,-1,0};\\n\\nclass Solution {\\n\\t//function to check if the element is inside the grid or not\\n    bool isValid(int i,int j,int r,int c)\\n    {\\n        if(i<0 or j<0 or i>=r or j>=c)\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>> &grid,int r,int c,int i,int j,int col)\\n    {\\n\\t\\t// if (i,j) lies out of the grid or the current square has different color we return\\n        if(!isValid(i,j,r,c) or grid[i][j] != col) \\n            return;\\n        \\n\\t\\t//replace the color of components by -1\\n        grid[i][j] = -1;\\n\\t\\t\\n\\t\\t//calling dfs in all 4 directions\\n        for(int x=0;x<4;x++)\\n            dfs(grid,r,c,i+dr[x],j+dc[x],col);\\n    }\\n    \\n\\t//function to check if a component is surrounded by components from all 4 sides\\n    bool surrounded(vector<vector<int>> &grid,int i,int j,int r,int c)\\n    {   \\n\\t\\t//only non-boundary elements\\n        if(i>0 and j>0 and i<r-1 and j<c-1)\\n        {\\n            if(grid[i-1][j] == -1 and grid[i+1][j] == -1\\n              and grid[i][j-1] == -1 and grid[i][j+1] == -1) \\n                return true; \\n            \\n            else return false;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int col = grid[r0][c0];\\n        \\n        int r = grid.size() , c = grid[0].size();\\n        \\n        dfs(grid,r,c,r0,c0,col);\\n        \\n\\t\\t//hashmap to store positions of the surrounded components\\n        map<pair<int,int>,int> mp;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n\\t\\t\\t\\t//storing all the surrouned coordinates\\n                if(grid[i][j] == -1 and surrounded(grid,i,j,r,c))\\n                {\\n                   mp[{i,j}] = 1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//now coloring all -1 to desired colors \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j] == -1)\\n                {\\n\\t\\t\\t\\t\\t//if surroudned then revert back to original color\\n                    if(mp.find({i,j}) != mp.end()) grid[i][j] = col;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//else color with new color\\n                   else grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(r * c)\\n\\n**Space Complexity :** O(r-2 * c-2) ~ O(r * c) [HASHMAP]",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//all 4 directions\\nint dr[4] = {1,0,0,-1};\\nint dc[4] = {0,1,-1,0};\\n\\nclass Solution {\\n\\t//function to check if the element is inside the grid or not\\n    bool isValid(int i,int j,int r,int c)\\n    {\\n        if(i<0 or j<0 or i>=r or j>=c)\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>> &grid,int r,int c,int i,int j,int col)\\n    {\\n\\t\\t// if (i,j) lies out of the grid or the current square has different color we return\\n        if(!isValid(i,j,r,c) or grid[i][j] != col) \\n            return;\\n        \\n\\t\\t//replace the color of components by -1\\n        grid[i][j] = -1;\\n\\t\\t\\n\\t\\t//calling dfs in all 4 directions\\n        for(int x=0;x<4;x++)\\n            dfs(grid,r,c,i+dr[x],j+dc[x],col);\\n    }\\n    \\n\\t//function to check if a component is surrounded by components from all 4 sides\\n    bool surrounded(vector<vector<int>> &grid,int i,int j,int r,int c)\\n    {   \\n\\t\\t//only non-boundary elements\\n        if(i>0 and j>0 and i<r-1 and j<c-1)\\n        {\\n            if(grid[i-1][j] == -1 and grid[i+1][j] == -1\\n              and grid[i][j-1] == -1 and grid[i][j+1] == -1) \\n                return true; \\n            \\n            else return false;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int col = grid[r0][c0];\\n        \\n        int r = grid.size() , c = grid[0].size();\\n        \\n        dfs(grid,r,c,r0,c0,col);\\n        \\n\\t\\t//hashmap to store positions of the surrounded components\\n        map<pair<int,int>,int> mp;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n\\t\\t\\t\\t//storing all the surrouned coordinates\\n                if(grid[i][j] == -1 and surrounded(grid,i,j,r,c))\\n                {\\n                   mp[{i,j}] = 1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//now coloring all -1 to desired colors \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j] == -1)\\n                {\\n\\t\\t\\t\\t\\t//if surroudned then revert back to original color\\n                    if(mp.find({i,j}) != mp.end()) grid[i][j] = col;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//else color with new color\\n                   else grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227062,
                "title": "c-bfs-95",
                "content": "```\\nclass Solution {\\n    int dirx[4] = {0,1,0,-1};\\n    int diry[4] = {1,0,-1,0};\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> ans = grid;\\n        \\n        int sc = grid[r0][c0];\\n        q.push({r0,c0});\\n        grid[r0][c0] = 2000;\\n        \\n        while(q.size()) {\\n            pair<int, int> p = q.front(); q.pop();\\n            int x = p.first, y = p.second;\\n            bool isBoundary = false;\\n            \\n            for(int k=0; k<4; k++) {\\n                int nx = x + dirx[k];\\n                int ny = y + diry[k];\\n                \\n                if(nx==-1 or nx==m or ny==-1 or ny==n or (grid[nx][ny]!=2000 and grid[nx][ny]!=sc)) {\\n                    isBoundary = true;\\n                }\\n                \\n                if(nx>=0 and nx<m and ny>=0 and ny<n and grid[nx][ny] == sc) {\\n                    grid[nx][ny] = 2000;\\n                    q.push({nx, ny});\\n                }\\n            }\\n            \\n            if(isBoundary) ans[x][y] = color;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int dirx[4] = {0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1112872,
                "title": "c-dfs-0-extra-space-and-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int r, int c,int initial_color)\\n    {\\n        \\n        \\n        // Get size of the gird\\n        int n=grid.size(),m=grid[0].size(),check=0;\\n        \\n        // Check if the given row and column are valid and if the element hasnt already been visited\\n        if(r>=n || r<0 || c>=m || c<0 || grid[r][c]!=initial_color) return;\\n        \\n        // Check if the given element is at the border or not(checking if it is adjacent to a square not in the connected component)\\n        if(r+1<n && (grid[r+1][c]!=initial_color && grid[r+1][c]!=1001 && grid[r+1][c]!=1002)) check=1;\\n        if(r-1>=0 && (grid[r-1][c]!=initial_color && grid[r-1][c]!=1001 && grid[r-1][c]!=1002)) check=1;\\n        if(c+1<m && (grid[r][c+1]!=initial_color && grid[r][c+1]!=1001 && grid[r][c+1]!=1002)) check=1;\\n        if(c-1>=0 && (grid[r][c-1]!=initial_color && grid[r][c-1]!=1001 && grid[r][c-1]!=1002)) check=1;\\n        \\n        // Checking if the element is on the boundry and hence a border element\\n        if(c==m-1 || c==0 || r==0 || r==n-1) check=1;\\n        \\n        // Marking it with 1001 if its a border element\\n        if(check)\\n            grid[r][c]=1001;\\n        \\n        // Marking it with 1002 if its a central element(non border)\\n        else\\n            grid[r][c]=1002;\\n        \\n        // checking and visiting all its immediate neighbours\\n        dfs(grid,r+1,c,initial_color);\\n        dfs(grid,r-1,c,initial_color);\\n        dfs(grid,r,c+1,initial_color);\\n        dfs(grid,r,c-1,initial_color);\\n        \\n        // Changing the central element to its original value hence marking it unvisited \\n        if(grid[r][c]==1002) grid[r][c]=initial_color;\\n        return ;\\n        \\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int initial_color=grid[r0][c0];\\n        dfs(grid,r0,c0,initial_color);\\n        \\n        // Changing 1001 to the desired color \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(grid[i][j]==1001) grid[i][j]=color;         \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int r, int c,int initial_color)\\n    {\\n        \\n        \\n        // Get size of the gird\\n        int n=grid.size(),m=grid[0].size(),check=0;\\n        \\n        // Check if the given row and column are valid and if the element hasnt already been visited\\n        if(r>=n || r<0 || c>=m || c<0 || grid[r][c]!=initial_color) return;\\n        \\n        // Check if the given element is at the border or not(checking if it is adjacent to a square not in the connected component)\\n        if(r+1<n && (grid[r+1][c]!=initial_color && grid[r+1][c]!=1001 && grid[r+1][c]!=1002)) check=1;\\n        if(r-1>=0 && (grid[r-1][c]!=initial_color && grid[r-1][c]!=1001 && grid[r-1][c]!=1002)) check=1;\\n        if(c+1<m && (grid[r][c+1]!=initial_color && grid[r][c+1]!=1001 && grid[r][c+1]!=1002)) check=1;\\n        if(c-1>=0 && (grid[r][c-1]!=initial_color && grid[r][c-1]!=1001 && grid[r][c-1]!=1002)) check=1;\\n        \\n        // Checking if the element is on the boundry and hence a border element\\n        if(c==m-1 || c==0 || r==0 || r==n-1) check=1;\\n        \\n        // Marking it with 1001 if its a border element\\n        if(check)\\n            grid[r][c]=1001;\\n        \\n        // Marking it with 1002 if its a central element(non border)\\n        else\\n            grid[r][c]=1002;\\n        \\n        // checking and visiting all its immediate neighbours\\n        dfs(grid,r+1,c,initial_color);\\n        dfs(grid,r-1,c,initial_color);\\n        dfs(grid,r,c+1,initial_color);\\n        dfs(grid,r,c-1,initial_color);\\n        \\n        // Changing the central element to its original value hence marking it unvisited \\n        if(grid[r][c]==1002) grid[r][c]=initial_color;\\n        return ;\\n        \\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int initial_color=grid[r0][c0];\\n        dfs(grid,r0,c0,initial_color);\\n        \\n        // Changing 1001 to the desired color \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(grid[i][j]==1001) grid[i][j]=color;         \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986426,
                "title": "java-easy-solution-beats-100",
                "content": "So, basically we need to color the border of the given cells(r0, c0) connected component.\\nWe can color a cell if \\n\\t(i). It is the cell at the boundary of our matrix or any element from 0th and last row or column.\\n\\t(ii). If one of the adjacent cell is not of the same color as the color of the given cell(r0, c0).\\n\\n\\n    boolean call(int[][] grid, boolean[][] visited, int row, int col, int color, int component)\\n    {\\n        if(row>= grid.length || row<0 || col>= grid[0].length || col<0)\\n            return true;\\n        else if(visited[row][col])\\n            return false;\\n        else if(grid[row][col]!= component)\\n            return true;\\n\\n        visited[row][col]= true;\\n        boolean should_i_color= call(grid, visited, row+1, col, color, component);\\n        should_i_color|= call(grid, visited, row-1, col, color, component);\\n        should_i_color|= call(grid, visited, row, col+1, color, component);\\n        should_i_color|= call(grid, visited, row, col-1, color, component);\\n\\n        if(should_i_color)\\n            grid[row][col]= color;\\n        return false;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) \\n    {\\n        boolean[][] visited= new boolean[grid.length][grid[0].length];\\n        call(grid, visited, r0, c0, color, grid[r0][c0]);\\n\\n        return grid;\\n    }",
                "solutionTags": [],
                "code": "So, basically we need to color the border of the given cells(r0, c0) connected component.\\nWe can color a cell if \\n\\t(i). It is the cell at the boundary of our matrix or any element from 0th and last row or column.\\n\\t(ii). If one of the adjacent cell is not of the same color as the color of the given cell(r0, c0).\\n\\n\\n    boolean call(int[][] grid, boolean[][] visited, int row, int col, int color, int component)\\n    {\\n        if(row>= grid.length || row<0 || col>= grid[0].length || col<0)\\n            return true;\\n        else if(visited[row][col])\\n            return false;\\n        else if(grid[row][col]!= component)\\n            return true;\\n\\n        visited[row][col]= true;\\n        boolean should_i_color= call(grid, visited, row+1, col, color, component);\\n        should_i_color|= call(grid, visited, row-1, col, color, component);\\n        should_i_color|= call(grid, visited, row, col+1, color, component);\\n        should_i_color|= call(grid, visited, row, col-1, color, component);\\n\\n        if(should_i_color)\\n            grid[row][col]= color;\\n        return false;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) \\n    {\\n        boolean[][] visited= new boolean[grid.length][grid[0].length];\\n        call(grid, visited, r0, c0, color, grid[r0][c0]);\\n\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 906205,
                "title": "c-bfs-solution-explained",
                "content": "Runtime: 32 ms, faster than 74.70% of C++ online submissions for Coloring A Border.\\nMemory Usage: 14.4 MB, less than 13.99% of C++ online submissions for Coloring A Border.\\n\\nColor the border of the connected component. Nodes of connected component has same color and adjacent\\nin any 4 direction. Border of connected component are part of connected component means they have same\\ncolor as the color of the component except -\\na) border node has at least one neighbor node with different color\\nb) border node is in the border of the grid (first or last row or col)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // return true if node position is a border node of connected component\\n    bool isBorder(int &m, int &n, int &tx, int &ty, vector<vector<int>>& grid)\\n    {\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        int px,py;\\n        for(int i=0;i<4;i++)\\n        {\\n            px = tx + rowOffset[i];\\n            py = ty + colOffset[i];\\n            \\n            // node is border node if it has at least one neighbor with different color and so return true\\n            if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]!=grid[px][py]) return true;\\n        }\\n        \\n        // node is border node if it is border of the grid\\n        return (tx==0 || ty==0 || tx==m-1 || ty==n-1);\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track if the square is visited or a border node of connected component\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        \\n        // push source node (r0, c0) in to queue and also mark visited \\n        queue<pair<int,int>>Q;\\n        Q.push({r0,c0});\\n        visited[r0][c0] = 1;\\n        \\n        int tx,ty,px,py;\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        // run BFS until queue is empty\\n        while(!Q.empty())\\n        {\\n            tx = Q.front().first;\\n            ty = Q.front().second;\\n            Q.pop();\\n            \\n            // check if the current node is a border node, if then mark it as border node\\n            if(isBorder(m,n,tx,ty,grid))visited[tx][ty] = 2;            \\n\\n            // check the neighbor nodes\\n            for(int i=0;i<4;i++)\\n            {\\n                px = tx + rowOffset[i];\\n                py = ty + colOffset[i];\\n\\n                // push unvisited neighbor nodes with same color (connected component node) of the current node\\n                if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]==grid[px][py] && visited[px][py]==0)\\n                    visited[px][py] = 1,Q.push({px,py}); \\n            }\\n        }\\n        \\n        // check node positions marked as border node and color them\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(visited[i][j]==2) grid[i][j] = color;\\n        \\n        return grid;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // return true if node position is a border node of connected component\\n    bool isBorder(int &m, int &n, int &tx, int &ty, vector<vector<int>>& grid)\\n    {\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        int px,py;\\n        for(int i=0;i<4;i++)\\n        {\\n            px = tx + rowOffset[i];\\n            py = ty + colOffset[i];\\n            \\n            // node is border node if it has at least one neighbor with different color and so return true\\n            if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]!=grid[px][py]) return true;\\n        }\\n        \\n        // node is border node if it is border of the grid\\n        return (tx==0 || ty==0 || tx==m-1 || ty==n-1);\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track if the square is visited or a border node of connected component\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        \\n        // push source node (r0, c0) in to queue and also mark visited \\n        queue<pair<int,int>>Q;\\n        Q.push({r0,c0});\\n        visited[r0][c0] = 1;\\n        \\n        int tx,ty,px,py;\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        // run BFS until queue is empty\\n        while(!Q.empty())\\n        {\\n            tx = Q.front().first;\\n            ty = Q.front().second;\\n            Q.pop();\\n            \\n            // check if the current node is a border node, if then mark it as border node\\n            if(isBorder(m,n,tx,ty,grid))visited[tx][ty] = 2;            \\n\\n            // check the neighbor nodes\\n            for(int i=0;i<4;i++)\\n            {\\n                px = tx + rowOffset[i];\\n                py = ty + colOffset[i];\\n\\n                // push unvisited neighbor nodes with same color (connected component node) of the current node\\n                if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]==grid[px][py] && visited[px][py]==0)\\n                    visited[px][py] = 1,Q.push({px,py}); \\n            }\\n        }\\n        \\n        // check node positions marked as border node and color them\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(visited[i][j]==2) grid[i][j] = color;\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873995,
                "title": "python-dfs-faster-than-100-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        \\n        def dfs(r, c, current, border, seen):\\n            \\n            # if out of range or seen\\n            if r<0 or c<0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != current or (r,c) in seen:\\n                return\\n            \\n            seen.add((r,c))\\n            \\n            # if it is a border\\n            if (r==0 or c==0 or r==len(grid)-1 or c==len(grid[0])-1 or grid[r-1][c] != current or grid[r+1][c] != current or grid[r][c-1] != current or grid[r][c+1] != current):\\n                border.add((r,c))\\n                \\n                \\n            dfs(r-1, c, current, border, seen)\\n            dfs(r+1, c, current, border, seen)\\n            dfs(r, c-1, current, border, seen)\\n            dfs(r, c+1, current, border, seen)\\n                \\n            return\\n        \\n        if not grid:\\n            return grid\\n        \\n        current = grid[r0][c0]\\n        border = set()\\n        seen = set()\\n        dfs(r0, c0, current, border, seen)\\n        \\n        for elem in border:\\n            grid[elem[0]][elem[1]] = color\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        \\n        def dfs(r, c, current, border, seen):\\n            \\n            # if out of range or seen\\n            if r<0 or c<0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != current or (r,c) in seen:\\n                return\\n            \\n            seen.add((r,c))\\n            \\n            # if it is a border\\n            if (r==0 or c==0 or r==len(grid)-1 or c==len(grid[0])-1 or grid[r-1][c] != current or grid[r+1][c] != current or grid[r][c-1] != current or grid[r][c+1] != current):\\n                border.add((r,c))\\n                \\n                \\n            dfs(r-1, c, current, border, seen)\\n            dfs(r+1, c, current, border, seen)\\n            dfs(r, c-1, current, border, seen)\\n            dfs(r, c+1, current, border, seen)\\n                \\n            return\\n        \\n        if not grid:\\n            return grid\\n        \\n        current = grid[r0][c0]\\n        border = set()\\n        seen = set()\\n        dfs(r0, c0, current, border, seen)\\n        \\n        for elem in border:\\n            grid[elem[0]][elem[1]] = color\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853190,
                "title": "java-dfs-simple-solution-beats-100-runtime",
                "content": "\\nLogic is an application of *Flood Fill* algorithm. Here, there are two additional conditions to be checked: \\n\\n1. bordering cell of the input grid is always a border of the connected component, hence change the color to ncolor. \\n2. current cell bordering a cell (in the four direction) with a different color is also a border of the connected component. \\n\\t\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r, int c, int color) {\\n        dfs(grid,r,c,color,grid[r][c],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n    \\n    public void dfs(int[][] grid, int r, int c, int ncolor, int ocolor, boolean[][] visited){\\n        \\n        visited[r][c]=true;\\n        \\n\\t\\t//1. grid bordering cell is always a border of the connected component\\n        if( r==grid.length-1 || r==0 || c==0 || c==grid[0].length-1 )\\n                grid[r][c]=ncolor;\\n        \\n\\t\\t//2. if the next cell in the four directions is not of the same color, then the current cell is on border of the connected component\\n        if(r+1<grid.length && !visited[r+1][c]){\\n            if(grid[r+1][c]==ocolor)\\n                dfs(grid,r+1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n        \\n\\t\\tif(r-1>=0 && !visited[r-1][c]){\\n            if(grid[r-1][c]==ocolor)\\n                dfs(grid,r-1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n\\t\\t\\n        if(c+1<grid[0].length && !visited[r][c+1]){\\n            if(grid[r][c+1]==ocolor)\\n                dfs(grid,r,c+1,ncolor,ocolor,visited);  \\n            else\\n                grid[r][c]=ncolor;\\n        }\\n            \\n        if(c-1>=0 && !visited[r][c-1]){\\n            if(grid[r][c-1]==ocolor)\\n                dfs(grid,r,c-1,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r, int c, int color) {\\n        dfs(grid,r,c,color,grid[r][c],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n    \\n    public void dfs(int[][] grid, int r, int c, int ncolor, int ocolor, boolean[][] visited){\\n        \\n        visited[r][c]=true;\\n        \\n\\t\\t//1. grid bordering cell is always a border of the connected component\\n        if( r==grid.length-1 || r==0 || c==0 || c==grid[0].length-1 )\\n                grid[r][c]=ncolor;\\n        \\n\\t\\t//2. if the next cell in the four directions is not of the same color, then the current cell is on border of the connected component\\n        if(r+1<grid.length && !visited[r+1][c]){\\n            if(grid[r+1][c]==ocolor)\\n                dfs(grid,r+1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n        \\n\\t\\tif(r-1>=0 && !visited[r-1][c]){\\n            if(grid[r-1][c]==ocolor)\\n                dfs(grid,r-1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n\\t\\t\\n        if(c+1<grid[0].length && !visited[r][c+1]){\\n            if(grid[r][c+1]==ocolor)\\n                dfs(grid,r,c+1,ncolor,ocolor,visited);  \\n            else\\n                grid[r][c]=ncolor;\\n        }\\n            \\n        if(c-1>=0 && !visited[r][c-1]){\\n            if(grid[r][c-1]==ocolor)\\n                dfs(grid,r,c-1,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700798,
                "title": "easy-c-code-using-dfs-with-explanation-easier-to-understand-xd",
                "content": "Temporary visited array is made\\n\\n\\t\\t\\tvis[i][j]=1     -->     point is visited before\\n\\t\\t\\tvis[i][j]=2     -->     point needs to be colored as given color\\n2 conditions to color a point:\\n1) If current point is boundary itself\\n2) if any point adjacent does not have the same color as connected component color\\nIn both these cases... the current point will be coloured\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    void dfs(int u,int v,vector<vector<int>>& A,vector<vector<int>>& vis,int c){\\n        bool ans=false;// denotes weather the color of curent point needs to be changed\\n        vis[u][v]=1;\\n        int n=A.size();\\n        int m=A[0].size();\\n        for(int i=0;i<4;i++){\\n            int x=u+dx[i];\\n            int y=v+dy[i];\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && !vis[x][y] && A[x][y]==c){\\n                dfs(x,y,A,vis,c);//If same color node(unvisited) is found then do the dfs.\\n            }\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && A[x][y]!=c){\\n                ans=true;// If another color adjacent point is found then current point\\'s color needs to be changed\\n            }\\n        }\\n        if(u==0 || v==0 || u==n-1 || v==m-1 || ans){\\n            vis[u][v]=2;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int c=A[r0][c0];\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        dfs(r0,c0,A,vis,c);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==2){\\n                    A[i][j]=color;\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    void dfs(int u,int v,vector<vector<int>>& A,vector<vector<int>>& vis,int c){\\n        bool ans=false;// denotes weather the color of curent point needs to be changed\\n        vis[u][v]=1;\\n        int n=A.size();\\n        int m=A[0].size();\\n        for(int i=0;i<4;i++){\\n            int x=u+dx[i];\\n            int y=v+dy[i];\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && !vis[x][y] && A[x][y]==c){\\n                dfs(x,y,A,vis,c);//If same color node(unvisited) is found then do the dfs.\\n            }\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && A[x][y]!=c){\\n                ans=true;// If another color adjacent point is found then current point\\'s color needs to be changed\\n            }\\n        }\\n        if(u==0 || v==0 || u==n-1 || v==m-1 || ans){\\n            vis[u][v]=2;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int c=A[r0][c0];\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        dfs(r0,c0,A,vis,c);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==2){\\n                    A[i][j]=color;\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481841,
                "title": "simple-c-dsu-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        private static readonly (int, int)[] _directions = { (0,1), (0,-1), (1,0), (-1,0) };\\n\\n        public int[][] ColorBorder(int[][] grid, int r0, int c0, int color)\\n        {\\n            int n = grid.Length;\\n            int m = grid[0].Length;\\n\\n            Unions dsu = new Unions(n * m);\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[i][j] == grid[newI][newJ])\\n                        {\\n                            dsu.Union(ij, newI * m + newJ);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            var targetRoot = dsu.Find(r0 * m + c0);\\n            ISet<(int,int)> border = new HashSet<(int, int)>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    if (dsu.Find(ij) != targetRoot)\\n                    {\\n                        continue;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI < 0 || newI >= n || newJ < 0 || newJ >= m || dsu.Find(newI * m + newJ) != targetRoot)\\n                        {\\n                            border.Add((i, j));\\n                        }\\n                    }\\n                }\\n            }\\n\\n            foreach (var cell in border)\\n            {\\n                grid[cell.Item1][cell.Item2] = color;\\n            }\\n\\n            return grid;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        private static readonly (int, int)[] _directions = { (0,1), (0,-1), (1,0), (-1,0) };\\n\\n        public int[][] ColorBorder(int[][] grid, int r0, int c0, int color)\\n        {\\n            int n = grid.Length;\\n            int m = grid[0].Length;\\n\\n            Unions dsu = new Unions(n * m);\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[i][j] == grid[newI][newJ])\\n                        {\\n                            dsu.Union(ij, newI * m + newJ);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            var targetRoot = dsu.Find(r0 * m + c0);\\n            ISet<(int,int)> border = new HashSet<(int, int)>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    if (dsu.Find(ij) != targetRoot)\\n                    {\\n                        continue;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI < 0 || newI >= n || newJ < 0 || newJ >= m || dsu.Find(newI * m + newJ) != targetRoot)\\n                        {\\n                            border.Add((i, j));\\n                        }\\n                    }\\n                }\\n            }\\n\\n            foreach (var cell in border)\\n            {\\n                grid[cell.Item1][cell.Item2] = color;\\n            }\\n\\n            return grid;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294725,
                "title": "java-clean-short-only-one-pass-dfs-with-details-explanation",
                "content": "```\\n private static final int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if (grid == null || grid.length == 0) return grid;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[r0][c0] = true;\\n        dfs(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int r, int c, int targetColor, int color, boolean[][] visited) {\\n        int count = 0; // the number of neighbors is connected\\n        for (int[] dir : dirs) {\\n            int x = r + dir[0];\\n            int y = c + dir[1];\\n            if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n            if (grid[x][y] == targetColor || visited[x][y]) count++; // If the neighbor is our target, Or if we\\'ve already visited it, which means its connected \\n            if (grid[x][y] == targetColor && !visited[x][y]) { // We only visit the neighbor whose color is our target.\\n                visited[x][y] = true; \\n                dfs(grid, x, y, targetColor, color, visited);\\n            }\\n        }\\n        \\n        if (count != 4) { // if the count < 4, which means its a border, we need to change the color\\n            grid[r][c] = color;\\n        }\\n        return;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n private static final int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if (grid == null || grid.length == 0) return grid;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[r0][c0] = true;\\n        dfs(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int r, int c, int targetColor, int color, boolean[][] visited) {\\n        int count = 0; // the number of neighbors is connected\\n        for (int[] dir : dirs) {\\n            int x = r + dir[0];\\n            int y = c + dir[1];\\n            if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n            if (grid[x][y] == targetColor || visited[x][y]) count++; // If the neighbor is our target, Or if we\\'ve already visited it, which means its connected \\n            if (grid[x][y] == targetColor && !visited[x][y]) { // We only visit the neighbor whose color is our target.\\n                visited[x][y] = true; \\n                dfs(grid, x, y, targetColor, color, visited);\\n            }\\n        }\\n        \\n        if (count != 4) { // if the count < 4, which means its a border, we need to change the color\\n            grid[r][c] = color;\\n        }\\n        return;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991984,
                "title": "dfs-c-clean-and-concise-code-killer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint m,n;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& image, int sr, int sc, int color) \\n    {\\n        m=image.size();\\n        n=image[0].size();\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        int hunt=image[sr][sc];\\n        dfs(sr,sc,image,vis,hunt,color);\\n        return image;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& image,vector<vector<bool>>& vis,int hunt,int color)\\n    {\\n        if(i<0||j<0||i>=m||j>=n||vis[i][j]||image[i][j]!=hunt)\\n        return;\\n        vis[i][j]=true;\\n        if(i==0||j==0||i>=m-1||j>=n-1)\\n        {\\n            image[i][j]=color;\\n        }\\n        if((i+1<=m-1 && image[i+1][j]!=hunt && !vis[i+1][j]) || (i-1>=0 && image[i-1][j]!=hunt && !vis[i-1][j]) || (j+1<=n-1 && image[i][j+1]!=hunt && !vis[i][j+1]) || (j-1>=0 && image[i][j-1]!=hunt && !vis[i][j-1]))\\n        image[i][j] = color;\\n        dfs(i+1,j,image,vis,hunt,color);\\n        dfs(i-1,j,image,vis,hunt,color);\\n        dfs(i,j+1,image,vis,hunt,color);\\n        dfs(i,j-1,image,vis,hunt,color);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint m,n;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& image, int sr, int sc, int color) \\n    {\\n        m=image.size();\\n        n=image[0].size();\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        int hunt=image[sr][sc];\\n        dfs(sr,sc,image,vis,hunt,color);\\n        return image;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& image,vector<vector<bool>>& vis,int hunt,int color)\\n    {\\n        if(i<0||j<0||i>=m||j>=n||vis[i][j]||image[i][j]!=hunt)\\n        return;\\n        vis[i][j]=true;\\n        if(i==0||j==0||i>=m-1||j>=n-1)\\n        {\\n            image[i][j]=color;\\n        }\\n        if((i+1<=m-1 && image[i+1][j]!=hunt && !vis[i+1][j]) || (i-1>=0 && image[i-1][j]!=hunt && !vis[i-1][j]) || (j+1<=n-1 && image[i][j+1]!=hunt && !vis[i][j+1]) || (j-1>=0 && image[i][j-1]!=hunt && !vis[i][j-1]))\\n        image[i][j] = color;\\n        dfs(i+1,j,image,vis,hunt,color);\\n        dfs(i-1,j,image,vis,hunt,color);\\n        dfs(i,j+1,image,vis,hunt,color);\\n        dfs(i,j-1,image,vis,hunt,color);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643291,
                "title": "dfs-intuitive-with-is-valid-pixel-and-is-border-helpers",
                "content": "# Intuition\\nAt first glance, the problem requires us to change the color of the border of a region in an image. Since the region is defined as all pixels with the same color that are 4-directionally connected (meaning they are connected either vertically or horizontally), the natural inclination is to solve this problem using depth-first search (DFS), a well-known algorithm used for traversing or searching tree or graph data structures. We use DFS to visit all pixels in the region. While doing this, we also check if the current pixel is on the border of the region, and if so, we color it with the new color.\\n\\n# Approach\\nThe approach to solve this problem involves three helper functions: `is_valid_pixel`, `is_border`, and `dfs`. `is_valid_pixel` checks if a pixel is inside the image and if it has the original color. `is_border` checks if a pixel is on the border of the image or is adjacent to a pixel that is not part of the region and has not yet been visited. If a pixel satisfies these conditions, it\\'s a border pixel.\\n\\nThe `dfs` function is where we perform the depth-first search. It checks if the current pixel is valid and unvisited. If it is a border pixel, we change its color to the new color. We then visit all four directions from the current pixel.\\n\\nFinally, the condition `original_color != newColor` prevents infinite loops when the new color is the same as the original color.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is O(n), where n is the number of pixels in the image. In the worst-case scenario, every pixel in the image is visited once.\\n  \\n- Space complexity: The space complexity is also O(n), where n is the number of pixels in the image. The space complexity comes from the memory used to store the visited set and the memory used for the stack in the recursive DFS function. In the worst-case scenario, the depth of recursion could go up to n. This worst-case scenario would occur if all pixels have the same color and the starting pixel is at one corner of the image.\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        DIRECTIONS = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n        R = len(image); C = len(image[0])\\n        original_color = image[sr][sc]\\n        visited = set()\\n\\n        # return true if the pixel is in the image\\n        def is_valid_pixel(row, col):\\n            return 0 <= row < R and 0 <= col < C and image[row][col] == original_color\\n\\n        # return True if the pixel is at the border\\n        def is_border(row, col):\\n            return row == 0 or row == R-1 or col == 0 or col == C-1 or any(\\n                0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited\\n                for dr, dc in DIRECTIONS\\n            )\\n\\n        def dfs(row, col):\\n            if not is_valid_pixel(row, col) or (row, col) in visited:\\n                return\\n            if is_border(row, col):\\n                image[row][col] = newColor\\n            visited.add((row, col))\\n            for dr, dc in DIRECTIONS:\\n                dfs(row + dr, col + dc)\\n\\n        if original_color != newColor:\\n            dfs(sr, sc)\\n        return image\\n\\n```\\n\\n# is_border\\n`is_border` determines whether a given pixel, specified by its row and column indices, is on the border of a region with the same color in the image.\\n\\nHere is a detailed explanation of the logic:\\n\\n- `row == 0 or row == R-1 or col == 0 or col == C-1`: This condition checks if the pixel is on the edge of the image. If it is, it\\'s part of the border by definition.\\n\\n- `any(0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited for dr, dc in DIRECTIONS)`: This condition uses the `any` function, which returns `True` if any element in the iterable it\\'s given is `True`. It\\'s iterating over the four possible directions from the current pixel (up, down, left, right) represented by `DIRECTIONS`.\\n\\n  - `0 <= row + dr < R and 0 <= col + dc < C`: These conditions check that the pixel in the direction `(dr, dc)` is still within the image bounds.\\n\\n  - `image[row + dr][col + dc] != original_color`: This condition checks that the color of the pixel in the direction `(dr, dc)` is different from the original color. This would mean that the current pixel is next to a pixel of a different color, and is therefore on the border of its region.\\n\\n  - `(row+dr, col+dc) not in visited`: This condition checks that the pixel in the direction `(dr, dc)` has not been visited. This is to ensure that we don\\'t count pixels that have already been recolored as being different, as they might have been the same color originally. \\nIf any of these conditions is `True`, the function will return `True`, indicating that the pixel is indeed a border pixel.\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        DIRECTIONS = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n        R = len(image); C = len(image[0])\\n        original_color = image[sr][sc]\\n        visited = set()\\n\\n        # return true if the pixel is in the image\\n        def is_valid_pixel(row, col):\\n            return 0 <= row < R and 0 <= col < C and image[row][col] == original_color\\n\\n        # return True if the pixel is at the border\\n        def is_border(row, col):\\n            return row == 0 or row == R-1 or col == 0 or col == C-1 or any(\\n                0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited\\n                for dr, dc in DIRECTIONS\\n            )\\n\\n        def dfs(row, col):\\n            if not is_valid_pixel(row, col) or (row, col) in visited:\\n                return\\n            if is_border(row, col):\\n                image[row][col] = newColor\\n            visited.add((row, col))\\n            for dr, dc in DIRECTIONS:\\n                dfs(row + dr, col + dc)\\n\\n        if original_color != newColor:\\n            dfs(sr, sc)\\n        return image\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633496,
                "title": "c-bfs-onepass",
                "content": "\\n# Approach\\nmain idea is that if a node does not have similar values on all 4 sides than it is border cell. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int clr=grid[row][col];\\n\\n        vector<vector<int>> dir = {{-1,0},{1,0},{0,1},{0,-1}};\\n        vector<vector<bool>> vi(m,vector<bool>(n,0));\\n        vi[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            int cnt=0;\\n            for(int i=0;i<dir.size();i++){\\n                int nr=r+dir[i][0];\\n                int nc=c+dir[i][1];\\n                if(nr<m && nr>=0 && nc<n && nc>=0){\\n                    if(vi[nr][nc]==1) cnt++;\\n                    else if(grid[nr][nc]==clr){\\n                        cnt++;\\n                        vi[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n            if(cnt!=4) grid[r][c]=color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int clr=grid[row][col];\\n\\n        vector<vector<int>> dir = {{-1,0},{1,0},{0,1},{0,-1}};\\n        vector<vector<bool>> vi(m,vector<bool>(n,0));\\n        vi[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            int cnt=0;\\n            for(int i=0;i<dir.size();i++){\\n                int nr=r+dir[i][0];\\n                int nc=c+dir[i][1];\\n                if(nr<m && nr>=0 && nc<n && nc>=0){\\n                    if(vi[nr][nc]==1) cnt++;\\n                    else if(grid[nr][nc]==clr){\\n                        cnt++;\\n                        vi[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n            if(cnt!=4) grid[r][c]=color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606150,
                "title": "correct-c-solution-with-missing-testcase-so-far",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       \\n    //my solution using visited\\n    //easy to understand\\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color,vector<vector<bool> >& visited){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true; \\n        }\\n        if(visited[r][c]){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            //checking is color is different after checking visited because we ourselves may have had changed the color\\n            return true;\\n        }\\n        visited[r][c] = true;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color,visited);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color,visited);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color,visited);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color,visited);\\n        if(u || f || d || b){\\n            // GETTING TRUE IMPLIES THAT CURRENT VERTEX IS ON BORDER\\n            grid[r][c] = color; // changing to required color\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool> (grid[0].size(),false));\\n        dfsHelper(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n    }\\n    \\n```\\nI HAVE SUBMITTED AN VALID TESTCASE WHERE OTHER SOLUTION LIKE BELOW GIVE TLE BUT GOT ACCEPTED WHEN SUBMITTED: \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/13932\\n\\n```\\n    /* WRONG(TLE) BUT ACCEPTED SOLUTION\\n\\n    This solution(below) got submitted successfully but it should give TLE for these testcases:\\n    1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\n    2) Testcase of 50 x 50 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/9y9si\\n    */\\n    \\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true;\\n        }\\n        if(grid[r][c] == -1 * componentColor){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            return true;\\n        }\\n\\n        grid[r][c] *= -1;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color);\\n        if(!u && !f && !d && !b){\\n            grid[r][c] *= -1;\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int componentColor = grid[row][col];\\n        dfsHelper(grid,row,col,componentColor,color);\\n        for(int i = 0; i< grid.size(); i++){\\n            for(int j = 0; j< grid[0].size(); j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    \\n};\\n```\\n#UPDATED\\n1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\nTHIS TESTCASE HAS BEEN ADDED NOW \\nNOW THE ABOVE WRONG(TLE) ANS WILL NOT BE ACCEPTED\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       \\n    //my solution using visited\\n    //easy to understand\\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color,vector<vector<bool> >& visited){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true; \\n        }\\n        if(visited[r][c]){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            //checking is color is different after checking visited because we ourselves may have had changed the color\\n            return true;\\n        }\\n        visited[r][c] = true;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color,visited);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color,visited);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color,visited);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color,visited);\\n        if(u || f || d || b){\\n            // GETTING TRUE IMPLIES THAT CURRENT VERTEX IS ON BORDER\\n            grid[r][c] = color; // changing to required color\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool> (grid[0].size(),false));\\n        dfsHelper(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n    }\\n    \\n```\n```\\n    /* WRONG(TLE) BUT ACCEPTED SOLUTION\\n\\n    This solution(below) got submitted successfully but it should give TLE for these testcases:\\n    1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\n    2) Testcase of 50 x 50 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/9y9si\\n    */\\n    \\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true;\\n        }\\n        if(grid[r][c] == -1 * componentColor){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            return true;\\n        }\\n\\n        grid[r][c] *= -1;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color);\\n        if(!u && !f && !d && !b){\\n            grid[r][c] *= -1;\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int componentColor = grid[row][col];\\n        dfsHelper(grid,row,col,componentColor,color);\\n        for(int i = 0; i< grid.size(); i++){\\n            for(int j = 0; j< grid[0].size(); j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175011,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "```\\nvar colorBorder = function(grid, row, col, color) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Set();\\n    const isBorder = (row, col, color) => {\\n        const value = grid[row]?.[col];\\n        return value === \\'x\\' || value === color;\\n    };\\n    const coloring = (row, col, color) => {\\n        if (row < 0 || col < 0 || row >= m || col >= n) return;\\n        if (visited.has(`${row}_${col}`)) return;\\n        const value = grid[row][col];\\n        if (value !== color) return;\\n\\n        grid[row][col] = \\'x\\';\\n        coloring(row - 1, col, color);\\n        coloring(row + 1, col, color);\\n        coloring(row, col - 1, color);\\n        coloring(row, col + 1, color);\\n        const checkTop = isBorder(row - 1, col, color);\\n        const checkBottom = isBorder(row + 1, col, color);\\n        const checkLeft = isBorder(row, col - 1, color);\\n        const checkRight = isBorder(row, col + 1, color);\\n        if (checkTop && checkBottom && checkLeft && checkRight) {\\n          grid[row][col] = color;\\n          visited.add(`${row}_${col}`);\\n        }\\n    };\\n\\n    coloring(row, col, grid[row][col]);\\n    return grid.map(col => col.map(value => value === \\'x\\' ? color : value ));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar colorBorder = function(grid, row, col, color) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Set();\\n    const isBorder = (row, col, color) => {\\n        const value = grid[row]?.[col];\\n        return value === \\'x\\' || value === color;\\n    };\\n    const coloring = (row, col, color) => {\\n        if (row < 0 || col < 0 || row >= m || col >= n) return;\\n        if (visited.has(`${row}_${col}`)) return;\\n        const value = grid[row][col];\\n        if (value !== color) return;\\n\\n        grid[row][col] = \\'x\\';\\n        coloring(row - 1, col, color);\\n        coloring(row + 1, col, color);\\n        coloring(row, col - 1, color);\\n        coloring(row, col + 1, color);\\n        const checkTop = isBorder(row - 1, col, color);\\n        const checkBottom = isBorder(row + 1, col, color);\\n        const checkLeft = isBorder(row, col - 1, color);\\n        const checkRight = isBorder(row, col + 1, color);\\n        if (checkTop && checkBottom && checkLeft && checkRight) {\\n          grid[row][col] = color;\\n          visited.add(`${row}_${col}`);\\n        }\\n    };\\n\\n    coloring(row, col, grid[row][col]);\\n    return grid.map(col => col.map(value => value === \\'x\\' ? color : value ));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112503,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "# Intuition\\nFrog walk Approach\\n\\n# Approach\\ncolorTheComponent (getNeighbors) (coloring the boundary Components as well) with -1 as color\\nfind Components which aren\\'t part of boundary\\nreplace Components which aren\\'t part of boundary with original color\\nreplace all -1 components with original color\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunction getNeighbors(grid, row, column) {\\n\\tconst totalRows = grid.length;\\n\\tconst totalColumns = grid[0].length;\\n\\tconst neighbors = [];\\n\\tif (row > 0) {\\n\\t\\tneighbors.push({ rowIndex: row - 1, columnIndex: column });\\n\\t}\\n\\tif (row < totalRows - 1) {\\n\\t\\tneighbors.push({ rowIndex: row + 1, columnIndex: column });\\n\\t}\\n\\n\\tif (column > 0) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column - 1 });\\n\\t}\\n\\n\\tif (column < totalColumns - 1) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column + 1 });\\n\\t}\\n\\n\\treturn neighbors;\\n}\\n\\nfunction colorTheComponent(grid, row, col, foundColor, color = -1, explored = {}) {\\n\\tconst neighbors = getNeighbors(grid, row, col);\\n\\tfor (const { rowIndex, columnIndex } of neighbors) {\\n\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\tif (!explored[key] && grid[rowIndex][columnIndex] === foundColor) {\\n\\t\\t\\texplored[key] = true;\\n\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\tcolorTheComponent(grid, rowIndex, columnIndex, foundColor, color, explored);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction isBoundary(grid, rowIndex, columnIndex) {\\n\\tconst response =\\n\\t\\tgrid[rowIndex - 1] &&\\n\\t\\tgrid[rowIndex - 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex + 1] &&\\n\\t\\tgrid[rowIndex + 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex] &&\\n\\t\\tgrid[rowIndex][columnIndex - 1] === -1 &&\\n\\t\\tgrid[rowIndex][columnIndex + 1] === -1\\n\\t\\t\\t? true\\n\\t\\t\\t: false;\\n\\treturn response;\\n}\\n\\nvar colorBorder = function(grid, row, col, color) {\\n\\tconst foundColor = grid[row][col];\\n\\tgrid[row][col] = -1;\\n\\tconst notInBoundary = [];\\n\\tcolorTheComponent(grid, row, col, foundColor);\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tif (isBoundary(grid, rowIndex, columnIndex)) {\\n\\t\\t\\t\\t\\tnotInBoundary.push({ rowIndex, columnIndex });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (const { rowIndex, columnIndex } of notInBoundary) {\\n\\t\\tgrid[rowIndex][columnIndex] = foundColor;\\n\\t}\\n\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction getNeighbors(grid, row, column) {\\n\\tconst totalRows = grid.length;\\n\\tconst totalColumns = grid[0].length;\\n\\tconst neighbors = [];\\n\\tif (row > 0) {\\n\\t\\tneighbors.push({ rowIndex: row - 1, columnIndex: column });\\n\\t}\\n\\tif (row < totalRows - 1) {\\n\\t\\tneighbors.push({ rowIndex: row + 1, columnIndex: column });\\n\\t}\\n\\n\\tif (column > 0) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column - 1 });\\n\\t}\\n\\n\\tif (column < totalColumns - 1) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column + 1 });\\n\\t}\\n\\n\\treturn neighbors;\\n}\\n\\nfunction colorTheComponent(grid, row, col, foundColor, color = -1, explored = {}) {\\n\\tconst neighbors = getNeighbors(grid, row, col);\\n\\tfor (const { rowIndex, columnIndex } of neighbors) {\\n\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\tif (!explored[key] && grid[rowIndex][columnIndex] === foundColor) {\\n\\t\\t\\texplored[key] = true;\\n\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\tcolorTheComponent(grid, rowIndex, columnIndex, foundColor, color, explored);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction isBoundary(grid, rowIndex, columnIndex) {\\n\\tconst response =\\n\\t\\tgrid[rowIndex - 1] &&\\n\\t\\tgrid[rowIndex - 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex + 1] &&\\n\\t\\tgrid[rowIndex + 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex] &&\\n\\t\\tgrid[rowIndex][columnIndex - 1] === -1 &&\\n\\t\\tgrid[rowIndex][columnIndex + 1] === -1\\n\\t\\t\\t? true\\n\\t\\t\\t: false;\\n\\treturn response;\\n}\\n\\nvar colorBorder = function(grid, row, col, color) {\\n\\tconst foundColor = grid[row][col];\\n\\tgrid[row][col] = -1;\\n\\tconst notInBoundary = [];\\n\\tcolorTheComponent(grid, row, col, foundColor);\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tif (isBoundary(grid, rowIndex, columnIndex)) {\\n\\t\\t\\t\\t\\tnotInBoundary.push({ rowIndex, columnIndex });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (const { rowIndex, columnIndex } of notInBoundary) {\\n\\t\\tgrid[rowIndex][columnIndex] = foundColor;\\n\\t}\\n\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648186,
                "title": "2ms-java-ac-solution-in-o-1-space-dfs-graph-traversal",
                "content": "\\n\\t\\n\\t\\n\\tclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int ans[][] = grid;\\n        int inCo = grid[row][col];\\n        dfs(grid,row,col,grid[row][col]);\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        return grid;\\n    }\\n    int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void dfs(int[][] grid,int row,int col,int inCo){\\n        \\n        grid[row][col] = -inCo;\\n        int c=0;\\n        for(int i=0;i<4;i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash<0 || coldash<0 || rowdash>=grid.length || coldash>=grid[0].length\\n               || Math.abs(grid[rowdash][coldash]) != inCo)\\n                continue;\\n            c++;\\n            if(grid[rowdash][coldash] != -inCo){\\n                dfs(grid,rowdash,coldash,inCo);\\n            }\\n           \\n        }\\n        if(c==4)\\n            grid[row][col] = inCo;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int ans[][] = grid;\\n        int inCo = grid[row][col];\\n        dfs(grid,row,col,grid[row][col]);\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2635883,
                "title": "c-python-flood-fill-with-condition-short-concise",
                "content": "# C++\\n```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int orgc, int c, vector<vector<int>> &temp) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] != orgc || grid[i][j] == c) return;\\n        grid[i][j] = c;\\n        \\n        dfs(i + 1, j, grid, orgc, c, temp);\\n        dfs(i - 1, j, grid, orgc, c, temp);\\n        dfs(i, j + 1, grid, orgc, c, temp);\\n        dfs(i, j - 1, grid, orgc, c, temp);\\n        \\n        if(i - 1 >= 0 && i + 1 < grid.size() && j - 1 >= 0 && j + 1 < grid[0].size()) {\\n            if(temp[i - 1][j] == orgc && temp[i + 1][j] == orgc && temp[i][j - 1] == orgc && temp[i][j + 1] == orgc) grid[i][j] = orgc;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int c) {\\n        vector<vector<int>> temp = grid;\\n        dfs(i, j, grid, grid[i][j], c, temp);\\n        return grid;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        temp = copy.deepcopy(grid)\\n        \\n        def dfs(i, j, g, orgc, c, temp):\\n            if(i < 0 or i == len(g) or j < 0 or j == len(g[0]) or g[i][j] != orgc or g[i][j] == c): return\\n            g[i][j] = c\\n            \\n            dfs(i + 1, j, g, orgc, c, temp)\\n            dfs(i - 1, j, g, orgc, c, temp)\\n            dfs(i, j + 1, g, orgc, c, temp)\\n            dfs(i, j - 1, g, orgc, c, temp)\\n            \\n            if(i - 1 >= 0 and i + 1 < len(g) and j - 1 >= 0 and j + 1 < len(g[0])):\\n                if(temp[i - 1][j] == orgc and temp[i + 1][j] == orgc and temp[i][j - 1] == orgc and temp[i][j + 1] == orgc):\\n                    g[i][j] = orgc\\n        \\n        dfs(row, col, grid, grid[row][col], color, temp)\\n        return grid\\n             \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int orgc, int c, vector<vector<int>> &temp) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] != orgc || grid[i][j] == c) return;\\n        grid[i][j] = c;\\n        \\n        dfs(i + 1, j, grid, orgc, c, temp);\\n        dfs(i - 1, j, grid, orgc, c, temp);\\n        dfs(i, j + 1, grid, orgc, c, temp);\\n        dfs(i, j - 1, grid, orgc, c, temp);\\n        \\n        if(i - 1 >= 0 && i + 1 < grid.size() && j - 1 >= 0 && j + 1 < grid[0].size()) {\\n            if(temp[i - 1][j] == orgc && temp[i + 1][j] == orgc && temp[i][j - 1] == orgc && temp[i][j + 1] == orgc) grid[i][j] = orgc;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int c) {\\n        vector<vector<int>> temp = grid;\\n        dfs(i, j, grid, grid[i][j], c, temp);\\n        return grid;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        temp = copy.deepcopy(grid)\\n        \\n        def dfs(i, j, g, orgc, c, temp):\\n            if(i < 0 or i == len(g) or j < 0 or j == len(g[0]) or g[i][j] != orgc or g[i][j] == c): return\\n            g[i][j] = c\\n            \\n            dfs(i + 1, j, g, orgc, c, temp)\\n            dfs(i - 1, j, g, orgc, c, temp)\\n            dfs(i, j + 1, g, orgc, c, temp)\\n            dfs(i, j - 1, g, orgc, c, temp)\\n            \\n            if(i - 1 >= 0 and i + 1 < len(g) and j - 1 >= 0 and j + 1 < len(g[0])):\\n                if(temp[i - 1][j] == orgc and temp[i + 1][j] == orgc and temp[i][j - 1] == orgc and temp[i][j + 1] == orgc):\\n                    g[i][j] = orgc\\n        \\n        dfs(row, col, grid, grid[row][col], color, temp)\\n        return grid\\n             \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354488,
                "title": "dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dr[4] = {-1,0,0,1};\\n    int dc[4] = {0,-1,1,0};\\n    void dfs(int r,int c,int n,int m,vector<vector<int>>& grid){\\n  \\n        \\n        int count = 0;\\n        grid[r][c] = -grid[r][c];\\n        \\n        for(int i=0;i<4;i++){\\n            int x = r + dr[i];\\n            int y = c + dc[i];\\n            \\n            if(x<0 || x>=n || y<0 || y>=m)\\n                continue;\\n            \\n            if(grid[x][y] == grid[r][c]){\\n                count += 1;\\n            }\\n            \\n            else if(-grid[x][y] == grid[r][c]){\\n                count += 1;\\n                dfs(x,y,n,m,grid);\\n            }\\n        }\\n        \\n        if(count == 4){\\n            grid[r][c] = -grid[r][c];\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        dfs(row,col,n,m,grid);\\n        // return grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int dr[4] = {-1,0,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2303112,
                "title": "80-tc-and-76-sc-easy-python-solution",
                "content": "```\\ndef colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\treturn(grid)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\treturn(grid)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2163778,
                "title": "dfs-and-bfs",
                "content": "**BFS SOLUTION**\\n\\n\\tclass Solution {\\n\\t\\t\\tstruct Pair{\\n\\t\\t\\t\\tint i;\\n\\t\\t\\t\\tint j;\\n\\t\\t\\t\\tbool border;\\n\\n\\t\\t\\t\\tPair(int i,int j,bool border){\\n\\t\\t\\t\\t\\tthis->i = i;\\n\\t\\t\\t\\t\\tthis->j = j;\\n\\t\\t\\t\\t\\tthis->border = border;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tvector<vector<bool>> visited;\\n\\t\\t\\tint dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\t\\tpublic:\\n\\n\\t\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\t\\t\\t\\t// dfs\\n\\t\\t\\t\\tint originalColor = grid[row][col];\\n\\n\\t\\t\\t\\tvisited = vector<vector<bool>>(grid.size(),vector<bool>(grid[0].size(),0));\\n\\t\\t\\t\\tqueue<Pair> qu;\\n\\t\\t\\t\\tqu.push(Pair(row,col, isBorder(grid,row,col)));\\n\\n\\t\\t\\t\\tvector<Pair> vp;\\n\\t\\t\\t\\twhile(!qu.empty()){\\n\\t\\t\\t\\t\\tauto top = qu.front();\\n\\t\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\t\\tif(visited[top.i][top.j])continue;\\n\\t\\t\\t\\t\\tvisited[top.i][top.j] = true;\\n\\t\\t\\t\\t\\t// some checks\\n\\t\\t\\t\\t\\tvp.push_back(top);\\n\\n\\t\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\t\\tint i = d[0] + top.i;\\n\\t\\t\\t\\t\\t\\tint j = d[1] + top.j;\\n\\t\\t\\t\\t\\t\\tif(i>=0 and j>=0 and i<grid.size() and j<grid[0].size() and visited[i][j]==false and grid[i][j]==originalColor){\\n\\t\\t\\t\\t\\t\\t\\tqu.push(Pair(i,j, isBorder(grid,i,j)));\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto p : vp){\\n\\t\\t\\t\\t\\tif(p.border){\\n\\t\\t\\t\\t\\t\\tgrid[p.i][p.j] = color;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn grid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool isBorder(vector<vector<int>> &grid,int i,int j){\\n\\t\\t\\t\\tif(i==0 || j == 0 || i==grid.size() -1 || j==grid[0].size() - 1){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\tint x = d[0] + i;\\n\\t\\t\\t\\t\\tint y = d[1] + j;\\n\\n\\t\\t\\t\\t\\tif(grid[i][j]!=grid[x][y])return true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\n**DFS SOLUTION:**\\nNot sure about some check conditions 100% but it passed all testcases \\n\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tvector<vector<bool>> visited;\\n\\t\\t\\tint dir[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\\n\\t\\tpublic:\\n\\t\\t\\tvoid dfs(vector<vector<int>> &grid,int row,int col,int r,int c,int color){\\n\\t\\t\\t\\tif(visited[r][c])return;\\n\\t\\t\\t\\tif(grid[row][col] != grid[r][c])return;\\n\\t\\t\\t\\tbool current = false;\\n\\t\\t\\t\\tvisited[r][c] = true;\\n\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\tint x = d[0] + r;\\n\\t\\t\\t\\t\\tint y = d[1] + c;\\n\\n\\t\\t\\t\\t\\tif(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() ||(visited[x][y]==false and grid[x][y]!=grid[row][col])){\\n\\t\\t\\t\\t\\t\\tcurrent = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size() && visited[x][y]==false){\\n\\t\\t\\t\\t\\t\\tdfs(grid,row,col,x,y,color);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(current){\\n\\t\\t\\t\\t\\tgrid[r][c] = color;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\t\\t\\t\\t// dfs\\n\\n\\t\\t\\t\\tvisited = vector<vector<bool>>(grid.size(),vector<bool>(grid[0].size(),0));\\n\\n\\t\\t\\t\\tdfs(grid,row,col,row,col,color);\\n\\n\\t\\t\\t\\treturn grid;\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\t\\tstruct Pair{\\n\\t\\t\\t\\tint i;\\n\\t\\t\\t\\tint j;\\n\\t\\t\\t\\tbool border;\\n\\n\\t\\t\\t\\tPair(int i,int j,bool border){\\n\\t\\t\\t\\t\\tthis->i = i;\\n\\t\\t\\t\\t\\tthis->j = j;\\n\\t\\t\\t\\t\\tthis->border = border;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2133781,
                "title": "python-standard-dfs-71-faster",
                "content": "```\\nfrom queue import Queue\\nclass Solution:\\n    \"\"\"\\n    approach: the problem can be tackled using breadth first approach\\n    start the bfs from (row, col) and maintain visited and border_set\\n    \"\"\"\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        start_color = grid[row][col]\\n        visited = set()\\n        \\n        def is_valid(index):\\n            i, j = index\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def is_boundary(index):\\n            i, j = index\\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\\n                return True\\n            return False\\n        \\n        def get_neighbors(index):\\n            i, j = index\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(index):\\n            visited.add(index)\\n            \\n            flag = 0\\n            if is_boundary(index):\\n                flag = 1\\n                \\n            for pos in get_neighbors(index):\\n                if is_valid(pos) and pos not in visited: \\n                    if grid[pos[0]][pos[1]] == start_color:\\n                        dfs(pos)\\n                    else:\\n                        # it\\'s a border point, index needs to be colored with color\\n                        flag = 1\\n            if flag:\\n                grid[index[0]][index[1]] = color\\n                \\n        dfs((row, col))\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\nclass Solution:\\n    \"\"\"\\n    approach: the problem can be tackled using breadth first approach\\n    start the bfs from (row, col) and maintain visited and border_set\\n    \"\"\"\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        start_color = grid[row][col]\\n        visited = set()\\n        \\n        def is_valid(index):\\n            i, j = index\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def is_boundary(index):\\n            i, j = index\\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\\n                return True\\n            return False\\n        \\n        def get_neighbors(index):\\n            i, j = index\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(index):\\n            visited.add(index)\\n            \\n            flag = 0\\n            if is_boundary(index):\\n                flag = 1\\n                \\n            for pos in get_neighbors(index):\\n                if is_valid(pos) and pos not in visited: \\n                    if grid[pos[0]][pos[1]] == start_color:\\n                        dfs(pos)\\n                    else:\\n                        # it\\'s a border point, index needs to be colored with color\\n                        flag = 1\\n            if flag:\\n                grid[index[0]][index[1]] = color\\n                \\n        dfs((row, col))\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918709,
                "title": "c-easy-solution-dfs-explained",
                "content": "What question has asked?\\nin the connectred component mark all the values to the colored one which are on the border of the sqaure or who has adjacently atleast one square which is not the part of connected component.\\n```\\n// m,n,co are number of row, column and color to assigned\\nint m,n,co;\\n    void dfs(vector<vector<int>>& grid , vector<vector<bool>>& vis , int i , int j ,int val)\\n    {\\n\\t// base condition to eliminate the coordinate\\n        if(i<0 || j<0 || i>=m || j>=n || vis[i][j] || grid[i][j]!=val)\\n            return;\\n        vis[i][j] = true;\\n\\t\\t// check if present on the border of the square or not\\n        if(i==0 || j==0 || i>=m-1 || j>=n-1)\\n            grid[i][j]=co;\\n\\t\\t\\t// conditon to check if their is present some differnt color square on the border of the connected component\\n        if((i+1<=m-1 && grid[i+1][j]!=val && !vis[i+1][j]) || (i-1>=0 && grid[i-1][j]!=val && !vis[i-1][j]) || (j+1<=n-1 && grid[i][j+1]!=val && !vis[i][j+1]) || (j-1>=0 && grid[i][j-1]!=val && !vis[i][j-1]))\\n            grid[i][j] = co;\\n\\t\\t\\t// do dfs in all 4 directions\\n        dfs(grid,vis,i+1,j,val);\\n        dfs(grid,vis,i,j+1,val);\\n        dfs(grid,vis,i,j-1,val);\\n        dfs(grid,vis,i-1,j,val);\\n        return;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        co = color;\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        dfs(grid,vis,row,col,grid[row][col]);\\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n// m,n,co are number of row, column and color to assigned\\nint m,n,co;\\n    void dfs(vector<vector<int>>& grid , vector<vector<bool>>& vis , int i , int j ,int val)\\n    {\\n\\t// base condition to eliminate the coordinate\\n        if(i<0 || j<0 || i>=m || j>=n || vis[i][j] || grid[i][j]!=val)\\n            return;\\n        vis[i][j] = true;\\n\\t\\t// check if present on the border of the square or not\\n        if(i==0 || j==0 || i>=m-1 || j>=n-1)\\n            grid[i][j]=co;\\n\\t\\t\\t// conditon to check if their is present some differnt color square on the border of the connected component\\n        if((i+1<=m-1 && grid[i+1][j]!=val && !vis[i+1][j]) || (i-1>=0 && grid[i-1][j]!=val && !vis[i-1][j]) || (j+1<=n-1 && grid[i][j+1]!=val && !vis[i][j+1]) || (j-1>=0 && grid[i][j-1]!=val && !vis[i][j-1]))\\n            grid[i][j] = co;\\n\\t\\t\\t// do dfs in all 4 directions\\n        dfs(grid,vis,i+1,j,val);\\n        dfs(grid,vis,i,j+1,val);\\n        dfs(grid,vis,i,j-1,val);\\n        dfs(grid,vis,i-1,j,val);\\n        return;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        co = color;\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        dfs(grid,vis,row,col,grid[row][col]);\\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905263,
                "title": "python-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \\n        def dfs(i,j,parent):\\n            if (i,j) in visited:\\n                return\\n            \\n            if i<0 or j<0 or i>=m or j>=n or grid[i][j]!=ic  :\\n                grid[parent[0]][parent[1]]=color\\n                return\\n            \\n            visited.add((i,j))\\n            \\n            dfs(i-1,j,(i,j))\\n            dfs(i+1,j,(i,j))\\n            dfs(i,j-1,(i,j))\\n            dfs(i,j+1,(i,j))\\n            \\n        ic=grid[row][col]\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=set()\\n        dfs(row,col,(-1,-1))\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \\n        def dfs(i,j,parent):\\n            if (i,j) in visited:\\n                return\\n            \\n            if i<0 or j<0 or i>=m or j>=n or grid[i][j]!=ic  :\\n                grid[parent[0]][parent[1]]=color\\n                return\\n            \\n            visited.add((i,j))\\n            \\n            dfs(i-1,j,(i,j))\\n            dfs(i+1,j,(i,j))\\n            dfs(i,j-1,(i,j))\\n            dfs(i,j+1,(i,j))\\n            \\n        ic=grid[row][col]\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=set()\\n        dfs(row,col,(-1,-1))\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850221,
                "title": "java-dfs-recursion-2-passes",
                "content": "Pretty simple solution using DFS recursion. The idea was to mark the component using negatives and then flip them back in a second pass.\\n\\nIf I didn\\'t want to mess with the initial grid I would create a second result grid. Then do a single pass writing to the result grid and use non-zero values in said grid to track visited cells. As the final step I\\'d loop through the origional grid to copy over everything missing in the result grid. \\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        markComponent(grid,row,col,grid[row][col],color);\\n        fixComponent(grid,row,col);\\n        return grid;\\n    }\\n    \\n    int markComponent(int[][] g, int r, int c, int t, int color) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || (g[r][c] != t && g[r][c] > 0)) return 0;\\n        if (g[r][c] > 0) {\\n            g[r][c] = -t;\\n            if (markComponent(g,r-1,c,t,color) +\\n               markComponent(g,r+1,c,t,color) +\\n               markComponent(g,r,c-1,t,color) +\\n               markComponent(g,r,c+1,t,color) < 4)\\n                g[r][c] = -color;\\n        }\\n        return 1;\\n    }\\n    \\n    void fixComponent(int[][] g, int r, int c) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || g[r][c] > 0) return;\\n        g[r][c] = -g[r][c];\\n        fixComponent(g,r-1,c);\\n        fixComponent(g,r+1,c);\\n        fixComponent(g,r,c-1);\\n        fixComponent(g,r,c+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        markComponent(grid,row,col,grid[row][col],color);\\n        fixComponent(grid,row,col);\\n        return grid;\\n    }\\n    \\n    int markComponent(int[][] g, int r, int c, int t, int color) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || (g[r][c] != t && g[r][c] > 0)) return 0;\\n        if (g[r][c] > 0) {\\n            g[r][c] = -t;\\n            if (markComponent(g,r-1,c,t,color) +\\n               markComponent(g,r+1,c,t,color) +\\n               markComponent(g,r,c-1,t,color) +\\n               markComponent(g,r,c+1,t,color) < 4)\\n                g[r][c] = -color;\\n        }\\n        return 1;\\n    }\\n    \\n    void fixComponent(int[][] g, int r, int c) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || g[r][c] > 0) return;\\n        g[r][c] = -g[r][c];\\n        fixComponent(g,r-1,c);\\n        fixComponent(g,r+1,c);\\n        fixComponent(g,r,c-1);\\n        fixComponent(g,r,c+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615762,
                "title": "c-bfs",
                "content": "```\\nint direction[][4] = {{1,-1,0,0}, {0,0,1,-1}};\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int colour = grid[row][col];\\n        if (colour == color) {\\n            return grid;\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n\\n       \\n        while (!q.empty()) {\\n            int row = q.front().first, col = q.front().second;\\n            int cnt = 0;\\n            for (int d = 0; d < 4; ++d) {\\n                int r = row + direction[0][d], c = col + direction[1][d];\\n                \\n                if (0 <= r && r < grid.size() && \\n                    0 <= c && c < grid[r].size()) {\\n                    cnt += grid[r][c] == colour || grid[r][c] < 0;\\n                    if (grid[r][c] == colour) {\\n                        q.push({r, c});\\n                    }\\n                }\\n            }\\n            if (cnt < 4) {\\n                grid[row][col] = -color;\\n            } else {\\n                grid[row][col] *= -1;\\n            }\\n            q.pop();\\n        }\\n\\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[i].size(); ++j) {\\n                grid[i][j] = abs(grid[i][j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint direction[][4] = {{1,-1,0,0}, {0,0,1,-1}};\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int colour = grid[row][col];\\n        if (colour == color) {\\n            return grid;\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n\\n       \\n        while (!q.empty()) {\\n            int row = q.front().first, col = q.front().second;\\n            int cnt = 0;\\n            for (int d = 0; d < 4; ++d) {\\n                int r = row + direction[0][d], c = col + direction[1][d];\\n                \\n                if (0 <= r && r < grid.size() && \\n                    0 <= c && c < grid[r].size()) {\\n                    cnt += grid[r][c] == colour || grid[r][c] < 0;\\n                    if (grid[r][c] == colour) {\\n                        q.push({r, c});\\n                    }\\n                }\\n            }\\n            if (cnt < 4) {\\n                grid[row][col] = -color;\\n            } else {\\n                grid[row][col] *= -1;\\n            }\\n            q.pop();\\n        }\\n\\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[i].size(); ++j) {\\n                grid[i][j] = abs(grid[i][j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613627,
                "title": "simple-java-dfs",
                "content": "```\\nclass Solution {\\n   public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if (grid == null || grid.length == 0) {\\n            return grid;\\n        }\\n        int val = grid[row][col];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid, row, col, val, visited);\\n        fillGrid(grid, color, visited);\\n        return grid;\\n    }\\n\\n    public void dfs(int[][] grid, int row, int col, int val, boolean[][] visited) {\\n\\n        if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0 || grid[row][col] != val || visited[row][col]) {\\n            return;\\n        }\\n\\n        //LURD\\n        if (grid[row][col] == val) {\\n            visited[row][col] = true;\\n            dfs(grid, row, col - 1, val, visited);\\n            dfs(grid, row + 1, col, val, visited);\\n            dfs(grid, row, col + 1, val, visited);\\n            dfs(grid, row - 1, col, val, visited);\\n        }\\n    }\\n\\n    public void fillGrid(int[][] grid, int color, boolean[][] visited) {\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n\\n                if (visited[i][j]) {\\n\\n                    //color boundary elements\\n                    if (i + 1 >= grid.length || j + 1 >= grid[0].length || i - 1 < 0 || j - 1 < 0) {\\n                        grid[i][j] = color;\\n                    }\\n                    //middle element\\n                    else if ((visited[i + 1][j] && visited[i - 1][j] && visited[i][j - 1] && visited[i][j + 1])) {\\n                        continue;\\n                    }\\n                    else{\\n                        grid[i][j] = color;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n   public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if (grid == null || grid.length == 0) {\\n            return grid;\\n        }\\n        int val = grid[row][col];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid, row, col, val, visited);\\n        fillGrid(grid, color, visited);\\n        return grid;\\n    }\\n\\n    public void dfs(int[][] grid, int row, int col, int val, boolean[][] visited) {\\n\\n        if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0 || grid[row][col] != val || visited[row][col]) {\\n            return;\\n        }\\n\\n        //LURD\\n        if (grid[row][col] == val) {\\n            visited[row][col] = true;\\n            dfs(grid, row, col - 1, val, visited);\\n            dfs(grid, row + 1, col, val, visited);\\n            dfs(grid, row, col + 1, val, visited);\\n            dfs(grid, row - 1, col, val, visited);\\n        }\\n    }\\n\\n    public void fillGrid(int[][] grid, int color, boolean[][] visited) {\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n\\n                if (visited[i][j]) {\\n\\n                    //color boundary elements\\n                    if (i + 1 >= grid.length || j + 1 >= grid[0].length || i - 1 < 0 || j - 1 < 0) {\\n                        grid[i][j] = color;\\n                    }\\n                    //middle element\\n                    else if ((visited[i + 1][j] && visited[i - 1][j] && visited[i][j - 1] && visited[i][j + 1])) {\\n                        continue;\\n                    }\\n                    else{\\n                        grid[i][j] = color;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602546,
                "title": "java-easy-and-clean-dfs-solution-1ms-runtime",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        find(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    public void find(int[][] grid, int r, int c, int toChange){\\n        grid[r][c] = -toChange;\\n        int count = 0;       \\n        for(int i = 0; i < 4; i++){\\n            int nr = r + dir[i][0];\\n            int nc = c + dir[i][1];         \\n            if(nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || Math.abs(grid[nr][nc]) != toChange)\\n                continue;\\n            count++;\\n            if(grid[nr][nc] == toChange)\\n                find(grid, nr, nc, toChange);\\n        }        \\n        if(count == 4)\\n            grid[r][c] = toChange;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        find(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    public void find(int[][] grid, int r, int c, int toChange){\\n        grid[r][c] = -toChange;\\n        int count = 0;       \\n        for(int i = 0; i < 4; i++){\\n            int nr = r + dir[i][0];\\n            int nc = c + dir[i][1];         \\n            if(nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || Math.abs(grid[nr][nc]) != toChange)\\n                continue;\\n            count++;\\n            if(grid[nr][nc] == toChange)\\n                find(grid, nr, nc, toChange);\\n        }        \\n        if(count == 4)\\n            grid[r][c] = toChange;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563141,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&grid,int row,int col,int &s,vector<pair<int,int>>&indexes,vector<vector<bool>>&visited){\\n        if(row<0 or col<0 or row>=grid.size() or col>=grid[0].size() or grid[row][col]!=s )return false;\\n        if(visited[row][col])return true;\\n        visited[row][col]=true;\\n        bool a=dfs(grid,row+1,col,s,indexes,visited);\\n        bool b=dfs(grid,row,col+1,s,indexes,visited);\\n        bool c=dfs(grid,row-1,col,s,indexes,visited);\\n        bool d=dfs(grid,row,col-1,s,indexes,visited);\\n        if(!(a and b and c and d))v.push_back(make_pair(row,col));\\n        return true;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int s=grid[row][col];\\n        vector<pair<int,int>>indexes;    // storing border indexes\\n        vector<vector<bool>>visited(grid.size(),vector<bool>(grid[0].size(),0)); // checking for visited nodes\\n        if(s!=color)dfs(grid,row,col,s,indexes,visited);\\n        for(int i=0;i<v.size();i++){\\n            grid[v[i].first][v[i].second]=color;\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&grid,int row,int col,int &s,vector<pair<int,int>>&indexes,vector<vector<bool>>&visited){\\n        if(row<0 or col<0 or row>=grid.size() or col>=grid[0].size() or grid[row][col]!=s )return false;\\n        if(visited[row][col])return true;\\n        visited[row][col]=true;\\n        bool a=dfs(grid,row+1,col,s,indexes,visited);\\n        bool b=dfs(grid,row,col+1,s,indexes,visited);\\n        bool c=dfs(grid,row-1,col,s,indexes,visited);\\n        bool d=dfs(grid,row,col-1,s,indexes,visited);\\n        if(!(a and b and c and d))v.push_back(make_pair(row,col));\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1501918,
                "title": "c-bfs-solution",
                "content": "\\n\\'\\'\\'\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<vector<int>> res = grid;\\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        set<pair<int, int>> visited;\\n        queue<pair<int, int>> q;\\n        q.push({r0, c0});\\n        visited.insert({r0, c0});\\n        int val = grid[r0][c0];\\n        \\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop();\\n            int notConnected = 0;\\n            for (auto dir : dirs) {\\n                int x = cur.first + dir.first;\\n                int y = cur.second + dir.second;\\n                // check the new point is valid\\n                if (x>=0 && x<grid.size() && y>=0 && y<grid[0].size() && visited.count({x,y})==0) {\\n                    if (grid[x][y] == val) {\\n                        q.push({x, y});\\n                        visited.insert({x, y});\\n                    } else {\\n                        ++notConnected;\\n                    }\\n                } else if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size()) {\\n                    ++notConnected;\\n                }\\n            }\\n            // check if this point is a border or not, if yes, color it !\\n            if (notConnected > 0) res[cur.first][cur.second] = color;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<vector<int>> res = grid;\\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        set<pair<int, int>> visited;\\n        queue<pair<int, int>> q;\\n        q.push({r0, c0});\\n        visited.insert({r0, c0});\\n        int val = grid[r0][c0];\\n        \\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop();\\n            int notConnected = 0;\\n            for (auto dir : dirs) {\\n                int x = cur.first + dir.first;\\n                int y = cur.second + dir.second;\\n                // check the new point is valid\\n                if (x>=0 && x<grid.size() && y>=0 && y<grid[0].size() && visited.count({x,y})==0) {\\n                    if (grid[x][y] == val) {\\n                        q.push({x, y});\\n                        visited.insert({x, y});\\n                    } else {\\n                        ++notConnected;\\n                    }\\n                } else if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size()) {\\n                    ++notConnected;\\n                }\\n            }\\n            // check if this point is a border or not, if yes, color it !\\n            if (notConnected > 0) res[cur.first][cur.second] = color;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1468590,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows,cols=len(grid),len(grid[0])\\n        g=[x.copy() for x in grid]#Create a copy of grid\\n        def dfs(i,j,n,visit):\\n            cnt=0\\n            for nei in [(i-1,j),(i,j+1),(i+1,j),(i,j-1)]:#Iterate neighbours\\n                nx,ny=nei\\n                if 0<=nx<rows and 0<=ny<cols and grid[nx][ny]==n:\\n                    cnt+=1\\n                    if nei not in visit:\\n                        visit.append(nei)\\n                        dfs(nx,ny,n,visit)\\n            if cnt!=4:#If a neighbour is not at border cnt will be 4\\n                g[i][j]=color\\n        dfs(row,col,grid[row][col],[(row,col)])\\n        return g\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows,cols=len(grid),len(grid[0])\\n        g=[x.copy() for x in grid]#Create a copy of grid\\n        def dfs(i,j,n,visit):\\n            cnt=0\\n            for nei in [(i-1,j),(i,j+1),(i+1,j),(i,j-1)]:#Iterate neighbours\\n                nx,ny=nei\\n                if 0<=nx<rows and 0<=ny<cols and grid[nx][ny]==n:\\n                    cnt+=1\\n                    if nei not in visit:\\n                        visit.append(nei)\\n                        dfs(nx,ny,n,visit)\\n            if cnt!=4:#If a neighbour is not at border cnt will be 4\\n                g[i][j]=color\\n        dfs(row,col,grid[row][col],[(row,col)])\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375273,
                "title": "c-dfs-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&v,int i,int j,int c,int color,vector<vector<bool>>&vis)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() )\\n            return;\\n        if(v[i][j]!=color || vis[i][j])\\n            return;\\n        vis[i][j]=true;\\n        if(i==0 || j==0 || i==v.size()-1 || j==v[0].size()-1)\\n        {v[i][j]=c;}\\n        if(( i+1<v.size()&&v[i+1][j]!=color && !vis[i+1][j] ) || ( i-1>=0 &&v[i-1][j]!=color && !vis[i-1][j] ) || ( j+1<v[0].size() &&v[i][j+1]!=color && !vis[i][j+1]) || ( j-1>=0 &&v[i][j-1]!=color && !vis[i][j-1]))\\n        {v[i][j]=c;}\\n        \\n        dfs(v,i+1,j,c,color,vis);\\n         dfs(v,i-1,j,c,color,vis);\\n         dfs(v,i,j-1,c,color,vis);\\n         dfs(v,i,j+1,c,color,vis);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>>v(n,vector<bool>(m,false));\\n       \\n        dfs(grid,r0,c0,color,grid[r0][c0],v);\\n      \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&v,int i,int j,int c,int color,vector<vector<bool>>&vis)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() )\\n            return;\\n        if(v[i][j]!=color || vis[i][j])\\n            return;\\n        vis[i][j]=true;\\n        if(i==0 || j==0 || i==v.size()-1 || j==v[0].size()-1)\\n        {v[i][j]=c;}\\n        if(( i+1<v.size()&&v[i+1][j]!=color && !vis[i+1][j] ) || ( i-1>=0 &&v[i-1][j]!=color && !vis[i-1][j] ) || ( j+1<v[0].size() &&v[i][j+1]!=color && !vis[i][j+1]) || ( j-1>=0 &&v[i][j-1]!=color && !vis[i][j-1]))\\n        {v[i][j]=c;}\\n        \\n        dfs(v,i+1,j,c,color,vis);\\n         dfs(v,i-1,j,c,color,vis);\\n         dfs(v,i,j-1,c,color,vis);\\n         dfs(v,i,j+1,c,color,vis);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>>v(n,vector<bool>(m,false));\\n       \\n        dfs(grid,r0,c0,color,grid[r0][c0],v);\\n      \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313469,
                "title": "java-dfs-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    int[][] dir = {{1,0} ,{-1 , 0} , {0,1} , {0,-1}};\\n   public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int oldColor = grid[r0][c0];\\n\\n        if (oldColor == color)\\n            return grid;\\n\\n        boolean[][] vis = new boolean[n][m];\\n\\n        paint(grid, r0, c0, vis, color, oldColor);\\n\\n        return grid;\\n    }\\n    public void paint(int[][] grid, int r, int c, boolean[][] vis, int color, int oldColor) {\\n\\n        int count = 0;\\n\\n        grid[r][c] = color;\\n        vis[r][c] = true;\\n\\n        for (int d = 0; d < 4; d++) {\\n            int x = r + dir[d][0];\\n            int y = c + dir[d][1];\\n\\n            if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length) {\\n                if (grid[x][y] == oldColor) {\\n                    count++;\\n                    paint(grid, x, y, vis, color, oldColor);\\n                } else if (grid[x][y] == color) {\\n                    if (vis[x][y])\\n                        count++;\\n                }\\n            }\\n        }\\n        if (count == 4)\\n            grid[r][c] = oldColor;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{1,0} ,{-1 , 0} , {0,1} , {0,-1}};\\n   public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int oldColor = grid[r0][c0];\\n\\n        if (oldColor == color)\\n            return grid;\\n\\n        boolean[][] vis = new boolean[n][m];\\n\\n        paint(grid, r0, c0, vis, color, oldColor);\\n\\n        return grid;\\n    }\\n    public void paint(int[][] grid, int r, int c, boolean[][] vis, int color, int oldColor) {\\n\\n        int count = 0;\\n\\n        grid[r][c] = color;\\n        vis[r][c] = true;\\n\\n        for (int d = 0; d < 4; d++) {\\n            int x = r + dir[d][0];\\n            int y = c + dir[d][1];\\n\\n            if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length) {\\n                if (grid[x][y] == oldColor) {\\n                    count++;\\n                    paint(grid, x, y, vis, color, oldColor);\\n                } else if (grid[x][y] == color) {\\n                    if (vis[x][y])\\n                        count++;\\n                }\\n            }\\n        }\\n        if (count == 4)\\n            grid[r][c] = oldColor;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305444,
                "title": "simple-dfs-java-100-faster",
                "content": "```\\nclass Solution {\\n     private int dfs(int i,int j,int[][] g,int ans,int val,int[][] v){\\n//check if it is out of boundary \\n         if(i<0||j<0||i>=g.length||j>=g[0].length){return -1;}\\n// if it is already visited(it means that it was part of same component)         \\n         if(v[i][j]==1){\\n            return 0;\\n        }\\n// if the value is not same as that of current component          \\n        if(g[i][j]!=val)return -1;\\n       \\n         v[i][j]=1;\\n        \\n        int v1=dfs(i+1,j,g,ans,val,v);\\n         int v2=dfs(i-1,j,g,ans,val,v);\\n        int v3=dfs(i,j+1,g,ans,val,v);\\n        int v4=dfs(i,j-1,g,ans,val,v);\\n        \\n         if(v1==0&&v2==0&&v3==0&&v4==0)return 0;\\n        \\n         \\n         \\n         g[i][j]=ans;\\n         return 0;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int[][] v=new int[grid.length][grid[0].length];\\n        dfs(r0,c0,grid,color,grid[r0][c0],v);\\n        return grid;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     private int dfs(int i,int j,int[][] g,int ans,int val,int[][] v){\\n//check if it is out of boundary \\n         if(i<0||j<0||i>=g.length||j>=g[0].length){return -1;}",
                "codeTag": "Java"
            },
            {
                "id": 1256359,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n     int defaults = 0; \\n    int dir[][] = {{1, 0} , {-1 , 0} , {0 , 1} , { 0 , -1}}; \\n\\n    public void dfs(int[][] grid , int r ,int c , int color , boolean[][] visited)\\n    {\\n        int count = 0; \\n        visited[r][c] = true; \\n        grid[r][c] = color; \\n        for(int d = 0 ; d < 4 ; d++)\\n        {\\n            int x = r + dir[d][0]; //r =  1 + 1 = 2\\n            int y = c + dir[d][1]; //c =  1 + 0 = 1 \\n            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length) //valid posiiton \\n            {\\n                if(visited[x][y] == true)\\n                   count++;     \\n                else\\n                {\\n                    if(grid[x][y] == defaults) //not visited and \\n                    {\\n                        count++;  \\n                        dfs(grid , x , y , color , visited); \\n                    }\\n                }\\n            }\\n            if(count == 4)\\n                grid[r][c] = defaults;  \\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;  \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        defaults = grid[r0][c0]; \\n        dfs(grid , r0 , c0, color , visited); \\n        return grid; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n     int defaults = 0; \\n    int dir[][] = {{1, 0} , {-1 , 0} , {0 , 1} , { 0 , -1}}; \\n\\n    public void dfs(int[][] grid , int r ,int c , int color , boolean[][] visited)\\n    {\\n        int count = 0; \\n        visited[r][c] = true; \\n        grid[r][c] = color; \\n        for(int d = 0 ; d < 4 ; d++)\\n        {\\n            int x = r + dir[d][0]; //r =  1 + 1 = 2\\n            int y = c + dir[d][1]; //c =  1 + 0 = 1 \\n            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length) //valid posiiton \\n            {\\n                if(visited[x][y] == true)\\n                   count++;     \\n                else\\n                {\\n                    if(grid[x][y] == defaults) //not visited and \\n                    {\\n                        count++;  \\n                        dfs(grid , x , y , color , visited); \\n                    }\\n                }\\n            }\\n            if(count == 4)\\n                grid[r][c] = defaults;  \\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;  \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        defaults = grid[r0][c0]; \\n        dfs(grid , r0 , c0, color , visited); \\n        return grid; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238412,
                "title": "bfs-using-unordered-set-for-visited-coordinates",
                "content": "\\n        int dir[4][2] = { {-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        if(grid.size()==0 || grid[0].size()==0) return grid;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       \\n        int cl = grid[r0][c0];\\n       \\n        queue<int>que;\\n        que.push(r0*m+c0);\\n        unordered_set<int>vis;\\n        vis.insert(r0*m+c0);\\n          \\n        while(que.size()!=0){\\n            \\n            int t = que.front();\\n            que.pop();\\n            \\n            int r = t/m;\\n            int c = t%m;\\n                \\n           if (r == 0 || r == n - 1 || c == 0 || c == m - 1) { grid[r][c] = color; }\\n          \\n             \\n            for(int d=0;d<4;d++){\\n                int nr= r + dir[d][0];\\n                int nc= c + dir[d][1];\\n                if(nr>=0 && nr<n && nc>=0 && nc < m && !vis.count(nr*m+nc)){\\n                        if(grid[nr][nc]==cl){\\n                            vis.insert(nr*m+nc);\\n                            que.push(nr*m+nc);\\n                        }else{\\n                                grid[r][c]=color;\\n                             }\\n                        }\\n            \\n                    }\\n                \\n            }\\n        return grid;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "\\n        int dir[4][2] = { {-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        if(grid.size()==0 || grid[0].size()==0) return grid;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       \\n        int cl = grid[r0][c0];\\n       \\n        queue<int>que;\\n        que.push(r0*m+c0);\\n        unordered_set<int>vis;\\n        vis.insert(r0*m+c0);\\n          \\n        while(que.size()!=0){\\n            \\n            int t = que.front();\\n            que.pop();\\n            \\n            int r = t/m;\\n            int c = t%m;\\n                \\n           if (r == 0 || r == n - 1 || c == 0 || c == m - 1) { grid[r][c] = color; }\\n          \\n             \\n            for(int d=0;d<4;d++){\\n                int nr= r + dir[d][0];\\n                int nc= c + dir[d][1];\\n                if(nr>=0 && nr<n && nc>=0 && nc < m && !vis.count(nr*m+nc)){\\n                        if(grid[nr][nc]==cl){\\n                            vis.insert(nr*m+nc);\\n                            que.push(nr*m+nc);\\n                        }else{\\n                                grid[r][c]=color;\\n                             }\\n                        }\\n            \\n                    }\\n                \\n            }\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1150961,
                "title": "java-0ms-runtime-100-faster",
                "content": "```\\nclass Solution {\\n    int[][] dir = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    boolean[][] visited;\\n    \\n    private void dfs(int[][] grid, int r0, int c0, int origColor, int newColor, int n, int m) {       \\n\\n\\t\\tvisited[r0][c0] = true;\\n        for(int[] d: dir) {\\n            int x = r0 + d[0];\\n            int y = c0 + d[1];\\n            \\n\\t\\t\\t// if next cell is either boundary OR of diff color but not previously visited\\n            if(x>=n || x<0 || y>=m || y<0 || (!visited[x][y] && grid[x][y]!=origColor)) {\\n                grid[r0][c0] = newColor;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// continue if previously visited\\n            if(visited[x][y])\\n                continue;\\n            \\n            dfs(grid, x, y, origColor, newColor, n, m);\\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid[r0][c0] == color)\\n            return grid;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        visited = new boolean[n][m];\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], color, n, m);\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    boolean[][] visited;\\n    \\n    private void dfs(int[][] grid, int r0, int c0, int origColor, int newColor, int n, int m) {       \\n\\n\\t\\tvisited[r0][c0] = true;\\n        for(int[] d: dir) {\\n            int x = r0 + d[0];\\n            int y = c0 + d[1];\\n            \\n\\t\\t\\t// if next cell is either boundary OR of diff color but not previously visited\\n            if(x>=n || x<0 || y>=m || y<0 || (!visited[x][y] && grid[x][y]!=origColor)) {\\n                grid[r0][c0] = newColor;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// continue if previously visited\\n            if(visited[x][y])\\n                continue;\\n            \\n            dfs(grid, x, y, origColor, newColor, n, m);\\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid[r0][c0] == color)\\n            return grid;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        visited = new boolean[n][m];\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], color, n, m);\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791470,
                "title": "c-solution-using-dfs-faster-than-99-39-with-explanation",
                "content": "The approach is simple DFS that finds the **connected** component from *r0, c0*. In addition, we need to color the boundary of the connected component with the given *color*.\\n\\nA **boundary** of a connected component is defined as the boxes which are **surrounded 4-directonally by atleast one box that has a different color** other than that of connected component. Consider an example below to understand the boundary, *r0* = 1, *c0* = 1, *color* = 3.\\n\\n![image](https://assets.leetcode.com/users/images/eb05a688-bbbd-41e9-90c6-d4eb4c5bf3f3_1597411149.5754387.png)\\n\\n**Marking Boundary in DFS**\\nUse a variable to keep track of count of same boxes present in 4-directions. Let it be *same*. It is incremented in two cases:\\n1. If a box is already visited, then it must be a part of the connected component.\\n2. When making recursive call for unvisited part of the connected component.\\n\\nIf *same* is less than 4 for a box, change its color to the given *color* as it is the part of the boundary. \\n```\\nclass Solution {\\npublic:\\n    int xDir[4] = {1, 0, -1, 0};\\n    int yDir[4] = {0, 1, 0, -1};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, bool **visited, int color) {\\n        visited[r][c] = true;\\n        \\n\\t\\t// variable to keep track of count of same boxes in 4-directions\\n        int same = 0;\\n        \\n\\t\\t// checking 4-directionally\\n        for(int k = 0; k < 4; k++) {\\n            int i = r + xDir[k], j = c + yDir[k];\\n              \\n            if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n                continue;\\n            \\n\\t\\t\\t// if visited, it must a part of the connected component\\n            if(visited[i][j]) {\\n                same++;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// recursive call for unvisited part of the connected component\\n            if(grid[i][j] == grid[r][c]) {\\n                dfs(i, j, grid, visited, color);\\n                same++;\\n            }\\n        }\\n        \\n\\t\\t// if it is the part of the boundary\\n        if(same < 4)\\n            grid[r][c] = color;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        bool **visited;\\n        visited = new bool*[grid.size()];\\n        \\n        for(int i = 0; i < grid.size(); i++) {\\n            visited[i] = new bool[grid[0].size()];\\n            \\n            for(int j = 0; j < grid[0].size(); j++)\\n                visited[i][j] = false;\\n        }\\n        \\n        dfs(r0, c0, grid, visited, color);\\n        \\n        return grid;\\n    }\\n};\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int xDir[4] = {1, 0, -1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 777088,
                "title": "python-dfs",
                "content": "```\\ndef colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(n)] for _ in xrange(m)]\\n        def check(x, y):\\n            return 0 <= x < m and 0 <= y < n\\n        def findBorder(i, j):\\n            visited[i][j] = True\\n            flag = False\\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\\n                if check(x, y) and not visited[x][y] and grid[x][y] == grid[i][j]:\\n                    findBorder(x, y)\\n                if check(x, y) and not visited[x][y] and grid[i][j] != grid[x][y]:\\n                    flag = True\\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1 or flag:\\n                grid[i][j] = color\\n        findBorder(r0, c0)\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\ndef colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(n)] for _ in xrange(m)]\\n        def check(x, y):\\n            return 0 <= x < m and 0 <= y < n\\n        def findBorder(i, j):\\n            visited[i][j] = True\\n            flag = False\\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\\n                if check(x, y) and not visited[x][y] and grid[x][y] == grid[i][j]:\\n                    findBorder(x, y)\\n                if check(x, y) and not visited[x][y] and grid[i][j] != grid[x][y]:\\n                    flag = True\\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1 or flag:\\n                grid[i][j] = color\\n        findBorder(r0, c0)\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 768427,
                "title": "intuitive-dfs-sol-python3",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n\\n        if not grid or not grid[0]:\\n            return\\n\\n        n = len(grid)\\n        m = len(grid[0])\\n\\n        self.start_color = grid[r0][c0]\\n        self.seen = [[False] * m for i in range(n)]\\n\\n        dr = [-1, 0, 1, 0]\\n        dc = [0, 1, 0, -1]\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m or self.seen[i][j]:\\n                return\\n\\n            if grid[i][j] != self.start_color:\\n                return True\\n\\t\\t\\t\\t\\n            self.seen[i][j] = True\\n\\n            if i == 0 or j == 0 or i == n - 1 or j == m - 1:\\n                grid[i][j] = color\\n\\n            for d in range(4):\\n\\n                if dfs(i + dr[d], j + dc[d]):\\n                    grid[i][j] = color\\n\\n        dfs(r0, c0)\\n\\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n\\n        if not grid or not grid[0]:\\n            return\\n\\n        n = len(grid)\\n        m = len(grid[0])\\n\\n        self.start_color = grid[r0][c0]\\n        self.seen = [[False] * m for i in range(n)]\\n\\n        dr = [-1, 0, 1, 0]\\n        dc = [0, 1, 0, -1]\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m or self.seen[i][j]:\\n                return\\n\\n            if grid[i][j] != self.start_color:\\n                return True\\n\\t\\t\\t\\t\\n            self.seen[i][j] = True\\n\\n            if i == 0 or j == 0 or i == n - 1 or j == m - 1:\\n                grid[i][j] = color\\n\\n            for d in range(4):\\n\\n                if dfs(i + dr[d], j + dc[d]):\\n                    grid[i][j] = color\\n\\n        dfs(r0, c0)\\n\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683364,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\n    int r = 0, c = 0;\\n    vector<vector<bool>>visited;\\n    vector<vector<int>>res;\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j, int color, int color0) {\\n        if (i < 0 || j < 0 || i >= r || j >= c || grid[i][j] != color0)\\n            return true;\\n\\n        if (visited[i][j])\\n            return grid[i][j] != color0;\\n        \\n        visited[i][j] = true;\\n        if (dfs(grid, i+1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i-1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j+1, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j-1, color, color0))\\n            res[i][j] = color;\\n\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        r = grid.size();\\n        c = grid[0].size();\\n        \\n        int color0 = grid[r0][c0];\\n        visited.resize(r, vector<bool>(c, false));\\n        res = grid;\\n        \\n        dfs(grid, r0, c0, color, color0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int r = 0, c = 0;\\n    vector<vector<bool>>visited;\\n    vector<vector<int>>res;\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j, int color, int color0) {\\n        if (i < 0 || j < 0 || i >= r || j >= c || grid[i][j] != color0)\\n            return true;\\n\\n        if (visited[i][j])\\n            return grid[i][j] != color0;\\n        \\n        visited[i][j] = true;\\n        if (dfs(grid, i+1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i-1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j+1, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j-1, color, color0))\\n            res[i][j] = color;\\n\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        r = grid.size();\\n        c = grid[0].size();\\n        \\n        int color0 = grid[r0][c0];\\n        visited.resize(r, vector<bool>(c, false));\\n        res = grid;\\n        \\n        dfs(grid, r0, c0, color, color0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680918,
                "title": "c-bfs-solution",
                "content": "Space Complexity: O(min(n,m)) where m and n are the number of rows, columns on the grid\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int r = A.size();\\n        if(r==0) return vector<vector<int>>();\\n        int c = A[0].size();\\n        vector<vector<int>>  visited =  vector<vector<int>> (r, vector<int> (c, 2)); // white\\n        queue<pair<int,int>> q;\\n        q.push({r0, c0});\\n        visited[r0][c0] = 1;\\n        set<pair<int,int>> border;\\n        while(!q.empty()){\\n            auto u = q.front(); q.pop();\\n            int x = u.first, y = u.second;\\n            // cout<<\"Popped: \"<<x<<\" \"<<y<<endl;\\n            for(auto d: dirs){\\n                int i = x + d.first;\\n                int j = y + d.second;\\n                if(i>=0 && i<r && j>=0 && j<c && A[i][j]==A[x][y]){\\n                    if(visited[i][j]==2){\\n                        // cout<<\"pushing \"<<i<<\" \"<<j<<\" color: \"<<A[i][j]<<endl;\\n                        q.push({i,j});\\n                        visited[i][j] = 1;\\n                    }\\n                }\\n                else{\\n                    // cout<<\"Border: \"<<x<<\" \"<<y<<endl;\\n                    border.insert({x,y});\\n                }\\n            }\\n            visited[x][y] = 0;\\n        }\\n        for(auto s: border){\\n            A[s.first][s.second] = color;\\n        }\\n        return A;\\n    }\\n};\\n\\n\\n//  1    1   1\\n//  1   (1)  1  --> this one is surrounded by elements of same color and is not on border- should not be colored\\n//  1    1   1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int r = A.size();\\n        if(r==0) return vector<vector<int>>();\\n        int c = A[0].size();\\n        vector<vector<int>>  visited =  vector<vector<int>> (r, vector<int> (c, 2)); // white\\n        queue<pair<int,int>> q;\\n        q.push({r0, c0});\\n        visited[r0][c0] = 1;\\n        set<pair<int,int>> border;\\n        while(!q.empty()){\\n            auto u = q.front(); q.pop();\\n            int x = u.first, y = u.second;\\n            // cout<<\"Popped: \"<<x<<\" \"<<y<<endl;\\n            for(auto d: dirs){\\n                int i = x + d.first;\\n                int j = y + d.second;\\n                if(i>=0 && i<r && j>=0 && j<c && A[i][j]==A[x][y]){\\n                    if(visited[i][j]==2){\\n                        // cout<<\"pushing \"<<i<<\" \"<<j<<\" color: \"<<A[i][j]<<endl;\\n                        q.push({i,j});\\n                        visited[i][j] = 1;\\n                    }\\n                }\\n                else{\\n                    // cout<<\"Border: \"<<x<<\" \"<<y<<endl;\\n                    border.insert({x,y});\\n                }\\n            }\\n            visited[x][y] = 0;\\n        }\\n        for(auto s: border){\\n            A[s.first][s.second] = color;\\n        }\\n        return A;\\n    }\\n};\\n\\n\\n//  1    1   1\\n//  1   (1)  1  --> this one is surrounded by elements of same color and is not on border- should not be colored\\n//  1    1   1\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645798,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> visited;\\n    vector<vector<int>> copy;\\n    int r, c, original;\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        original = grid[r0][c0];\\n        copy = grid;\\n        visited = vector<vector<bool>>(r, vector<bool>(c, false));\\n        visit(grid, color, r0, c0);\\n        return copy;\\n    }\\n    \\n    void visit(vector<vector<int>>& grid, int color, int x, int y){\\n        visited[x][y] = true;\\n        if (x==0 || grid[x-1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x-1][y]){\\n            visit(grid, color, x-1, y);\\n        }\\n        if (x==r-1 || grid[x+1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x+1][y]){\\n            visit(grid, color, x+1, y);\\n        }\\n        if (y==0 || grid[x][y-1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y-1]){\\n            visit(grid, color, x, y-1);\\n        }\\n        if (y==c-1 || grid[x][y+1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y+1]){\\n            visit(grid, color, x, y+1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> visited;\\n    vector<vector<int>> copy;\\n    int r, c, original;\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        original = grid[r0][c0];\\n        copy = grid;\\n        visited = vector<vector<bool>>(r, vector<bool>(c, false));\\n        visit(grid, color, r0, c0);\\n        return copy;\\n    }\\n    \\n    void visit(vector<vector<int>>& grid, int color, int x, int y){\\n        visited[x][y] = true;\\n        if (x==0 || grid[x-1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x-1][y]){\\n            visit(grid, color, x-1, y);\\n        }\\n        if (x==r-1 || grid[x+1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x+1][y]){\\n            visit(grid, color, x+1, y);\\n        }\\n        if (y==0 || grid[x][y-1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y-1]){\\n            visit(grid, color, x, y-1);\\n        }\\n        if (y==c-1 || grid[x][y+1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y+1]){\\n            visit(grid, color, x, y+1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545883,
                "title": "c-solution-simple-dfs-approach-easy-to-understand",
                "content": "class Solution {\\npublic:\\n        \\n    vector<vector<int>> borders ;\\n    void dfs(int i, int j, int color, int color_base, vector<vector<int>>& grid, vector<vector<bool>>& visited)\\n    {   \\n        if (i<0||j<0||i>=grid.size()||j>=grid[0].size())\\n            return ;\\n        if (grid[i][j]!=color_base)\\n            return ;\\n        if (visited[i][j]==true)\\n            return ;\\n                \\n        // condition (on the border)\\n        bool condition1 = (i*j==0 || i==grid.size()-1 || j==grid[0].size()-1) ;\\n                \\n        // condition (element has a 4 directional adjacent element not in the component)\\n        bool condition3 = (!condition1 && (grid[i+1][j]!=color_base||grid[i-1][j]!=color_base||grid[i][j+1]!=color_base||grid[i][j-1]!=color_base)) ; \\n                \\n        if (condition1 || condition3)\\n            borders.push_back({i,j});\\n        \\n        visited[i][j] = true ;\\n        dfs(i+1,j,color,color_base,grid,visited) ;\\n        dfs(i-1,j,color,color_base,grid,visited) ;\\n        dfs(i,j+1,color,color_base,grid,visited) ;\\n        dfs(i,j-1,color,color_base,grid,visited) ;\\n        \\n        return ;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        vector<vector<bool>> visited (m, vector<bool>(n, false)) ;\\n        dfs(r0, c0, color, grid[r0][c0], grid, visited) ;\\n        \\n        for (auto x : borders)\\n            grid[x[0]][x[1]] = color ;\\n         \\n        return grid ;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n        \\n    vector<vector<int>> borders ;\\n    void dfs(int i, int j, int color, int color_base, vector<vector<int>>& grid, vector<vector<bool>>& visited)\\n    {   \\n        if (i<0||j<0||i>=grid.size()||j>=grid[0].size())\\n            return ;\\n        if (grid[i][j]!=color_base)\\n            return ;\\n        if (visited[i][j]==true)\\n            return ;\\n                \\n        // condition (on the border)\\n        bool condition1 = (i*j==0 || i==grid.size()-1 || j==grid[0].size()-1) ;\\n                \\n        // condition (element has a 4 directional adjacent element not in the component)\\n        bool condition3 = (!condition1 && (grid[i+1][j]!=color_base||grid[i-1][j]!=color_base||grid[i][j+1]!=color_base||grid[i][j-1]!=color_base)) ; \\n                \\n        if (condition1 || condition3)\\n            borders.push_back({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 403401,
                "title": "python-dfs-inside-of-the-connected-component-checking-if-current-node-is-on-the-border",
                "content": "```python\\ndef colorBorder(self, grid, r0, c0, color):\\n\\t# True if node (i, j) is inside of the connected component.\\n\\tdef inside_cc(i, j):   \\n\\t\\t# Note: Only nodes inside of the connected component are added to \"visited\".\\n\\t\\tif (i, j) in visited: return True\\n\\t\\telif 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==cc_color:\\n\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\tneighbors = [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]\\n\\t\\t\\t# If one of the neighbors is not inside of cc, then node (i, j) is a border node.\\n\\t\\t\\tif any([not inside_cc(x, y) for x, y in neighbors]):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\t\\t\\treturn True\\n\\t\\telse: return False\\n\\tcc_color = grid[r0][c0]\\n\\tvisited = set()\\n\\tinside_cc(r0,c0)\\n\\treturn grid  \\n```",
                "solutionTags": [],
                "code": "```python\\ndef colorBorder(self, grid, r0, c0, color):\\n\\t# True if node (i, j) is inside of the connected component.\\n\\tdef inside_cc(i, j):   \\n\\t\\t# Note: Only nodes inside of the connected component are added to \"visited\".\\n\\t\\tif (i, j) in visited: return True\\n\\t\\telif 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==cc_color:\\n\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\tneighbors = [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]\\n\\t\\t\\t# If one of the neighbors is not inside of cc, then node (i, j) is a border node.\\n\\t\\t\\tif any([not inside_cc(x, y) for x, y in neighbors]):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\t\\t\\treturn True\\n\\t\\telse: return False\\n\\tcc_color = grid[r0][c0]\\n\\tvisited = set()\\n\\tinside_cc(r0,c0)\\n\\treturn grid  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395693,
                "title": "javascript-dfs-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} r0\\n * @param {number} c0\\n * @param {number} color\\n * @return {number[][]}\\n */\\nconst colorBorder = function(grid, r0, c0, color) {\\n   if (grid[r0][c0] === color) { return grid; }\\n    \\n    const visited = new Array(grid.length).fill(0).map( row => {\\n        return new Array(grid[0].length).fill(false);\\n    })\\n    \\n    dfs(grid, visited, grid[r0][c0], r0, c0, color);\\n        \\n    return grid;\\n};\\n\\nconst dfs = function(grid, visited, prevVal, r, c, color){\\n    /*  Order here matters  */\\n    if ( r < 0 || c < 0 || r === grid.length ||  c === grid[0].length) { return -1; }\\n\\n    if (visited[r][c]) { return color; }\\n    \\n    if(grid[r][c] !== prevVal) { return -1; }\\n    \\n    \\n    visited[r][c] = true;\\n    const v1 = dfs(grid, visited, grid[r][c], r+1, c, color);\\n    const v2 = dfs(grid, visited, grid[r][c], r-1, c, color);\\n    const v3 = dfs(grid, visited, grid[r][c], r, c+1, color);\\n    const v4 = dfs(grid, visited, grid[r][c], r, c-1, color);\\n\\n    if( ![v1, v2, v3, v4].every( val => ( val === color || val === prevVal))){\\n        grid[r][c] = color;\\n    }\\n\\n    return grid[r][c];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} r0\\n * @param {number} c0\\n * @param {number} color\\n * @return {number[][]}\\n */\\nconst colorBorder = function(grid, r0, c0, color) {\\n   if (grid[r0][c0] === color) { return grid; }\\n    \\n    const visited = new Array(grid.length).fill(0).map( row => {\\n        return new Array(grid[0].length).fill(false);\\n    })\\n    \\n    dfs(grid, visited, grid[r0][c0], r0, c0, color);\\n        \\n    return grid;\\n};\\n\\nconst dfs = function(grid, visited, prevVal, r, c, color){\\n    /*  Order here matters  */\\n    if ( r < 0 || c < 0 || r === grid.length ||  c === grid[0].length) { return -1; }\\n\\n    if (visited[r][c]) { return color; }\\n    \\n    if(grid[r][c] !== prevVal) { return -1; }\\n    \\n    \\n    visited[r][c] = true;\\n    const v1 = dfs(grid, visited, grid[r][c], r+1, c, color);\\n    const v2 = dfs(grid, visited, grid[r][c], r-1, c, color);\\n    const v3 = dfs(grid, visited, grid[r][c], r, c+1, color);\\n    const v4 = dfs(grid, visited, grid[r][c], r, c-1, color);\\n\\n    if( ![v1, v2, v3, v4].every( val => ( val === color || val === prevVal))){\\n        grid[r][c] = color;\\n    }\\n\\n    return grid[r][c];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328475,
                "title": "java-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    int[][] dir = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        if (grid.length == 0 || grid[0].length == 0) return grid;    \\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        dfs(grid, r0, c0, m, n, color, grid[r0][c0], new boolean[m][n]);\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int m, int n, int color, int ic, boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i == m || j == n || visited[i][j] || grid[i][j] != ic) return;\\n        \\n        if (changeColor(grid, i, j, m, n, ic, visited)) {\\n            grid[i][j] = color;    \\n        } \\n        \\n        visited[i][j] = true;\\n        \\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            \\n            dfs(grid, x, y, m, n, color, ic, visited);\\n        }\\n    }\\n    \\n    private boolean changeColor(int[][] grid, int i, int j, int m, int n, int ic, boolean[][] visited) {\\n        \\n        if (i == 0 || j == 0 || i+1 == m || j+1 == n) return true;\\n        \\n        int borders = 4;\\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n        \\n            if (visited[x][y] || grid[x][y] == ic) {\\n                borders--;    \\n            }\\n        }\\n        \\n        return borders > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dir = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        if (grid.length == 0 || grid[0].length == 0) return grid;    \\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        dfs(grid, r0, c0, m, n, color, grid[r0][c0], new boolean[m][n]);\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int m, int n, int color, int ic, boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i == m || j == n || visited[i][j] || grid[i][j] != ic) return;\\n        \\n        if (changeColor(grid, i, j, m, n, ic, visited)) {\\n            grid[i][j] = color;    \\n        } \\n        \\n        visited[i][j] = true;\\n        \\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            \\n            dfs(grid, x, y, m, n, color, ic, visited);\\n        }\\n    }\\n    \\n    private boolean changeColor(int[][] grid, int i, int j, int m, int n, int ic, boolean[][] visited) {\\n        \\n        if (i == 0 || j == 0 || i+1 == m || j+1 == n) return true;\\n        \\n        int borders = 4;\\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n        \\n            if (visited[x][y] || grid[x][y] == ic) {\\n                borders--;    \\n            }\\n        }\\n        \\n        return borders > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284393,
                "title": "java-dfs-short-1ms-solution",
                "content": "```\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length, n = grid[0].length, oldColor = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        dfs(grid, r0, c0, m, n, oldColor, color, visited);\\n        for (int i = 1; i < m - 1; i++) {\\n            for (int j = 1; j < n - 1; j++) {\\n                if (visited[i][j] && visited[i - 1][j] && visited[i + 1][j] && visited[i][j + 1] && visited[i][j - 1]) {\\n                    grid[i][j] = oldColor;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j, int m, int n, int oldColor, int color, boolean[][] visited) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid[i][j] != oldColor) return;\\n        visited[i][j] = true;\\n        grid[i][j] = color;\\n        dfs(grid, i + 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i - 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i, j + 1, m, n, oldColor, color, visited);\\n        dfs(grid, i, j - 1, m, n, oldColor, color, visited);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length, n = grid[0].length, oldColor = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        dfs(grid, r0, c0, m, n, oldColor, color, visited);\\n        for (int i = 1; i < m - 1; i++) {\\n            for (int j = 1; j < n - 1; j++) {\\n                if (visited[i][j] && visited[i - 1][j] && visited[i + 1][j] && visited[i][j + 1] && visited[i][j - 1]) {\\n                    grid[i][j] = oldColor;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j, int m, int n, int oldColor, int color, boolean[][] visited) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid[i][j] != oldColor) return;\\n        visited[i][j] = true;\\n        grid[i][j] = color;\\n        dfs(grid, i + 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i - 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i, j + 1, m, n, oldColor, color, visited);\\n        dfs(grid, i, j - 1, m, n, oldColor, color, visited);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 283806,
                "title": "java-short-and-simple-dfs-with-explaination",
                "content": "Recursion rule: It will enter the next level of recursion only if current point is not a border. \\nEach time we check 4 directions, say next point:\\n* If current point is a border, we would change current point\\'s color and not enter the recursion with this next point, since it already reaches the border. \\n* If not, we do not change current color and enter the next level of recursion.\\n\\nSo we do not need to test the boundary in the base case, we only test whether it is visted.\\n\\nNoted, when test it is a border:\\nOther than the next point is out of boundary, it also may be an inner point.\\nIf the next point\\'s color is not the original color, we also need to test wehter we have visited before. Because it may be an inner point so that we didn\\'t change its color.\\n\\n```\\nclass Solution {\\n    private static final int[][] dir = { {-1,0}, {1,0}, {0,-1}, {0,1} };\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        colorBorder(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    private void colorBorder(int[][] grid, int r, int c, int orig, int color, boolean[][] visited) {\\n        if (visited[r][c]) return;\\n        visited[r][c] = true;\\n        for (int[] d : dir) {\\n            int nr = r + d[0], nc = c + d[1]; // next point\\n            if (nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || (grid[nr][nc] != orig && !visited[nr][nc])) {\\n\\t\\t\\t// update current color since either the next point is out of boundary or the next point\\'s color is different and we did not visit it before.\\n                grid[r][c] = color; \\n                continue; // not enter the recursion and go next direction.\\n            }\\n            colorBorder(grid, nr, nc, orig, color, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[][] dir = { {-1,0}, {1,0}, {0,-1}, {0,1} };\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        colorBorder(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    private void colorBorder(int[][] grid, int r, int c, int orig, int color, boolean[][] visited) {\\n        if (visited[r][c]) return;\\n        visited[r][c] = true;\\n        for (int[] d : dir) {\\n            int nr = r + d[0], nc = c + d[1]; // next point\\n            if (nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || (grid[nr][nc] != orig && !visited[nr][nc])) {\\n\\t\\t\\t// update current color since either the next point is out of boundary or the next point\\'s color is different and we did not visit it before.\\n                grid[r][c] = color; \\n                continue; // not enter the recursion and go next direction.\\n            }\\n            colorBorder(grid, nr, nc, orig, color, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283054,
                "title": "python",
                "content": "\\u54CE\\u3002\\u3002\\u3002\\u6211\\u5FC5\\u987B\\u5766\\u767D\\u8FD9\\u4E2A\\u9898contest\\u7684\\u65F6\\u5019\\u6CA1\\u505A\\u51FA\\u6765\\uFF0C\\u4E0D\\u662F\\u56E0\\u4E3A\\u4E0D\\u4F1A\\uFF0C\\u800C\\u662F\\u6CA1\\u641E\\u6E05\\u695Aborder\\u7684\\u5B9A\\u4E49\\u88AB\\u5751\\u4E86\\uFF0C\\u7136\\u540E\\u5C31\\u4E00\\u76F4\\u8C03\\u4EE3\\u7801\\uFF0Cgg\\u3002\\u3002\\u3002\\n\\u8FD9\\u79CD\\u9898\\u7684\\u601D\\u8DEF\\u8FD8\\u662F\\u5F88\\u6E05\\u695A\\u7684\\uFF0C\\u5C31\\u662F\\u6F2B\\u6C34\\u7B97\\u6CD5\\uFF08floodfill\\uFF09\\uFF0C\\u6216\\u8005\\u8BF4\\u6DF1\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u3002\\u6211\\u4EEC\\u53EF\\u4EE5\\u4ECE\\u7ED9\\u5B9A\\u7684\\u683C\\u70B9\\u5F00\\u59CBdfs\\uFF0C\\u5982\\u679C\\u53D1\\u73B0\\u5F53\\u524D\\u70B9\\u662Fborder\\uFF0C\\u5C31\\u67D3\\u8272\\u3002\\n\\u4F46\\u662F\\u8FD9\\u91CC\\u6709\\u51E0\\u4E2A\\u5751\\uFF1A\\n1. \\u9996\\u5148\\u662F\\u9898\\u76EE\\u5173\\u4E8Eborder\\u7684\\u63CF\\u8FF0\\uFF0C\\u90A3\\u4E2A```4-directionally adjacent```\\u7684\\u610F\\u601D\\u662F\\u53EA\\u8981\\u56DB\\u4E2A\\u90BB\\u5C45\\u91CC\\u9762\\u6709\\u4E00\\u4E2A\\u548C\\u5B83\\u989C\\u8272\\u4E0D\\u4E00\\u6837\\u5C31\\u662Fborder\\u4E86\\uFF0C\\u4E00\\u5F00\\u59CB\\u8FD8\\u4EE5\\u4E3A\\u662F4\\u4E2A\\u90BB\\u5C45\\u90FD\\u8981\\u548C\\u5B83\\u4E0D\\u4E00\\u6837\\u3002\\u3002\\u3002\\u545C\\u545C\\u545C\\n2. \\u5176\\u6B21\\uFF0C\\u6211\\u4EEC\\u4E0D\\u80FD\\u76F4\\u63A5\\u5BF9\\u539F\\u6570\\u7EC4\\u67D3\\u8272\\uFF0C\\u56E0\\u4E3A\\u8FB9dfs\\u8FB9\\u67D3\\u8272\\u53EF\\u80FD\\u5F71\\u54CD\\u5230\\u4E00\\u4E9B\\u8FD8\\u6CA1\\u6709\\u641C\\u7D22\\u5230\\u7684\\u683C\\u70B9\\u7684\\u6761\\u4EF6\\u5224\\u65AD\\uFF0C\\u4FDD\\u9669\\u7684\\u505A\\u6CD5\\u662F\\u7528\\u53E6\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u6570\\u7EC4```should_color```\\u6765\\u6807\\u8BB0\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u8981\\u4E0D\\u8981\\u67D3\\u8272\\n\\n\\u4EE3\\u7801\\uFF1A\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        def is_border(grid, i, j):\\n\\t\\t\\t# \\u6570\\u7EC4\\u8FB9\\u754C\\n            if i == 0 or i == nr - 1 or j == 0 or j == nc - 1:\\n                return True\\n\\t\\t\\t# \\u56DB\\u4E2A\\u65B9\\u5411\\u6709\\u4E00\\u4E2A\\u4E0D\\u4E00\\u6837\\u7684\\u90BB\\u5C45\\t\\n            target = grid[i][j]\\n            left = grid[i][j-1]\\n            right = grid[i][j+1]\\n            top = grid[i-1][j]\\n            down = grid[i+1][j]\\n            if left != target or right != target or top != target or down != target:\\n                return True\\n            return False\\n            \\n        def dfs(grid, i, j, target, visited, color):\\n\\t\\t\\t# \\u641C\\u5230\\u4E86\\u8FB9\\u754C\\uFF0C\\u8FD4\\u56DE\\n            if i < 0  or i >= nr or j < 0 or j >= nc:\\n                return\\n\\t\\t\\t# \\u5DF2\\u7ECF\\u641C\\u8FC7\\uFF0C\\u8FD4\\u56DE\\n            if visited[i][j]:\\n                return\\n\\t\\t\\t# \\u5F53\\u524D\\u989C\\u8272\\u4E0D\\u662Ftarget\\u7684\\u989C\\u8272\\uFF0C\\u4E0D\\u5C5E\\u4E8E\\u8FD9\\u4E2Aconnected component\\uFF0C\\u8FD4\\u56DE\\n            if target != grid[i][j]:\\n                return\\n            visited[i][j] = 1\\n            \\n            if is_border(grid, i, j):\\n                # grid[i][j] = color  # dont do that!\\n                should_color[i][j] = 1\\n            dfs(grid, i, j+1, target, visited, color)\\n            dfs(grid, i, j-1, target, visited, color)\\n            dfs(grid, i-1, j, target, visited, color)\\n            dfs(grid, i+1, j, target, visited, color)\\n        \\n        nr = len(grid)\\n        nc = len(grid[0])\\n        visited = [[0]*nc for _ in range(nr)]\\n        should_color = [[0]*nc for _ in range(nr)]\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], visited, color)\\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                if should_color[i][j]:\\n                    grid[i][j] = color\\n        \\n        return grid\\n```",
                "solutionTags": [],
                "code": "```4-directionally adjacent```\n```should_color```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        def is_border(grid, i, j):\\n\\t\\t\\t# \\u6570\\u7EC4\\u8FB9\\u754C\\n            if i == 0 or i == nr - 1 or j == 0 or j == nc - 1:\\n                return True\\n\\t\\t\\t# \\u56DB\\u4E2A\\u65B9\\u5411\\u6709\\u4E00\\u4E2A\\u4E0D\\u4E00\\u6837\\u7684\\u90BB\\u5C45\\t\\n            target = grid[i][j]\\n            left = grid[i][j-1]\\n            right = grid[i][j+1]\\n            top = grid[i-1][j]\\n            down = grid[i+1][j]\\n            if left != target or right != target or top != target or down != target:\\n                return True\\n            return False\\n            \\n        def dfs(grid, i, j, target, visited, color):\\n\\t\\t\\t# \\u641C\\u5230\\u4E86\\u8FB9\\u754C\\uFF0C\\u8FD4\\u56DE\\n            if i < 0  or i >= nr or j < 0 or j >= nc:\\n                return\\n\\t\\t\\t# \\u5DF2\\u7ECF\\u641C\\u8FC7\\uFF0C\\u8FD4\\u56DE\\n            if visited[i][j]:\\n                return\\n\\t\\t\\t# \\u5F53\\u524D\\u989C\\u8272\\u4E0D\\u662Ftarget\\u7684\\u989C\\u8272\\uFF0C\\u4E0D\\u5C5E\\u4E8E\\u8FD9\\u4E2Aconnected component\\uFF0C\\u8FD4\\u56DE\\n            if target != grid[i][j]:\\n                return\\n            visited[i][j] = 1\\n            \\n            if is_border(grid, i, j):\\n                # grid[i][j] = color  # dont do that!\\n                should_color[i][j] = 1\\n            dfs(grid, i, j+1, target, visited, color)\\n            dfs(grid, i, j-1, target, visited, color)\\n            dfs(grid, i-1, j, target, visited, color)\\n            dfs(grid, i+1, j, target, visited, color)\\n        \\n        nr = len(grid)\\n        nc = len(grid[0])\\n        visited = [[0]*nc for _ in range(nr)]\\n        should_color = [[0]*nc for _ in range(nr)]\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], visited, color)\\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                if should_color[i][j]:\\n                    grid[i][j] = color\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283010,
                "title": "bfs-method-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<pair<int,int>> retv;\\n        queue<pair<int,int>> q;\\n        q.push(pair<int,int>(r0,c0));\\n        vector<vector<bool>> go(grid.size(),vector<bool>(grid[0].size(),false));\\n        vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        go[r0][c0] = true;\\n        while(!q.empty())\\n        {\\n            auto e = q.front();q.pop();\\n            int x = e.first;\\n            int y = e.second;\\n            for(auto d : dirs)\\n            {\\n                int _x = x+d[0];\\n                int _y = y+d[1];\\n                if(_x>=0&&_x<grid.size()&&_y>=0&&_y<grid[0].size()&&grid[_x][_y] == grid[x][y])\\n                {\\n                    if(go[_x][_y] == false)\\n                    {\\n                        q.push(pair<int,int>(_x,_y));    \\n                        go[_x][_y] = true;\\n                    }\\n                }\\n                else\\n                {\\n                    retv.push_back(pair<int,int>(x,y));\\n                }\\n            }\\n        }\\n        for(auto e: retv)\\n        {\\n            grid[e.first][e.second] = color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<pair<int,int>> retv;\\n        queue<pair<int,int>> q;\\n        q.push(pair<int,int>(r0,c0));\\n        vector<vector<bool>> go(grid.size(),vector<bool>(grid[0].size(),false));\\n        vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        go[r0][c0] = true;\\n        while(!q.empty())\\n        {\\n            auto e = q.front();q.pop();\\n            int x = e.first;\\n            int y = e.second;\\n            for(auto d : dirs)\\n            {\\n                int _x = x+d[0];\\n                int _y = y+d[1];\\n                if(_x>=0&&_x<grid.size()&&_y>=0&&_y<grid[0].size()&&grid[_x][_y] == grid[x][y])\\n                {\\n                    if(go[_x][_y] == false)\\n                    {\\n                        q.push(pair<int,int>(_x,_y));    \\n                        go[_x][_y] = true;\\n                    }\\n                }\\n                else\\n                {\\n                    retv.push_back(pair<int,int>(x,y));\\n                }\\n            }\\n        }\\n        for(auto e: retv)\\n        {\\n            grid[e.first][e.second] = color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282948,
                "title": "dfs-solution-using-java",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] check = new boolean[grid.length][grid[0].length];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        int cur_color = grid[r0][c0];\\n        dfs(grid, check, visited, r0, c0, cur_color);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(check[i][j]){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n    \\n    \\n    public void dfs(int[][] grid, boolean[][] check, boolean[][] visited, int i, int j, int color){\\n        if(visited[i][j] == true){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        for(int[] dir: dirs){\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=color){\\n                check[i][j] = true;\\n            }\\n            if(x>=0 && x<grid.length && y>=0 && y<grid[0].length && grid[x][y] == color){\\n                dfs(grid, check, visited, x, y, color);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] check = new boolean[grid.length][grid[0].length];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        int cur_color = grid[r0][c0];\\n        dfs(grid, check, visited, r0, c0, cur_color);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(check[i][j]){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n    \\n    \\n    public void dfs(int[][] grid, boolean[][] check, boolean[][] visited, int i, int j, int color){\\n        if(visited[i][j] == true){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        for(int[] dir: dirs){\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=color){\\n                check[i][j] = true;\\n            }\\n            if(x>=0 && x<grid.length && y>=0 && y<grid[0].length && grid[x][y] == color){\\n                dfs(grid, check, visited, x, y, color);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282892,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nPerform dfs from the start poistion and mark with `-1` to remember the visited positions and mark with `0` to cells which are border cells.\\nWe cannot paint a cell with new color yet while doing dfs because that will change the status of its neighbor cells (neighbor cells will think they are on the border).\\n\\n```\\npublic int[][] colorBorder(int[][] g, int r0, int c0, int c) {\\n        int old = g[r0][c0];\\n        dfs(g, r0, c0, old);\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    g[i][j] = c;\\n                else if(g[i][j] == -1)\\n                    g[i][j] = old;\\n        return g;\\n    }\\n    private void dfs(int[][] g, int x, int y, int c){\\n        if(x < 0 || x == g.length || y < 0 || y == g[0].length || g[x][y] != c) return;\\n        border(g, x, y, c);\\n        dfs(g, x+1, y, c);\\n        dfs(g, x-1, y, c);\\n        dfs(g, x, y+1, c);\\n        dfs(g, x, y-1, c);\\n    }\\n    private void border(int[][] g, int x, int y, int c){\\n        g[x][y] = -1;\\n        if(isBorder(g, x+1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x-1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y-1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y+1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n    }\\n    private boolean isBorder(int[][] g, int x, int y, int c){\\n        return x < 0 || x == g.length || y < 0 || y == g[0].length || (g[x][y] != c && g[x][y] != -1 && g[x][y] != 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] colorBorder(int[][] g, int r0, int c0, int c) {\\n        int old = g[r0][c0];\\n        dfs(g, r0, c0, old);\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    g[i][j] = c;\\n                else if(g[i][j] == -1)\\n                    g[i][j] = old;\\n        return g;\\n    }\\n    private void dfs(int[][] g, int x, int y, int c){\\n        if(x < 0 || x == g.length || y < 0 || y == g[0].length || g[x][y] != c) return;\\n        border(g, x, y, c);\\n        dfs(g, x+1, y, c);\\n        dfs(g, x-1, y, c);\\n        dfs(g, x, y+1, c);\\n        dfs(g, x, y-1, c);\\n    }\\n    private void border(int[][] g, int x, int y, int c){\\n        g[x][y] = -1;\\n        if(isBorder(g, x+1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x-1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y-1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y+1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n    }\\n    private boolean isBorder(int[][] g, int x, int y, int c){\\n        return x < 0 || x == g.length || y < 0 || y == g[0].length || (g[x][y] != c && g[x][y] != -1 && g[x][y] != 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282852,
                "title": "java-bfs",
                "content": "though not so efficient in space\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        boolean[][] visited = new boolean[row][col];\\n        boolean[][] border = new boolean[row][col];\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{r0,c0});\\n        visited[r0][c0] = true; // visited\\n        \\n        int[][] steps = {{-1,0},{1,0},{0,1},{0,-1}};\\n        //System.out.println(\"now to bfs\");\\n        \\n        while(!queue.isEmpty()) {\\n            int[] item = queue.poll();\\n            int x = item[0];\\n            int y = item[1];\\n            //System.out.println(\"x=\" + x + \", y=\" + y);\\n            for(int i = 0; i < steps.length; ++i) {\\n                int nextx = x + steps[i][0];\\n                int nexty = y + steps[i][1];\\n                if(nextx < 0 || nextx >= row || nexty < 0 || nexty >= col || grid[nextx][nexty] != grid[x][y]) {\\n                    border[x][y] = true; // is border\\n                }\\n                else { // so here, next color is the same \\n                    if(!visited[nextx][nexty]) { // not visited\\n                        queue.add(new int[]{nextx, nexty});\\n                        visited[nextx][nexty] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[i].length; ++j) {\\n                if(border[i][j]) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        boolean[][] visited = new boolean[row][col];\\n        boolean[][] border = new boolean[row][col];\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{r0,c0});\\n        visited[r0][c0] = true; // visited\\n        \\n        int[][] steps = {{-1,0},{1,0},{0,1},{0,-1}};\\n        //System.out.println(\"now to bfs\");\\n        \\n        while(!queue.isEmpty()) {\\n            int[] item = queue.poll();\\n            int x = item[0];\\n            int y = item[1];\\n            //System.out.println(\"x=\" + x + \", y=\" + y);\\n            for(int i = 0; i < steps.length; ++i) {\\n                int nextx = x + steps[i][0];\\n                int nexty = y + steps[i][1];\\n                if(nextx < 0 || nextx >= row || nexty < 0 || nexty >= col || grid[nextx][nexty] != grid[x][y]) {\\n                    border[x][y] = true; // is border\\n                }\\n                else { // so here, next color is the same \\n                    if(!visited[nextx][nexty]) { // not visited\\n                        queue.add(new int[]{nextx, nexty});\\n                        visited[nextx][nexty] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[i].length; ++j) {\\n                if(border[i][j]) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282840,
                "title": "python-clean-bfs-solution",
                "content": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        queue = deque()\\n\\t\\tqueue.append((r0,c0))\\n        visited = set()\\n        visited.add((r0,c0))\\n        marked = []\\n        direc = [(-1,0), (1,0), (0,1),(0,-1)]\\n        old = grid[r0][c0]\\n        while queue:\\n            r, c = queue.popleft()\\n            if r == 0 or r == len(grid)-1 or c == 0 or c == len(grid[0])-1 or grid[r-1][c] != old or grid[r+1][c] != old or grid[r][c-1] != old or grid[r][c+1] != old:\\n                marked.append((r,c))\\n            for d_x,d_y in direc:\\n                x = r+d_x\\n                y = c+d_y\\n                if x >= 0 and x < len(grid) and y >=0 and y < len(grid[0]) and grid[x][y] == old and (x,y) not in visited:\\n                    visited.add((x,y))\\n                    queue.append((x,y))\\n        for x,y in marked:\\n            grid[x][y] = color\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        queue = deque()\\n\\t\\tqueue.append((r0,c0))\\n        visited = set()\\n        visited.add((r0,c0))\\n        marked = []\\n        direc = [(-1,0), (1,0), (0,1),(0,-1)]\\n        old = grid[r0][c0]\\n        while queue:\\n            r, c = queue.popleft()\\n            if r == 0 or r == len(grid)-1 or c == 0 or c == len(grid[0])-1 or grid[r-1][c] != old or grid[r+1][c] != old or grid[r][c-1] != old or grid[r][c+1] != old:\\n                marked.append((r,c))\\n            for d_x,d_y in direc:\\n                x = r+d_x\\n                y = c+d_y\\n                if x >= 0 and x < len(grid) and y >=0 and y < len(grid[0]) and grid[x][y] == old and (x,y) not in visited:\\n                    visited.add((x,y))\\n                    queue.append((x,y))\\n        for x,y in marked:\\n            grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4097638,
                "title": "python-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+v) where v is the linear operation for checking visited list and n is for checking through n points.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for a visited list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        prev_color = grid[row][col]\\n\\n        def dfs(row, col):\\n            # addind the node in visited\\n            visited.add((row, col))\\n\\n            # explore four adjucent node\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n\\n                # check if the new node is already visited or not\\n                if (new_row, new_col) not in visited:\\n\\n                    # check if the new node is out of range or not\\n                    if (0 <= new_row < rows) and (0 <= new_col < cols):\\n\\n                        # check if the new node has the same color or not\\n                        if grid[new_row][new_col]==prev_color:\\n\\n                                # do dfs on new node\\n                                dfs(new_row, new_col)\\n                        \\n                        # If the node is not same color then it is a border node. Change the color        \\n                        else:\\n                            grid[row][col] = color\\n                    \\n                    # if new node out of range, then it is a border node. Change the color\\n                    else:\\n                        grid[row][col] = color\\n    \\n        # start the bfs from the given point\\n        dfs(row, col)\\n\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        prev_color = grid[row][col]\\n\\n        def dfs(row, col):\\n            # addind the node in visited\\n            visited.add((row, col))\\n\\n            # explore four adjucent node\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n\\n                # check if the new node is already visited or not\\n                if (new_row, new_col) not in visited:\\n\\n                    # check if the new node is out of range or not\\n                    if (0 <= new_row < rows) and (0 <= new_col < cols):\\n\\n                        # check if the new node has the same color or not\\n                        if grid[new_row][new_col]==prev_color:\\n\\n                                # do dfs on new node\\n                                dfs(new_row, new_col)\\n                        \\n                        # If the node is not same color then it is a border node. Change the color        \\n                        else:\\n                            grid[row][col] = color\\n                    \\n                    # if new node out of range, then it is a border node. Change the color\\n                    else:\\n                        grid[row][col] = color\\n    \\n        # start the bfs from the given point\\n        dfs(row, col)\\n\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097603,
                "title": "python-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApplying Breadth First Search. The idea is we will take a point and then we will find out if this point is our point of interest. After that, we will look points which is \\'one\\' distance from the first point. We can say this layer 1. In our case, there are total four points as such. Top, bottom, right and left points of the main point. We will check the top point and see if it is desired point or not. Then checke the bottom then right and then left. Layer 1 is complete. Then we will go for layer 2. We will check the 4 neighbors of Top point. And it continues.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a list called components to list down the points that needs to be checked sequntially. And then apply checking on the points from the component list.\\n\\n# Complexity\\n- Time complexity: Although it looks like a $$O(n^3)$$ [while loop for components, inside for loop for neighbors, inside checking the neighbors in visited set] but really the computation is way less. because the for loop only checks four neighbour so instead of $$O(n * n * n)$$ it becomes $$O(n * 4 * n)$$ which is $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nCorrect me if I am wrong.\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows, cols = len(grid), len(grid[0])\\n        # co-ordinate that we visited\\n        visited = set()\\n        # co-ordinates that we need to visit\\n        components = [(row, col)]\\n        prev_color = grid[row][col]\\n\\n        def bfs(row, col):\\n            visited.add((row, col))\\n\\n            # checking four neighbors of the point\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n                if (new_row, new_col) not in visited:\\n                    if (0<=new_row<rows) and (0<=new_col<cols):\\n                        # add to the components if the neighboring point is not in perimeter of the matrix\\n                        components.append((new_row, new_col))\\n                        if grid[new_row][new_col] != prev_color:\\n                            # if the color doesn\\'t match, means the new point is not connected component. so we don\\'t need to visit this point anymore.\\n                            components.pop(-1)\\n                            # because colors doesn\\'t match that means this is a border\\n                            grid[row][col] = color\\n\\n                    else:\\n                        # permimeter of the matrix, border by definition\\n                        grid[row][col] = color\\n\\n        # looping through components and do bfs for each point\\n        i = 0\\n        while i < len(components):\\n            bfs(*components[i])\\n            i += 1\\n\\n        return grid\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows, cols = len(grid), len(grid[0])\\n        # co-ordinate that we visited\\n        visited = set()\\n        # co-ordinates that we need to visit\\n        components = [(row, col)]\\n        prev_color = grid[row][col]\\n\\n        def bfs(row, col):\\n            visited.add((row, col))\\n\\n            # checking four neighbors of the point\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n                if (new_row, new_col) not in visited:\\n                    if (0<=new_row<rows) and (0<=new_col<cols):\\n                        # add to the components if the neighboring point is not in perimeter of the matrix\\n                        components.append((new_row, new_col))\\n                        if grid[new_row][new_col] != prev_color:\\n                            # if the color doesn\\'t match, means the new point is not connected component. so we don\\'t need to visit this point anymore.\\n                            components.pop(-1)\\n                            # because colors doesn\\'t match that means this is a border\\n                            grid[row][col] = color\\n\\n                    else:\\n                        # permimeter of the matrix, border by definition\\n                        grid[row][col] = color\\n\\n        # looping through components and do bfs for each point\\n        i = 0\\n        while i < len(components):\\n            bfs(*components[i])\\n            i += 1\\n\\n        return grid\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046648,
                "title": "c-easy-clean-code",
                "content": "=\\n\\n# Code\\n```\\nclass Solution {\\npublic:map<pair<int,int>,int> p;\\n    void t(int i,int j,vector<vector<int>> &g,int x, vector<vector<int>> &v)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]!=x || v[i][j]==1) return ;\\n        v[i][j]=1;\\n        p[{i,j}]++;\\n        t(i+1,j,g,x,v); \\n        t(i-1,j,g,x,v);\\n        t(i,j+1,g,x,v);\\n        t(i,j-1,g,x,v);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int r, int c, int col) {\\n       int m=g.size(),n=g[0].size();\\n       vector<vector<int>> v(m,vector<int> (n,0));\\n       t(r,c,g,g[r][c],v);\\n\\n       for(int i=0;i<g.size();i++)\\n       for(int j=0;j<g[0].size();j++)\\n       {\\n           if(p[{i,j}]>0)\\n           {\\n               if((i-1>=0&&p[{i-1,j}]==0) || (i+1<=g.size()&&p[{i+1,j}]==0) || (j-1>=0&&p[{i,j-1}]==0) || (j+1<=g[0].size()&&p[{i,j+1}]==0))\\n               g[i][j]=col;\\n               \\n               if(i==g.size()-1 || j==g[0].size()-1 || i==0 || j==0)\\n               g[i][j]=col;\\n           }\\n       }\\n       return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:map<pair<int,int>,int> p;\\n    void t(int i,int j,vector<vector<int>> &g,int x, vector<vector<int>> &v)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]!=x || v[i][j]==1) return ;\\n        v[i][j]=1;\\n        p[{i,j}]++;\\n        t(i+1,j,g,x,v); \\n        t(i-1,j,g,x,v);\\n        t(i,j+1,g,x,v);\\n        t(i,j-1,g,x,v);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int r, int c, int col) {\\n       int m=g.size(),n=g[0].size();\\n       vector<vector<int>> v(m,vector<int> (n,0));\\n       t(r,c,g,g[r][c],v);\\n\\n       for(int i=0;i<g.size();i++)\\n       for(int j=0;j<g[0].size();j++)\\n       {\\n           if(p[{i,j}]>0)\\n           {\\n               if((i-1>=0&&p[{i-1,j}]==0) || (i+1<=g.size()&&p[{i+1,j}]==0) || (j-1>=0&&p[{i,j-1}]==0) || (j+1<=g[0].size()&&p[{i,j+1}]==0))\\n               g[i][j]=col;\\n               \\n               if(i==g.size()-1 || j==g[0].size()-1 || i==0 || j==0)\\n               g[i][j]=col;\\n           }\\n       }\\n       return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031252,
                "title": "bfs-short-precise-easy-to-understand-beats-99-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n# BFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dr[4]={1,0,-1,0};\\n    int dc[4]={0,1,0,-1};\\n\\n    bool isvalid(int i ,int j,int m,int n,vector<vector<int>>& grid,int b){\\n        return (i >= 0 && j >= 0 && i < m && j < n && grid[i][j]==b);\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int t = grid[row][col];\\n\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> visited(m,vector<int> (n,0));\\n        vector<vector<int>> newgrid;\\n\\n        newgrid=grid;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int nr = r+dr[k];\\n                int nc = c+dc[k];\\n                if(isvalid(nr,nc,m,n,grid,t)){\\n                    if(nr >= 0 && nc >= 0 && nr < m && nc < n && !visited[nr][nc]){\\n                        visited[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }else{\\n                    newgrid[r][c]=color;\\n                }\\n            }\\n        }\\n\\n        return newgrid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dr[4]={1,0,-1,0};\\n    int dc[4]={0,1,0,-1};\\n\\n    bool isvalid(int i ,int j,int m,int n,vector<vector<int>>& grid,int b){\\n        return (i >= 0 && j >= 0 && i < m && j < n && grid[i][j]==b);\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int t = grid[row][col];\\n\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> visited(m,vector<int> (n,0));\\n        vector<vector<int>> newgrid;\\n\\n        newgrid=grid;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int nr = r+dr[k];\\n                int nc = c+dc[k];\\n                if(isvalid(nr,nc,m,n,grid,t)){\\n                    if(nr >= 0 && nc >= 0 && nr < m && nc < n && !visited[nr][nc]){\\n                        visited[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }else{\\n                    newgrid[r][c]=color;\\n                }\\n            }\\n        }\\n\\n        return newgrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982702,
                "title": "color-border-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971945,
                "title": "dfs-solution-tle-resolved",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int curColor,vector<vector<bool>>& visited)\\n    {\\n        if(i<0 or i==grid.size() or j<0 or j==grid[0].size() or grid[i][j]!=curColor or visited[i][j])\\n            return;\\n        \\n        visited[i][j]=true;\\n        grid[i][j]= -curColor;\\n        dfs(grid,i+1,j,curColor,visited);\\n        dfs(grid,i-1,j,curColor,visited);\\n        dfs(grid,i,j-1,curColor,visited);\\n        dfs(grid,i,j+1,curColor,visited);\\n        if(i>0 and i<grid.size()-1 and j>0 and j<grid[0].size()-1 and abs(grid[i+1][j])==curColor and abs(grid[i-1][j])==curColor and abs(grid[i][j-1])==curColor and abs(grid[i][j+1])==curColor)\\n            grid[i][j]=curColor;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        dfs(grid,row,col,grid[row][col],visited);\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]<0)\\n                    grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int curColor,vector<vector<bool>>& visited)\\n    {\\n        if(i<0 or i==grid.size() or j<0 or j==grid[0].size() or grid[i][j]!=curColor or visited[i][j])\\n            return;\\n        \\n        visited[i][j]=true;\\n        grid[i][j]= -curColor;\\n        dfs(grid,i+1,j,curColor,visited);\\n        dfs(grid,i-1,j,curColor,visited);\\n        dfs(grid,i,j-1,curColor,visited);\\n        dfs(grid,i,j+1,curColor,visited);\\n        if(i>0 and i<grid.size()-1 and j>0 and j<grid[0].size()-1 and abs(grid[i+1][j])==curColor and abs(grid[i-1][j])==curColor and abs(grid[i][j-1])==curColor and abs(grid[i][j+1])==curColor)\\n            grid[i][j]=curColor;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        dfs(grid,row,col,grid[row][col],visited);\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]<0)\\n                    grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956361,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        vector<vector<int>>ans=grid;\\n        int cl=grid[row][col];\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        while(q.size()){\\n            int ro=q.front().first;\\n            int co=q.front().second;\\n            q.pop();\\n            vis[ro][co]=1;\\n            int r[4]={-1,0,0,1};\\n            int c[4]={0,-1,1,0};\\n            int count=0;\\n            for(int k=0;k<4;k++){\\n                int nr=ro+r[k],nc=co+c[k];\\n                if(nr>=0&&nr<m&&nc>=0&&nc<n&&grid[nr][nc]==cl){\\n                    if(vis[nr][nc]==0)q.push({nr,nc});\\n                    count++;\\n                }\\n            }\\n            if(count<4){\\n                ans[ro][co]=color;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        vector<vector<int>>ans=grid;\\n        int cl=grid[row][col];\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        while(q.size()){\\n            int ro=q.front().first;\\n            int co=q.front().second;\\n            q.pop();\\n            vis[ro][co]=1;\\n            int r[4]={-1,0,0,1};\\n            int c[4]={0,-1,1,0};\\n            int count=0;\\n            for(int k=0;k<4;k++){\\n                int nr=ro+r[k],nc=co+c[k];\\n                if(nr>=0&&nr<m&&nc>=0&&nc<n&&grid[nr][nc]==cl){\\n                    if(vis[nr][nc]==0)q.push({nr,nc});\\n                    count++;\\n                }\\n            }\\n            if(count<4){\\n                ans[ro][co]=color;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949906,
                "title": "basic-solution-explained-in-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// we are supposewd to colour the boarder of the given compomet of the graph\\n// boared cells -> boarder cells are the cells who are not surrounded by the same color cells ( 4 way movement allowed , no diagonal movement allowed )\\n// so we just need to perform dfs on the given row and col \\n// and check if a cell is surronded by all four sides or not ( by the same color cell )\\n// if yes -> update the cell with the new color, else go to next dfs call\\n// there will be one issue when checking for the surrounding color, it\\'ll be because we are updatin the color with the new color so if we go to a new cell and see around it, even if earlier there was the source color to the left/right/up/down of it, we will see the new color and will end up making the wrong judgement, so to avoid this, we will make a copy of the given grid and look for surrounging in the copy vector not in the initailly given grid vector because we are constantly making changes in the grid vector \\n\\n    void dfs(int row, int col, vector<vector<int>>& vis, vector<vector<int>>& grid, int gRow, int gCol, int color, int src, vector<vector<int>>& copy ){\\n        \\n        vis[row][col] = 1; // marking as visited\\n\\n        int surr = 0; // this var will count how many sides our current cell is surrounded by the cell of source color\\n\\n        // checking the surrounding\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row+1][col+0] == src ) surr += 1;\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row-1][col+0] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && copy[row+0][col+1] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && copy[row+0][col-1] == src ) surr += 1;\\n\\n        if( surr != 4 ) grid[row][col] = color; // if .. ( you can see )\\n        \\n        // making the next dfs call\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row+1][col+0] == 0 && grid[row+1][col+0] == src ) dfs(row+1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row-1][col+0] == 0 && grid[row-1][col+0] == src ) dfs(row-1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && vis[row+0][col+1] == 0 && grid[row+0][col+1] == src ) dfs(row+0 , col+1, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && vis[row+0][col-1] == 0 && grid[row+0][col-1] == src ) dfs(row+0 , col-1, vis, grid, gRow, gCol, color, src,copy);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int gRow = grid.size();\\n        int gCol = grid[0].size();\\n\\n        vector<vector<int>> vis(gRow, vector<int> (gCol,0)); // visited array\\n        int src = grid[row][col]; // source color\\n\\n        vector<vector<int>> copy; // copy vector\\n        for( int i = 0; i<gRow; i++ ){\\n            vector<int> temp = grid[i];\\n            copy.push_back(temp);\\n        }\\n\\n        dfs(row, col, vis, grid, gRow, gCol, color, src,copy); // calling the dfs function\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// we are supposewd to colour the boarder of the given compomet of the graph\\n// boared cells -> boarder cells are the cells who are not surrounded by the same color cells ( 4 way movement allowed , no diagonal movement allowed )\\n// so we just need to perform dfs on the given row and col \\n// and check if a cell is surronded by all four sides or not ( by the same color cell )\\n// if yes -> update the cell with the new color, else go to next dfs call\\n// there will be one issue when checking for the surrounding color, it\\'ll be because we are updatin the color with the new color so if we go to a new cell and see around it, even if earlier there was the source color to the left/right/up/down of it, we will see the new color and will end up making the wrong judgement, so to avoid this, we will make a copy of the given grid and look for surrounging in the copy vector not in the initailly given grid vector because we are constantly making changes in the grid vector \\n\\n    void dfs(int row, int col, vector<vector<int>>& vis, vector<vector<int>>& grid, int gRow, int gCol, int color, int src, vector<vector<int>>& copy ){\\n        \\n        vis[row][col] = 1; // marking as visited\\n\\n        int surr = 0; // this var will count how many sides our current cell is surrounded by the cell of source color\\n\\n        // checking the surrounding\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row+1][col+0] == src ) surr += 1;\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row-1][col+0] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && copy[row+0][col+1] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && copy[row+0][col-1] == src ) surr += 1;\\n\\n        if( surr != 4 ) grid[row][col] = color; // if .. ( you can see )\\n        \\n        // making the next dfs call\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row+1][col+0] == 0 && grid[row+1][col+0] == src ) dfs(row+1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row-1][col+0] == 0 && grid[row-1][col+0] == src ) dfs(row-1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && vis[row+0][col+1] == 0 && grid[row+0][col+1] == src ) dfs(row+0 , col+1, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && vis[row+0][col-1] == 0 && grid[row+0][col-1] == src ) dfs(row+0 , col-1, vis, grid, gRow, gCol, color, src,copy);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int gRow = grid.size();\\n        int gCol = grid[0].size();\\n\\n        vector<vector<int>> vis(gRow, vector<int> (gCol,0)); // visited array\\n        int src = grid[row][col]; // source color\\n\\n        vector<vector<int>> copy; // copy vector\\n        for( int i = 0; i<gRow; i++ ){\\n            vector<int> temp = grid[i];\\n            copy.push_back(temp);\\n        }\\n\\n        dfs(row, col, vis, grid, gRow, gCol, color, src,copy); // calling the dfs function\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948118,
                "title": "python-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        queue = [(row, col)]\\n        border = []\\n        seen = set()\\n        \\n        while queue:\\n            nq = []\\n            for r, c in queue:\\n                if (r,c) not in seen:\\n                    seen.add((r,c))\\n                    num = 0\\n                    for i, j in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\\n                        if 0 <= i < m and 0 <= j < n and grid[i][j] == grid[row][col]:\\n                            nq.append((i,j))\\n                            num += 1\\n                    if num != 4: border.append((r,c))\\n            queue = nq\\n        \\n        for r, c in border: grid[r][c] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        queue = [(row, col)]\\n        border = []\\n        seen = set()\\n        \\n        while queue:\\n            nq = []\\n            for r, c in queue:\\n                if (r,c) not in seen:\\n                    seen.add((r,c))\\n                    num = 0\\n                    for i, j in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\\n                        if 0 <= i < m and 0 <= j < n and grid[i][j] == grid[row][col]:\\n                            nq.append((i,j))\\n                            num += 1\\n                    if num != 4: border.append((r,c))\\n            queue = nq\\n        \\n        for r, c in border: grid[r][c] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935835,
                "title": "simplified-solution-with-detailed-institution-99-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem description is bit vague in the sense that understanding of border connected components is not very clear.\\nConected components we will all know however a connected components will be fall in the definition of boarder connected components if it has any of the following features:\\n1. Its(grid) belongs to first or last row or grid belongs to first or last columns.\\n2. Its connected components has different color.\\n\\nThen Use the same Traversing approach as that of Flood Fill Algorithm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n){for calling DFS stack function this number of times} + O(m * n * 4){for Traversing in all 4 direction of a particular grid}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n) for storing Visited vector  + O(m * n) {for stack memory of DFS call}\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int row, int col, int startCol, int newColor, int m, int n)\\n    {\\n        //bool border = false;\\n        vis[row][col] = 1;\\n        if(row==0 || row==m-1 || col==0 ||col==n-1)\\n            grid[row][col] = newColor;\\n\\n        int rowArr[] = {0, -1, 0, 1};\\n        int colArr[] = {-1, 0, 1, 0};\\n\\n        for(int i = 0; i<4; i++)\\n        {\\n            int nRow = row + rowArr[i];\\n            int nCol = col + colArr[i];\\n\\n            if(nRow>=0 && nRow<m && nCol>=0 && nCol<n )\\n            {\\n                if(!vis[nRow][nCol])\\n                {\\n                    if(grid[nRow][nCol]==startCol)\\n                        dfs(grid, vis, nRow, nCol, startCol, newColor, m, n);\\n                    else\\n                        grid[row][col] = newColor;\\n                }\\n                \\n            }\\n            else\\n                grid[row][col] = newColor;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int>(n,0));\\n        dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        // for(int i = row; i<m ;i++)\\n        // {\\n        //     for(int j = col;j<n; j++)\\n        //     {\\n        //         if(!vis)\\n        //         dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        //     }\\n        // }\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int row, int col, int startCol, int newColor, int m, int n)\\n    {\\n        //bool border = false;\\n        vis[row][col] = 1;\\n        if(row==0 || row==m-1 || col==0 ||col==n-1)\\n            grid[row][col] = newColor;\\n\\n        int rowArr[] = {0, -1, 0, 1};\\n        int colArr[] = {-1, 0, 1, 0};\\n\\n        for(int i = 0; i<4; i++)\\n        {\\n            int nRow = row + rowArr[i];\\n            int nCol = col + colArr[i];\\n\\n            if(nRow>=0 && nRow<m && nCol>=0 && nCol<n )\\n            {\\n                if(!vis[nRow][nCol])\\n                {\\n                    if(grid[nRow][nCol]==startCol)\\n                        dfs(grid, vis, nRow, nCol, startCol, newColor, m, n);\\n                    else\\n                        grid[row][col] = newColor;\\n                }\\n                \\n            }\\n            else\\n                grid[row][col] = newColor;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int>(n,0));\\n        dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        // for(int i = row; i<m ;i++)\\n        // {\\n        //     for(int j = col;j<n; j++)\\n        //     {\\n        //         if(!vis)\\n        //         dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        //     }\\n        // }\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916013,
                "title": "easy-python-solution-by-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n    #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n    #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n    #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type row: int\\n        :type col: int\\n        :type color: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n        #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n        #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n        #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n        m,n = len(grid),len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        target = grid[row][col]\\n        lst = []\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] == target:\\n                    #\\u4E0A\\u65B9\\u65E0\\n                    flag = False\\n                    if i-1<0 or grid[i-1][j] != target:\\n                        flag = True\\n                    if i+1>m-1 or grid[i+1][j] != target:\\n                        flag = True\\n                    if j-1<0 or grid[i][j-1] != target:\\n                        flag = True\\n                    if j+1>n-1 or grid[i][j+1] != target:\\n                        flag = True\\n                    if flag:\\n                        lst.append((i,j))\\n\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n\\n        dfs(row,col)\\n        for i,j in lst:\\n            grid[i][j] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type row: int\\n        :type col: int\\n        :type color: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n        #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n        #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n        #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n        m,n = len(grid),len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        target = grid[row][col]\\n        lst = []\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] == target:\\n                    #\\u4E0A\\u65B9\\u65E0\\n                    flag = False\\n                    if i-1<0 or grid[i-1][j] != target:\\n                        flag = True\\n                    if i+1>m-1 or grid[i+1][j] != target:\\n                        flag = True\\n                    if j-1<0 or grid[i][j-1] != target:\\n                        flag = True\\n                    if j+1>n-1 or grid[i][j+1] != target:\\n                        flag = True\\n                    if flag:\\n                        lst.append((i,j))\\n\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n\\n        dfs(row,col)\\n        for i,j in lst:\\n            grid[i][j] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811935,
                "title": "c-solution-dfs",
                "content": "# Intuition\\nDFS to find the adjecnt elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    int[][] dir = new int[][] {new int[]{0,1}, new int[]{0,-1}, new int[]{1, 0}, new int[]{-1, 0}};\\n    int m;\\n    int n;\\n    int toColo;\\n    int[][] visited;\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.Length;\\n        n = grid[0].Length;\\n        visited = new int[m][];\\n        toColo = color;\\n\\n        for(var r=0; r<m; ++r){\\n            visited[r] = new int[n];\\n            for(var c=0; c<n; ++c){\\n                visited[r][c] = -1;\\n            }\\n        }\\n        \\n        DFS(row, col, grid[row][col], grid);\\n\\n        for(int i=0; i<m; i++)\\n        for(int j=0; j<n; j++){\\n            if(visited[i][j]==-1){\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return visited;\\n    }\\n\\n    public void DFS(int row, int col, int color, int[][] grid){\\n        if(visited[row][col]!=-1) return;\\n\\n        visited[row][col] = color;\\n\\n        if(row==0 || row==m-1 || col==0 || col==n-1){\\n            visited[row][col] = toColo;\\n        }\\n\\n        foreach(var coor in dir){\\n            int nx = row + coor[0];\\n            int ny = col + coor[1];\\n\\n            if(nx>=0 && nx<m && ny>=0 && ny<n){\\n                if(grid[nx][ny]==color){\\n                    DFS(nx, ny, color, grid);\\n                }\\n                else if(grid[row][col]!=toColo){\\n                    visited[row][col] = toColo;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[][] dir = new int[][] {new int[]{0,1}, new int[]{0,-1}, new int[]{1, 0}, new int[]{-1, 0}};\\n    int m;\\n    int n;\\n    int toColo;\\n    int[][] visited;\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.Length;\\n        n = grid[0].Length;\\n        visited = new int[m][];\\n        toColo = color;\\n\\n        for(var r=0; r<m; ++r){\\n            visited[r] = new int[n];\\n            for(var c=0; c<n; ++c){\\n                visited[r][c] = -1;\\n            }\\n        }\\n        \\n        DFS(row, col, grid[row][col], grid);\\n\\n        for(int i=0; i<m; i++)\\n        for(int j=0; j<n; j++){\\n            if(visited[i][j]==-1){\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return visited;\\n    }\\n\\n    public void DFS(int row, int col, int color, int[][] grid){\\n        if(visited[row][col]!=-1) return;\\n\\n        visited[row][col] = color;\\n\\n        if(row==0 || row==m-1 || col==0 || col==n-1){\\n            visited[row][col] = toColo;\\n        }\\n\\n        foreach(var coor in dir){\\n            int nx = row + coor[0];\\n            int ny = col + coor[1];\\n\\n            if(nx>=0 && nx<m && ny>=0 && ny<n){\\n                if(grid[nx][ny]==color){\\n                    DFS(nx, ny, color, grid);\\n                }\\n                else if(grid[row][col]!=toColo){\\n                    visited[row][col] = toColo;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779395,
                "title": "c-dfs-solution",
                "content": "# intution\\nfind the neighbours of every cell, if valid neighbour count is 4 , then its not border \\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,vector<pair<int,int>>&borders,vector<vector<int>>&visited,int row,int col,int n,int m)\\n    {\\n\\n        int flag =0;\\n        if(row ==0 or col ==0 or row==n-1 or col==m-1)flag =1;\\n\\n        int count =0;\\n        visited[row][col]=1;\\n        int del_row[] = {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ne_row = row+del_row[i];\\n            int ne_col = col+del_col[i];\\n            if(ne_row<n && ne_col <m && ne_row>=0 && ne_col >=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n\\n\\n                dfs(grid,borders,visited,ne_row,ne_col,n,m);\\n            }\\n            if(ne_row<n && ne_col<m && ne_row>=0 && ne_col >=0 && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n                count++;\\n            }\\n\\n        }\\n        \\n        if(flag ==1 or count<4)\\n        {\\n            borders.push_back({row,col});\\n        }\\n\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m = grid[0].size();\\n        vector<pair<int,int>>borders;\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        dfs(grid,borders,visited,row,col,n,m);\\n        for(int i=0;i<borders.size();i++)\\n        {\\n            grid[borders[i].first][borders[i].second]=color;\\n        }\\n        return grid;\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,vector<pair<int,int>>&borders,vector<vector<int>>&visited,int row,int col,int n,int m)\\n    {\\n\\n        int flag =0;\\n        if(row ==0 or col ==0 or row==n-1 or col==m-1)flag =1;\\n\\n        int count =0;\\n        visited[row][col]=1;\\n        int del_row[] = {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ne_row = row+del_row[i];\\n            int ne_col = col+del_col[i];\\n            if(ne_row<n && ne_col <m && ne_row>=0 && ne_col >=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n\\n\\n                dfs(grid,borders,visited,ne_row,ne_col,n,m);\\n            }\\n            if(ne_row<n && ne_col<m && ne_row>=0 && ne_col >=0 && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n                count++;\\n            }\\n\\n        }\\n        \\n        if(flag ==1 or count<4)\\n        {\\n            borders.push_back({row,col});\\n        }\\n\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m = grid[0].size();\\n        vector<pair<int,int>>borders;\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        dfs(grid,borders,visited,row,col,n,m);\\n        for(int i=0;i<borders.size();i++)\\n        {\\n            grid[borders[i].first][borders[i].second]=color;\\n        }\\n        return grid;\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764382,
                "title": "clean-and-easy-c-bfs-solution-beats-40-of-users",
                "content": "# Intuition\\nApply BFS Algorithm in the grid and check whether the front element in the queue is a border square or not ,if yes color it with the given color.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,1,-1};\\n\\n    bool is_valid(vector<vector<int>> &grid,int r,int c){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool is_border(vector<vector<int>> grid,int r,int c){\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int og=grid[r][c];\\n        if(r==0 || r==rows-1 || c==0 || c==cols-1){\\n            return true;\\n        }\\n\\n        if(grid[r+1][c]!=og || grid[r-1][c]!=og || grid[r][c-1]!=og || grid[r][c+1]!=og){\\n            return true;\\n        }\\n        return false;\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<vector<int>> ans=grid;\\n        vector<vector<int>> visited(rows,vector<int>(cols,-1));\\n        visited[row][col]=1;\\n        int og=grid[row][col];\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                auto fro=q.front();\\n                q.pop();\\n                int r=fro.first;\\n                int c=fro.second;\\n\\n                if(is_border(grid,r,c)){\\n                    ans[r][c]=color;\\n                }\\n\\n                for(int j=0;j<4;j++){\\n                    int nr=r+dx[j];\\n                    int nc=c+dy[j];\\n\\nif(is_valid(grid,nr,nc) && visited[nr][nc]==-1 && grid[nr][nc]==og){\\n                visited[nr][nc]=1;\\n                q.push({nr,nc});\\n                }\\n\\n                }\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,1,-1};\\n\\n    bool is_valid(vector<vector<int>> &grid,int r,int c){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool is_border(vector<vector<int>> grid,int r,int c){\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int og=grid[r][c];\\n        if(r==0 || r==rows-1 || c==0 || c==cols-1){\\n            return true;\\n        }\\n\\n        if(grid[r+1][c]!=og || grid[r-1][c]!=og || grid[r][c-1]!=og || grid[r][c+1]!=og){\\n            return true;\\n        }\\n        return false;\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<vector<int>> ans=grid;\\n        vector<vector<int>> visited(rows,vector<int>(cols,-1));\\n        visited[row][col]=1;\\n        int og=grid[row][col];\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                auto fro=q.front();\\n                q.pop();\\n                int r=fro.first;\\n                int c=fro.second;\\n\\n                if(is_border(grid,r,c)){\\n                    ans[r][c]=color;\\n                }\\n\\n                for(int j=0;j<4;j++){\\n                    int nr=r+dx[j];\\n                    int nc=c+dy[j];\\n\\nif(is_valid(grid,nr,nc) && visited[nr][nc]==-1 && grid[nr][nc]==og){\\n                visited[nr][nc]=1;\\n                q.push({nr,nc});\\n                }\\n\\n                }\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755304,
                "title": "some-modifications-in-standard-dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int r, int c, vector<vector<bool>> &vis, vector<vector<int>> &g, vector<vector<int>> &ans, int &OR_COL, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n        vis[r][c]=1;\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};\\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0){\\n                if((R==0||C==m-1||R==n-1||C==0) && g[R][C]==OR_COL){\\n                    ans[R][C]=newColor;\\n                }\\n\\n                if(!vis[R][C] && g[R][C]==OR_COL) {\\n                    dfs(R,C,vis,g,ans,OR_COL,newColor);\\n                }\\n            }\\n        }\\n    }    \\n\\n    void colorRemaining(int r, int c, vector<vector<bool>> &vis, vector<vector<int>>& g, vector<vector<int>>& ans, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};        \\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0 && vis[R][C]){\\n                ans[R][C]=newColor;\\n            }            \\n        }        \\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int row, int col, int color) {\\n        int n=g.size(), m=g[0].size();\\n        int originalColor = g[row][col];\\n        vector<vector<int>> ans = g;\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n\\n        dfs(row,col,vis,g,ans,originalColor,color);\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]) colorRemaining(i,j,vis,g,ans,color);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int r, int c, vector<vector<bool>> &vis, vector<vector<int>> &g, vector<vector<int>> &ans, int &OR_COL, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n        vis[r][c]=1;\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};\\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0){\\n                if((R==0||C==m-1||R==n-1||C==0) && g[R][C]==OR_COL){\\n                    ans[R][C]=newColor;\\n                }\\n\\n                if(!vis[R][C] && g[R][C]==OR_COL) {\\n                    dfs(R,C,vis,g,ans,OR_COL,newColor);\\n                }\\n            }\\n        }\\n    }    \\n\\n    void colorRemaining(int r, int c, vector<vector<bool>> &vis, vector<vector<int>>& g, vector<vector<int>>& ans, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};        \\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0 && vis[R][C]){\\n                ans[R][C]=newColor;\\n            }            \\n        }        \\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int row, int col, int color) {\\n        int n=g.size(), m=g[0].size();\\n        int originalColor = g[row][col];\\n        vector<vector<int>> ans = g;\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n\\n        dfs(row,col,vis,g,ans,originalColor,color);\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]) colorRemaining(i,j,vis,g,ans,color);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754912,
                "title": "c-dfs-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int r, int c,int ol,int nc,vector<vector<int>>& grid,vector<vector<int>>& ans,vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        int drow[4]={0,1,0,-1};\\n        int dcol[4]={1,0,-1,0};\\n        int cnt=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            int newr = r+drow[i];\\n            int newc = c+dcol[i];\\n            if(newr>=0 and newr<grid.size() and newc>=0 and newc<grid[0].size() and grid[newr][newc]==ol)\\n            {\\n                cnt++;\\n                if(vis[newr][newc]==0)\\n                dfs(newr,newc,ol,nc,grid,ans,vis);\\n            } \\n        }\\n        if(cnt<4)\\n        ans[r][c]=nc;\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<int>> ans = grid;\\n        int p=grid[row][col];\\n        vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n        //if(p==color)return ans;\\n        dfs(row,col,p,color,grid,ans,vis);\\n        int n=grid.size();int m=grid[0].size();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int r, int c,int ol,int nc,vector<vector<int>>& grid,vector<vector<int>>& ans,vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        int drow[4]={0,1,0,-1};\\n        int dcol[4]={1,0,-1,0};\\n        int cnt=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            int newr = r+drow[i];\\n            int newc = c+dcol[i];\\n            if(newr>=0 and newr<grid.size() and newc>=0 and newc<grid[0].size() and grid[newr][newc]==ol)\\n            {\\n                cnt++;\\n                if(vis[newr][newc]==0)\\n                dfs(newr,newc,ol,nc,grid,ans,vis);\\n            } \\n        }\\n        if(cnt<4)\\n        ans[r][c]=nc;\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<int>> ans = grid;\\n        int p=grid[row][col];\\n        vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n        //if(p==color)return ans;\\n        dfs(row,col,p,color,grid,ans,vis);\\n        int n=grid.size();int m=grid[0].size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752956,
                "title": "ruby-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[][]} grid\\n# @param {Integer} row\\n# @param {Integer} col\\n# @param {Integer} color\\n# @return {Integer[][]}\\ndef color_border(grid, row, col, color)\\n   @main_color = grid[row][col]\\n   @output = Array.new(grid.size){Array.new(grid[0].size)}\\n   for i in 0..grid.size - 1\\n        for j in 0..grid[0].size - 1\\n            @output[i][j] = grid[i][j]\\n        end\\n    end\\n   visited = Array.new(grid.size){Array.new(grid[0].size)}\\n   dfs([row, col], grid, visited, color)\\n   @output\\nend\\n\\n\\ndef neighbours(location, row_length, col_length)\\n    nb = []\\n    nb << [location[0]+1, location[1]] if location[0] + 1 < row_length\\n    nb << [location[0]-1, location[1]] if location[0] > 0\\n    nb << [location[0], location[1]+1] if location[1] + 1 < col_length\\n    nb << [location[0], location[1]-1] if location[1] > 0\\n    nb\\nend\\n\\ndef dfs(loc, grid, visited, color)\\n    visited[loc[0]][loc[1]] = true\\n    nbrs = neighbours(loc, grid.size, grid[0].size)\\n\\n    if (loc[0] == 0 || loc[0] == grid.size - 1) || (loc[1] == 0 || loc[1] == grid[0].size - 1)\\n        @output[loc[0]][loc[1]] = color\\n    else\\n        for nb in nbrs\\n            if @main_color != grid[nb[0]][nb[1]]            \\n                @output[loc[0]][loc[1]] = color\\n                break\\n            end\\n        end\\n    end\\n\\n    for nb in nbrs\\n        if @main_color == grid[nb[0]][nb[1]] && !visited[nb[0]][nb[1]]\\n            dfs([nb[0],nb[1]], grid, visited, color)\\n        end\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @param {Integer} row\\n# @param {Integer} col\\n# @param {Integer} color\\n# @return {Integer[][]}\\ndef color_border(grid, row, col, color)\\n   @main_color = grid[row][col]\\n   @output = Array.new(grid.size){Array.new(grid[0].size)}\\n   for i in 0..grid.size - 1\\n        for j in 0..grid[0].size - 1\\n            @output[i][j] = grid[i][j]\\n        end\\n    end\\n   visited = Array.new(grid.size){Array.new(grid[0].size)}\\n   dfs([row, col], grid, visited, color)\\n   @output\\nend\\n\\n\\ndef neighbours(location, row_length, col_length)\\n    nb = []\\n    nb << [location[0]+1, location[1]] if location[0] + 1 < row_length\\n    nb << [location[0]-1, location[1]] if location[0] > 0\\n    nb << [location[0], location[1]+1] if location[1] + 1 < col_length\\n    nb << [location[0], location[1]-1] if location[1] > 0\\n    nb\\nend\\n\\ndef dfs(loc, grid, visited, color)\\n    visited[loc[0]][loc[1]] = true\\n    nbrs = neighbours(loc, grid.size, grid[0].size)\\n\\n    if (loc[0] == 0 || loc[0] == grid.size - 1) || (loc[1] == 0 || loc[1] == grid[0].size - 1)\\n        @output[loc[0]][loc[1]] = color\\n    else\\n        for nb in nbrs\\n            if @main_color != grid[nb[0]][nb[1]]            \\n                @output[loc[0]][loc[1]] = color\\n                break\\n            end\\n        end\\n    end\\n\\n    for nb in nbrs\\n        if @main_color == grid[nb[0]][nb[1]] && !visited[nb[0]][nb[1]]\\n            dfs([nb[0],nb[1]], grid, visited, color)\\n        end\\n    end\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3729607,
                "title": "c-dfs-easy",
                "content": "simple dfs , just check for border and the given condition\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(int row , int col , int color , vector<vector<int>>& vis , vector<vector<int>>& grid , int ogcolor){\\n       int n = grid.size();\\n       int m = grid[0].size();\\n\\n       vis[row][col] = 1;\\n\\n       int delrow[] = {1,0,-1,0};\\n       int delcol[] = {0,-1,0,1};\\n\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow < 0 || ncol < 0 || nrow >= n || ncol >= m || (grid[nrow][ncol] != ogcolor and !vis[nrow][ncol])){\\n                grid[row][col] = color;\\n           } \\n       }\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow >= 0 and ncol >= 0 and nrow < n and ncol < m and grid[nrow][ncol] == ogcolor and !vis[nrow][ncol]){\\n               vis[nrow][ncol] = 1;\\n                dfs(nrow,ncol,color,vis,grid,ogcolor);\\n           } \\n       }\\n   }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        dfs(row,col,color,vis,grid,grid[row][col]);\\n        return grid;\\n    }\\n};\\n/*\\n1 2 1 2 1 2\\n2 2 2 2 1 2\\n1 2 2 2 1 2\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(int row , int col , int color , vector<vector<int>>& vis , vector<vector<int>>& grid , int ogcolor){\\n       int n = grid.size();\\n       int m = grid[0].size();\\n\\n       vis[row][col] = 1;\\n\\n       int delrow[] = {1,0,-1,0};\\n       int delcol[] = {0,-1,0,1};\\n\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow < 0 || ncol < 0 || nrow >= n || ncol >= m || (grid[nrow][ncol] != ogcolor and !vis[nrow][ncol])){\\n                grid[row][col] = color;\\n           } \\n       }\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow >= 0 and ncol >= 0 and nrow < n and ncol < m and grid[nrow][ncol] == ogcolor and !vis[nrow][ncol]){\\n               vis[nrow][ncol] = 1;\\n                dfs(nrow,ncol,color,vis,grid,ogcolor);\\n           } \\n       }\\n   }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        dfs(row,col,color,vis,grid,grid[row][col]);\\n        return grid;\\n    }\\n};\\n/*\\n1 2 1 2 1 2\\n2 2 2 2 1 2\\n1 2 2 2 1 2\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729232,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n        int iniCol = grid[row][col];\\n\\n        vector<int> dx = {0 , 1 , 0 , -1};\\n        vector<int> dy = {-1 , 0 , 1 , 0};\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vis[row][col] = 1;\\n\\n        while (!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            bool temp = false;\\n            if (r==m-1 || r==0 || c==n-1 || c==0)\\n                temp = true;\\n\\n            bool flag = false;\\n            for (int i=0 ; i<4 ; i++){\\n                int nr = r + dx[i];\\n                int nc = c + dy[i];\\n                if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc]){\\n                    if (grid[nr][nc]==iniCol){\\n                        vis[nr][nc] = 1;\\n                        q.push({nr,nc});\\n                    }\\n                    else{\\n                        flag = true;\\n                    }\\n                }\\n            }\\n            if (flag || temp)\\n                grid[r][c] = color;\\n        }\\n        return grid;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n        int iniCol = grid[row][col];\\n\\n        vector<int> dx = {0 , 1 , 0 , -1};\\n        vector<int> dy = {-1 , 0 , 1 , 0};\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vis[row][col] = 1;\\n\\n        while (!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            bool temp = false;\\n            if (r==m-1 || r==0 || c==n-1 || c==0)\\n                temp = true;\\n\\n            bool flag = false;\\n            for (int i=0 ; i<4 ; i++){\\n                int nr = r + dx[i];\\n                int nc = c + dy[i];\\n                if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc]){\\n                    if (grid[nr][nc]==iniCol){\\n                        vis[nr][nc] = 1;\\n                        q.push({nr,nc});\\n                    }\\n                    else{\\n                        flag = true;\\n                    }\\n                }\\n            }\\n            if (flag || temp)\\n                grid[r][c] = color;\\n        }\\n        return grid;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716069,
                "title": "c-very-simple-bfs-explained",
                "content": "# Intuition\\nThe goal is to color the border cells and cells adjacent to different colors with the target color. To achieve this, we can use Breadth-First Search (BFS) starting from the given cell.\\n\\n\\n# Approach\\nPush the starting cell coordinates into the queue, mark it as visited, and store its color as the original color.\\n\\nPerform BFS traversal:\\n\\nWhile the queue is not empty, do the following:\\nExtract the front element from the queue, representing the current cell coordinates.\\n\\nCheck if the current cell is on the border or adjacent to a different color:\\nInitialize the isBorder flag to check if the cell is on the border (first or last row/column).\\nInitialize the isAdjacentToDifferentColor flag to track if the cell is adjacent to a different color.\\n\\nIterate through the four directions:\\nCalculate the new row and column coordinates.\\nIf the new coordinates are within the grid boundaries and the cell is unvisited:\\n\\nCheck if the cell has the original color.\\nIf so, push it into the queue, mark it as visited, and continue the BFS traversal.\\n\\nOtherwise, set the isAdjacentToDifferentColor flag to true.\\nIf the current cell is on the border or adjacent to a different color, update its color to the target color.\\n\\nAfter the BFS traversal is complete, return the modified grid.\\n# Complexity\\n- Time complexity:\\n O(n * m)\\n- Space complexity:\\n O(n * m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        visited[row][col] = true;\\n\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            //checking if the row or coloumn are border or not, initially keeping it false.\\n            bool isb=false;\\n            if(r == 0 || r == m - 1 || c == 0 || c ==n - 1)\\n            isb =true;\\n            //initially we keep adj as false, this tells us whether the cell is adjacent to some cell which is not of the same color to any side, that is the outline of the connected component.\\n            bool isad = false;\\n\\n            for (int k = 0; k < 4; k++) {\\n                //iterating on all 4 directions\\n                int nr = r + delr[k];\\n                int nc = c + delc[k];\\n\\n                if (nr >= 0 && nc >= 0 && nr < m && nc < n) {\\n                    if (!visited[nr][nc]) {\\n                        //checking if the new cell is connected component or not, if yes, we take it into consideration for the next iteration and push in the queue.\\n                        if (grid[nr][nc] == originalColor) {\\n                            q.push({nr, nc});\\n                            visited[nr][nc] = true;\\n                        } else {\\n                            //if not connected then we have found one cell which is the outline of the connected component.\\n                            isad = true;\\n                        }\\n                    }\\n                }\\n            }\\n            //at last we are just coloring all the cells are which are either border cells or the outline of the connected component.\\n            if (isb || isad) {\\n                grid[r][c] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        visited[row][col] = true;\\n\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            //checking if the row or coloumn are border or not, initially keeping it false.\\n            bool isb=false;\\n            if(r == 0 || r == m - 1 || c == 0 || c ==n - 1)\\n            isb =true;\\n            //initially we keep adj as false, this tells us whether the cell is adjacent to some cell which is not of the same color to any side, that is the outline of the connected component.\\n            bool isad = false;\\n\\n            for (int k = 0; k < 4; k++) {\\n                //iterating on all 4 directions\\n                int nr = r + delr[k];\\n                int nc = c + delc[k];\\n\\n                if (nr >= 0 && nc >= 0 && nr < m && nc < n) {\\n                    if (!visited[nr][nc]) {\\n                        //checking if the new cell is connected component or not, if yes, we take it into consideration for the next iteration and push in the queue.\\n                        if (grid[nr][nc] == originalColor) {\\n                            q.push({nr, nc});\\n                            visited[nr][nc] = true;\\n                        } else {\\n                            //if not connected then we have found one cell which is the outline of the connected component.\\n                            isad = true;\\n                        }\\n                    }\\n                }\\n            }\\n            //at last we are just coloring all the cells are which are either border cells or the outline of the connected component.\\n            if (isb || isad) {\\n                grid[r][c] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673871,
                "title": "c-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool is_safe(int i,int j,int row,int col){\\n    if(i<0 ||j<0 || i>=row || j>=col)return false;\\n    return true;\\n}\\nint deli[4]={0,1,0,-1};\\nint delj[4]={1,0,-1,0};\\nvoid dfs(int i,int j,int row,int col,int curcol,int newcol,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& ggrid){\\n    int temp=0;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol)temp++;\\n    }\\n    if(temp!=4)ggrid[i][j]=newcol;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol && !vis[new_i][new_j]){\\n            vis[new_i][new_j]=1;\\n            dfs(new_i,new_j,row,col,curcol,newcol,grid,vis,ggrid);\\n        }\\n    }\\n    \\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int newcol) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int curcol=grid[i][j];\\n        if (curcol==newcol)return grid;\\n        vector<vector<int>>vis(row,vector<int>(col,0));\\n        vector<vector<int>>ggrid(row,vector<int>(col,0));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ggrid[i][j]=grid[i][j];\\n            }\\n        }\\n        vis[i][j]=1;\\n        dfs(i,j,row,col,curcol,newcol,grid,vis,ggrid);\\n        return ggrid;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool is_safe(int i,int j,int row,int col){\\n    if(i<0 ||j<0 || i>=row || j>=col)return false;\\n    return true;\\n}\\nint deli[4]={0,1,0,-1};\\nint delj[4]={1,0,-1,0};\\nvoid dfs(int i,int j,int row,int col,int curcol,int newcol,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& ggrid){\\n    int temp=0;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol)temp++;\\n    }\\n    if(temp!=4)ggrid[i][j]=newcol;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol && !vis[new_i][new_j]){\\n            vis[new_i][new_j]=1;\\n            dfs(new_i,new_j,row,col,curcol,newcol,grid,vis,ggrid);\\n        }\\n    }\\n    \\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int newcol) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int curcol=grid[i][j];\\n        if (curcol==newcol)return grid;\\n        vector<vector<int>>vis(row,vector<int>(col,0));\\n        vector<vector<int>>ggrid(row,vector<int>(col,0));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ggrid[i][j]=grid[i][j];\\n            }\\n        }\\n        vis[i][j]=1;\\n        dfs(i,j,row,col,curcol,newcol,grid,vis,ggrid);\\n        return ggrid;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655448,
                "title": "c-dfs-graph-easy-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nint row[4] = {1, -1, 0, 0};\\nint col[4] = {0, 0, 1, -1};\\n\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &target, int& color){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]!=target)\\n    return;\\n\\n    visited[i][j] = 1;\\n    bool flag = 0;\\n\\n    for(int p = 0 ;p<4 ;p++){\\n        int newX = i+row[p];\\n        int newY = j+col[p];\\n\\n        if(i==0 || i==grid.size()-1 || j==0 || j==grid[0].size()-1 || (visited[newX][newY] == 0 && grid[i][j]!=grid[newX][newY]) )\\n        flag = 1;\\n\\n        dfs(grid, visited, newX, newY, target, color);\\n    }\\n\\n    if(flag)\\n    grid[i][j] = color;  \\n}\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int target = grid[row][col];\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        dfs(grid, visited, row, col, target, color);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint row[4] = {1, -1, 0, 0};\\nint col[4] = {0, 0, 1, -1};\\n\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &target, int& color){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]!=target)\\n    return;\\n\\n    visited[i][j] = 1;\\n    bool flag = 0;\\n\\n    for(int p = 0 ;p<4 ;p++){\\n        int newX = i+row[p];\\n        int newY = j+col[p];\\n\\n        if(i==0 || i==grid.size()-1 || j==0 || j==grid[0].size()-1 || (visited[newX][newY] == 0 && grid[i][j]!=grid[newX][newY]) )\\n        flag = 1;\\n\\n        dfs(grid, visited, newX, newY, target, color);\\n    }\\n\\n    if(flag)\\n    grid[i][j] = color;  \\n}\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int target = grid[row][col];\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        dfs(grid, visited, row, col, target, color);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642008,
                "title": "2-bfs-traversal-in-a-single-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        //at first visit all the nodes which have the color = oldcolor and connected to current component \\n        queue<pair<int,int>>q;\\n        vector<pair<int,int>>v;\\n        q.push({row,col});\\n        int oldcolor = grid[row][col];\\n        int delrow[4] = {0,-1,0,+1};\\n        int delcol[4] = {+1,0,-1,0};\\n        vis[row][col] = 1;\\n        //after getting all the nodes of the current component please check which of those nodes lie in the circle \\n        while(q.empty() == false){\\n            int row = q.front().first ;\\n            int col = q.front().second;\\n            v.push_back(make_pair(row,col));\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                && !vis[nrow][ncol] && grid[nrow][ncol] == oldcolor){\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n        //now inside v i have got all the nodes which are connected to the current compnent \\n        //and all those nodes have the color oldcolor\\n\\n        //now i have to check all the nodes in the current component which are boundary nodes \\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vis[i][j] = 0;\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            q.push({v[i].first,v[i].second});\\n            cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n            vis[v[i].first][v[i].second] = 1;\\n        }\\n        cout<<v.size()<<endl;\\n        vector<vector<int>> arr = grid;\\n        while(q.empty() == false){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            if(row == 0 || col == 0 || row == n-1 || col == m-1){\\n                arr[row][col] = color;\\n                q.pop();\\n                continue;\\n            }\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(grid[nrow][ncol]!=oldcolor){\\n                        arr[row][col] = color;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        //at first visit all the nodes which have the color = oldcolor and connected to current component \\n        queue<pair<int,int>>q;\\n        vector<pair<int,int>>v;\\n        q.push({row,col});\\n        int oldcolor = grid[row][col];\\n        int delrow[4] = {0,-1,0,+1};\\n        int delcol[4] = {+1,0,-1,0};\\n        vis[row][col] = 1;\\n        //after getting all the nodes of the current component please check which of those nodes lie in the circle \\n        while(q.empty() == false){\\n            int row = q.front().first ;\\n            int col = q.front().second;\\n            v.push_back(make_pair(row,col));\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                && !vis[nrow][ncol] && grid[nrow][ncol] == oldcolor){\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n        //now inside v i have got all the nodes which are connected to the current compnent \\n        //and all those nodes have the color oldcolor\\n\\n        //now i have to check all the nodes in the current component which are boundary nodes \\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vis[i][j] = 0;\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            q.push({v[i].first,v[i].second});\\n            cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n            vis[v[i].first][v[i].second] = 1;\\n        }\\n        cout<<v.size()<<endl;\\n        vector<vector<int>> arr = grid;\\n        while(q.empty() == false){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            if(row == 0 || col == 0 || row == n-1 || col == m-1){\\n                arr[row][col] = color;\\n                q.pop();\\n                continue;\\n            }\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(grid[nrow][ncol]!=oldcolor){\\n                        arr[row][col] = color;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3569737,
                "title": "c-fast-dfs",
                "content": "\\nclass Solution  {\\n\\npublic:\\n\\n    void dfs(int row,int col,int clr,vector<vector<int>>& grid){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        int r[] = {-1,0,1,0};\\n        int c[] = {0,+1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int adjr = row + r[i];\\n            int adjc = col + c[i];\\n            if(adjr<0||adjr>=grid.size()||adjc<0 || adjc>=grid[0].size() || abs(grid[adjr][adjc]) != clr)\\n            {\\n                continue;\\n            }\\n            count++;\\n            if(grid[adjr][adjc] == clr)\\n                dfs(adjr,adjc,clr,grid);\\n        }\\n        if(count==4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        dfs(row,col,grid[row][col],grid);\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution  {\\n\\npublic:\\n\\n    void dfs(int row,int col,int clr,vector<vector<int>>& grid){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        int r[] = {-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3561284,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        M, N = len(grid), len(grid[0])\\n        q = collections.deque()\\n        q.append((row, col))\\n        dir_lst = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        seen = set()\\n        seen.add((row, col))\\n        border = set()\\n        while q:\\n            i, j = q.popleft()\\n            is_border = i in [0, M-1] or j in [0, N-1]\\n            for di, dj in dir_lst:\\n                ni, nj = i+di, j+dj\\n                if 0<=ni<M and 0<=nj<N and (ni, nj) not in seen:\\n                    if grid[ni][nj]!=grid[i][j]:\\n                        is_border = True\\n                    else:\\n                        seen.add((ni, nj))\\n                        q.append((ni, nj))\\n            if is_border:\\n                border.add((i, j))\\n        \\n        for i, j in border:\\n            grid[i][j] = color\\n        return grid\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[row][col]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid,row,col,grid[row][col],visited,color,n,m);\\n\\n        return grid;\\n    }\\n    void dfs(int[][] grid,int i,int j,int oldColor,boolean[][] visited,int targetColor,int n,int m) {\\n        if (i>=n || i<0 || j<0 || j>=m || grid[i][j]!=oldColor || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n\\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=oldColor || grid[i-1][j]!=oldColor || grid[i][j-1]!=oldColor || grid[i][j+1]!=oldColor)\\n            border = true;\\n        \\n        dfs(grid,i+1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i-1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j+1,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j-1,oldColor,visited,targetColor,n,m);\\n\\n        if (border)\\n            grid[i][j] = targetColor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        M, N = len(grid), len(grid[0])\\n        q = collections.deque()\\n        q.append((row, col))\\n        dir_lst = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        seen = set()\\n        seen.add((row, col))\\n        border = set()\\n        while q:\\n            i, j = q.popleft()\\n            is_border = i in [0, M-1] or j in [0, N-1]\\n            for di, dj in dir_lst:\\n                ni, nj = i+di, j+dj\\n                if 0<=ni<M and 0<=nj<N and (ni, nj) not in seen:\\n                    if grid[ni][nj]!=grid[i][j]:\\n                        is_border = True\\n                    else:\\n                        seen.add((ni, nj))\\n                        q.append((ni, nj))\\n            if is_border:\\n                border.add((i, j))\\n        \\n        for i, j in border:\\n            grid[i][j] = color\\n        return grid\\n```\n```Java []\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[row][col]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid,row,col,grid[row][col],visited,color,n,m);\\n\\n        return grid;\\n    }\\n    void dfs(int[][] grid,int i,int j,int oldColor,boolean[][] visited,int targetColor,int n,int m) {\\n        if (i>=n || i<0 || j<0 || j>=m || grid[i][j]!=oldColor || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n\\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=oldColor || grid[i-1][j]!=oldColor || grid[i][j-1]!=oldColor || grid[i][j+1]!=oldColor)\\n            border = true;\\n        \\n        dfs(grid,i+1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i-1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j+1,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j-1,oldColor,visited,targetColor,n,m);\\n\\n        if (border)\\n            grid[i][j] = targetColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513135,
                "title": "souvik-hazra-coloring-a-border",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        if (pre := grid[row][col]) == color:\\n            return grid\\n        m, n, d = len(grid), len(grid[0]), [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        visited = [[False] * n for _ in range(m)]\\n        \\n        def dfs(x: int, y: int) -> None:\\n            if not -1 < x < m or not -1 < y < n or grid[x][y] != pre:\\n                return\\n            grid[x][y], visited[x][y] = color, True\\n            for dx, dy in d:\\n                dfs(x + dx, y + dy)        \\n        dfs(row, col)\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                if visited[i][j] and all(visited[i + dx][j + dy] for dx, dy in d):\\n                    grid[i][j] = pre\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        if (pre := grid[row][col]) == color:\\n            return grid\\n        m, n, d = len(grid), len(grid[0]), [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        visited = [[False] * n for _ in range(m)]\\n        \\n        def dfs(x: int, y: int) -> None:\\n            if not -1 < x < m or not -1 < y < n or grid[x][y] != pre:\\n                return\\n            grid[x][y], visited[x][y] = color, True\\n            for dx, dy in d:\\n                dfs(x + dx, y + dy)        \\n        dfs(row, col)\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                if visited[i][j] and all(visited[i + dx][j + dy] for dx, dy in d):\\n                    grid[i][j] = pre\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501355,
                "title": "i-am-trying-with-no-extra-space-but-getting-wrong-answer-can-someone-help-me",
                "content": "\\nm, n is grid size\\nc is color that is to be coloured on the perimeter\\nc1 is color that need to replaced\\n\\nThis code is giving WA at 150/154 case.\\n```\\nclass Solution {\\npublic:\\n    int c,m,n,c1;\\n    void solve(vector<vector<int>> &grid, int row,int col){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]!=c1)return;\\n        grid[row][col] = -c1;\\n        bool tocolor = false;\\n\\n        if(row+1>=m || row-1<0 || col+1>=n || col-1<0){\\n            tocolor = true;\\n        }else if(abs(grid[row+1][col])!=c1 ||\\n                abs(grid[row-1][col])!=c1  ||\\n                abs(grid[row][col-1])!=c1  ||\\n                abs(grid[row][col+1])!=c1){\\n            tocolor=true;\\n        }\\n\\n        solve(grid,row+1,col);\\n        solve(grid,row,col-1);\\n        solve(grid,row-1,col);\\n        solve(grid,row,col+1);\\n\\n        if(tocolor)grid[row][col] = c;\\n        else grid[row][col]*=-1;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        c = color;\\n        c1=grid[row][col];\\n        m=grid.size(),n=grid[0].size();\\n        solve(grid,row,col);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c,m,n,c1;\\n    void solve(vector<vector<int>> &grid, int row,int col){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]!=c1)return;\\n        grid[row][col] = -c1;\\n        bool tocolor = false;\\n\\n        if(row+1>=m || row-1<0 || col+1>=n || col-1<0){\\n            tocolor = true;\\n        }else if(abs(grid[row+1][col])!=c1 ||\\n                abs(grid[row-1][col])!=c1  ||\\n                abs(grid[row][col-1])!=c1  ||\\n                abs(grid[row][col+1])!=c1){\\n            tocolor=true;\\n        }\\n\\n        solve(grid,row+1,col);\\n        solve(grid,row,col-1);\\n        solve(grid,row-1,col);\\n        solve(grid,row,col+1);\\n\\n        if(tocolor)grid[row][col] = c;\\n        else grid[row][col]*=-1;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        c = color;\\n        c1=grid[row][col];\\n        m=grid.size(),n=grid[0].size();\\n        solve(grid,row,col);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478110,
                "title": "coloring-a-border",
                "content": "------------------ Easy C++ Solution ------------------\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,int color) {\\n    dfs(grid, r0, c0, grid[r0][c0]);\\n\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if(grid[i][j] < 0)\\n          grid[i][j] = color;\\n\\n    return grid;\\n  }\\n\\n private:\\n  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {\\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\\n      return;\\n    if (grid[i][j] != startColor)\\n      return;\\n\\n    grid[i][j] = -startColor;\\n    dfs(grid, i + 1, j, startColor);\\n    dfs(grid, i - 1, j, startColor);\\n    dfs(grid, i, j + 1, startColor);\\n    dfs(grid, i, j - 1, startColor);\\n\\n    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)\\n      return;\\n\\n    if (abs(grid[i + 1][j]) == startColor &&  abs(grid[i - 1][j]) == startColor && abs(grid[i][j + 1]) == startColor &&   abs(grid[i][j - 1]) == startColor)\\n      grid[i][j] = startColor;\\n  }\\n};\\n// [\\n// [1,1],\\n// [1,2]\\n// ]\\n// [\\n// [3,3],\\n// [3,2]\\n// ]\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,int color) {\\n    dfs(grid, r0, c0, grid[r0][c0]);\\n\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if(grid[i][j] < 0)\\n          grid[i][j] = color;\\n\\n    return grid;\\n  }\\n\\n private:\\n  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {\\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\\n      return;\\n    if (grid[i][j] != startColor)\\n      return;\\n\\n    grid[i][j] = -startColor;\\n    dfs(grid, i + 1, j, startColor);\\n    dfs(grid, i - 1, j, startColor);\\n    dfs(grid, i, j + 1, startColor);\\n    dfs(grid, i, j - 1, startColor);\\n\\n    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)\\n      return;\\n\\n    if (abs(grid[i + 1][j]) == startColor &&  abs(grid[i - 1][j]) == startColor && abs(grid[i][j + 1]) == startColor &&   abs(grid[i][j - 1]) == startColor)\\n      grid[i][j] = startColor;\\n  }\\n};\\n// [\\n// [1,1],\\n// [1,2]\\n// ]\\n// [\\n// [3,3],\\n// [3,2]\\n// ]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399098,
                "title": "c-simple-to-understand",
                "content": "# Intuition\\nMark the island, calculate gradient in r,c direction. Any non 0 numbers means point r,c is on border\\n\\n# Approach\\nBFS to mark an island. Gradient dr = map[r] - map[r - 1], same for columns. Any non zero dr or dc means we are on border of found island.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n) - you can optimize it all a bit and use original grid and negative numbers to save on separate visited grid.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        static const vector<pair<int, int>> D = { {-1, 0}, {+1, 0}, {0, -1}, {0, +1} };\\n        const int testColor = grid[row][col];\\n\\n        const int R = grid.size();\\n        const int C = grid[0].size();\\n\\n        vector<vector<int>> visited(R, vector<int>(C, 0));\\n        queue<pair<int, int>> q;\\n        \\n        q.push( {row, col} );\\n        visited[row][col] = 1;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n\\n            for (auto d: D) {\\n                int nr = p.first + d.first;\\n                int nc = p.second + d.second;\\n\\n                if (nr < 0 || nr == R || nc < 0 || nc == C) {\\n                    continue;\\n                }\\n\\n                if (!visited[nr][nc] && grid[nr][nc] == testColor) {\\n                    q.push( {nr, nc} );\\n                    visited[nr][nc] = 1;\\n                }\\n            }\\n        }\\n\\n        for (int r = 0;r < R;r ++) {\\n            for (int c = 0;c < C;c ++) {\\n                if (visited[r][c] == 0) {\\n                    continue;\\n                }\\n\\n                int rm = r - 1;\\n                int rp = r + 1;\\n                int cm = c - 1;\\n                int cp = c + 1;\\n\\n                if (\\n                    (rm < 0 || visited[rm][c] == 0) || (rp == R || visited[rp][c] == 0) || \\n                    (cm < 0 || visited[r][cm] == 0) || (cp == C || visited[r][cp] == 0)\\n                   ) \\n                {\\n                    grid[r][c] = color;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        static const vector<pair<int, int>> D = { {-1, 0}, {+1, 0}, {0, -1}, {0, +1} };\\n        const int testColor = grid[row][col];\\n\\n        const int R = grid.size();\\n        const int C = grid[0].size();\\n\\n        vector<vector<int>> visited(R, vector<int>(C, 0));\\n        queue<pair<int, int>> q;\\n        \\n        q.push( {row, col} );\\n        visited[row][col] = 1;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n\\n            for (auto d: D) {\\n                int nr = p.first + d.first;\\n                int nc = p.second + d.second;\\n\\n                if (nr < 0 || nr == R || nc < 0 || nc == C) {\\n                    continue;\\n                }\\n\\n                if (!visited[nr][nc] && grid[nr][nc] == testColor) {\\n                    q.push( {nr, nc} );\\n                    visited[nr][nc] = 1;\\n                }\\n            }\\n        }\\n\\n        for (int r = 0;r < R;r ++) {\\n            for (int c = 0;c < C;c ++) {\\n                if (visited[r][c] == 0) {\\n                    continue;\\n                }\\n\\n                int rm = r - 1;\\n                int rp = r + 1;\\n                int cm = c - 1;\\n                int cp = c + 1;\\n\\n                if (\\n                    (rm < 0 || visited[rm][c] == 0) || (rp == R || visited[rp][c] == 0) || \\n                    (cm < 0 || visited[r][cm] == 0) || (cp == C || visited[r][cp] == 0)\\n                   ) \\n                {\\n                    grid[r][c] = color;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392758,
                "title": "2-traversal-solutions-iterative-and-recursive-python",
                "content": "```\\n\"\"\"\\nContinuing on Problem 733 Flood Fill.\\n\\nTreatment: Traversal in both iterative and recursive formats here.\\n\\nFollow up at Youtube channel: \"Code-Yao\"\\n\"\"\"\\n\\nclass SolutionV1:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        iterative format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs fn in iterative format\\n        def get_component(r, c, color):\\n            visited = set()\\n            s = [(r, c)]\\n            while s:\\n                x, y = s.pop()\\n                visited.add((x, y))\\n                for x1, y1 in {(x-1, y), (x+1, y), (x, y-1), (x, y+1)}:\\n                    if (0 <= x1 < m) and (0 <= y1 < n) and ((x1, y1) not in visited) and grid[x1][y1] == color:\\n                        s.append((x1, y1))\\n            return visited\\n        \\n        # step-2 set the \"bdr\" of cc cells to color\\n        cluster = get_component(row, col, grid[row][col])\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n    \\n    \\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        recursive format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs helper fn in recursion\\n        visited = set()\\n        # @cache\\n        def traverse(r, c, color):\\n            if r < 0 or r >= m or c < 0 or c >= n:\\n                return\\n            if grid[r][c] == color and (r, c) not in visited:\\n                visited.add((r, c))\\n                traverse(r-1, c, color)\\n                traverse(r+1, c, color)\\n                traverse(r, c-1, color)\\n                traverse(r, c+1, color)\\n        \\n        # step-2\\n        traverse(row, col, grid[row][col])\\n        \\n        cluster = visited\\n        \\n        # step-3 set the color\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nContinuing on Problem 733 Flood Fill.\\n\\nTreatment: Traversal in both iterative and recursive formats here.\\n\\nFollow up at Youtube channel: \"Code-Yao\"\\n\"\"\"\\n\\nclass SolutionV1:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        iterative format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs fn in iterative format\\n        def get_component(r, c, color):\\n            visited = set()\\n            s = [(r, c)]\\n            while s:\\n                x, y = s.pop()\\n                visited.add((x, y))\\n                for x1, y1 in {(x-1, y), (x+1, y), (x, y-1), (x, y+1)}:\\n                    if (0 <= x1 < m) and (0 <= y1 < n) and ((x1, y1) not in visited) and grid[x1][y1] == color:\\n                        s.append((x1, y1))\\n            return visited\\n        \\n        # step-2 set the \"bdr\" of cc cells to color\\n        cluster = get_component(row, col, grid[row][col])\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n    \\n    \\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        recursive format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs helper fn in recursion\\n        visited = set()\\n        # @cache\\n        def traverse(r, c, color):\\n            if r < 0 or r >= m or c < 0 or c >= n:\\n                return\\n            if grid[r][c] == color and (r, c) not in visited:\\n                visited.add((r, c))\\n                traverse(r-1, c, color)\\n                traverse(r+1, c, color)\\n                traverse(r, c-1, color)\\n                traverse(r, c+1, color)\\n        \\n        # step-2\\n        traverse(row, col, grid[row][col])\\n        \\n        cluster = visited\\n        \\n        # step-3 set the color\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374584,
                "title": "simple-c-solution-with-bfs",
                "content": "```\\nclass Solution {\\n    bool isValid(int newr,int newc,int n,int m){\\n        return (newr>=0 and newr<n and newc>=0 and newc<m);\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        int clr = grid[row][col];\\n        \\n        int delr[] = {0,1,0,-1};\\n        int delc[] = {1,0,-1,0};\\n        \\n        while(!q.empty()){\\n            auto [r,c] = q.front();\\n            q.pop();\\n \\n            for(int i=0;i<4;i++){\\n                int newr = r+delr[i];\\n                int newc = c+delc[i];\\n                \\n                if(isValid(newr,newc,n,m) and !vis[newr][newc] and grid[newr][newc]==clr){\\n                    q.push({newr,newc});\\n                    vis[newr][newc]=1;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int newr=i+delr[k];\\n                        int newc=j+delc[k];\\n                        \\n                        if(isValid(newr,newc,n,m) and vis[newr][newc]) continue;\\n                        if(newr<0 or newr>=n or newc<0 or newc>=m or grid[newr][newc]!=clr){           \\n                            grid[i][j]=color;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int newr,int newc,int n,int m){\\n        return (newr>=0 and newr<n and newc>=0 and newc<m);\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        int clr = grid[row][col];\\n        \\n        int delr[] = {0,1,0,-1};\\n        int delc[] = {1,0,-1,0};\\n        \\n        while(!q.empty()){\\n            auto [r,c] = q.front();\\n            q.pop();\\n \\n            for(int i=0;i<4;i++){\\n                int newr = r+delr[i];\\n                int newc = c+delc[i];\\n                \\n                if(isValid(newr,newc,n,m) and !vis[newr][newc] and grid[newr][newc]==clr){\\n                    q.push({newr,newc});\\n                    vis[newr][newc]=1;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int newr=i+delr[k];\\n                        int newc=j+delc[k];\\n                        \\n                        if(isValid(newr,newc,n,m) and vis[newr][newc]) continue;\\n                        if(newr<0 or newr>=n or newc<0 or newc>=m or grid[newr][newc]!=clr){           \\n                            grid[i][j]=color;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367569,
                "title": "dfs-matrix-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean allSet(int[][] grid,int i,int j,int color){\\n        int cnt=0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i==0 || i==m-1 || j==0 || j==n-1) return true;\\n        if(grid[i-1][j]==color) cnt++;\\n        if(grid[i+1][j]==color) cnt++;\\n        if(grid[i][j-1]==color) cnt++;\\n        if(grid[i][j+1]==color) cnt++;\\n        return cnt<4;\\n    }\\n    public void dfs(int[][] grid,int[][] visited,int row,int col,int color,int oldcolor,int[][] board,boolean[][] safe){\\n        visited[row][col]=1;\\n        if(safe[row][col]==true){\\n        board[row][col] = color;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] drow = {-1,0,1,0};\\n        int[] dcol = {0,1,0,-1};   \\n           for(int i=0;i<4;i++){\\n               int newr = row + drow[i];\\n               int newc = col + dcol[i];\\nif(newr>=0 && newr<m && newc>=0 && newc<n && visited[newr][newc]!=1 && grid[newr][newc]==oldcolor){\\n                   dfs(grid,visited,newr,newc,color,oldcolor,board,safe);\\n               }\\n           }\\n\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n];\\n        int[][] board = grid;\\n        boolean[][] safe = new boolean[m][n];\\n        int oldcolor = grid[row][col];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                safe[i][j]=allSet(grid,i,j,oldcolor);\\n            }\\n        }\\n        dfs(grid,visited,row,col,color,oldcolor,board,safe);\\n        return board;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean allSet(int[][] grid,int i,int j,int color){\\n        int cnt=0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i==0 || i==m-1 || j==0 || j==n-1) return true;\\n        if(grid[i-1][j]==color) cnt++;\\n        if(grid[i+1][j]==color) cnt++;\\n        if(grid[i][j-1]==color) cnt++;\\n        if(grid[i][j+1]==color) cnt++;\\n        return cnt<4;\\n    }\\n    public void dfs(int[][] grid,int[][] visited,int row,int col,int color,int oldcolor,int[][] board,boolean[][] safe){\\n        visited[row][col]=1;\\n        if(safe[row][col]==true){\\n        board[row][col] = color;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] drow = {-1,0,1,0};\\n        int[] dcol = {0,1,0,-1};   \\n           for(int i=0;i<4;i++){\\n               int newr = row + drow[i];\\n               int newc = col + dcol[i];\\nif(newr>=0 && newr<m && newc>=0 && newc<n && visited[newr][newc]!=1 && grid[newr][newc]==oldcolor){\\n                   dfs(grid,visited,newr,newc,color,oldcolor,board,safe);\\n               }\\n           }\\n\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n];\\n        int[][] board = grid;\\n        boolean[][] safe = new boolean[m][n];\\n        int oldcolor = grid[row][col];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                safe[i][j]=allSet(grid,i,j,oldcolor);\\n            }\\n        }\\n        dfs(grid,visited,row,col,color,oldcolor,board,safe);\\n        return board;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362533,
                "title": "bfs-expalantion-in-comment-java",
                "content": "\\n- Time complexity:M*N\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        /*if value of grid[row][col] is surrounded in 4 adjacent direction and if the value is same then we donot take it*/\\n        /*all adjacent cell which same value as grid[row][col] will be color*/\\n     /*we have used BFS traversal first we are inseting the row col and after removing we are seeing if its adjacent cell has same value then we insert that adjacent cell into the queue and another array we have used so if count <4 so we color that particular res[x][y]=color*/ \\n     /*Also we have used an 2d boolean array of same length as grid so that we marked that cell which is already visited and not to visit again*/\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int res[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=grid[i][j];\\n            }\\n        }\\n        Queue<int[]> q=new LinkedList<>();\\n        boolean visited[][]=new boolean[m][n];\\n        int t[]=new int[2];\\n        int v=grid[row][col];\\n        if(v==color)return grid;\\n        t[0]=row;\\n        t[1]=col;\\n        q.add(t);\\n       while(!q.isEmpty()){\\n           int size=q.size();\\n           for(int i=0;i<size;i++){\\n               int arr[]=q.remove();\\n               int x=arr[0];\\n               int y=arr[1];\\n               if(visited[x][y])continue;\\n               visited[x][y]=true;\\n               int c=y+1;\\n               int c1=y-1;\\n               int r=x+1;\\n               int r1=x-1;\\n               int count=0;\\n               if(c<n && grid[x][c]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c;\\n                   q.add(temp);\\n               }\\n                if(c1>=0 && grid[x][c1]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c1;\\n                   q.add(temp);\\n               }\\n               if(r<m && grid[r][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n                if(r1>=0 && grid[r1][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r1;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n               System.out.print(count+\"  \");\\n               if(count!=4){\\n                   res[x][y]=color;\\n               }\\n           }\\n       }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        /*if value of grid[row][col] is surrounded in 4 adjacent direction and if the value is same then we donot take it*/\\n        /*all adjacent cell which same value as grid[row][col] will be color*/\\n     /*we have used BFS traversal first we are inseting the row col and after removing we are seeing if its adjacent cell has same value then we insert that adjacent cell into the queue and another array we have used so if count <4 so we color that particular res[x][y]=color*/ \\n     /*Also we have used an 2d boolean array of same length as grid so that we marked that cell which is already visited and not to visit again*/\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int res[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=grid[i][j];\\n            }\\n        }\\n        Queue<int[]> q=new LinkedList<>();\\n        boolean visited[][]=new boolean[m][n];\\n        int t[]=new int[2];\\n        int v=grid[row][col];\\n        if(v==color)return grid;\\n        t[0]=row;\\n        t[1]=col;\\n        q.add(t);\\n       while(!q.isEmpty()){\\n           int size=q.size();\\n           for(int i=0;i<size;i++){\\n               int arr[]=q.remove();\\n               int x=arr[0];\\n               int y=arr[1];\\n               if(visited[x][y])continue;\\n               visited[x][y]=true;\\n               int c=y+1;\\n               int c1=y-1;\\n               int r=x+1;\\n               int r1=x-1;\\n               int count=0;\\n               if(c<n && grid[x][c]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c;\\n                   q.add(temp);\\n               }\\n                if(c1>=0 && grid[x][c1]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c1;\\n                   q.add(temp);\\n               }\\n               if(r<m && grid[r][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n                if(r1>=0 && grid[r1][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r1;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n               System.out.print(count+\"  \");\\n               if(count!=4){\\n                   res[x][y]=color;\\n               }\\n           }\\n       }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334204,
                "title": "c-92-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBorder(vector<vector<int>> &grid, int i, int j, int n, int m, int val) {\\n        if(i == 0 or j == 0 or i == n - 1 or j == m - 1) return true;\\n        if(grid[i + 1][j] != val or grid[i - 1][j] != val or grid[i][j - 1] != val or grid[i][j + 1] != val) return true;\\n        return false;\\n    }\\n\\n    void dfs(int r, int c, int val, vector<vector<int>> &grid, vector<vector<int>> &temp, vector<vector<int>> &vis, int color, int n, int m) {\\n        vis[r][c] = 1;\\n        \\n        if(isBorder(grid, r, c, n, m, val))\\n            temp[r][c] = color;\\n        \\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        int cnt = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] == val) \\n                dfs(nx, ny, val, grid, temp, vis, color, n, m);\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int row, int col, int color) {\\n        int val = grid[row][col];\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m)), temp {grid};\\n\\n        dfs(row, col, val, grid, temp, vis, color, n, m);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBorder(vector<vector<int>> &grid, int i, int j, int n, int m, int val) {\\n        if(i == 0 or j == 0 or i == n - 1 or j == m - 1) return true;\\n        if(grid[i + 1][j] != val or grid[i - 1][j] != val or grid[i][j - 1] != val or grid[i][j + 1] != val) return true;\\n        return false;\\n    }\\n\\n    void dfs(int r, int c, int val, vector<vector<int>> &grid, vector<vector<int>> &temp, vector<vector<int>> &vis, int color, int n, int m) {\\n        vis[r][c] = 1;\\n        \\n        if(isBorder(grid, r, c, n, m, val))\\n            temp[r][c] = color;\\n        \\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        int cnt = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] == val) \\n                dfs(nx, ny, val, grid, temp, vis, color, n, m);\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int row, int col, int color) {\\n        int val = grid[row][col];\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m)), temp {grid};\\n\\n        dfs(row, col, val, grid, temp, vis, color, n, m);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327373,
                "title": "easy-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        def out_of_boundary(x, y):\\n            return x < 0 or y < 0 or x >= m or y >= n\\n\\n        def get_color(x, y):\\n            if out_of_boundary(x, y):\\n                return -2\\n            return grid[x][y]\\n\\n        def check_inside(x, y, target):\\n            dirs = [1, 0, -1, 0]\\n            for i in range(4):\\n                color = get_color(x + dirs[i], y + dirs[(i + 1) % 4])\\n                if color != -1 and color != target:\\n                    return False\\n            return True\\n\\n        p = []\\n        \\n        def dfs(x, y, target):\\n            if out_of_boundary(x, y):\\n                return\\n            if grid[x][y] != target:\\n                return\\n            if check_inside(x, y, target):\\n                p.append((x, y, grid[x][y]))\\n            grid[x][y] = -1\\n            dfs(x + 1, y, target)\\n            dfs(x - 1, y, target)\\n            dfs(x, y + 1, target)\\n            dfs(x, y - 1, target)\\n        \\n        dfs(row, col, grid[row][col])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == -1:\\n                    grid[i][j] = color\\n\\n        for x, y, color in p:\\n            grid[x][y] = color\\n            \\n        return grid\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        def out_of_boundary(x, y):\\n            return x < 0 or y < 0 or x >= m or y >= n\\n\\n        def get_color(x, y):\\n            if out_of_boundary(x, y):\\n                return -2\\n            return grid[x][y]\\n\\n        def check_inside(x, y, target):\\n            dirs = [1, 0, -1, 0]\\n            for i in range(4):\\n                color = get_color(x + dirs[i], y + dirs[(i + 1) % 4])\\n                if color != -1 and color != target:\\n                    return False\\n            return True\\n\\n        p = []\\n        \\n        def dfs(x, y, target):\\n            if out_of_boundary(x, y):\\n                return\\n            if grid[x][y] != target:\\n                return\\n            if check_inside(x, y, target):\\n                p.append((x, y, grid[x][y]))\\n            grid[x][y] = -1\\n            dfs(x + 1, y, target)\\n            dfs(x - 1, y, target)\\n            dfs(x, y + 1, target)\\n            dfs(x, y - 1, target)\\n        \\n        dfs(row, col, grid[row][col])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == -1:\\n                    grid[i][j] = color\\n\\n        for x, y, color in p:\\n            grid[x][y] = color\\n            \\n        return grid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327297,
                "title": "c-bfs-using-queue-and-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS technique to traverse every cell of the connected component and check if the cell color needs to be changed if its a bordering cell.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart from grid[row][col] cell and traverse all the adjacent cells that are part of same component by BFS technique using queue. While traversing the connected component we also check which cells are border cells by checking if it touches the grid limit (0 <= cell_row < grid_row) or (0 <= cell_col < grid_col) or it touches the cell of another connected component (adjacent cell color != original component color).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where \\'n\\' is the no. of cells in the connected component which can be r*c(no. of rows and coloumns in the grid) in worst case. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where \\'n\\' is the no. of cells in the connected component which can be r*c(no. of rows and coloumns in the grid) in worst case.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int gr = grid.size();\\n        int gc = grid[0].size();\\n        int compColor = grid[row][col];\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        int move[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        set<pair<int, int>> st;\\n        st.insert({row,col});\\n\\n        while(!q.empty()) {\\n            int cr = q.front().first;\\n            int cc = q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int nr = cr + move[k][0];\\n                int nc = cc + move[k][1];\\n\\n                if(nr < 0 || nr >= gr || nc < 0 || nc >= gc) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] != compColor && st.find({nr,nc}) == st.end()) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] == compColor && st.find({nr,nc}) == st.end()) {\\n                    q.push({nr, nc});\\n                    st.insert({nr,nc});\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int gr = grid.size();\\n        int gc = grid[0].size();\\n        int compColor = grid[row][col];\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        int move[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        set<pair<int, int>> st;\\n        st.insert({row,col});\\n\\n        while(!q.empty()) {\\n            int cr = q.front().first;\\n            int cc = q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int nr = cr + move[k][0];\\n                int nc = cc + move[k][1];\\n\\n                if(nr < 0 || nr >= gr || nc < 0 || nc >= gc) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] != compColor && st.find({nr,nc}) == st.end()) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] == compColor && st.find({nr,nc}) == st.end()) {\\n                    q.push({nr, nc});\\n                    st.insert({nr,nc});\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303499,
                "title": "python-bfs-solution",
                "content": "# Intuition\\nWe can use BFS solution to solve this problem. Start from point (row, col) and move to the neighbors if neighbour has color that we should repaint. We should use visited and painted set to define visited and painted points.\\n\\n# Approach\\nDefine a queue and first point in the queue as grid[row][col].\\nUse BFS to move to the neigbours of current point if the neigbour has color that should be repainted. If all neigbours should be repainted or were repainted that current point should be leave with current color because the current point in the middle. Otherwise, repaint current point and add the point to repainted.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        if m == 0:\\n            return grid\\n        n = len(grid[0])\\n\\n        dr = [[-1,0],[0,1],[1,0],[0,-1]]\\n        visited = set()\\n        painted = set()\\n        cl = grid[row][col]\\n\\n        q = deque()\\n        q.append([row, col])\\n        while q:\\n            for i in range(len(q)):\\n                paint = False\\n                y, x = q.popleft()\\n                key = str(y) + \\':\\' + str(x)\\n                if key in visited:\\n                    continue\\n                visited.add(key)\\n                for dY, dX in dr:\\n                    newY = y + dY\\n                    newX = x + dX\\n                    if newY >= 0 and newY < m and newX >= 0 and newX < n and grid[newY][newX] == cl:\\n                        q.append([newY, newX])\\n                    elif str(newY) + \\':\\' + str(newX) not in painted:\\n                        paint = True\\n                if paint:\\n                    painted.add(key)\\n                    grid[y][x] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        if m == 0:\\n            return grid\\n        n = len(grid[0])\\n\\n        dr = [[-1,0],[0,1],[1,0],[0,-1]]\\n        visited = set()\\n        painted = set()\\n        cl = grid[row][col]\\n\\n        q = deque()\\n        q.append([row, col])\\n        while q:\\n            for i in range(len(q)):\\n                paint = False\\n                y, x = q.popleft()\\n                key = str(y) + \\':\\' + str(x)\\n                if key in visited:\\n                    continue\\n                visited.add(key)\\n                for dY, dX in dr:\\n                    newY = y + dY\\n                    newX = x + dX\\n                    if newY >= 0 and newY < m and newX >= 0 and newX < n and grid[newY][newX] == cl:\\n                        q.append([newY, newX])\\n                    elif str(newY) + \\':\\' + str(newX) not in painted:\\n                        paint = True\\n                if paint:\\n                    painted.add(key)\\n                    grid[y][x] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300638,
                "title": "java-dfs-o-n2-self-explained-code",
                "content": "# Complexity\\n- Time complexity: $$O(n2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(new Integer[]{0,1},\\n            new Integer[]{0,-1}, new Integer[]{1,0}, new Integer[]{-1,0});\\n    private final Set<String> visited = new HashSet<>();\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color) return grid;\\n        dfs(row, col, grid[row][col], color, grid);\\n        return grid;\\n    }\\n\\n    private void dfs(int row, int col, int componentColor, int newColor, int[][] grid) {\\n        visited.add(row + \",\" + col);\\n        if(isOnBorders(row, col, grid) || isAdjacentToDiffComponent(row, col, componentColor, grid)) \\n            grid[row][col] = newColor;\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid,i,j) && !visited.contains(i + \",\" + j) && grid[i][j] == componentColor)\\n                dfs(i, j, componentColor, newColor, grid);\\n        }\\n    }\\n\\n    private boolean isAdjacentToDiffComponent(int row, int col, int componentColor, int[][] grid) {\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid, i, j) && !visited.contains(i + \",\" + j)  && grid[i][j] != componentColor)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidCoordinates(int[][] grid, int i, int j) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isOnBorders(int row, int col, int[][] grid) {\\n        return row == 0 || row == grid.length-1 || col == 0 || col == grid[0].length-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(new Integer[]{0,1},\\n            new Integer[]{0,-1}, new Integer[]{1,0}, new Integer[]{-1,0});\\n    private final Set<String> visited = new HashSet<>();\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color) return grid;\\n        dfs(row, col, grid[row][col], color, grid);\\n        return grid;\\n    }\\n\\n    private void dfs(int row, int col, int componentColor, int newColor, int[][] grid) {\\n        visited.add(row + \",\" + col);\\n        if(isOnBorders(row, col, grid) || isAdjacentToDiffComponent(row, col, componentColor, grid)) \\n            grid[row][col] = newColor;\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid,i,j) && !visited.contains(i + \",\" + j) && grid[i][j] == componentColor)\\n                dfs(i, j, componentColor, newColor, grid);\\n        }\\n    }\\n\\n    private boolean isAdjacentToDiffComponent(int row, int col, int componentColor, int[][] grid) {\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid, i, j) && !visited.contains(i + \",\" + j)  && grid[i][j] != componentColor)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidCoordinates(int[][] grid, int i, int j) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isOnBorders(int row, int col, int[][] grid) {\\n        return row == 0 || row == grid.length-1 || col == 0 || col == grid[0].length-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291684,
                "title": "dfs-iterative-and-recursive-approaches-bfs-in-python-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStarting from the given cell (row, col) traverse all the neighbors (UP, DOWN, RIGHT, LEFT neighbors) with the same color, and change the cell\\'s color to given color. But we should only change the color of cell when it is a border.\\n\\nA cell can be a border in 2 cases only:\\n- 1. when it is already in the border of the grid\\n- 2. when it is in the middle of the grid and one of the neighbor has different color\\n\\nWe can solve this problem with either DFS or BFS.\\nFor both of them the approach, intuition, complexity analysis are the same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. starting from the given cell (row, col)\\n2. mark this cell as visited\\n3. traverse all neighbors [(1,0), (-1, 0), (0,1), (0,-1)] with the same color only\\n4. if one of the neighbors has different color mark `isBorder` flag as true\\n5. if the current cell is border change its color\\n\\n \\n# Complexity\\n- Time complexity: O(MN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(MN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**DFS (Iteratative Approach)**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n```\\n\\n**DFS Approach with recursion**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n\\n        def dfs(row, col, color):\\n            visited.add((row, col))\\n            neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row+r, col+c\\n                \\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                dfs(new_r, new_c, color)\\n            \\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        dfs(r, c, grid[r][c])\\n\\n        return grid\\n```\\n\\n**BFS Approach**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            \\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n\\n        def dfs(row, col, color):\\n            visited.add((row, col))\\n            neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row+r, col+c\\n                \\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                dfs(new_r, new_c, color)\\n            \\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        dfs(r, c, grid[r][c])\\n\\n        return grid\\n```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            \\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267644,
                "title": "1034-coloring-a-border-java-dfs-bit-manipulation-approach",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/4766e2d3-e32d-4122-86db-e060c39a27cf_1678173936.385443.png)\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] ans;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        ans = new int[grid.length][];\\n        for(int i=0;i<grid.length;i++){\\n            ans[i] = grid[i].clone();\\n        }\\n\\n        coloring(grid,row,col,grid[row][col],color,new int[grid.length]);\\n\\n       return ans;\\n    }\\n\\n    public boolean check(int n, int pos){\\n        int mask = 1<<pos;\\n\\n        if((n&mask) == mask){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    public int toggle(int n, int pos){\\n        int mask = 1<<pos;\\n        return (n^mask);\\n    }\\n\\n    public void coloring(int[][] arr, int row, int col, int oCol,int target, int[] visited){\\n        if(row<0 || row>=arr.length || col<0 || col>=arr[0].length || (check(visited[row],col) == true) || arr[row][col] != oCol){\\n            return;\\n        }\\n\\n        if((row == 0 || row == arr.length-1 || col == 0 || col == arr[0].length-1 || (arr[row-1][col] != oCol || arr[row][col-1] != oCol || arr[row+1][col] != oCol || arr[row][col+1] != oCol)) && arr[row][col] == oCol){\\n            ans[row][col] = target;\\n        }\\n\\n        visited[row] = toggle(visited[row], col);\\n        coloring(arr,row-1,col,oCol,target,visited);\\n        coloring(arr,row,col-1,oCol,target,visited);\\n        coloring(arr,row+1,col,oCol,target,visited);\\n        coloring(arr,row,col+1,oCol,target,visited);\\n        visited[row] = toggle(visited[row], col);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] ans;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        ans = new int[grid.length][];\\n        for(int i=0;i<grid.length;i++){\\n            ans[i] = grid[i].clone();\\n        }\\n\\n        coloring(grid,row,col,grid[row][col],color,new int[grid.length]);\\n\\n       return ans;\\n    }\\n\\n    public boolean check(int n, int pos){\\n        int mask = 1<<pos;\\n\\n        if((n&mask) == mask){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    public int toggle(int n, int pos){\\n        int mask = 1<<pos;\\n        return (n^mask);\\n    }\\n\\n    public void coloring(int[][] arr, int row, int col, int oCol,int target, int[] visited){\\n        if(row<0 || row>=arr.length || col<0 || col>=arr[0].length || (check(visited[row],col) == true) || arr[row][col] != oCol){\\n            return;\\n        }\\n\\n        if((row == 0 || row == arr.length-1 || col == 0 || col == arr[0].length-1 || (arr[row-1][col] != oCol || arr[row][col-1] != oCol || arr[row+1][col] != oCol || arr[row][col+1] != oCol)) && arr[row][col] == oCol){\\n            ans[row][col] = target;\\n        }\\n\\n        visited[row] = toggle(visited[row], col);\\n        coloring(arr,row-1,col,oCol,target,visited);\\n        coloring(arr,row,col-1,oCol,target,visited);\\n        coloring(arr,row+1,col,oCol,target,visited);\\n        coloring(arr,row,col+1,oCol,target,visited);\\n        visited[row] = toggle(visited[row], col);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191048,
                "title": "c",
                "content": "```\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    *returnSize = m;\\n    *returnColumnSizes = malloc(m * sizeof(int ));\\n    for(int i = 0; i < m; i++){\\n        returnColumnSizes[0][i] = n;\\n    }\\n    if(grid[row][col] == color)\\n        return grid ;\\n    \\n    bool** used = malloc(m * sizeof(bool*));\\n    for(int i = 0; i < m; i++){\\n        used[i] = calloc(n , sizeof(bool));            \\n    }\\n    \\n    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;\\n    \\n    int** queue = malloc(m * n * sizeof(int*));\\n    int org = grid[row][col] ;\\n    int idx = 0;\\n    queue[idx] = malloc(2 * sizeof(int));\\n    queue[idx][0] = row;\\n    queue[idx][1] = col;\\n    idx++;\\n    int pos = 0;\\n      \\n    used[row][col] = true ;\\n    grid[row][col] = -1*color ;\\n    while(pos < idx){\\n        int x = queue[pos][0];\\n        int y = queue[pos][1];\\n        for(int i = 0; i < 4; i++){\\n            int xx = x + dir[i][0] ;\\n            int yy = y + dir[i][1] ;\\n            if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                continue ;\\n            if(used[xx][yy] || grid[xx][yy] != org)\\n                continue ;\\n            used[xx][yy] = true ;\\n            queue[idx] = malloc(2 * sizeof(int)) ;\\n            queue[idx][0] = xx ;\\n            queue[idx][1] = yy ;\\n            idx++ ;\\n            grid[xx][yy] = -1 * color ;\\n        }\\n        pos++;\\n    }\\n\\n    for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n            if(grid[i][j] == -1 * color){\\n                if(i == 0 || j == 0 || (i == (m-1)) || (j == (n-1)) ){\\n                    grid[i][j] = color ;\\n                    continue ;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int ii = i + dir[k][0] ;\\n                    int jj = j + dir[k][1] ;\\n                    if(used[ii][jj] == false){\\n                        grid[i][j] = color ;\\n                        break ;\\n                    }\\n                    if(k == 3)\\n                        grid[i][j] = org ;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for(int i = 0; i < idx; i++)\\n        free(queue[i]) ;\\n    free(queue) ;\\n    for(int i = 0; i < m; i++)\\n        free(used[i]) ;\\n    free(used) ;\\n    return grid;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    *returnSize = m;\\n    *returnColumnSizes = malloc(m * sizeof(int ));\\n    for(int i = 0; i < m; i++){\\n        returnColumnSizes[0][i] = n;\\n    }\\n    if(grid[row][col] == color)\\n        return grid ;\\n    \\n    bool** used = malloc(m * sizeof(bool*));\\n    for(int i = 0; i < m; i++){\\n        used[i] = calloc(n , sizeof(bool));            \\n    }\\n    \\n    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;\\n    \\n    int** queue = malloc(m * n * sizeof(int*));\\n    int org = grid[row][col] ;\\n    int idx = 0;\\n    queue[idx] = malloc(2 * sizeof(int));\\n    queue[idx][0] = row;\\n    queue[idx][1] = col;\\n    idx++;\\n    int pos = 0;\\n      \\n    used[row][col] = true ;\\n    grid[row][col] = -1*color ;\\n    while(pos < idx){\\n        int x = queue[pos][0];\\n        int y = queue[pos][1];\\n        for(int i = 0; i < 4; i++){\\n            int xx = x + dir[i][0] ;\\n            int yy = y + dir[i][1] ;\\n            if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                continue ;\\n            if(used[xx][yy] || grid[xx][yy] != org)\\n                continue ;\\n            used[xx][yy] = true ;\\n            queue[idx] = malloc(2 * sizeof(int)) ;\\n            queue[idx][0] = xx ;\\n            queue[idx][1] = yy ;\\n            idx++ ;\\n            grid[xx][yy] = -1 * color ;\\n        }\\n        pos++;\\n    }\\n\\n    for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n            if(grid[i][j] == -1 * color){\\n                if(i == 0 || j == 0 || (i == (m-1)) || (j == (n-1)) ){\\n                    grid[i][j] = color ;\\n                    continue ;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int ii = i + dir[k][0] ;\\n                    int jj = j + dir[k][1] ;\\n                    if(used[ii][jj] == false){\\n                        grid[i][j] = color ;\\n                        break ;\\n                    }\\n                    if(k == 3)\\n                        grid[i][j] = org ;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for(int i = 0; i < idx; i++)\\n        free(queue[i]) ;\\n    free(queue) ;\\n    for(int i = 0; i < m; i++)\\n        free(used[i]) ;\\n    free(used) ;\\n    return grid;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152022,
                "title": "easy-iterative-bfs-c-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSimple Bfs using Queue , just one make sure when you are performing Bfs from a node check whether all it 4 adjacent sides have same intial given color or not. If yes , then no need to color it , else color that node with given final color.\\nAll everything else like visited array , queue processing ,is same\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int iniColor = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> vis (n,vector<int> (m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col] = 1;\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            int cnt = 0;\\n            for(int i=0;i<4;i++){\\n                int newrow = row + delrow[i];\\n                int newcol = col + delcol[i];\\n                if(newrow >= 0 && newrow < n && newcol >=0 && newcol < m && grid[newrow][newcol] == iniColor){\\n                    cnt++;\\n                    if(!vis[newrow][newcol]){\\n                        vis[newrow][newcol] = 1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            if(cnt != 4) ans[row][col] = color;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int iniColor = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> vis (n,vector<int> (m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col] = 1;\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            int cnt = 0;\\n            for(int i=0;i<4;i++){\\n                int newrow = row + delrow[i];\\n                int newcol = col + delcol[i];\\n                if(newrow >= 0 && newrow < n && newcol >=0 && newcol < m && grid[newrow][newcol] == iniColor){\\n                    cnt++;\\n                    if(!vis[newrow][newcol]){\\n                        vis[newrow][newcol] = 1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            if(cnt != 4) ans[row][col] = color;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103474,
                "title": "easy-java-dfs-solution-with-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /**\\n     * We should only color the border not the elements inside the border.\\n     * Approach:\\n     * 1.Run a dfs from row,col and find all the elements in the connected component\\n     * 2.Once we get elements in the connected component, we can check if we have to color a element or not by following the below given rules\\n     * i)If the node is surrounded by all same color nodes don\\'t color it\\n     * ii)If the node at-least have one non-same color node adjacent to it, then color it\\n     */\\n    private static int prevColor;\\n    private static HashSet<Pair<Integer, Integer>> visited;\\n    private static ArrayList<Pair<Integer, Integer>> connectedComponent;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        prevColor = grid[row][col];\\n        visited = new HashSet<>();\\n        connectedComponent = new ArrayList<>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean flag = false;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == prevColor) {\\n                    dfs(grid, row, col);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) break;\\n        }\\n\\n        int newGrid[][] = new int[m][n];\\n        //copy grid to newGrid\\n        for (int i = 0; i < m; i++) {\\n            newGrid[i] = grid[i].clone();\\n        }\\n        for (int i = 0; i < connectedComponent.size(); i++) {\\n            Pair<Integer, Integer> p = connectedComponent.get(i);\\n\\n            if (!isSame(grid, p.getKey(), p.getValue(), prevColor)) {\\n                newGrid[p.getKey()][p.getValue()] = color;\\n            }\\n\\n        }\\n        return newGrid;\\n    }\\n\\n\\n    //Helper method to determine if we have to color or not\\n    private boolean isSame(int[][] grid, Integer row, Integer col, int prevColor) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        //iterate all the four directions and see if it is surrounded by same color\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (!isValid(nextRow, nextCol, m, n) || grid[nextRow][nextCol] != prevColor) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        visited.add(new Pair<Integer, Integer>(row, col));\\n        connectedComponent.add(new Pair<Integer, Integer>(row, col));\\n\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (isValid(nextRow, nextCol, grid.length, grid[0].length) && !visited.contains(new Pair<Integer, Integer>(nextRow, nextCol)) && grid[nextRow][nextCol] == prevColor) {\\n                dfs(grid, nextRow, nextCol);\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(int nextRow, int nextCol, int m, int n) {\\n        return nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * We should only color the border not the elements inside the border.\\n     * Approach:\\n     * 1.Run a dfs from row,col and find all the elements in the connected component\\n     * 2.Once we get elements in the connected component, we can check if we have to color a element or not by following the below given rules\\n     * i)If the node is surrounded by all same color nodes don\\'t color it\\n     * ii)If the node at-least have one non-same color node adjacent to it, then color it\\n     */\\n    private static int prevColor;\\n    private static HashSet<Pair<Integer, Integer>> visited;\\n    private static ArrayList<Pair<Integer, Integer>> connectedComponent;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        prevColor = grid[row][col];\\n        visited = new HashSet<>();\\n        connectedComponent = new ArrayList<>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean flag = false;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == prevColor) {\\n                    dfs(grid, row, col);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) break;\\n        }\\n\\n        int newGrid[][] = new int[m][n];\\n        //copy grid to newGrid\\n        for (int i = 0; i < m; i++) {\\n            newGrid[i] = grid[i].clone();\\n        }\\n        for (int i = 0; i < connectedComponent.size(); i++) {\\n            Pair<Integer, Integer> p = connectedComponent.get(i);\\n\\n            if (!isSame(grid, p.getKey(), p.getValue(), prevColor)) {\\n                newGrid[p.getKey()][p.getValue()] = color;\\n            }\\n\\n        }\\n        return newGrid;\\n    }\\n\\n\\n    //Helper method to determine if we have to color or not\\n    private boolean isSame(int[][] grid, Integer row, Integer col, int prevColor) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        //iterate all the four directions and see if it is surrounded by same color\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (!isValid(nextRow, nextCol, m, n) || grid[nextRow][nextCol] != prevColor) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        visited.add(new Pair<Integer, Integer>(row, col));\\n        connectedComponent.add(new Pair<Integer, Integer>(row, col));\\n\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (isValid(nextRow, nextCol, grid.length, grid[0].length) && !visited.contains(new Pair<Integer, Integer>(nextRow, nextCol)) && grid[nextRow][nextCol] == prevColor) {\\n                dfs(grid, nextRow, nextCol);\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(int nextRow, int nextCol, int m, int n) {\\n        return nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078407,
                "title": "c-bfs-easy-understanding-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe are using bfs here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe start bfs from the given node (row,col).\\nnow we check it\\'s neighbours if it is has same color then we push in queue and increment the counter .\\nif value of counter is less than 4 than we have to recolor to thisw node with given color.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N*M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\nint dx[4]={-1,0,1,0};\\nint dy[4]={0,1,0,-1};\\nvector<vector<int>>vis,ans;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        ans.resize(n,vector<int>(m,0));\\n        vis.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        int c=grid[row][col];\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int cnt=0;\\n             for(int i=0;i<4;i++){\\n                 int nx=x+dx[i];\\n                 int ny=y+dy[i];\\n                 if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]==c){\\n                     cnt++;\\n                     \\n                     if(!vis[nx][ny]){\\n                      q.push({nx,ny});\\n                      vis[nx][ny]=1;\\n                     }\\n                 }\\n             }\\n\\n             if(cnt<4){\\n                 ans[x][y]=color;\\n             }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\nint dx[4]={-1,0,1,0};\\nint dy[4]={0,1,0,-1};\\nvector<vector<int>>vis,ans;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        ans.resize(n,vector<int>(m,0));\\n        vis.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        int c=grid[row][col];\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int cnt=0;\\n             for(int i=0;i<4;i++){\\n                 int nx=x+dx[i];\\n                 int ny=y+dy[i];\\n                 if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]==c){\\n                     cnt++;\\n                     \\n                     if(!vis[nx][ny]){\\n                      q.push({nx,ny});\\n                      vis[nx][ny]=1;\\n                     }\\n                 }\\n             }\\n\\n             if(cnt<4){\\n                 ans[x][y]=color;\\n             }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067884,
                "title": "backtracking-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] arr, int row, int col, int color) {\\n        check(arr,row,col,arr[row][col]);\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[0].length;j++){\\n                if(arr[i][j]<0){\\n                    arr[i][j] = color;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public void check(int[][] arr,int row,int col,int clr){\\n        arr[row][col] = -clr;\\n\\n        // check in 4 direction\\n        int count=0;\\n        for(int i=0;i<4;i++){\\n            // check coonected component;\\n            int r = row + dir[i][0];\\n            int c = col + dir[i][1];\\n\\n            if(r<0 || r>=arr.length || c<0 || c>=arr[0].length || Math.abs(arr[r][c]) != clr){\\n                continue;\\n            }\\n\\n            count++;\\n            if(arr[r][c]==clr){\\n                check(arr,r,c,clr);\\n            }\\n        }\\n\\n        // check if all dir same or not\\n        if(count==4){\\n            arr[row][col]=clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] arr, int row, int col, int color) {\\n        check(arr,row,col,arr[row][col]);\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[0].length;j++){\\n                if(arr[i][j]<0){\\n                    arr[i][j] = color;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public void check(int[][] arr,int row,int col,int clr){\\n        arr[row][col] = -clr;\\n\\n        // check in 4 direction\\n        int count=0;\\n        for(int i=0;i<4;i++){\\n            // check coonected component;\\n            int r = row + dir[i][0];\\n            int c = col + dir[i][1];\\n\\n            if(r<0 || r>=arr.length || c<0 || c>=arr[0].length || Math.abs(arr[r][c]) != clr){\\n                continue;\\n            }\\n\\n            count++;\\n            if(arr[r][c]==clr){\\n                check(arr,r,c,clr);\\n            }\\n        }\\n\\n        // check if all dir same or not\\n        if(count==4){\\n            arr[row][col]=clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056667,
                "title": "clean-python-9-lines-high-speed-o-n-time-o-1-space-beats-96-9",
                "content": "\\n# Python, DFS:\\n##### We can color the border inside the DFS.\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]): return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4: grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\\n\\n# Python, BFS:\\n\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else: border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]): return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4: grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else: border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049602,
                "title": "simple-java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int len, wid;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        this.len = grid.length;\\n        this.wid = grid[0].length;\\n        Dfs(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < wid; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public void Dfs(int[][] grid, int row, int col, int color) {\\n        grid[row][col] = -color; \\n        int count = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int rowdash = row + dir[i][0];\\n            int coldash = col + dir[i][1];\\n            if(rowdash < 0 || coldash < 0 || rowdash >= len || coldash >= wid \\n            || Math.abs(grid[rowdash][coldash]) != color) {\\n                continue;\\n            }\\n            count++; \\n            if(grid[rowdash][coldash] == color)\\n                Dfs(grid, rowdash, coldash, color);\\n        }\\n        if(count == 4)\\n            grid[row][col] = color;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int len, wid;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        this.len = grid.length;\\n        this.wid = grid[0].length;\\n        Dfs(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < wid; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public void Dfs(int[][] grid, int row, int col, int color) {\\n        grid[row][col] = -color; \\n        int count = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int rowdash = row + dir[i][0];\\n            int coldash = col + dir[i][1];\\n            if(rowdash < 0 || coldash < 0 || rowdash >= len || coldash >= wid \\n            || Math.abs(grid[rowdash][coldash]) != color) {\\n                continue;\\n            }\\n            count++; \\n            if(grid[rowdash][coldash] == color)\\n                Dfs(grid, rowdash, coldash, color);\\n        }\\n        if(count == 4)\\n            grid[row][col] = color;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041332,
                "title": "95-faster-easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>g(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                g[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        int y=grid[row][col];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int dr[]={0,-1,0,1};\\n        int dc[]={1,0,-1,0};\\n        while(!q.empty()){\\n            auto it=q.front();\\n            q.pop();\\n            int r=it.first;\\n            int c=it.second;\\n            if(vis[r][c]==1)continue;\\n            vis[r][c]=1;\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0&&nr<n&&nc>=0&&nc<m){\\n                    if(grid[nr][nc]==y){\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==1){\\n                    if((i==0&&j>=0&&j<m)||(i==n-1&&j>=0&&j<m)\\n                    ||(j==0&&i>=0&&i<n)||(j==m-1&&i>=0&&i<n)){\\n                        g[i][j]=color;\\n                        continue;\\n\\n                    }\\n                    for(int x=0;x<4;x++){\\n                        int nr=i+dr[x];\\n                        int nc=j+dc[x];\\n                        \\n                        if((nr>=0&&nr<n&&nc>=0&&nc<m&&grid[nr][nc]!=y)){\\n                            g[i][j]=color;\\n                            continue;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>g(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                g[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        int y=grid[row][col];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int dr[]={0,-1,0,1};\\n        int dc[]={1,0,-1,0};\\n        while(!q.empty()){\\n            auto it=q.front();\\n            q.pop();\\n            int r=it.first;\\n            int c=it.second;\\n            if(vis[r][c]==1)continue;\\n            vis[r][c]=1;\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0&&nr<n&&nc>=0&&nc<m){\\n                    if(grid[nr][nc]==y){\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==1){\\n                    if((i==0&&j>=0&&j<m)||(i==n-1&&j>=0&&j<m)\\n                    ||(j==0&&i>=0&&i<n)||(j==m-1&&i>=0&&i<n)){\\n                        g[i][j]=color;\\n                        continue;\\n\\n                    }\\n                    for(int x=0;x<4;x++){\\n                        int nr=i+dr[x];\\n                        int nc=j+dc[x];\\n                        \\n                        if((nr>=0&&nr<n&&nc>=0&&nc<m&&grid[nr][nc]!=y)){\\n                            g[i][j]=color;\\n                            continue;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034757,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn color_border(grid: Vec<Vec<i32>>, row: i32, col: i32, color: i32) -> Vec<Vec<i32>> {\\n        fn dfs(grid: &mut Vec<Vec<i32>>, r: i32, c: i32, cl: i32) {\\n            if r < 0\\n                || r >= grid.len() as i32\\n                || c < 0\\n                || c >= grid[r as usize].len() as i32\\n                || grid[r as usize][c as usize] != cl\\n            {\\n                return;\\n            }\\n            grid[r as usize][c as usize] = -cl;\\n            dfs(grid, r - 1, c, cl);\\n            dfs(grid, r + 1, c, cl);\\n            dfs(grid, r, c - 1, cl);\\n            dfs(grid, r, c + 1, cl);\\n            if r > 0\\n                && r < grid.len() as i32 - 1\\n                && c > 0\\n                && c < grid[r as usize].len() as i32 - 1\\n                && cl == grid[(r - 1) as usize][c as usize].abs()\\n                && cl == grid[(r + 1) as usize][c as usize].abs()\\n                && cl == grid[r as usize][(c - 1) as usize].abs()\\n                && cl == grid[r as usize][(c + 1) as usize].abs()\\n            {\\n                grid[r as usize][c as usize] = cl;\\n            }\\n        }\\n\\n        let mut grid = grid;\\n        let cl = grid[row as usize][col as usize];\\n        dfs(&mut grid, row, col, cl);\\n        for item in grid.iter_mut() {\\n            for pt in item.iter_mut() {\\n                *pt = if *pt < 0 { color } else { *pt };\\n            }\\n        }\\n        grid\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn color_border(grid: Vec<Vec<i32>>, row: i32, col: i32, color: i32) -> Vec<Vec<i32>> {\\n        fn dfs(grid: &mut Vec<Vec<i32>>, r: i32, c: i32, cl: i32) {\\n            if r < 0\\n                || r >= grid.len() as i32\\n                || c < 0\\n                || c >= grid[r as usize].len() as i32\\n                || grid[r as usize][c as usize] != cl\\n            {\\n                return;\\n            }\\n            grid[r as usize][c as usize] = -cl;\\n            dfs(grid, r - 1, c, cl);\\n            dfs(grid, r + 1, c, cl);\\n            dfs(grid, r, c - 1, cl);\\n            dfs(grid, r, c + 1, cl);\\n            if r > 0\\n                && r < grid.len() as i32 - 1\\n                && c > 0\\n                && c < grid[r as usize].len() as i32 - 1\\n                && cl == grid[(r - 1) as usize][c as usize].abs()\\n                && cl == grid[(r + 1) as usize][c as usize].abs()\\n                && cl == grid[r as usize][(c - 1) as usize].abs()\\n                && cl == grid[r as usize][(c + 1) as usize].abs()\\n            {\\n                grid[r as usize][c as usize] = cl;\\n            }\\n        }\\n\\n        let mut grid = grid;\\n        let cl = grid[row as usize][col as usize];\\n        dfs(&mut grid, row, col, cl);\\n        for item in grid.iter_mut() {\\n            for pt in item.iter_mut() {\\n                *pt = if *pt < 0 { color } else { *pt };\\n            }\\n        }\\n        grid\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031681,
                "title": "cpp-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>grid,vector<vector<int>>&visited,int row,int col,int value) {\\n        \\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col] = 1;\\n        while(!q.empty()) {\\n           \\n            int row = q.front().first;\\n            int col = q.front().second;\\n            \\n            q.pop();\\n            int a = row + 1;\\n            int b = row - 1;\\n            int c = col + 1;\\n            int d = col - 1;\\n            if(a>=0&&col>=0&&a<grid.size()&&col<grid[0].size()&&grid[a][col]==value&&visited[a][col]==0){\\n                \\n                q.push({a,col});\\n                visited[a][col] = 1;\\n            }\\n                   if(b>=0&&col>=0&&b<grid.size()&&col<grid[0].size()&&grid[b][col]==value&&visited[b][col]==0){\\n                      \\n                q.push({b,col});\\n                visited[b][col] = 1;\\n            }\\n                             if(row>=0&&c>=0&&row<grid.size()&&c<grid[0].size()&&grid[row][c]==value&&visited[row][c]==0){\\n                                \\n                q.push({row,c});\\n                visited[row][c] = 1;\\n            }\\n                                         if(row>=0&&d>=0&&row<grid.size()&&d<grid[0].size()&&grid[row][d]==value&&visited[row][d]==0){\\n                                             \\n                q.push({row,d});\\n                visited[row][d] = 1;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        int val=grid[row][col];\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        ans=grid;\\n        bfs(grid,visited,row,col,val);\\n        \\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<m;j++)\\n        //     {\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl<<endl;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            for(int j=0;j<m;j++){\\n          \\n              \\n                if(i>0&&j>0&&i<grid.size()-1&&j<grid[i].size()-1)\\n                {\\n                     int a = i + 1;\\n                     int b = i - 1;\\n                     int c = j + 1;\\n                     int d = j - 1; \\n                    \\n                     if(grid[a][j]==val&&grid[b][j]==val&&grid[i]                                     [c]==val&&grid[i][d]==val)\\n                     {\\n                       \\n                             ans[i][j]=grid[i][j];\\n                         \\n                         \\n                     }\\n                    else\\n                    {\\n                          if(visited[i][j]==1)\\n                    {\\n                        ans[i][j]=color;\\n                    }\\n                    else\\n                    {\\n                        ans[i][j]=grid[i][j];\\n                    }\\n                    }\\n        \\n         \\n                   }\\n                else\\n                {\\n                    if(visited[i][j]==1)\\n                    {\\n                        ans[i][j]=color;\\n                    }\\n                    else\\n                    {\\n                        ans[i][j]=grid[i][j];\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        return ans;\\n        \\n    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void bfs(vector<vector<int>>grid,vector<vector<int>>&visited,int row,int col,int value) {\\n        \\n        queue<pair<int,int>>q;\\n        q.push({row,col}",
                "codeTag": "Java"
            },
            {
                "id": 3027562,
                "title": "go-bfs-beat-100",
                "content": "# Code\\n```\\nfunc colorBorder(grid [][]int, row int, col int, color int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    directions := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}\\n    borders := make([][]int, 0, 10)\\n    queue := make([][]int, 0, 10)\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n\\n    queue = append(queue, []int{row, col})\\n    connectedValue := grid[row][col]\\n    for len(queue) > 0 {\\n        i, j := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        visited[i][j] = 1\\n        \\n        isBorder := false\\n        for _, d := range directions {\\n            di, dj := i+d[0], j+d[1]\\n            if di >= 0 && di < m && dj >= 0 && dj < n {\\n                if grid[di][dj] == connectedValue {\\n                    if visited[di][dj] == 0 {\\n                        queue = append(queue, []int{di, dj})\\n                    }\\n                } else {\\n                    isBorder = true\\n                }\\n            } else {\\n                isBorder = true\\n            }\\n        }\\n        if isBorder {\\n            borders = append(borders, []int{i, j})\\n        }\\n\\n    }\\n    for _, b := range borders {\\n        i, j := b[0], b[1]\\n        grid[i][j] = color\\n    }\\n\\n    return grid \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc colorBorder(grid [][]int, row int, col int, color int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    directions := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}\\n    borders := make([][]int, 0, 10)\\n    queue := make([][]int, 0, 10)\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n\\n    queue = append(queue, []int{row, col})\\n    connectedValue := grid[row][col]\\n    for len(queue) > 0 {\\n        i, j := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        visited[i][j] = 1\\n        \\n        isBorder := false\\n        for _, d := range directions {\\n            di, dj := i+d[0], j+d[1]\\n            if di >= 0 && di < m && dj >= 0 && dj < n {\\n                if grid[di][dj] == connectedValue {\\n                    if visited[di][dj] == 0 {\\n                        queue = append(queue, []int{di, dj})\\n                    }\\n                } else {\\n                    isBorder = true\\n                }\\n            } else {\\n                isBorder = true\\n            }\\n        }\\n        if isBorder {\\n            borders = append(borders, []int{i, j})\\n        }\\n\\n    }\\n    for _, b := range borders {\\n        i, j := b[0], b[1]\\n        grid[i][j] = color\\n    }\\n\\n    return grid \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011082,
                "title": "easy-java-dfs-with-comments",
                "content": "# Intuition\\n4 directions neighbor tells if a cell is border or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private boolean[][] visited;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        visited = new boolean[m][n];\\n        process(grid, row, col, grid[row][col], color);\\n        return grid;\\n    }\\n\\n    private int process(int[][] grid, int row, int col, int origColor, int color) {\\n        // out of bundary\\n        if (row < 0 || row >= m || col < 0 || col >= n) {\\n            return 0;\\n        }\\n\\n        // already visited\\n        if (visited[row][col]) {\\n            return 1;\\n        }\\n\\n        // different color\\n        if (grid[row][col] != origColor) {\\n            return 0;\\n        }\\n\\n        visited[row][col] = true;\\n\\n        // sum up score from 4 directions\\n        int score = process(grid, row - 1, col, origColor, color) + process(grid, row, col + 1, origColor, color) + process(grid, row + 1, col, origColor, color) + process(grid, row, col - 1, origColor, color);\\n\\n        // if score is less than 4, the cell (x, y) is a border\\n        if (score < 4) {\\n            grid[row][col] = color;\\n        }\\n\\n        // inner component cell, return 1 \\n        return 1;\\n    }\\n}\\n\\n\\n/*\\n\\nKey point is to understand what \"border\" is.\\n1. a border cell must belong to connected component \\n2. a border cell is either:\\n    a. connected to a different color cell\\n    b. boundary\\n\\ne.g.\\n\\n[0, 0, 0]\\n[1, 1, 1]\\n[1, 1, 1]\\n[1, 1, 1]\\n\\nrow = 2, col = 1, color = 2\\ncell(2, 1) \\n\\n[0, 0, 0]\\n[2, 2, 2]\\n[2, 1, 2]\\n[2, 2, 2]\\n\\nfor a cell (x, y)\\nif it\\'s inner component, it is surrounded by 4 same-color cells\\nif it\\'s border,\\n    1. it\\'s bundary\\n    2. it\\'s connected to a different color\\n\\nto determine if a cell(x, y) is inner component, we can ask its surranders.\\nif a surrander is same color, it returns 1\\notherwise, bundary returns 0, different color returns 0.\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private boolean[][] visited;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        visited = new boolean[m][n];\\n        process(grid, row, col, grid[row][col], color);\\n        return grid;\\n    }\\n\\n    private int process(int[][] grid, int row, int col, int origColor, int color) {\\n        // out of bundary\\n        if (row < 0 || row >= m || col < 0 || col >= n) {\\n            return 0;\\n        }\\n\\n        // already visited\\n        if (visited[row][col]) {\\n            return 1;\\n        }\\n\\n        // different color\\n        if (grid[row][col] != origColor) {\\n            return 0;\\n        }\\n\\n        visited[row][col] = true;\\n\\n        // sum up score from 4 directions\\n        int score = process(grid, row - 1, col, origColor, color) + process(grid, row, col + 1, origColor, color) + process(grid, row + 1, col, origColor, color) + process(grid, row, col - 1, origColor, color);\\n\\n        // if score is less than 4, the cell (x, y) is a border\\n        if (score < 4) {\\n            grid[row][col] = color;\\n        }\\n\\n        // inner component cell, return 1 \\n        return 1;\\n    }\\n}\\n\\n\\n/*\\n\\nKey point is to understand what \"border\" is.\\n1. a border cell must belong to connected component \\n2. a border cell is either:\\n    a. connected to a different color cell\\n    b. boundary\\n\\ne.g.\\n\\n[0, 0, 0]\\n[1, 1, 1]\\n[1, 1, 1]\\n[1, 1, 1]\\n\\nrow = 2, col = 1, color = 2\\ncell(2, 1) \\n\\n[0, 0, 0]\\n[2, 2, 2]\\n[2, 1, 2]\\n[2, 2, 2]\\n\\nfor a cell (x, y)\\nif it\\'s inner component, it is surrounded by 4 same-color cells\\nif it\\'s border,\\n    1. it\\'s bundary\\n    2. it\\'s connected to a different color\\n\\nto determine if a cell(x, y) is inner component, we can ask its surranders.\\nif a surrander is same color, it returns 1\\notherwise, bundary returns 0, different color returns 0.\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991007,
                "title": "simple-c-solution-by-breaking-into-steps",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n , m;\\n    void markMinusOne(int i , int j , int color , vector<vector<int>> &grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=color) return;\\n\\n        grid[i][j] = -1;\\n\\n        markMinusOne(i+1 , j , color, grid);\\n        markMinusOne(i-1 , j , color, grid);\\n        markMinusOne(i , j+1 , color, grid);\\n        markMinusOne(i , j-1 , color, grid);\\n    }\\n\\n\\n\\n    bool isSurrounded(int i , int j , vector<vector<int>>&grid){\\n        if(i==0 or  j==0 or  i==n-1 or  j==m-1) return false;\\n        if(i!=0 && !(grid[i-1][j]==-1 or grid[i-1][j]==0)) return false;\\n        if(j!=0 && !(grid[i][j-1]==-1 or grid[i][j-1]==0)) return false;\\n        if(i!=n-1 && !(grid[i+1][j]==-1 or grid[i+1][j]==0)) return false;\\n        if(j!=m-1 && !(grid[i][j+1]==-1 or grid[i][j+1]==0)) return false;\\n        return true;\\n    }\\n\\n    void undoInner(int i , int j ,int color ,vector<vector<bool>>&vis  ,vector<vector<int>>&grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=-1 or vis[i][j]) return;\\n        vis[i][j] = true;\\n\\n        if(isSurrounded(i , j , grid)){\\n            grid[i][j] = 0;\\n        }\\n\\n        undoInner(i+1 , j , color, vis ,grid);\\n        undoInner(i-1 , j , color, vis ,grid);\\n        undoInner(i , j+1 , color,  vis ,grid);\\n        undoInner(i , j-1 , color, vis ,grid);\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int x = grid[row][col];\\n        n = grid.size();\\n        m = grid[0].size();\\n        // -1 -> with color x\\n        // 0 -> inner x within the component\\n\\n        // marking the x as -1 in the connected component\\n        markMinusOne(row , col , x , grid);\\n\\n        // marking the inner x as 0 in the connected component\\n        vector<vector<bool>> vis(n , vector<bool>(m , false));\\n        undoInner(row , col , x , vis ,grid);\\n\\n        // coloring the -1 with color in the connected component and inner blocks as x\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(grid[i][j]==-1)grid[i][j] = color;\\n                if(grid[i][j]==0) grid[i][j] = x;\\n            }\\n        }\\n\\n\\n        // returning the final grid\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n , m;\\n    void markMinusOne(int i , int j , int color , vector<vector<int>> &grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=color) return;\\n\\n        grid[i][j] = -1;\\n\\n        markMinusOne(i+1 , j , color, grid);\\n        markMinusOne(i-1 , j , color, grid);\\n        markMinusOne(i , j+1 , color, grid);\\n        markMinusOne(i , j-1 , color, grid);\\n    }\\n\\n\\n\\n    bool isSurrounded(int i , int j , vector<vector<int>>&grid){\\n        if(i==0 or  j==0 or  i==n-1 or  j==m-1) return false;\\n        if(i!=0 && !(grid[i-1][j]==-1 or grid[i-1][j]==0)) return false;\\n        if(j!=0 && !(grid[i][j-1]==-1 or grid[i][j-1]==0)) return false;\\n        if(i!=n-1 && !(grid[i+1][j]==-1 or grid[i+1][j]==0)) return false;\\n        if(j!=m-1 && !(grid[i][j+1]==-1 or grid[i][j+1]==0)) return false;\\n        return true;\\n    }\\n\\n    void undoInner(int i , int j ,int color ,vector<vector<bool>>&vis  ,vector<vector<int>>&grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=-1 or vis[i][j]) return;\\n        vis[i][j] = true;\\n\\n        if(isSurrounded(i , j , grid)){\\n            grid[i][j] = 0;\\n        }\\n\\n        undoInner(i+1 , j , color, vis ,grid);\\n        undoInner(i-1 , j , color, vis ,grid);\\n        undoInner(i , j+1 , color,  vis ,grid);\\n        undoInner(i , j-1 , color, vis ,grid);\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int x = grid[row][col];\\n        n = grid.size();\\n        m = grid[0].size();\\n        // -1 -> with color x\\n        // 0 -> inner x within the component\\n\\n        // marking the x as -1 in the connected component\\n        markMinusOne(row , col , x , grid);\\n\\n        // marking the inner x as 0 in the connected component\\n        vector<vector<bool>> vis(n , vector<bool>(m , false));\\n        undoInner(row , col , x , vis ,grid);\\n\\n        // coloring the -1 with color in the connected component and inner blocks as x\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(grid[i][j]==-1)grid[i][j] = color;\\n                if(grid[i][j]==0) grid[i][j] = x;\\n            }\\n        }\\n\\n\\n        // returning the final grid\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981040,
                "title": "java-solution-0ms-100-faster",
                "content": "Start **DFS** from current point \\n-> If current point is on border of the matrix,mark it with border color\\n->Check 4 directions, If a non-same region,non-border element found,mark current point with border color\\n\\nNote:Here, **```borderValidity```** is a number indicating number of foreign regions or grid borders are in the neighborhood of current cell\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        dfs(grid,row,col,grid.length,grid[0].length,\\n        color,grid[row][col],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n\\n   int dfs(int[][] arr,int i,int j,int row,int col,\\n    int borderColor,int regionColor,boolean[][] visited){\\n        if(i<0 || i>=row || j<0 || j>=col) return 1;\\n        if(visited[i][j]) return 0;\\n        if(arr[i][j]!=regionColor) return 1;\\n        visited[i][j] = true;\\n\\n        int borderValidity = 0;\\n        borderValidity+=dfs(arr,i+1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j+1,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i-1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j-1,row,col,borderColor,regionColor,visited);\\n\\n        if(borderValidity>0) arr[i][j] = borderColor;\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```borderValidity```\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        dfs(grid,row,col,grid.length,grid[0].length,\\n        color,grid[row][col],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n\\n   int dfs(int[][] arr,int i,int j,int row,int col,\\n    int borderColor,int regionColor,boolean[][] visited){\\n        if(i<0 || i>=row || j<0 || j>=col) return 1;\\n        if(visited[i][j]) return 0;\\n        if(arr[i][j]!=regionColor) return 1;\\n        visited[i][j] = true;\\n\\n        int borderValidity = 0;\\n        borderValidity+=dfs(arr,i+1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j+1,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i-1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j-1,row,col,borderColor,regionColor,visited);\\n\\n        if(borderValidity>0) arr[i][j] = borderColor;\\n        return 0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937057,
                "title": "beats-98-8-1-ms-java-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# We should color the cell iff:\\n- The cell is on the grid border\\n- or any of its neighbours does not have the same color\\n\\n# Complexity\\n- Time complexity: O(nxm) won\\'t visit the same cell more than once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nxm) for the visited array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, row, col, color, visited);\\n    }\\n    public int[][] dfs(int[][] grid, int row, int col, int color, boolean[][] visited){\\n        visited[row][col] = true;\\n        boolean isBoundry = false;\\n        if(row == 0 || row == grid.length - 1 || col == 0 || col == grid[0].length - 1)\\n            isBoundry = true;\\n        int[] rd = {1, 0, -1, 0};\\n        int[] cd = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++){\\n            int newRow = row + rd[i];\\n            int newCol = col + cd[i];\\n            if(isValid(grid, newRow, newCol) && !visited[newRow][newCol]){\\n                if(grid[newRow][newCol] == grid[row][col])\\n                    dfs(grid, newRow, newCol, color, visited);\\n                else isBoundry = true;\\n            }\\n        }\\n        if(isBoundry) grid[row][col] = color;\\n        return grid;\\n    }\\n    public boolean isValid(int[][] grid, int row, int col){\\n        return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, row, col, color, visited);\\n    }\\n    public int[][] dfs(int[][] grid, int row, int col, int color, boolean[][] visited){\\n        visited[row][col] = true;\\n        boolean isBoundry = false;\\n        if(row == 0 || row == grid.length - 1 || col == 0 || col == grid[0].length - 1)\\n            isBoundry = true;\\n        int[] rd = {1, 0, -1, 0};\\n        int[] cd = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++){\\n            int newRow = row + rd[i];\\n            int newCol = col + cd[i];\\n            if(isValid(grid, newRow, newCol) && !visited[newRow][newCol]){\\n                if(grid[newRow][newCol] == grid[row][col])\\n                    dfs(grid, newRow, newCol, color, visited);\\n                else isBoundry = true;\\n            }\\n        }\\n        if(isBoundry) grid[row][col] = color;\\n        return grid;\\n    }\\n    public boolean isValid(int[][] grid, int row, int col){\\n        return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914741,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} row\\n * @param {number} col\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar colorBorder = function(grid, row, col, color) {\\n    const borderCells = getSolution(grid, row, col, color)()\\n\\n    for(let i=0; i < borderCells.length; i++){\\n        const {row,col} = borderCells[i]\\n\\n        grid[row][col] = color\\n    }\\n\\n    return grid\\n};\\n\\nfunction getSolution(grid, row, col, color){\\n    const visited = {}\\n    const borderCells = []\\n\\n    const componentColor = grid[row][col]\\n    return function(){\\n        const queue = [{row,col}]\\n\\n        while (queue.length) {\\n            const currentPos = queue.shift();\\n            visited[`${currentPos.row}|${currentPos.col}`] = true\\n\\n            if (isABorderCell(currentPos, grid)) {\\n                borderCells.push(currentPos);\\n            }\\n\\n            queue.push(\\n                ...getNeighbouringCells(currentPos, grid).filter(\\n                    pos =>\\n                        Boolean(pos) &&\\n                        visited[`${pos.row}|${pos.col}`] !== true &&\\n                        grid[pos.row][pos.col] === componentColor\\n                )\\n            );\\n        }\\n\\n        return borderCells\\n    }\\n}\\n\\nfunction isABorderCell({ row, col }, grid) {\\n  return (\\n    row === 0 ||\\n    col === 0 ||\\n    row === grid.length - 1 ||\\n    col === grid[0].length - 1 ||\\n    (\\n        grid[row - 1][col] !== grid[row][col]\\n        || grid[row + 1][col] !== grid[row][col]\\n        || grid[row][col - 1] !== grid[row][col]\\n        || grid[row][col + 1] !== grid[row][col]\\n    )\\n  );\\n}\\n\\nfunction getNeighbouringCells({ row, col }, grid){\\n    return [\\n        getNextPos(\"l\", { row, col }, grid),\\n        getNextPos(\"r\", { row, col }, grid),\\n        getNextPos(\"u\", { row, col }, grid),\\n        getNextPos(\"d\", { row, col }, grid),\\n    ]\\n}\\n\\nfunction getNextPos(dir, { row, col }, grid) {\\n  if (dir === \"l\") {\\n    if (col - 1 >= 0) return { row, col: col - 1 };\\n  } else if (dir === \"r\") {\\n    if (col + 1 < grid[0].length) return { row, col: col + 1 };\\n  } else if (dir === \"u\") {\\n    if (row - 1 >= 0) return { row: row - 1, col };\\n  } else if (dir === \"d\") {\\n    if (row + 1 < grid.length) return { row: row + 1, col };\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} row\\n * @param {number} col\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar colorBorder = function(grid, row, col, color) {\\n    const borderCells = getSolution(grid, row, col, color)()\\n\\n    for(let i=0; i < borderCells.length; i++){\\n        const {row,col} = borderCells[i]\\n\\n        grid[row][col] = color\\n    }\\n\\n    return grid\\n};\\n\\nfunction getSolution(grid, row, col, color){\\n    const visited = {}\\n    const borderCells = []\\n\\n    const componentColor = grid[row][col]\\n    return function(){\\n        const queue = [{row,col}]\\n\\n        while (queue.length) {\\n            const currentPos = queue.shift();\\n            visited[`${currentPos.row}|${currentPos.col}`] = true\\n\\n            if (isABorderCell(currentPos, grid)) {\\n                borderCells.push(currentPos);\\n            }\\n\\n            queue.push(\\n                ...getNeighbouringCells(currentPos, grid).filter(\\n                    pos =>\\n                        Boolean(pos) &&\\n                        visited[`${pos.row}|${pos.col}`] !== true &&\\n                        grid[pos.row][pos.col] === componentColor\\n                )\\n            );\\n        }\\n\\n        return borderCells\\n    }\\n}\\n\\nfunction isABorderCell({ row, col }, grid) {\\n  return (\\n    row === 0 ||\\n    col === 0 ||\\n    row === grid.length - 1 ||\\n    col === grid[0].length - 1 ||\\n    (\\n        grid[row - 1][col] !== grid[row][col]\\n        || grid[row + 1][col] !== grid[row][col]\\n        || grid[row][col - 1] !== grid[row][col]\\n        || grid[row][col + 1] !== grid[row][col]\\n    )\\n  );\\n}\\n\\nfunction getNeighbouringCells({ row, col }, grid){\\n    return [\\n        getNextPos(\"l\", { row, col }, grid),\\n        getNextPos(\"r\", { row, col }, grid),\\n        getNextPos(\"u\", { row, col }, grid),\\n        getNextPos(\"d\", { row, col }, grid),\\n    ]\\n}\\n\\nfunction getNextPos(dir, { row, col }, grid) {\\n  if (dir === \"l\") {\\n    if (col - 1 >= 0) return { row, col: col - 1 };\\n  } else if (dir === \"r\") {\\n    if (col + 1 < grid[0].length) return { row, col: col + 1 };\\n  } else if (dir === \"u\") {\\n    if (row - 1 >= 0) return { row: row - 1, col };\\n  } else if (dir === \"d\") {\\n    if (row + 1 < grid.length) return { row: row + 1, col };\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908771,
                "title": "python-3-dfs-quite-simple-solution-with-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/0eb25c3a-eb99-4568-8ea1-9d9e8a3e822f_1670961669.9535344.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        visited, changed = set(), set()\\n        stack = deque()\\n        \\n        color_initial = grid[row][col]\\n        row_n, col_n  = len(grid), len(grid[0])\\n        \\n        # add initial cell to stack\\n        stack.append([row, col])\\n        while stack:\\n            r, c = stack.pop()\\n            if (r, c) in visited:   continue\\n            visited.add((r, c))\\n\\n            ind_brd = False   # indicator of border \\n            for r_dlt, c_dlt in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\\n                if 0 <= r + r_dlt < row_n and \\\\\\n                   0 <= c + c_dlt < col_n: \\n                    \\n                    new_cell = grid[r + r_dlt][c + c_dlt]\\n\\n                    # cell on boundary of the grid     or\\n                    # adjacent cell has another color  --> ind = True\\n                    if r in (0, row_n - 1) or \\\\\\n                       c in (0, col_n - 1) or  new_cell != color_initial:\\n                        ind_brd = True\\n                    \\n                    # cell has the same color --> add to stack \\n                    if new_cell == color_initial:\\n                        stack.append([r + r_dlt, c + c_dlt])\\n\\n            # we should change color in the end, otherwise we could paint cells inside              \\n            # add cell to the set\\n            if ind_brd:\\n                changed.add((r, c))\\n        \\n        # paint borders\\n        for (r, c) in changed:\\n            grid[r][c] = color\\n\\n        return grid\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        visited, changed = set(), set()\\n        stack = deque()\\n        \\n        color_initial = grid[row][col]\\n        row_n, col_n  = len(grid), len(grid[0])\\n        \\n        # add initial cell to stack\\n        stack.append([row, col])\\n        while stack:\\n            r, c = stack.pop()\\n            if (r, c) in visited:   continue\\n            visited.add((r, c))\\n\\n            ind_brd = False   # indicator of border \\n            for r_dlt, c_dlt in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\\n                if 0 <= r + r_dlt < row_n and \\\\\\n                   0 <= c + c_dlt < col_n: \\n                    \\n                    new_cell = grid[r + r_dlt][c + c_dlt]\\n\\n                    # cell on boundary of the grid     or\\n                    # adjacent cell has another color  --> ind = True\\n                    if r in (0, row_n - 1) or \\\\\\n                       c in (0, col_n - 1) or  new_cell != color_initial:\\n                        ind_brd = True\\n                    \\n                    # cell has the same color --> add to stack \\n                    if new_cell == color_initial:\\n                        stack.append([r + r_dlt, c + c_dlt])\\n\\n            # we should change color in the end, otherwise we could paint cells inside              \\n            # add cell to the set\\n            if ind_brd:\\n                changed.add((r, c))\\n        \\n        # paint borders\\n        for (r, c) in changed:\\n            grid[r][c] = color\\n\\n        return grid\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862569,
                "title": "java-solution-bfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair {\\n    int row;\\n    int col;\\n\\n    public Pair(int row, int col)\\n    {\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int vis[][] = new int [r][c];\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.add(new Pair(row , col));\\n        vis[row][col]=1;\\n        int val = grid[row][col];\\n        int ans[][] = new int[r][c];\\n\\n        for(int i=0; i< r; i++)\\n        {\\n            for(int j=0; j< c ; j++)\\n            {\\n                ans[i][j]= grid[i][j];\\n            }\\n        }\\n\\n\\n        int delRow [] = {-1,0,0,1};\\n        int delCol [] = {0,1,-1,0};\\n\\n\\n        while(!queue.isEmpty())\\n        {\\n            int qr = queue.peek().row;\\n            int qc = queue.peek().col;\\n            queue.remove();\\n            int cnt = 0;\\n            for(int i=0; i<4 ; i++)\\n            {\\n                int nrow = qr + delRow[i];\\n                int ncol = qc + delCol[i];\\n\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && vis[nrow][ncol] != 1 && grid[nrow][ncol] == val)\\n                {\\n                  queue.add(new Pair(nrow, ncol));\\n                  vis[nrow][ncol] =1;\\n                \\n                }\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && grid[nrow][ncol] == val)\\n                {\\n                  cnt++;              \\n                }\\n            }\\n            if(cnt != 4)\\n            {\\n               ans[qr][qc] = color;\\n            }\\n             \\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair {\\n    int row;\\n    int col;\\n\\n    public Pair(int row, int col)\\n    {\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int vis[][] = new int [r][c];\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.add(new Pair(row , col));\\n        vis[row][col]=1;\\n        int val = grid[row][col];\\n        int ans[][] = new int[r][c];\\n\\n        for(int i=0; i< r; i++)\\n        {\\n            for(int j=0; j< c ; j++)\\n            {\\n                ans[i][j]= grid[i][j];\\n            }\\n        }\\n\\n\\n        int delRow [] = {-1,0,0,1};\\n        int delCol [] = {0,1,-1,0};\\n\\n\\n        while(!queue.isEmpty())\\n        {\\n            int qr = queue.peek().row;\\n            int qc = queue.peek().col;\\n            queue.remove();\\n            int cnt = 0;\\n            for(int i=0; i<4 ; i++)\\n            {\\n                int nrow = qr + delRow[i];\\n                int ncol = qc + delCol[i];\\n\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && vis[nrow][ncol] != 1 && grid[nrow][ncol] == val)\\n                {\\n                  queue.add(new Pair(nrow, ncol));\\n                  vis[nrow][ncol] =1;\\n                \\n                }\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && grid[nrow][ncol] == val)\\n                {\\n                  cnt++;              \\n                }\\n            }\\n            if(cnt != 4)\\n            {\\n               ans[qr][qc] = color;\\n            }\\n             \\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861615,
                "title": "simple-solution-in-c-using-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\nbool solve(int i,int j,vector<vector<int>>&grid,int color,int n,int m,int t,vector<vector<bool>>&visited)\\n{\\n    if(i<0||j<0||i==n||j==m||grid[i][j]!=t||visited[i][j])\\n    return false;\\n    visited[i][j]=true;\\n    bool bod=false;\\n    if(i==0||j==0||i==n-1||j==m-1||grid[i-1][j]!=t||grid[i+1][j]!=t||grid[i][j-1]!=t||grid[i][j+1]!=t)\\n    bod=true ;\\n    solve(i-1,j,grid,color,n,m,t,visited);\\n    solve(i+1,j,grid,color,n,m,t,visited);\\n    solve(i,j-1,grid,color,n,m,t,visited);\\n    solve(i,j+1,grid,color,n,m,t,visited);\\n    if(bod)\\n    grid[i][j]=color;\\n    return bod;\\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size(),m=grid[0].size(),t=grid[row][col];\\n        if(grid[row][col]==color)\\n        return grid;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        solve(row,col,grid,color,n,m,t,visited);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\nbool solve(int i,int j,vector<vector<int>>&grid,int color,int n,int m,int t,vector<vector<bool>>&visited)\\n{\\n    if(i<0||j<0||i==n||j==m||grid[i][j]!=t||visited[i][j])\\n    return false;\\n    visited[i][j]=true;\\n    bool bod=false;\\n    if(i==0||j==0||i==n-1||j==m-1||grid[i-1][j]!=t||grid[i+1][j]!=t||grid[i][j-1]!=t||grid[i][j+1]!=t)\\n    bod=true ;\\n    solve(i-1,j,grid,color,n,m,t,visited);\\n    solve(i+1,j,grid,color,n,m,t,visited);\\n    solve(i,j-1,grid,color,n,m,t,visited);\\n    solve(i,j+1,grid,color,n,m,t,visited);\\n    if(bod)\\n    grid[i][j]=color;\\n    return bod;\\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size(),m=grid[0].size(),t=grid[row][col];\\n        if(grid[row][col]==color)\\n        return grid;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        solve(row,col,grid,color,n,m,t,visited);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848632,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis type of problem, it is good to use recursion. isSafe is very important to have this function for further move and identyfy the boundary.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursion move to adjacent block\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    bool isBoundary(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, const int& myColor) {\\n        if (row < 0 || col < 0 || row >= ROWS || col >= COLS) {\\n            return true;\\n        } else if (grid[row][col] != myColor) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void markBoundary(vector<vector<int> >& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<int>>& maze) {\\n        if (isBoundary(grid, row, col - 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row, col + 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row - 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row + 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int myColor, vector<vector<bool> >& visited) {\\n        if (row >= 0 && col >= 0 && row < ROWS && col < COLS && grid[row][col] == myColor && !visited[row][col]) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void colorGrid(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<bool> >& visited, vector<vector<int> >& maze) {\\n        visited[row][col] = true;\\n        markBoundary(grid, row, col, ROWS, COLS, color, myColor, maze);\\n        if (isSafe(grid, row - 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row - 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row + 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row + 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col - 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col - 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col + 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col + 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        vector<bool> vc(COLS, false);\\n        vector<vector<bool> > visited(ROWS, vc);\\n        const int myColor = grid[row][col];\\n        vector<vector<int> > maze = grid;\\n        colorGrid(grid, row, col, ROWS, COLS, color, myColor, visited, maze);\\n        return maze;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isBoundary(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, const int& myColor) {\\n        if (row < 0 || col < 0 || row >= ROWS || col >= COLS) {\\n            return true;\\n        } else if (grid[row][col] != myColor) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void markBoundary(vector<vector<int> >& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<int>>& maze) {\\n        if (isBoundary(grid, row, col - 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row, col + 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row - 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row + 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int myColor, vector<vector<bool> >& visited) {\\n        if (row >= 0 && col >= 0 && row < ROWS && col < COLS && grid[row][col] == myColor && !visited[row][col]) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void colorGrid(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<bool> >& visited, vector<vector<int> >& maze) {\\n        visited[row][col] = true;\\n        markBoundary(grid, row, col, ROWS, COLS, color, myColor, maze);\\n        if (isSafe(grid, row - 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row - 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row + 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row + 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col - 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col - 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col + 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col + 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        vector<bool> vc(COLS, false);\\n        vector<vector<bool> > visited(ROWS, vc);\\n        const int myColor = grid[row][col];\\n        vector<vector<int> > maze = grid;\\n        colorGrid(grid, row, col, ROWS, COLS, color, myColor, visited, maze);\\n        return maze;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833475,
                "title": "simple-dfs-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursive(vector<vector<int>>& grid, vector<vector<int>>& ans, int row, int col, int color, int comp, vector<vector<int>>& visited){\\n        if(row>=grid.size() || row<0 || col>=grid[0].size() || col<0 || grid[row][col]!=comp || visited[row][col]) return;\\n\\n        visited[row][col] = 1;\\n        if(row<1 || col<1 || row==grid.size()-1 || col==grid[0].size()-1 || grid[row+1][col]!=comp || grid[row-1][col]!=comp || grid[row][col+1]!=comp || grid[row][col-1]!=comp)\\n        ans[row][col] = color;\\n\\n        recursive(grid, ans, row+1, col, color, comp, visited);\\n        recursive(grid, ans, row-1, col, color, comp, visited);\\n        recursive(grid, ans, row, col+1, color, comp, visited);\\n        recursive(grid, ans, row, col-1, color, comp, visited);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int component = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        recursive(grid, ans, row, col, color, component, visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursive(vector<vector<int>>& grid, vector<vector<int>>& ans, int row, int col, int color, int comp, vector<vector<int>>& visited){\\n        if(row>=grid.size() || row<0 || col>=grid[0].size() || col<0 || grid[row][col]!=comp || visited[row][col]) return;\\n\\n        visited[row][col] = 1;\\n        if(row<1 || col<1 || row==grid.size()-1 || col==grid[0].size()-1 || grid[row+1][col]!=comp || grid[row-1][col]!=comp || grid[row][col+1]!=comp || grid[row][col-1]!=comp)\\n        ans[row][col] = color;\\n\\n        recursive(grid, ans, row+1, col, color, comp, visited);\\n        recursive(grid, ans, row-1, col, color, comp, visited);\\n        recursive(grid, ans, row, col+1, color, comp, visited);\\n        recursive(grid, ans, row, col-1, color, comp, visited);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int component = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        recursive(grid, ans, row, col, color, component, visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832809,
                "title": "simple-dfs-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<vector<int>> ans;\\n    bool isValid(int r, int c)\\n    {\\n        if(r<0 || c<0 || r==rows || c==cols) return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>> &vis, int co, int r, int c, int color)\\n    {\\n        vis[r][c]=1;\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        for(int x=0; x<4; x++)\\n        {\\n            int dr=r+directions[x][0], dc=c+directions[x][1];\\n            if(isValid(dr,dc) && grid[dr][dc]==co) \\n            {\\n                if(!vis[dr][dc]) dfs(grid,vis,co,dr,dc,color);\\n            }\\n            else if(!isValid(dr,dc) || (isValid(dr,dc) && grid[dr][dc]!=co)) ans[r][c]=color;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) \\n    {\\n        ans=grid;\\n        int co=grid[row][col];\\n        rows=grid.size(), cols=grid[0].size();\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        dfs(grid,vis,co,row,col,color);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<vector<int>> ans;\\n    bool isValid(int r, int c)\\n    {\\n        if(r<0 || c<0 || r==rows || c==cols) return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>> &vis, int co, int r, int c, int color)\\n    {\\n        vis[r][c]=1;\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        for(int x=0; x<4; x++)\\n        {\\n            int dr=r+directions[x][0], dc=c+directions[x][1];\\n            if(isValid(dr,dc) && grid[dr][dc]==co) \\n            {\\n                if(!vis[dr][dc]) dfs(grid,vis,co,dr,dc,color);\\n            }\\n            else if(!isValid(dr,dc) || (isValid(dr,dc) && grid[dr][dc]!=co)) ans[r][c]=color;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) \\n    {\\n        ans=grid;\\n        int co=grid[row][col];\\n        rows=grid.size(), cols=grid[0].size();\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        dfs(grid,vis,co,row,col,color);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832752,
                "title": "dfs",
                "content": "# Intuition\\nsimple dfs\\n\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,int c,vector<vector<int>>& grid,vector<vector<int>>& vis,int m,int n,int color,vector<vector<int>>&ans)\\n    {\\n        vis[row][col]=1;\\n        int di[]={-1,1,0,0};\\n        int dj[]={0,0,-1,1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ni=row+di[i];\\n            int nj=col+dj[i];\\n            if (ni<m && nj<n && ni>=0 && nj>=0 && grid[ni][nj]==c)\\n            {\\n                if (!vis[ni][nj])\\n                {\\n                dfs(ni,nj,c,grid,vis,m,n,color,ans);\\n                }\\n            }\\n            else{\\n               ans[row][col]=color;\\n                \\n            }\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     vector<vector<int>>ans(m,vector<int>(n,-1));\\n     int c=grid[row][col];\\n      dfs(row,col,c,grid,vis,m,n,color,ans);\\n      for (int i=0;i<m;i++)\\n      {\\n          for (int j=0;j<n;j++)\\n          {\\n              if (ans[i][j]==-1)\\n              {\\n                  ans[i][j]=grid[i][j];\\n              }\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,int c,vector<vector<int>>& grid,vector<vector<int>>& vis,int m,int n,int color,vector<vector<int>>&ans)\\n    {\\n        vis[row][col]=1;\\n        int di[]={-1,1,0,0};\\n        int dj[]={0,0,-1,1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ni=row+di[i];\\n            int nj=col+dj[i];\\n            if (ni<m && nj<n && ni>=0 && nj>=0 && grid[ni][nj]==c)\\n            {\\n                if (!vis[ni][nj])\\n                {\\n                dfs(ni,nj,c,grid,vis,m,n,color,ans);\\n                }\\n            }\\n            else{\\n               ans[row][col]=color;\\n                \\n            }\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     vector<vector<int>>ans(m,vector<int>(n,-1));\\n     int c=grid[row][col];\\n      dfs(row,col,c,grid,vis,m,n,color,ans);\\n      for (int i=0;i<m;i++)\\n      {\\n          for (int j=0;j<n;j++)\\n          {\\n              if (ans[i][j]==-1)\\n              {\\n                  ans[i][j]=grid[i][j];\\n              }\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829527,
                "title": "beats-99-java-easy-solution-dfs-graph",
                "content": "```\\nclass Solution {\\n    int initial = 0;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visi = new boolean[grid.length][grid[0].length];\\n        initial = grid[row][col];\\n        call(grid,row,col,color,visi);\\n        \\n        return grid;\\n    }\\n    \\n    public boolean  call(int[][] grid,int i,int j,int color,boolean[][] visi){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length){\\n            return true;\\n        }\\n        if(visi[i][j] == true)return false;\\n        \\n        if(grid[i][j] != initial){\\n            return true;\\n        }\\n        \\n        \\n        visi[i][j] = true;      \\n        boolean r = call(grid,i,j + 1,color,visi);\\n        boolean d = call(grid,i + 1,j,color,visi);\\n        boolean u = call(grid,i - 1,j,color,visi);\\n        boolean l = call(grid,i,j - 1,color,visi);\\n        \\n        if(r || d || u || l){\\n            grid[i][j] = color;\\n        }\\n       \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int initial = 0;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visi = new boolean[grid.length][grid[0].length];\\n        initial = grid[row][col];\\n        call(grid,row,col,color,visi);\\n        \\n        return grid;\\n    }\\n    \\n    public boolean  call(int[][] grid,int i,int j,int color,boolean[][] visi){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length){\\n            return true;\\n        }\\n        if(visi[i][j] == true)return false;\\n        \\n        if(grid[i][j] != initial){\\n            return true;\\n        }\\n        \\n        \\n        visi[i][j] = true;      \\n        boolean r = call(grid,i,j + 1,color,visi);\\n        boolean d = call(grid,i + 1,j,color,visi);\\n        boolean u = call(grid,i - 1,j,color,visi);\\n        boolean l = call(grid,i,j - 1,color,visi);\\n        \\n        if(r || d || u || l){\\n            grid[i][j] = color;\\n        }\\n       \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808321,
                "title": "java-dfs",
                "content": "# Intuition\\nwe will make DFS on the graph and make a flage to check for each nodes if it totally have 4  neighbors with th same color if it does not, this means it is a boundary so we should change its color.\\n# Approach\\nDepth First Search \\n# Complexity\\n- Time complexity:\\nO(n*m + E)\\n- Space complexity:\\nO(n*m) due to recursive calls\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color)\\n    {\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n\\n        \\n    }\\n\\n    public int dfs(int[][] grid, int row, int col,int targetColor, int newColor, Set<Integer> visited)\\n    {\\n        if(visited.contains(row*50+col))\\n        return 1;\\n        if(row<0||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]!=targetColor)\\n        return 0;\\n\\n        int flag = 1;\\n        visited.add(row*50+col);\\n        flag*=dfs(grid,row-1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row+1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col-1,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col+1,targetColor,newColor,visited);\\n\\n        if(flag==0)\\n        grid[row][col] = newColor;\\n\\n        return 1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color)\\n    {\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n\\n        \\n    }\\n\\n    public int dfs(int[][] grid, int row, int col,int targetColor, int newColor, Set<Integer> visited)\\n    {\\n        if(visited.contains(row*50+col))\\n        return 1;\\n        if(row<0||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]!=targetColor)\\n        return 0;\\n\\n        int flag = 1;\\n        visited.add(row*50+col);\\n        flag*=dfs(grid,row-1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row+1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col-1,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col+1,targetColor,newColor,visited);\\n\\n        if(flag==0)\\n        grid[row][col] = newColor;\\n\\n        return 1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805987,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        dfs(grid , row , col , grid[row][col]);\\n        for(int i = 0 ; i < grid.length ; i++){\\n            for(int j = 0 ; j < grid[0].length ; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    int[][] dirs = {{1,0} , {0,1}, {-1,0},{0,-1}};\\n    public void dfs(int[][] grid , int row, int col , int clr){\\n        \\n        grid[row][col] = -clr;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < 4 ; i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash < 0 || coldash < 0 || rowdash >= grid.length || coldash >= grid[0].length || Math.abs(grid[rowdash][coldash]) != clr){\\n                continue;\\n            } \\n            \\n                count++;\\n                if(grid[rowdash][coldash] == clr){\\n                    dfs(grid,rowdash , coldash,clr);\\n                }       \\n        }\\n        \\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        dfs(grid , row , col , grid[row][col]);\\n        for(int i = 0 ; i < grid.length ; i++){\\n            for(int j = 0 ; j < grid[0].length ; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    int[][] dirs = {{1,0} , {0,1}, {-1,0},{0,-1}};\\n    public void dfs(int[][] grid , int row, int col , int clr){\\n        \\n        grid[row][col] = -clr;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < 4 ; i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash < 0 || coldash < 0 || rowdash >= grid.length || coldash >= grid[0].length || Math.abs(grid[rowdash][coldash]) != clr){\\n                continue;\\n            } \\n            \\n                count++;\\n                if(grid[rowdash][coldash] == clr){\\n                    dfs(grid,rowdash , coldash,clr);\\n                }       \\n        }\\n        \\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788861,
                "title": "java-solution-beats-98",
                "content": "```\\n\\n /**\\n     * [1,1,1],\\n     * [1,1,1],\\n     * [1,1,1]\\n     * @param grid\\n     * @param row\\n     * @param col\\n     * @param color\\n     * @return\\n     */\\n public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int org = grid[row][col];\\n        colorBorder_DFS(row,col,grid,org);\\n        for(int i =0;i<grid.length;i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] < 0) grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void colorBorder_DFS(int row_i, int col_j, int[][] grid, int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row || grid[row_i][col_j] != org) return;\\n\\n        grid[row_i][col_j] = -org;\\n        colorBorder_DFS(row_i + 1, col_j, grid, org);\\n        colorBorder_DFS(row_i - 1, col_j, grid, org);\\n        colorBorder_DFS(row_i, col_j + 1, grid, org);\\n        colorBorder_DFS(row_i, col_j - 1, grid, org);\\n\\n        if (colorBorder_DFS_abs(grid, row_i + 1, col_j,org) && colorBorder_DFS_abs(grid, row_i - 1, col_j,org)\\n                && colorBorder_DFS_abs(grid, row_i, col_j + 1,org) && colorBorder_DFS_abs(grid, row_i, col_j - 1,org)) {\\n\\t\\t\\t\\t// if the val in 4-diretion is equal to the Math.abs( orginal color ), which means current location is not border, so we don\\'t need to change the color\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t-1, [1],-1\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif  the neighbor of mat[1][1]  all equal -1,  mat[1][1] still is original color 1\\n\\t\\t\\t\\t*/\\n\\t\\t\\n            grid[row_i][col_j] = org;\\n        }\\n\\n    }\\n\\n    private boolean colorBorder_DFS_abs(int[][] grid, int row_i, int col_j,int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n\\t\\t// Beyond the Boundary \\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row ) return false;\\n\\n       if(grid[row_i][col_j]  ==org ||grid[row_i][col_j]  == -org  ) return true;\\n       return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n /**\\n     * [1,1,1],\\n     * [1,1,1],\\n     * [1,1,1]\\n     * @param grid\\n     * @param row\\n     * @param col\\n     * @param color\\n     * @return\\n     */\\n public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int org = grid[row][col];\\n        colorBorder_DFS(row,col,grid,org);\\n        for(int i =0;i<grid.length;i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] < 0) grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void colorBorder_DFS(int row_i, int col_j, int[][] grid, int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row || grid[row_i][col_j] != org) return;\\n\\n        grid[row_i][col_j] = -org;\\n        colorBorder_DFS(row_i + 1, col_j, grid, org);\\n        colorBorder_DFS(row_i - 1, col_j, grid, org);\\n        colorBorder_DFS(row_i, col_j + 1, grid, org);\\n        colorBorder_DFS(row_i, col_j - 1, grid, org);\\n\\n        if (colorBorder_DFS_abs(grid, row_i + 1, col_j,org) && colorBorder_DFS_abs(grid, row_i - 1, col_j,org)\\n                && colorBorder_DFS_abs(grid, row_i, col_j + 1,org) && colorBorder_DFS_abs(grid, row_i, col_j - 1,org)) {\\n\\t\\t\\t\\t// if the val in 4-diretion is equal to the Math.abs( orginal color ), which means current location is not border, so we don\\'t need to change the color\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t-1, [1],-1\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif  the neighbor of mat[1][1]  all equal -1,  mat[1][1] still is original color 1\\n\\t\\t\\t\\t*/\\n\\t\\t\\n            grid[row_i][col_j] = org;\\n        }\\n\\n    }\\n\\n    private boolean colorBorder_DFS_abs(int[][] grid, int row_i, int col_j,int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n\\t\\t// Beyond the Boundary \\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row ) return false;\\n\\n       if(grid[row_i][col_j]  ==org ||grid[row_i][col_j]  == -org  ) return true;\\n       return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782694,
                "title": "java-easy-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nborder rules\\nany adjacent box which can not be colored\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public class Node{\\n        int i;\\n        int j;\\n        public Node(int ii,int jj)\\n        {\\n            i=ii;\\n            j=jj;\\n        }\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int comp=grid[row][col];\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        int[][] dir={{-1,0,1,0},{0,-1,0,1}};\\n        LinkedList<Node> li=new LinkedList<>();\\n        li.addFirst(new Node(row,col));\\n        while(li.size()!=0)\\n        {\\n            Node temp=li.removeFirst();\\n            visited[temp.i][temp.j]=true;\\n            for(int z=0;z<dir[0].length;z++)\\n            {\\n                int i=temp.i+dir[0][z];\\n                int j=temp.j+dir[1][z];\\n                if(i<0 || j<0 || i==grid.length || j==grid[0].length || grid[i][j]!=comp && !visited[i][j])\\n                {\\n                    grid[temp.i][temp.j]=color;\\n                    continue;\\n                }\\n                if(!visited[i][j])\\n                {\\n                    li.addFirst(new Node(i,j));\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public class Node{\\n        int i;\\n        int j;\\n        public Node(int ii,int jj)\\n        {\\n            i=ii;\\n            j=jj;\\n        }\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int comp=grid[row][col];\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        int[][] dir={{-1,0,1,0},{0,-1,0,1}};\\n        LinkedList<Node> li=new LinkedList<>();\\n        li.addFirst(new Node(row,col));\\n        while(li.size()!=0)\\n        {\\n            Node temp=li.removeFirst();\\n            visited[temp.i][temp.j]=true;\\n            for(int z=0;z<dir[0].length;z++)\\n            {\\n                int i=temp.i+dir[0][z];\\n                int j=temp.j+dir[1][z];\\n                if(i<0 || j<0 || i==grid.length || j==grid[0].length || grid[i][j]!=comp && !visited[i][j])\\n                {\\n                    grid[temp.i][temp.j]=color;\\n                    continue;\\n                }\\n                if(!visited[i][j])\\n                {\\n                    li.addFirst(new Node(i,j));\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754832,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color){\\n            return grid;\\n        }\\n        DFS(grid,row,col,grid[row][col]);\\n        for(int i = 0 ; i < grid.Length; i++){\\n            for(int j = 0 ; j < grid[0].Length; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n    int[,] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    private void DFS(int[][] grid, int row, int col, int clr){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        for(int i = 0 ; i < 4 ; i++){\\n            int r = row + dir[i,0];\\n            int c = col + dir[i,1];\\n            \\n            if( r < 0 || c < 0 || r >= grid.Length || c >= grid[0].Length || Math.Abs(grid[r][c]) != clr){\\n                continue;\\n            }\\n            ++count;\\n            if(grid[r][c] == clr){\\n                DFS(grid,r,c,clr);\\n            }\\n        }\\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color){\\n            return grid;\\n        }\\n        DFS(grid,row,col,grid[row][col]);\\n        for(int i = 0 ; i < grid.Length; i++){\\n            for(int j = 0 ; j < grid[0].Length; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n    int[,] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    private void DFS(int[][] grid, int row, int col, int clr){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        for(int i = 0 ; i < 4 ; i++){\\n            int r = row + dir[i,0];\\n            int c = col + dir[i,1];\\n            \\n            if( r < 0 || c < 0 || r >= grid.Length || c >= grid[0].Length || Math.Abs(grid[r][c]) != clr){\\n                continue;\\n            }\\n            ++count;\\n            if(grid[r][c] == clr){\\n                DFS(grid,r,c,clr);\\n            }\\n        }\\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730663,
                "title": "dfs-solution",
                "content": "# Complexity\\n- Time complexity:\\n O(NxM) N is no of rows and M is no of columns\\n\\n- Space complexity:\\nO(NxM) + auxiliary stack space\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        int givenColor = grid[row][col];\\n        bool[,] visited = new bool[r,c];\\n        int[][] finalGrid = new int[r][];\\n        for(int i=0;i<r;i++)\\n          finalGrid[i] = new int[c];\\n          \\n        for(int i=0;i<r;i++)\\n        {\\n          for(int j=0;j<c;j++)\\n            finalGrid[i][j] = grid[i][j];\\n        }\\n        dfs(grid, row, col, givenColor, color, visited);\\n        void dfs(int[][] grid, int row, int col, int givenColor, int color, bool[,] visited)\\n        {\\n          if(row < 0 || col < 0 || row >= r || col >= c) return;\\n          if(grid[row][col] == givenColor && !visited[row,col])\\n          {\\n              visited[row,col] = true;\\n              if((row ==0 || col ==0 || row == r-1 || col == c-1)) \\n              {\\n                    finalGrid[row][col] = color;\\n              }\\n              else if(row-1 >= 0 && !(grid[row-1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(row+1 <= r-1 && !(grid[row+1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col-1 >= 0 && !(grid[row][col-1] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col+1 <= c-1 && !(grid[row][col+1] == givenColor))\\n                  finalGrid[row][col] = color;\\n\\n              dfs(grid,row-1,col,givenColor,color, visited);\\n              dfs(grid,row+1,col,givenColor,color, visited);\\n              dfs(grid,row,col-1,givenColor,color, visited);\\n              dfs(grid,row,col+1,givenColor,color, visited);\\n          }\\n        }\\n        return finalGrid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        int givenColor = grid[row][col];\\n        bool[,] visited = new bool[r,c];\\n        int[][] finalGrid = new int[r][];\\n        for(int i=0;i<r;i++)\\n          finalGrid[i] = new int[c];\\n          \\n        for(int i=0;i<r;i++)\\n        {\\n          for(int j=0;j<c;j++)\\n            finalGrid[i][j] = grid[i][j];\\n        }\\n        dfs(grid, row, col, givenColor, color, visited);\\n        void dfs(int[][] grid, int row, int col, int givenColor, int color, bool[,] visited)\\n        {\\n          if(row < 0 || col < 0 || row >= r || col >= c) return;\\n          if(grid[row][col] == givenColor && !visited[row,col])\\n          {\\n              visited[row,col] = true;\\n              if((row ==0 || col ==0 || row == r-1 || col == c-1)) \\n              {\\n                    finalGrid[row][col] = color;\\n              }\\n              else if(row-1 >= 0 && !(grid[row-1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(row+1 <= r-1 && !(grid[row+1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col-1 >= 0 && !(grid[row][col-1] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col+1 <= c-1 && !(grid[row][col+1] == givenColor))\\n                  finalGrid[row][col] = color;\\n\\n              dfs(grid,row-1,col,givenColor,color, visited);\\n              dfs(grid,row+1,col,givenColor,color, visited);\\n              dfs(grid,row,col-1,givenColor,color, visited);\\n              dfs(grid,row,col+1,givenColor,color, visited);\\n          }\\n        }\\n        return finalGrid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564824,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1570928,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1575145,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955641,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1944275,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1942977,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1918113,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1572643,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 2037655,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955696,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1564824,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1570928,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1575145,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955641,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1944275,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1942977,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1918113,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1572643,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 2037655,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955696,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            }
        ]
    }
]