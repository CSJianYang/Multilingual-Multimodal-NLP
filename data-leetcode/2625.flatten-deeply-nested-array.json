[
    {
        "title": "Flatten Deeply Nested Array",
        "question_content": "Given a&nbsp;multi-dimensional array&nbsp;arr&nbsp;and a depth n, return&nbsp;a&nbsp;flattened&nbsp;version of that array.\nA multi-dimensional&nbsp;array is a recursive data structure that contains integers or other&nbsp;multi-dimensional&nbsp;arrays.\nA&nbsp;flattened&nbsp;array is a version of that array with some or all of the sub-arrays removed and replaced with the actual elements in that sub-array. This flattening operation should only be done if the current depth of nesting&nbsp;is less&nbsp;than&nbsp;n. The depth of the elements in the first array are considered to be&nbsp;0.\nPlease solve it without the built-in&nbsp;Array.flat method.\n&nbsp;\nExample 1:\n\nInput\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 0\nOutput\n[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nExplanation\nPassing a depth of n=0 will always result in the original array. This is because the smallest possible depth of a subarray (0) is not less than n=0. Thus, no subarray should be flattened. \nExample 2:\n\nInput\narr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 1\nOutput\n[1, 2, 3, 4, 5, 6, 7, 8, [9, 10, 11], 12, 13, 14, 15]\nExplanation\nThe subarrays starting with 4, 7, and 13 are all flattened. This is because their depth of 0 is less than 1. However [9, 10, 11] remains unflattened because its depth is 1.\nExample 3:\n\nInput\narr = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]\nn = 2\nOutput\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\nExplanation\nThe maximum depth of any subarray is 1. Thus, all of them are flattened.\n&nbsp;\nConstraints:\n\n\t0 <= count of numbers in arr <=&nbsp;105\n\t0 <= count of subarrays in arr <=&nbsp;105\n\tmaxDepth <= 1000\n\t-1000 <= each number <= 1000\n\t0 <= n <= 1000",
        "solutions": [
            {
                "id": 3563943,
                "title": "easy-solution-2625-flatten-deeply-nested-array-level-up-your-javascript-skills-day-22",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>The problem requires us to flatten a multi-dimensional array based on a given depth. We need to maintain the structure of the array up to the given depth and flatten the remaining subarrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use an iterative approach with a stack.\\n>1. Initialize a stack with the elements of the array along with their\\ncorresponding depth levels. Each element is represented as a pair [item,\\ndepth].\\n>2. Initialize an empty array to store the flattened result.\\n>3. Enter a while loop, which continues as long as there are elements in the\\nstack.\\n>4. Within each iteration of the loop, retrieve the top element [item, depth] from\\nthe stack.\\n>5. If the item is an array and the current depth `depth` is greater than 0, it\\nmeans the element is a subarray that needs to be further flattened.\\n>6. Iterate over the subarray, and for each element, push it back to the stack\\nalong with a reduced depth level (depth - 1).\\n>7. If the item is not an array or the depth is 0, it means the element is a nonarray item that should be directly added to the result array.\\n>8. Continue the loop until there are no more elements in the stack.\\n>9. Finally, return the flattened result array.\\n\\n\\n ![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The time complexity of this approach is O(N), where N is the total number of elements in the input array. This is because we iterate over each element once, either to push it back to the stack or to add it to the result array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>The space complexity is also O(N), where N is the total number of elements in the input array. This is because in the worst case, all elements can be pushed onto the stack before being processed or added to the result array.\\n\\n# Code\\n```JavaScript []\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function(arr, depth) {\\n  const stack = [...arr.map(item => [item, depth])];\\n  const result = [];\\n\\n  while (stack.length > 0) {\\n    const [item, depth] = stack.pop();\\n\\n    if (Array.isArray(item) && depth > 0) {\\n      stack.push(...item.map(subItem => [subItem, depth - 1]));\\n    } else {\\n      result.push(item);\\n    }\\n  }\\n\\n  return result.reverse();\\n};\\n\\n\\n```\\n\\n# Important topic to Learn \\n\\n| Sr No. | Topic | Sr No. | Topic |\\n|-----|-----|-----|-----|\\n1.|Arrays , Array methods() * |2.|Function programming *|\\n3.|Higher-order function|4.|Memoization|\\n5.|Currying|6.|Promises, async/await|\\n7.|Compare Objects|8.|Prototypes, inheritance|\\n\\n>[ Note:- * marked is related to today\\'s problem ]\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```JavaScript []\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function(arr, depth) {\\n  const stack = [...arr.map(item => [item, depth])];\\n  const result = [];\\n\\n  while (stack.length > 0) {\\n    const [item, depth] = stack.pop();\\n\\n    if (Array.isArray(item) && depth > 0) {\\n      stack.push(...item.map(subItem => [subItem, depth - 1]));\\n    } else {\\n      result.push(item);\\n    }\\n  }\\n\\n  return result.reverse();\\n};\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3415372,
                "title": "100-simple-and-easy-explanation-faster-recursive-solution",
                "content": "**Understanding the Problem Statement**\\n\\nWe have given a multi-dimensional array, let\\'s suppose,\\n\\n`arr = [[1, 2], [3, [4, 5]]]`.\\n\\nThis array has two elements, each of which is itself an array. The first element **[1, 2]** has a depth of **1**, while the second element **[3, [4, 5]]** has a depth of **2**.\\n\\nTo flatten this array means to create a new array that contains all the elements of the original array, but with the nested arrays **\"flattened out\"** so that they no longer exist. For example, if we flatten arr with a depth of **1**, we would get:\\n\\n`answer = [1, 2, 3, [4, 5]];`\\n\\nThe sub-array **[4, 5]** was not flattened, since its depth is greater than the specified depth of 1.\\n\\n\\n**Intuition**\\n\\nWe can divide the problem into **sub-problems** as nested list can have any depth levels. Since we have to check for all the levels and flatten the array if depth is greater than 0, we can use **recursion** to do this.\\n\\n**Approach**\\n\\n1. Check if **n is equal to 0**, Simply return the original array as no flattening is required.\\n2. Initialize an `answer` array to store the result.\\n3. Now, traverse the array using for loop, and for each array check if n is greater than zero and element is instance of the `Array` : \\n\\t* \\tIf both the conditions are true, recursively call the function by passing `arr[i]` and reducing the n by 1 and add the result to answer array using the spread `...` operator.\\n\\t* \\tElse, Push the current array `arr[i]` to the `answer` array.\\n4. Return the `answer` array once the traversal is complete.\\n\\n\\n**Code**\\n```\\nvar flat = function (arr, n) {\\n    \\n    // if n is 0, no flattening is required, hence return the original array\\n    if(n == 0){\\n        return arr;\\n    }\\n    \\n    // create an answer array to store final result\\n    let answer = [];\\n    \\n    // traverse the array\\n    for(let i=0; i<arr.length; i++){\\n        \\n        // check if element is instance of array and depth is not equal to 0\\n        if(n>0 && Array.isArray(arr[i])){\\n            \\n            // recursively call the function for this array and push the flattened array to the answer array\\n            answer.push(...flat(arr[i], n-1));\\n        }\\n        // else directy push the current array\\n        else{\\n            answer.push(arr[i]);\\n        }\\n    }\\n    \\n    return answer;\\n};\\n```\\n\\n**Output**\\n![image](https://assets.leetcode.com/users/images/b3d8e1e7-3b1f-4ce0-a7bc-716f2a8143b6_1681454902.9784133.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar flat = function (arr, n) {\\n    \\n    // if n is 0, no flattening is required, hence return the original array\\n    if(n == 0){\\n        return arr;\\n    }\\n    \\n    // create an answer array to store final result\\n    let answer = [];\\n    \\n    // traverse the array\\n    for(let i=0; i<arr.length; i++){\\n        \\n        // check if element is instance of array and depth is not equal to 0\\n        if(n>0 && Array.isArray(arr[i])){\\n            \\n            // recursively call the function for this array and push the flattened array to the answer array\\n            answer.push(...flat(arr[i], n-1));\\n        }\\n        // else directy push the current array\\n        else{\\n            answer.push(arr[i]);\\n        }\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564820,
                "title": "recursive-iterative-approach-detailed-explanation",
                "content": "## \\u2705\\u2705 Please Upvote if you find it useful \\u2705\\u2705\\n\\n## Recursive Approach:\\n\\n1. The function `flat` takes an input array `arr` and a depth    as parameters.\\n2. If the current `depth` equals `0`, the function reaches the base case where no further flattening is required. In this case, the function creates a shallow copy of the array using the `slice()` method and returns it as the result.\\n3. If the current depth is greater than `0`, the function proceeds with flattening the array.\\n4. The function initializes an empty array called `flattened` to store the flattened elements.\\n5. It iterates through each element of the input array using a `for` loop.\\n6. For each element, it checks if it is an array using` Array.isArray(arr[i])`.\\n7. If the element is an array, it recursively calls the `flat` function with the nested array `(arr[i])` and a decreased depth `(depth - 1)`.\\n8. The result of the recursive call is stored in a variable called `nested`.\\n9. The `...` spread operator is used to concatenate the elements of the `nested` array into the `flattened` array.\\n10. If the element is not an array, it is a single value, so it is directly pushed into the `flattened` array.\\n11. After iterating through all the elements, the function returns the `flattened` array as the final result.\\n\\n# Code\\n```\\n// Recursive Approach\\nfunction flat(arr, depth) {\\n  if (depth === 0) {\\n    return arr.slice(); // Base case: return a shallow copy of the array\\n  }\\n\\n  let flattened = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const nested = flat(arr[i], depth - 1); // Recursively flatten nested arrays\\n      flattened.push(...nested); // Concatenate flattened nested arrays to the result\\n    } else {\\n      flattened.push(arr[i]); // Push individual elements to the result\\n    }\\n  }\\n\\n  return flattened; // Return the flattened array\\n}\\n\\n```\\n----\\n\\n## Iterative Approach: \\n\\nThe function `flat` takes an array `arr` and a depth `depth` as parameters like before.\\n\\nwe will use a `while` loop to continue the flattening operation as long as there are nested array elements (i.e. `hasNestedArray` is `true`) and the current depth is less than the specified depth.\\n\\nWithin each iteration of the loop, we initialize a `queue` array to store the flattened elements and then iterates through each element of the input array `arr`.\\n\\nFor each element, it checks if it\\'s an array using `Array.isArray(arr[i])`. If the element is an array, it spreads its elements into the queue array using the spread operator `(...)`. This adds the nested elements to the `queue` for further flattening. Additionally, it sets the `hasNestedArray` flag to true to indicate the presence of nested array elements.\\n\\nIf the element is not an array, it is a single value, so it is directly pushed into the `queue`.\\n\\nAfter iterating through all the elements of the current level, the function replaces the original array `arr` with the elements in the `queue`. This prepares for the next iteration of the loop, where the process continues to flatten nested arrays.\\n\\nwe increment the `currentDepth` at each iteration to keep track of the current depth of nesting.\\n\\nOnce there are no more nested array elements or the current depth reaches the specified depth, we exit.\\n\\n```java\\n// iterative approach\\nfunction flat (arr, depth) {\\n  let hasNestedArray = true;\\n  let queue;\\n  let currentDepth = 0;\\n\\n  // Continue flattening while there are nested array elements and the current depth is less than the specified depth\\n  while (hasNestedArray && currentDepth < depth) {\\n    hasNestedArray = false;\\n    queue = [];\\n\\n    // Iterate through each element in the array\\n    for (let i = 0; i < arr.length; i++) {\\n      if (Array.isArray(arr[i])) {\\n        queue.push(...arr[i]); // If the element is an array, spread its elements into the queue\\n        hasNestedArray = true; // Set the flag to indicate the presence of nested array elements\\n      } else {\\n        queue.push(arr[i]); // If the element is not an array, push it into the queue\\n      }\\n    }\\n\\n    arr = [...queue]; // Replace the original array with the elements in the queue\\n    currentDepth++; // Increment the depth counter\\n  }\\n\\n  return arr; // Return the flattened array\\n};\\n```\\n\\n## \\u2705\\u2705 Please Upvote if you find it useful \\u2705\\u2705",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Recursive Approach\\nfunction flat(arr, depth) {\\n  if (depth === 0) {\\n    return arr.slice(); // Base case: return a shallow copy of the array\\n  }\\n\\n  let flattened = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const nested = flat(arr[i], depth - 1); // Recursively flatten nested arrays\\n      flattened.push(...nested); // Concatenate flattened nested arrays to the result\\n    } else {\\n      flattened.push(arr[i]); // Push individual elements to the result\\n    }\\n  }\\n\\n  return flattened; // Return the flattened array\\n}\\n\\n```\n```java\\n// iterative approach\\nfunction flat (arr, depth) {\\n  let hasNestedArray = true;\\n  let queue;\\n  let currentDepth = 0;\\n\\n  // Continue flattening while there are nested array elements and the current depth is less than the specified depth\\n  while (hasNestedArray && currentDepth < depth) {\\n    hasNestedArray = false;\\n    queue = [];\\n\\n    // Iterate through each element in the array\\n    for (let i = 0; i < arr.length; i++) {\\n      if (Array.isArray(arr[i])) {\\n        queue.push(...arr[i]); // If the element is an array, spread its elements into the queue\\n        hasNestedArray = true; // Set the flag to indicate the presence of nested array elements\\n      } else {\\n        queue.push(arr[i]); // If the element is not an array, push it into the queue\\n      }\\n    }\\n\\n    arr = [...queue]; // Replace the original array with the elements in the queue\\n    currentDepth++; // Increment the depth counter\\n  }\\n\\n  return arr; // Return the flattened array\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406747,
                "title": "recursive-typescript-solution",
                "content": "# Approach\\nAny time I need to traverse a nested data structure, I reach for recursion.\\n\\nIntuitively, we need to loop through the array and check if each element is a number. If so, it is already flat, so it can be pushed into our result. If the element is also an array, we need to loop it as well and check each of its elements, etc., until we reach the level requested.\\n\\nSo we need to create a function that will check each element in an array and recursively flatten it if it is also an array.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ because in the worst case, we have to check every element of the array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ because we are using recursion, which means we will be pushing function calls onto the stack. In the worst case, we push a function call for each element of each array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n\\n    // base case. If we are on depth 0, we don\\'t flatten the element\\n    if (n === 0) {\\n        return arr;\\n    }\\n    \\n    // temp array to hold the flattened results for this level of the recursion\\n    const result: MultiDimensionalArray = [];\\n\\n    // loop the elements of this array. If they are numbers, don\\'t need to flatten,\\n    // just push into the result. If they are arrays, we need to flatten,\\n    // so recursively call the flat function, then spread the returned value and push into result.\\n    arr.forEach(el => {\\n        if (typeof el === \\'number\\') {\\n            result.push(el);\\n        } else {\\n            result.push(...flat(el, n - 1));\\n        }\\n    })\\n\\n    return result;\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n\\n    // base case. If we are on depth 0, we don\\'t flatten the element\\n    if (n === 0) {\\n        return arr;\\n    }\\n    \\n    // temp array to hold the flattened results for this level of the recursion\\n    const result: MultiDimensionalArray = [];\\n\\n    // loop the elements of this array. If they are numbers, don\\'t need to flatten,\\n    // just push into the result. If they are arrays, we need to flatten,\\n    // so recursively call the flat function, then spread the returned value and push into result.\\n    arr.forEach(el => {\\n        if (typeof el === \\'number\\') {\\n            result.push(el);\\n        } else {\\n            result.push(...flat(el, n - 1));\\n        }\\n    })\\n\\n    return result;\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983510,
                "title": "javascript-solution-using-recursion-easiest-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Write a recursive function that keeps track of the current depth.\\n2. If the current depth >= the maximum depth, always just push the value to the returned array.\\n3. Otherwise, recursively call flat on the array.\\n\\n<!-- # Complexity -->\\n\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const res = [];\\n\\n    function helper(arr,depth) {\\n        for(const val of arr) {\\n            if(typeof(val) === \\'object\\' && depth < n) {\\n                helper(val,depth + 1);\\n            } else {\\n                res.push(val);\\n            }\\n        }\\n        return res;\\n    }\\n    return helper(arr,0);\\n};\\n```\\n\\n# Code Efficiency\\n![Screenshot 2023-08-31 125758.png](https://assets.leetcode.com/users/images/2057208b-67d1-49f0-a3cb-1375472804a6_1693467241.863696.png)\\n\\n> Do UPVOTE if you liked the solution \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const res = [];\\n\\n    function helper(arr,depth) {\\n        for(const val of arr) {\\n            if(typeof(val) === \\'object\\' && depth < n) {\\n                helper(val,depth + 1);\\n            } else {\\n                res.push(val);\\n            }\\n        }\\n        return res;\\n    }\\n    return helper(arr,0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563751,
                "title": "easiest-solution-ever",
                "content": "# Code\\n```\\nvar flat = function (arr, n) {\\n    // if n = 0 then we return arr or if all the element of array is \\n    // integer (not an array) we return arr.\\n    if(n == 0 || arr.every((item) => !Array.isArray(item))) return arr;\\n    const result = [];\\n    for(let i=0;i<arr.length;i++)\\n      if(Array.isArray(arr[i]))\\n        result.push(...arr[i]);\\n      else\\n        result.push(arr[i]);\\n    return flat(result,n-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flat = function (arr, n) {\\n    // if n = 0 then we return arr or if all the element of array is \\n    // integer (not an array) we return arr.\\n    if(n == 0 || arr.every((item) => !Array.isArray(item))) return arr;\\n    const result = [];\\n    for(let i=0;i<arr.length;i++)\\n      if(Array.isArray(arr[i]))\\n        result.push(...arr[i]);\\n      else\\n        result.push(arr[i]);\\n    return flat(result,n-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563766,
                "title": "day-20-o-1-2-o-1-commented-eassiest",
                "content": "The given code defines a function called `flat` using arrow function syntax. This function takes in two parameters: `arr`, which is an array, and `n`, which represents the depth level until which the array should be flattened.\\n\\nThe code uses a ternary operator to check if the value of `n` is truthy. If `n` is truthy (non-zero), it indicates that the array needs to be flattened to a certain depth. Otherwise, if `n` is falsy (zero or undefined), it indicates that the array should be flattened completely.\\n\\nThe implementation uses the `reduce` method on the `arr` array to flatten it. Inside the `reduce` callback function, the code checks if the current element (`next`) is an array using the `Array.isArray` method.\\n\\nIf `next` is an array, it recursively calls the `flat` function with the nested array (`next`) and decreases the value of `n` by 1. The spread operator (`...`) is used to spread the flattened nested array elements into the `temp` array.\\n\\nIf `next` is not an array, it means it\\'s a non-nested element, so the code directly pushes it into the `temp` array.\\n\\nFinally, the callback function returns the `temp` array, which is the accumulated result at each step of the `reduce` operation.\\n\\nOutside the ternary operator, if `n` is truthy, the function returns the flattened array generated through the `reduce` operation. Otherwise, it returns the original `arr` without any flattening.\\n\\nHere\\'s an example to illustrate the behavior of the `flat` function:\\n\\n```javascript\\nconst array = [1, [2, [3, 4, [5, 6]]], 7];\\n\\nconsole.log(flat(array, 0));\\n// Output: [1, [2, [3, 4, [5, 6]]], 7]\\n\\nconsole.log(flat(array, 1));\\n// Output: [1, 2, [3, 4, [5, 6]], 7]\\n\\nconsole.log(flat(array, 2));\\n// Output: [1, 2, 3, 4, [5, 6], 7]\\n\\nconsole.log(flat(array, 3));\\n// Output: [1, 2, 3, 4, 5, 6, 7]\\n\\nconsole.log(flat(array));\\n// Output: [1, 2, 3, 4, 5, 6, 7] (complete flattening)\\n```\\n\\nIn the above example, the `array` contains nested arrays. By passing different values of `n` to the `flat` function, you can control the depth of flattening.\\n\\n***Here is the code to the current problem:-***\\n\\n```\\n\\nvar flat = (arr, n) =>\\n    n ?\\n        arr.reduce(\\n            (temp, next) => (\\n                Array.isArray(next) ?\\n                    temp.push(...flat(next, n - 1)) :\\n                    temp.push(next),\\n                temp\\n            ),\\n            []\\n        ) :\\n        arr;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```javascript\\nconst array = [1, [2, [3, 4, [5, 6]]], 7];\\n\\nconsole.log(flat(array, 0));\\n// Output: [1, [2, [3, 4, [5, 6]]], 7]\\n\\nconsole.log(flat(array, 1));\\n// Output: [1, 2, [3, 4, [5, 6]], 7]\\n\\nconsole.log(flat(array, 2));\\n// Output: [1, 2, 3, 4, [5, 6], 7]\\n\\nconsole.log(flat(array, 3));\\n// Output: [1, 2, 3, 4, 5, 6, 7]\\n\\nconsole.log(flat(array));\\n// Output: [1, 2, 3, 4, 5, 6, 7] (complete flattening)\\n```\n```\\n\\nvar flat = (arr, n) =>\\n    n ?\\n        arr.reduce(\\n            (temp, next) => (\\n                Array.isArray(next) ?\\n                    temp.push(...flat(next, n - 1)) :\\n                    temp.push(next),\\n                temp\\n            ),\\n            []\\n        ) :\\n        arr;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538780,
                "title": "detailed-solution-using-recursion-in-javascript-faster-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n According to the Problem Statement:\\n 1. If depth of the current array is less than n then we will flatten it.\\n 2. If depth of the current array is equal to n then we will flatten it.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n 1. We will use Recursive Function Flat(arr,depth,n).\\n 2. if depth==n then we will simply return array //Base Condition.\\n 3. else we will try to flatten array by traversing the array completely.\\n    ```\\n    let i=0;\\n    let Arr=[];\\n    while(i<arr.length)\\n    {\\n          //If current element is integer then no need to flatten it\\n          if(Number.isInteger(arr[i]))\\n          {\\n             Arr.push(arr[i]);\\n          }\\n          else\\n          {\\n             //we will call Flat(arr[i],depth+1,n) to flatten this arr\\n              let tempArr=Flat(arr[i],dept1,n);\\n              tempArr.forEach((ele)=>{\\n                  Arr.push(ele);\\n              })\\n          }\\n          i+=1;\\n    }\\n    return Arr;\\n```\\n\\n# Complexity\\n- Time complexity: O(n*N)\\n- where N max number of ele in particular depth while flatting given array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(Total number of integer in array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar Flat=function(arr,depth,n){\\n         if(depth==n)\\n         {\\n            return arr;\\n         }\\n         let Arr=[];\\n         let i=0;\\n         while(i<arr.length)\\n         {\\n               if(Number.isInteger(arr[i]))\\n               { \\n                  Arr.push(arr[i]);\\n               }\\n               else\\n               {\\n                  const v=Flat(arr[i],depth+1,n);  \\n                  v.forEach((x)=>{\\n                      Arr.push(x);\\n                  });\\n               }\\n               i+=1;  \\n         }\\n         return Arr;\\n}\\nvar flat = function (arr, n) {\\n           return Flat(arr,0,n);\\n};\\n```\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    let i=0;\\n    let Arr=[];\\n    while(i<arr.length)\\n    {\\n          //If current element is integer then no need to flatten it\\n          if(Number.isInteger(arr[i]))\\n          {\\n             Arr.push(arr[i]);\\n          }\\n          else\\n          {\\n             //we will call Flat(arr[i],depth+1,n) to flatten this arr\\n              let tempArr=Flat(arr[i],dept1,n);\\n              tempArr.forEach((ele)=>{\\n                  Arr.push(ele);\\n              })\\n          }\\n          i+=1;\\n    }\\n    return Arr;\\n```\n```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414016,
                "title": "constant-space-in-place-fast-iterative-solution-with-early-termination-optimization",
                "content": "# Intuition\\nThe problem statement doesn\\'t state that the input array must remain untouched, so we can perform operations in-place on the array to save memory. Additionally, solving things iteratively saves us from adding *n* recursive function calls to the stack, resulting in O(1) space.\\n\\n# Approach\\nIterate over the array a max of *n* times, flattening one-level of arrays each pass until there are no longer any sub-arrays, or we\\'ve done the specified number of passes. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    // Loop n times, flattening one-level at a time\\n    for (let k = n; k > 0; k--) {\\n        let alreadyFlat = true;\\n        for (let i = 0; i < arr.length; i++) {\\n            if (Array.isArray(arr[i])) {\\n                let sal = arr[i].length;\\n                arr.splice(i, 1, ...arr[i]);\\n                // Skip to the end of the elements we just added\\n                i += sal - 1;\\n                alreadyFlat = false;\\n            }\\n        }\\n        // If the array is already flat, we can return early\\n        if (alreadyFlat) return arr; \\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    // Loop n times, flattening one-level at a time\\n    for (let k = n; k > 0; k--) {\\n        let alreadyFlat = true;\\n        for (let i = 0; i < arr.length; i++) {\\n            if (Array.isArray(arr[i])) {\\n                let sal = arr[i].length;\\n                arr.splice(i, 1, ...arr[i]);\\n                // Skip to the end of the elements we just added\\n                i += sal - 1;\\n                alreadyFlat = false;\\n            }\\n        }\\n        // If the array is already flat, we can return early\\n        if (alreadyFlat) return arr; \\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409115,
                "title": "inorder-dfs-traversal-ft-generators",
                "content": "# Intuition\\nThe nested structure of the array suggests a recursive, tree-like structure. Thinking about how the array is flattened in this structure leads to the idea of a DFS traversal.\\n\\n# Approach\\nFor some array, we scan the elements left to right.\\n\\nIf the element is a number, we add it to our answer array.\\n\\nIf the element is an array, we either add it to our answer array if we have reached our depth limit or recurse on the array.\\n\\nAs an example, consider `arr = [1, 2, [3, [4, 5], 6], 7], n = 1`. The red arrows in the following image demonstrates what a DFS traversal could look like.\\n\\n![dfs.png](https://assets.leetcode.com/users/images/04460f6e-2c01-4254-b8a5-cc1300b8e257_1681307783.6384199.png)\\n\\nThis \"inorder\" traversal (and tree traversals in general) can be done nicely with generators.\\n\\n# Complexity\\n- Time complexity: $$O(\\\\ell)$$, where $\\\\ell$ is the length of the answer array.\\n\\n- Space complexity: $$O(\\\\ell)$$\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nfunction* inorder(arr: MultiDimensionalArray, n: number) {\\n    // depth limit reached\\n    if (n < 0) {\\n        yield arr;\\n        return;\\n    }\\n\\n    // recursively DFS\\n    for (const val of arr) {\\n        if (typeof val === \\'number\\') {\\n            yield val;\\n        } else {\\n            yield* inorder(val, n - 1);\\n        }\\n    }\\n};\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    return [...inorder(arr, n)];\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nfunction* inorder(arr: MultiDimensionalArray, n: number) {\\n    // depth limit reached\\n    if (n < 0) {\\n        yield arr;\\n        return;\\n    }\\n\\n    // recursively DFS\\n    for (const val of arr) {\\n        if (typeof val === \\'number\\') {\\n            yield val;\\n        } else {\\n            yield* inorder(val, n - 1);\\n        }\\n    }\\n};\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    return [...inorder(arr, n)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406801,
                "title": "simple-1-line-solution",
                "content": "# Approach\\nRecursively reduce `arr` by recursing through non-numerical inputs until base case of `n === 0`. If `e` is an element, it\\'s pushed into `acc`, otherwise, result of recursive call is unpacked before being pushed. For each case we return `acc` in the `reduce` HOF.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar flat = function (arr, n) {\\n    return n === 0 ? arr : arr.reduce(\\n            (acc, e) => typeof(e) === \"number\" ? \\n              (acc.push(e), acc) : (acc.push(...flat(e, n-1)), acc),\\n           []);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar flat = function (arr, n) {\\n    return n === 0 ? arr : arr.reduce(\\n            (acc, e) => typeof(e) === \"number\" ? \\n              (acc.push(e), acc) : (acc.push(...flat(e, n-1)), acc),\\n           []);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594316,
                "title": "fastest-easiest-solution-time-o-n-99-extra-space-o-n-90",
                "content": "# Solution from Pro JS Developer\\n\\nPlease take a look at the code below.\\n\\n# Approach\\n\\nNo rocket sciense, no magic, nothing excess.\\n**result** - returning array, accesed from closure.\\n**toFlat** - recursion function with same arguments. On each flattening level just passed **n - 1**.\\n\\n# Complexity\\n- Time complexity: O(n) - Runtime: **86 ms** - beats > 99%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) - Memory: **61.1 MB** - beats > 90%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![rail-sakhaviev-flattern.png](https://assets.leetcode.com/users/images/a57ea553-0299-4be6-b4b4-a87ab388ebdb_1685823541.569171.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (source, level) {\\n    const result = [];\\n    const toFlat = (arr, n) => {\\n        for (let i = 0; i < arr.length; i++) {\\n            if (Array.isArray(arr[i]) && n > 0) {\\n                toFlat(arr[i], n - 1);\\n            } else {\\n                result.push(arr[i]);\\n            }\\n        }\\n    };\\n    toFlat(source, level);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (source, level) {\\n    const result = [];\\n    const toFlat = (arr, n) => {\\n        for (let i = 0; i < arr.length; i++) {\\n            if (Array.isArray(arr[i]) && n > 0) {\\n                toFlat(arr[i], n - 1);\\n            } else {\\n                result.push(arr[i]);\\n            }\\n        }\\n    };\\n    toFlat(source, level);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565268,
                "title": "javascript-solution",
                "content": "\\n\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n==0){\\n        return arr;\\n    }\\n    let ans=[];\\n    for (let i=0; i<arr.length; i++){\\n        if(n>0 && Array.isArray(arr[i])){\\n            ans.push(...flat(arr[i],n-1));\\n        }else{\\n            ans.push(arr[i]);\\n        }\\n    }\\n   return ans \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n==0){\\n        return arr;\\n    }\\n    let ans=[];\\n    for (let i=0; i<arr.length; i++){\\n        if(n>0 && Array.isArray(arr[i])){\\n            ans.push(...flat(arr[i],n-1));\\n        }else{\\n            ans.push(arr[i]);\\n        }\\n    }\\n   return ans \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564438,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let res = [];\\n    const flattening = (nums, l) => {\\n      for (const num of nums) {\\n        if (Array.isArray(num) && l > 0 && l <= n) {\\n          flattening(num, l - 1);\\n        } else {\\n          res.push(num);\\n        }\\n      }\\n    }\\n\\n    flattening(arr, n);\\n    return res;\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/73113fa9-839a-4d44-945e-4194fe941d2e_1685091792.7403052.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let res = [];\\n    const flattening = (nums, l) => {\\n      for (const num of nums) {\\n        if (Array.isArray(num) && l > 0 && l <= n) {\\n          flattening(num, l - 1);\\n        } else {\\n          res.push(num);\\n        }\\n      }\\n    }\\n\\n    flattening(arr, n);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563617,
                "title": "java-script-solution-for-flatten-deeply-nested-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to recursively flatten the given multi-dimensional array while considering the depth constraint.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is a depth-first traversal of the input array. For each element in the array, it checks if it is an array and if the current depth is greater than 0. If both conditions are met, the function recursively calls itself with the sub-array and reduces the depth by 1. Otherwise, it pushes the element into the result array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the size of the input array and the depth. In the worst case, if the depth is equal to the maximum depth of the input array, the algorithm will visit all elements once. Therefore, the time complexity is O(N), where N is the total number of elements in the input array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(N) because the result array stores all the elements in the flattened array. Additionally, the recursive function calls occupy space on the call stack proportional to the depth of the array.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, depth) {\\n    var result = [];\\n    \\n    flatten(arr, depth, result);\\n    \\n    return result;\\n};\\n\\nfunction flatten(arr, depth, result) {\\n    for (var i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i]) && depth > 0) {\\n            flatten(arr[i], depth - 1, result);\\n        } else {\\n            result.push(arr[i]);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, depth) {\\n    var result = [];\\n    \\n    flatten(arr, depth, result);\\n    \\n    return result;\\n};\\n\\nfunction flatten(arr, depth, result) {\\n    for (var i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i]) && depth > 0) {\\n            flatten(arr[i], depth - 1, result);\\n        } else {\\n            result.push(arr[i]);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563545,
                "title": "javascript-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) {\\n    return arr;\\n  }\\n\\n  let ans = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const subArray = flat(arr[i], n - 1);\\n      ans.push(...subArray);\\n    } else {\\n      ans.push(arr[i]);\\n    }\\n  }\\n  return ans; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) {\\n    return arr;\\n  }\\n\\n  let ans = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const subArray = flat(arr[i], n - 1);\\n      ans.push(...subArray);\\n    } else {\\n      ans.push(arr[i]);\\n    }\\n  }\\n  return ans; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556297,
                "title": "best-javascript-and-typescript-solution-for-beginner",
                "content": "# Code\\n```javascript []\\nvar flat = function (arr, n) {\\n    if (n === 0) {\\n        return arr;\\n    }\\n    \\n    let answer = [];\\n    \\n    arr.forEach(element => {\\n        if (n > 0 && Array.isArray(element)) {\\n            answer.push(...flat(element, n - 1));\\n        } else {\\n            answer.push(element);\\n        }\\n    });\\n    \\n    return answer;\\n};\\n\\n```\\n```typescript []\\nconst flat = function (arr: any[], n: number): any[] {\\n    if (n === 0) {\\n        return arr;\\n    }\\n    \\n    let answer: any[] = [];\\n    \\n    arr.forEach(element => {\\n        if (n > 0 && Array.isArray(element)) {\\n            answer.push(...flat(element, n - 1));\\n        } else {\\n            answer.push(element);\\n        }\\n    });\\n    \\n    return answer;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\nvar flat = function (arr, n) {\\n    if (n === 0) {\\n        return arr;\\n    }\\n    \\n    let answer = [];\\n    \\n    arr.forEach(element => {\\n        if (n > 0 && Array.isArray(element)) {\\n            answer.push(...flat(element, n - 1));\\n        } else {\\n            answer.push(element);\\n        }\\n    });\\n    \\n    return answer;\\n};\\n\\n```\n```typescript []\\nconst flat = function (arr: any[], n: number): any[] {\\n    if (n === 0) {\\n        return arr;\\n    }\\n    \\n    let answer: any[] = [];\\n    \\n    arr.forEach(element => {\\n        if (n > 0 && Array.isArray(element)) {\\n            answer.push(...flat(element, n - 1));\\n        } else {\\n            answer.push(element);\\n        }\\n    });\\n    \\n    return answer;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556283,
                "title": "best-javascript-solution-for-beginner",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) {\\n        return arr;\\n    }\\n    \\n    let answer = [];\\n    \\n    arr.forEach(element => {\\n        if (n > 0 && Array.isArray(element)) {\\n            answer.push(...flat(element, n - 1));\\n        } else {\\n            answer.push(element);\\n        }\\n    });\\n    \\n    return answer;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) {\\n        return arr;\\n    }\\n    \\n    let answer = [];\\n    \\n    arr.forEach(element => {\\n        if (n > 0 && Array.isArray(element)) {\\n            answer.push(...flat(element, n - 1));\\n        } else {\\n            answer.push(element);\\n        }\\n    });\\n    \\n    return answer;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427313,
                "title": "javascript-recursive-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFlatten arrays recursively until n equals 0, then return array itself.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n\\n    let result = [];\\n\\n    for (let num of arr) {\\n        if (Array.isArray(num)) {\\n            result.push(...flat(num, n - 1));\\n        } else {\\n            result.push(num);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n\\n    let result = [];\\n\\n    for (let num of arr) {\\n        if (Array.isArray(num)) {\\n            result.push(...flat(num, n - 1));\\n        } else {\\n            result.push(num);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408569,
                "title": "100-recursive-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursion \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n==0) return arr;\\n    let result = [];\\n    const traverse = (a, n) => {\\n        for(let i in a) {\\n            if(n>0 && Array.isArray(a[i]))\\n                traverse(a[i], n-1)\\n            else\\n                result.push(a[i])\\n        }\\n    }\\n    traverse(arr, n);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n==0) return arr;\\n    let result = [];\\n    const traverse = (a, n) => {\\n        for(let i in a) {\\n            if(n>0 && Array.isArray(a[i]))\\n                traverse(a[i], n-1)\\n            else\\n                result.push(a[i])\\n        }\\n    }\\n    traverse(arr, n);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407714,
                "title": "recursive-solution",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  if (n === 0) return arr;\\n  let res = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      res.push(...flat(arr[i], n-1));\\n    } else {\\n      res.push(arr[i]);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  if (n === 0) return arr;\\n  let res = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      res.push(...flat(arr[i], n-1));\\n    } else {\\n      res.push(arr[i]);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406577,
                "title": "javascript-a-simple-recursive-solution",
                "content": "# Overall Idea\\n\\nThis problem lends very well for a recursive solution! We iterate through the array, checking for nested arrays within.\\n\\n1) If the element is another array, we call it recursively down one level. We can use the spread operator (`...`) to do the flattening for us when appending to our flattened array.\\n2) Otherwise, we can simply push the element.\\n\\nRemember to stop the recursion when `n = 0`!\\n\\n# Code\\n```js\\n// A normal, recursive approach.\\nconst flat = function (arr, n) {\\n    if (n === 0)\\n        return arr;\\n    let res = [];\\n    for (let i in arr) {\\n        if (Array.isArray(arr[i]))\\n            res.push(...flat(arr[i], n - 1));\\n        else\\n            res.push(arr[i]);\\n    }\\n    return res;\\n}\\n```\\n\\n## Considerations & Optimizations\\n\\nWe could also get away with not allocating an array at every recursive call! Instead, we can just define an inner recursive function that appends to an outer array for us.\\n\\nThe rest of the algorithm is more or less the same:\\n\\n```js\\n// An optimization - saves unnecessary\\n// array allocations at every call!\\nconst flat = function (arr, n) {\\n    let res = [];\\n    const recur = (arr, n) => {\\n        for (let i in arr) {\\n            if (n > 0 && Array.isArray(arr[i]))\\n                recur(arr[i], n - 1);\\n            else\\n                res.push(arr[i]);\\n        }\\n    }\\n    recur(arr, n);\\n    return res;\\n}\\n```\\n\\n# Complexity\\n\\n**Time complexity:** $$O(n)$$ - Unless `n = 0`, we wind up checking every element in the input array.\\n**Space complexity:** $$O(n)$$ - Besides the space required for the output array, we allocate a function call on the stack for every recursive call.",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\n// A normal, recursive approach.\\nconst flat = function (arr, n) {\\n    if (n === 0)\\n        return arr;\\n    let res = [];\\n    for (let i in arr) {\\n        if (Array.isArray(arr[i]))\\n            res.push(...flat(arr[i], n - 1));\\n        else\\n            res.push(arr[i]);\\n    }\\n    return res;\\n}\\n```\n```js\\n// An optimization - saves unnecessary\\n// array allocations at every call!\\nconst flat = function (arr, n) {\\n    let res = [];\\n    const recur = (arr, n) => {\\n        for (let i in arr) {\\n            if (n > 0 && Array.isArray(arr[i]))\\n                recur(arr[i], n - 1);\\n            else\\n                res.push(arr[i]);\\n        }\\n    }\\n    recur(arr, n);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914548,
                "title": "99-easy-dfs-recursive-solution-with-explanations",
                "content": "**Hello everyone! So, I\\'ve come up with a solution to resolve this problem, by the way i\\'m new to JS so if you have any advice you\\'re welcome. \\uD83D\\uDE01**\\n\\n# Intuition\\nWhich algorithm can i use to keep tracking the deep ?`\\uD83D\\uDCA1DFS`\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirstly, I\\'ve instantiated an array called ans, which will serve as a container for elements after they\\'ve been flattened. It essentially acts as a receptacle for our final data.\\n\\nNext, I\\'ve defined a function called dfs, which stands for \"Depth First Search.\" This function lies at the core of the process of traversing arrays to extract elements for flattening.\\n\\nThe dfs function comprises three parameters: depth (representing the current depth), maxDepth (defining the maximum depth of traversal), and currArray (the array currently under exploration).\\n\\nNow, the conditional statement is where the intrigue lies. It checks if the current depth depth matches the maximum depth maxDepth. If true, it signifies that we\\'ve reached the depth limit, so we add currArray (the array we\\'ve explored) to our container ans and we stop the depth exploration.\\n\\nHowever, if we haven\\'t reached the maximum depth yet, we enter a for...of loop. This acts like a machine to inspect each element within currArray.\\n\\nIf the element we\\'re looking at is itself an array, it means we can dig even deeper. Thus, we recursively call the dfs function, incrementing the depth by 1 and passing the new element as currArray.\\n\\nIn the case where the element isn\\'t an array, it simply indicates an ordinary value. In this case, we directly add that value to our container ans.\\n\\nFinally, the main flat function calls the dfs function with an initial depth of **-1** (to indicate we haven\\'t started yet), the maximum depth **n**, and the initial input array **arr**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n**m** = number of elements in arr\\n\\n**n** = maximum stack calls used by the recursion\\n\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  **O(max(n, m))**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    var ans= [];\\n\\n    const dfs = (depth,maxDepth,currArray) =>{\\n        if(depth==maxDepth){\\n            ans.push(currArray);\\n            return;\\n        }\\n\\n        for(element of currArray){\\n            if(Array.isArray(element)){\\n                dfs(depth+1,maxDepth,element);\\n            }else{\\n                ans.push(element);\\n            }\\n        }\\n    };\\n\\n    dfs(-1,n,arr);\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    var ans= [];\\n\\n    const dfs = (depth,maxDepth,currArray) =>{\\n        if(depth==maxDepth){\\n            ans.push(currArray);\\n            return;\\n        }\\n\\n        for(element of currArray){\\n            if(Array.isArray(element)){\\n                dfs(depth+1,maxDepth,element);\\n            }else{\\n                ans.push(element);\\n            }\\n        }\\n    };\\n\\n    dfs(-1,n,arr);\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894705,
                "title": "elegant-and-readable-solution",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = (arr, n) => {\\n    if (n === 0) return arr\\n\\n    const flatArr = []\\n\\n    arr.forEach(el => \\n        (Array.isArray(el) && n > 0) ? flatArr.push(...flat(el, n - 1)) : flatArr.push(el)\\n    )\\n\\n    return flatArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = (arr, n) => {\\n    if (n === 0) return arr\\n\\n    const flatArr = []\\n\\n    arr.forEach(el => \\n        (Array.isArray(el) && n > 0) ? flatArr.push(...flat(el, n - 1)) : flatArr.push(el)\\n    )\\n\\n    return flatArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3647141,
                "title": "javascript-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    \\n    if(n==0){\\n        return arr.slice();\\n    }\\n    \\n    let newArr = [];\\n\\n    arr.forEach((val) => {\\n        if(Array.isArray(val)){\\n            const nested = flat(val, n-1);\\n            newArr.push(...nested);\\n        }\\n        else{\\n            newArr.push(val);\\n        }\\n    });\\n\\n    return newArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    \\n    if(n==0){\\n        return arr.slice();\\n    }\\n    \\n    let newArr = [];\\n\\n    arr.forEach((val) => {\\n        if(Array.isArray(val)){\\n            const nested = flat(val, n-1);\\n            newArr.push(...nested);\\n        }\\n        else{\\n            newArr.push(val);\\n        }\\n    });\\n\\n    return newArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566468,
                "title": "javascript-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.reduce((acc, item) => {\\n        if(Array.isArray(item) && n > 0) {\\n            acc.push(...flat(item, n - 1))\\n        } else {\\n            acc.push(item)\\n        }\\n\\n        return acc\\n    }, [])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.reduce((acc, item) => {\\n        if(Array.isArray(item) && n > 0) {\\n            acc.push(...flat(item, n - 1))\\n        } else {\\n            acc.push(item)\\n        }\\n\\n        return acc\\n    }, [])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410946,
                "title": "easy-solution-short-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const ans =[]\\n    const traverse=(ele,i)=>{\\n        if(i > n || !Array.isArray(ele))return ans.push(ele)\\n        ele.forEach(e=>traverse(e ,i + 1))\\n    }\\n    traverse(arr,0)\\n    return ans \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const ans =[]\\n    const traverse=(ele,i)=>{\\n        if(i > n || !Array.isArray(ele))return ans.push(ele)\\n        ele.forEach(e=>traverse(e ,i + 1))\\n    }\\n    traverse(arr,0)\\n    return ans \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097587,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    function helper(arr,n) {\\n\\n        for (const el of arr) {\\n            if (Array.isArray(el) && n !== 0) {\\n                helper(el,n-1)\\n                continue;\\n            }\\n\\n            result.push(el)\\n        }\\n        return result\\n    }\\n    return helper(arr,n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    function helper(arr,n) {\\n\\n        for (const el of arr) {\\n            if (Array.isArray(el) && n !== 0) {\\n                helper(el,n-1)\\n                continue;\\n            }\\n\\n            result.push(el)\\n        }\\n        return result\\n    }\\n    return helper(arr,n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091701,
                "title": "flattening-multi-dimensional-arrays-to-a-specified-depth-in-javascript",
                "content": "# Intuition\\nThe problem requires flattening a multi-dimensional array up to a specified depth n. I need to decide whether to flatten subarrays or keep them intact based on their depth relative to `n`.\\n\\n# Approach\\n1. Create a function flat that takes two parameters: arr (the input array) and n (the specified depth).\\n2. Inside the flat function, define a helper function isArray to check if an item is an array.\\n3. Initialize an empty result array that will store the flattened elements.\\n4. Create a recursive function flattenArray to traverse the input array arr and flatten or keep subarrays based on the current depth.\\nIn the flattenArray function, iterate through the elements of arr.\\nFor each element:\\n    - If it\\'s an array and the current depth is less than n, recursively call flattenArray on that subarray with an incremented depth.\\n    - Otherwise, push the element to the result array.\\n5. Start the flattening process by calling flattenArray with the initial depth of 0.\\n6. Return the result array as the flattened output.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    function isArray(item) {\\n        return Array.isArray(item);\\n    }\\n\\n    var result = [];\\n\\n    function flattenArray(arr, currentDepth) {\\n        for (var i = 0; i < arr.length; i++) {\\n            if (isArray(arr[i]) && currentDepth < n) {\\n                flattenArray(arr[i], currentDepth + 1);\\n            } else {\\n                result.push(arr[i]);\\n            }\\n        }\\n    }\\n\\n    flattenArray(arr, 0);\\n\\n    return result;\\n};\\n\\n\\nvar arr1 = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]];\\nvar n1 = 0;\\nconsole.log(flat(arr1, n1));\\n\\nvar arr2 = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]];\\nvar n2 = 1;\\nconsole.log(flat(arr2, n2));\\n\\nvar arr3 = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]];\\nvar n3 = 2;\\nconsole.log(flat(arr3, n3));\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    function isArray(item) {\\n        return Array.isArray(item);\\n    }\\n\\n    var result = [];\\n\\n    function flattenArray(arr, currentDepth) {\\n        for (var i = 0; i < arr.length; i++) {\\n            if (isArray(arr[i]) && currentDepth < n) {\\n                flattenArray(arr[i], currentDepth + 1);\\n            } else {\\n                result.push(arr[i]);\\n            }\\n        }\\n    }\\n\\n    flattenArray(arr, 0);\\n\\n    return result;\\n};\\n\\n\\nvar arr1 = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]];\\nvar n1 = 0;\\nconsole.log(flat(arr1, n1));\\n\\nvar arr2 = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]];\\nvar n2 = 1;\\nconsole.log(flat(arr2, n2));\\n\\nvar arr3 = [[1, 2, 3], [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]];\\nvar n3 = 2;\\nconsole.log(flat(arr3, n3));\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090186,
                "title": "flatten-the-array-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    for(let i = 0; i < arr.length; i++){\\n        (Array.isArray(arr[i]) && n !== 0) ? result.push(...flat(arr[i], n - 1)) : result.push(arr[i])\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    for(let i = 0; i < arr.length; i++){\\n        (Array.isArray(arr[i]) && n !== 0) ? result.push(...flat(arr[i], n - 1)) : result.push(arr[i])\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085931,
                "title": "simple-recursion-with-typescript-beats-98-58",
                "content": "\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nfunction flatArray(arr:MultiDimensionalArray,outArr:MultiDimensionalArray,depth:number){\\n    depth--\\n    for(let a of arr){\\n        if(typeof a===\"number\") outArr.push(a)\\n        else if(depth<0) outArr.push(a)\\n        else flatArray(a,outArr,depth)\\n    }\\n}\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    const outArr:MultiDimensionalArray=[]\\n    flatArray(arr,outArr,n)\\n    return outArr\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nfunction flatArray(arr:MultiDimensionalArray,outArr:MultiDimensionalArray,depth:number){\\n    depth--\\n    for(let a of arr){\\n        if(typeof a===\"number\") outArr.push(a)\\n        else if(depth<0) outArr.push(a)\\n        else flatArray(a,outArr,depth)\\n    }\\n}\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    const outArr:MultiDimensionalArray=[]\\n    flatArray(arr,outArr,n)\\n    return outArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070821,
                "title": "recursive-function-flatten-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n   \\n    var res = [];\\n\\n    function helper(arr,depth) {\\n        for(const val of arr) {\\n            if(Array.isArray(val) && depth!=0 && depth <= n) {\\n                helper(val,depth - 1);\\n            } else {\\n                res.push(val);\\n            }\\n        }\\n        return res;\\n    }\\n    return helper(arr,n);\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n   \\n    var res = [];\\n\\n    function helper(arr,depth) {\\n        for(const val of arr) {\\n            if(Array.isArray(val) && depth!=0 && depth <= n) {\\n                helper(val,depth - 1);\\n            } else {\\n                res.push(val);\\n            }\\n        }\\n        return res;\\n    }\\n    return helper(arr,n);\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068448,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    if (!n)\\n        return arr;\\n\\n    let resultantArray = [];\\n    for (let i = 0; i < arr.length; ++i) {\\n        let temporaryResultArray = [];\\n        if (Array.isArray(arr[i]) && n) {\\n            temporaryResultArray = flat(arr[i], n - 1);\\n            resultantArray.push(...temporaryResultArray);\\n        }\\n        else {\\n            resultantArray.push(arr[i]);\\n        }\\n    }   \\n\\n    return resultantArray;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    if (!n)\\n        return arr;\\n\\n    let resultantArray = [];\\n    for (let i = 0; i < arr.length; ++i) {\\n        let temporaryResultArray = [];\\n        if (Array.isArray(arr[i]) && n) {\\n            temporaryResultArray = flat(arr[i], n - 1);\\n            resultantArray.push(...temporaryResultArray);\\n        }\\n        else {\\n            resultantArray.push(arr[i]);\\n        }\\n    }   \\n\\n    return resultantArray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067855,
                "title": "iterative-solution",
                "content": "```\\nvar flat = function (arr, n) {\\n    while(n>0){\\n        let ans =[];    \\n        let flag=false;\\n        for(let x of arr){\\n            if(Array.isArray(x)) {ans.push(...x); flag=true;}\\n            else ans.push(x);\\n        }\\n       if(flag===false) return ans;\\n        arr=ans;\\n        n--;\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar flat = function (arr, n) {\\n    while(n>0){\\n        let ans =[];    \\n        let flag=false;\\n        for(let x of arr){\\n            if(Array.isArray(x)) {ans.push(...x); flag=true;}\\n            else ans.push(x);\\n        }\\n       if(flag===false) return ans;\\n        arr=ans;\\n        n--;\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066057,
                "title": "deded",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n const res = [];\\n\\nfunction helper(arr,depth) {\\nfor(const val of arr) {\\nif(typeof(val) === \\'object\\' && depth < n) {\\nhelper(val,depth + 1);\\n} else {\\nres.push(val);\\n}\\n}\\nreturn res;\\n}\\nreturn helper(arr,0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n const res = [];\\n\\nfunction helper(arr,depth) {\\nfor(const val of arr) {\\nif(typeof(val) === \\'object\\' && depth < n) {\\nhelper(val,depth + 1);\\n} else {\\nres.push(val);\\n}\\n}\\nreturn res;\\n}\\nreturn helper(arr,0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064310,
                "title": "js-solve-with-explaination-upvote",
                "content": "## Problem: Flatten Array to a Specified Depth\\n\\nGiven an array and a depth, flatten the array to the specified depth.\\n\\n**Example**:\\nInput: [1, [2, 3, [4, 5]], 6], 1\\nOutput: [1, 2, 3, [4, 5], 6]\\n\\n### Solution: Recursion\\n\\nWe can use a recursive approach to flatten the array to a specified depth. \\n\\n```javascript\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    let result = [];\\n    if(n === 0) return arr;\\n    for(let item of arr){\\n        if(Array.isArray(item)){\\n            result.push(...flat(item, n - 1));\\n        }else{\\n            result.push(item);\\n        }\\n    }\\n    return result;\\n}\\n```\\n# UPVOTE NOW!!!\\n![Vote up.jpg](https://assets.leetcode.com/users/images/11d2f91f-c53f-4fd6-b26a-b61946656b12_1695126376.5285773.jpeg)\\n\\n## Explanation:\\n- We use a helper array named result to store the flattened elements.\\n- If the depth n is 0, we return the array as it is.\\n- We iterate over each element of the input array.\\n- If the element is an array (checked using Array.isArray(item)), we recursively call the flat function with a decreased depth n - 1 and spread its result into the result array.\\n- If the element is not an array, we simply push it into the result array.\\nFinally, we return the result",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    let result = [];\\n    if(n === 0) return arr;\\n    for(let item of arr){\\n        if(Array.isArray(item)){\\n            result.push(...flat(item, n - 1));\\n        }else{\\n            result.push(item);\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061918,
                "title": "easy-explanation-short-code-for-understanding-javascript",
                "content": "# Intuition\\n<!-- Generally speaking, flattening is about iterating over a nested array by its length and depth (which is length of the current arrays elements). -->\\n\\n# Approach\\n<!-- For length iteration, we simply use the forEach loop, for the width iteration, we use recursion. If the element of the current array has no depth(i.e. is a number) we simply push it to the returning array. Otherwise we push the destructed results of the array returned by the flat function -->\\n\\n\\n# Code\\n```\\nvar flat = function (arr, n) {\\n   if (n == 0) {\\n        return arr\\n    }\\n    let res = []\\n    n--\\n    arr.forEach(item => {\\n        if(typeof item == \\'number\\') res.push(item)    \\n        else res.push(...flat(item, n))\\n    })\\n    return res\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar flat = function (arr, n) {\\n   if (n == 0) {\\n        return arr\\n    }\\n    let res = []\\n    n--\\n    arr.forEach(item => {\\n        if(typeof item == \\'number\\') res.push(item)    \\n        else res.push(...flat(item, n))\\n    })\\n    return res\\n    \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059210,
                "title": "3-methods-using-reduce-concat-bruteforce-and-dfs",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, depth) {\\n    // Method 1: Using Reduce and concat. 127 / 131 testcases passed.\\n    /* if(depth === 0) return arr;\\n     return arr.reduce((acc, ele) => acc.concat((depth > 1 && Array.isArray(ele)) ? flat(ele, depth - 1): ele), []);\\n    */\\n\\n    // Method 2:\\n    /*\\n    if(depth === 0) return arr;\\n    let flattened = [];\\n    for(const ele of arr) {\\n        if(depth >= 1 && Array.isArray(ele)) {\\n            flattened.push(...flat(ele, depth - 1));\\n        } else {\\n            flattened.push(ele);\\n        }\\n    }\\n    return flattened;\\n    */\\n\\n    // Method 3: DFS\\n    let res = [];\\n    const dfs = (depth, maxDepth, arr) => {\\n        if(depth === maxDepth) {\\n            res.push(arr);\\n            return;\\n        }\\n        for(const ele of arr) {\\n            if(Array.isArray(ele)) {\\n                dfs(depth+1, maxDepth, ele);\\n            } else {\\n                res.push(ele);\\n            }\\n        }\\n    }\\n    dfs(-1, depth, arr);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, depth) {\\n    // Method 1: Using Reduce and concat. 127 / 131 testcases passed.\\n    /* if(depth === 0) return arr;\\n     return arr.reduce((acc, ele) => acc.concat((depth > 1 && Array.isArray(ele)) ? flat(ele, depth - 1): ele), []);\\n    */\\n\\n    // Method 2:\\n    /*\\n    if(depth === 0) return arr;\\n    let flattened = [];\\n    for(const ele of arr) {\\n        if(depth >= 1 && Array.isArray(ele)) {\\n            flattened.push(...flat(ele, depth - 1));\\n        } else {\\n            flattened.push(ele);\\n        }\\n    }\\n    return flattened;\\n    */\\n\\n    // Method 3: DFS\\n    let res = [];\\n    const dfs = (depth, maxDepth, arr) => {\\n        if(depth === maxDepth) {\\n            res.push(arr);\\n            return;\\n        }\\n        for(const ele of arr) {\\n            if(Array.isArray(ele)) {\\n                dfs(depth+1, maxDepth, ele);\\n            } else {\\n                res.push(ele);\\n            }\\n        }\\n    }\\n    dfs(-1, depth, arr);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058760,
                "title": "recursive-javascript-solution-with-closure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nconst flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n  let flattenedArray = []\\n\\n  function closureFlat(arr, n) {\\n      arr.forEach(ele => {\\n        if(Array.isArray(ele) && n > 0) {\\n          closureFlat(ele, n - 1)\\n        } else {\\n          flattenedArray.push(ele)\\n        }\\n      })\\n      return flattenedArray\\n  }\\n  return closureFlat(arr, n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nconst flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n  let flattenedArray = []\\n\\n  function closureFlat(arr, n) {\\n      arr.forEach(ele => {\\n        if(Array.isArray(ele) && n > 0) {\\n          closureFlat(ele, n - 1)\\n        } else {\\n          flattenedArray.push(ele)\\n        }\\n      })\\n      return flattenedArray\\n  }\\n  return closureFlat(arr, n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057581,
                "title": "beats-95-of-typescript-submissions",
                "content": "# Approach\\n1. Write a recursive function that keeps track of the current depth.\\n2. If the current depth >= the maximum depth, always just push the value to the returned array.\\n3. Otherwise, recursively call recurse on the array.\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    const res: MultiDimensionalArray = [];\\n    function recurse(arr: MultiDimensionalArray, depth: number) {\\n        for (const current of arr) {\\n            if (Array.isArray(current) && depth < n) {\\n                recurse(current, depth + 1);\\n            }\\n            else{\\n                res.push(current);\\n            }\\n        }\\n        return res;\\n    }\\n    return recurse(arr, 0);\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    const res: MultiDimensionalArray = [];\\n    function recurse(arr: MultiDimensionalArray, depth: number) {\\n        for (const current of arr) {\\n            if (Array.isArray(current) && depth < n) {\\n                recurse(current, depth + 1);\\n            }\\n            else{\\n                res.push(current);\\n            }\\n        }\\n        return res;\\n    }\\n    return recurse(arr, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057298,
                "title": "flatten-deeply-nested-array",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    // Create flattenArray\\n    const flattenArray = [];\\n\\n    // Create a flatten function to push data into the flatten array using \"Recursion\"\\n    const flattenFunction = (array, depth) => {\\n        // Loop over array for each element\\n        array.forEach(element => {\\n            // If element is array & this array depth is less than \"n\" \\n            if (Array.isArray(element) && depth < n) {\\n                // Recall the flatten function again\\n                flattenFunction(element, depth + 1);\\n            } else {\\n                // push element to the flatten array\\n                flattenArray.push(element);\\n            }\\n        });\\n\\n        return flattenArray;\\n    }\\n\\n    // Return the flatten function by calling it with a default depth equal to \"zero\"\\n    return flattenFunction(arr, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    // Create flattenArray\\n    const flattenArray = [];\\n\\n    // Create a flatten function to push data into the flatten array using \"Recursion\"\\n    const flattenFunction = (array, depth) => {\\n        // Loop over array for each element\\n        array.forEach(element => {\\n            // If element is array & this array depth is less than \"n\" \\n            if (Array.isArray(element) && depth < n) {\\n                // Recall the flatten function again\\n                flattenFunction(element, depth + 1);\\n            } else {\\n                // push element to the flatten array\\n                flattenArray.push(element);\\n            }\\n        });\\n\\n        return flattenArray;\\n    }\\n\\n    // Return the flatten function by calling it with a default depth equal to \"zero\"\\n    return flattenFunction(arr, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056044,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    const res = [];\\n    function helper(arr,depth) {\\n        for(const val of arr) {\\n            if(typeof(val) === \\'object\\' && depth < n) {\\n                helper(val,depth + 1);\\n            } else {\\n                res.push(val);\\n            }\\n        }\\n        return res;\\n    }\\n    return helper(arr,0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    const res = [];\\n    function helper(arr,depth) {\\n        for(const val of arr) {\\n            if(typeof(val) === \\'object\\' && depth < n) {\\n                helper(val,depth + 1);\\n            } else {\\n                res.push(val);\\n            }\\n        }\\n        return res;\\n    }\\n    return helper(arr,0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055554,
                "title": "two-methods-using-reduce-concat-bruteforce-approach",
                "content": "# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, depth) {\\n    // Method 1: Using Reduce and concat. 127 / 131 testcases passed.\\n    /* if(depth === 0) return arr;\\n     return arr.reduce((acc, ele) => acc.concat((depth > 1 && Array.isArray(ele)) ? flat(ele, depth - 1): ele), []);\\n    */\\n\\n    // Method 2:\\n    if(depth === 0) return arr;\\n    let flattened = [], temp;\\n    for(const ele of arr) {\\n        if(depth >= 1 && Array.isArray(ele)) {\\n            flattened.push(...flat(ele, depth - 1));\\n        } else {\\n            flattened.push(ele);\\n        }\\n    }\\n    return flattened;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, depth) {\\n    // Method 1: Using Reduce and concat. 127 / 131 testcases passed.\\n    /* if(depth === 0) return arr;\\n     return arr.reduce((acc, ele) => acc.concat((depth > 1 && Array.isArray(ele)) ? flat(ele, depth - 1): ele), []);\\n    */\\n\\n    // Method 2:\\n    if(depth === 0) return arr;\\n    let flattened = [], temp;\\n    for(const ele of arr) {\\n        if(depth >= 1 && Array.isArray(ele)) {\\n            flattened.push(...flat(ele, depth - 1));\\n        } else {\\n            flattened.push(ele);\\n        }\\n    }\\n    return flattened;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053249,
                "title": "javascript-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = function (nums, n) {\\n\\n    const target = [];\\n\\n    const recusion = (nums, n) => {\\n\\n        if (n === 0) {\\n            target.push(...nums);\\n            return;\\n        }\\n\\n        for (const num of nums) {\\n            if (Array.isArray(num)) {\\n                recusion(num, n - 1);\\n            } else {\\n                target.push(num);\\n            }\\n        }\\n    }\\n\\n    recusion(nums, n);\\n\\n    return target;\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = function (nums, n) {\\n\\n    const target = [];\\n\\n    const recusion = (nums, n) => {\\n\\n        if (n === 0) {\\n            target.push(...nums);\\n            return;\\n        }\\n\\n        for (const num of nums) {\\n            if (Array.isArray(num)) {\\n                recusion(num, n - 1);\\n            } else {\\n                target.push(num);\\n            }\\n        }\\n    }\\n\\n    recusion(nums, n);\\n\\n    return target;\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052871,
                "title": "use-of-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    const result = []\\n    function helper(array, depth)\\n    {\\n        if(depth < 0) return result.push(array)  \\n        array.map(item => {\\n            if(Array.isArray(item)){  \\n                return helper(item, depth-1)\\n            }\\n            else{\\n                result.push(item)\\n            }      \\n        })\\n    }\\n    helper(arr, n)\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Array} arr\\n * @param {number} depth\\n * @return {Array}\\n */\\nvar flat = function (arr, n) {\\n    const result = []\\n    function helper(array, depth)\\n    {\\n        if(depth < 0) return result.push(array)  \\n        array.map(item => {\\n            if(Array.isArray(item)){  \\n                return helper(item, depth-1)\\n            }\\n            else{\\n                result.push(item)\\n            }      \\n        })\\n    }\\n    helper(arr, n)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036539,
                "title": "with-inbuilt-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr=[], n) {\\n    for (i = 0; i < n; i++) {\\n        newP = [];\\n        arr.map(a => typeof(a)===\\'object\\'?newP.push(...a):newP.push(a));\\n        arr = newP\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr=[], n) {\\n    for (i = 0; i < n; i++) {\\n        newP = [];\\n        arr.map(a => typeof(a)===\\'object\\'?newP.push(...a):newP.push(a));\\n        arr = newP\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032624,
                "title": "flatten-deeply-nested-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSeeking the O(n) complexity, that approach looks optimal.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = (arr, n) => {\\n    if (n === 0) return arr;\\n\\n    const flattened = [];\\n    const flatten = (arr, depth) => {\\n        arr.forEach(e => {\\n            if (depth <= n && Array.isArray(e)) {\\n                flatten(e, depth + 1);\\n            } else {\\n                flattened.push(e);\\n            }\\n        })\\n    }\\n    flatten(arr, 1);\\n    return flattened;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = (arr, n) => {\\n    if (n === 0) return arr;\\n\\n    const flattened = [];\\n    const flatten = (arr, depth) => {\\n        arr.forEach(e => {\\n            if (depth <= n && Array.isArray(e)) {\\n                flatten(e, depth + 1);\\n            } else {\\n                flattened.push(e);\\n            }\\n        })\\n    }\\n    flatten(arr, 1);\\n    return flattened;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014339,
                "title": "easiest-solution-no-helper-function-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to recursively iterate over each array main array element\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Base condition:** when n equals 0 we return passed array itself \"no magic here\"\\n\\n**Steps:** \\n1- CREATE temp array to store flattning result of each recursive step.\\n\\n2- ITERATE over array and check if each element is an array or not.\\n\\n3- IF element is array then call the function again with decreasing value of n till you reach base case, each time array is returned the spread operator spreads its elements then all elements are pushed to the temp array\\n\\n4- IF it\\'s normal number just push it to the the temp array\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0)\\n        return arr\\n    \\n    let ans = [];\\n    for (item of arr) {\\n        if (Array.isArray(item)) {\\n            ans.push(...flat(item, n - 1));\\n        } else {\\n            ans.push(item);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0)\\n        return arr\\n    \\n    let ans = [];\\n    for (item of arr) {\\n        if (Array.isArray(item)) {\\n            ans.push(...flat(item, n - 1));\\n        } else {\\n            ans.push(item);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010466,
                "title": "one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006016,
                "title": "flatten-deeply-nested-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O((number all nested arrays in array on first `n` levels))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O((number all nested arrays in array on first `n` levels))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  const res = [];\\n  const m = [{value: arr, level: n}];\\n  while (m.length !== 0) {\\n    const currentEl = m.pop();\\n    if (!Array.isArray(currentEl.value)) {\\n      res.push(currentEl.value);\\n    } else if (currentEl.level === 0) {\\n      res.push(...currentEl.value);\\n    } else {\\n      let i = currentEl.value.length;\\n      const newLevel = currentEl.level - 1;\\n      while (i !== 0) {\\n        i--;\\n        m.push({value: currentEl.value[i], level: newLevel});\\n      }\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  const res = [];\\n  const m = [{value: arr, level: n}];\\n  while (m.length !== 0) {\\n    const currentEl = m.pop();\\n    if (!Array.isArray(currentEl.value)) {\\n      res.push(currentEl.value);\\n    } else if (currentEl.level === 0) {\\n      res.push(...currentEl.value);\\n    } else {\\n      let i = currentEl.value.length;\\n      const newLevel = currentEl.level - 1;\\n      while (i !== 0) {\\n        i--;\\n        m.push({value: currentEl.value[i], level: newLevel});\\n      }\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994519,
                "title": "spliced-recursion",
                "content": "# Intuition\\nThis needs to be recursive.\\n\\n# Approach\\nI wanted to use splice, but I think it may be a slow operation.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) so not great\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n  if(n<1) return arr;\\n\\n  for(let i=0;i<arr.length;i++){\\n      if(Array.isArray(arr[i])){\\n        const child = arr[i] as [];\\n        arr.splice(i,1,...child);\\n        //Move the index pointer so that the next increment moves past the items added by the child array\\n        i+=child.length-1;\\n      }\\n  }\\n  \\n  return flat(arr,n-1);\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n  if(n<1) return arr;\\n\\n  for(let i=0;i<arr.length;i++){\\n      if(Array.isArray(arr[i])){\\n        const child = arr[i] as [];\\n        arr.splice(i,1,...child);\\n        //Move the index pointer so that the next increment moves past the items added by the child array\\n        i+=child.length-1;\\n      }\\n  }\\n  \\n  return flat(arr,n-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3988821,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979551,
                "title": "recursion-with-closure-easy-to-read-modify",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion would be best way to flatten nested items.\\n\\nClosure would be handy to store output outside of recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing .push() to final array would be easier than capturing return values from .map().\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n)\\n    {\\n    let retVal = [];\\n\\n    // Closure for recursion:\\n    function flatInner(arr2,n2)\\n        {\\n        // When \"n\" aka depth is zero, return input un-flattened.\\n        // NOTE: this function gets invoked with original \"n\" -1, so\\n        // n===0 will invoke this with n2===-1 and return immediately,\\n        // n===1 will invoke this with n2===0 recurse once, ...\\n        if (n2 < 0 || ! Array.isArray(arr2)))\\n            {\\n            retVal.push(arr2);\\n            return;\\n            }\\n\\n        arr2.map( val => {\\n            flatInner(val, n2 - 1);\\n            })  // end .map()\\n        }   // end flatInner()\\n\\n    // Iterate through input array:\\n    flatInner(arr,n);\\n\\n    // Return final array:\\n    return retVal;\\n    };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n)\\n    {\\n    let retVal = [];\\n\\n    // Closure for recursion:\\n    function flatInner(arr2,n2)\\n        {\\n        // When \"n\" aka depth is zero, return input un-flattened.\\n        // NOTE: this function gets invoked with original \"n\" -1, so\\n        // n===0 will invoke this with n2===-1 and return immediately,\\n        // n===1 will invoke this with n2===0 recurse once, ...\\n        if (n2 < 0 || ! Array.isArray(arr2)))\\n            {\\n            retVal.push(arr2);\\n            return;\\n            }\\n\\n        arr2.map( val => {\\n            flatInner(val, n2 - 1);\\n            })  // end .map()\\n        }   // end flatInner()\\n\\n    // Iterate through input array:\\n    flatInner(arr,n);\\n\\n    // Return final array:\\n    return retVal;\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972951,
                "title": "recursion-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we see such type of problem always think about recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing recursion\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n, rA = []) {\\n    arr.forEach(item => {\\n        if(Array.isArray(item) && n > 0) {\\n            return flat(item, n - 1, rA)\\n        }\\n        rA.push(item);\\n    })\\n    return rA;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n, rA = []) {\\n    arr.forEach(item => {\\n        if(Array.isArray(item) && n > 0) {\\n            return flat(item, n - 1, rA)\\n        }\\n        rA.push(item);\\n    })\\n    return rA;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969706,
                "title": "java-bfs",
                "content": "# Intuition\\nThe goal of this problem is to flatten a nested array with a specified depth. We can achieve this by using a breadth-first approach where we process the array elements level by level up to the given depth.\\n\\n# Approach\\n1. We start by initializing a queue to hold the elements of the array.\\n2. We iterate through each depth level while reducing the depth count.\\n3. For each level, we process the current number of elements in the queue (since the queue size may change as we add elements).\\n4. If an element in the queue is a list, we convert it to a subarray and add its individual elements to the queue.\\n5. If an element is not a list, we add it back to the queue.\\n6. Repeat the above steps for the specified depth.\\n7. After processing all levels, the queue contains the flattened array with the specified depth.\\n\\n# Complexity\\n- Time complexity: O(N * D), where N is the total number of elements in the input array and D is the specified depth.\\n- Space complexity: O(N), where N is the total number of elements in the input array.\\n\\n# Further improvements\\nIn our current approach, we are processing each element as we reduce the depth. However, it\\'s necessary to only process elements that are lists each time we delve deeper.\\n\\n# Code\\n```java\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Queue;\\n\\npublic class FlattenArray {\\n    public static List<Object> flatten(Object[] arr, int depth) {\\n        Queue<Object> queue = new LinkedList<>();\\n        queue.addAll(Arrays.asList(arr));\\n\\n        while (depth > 0) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Object item = queue.poll();\\n                if (item instanceof List<?>) {\\n                    List<Object> subArray = new ArrayList<Object>((List<?>) item);\\n                    queue.addAll(subArray);\\n                } else {\\n                    queue.add(item);\\n                }\\n            }\\n            depth--;\\n        }\\n\\n        return new ArrayList<Object>(queue);\\n    }\\n\\n    public static void main(String[] args) {\\n        Object[] arr = new Object[]{\\n            1, 2, 3,\\n            Arrays.asList(4, 5, 6),\\n            Arrays.asList(\\n                7, 8,\\n                Arrays.asList(9, 10, 11),\\n                12\\n            ),\\n            Arrays.asList(13, 14, 15)\\n        };\\n\\n        List<Object> flattened = flatten(arr, 1);\\n        System.out.println(flattened);\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "# Intuition\\nThe goal of this problem is to flatten a nested array with a specified depth. We can achieve this by using a breadth-first approach where we process the array elements level by level up to the given depth.\\n\\n# Approach\\n1. We start by initializing a queue to hold the elements of the array.\\n2. We iterate through each depth level while reducing the depth count.\\n3. For each level, we process the current number of elements in the queue (since the queue size may change as we add elements).\\n4. If an element in the queue is a list, we convert it to a subarray and add its individual elements to the queue.\\n5. If an element is not a list, we add it back to the queue.\\n6. Repeat the above steps for the specified depth.\\n7. After processing all levels, the queue contains the flattened array with the specified depth.\\n\\n# Complexity\\n- Time complexity: O(N * D), where N is the total number of elements in the input array and D is the specified depth.\\n- Space complexity: O(N), where N is the total number of elements in the input array.\\n\\n# Further improvements\\nIn our current approach, we are processing each element as we reduce the depth. However, it\\'s necessary to only process elements that are lists each time we delve deeper.\\n\\n# Code\\n```java\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Queue;\\n\\npublic class FlattenArray {\\n    public static List<Object> flatten(Object[] arr, int depth) {\\n        Queue<Object> queue = new LinkedList<>();\\n        queue.addAll(Arrays.asList(arr));\\n\\n        while (depth > 0) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                Object item = queue.poll();\\n                if (item instanceof List<?>) {\\n                    List<Object> subArray = new ArrayList<Object>((List<?>) item);\\n                    queue.addAll(subArray);\\n                } else {\\n                    queue.add(item);\\n                }\\n            }\\n            depth--;\\n        }\\n\\n        return new ArrayList<Object>(queue);\\n    }\\n\\n    public static void main(String[] args) {\\n        Object[] arr = new Object[]{\\n            1, 2, 3,\\n            Arrays.asList(4, 5, 6),\\n            Arrays.asList(\\n                7, 8,\\n                Arrays.asList(9, 10, 11),\\n                12\\n            ),\\n            Arrays.asList(13, 14, 15)\\n        };\\n\\n        List<Object> flattened = flatten(arr, 1);\\n        System.out.println(flattened);\\n    }\\n}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3958505,
                "title": "simple-typescript-solution-with-recursion-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved with Recursion because you dont know how many subarrays will be there so in order to check each and every subarray i have use recursive approach in simple way\\n\\n# Complexity\\n- Time complexity: O(\\u2113) where \\u2113\\\\ell\\u2113 is the length of the array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(\\u2113)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n\\n    const Flatarr = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if(n > 0  && Array.isArray(arr[i])){\\n            const rawFlatArr =  flat(arr[i] as MultiDimensionalArray , n - 1);\\n            for (let elements of rawFlatArr.values()) {\\n                Flatarr.push(elements);\\n            }\\n        }\\n        else{\\n            Flatarr.push(arr[i]);\\n        }\\n    }\\n    return Flatarr; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n\\n    const Flatarr = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if(n > 0  && Array.isArray(arr[i])){\\n            const rawFlatArr =  flat(arr[i] as MultiDimensionalArray , n - 1);\\n            for (let elements of rawFlatArr.values()) {\\n                Flatarr.push(elements);\\n            }\\n        }\\n        else{\\n            Flatarr.push(arr[i]);\\n        }\\n    }\\n    return Flatarr; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951509,
                "title": "easy-to-understand-recursion-using-pattern-that-is-similar-to-solving-data-structure-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to step through each of the item in `arr` and if is met by `arr`, we want to explore more of subproblem make me think of recursion.\\n\\n#### 3 steps to writing a recursion functions\\n1) identify base case to break the recursion stack\\n2) changing the state and move toward the base case\\n3) decide whether to call itself\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use `Array.isArray()` to check if `subArray[i]` is an array so that this solution work for all type of data type and not just `number`\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m * n)$$, where m is the total number of elements in the input array and n is the depth up to which the flattening is performed.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(M + N)$$ - where m is the total number of elements in the input array, and n is the depth up to which the flattening is performed.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n === 0) return arr;\\n    const result = [];\\n    const helper = (subArray, n)=>{\\n        if(n === 0){\\n            result.push(...subArray);\\n            return;\\n        }\\n        for(let i = 0; i < subArray.length; i++){\\n            if(Array.isArray(subArray[i])){\\n                helper(subArray[i],n - 1);\\n            }else{\\n                result.push(subArray[i]);\\n            }\\n        }\\n    }\\n    helper(arr,n);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n === 0) return arr;\\n    const result = [];\\n    const helper = (subArray, n)=>{\\n        if(n === 0){\\n            result.push(...subArray);\\n            return;\\n        }\\n        for(let i = 0; i < subArray.length; i++){\\n            if(Array.isArray(subArray[i])){\\n                helper(subArray[i],n - 1);\\n            }else{\\n                result.push(subArray[i]);\\n            }\\n        }\\n    }\\n    helper(arr,n);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925088,
                "title": "best-solution-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n == 0) return arr;\\n    for(let i = 0; i < arr.length; i++){\\n        let item = arr[i];\\n        if(Array.isArray(item)){\\n            arr.splice(i, 1, ...item);\\n            i += item.length - 1;\\n        }\\n    }\\n    return flat(arr,--n);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n == 0) return arr;\\n    for(let i = 0; i < arr.length; i++){\\n        let item = arr[i];\\n        if(Array.isArray(item)){\\n            arr.splice(i, 1, ...item);\\n            i += item.length - 1;\\n        }\\n    }\\n    return flat(arr,--n);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923794,
                "title": "simple-fast",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n, flattened, current) {\\n    if (flattened === undefined) flattened = [];\\n    if (current === undefined) current = 0;\\n\\n    if (current > n) return flattened.push(arr);\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            flat(arr[i], n, flattened, current + 1);\\n        } else {\\n            flattened.push(arr[i]);\\n        }\\n    }\\n    \\n    return flattened;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n, flattened, current) {\\n    if (flattened === undefined) flattened = [];\\n    if (current === undefined) current = 0;\\n\\n    if (current > n) return flattened.push(arr);\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            flat(arr[i], n, flattened, current + 1);\\n        } else {\\n            flattened.push(arr[i]);\\n        }\\n    }\\n    \\n    return flattened;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919816,
                "title": "typescript-recurcive-solution",
                "content": "\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    if ( n === 0 ) return arr;\\n    let result: MultiDimensionalArray = [];\\n    for ( let i = 0; i < arr.length; i++ )\\n        if ( Array.isArray( arr[ i ] ) ) result.push( ...flat( arr[ i ] as MultiDimensionalArray, n - 1 ) )\\n        else result.push( arr[ i ] );\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    if ( n === 0 ) return arr;\\n    let result: MultiDimensionalArray = [];\\n    for ( let i = 0; i < arr.length; i++ )\\n        if ( Array.isArray( arr[ i ] ) ) result.push( ...flat( arr[ i ] as MultiDimensionalArray, n - 1 ) )\\n        else result.push( arr[ i ] );\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918908,
                "title": "easiest-to-undarstand-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let result = arr;\\n    for (let i=0; i<n; i++) {\\n        result = [].concat.apply([], result);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let result = arr;\\n    for (let i=0; i<n; i++) {\\n        result = [].concat.apply([], result);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917290,
                "title": "easy-guideline-for-javascript-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    const recursive = (element,num) => {\\n        if(num > 0 && Array.isArray(element)) {\\n            element.forEach(e => recursive(e, num -1))\\n        } else {\\n            result.push(element);\\n        }\\n    }\\n\\n    arr.forEach(a => recursive(a, n));\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    const recursive = (element,num) => {\\n        if(num > 0 && Array.isArray(element)) {\\n            element.forEach(e => recursive(e, num -1))\\n        } else {\\n            result.push(element);\\n        }\\n    }\\n\\n    arr.forEach(a => recursive(a, n));\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909596,
                "title": "javascript-solution-beats-98-08-recursive-approach",
                "content": "```javascript\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    const recursiveFlat = (auxArr, deep) => {\\n        if (typeof(auxArr) === \\'number\\' || deep < 0) {\\n            result.push(auxArr);\\n            return;\\n        }\\n        for (const elem of auxArr) {\\n            recursiveFlat(elem, deep-1);\\n        }\\n    };\\n    recursiveFlat(arr, n);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    const recursiveFlat = (auxArr, deep) => {\\n        if (typeof(auxArr) === \\'number\\' || deep < 0) {\\n            result.push(auxArr);\\n            return;\\n        }\\n        for (const elem of auxArr) {\\n            recursiveFlat(elem, deep-1);\\n        }\\n    };\\n    recursiveFlat(arr, n);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3904764,
                "title": "javascript-1-line",
                "content": "With the .flat method it\\'s quite easy...\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893327,
                "title": "flatten-multi-dimensional-array-to-depth",
                "content": "# Intuition\\nWe want to flatten a multi-dimensional array up to a given depth n, replacing sub-arrays with their elements only if the current depth of nesting is less than n.\\n\\n# Approach\\nWe can use a recursive approach to flatten the array. We iterate through each element of the array. If the element is an integer, we add it to the result array. If the element is an array and the current depth is less than n, we recursively flatten the sub-array up to the depth n-1. Otherwise, if the element is an array but the current depth is equal to or greater than n, we add the entire sub-array as a single element to the result array.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution depends on the total number of elements in the multi-dimensional array. In the worst case, where all elements are integers and the depth n is large, the time complexity could be O(N), where N is the total number of elements in the array.\\n\\n\\n- Space complexity:\\nThe space complexity is also dependent on the number of elements in the multi-dimensional array. In the worst case, where all elements are integers, and the depth n is large, the space complexity could be O(N), where N is the total number of elements in the array.\\n\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n\\n  function recursiveFlatten(subArray, depth) {\\n    for (const element of subArray) {\\n      if (Array.isArray(element) && depth < n) {\\n        recursiveFlatten(element, depth + 1);\\n      } else {\\n        result.push(element);\\n      }\\n    }\\n  }\\n\\n  recursiveFlatten(arr, 0);\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n\\n  function recursiveFlatten(subArray, depth) {\\n    for (const element of subArray) {\\n      if (Array.isArray(element) && depth < n) {\\n        recursiveFlatten(element, depth + 1);\\n      } else {\\n        result.push(element);\\n      }\\n    }\\n  }\\n\\n  recursiveFlatten(arr, 0);\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890487,
                "title": "no-additional-arrays-and-one-reccursive-function",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n-- === 0)\\n        return arr;\\n    for(let i = 0; i < arr.length; i++)\\n    {\\n        if(Array.isArray(arr[i])){\\n            //get array more flatted version\\n            const flattenArr = flat(arr[i], n);\\n            //flat it\\n            arr.splice(i--, 1);     \\n            flattenArr.forEach(element => arr.splice(++i, 0, element));\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n-- === 0)\\n        return arr;\\n    for(let i = 0; i < arr.length; i++)\\n    {\\n        if(Array.isArray(arr[i])){\\n            //get array more flatted version\\n            const flattenArr = flat(arr[i], n);\\n            //flat it\\n            arr.splice(i--, 1);     \\n            flattenArr.forEach(element => arr.splice(++i, 0, element));\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3870144,
                "title": "super-easy-recursion-detailed-approach-full-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1- first we write the base case ie if n =0 then we will simply return the given array as it is .\\n2- now we create an empty array (res) wherein we will be filling it with the elements of given array as per given depth condition.\\n3- use a for loop to iterate over the array and for each element we check if it is an array and if yes then is the allowed depth given to us greater than 0 i.e. do we need to go further inside this nested array or not.\\n*Recursive Step*\\n4- if yes then we simply use the spread operator to push the result of the flattend array of this sub array element we have encountered by passing it in the flat function with allowed depth one less than initial value and we have already gone inside one level.\\n5- if the conditon is not met ie the element is not an array or the allowed depth is not > 0 then we simply push that elemnt into our results array.\\n6- return the res array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n===0){\\n        return arr;\\n    }\\n    let res = [];\\n    for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i])&&n>0){\\n            res.push(...flat(arr[i],n-1));\\n        }else{\\n            res.push(arr[i]);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n===0){\\n        return arr;\\n    }\\n    let res = [];\\n    for(let i=0;i<arr.length;i++){\\n        if(Array.isArray(arr[i])&&n>0){\\n            res.push(...flat(arr[i],n-1));\\n        }else{\\n            res.push(arr[i]);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867350,
                "title": "easy-peasy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr = [], n) {\\n    var r = [];\\n\\n    if(n===0) return arr;\\n\\n    if (n > 0) {\\n        for(el of arr){\\n            if(Array.isArray(el))\\n                r.push(...flat(el,n-1))             \\n            else\\n                r.push(el)\\n        }\\n        n--\\n    }\\n\\n    return r\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr = [], n) {\\n    var r = [];\\n\\n    if(n===0) return arr;\\n\\n    if (n > 0) {\\n        for(el of arr){\\n            if(Array.isArray(el))\\n                r.push(...flat(el,n-1))             \\n            else\\n                r.push(el)\\n        }\\n        n--\\n    }\\n\\n    return r\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3865805,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    function helper(cur, depth) {\\n        const result = []\\n        cur.forEach(item => {\\n            if (depth < n && Array.isArray(item)) {\\n                result.push(...helper(item, depth + 1))\\n            } else {\\n                result.push(item)\\n            }\\n        })\\n        return result\\n    }\\n    return helper(arr, 0)\\n};\\n```\\n\\n```javascript\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    function helper(cur, depth) {\\n        return cur.reduce((x, y) => {\\n            if (depth < n && Array.isArray(y)) {\\n                x.push(...helper(y, depth + 1))\\n            } else {\\n                x.push(y)\\n            } return x\\n        }, [])\\n    }\\n    return helper(arr, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    function helper(cur, depth) {\\n        const result = []\\n        cur.forEach(item => {\\n            if (depth < n && Array.isArray(item)) {\\n                result.push(...helper(item, depth + 1))\\n            } else {\\n                result.push(item)\\n            }\\n        })\\n        return result\\n    }\\n    return helper(arr, 0)\\n};\\n```\n```javascript\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    function helper(cur, depth) {\\n        return cur.reduce((x, y) => {\\n            if (depth < n && Array.isArray(y)) {\\n                x.push(...helper(y, depth + 1))\\n            } else {\\n                x.push(y)\\n            } return x\\n        }, [])\\n    }\\n    return helper(arr, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3852244,
                "title": "javascript-recursive-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we need to flatten till given n , what we can do is to check if current is greater than n , so we can add it to our res , even if it\\'s number we can add irrespective of depth , else we can increase depth and recursively call child elements.\\n\\n\\n\\n# Code\\n```\\n    /**\\n    * @param {any[]} arr\\n    * @param {number} depth\\n    * @return {any[]}\\n    */\\n    var flat = function (arr, n) {\\n        var res=[]\\n        return flattenDeeplyNestedArray(res,arr,0,n);\\n       \\n\\n    };\\n\\n    const flattenDeeplyNestedArray =(res,arr,start,n)=> {\\n        if(typeof(arr)===\\'number\\' || start>n){\\n            res.push(arr)\\n            return arr;\\n        }      \\n        for(let i=0;i< arr.length;i++) \\n           flattenDeeplyNestedArray(res,arr[i],start+1,n);\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    /**\\n    * @param {any[]} arr\\n    * @param {number} depth\\n    * @return {any[]}\\n    */\\n    var flat = function (arr, n) {\\n        var res=[]\\n        return flattenDeeplyNestedArray(res,arr,0,n);\\n       \\n\\n    };\\n\\n    const flattenDeeplyNestedArray =(res,arr,start,n)=> {\\n        if(typeof(arr)===\\'number\\' || start>n){\\n            res.push(arr)\\n            return arr;\\n        }      \\n        for(let i=0;i< arr.length;i++) \\n           flattenDeeplyNestedArray(res,arr[i],start+1,n);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845229,
                "title": "easy-to-understand",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const res = [];\\n    n--;\\n    if(n < -1) {\\n        return [arr];\\n    }\\n    \\n    for(let val of arr) {\\n        if(Array.isArray(val)) {\\n            res.push(...flat(val, n));\\n        }else{\\n            res.push(val);\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const res = [];\\n    n--;\\n    if(n < -1) {\\n        return [arr];\\n    }\\n    \\n    for(let val of arr) {\\n        if(Array.isArray(val)) {\\n            res.push(...flat(val, n));\\n        }else{\\n            res.push(val);\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840536,
                "title": "beats-99-76-flatten-deeply-nested-array-easy-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const flat =[]\\n    const traverse=(ele,i)=>{\\n        if(i > n || !Array.isArray(ele))return flat.push(ele)\\n        ele.forEach(e=>traverse(e ,i + 1))\\n    }\\n    traverse(arr,0)\\n    return flat \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const flat =[]\\n    const traverse=(ele,i)=>{\\n        if(i > n || !Array.isArray(ele))return flat.push(ele)\\n        ele.forEach(e=>traverse(e ,i + 1))\\n    }\\n    traverse(arr,0)\\n    return flat \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839362,
                "title": "beats-99-69-simple-beginner-recursion",
                "content": "\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    \\n    if(n == 0) return arr;\\n\\n    let output = [];\\n    let depth = 0;\\n    flatten(arr,depth);\\n    return output\\n\\n    function flatten(arr,depth){\\n\\n        if(depth > n){\\n            output.push(arr);\\n            return;\\n        } \\n\\n        for(let i = 0;i<arr.length;i++){\\n            if(Array.isArray(arr[i])){\\n                flatten(arr[i],depth+1);\\n            } else {\\n                output.push(arr[i]);\\n            }\\n        }\\n        \\n    }\\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    \\n    if(n == 0) return arr;\\n\\n    let output = [];\\n    let depth = 0;\\n    flatten(arr,depth);\\n    return output\\n\\n    function flatten(arr,depth){\\n\\n        if(depth > n){\\n            output.push(arr);\\n            return;\\n        } \\n\\n        for(let i = 0;i<arr.length;i++){\\n            if(Array.isArray(arr[i])){\\n                flatten(arr[i],depth+1);\\n            } else {\\n                output.push(arr[i]);\\n            }\\n        }\\n        \\n    }\\n\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832926,
                "title": "82-ms-runtime-99-79-beats-62-6-mb-memory",
                "content": "\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\n\\nvar flat = function (arr, n) {\\n    \\n    // An array for store flatten elements\\n    const result = [];\\n\\n\\n    function recurs(arr, dep){$$O(n)$$\\n        arr.forEach(e=>{\\n\\n            // Checking that the element is an array and the depth is not equal to zero\\n            if(Array.isArray(e) && dep>0){\\n\\n                // Each time the function is called again, we go down one depth\\n                recurs(e, dep-1);\\n            }else{\\n\\n                // Directly push elements to result array\\n                result.push(e)\\n            }\\n        })\\n    }\\n    recurs(arr, n);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\n\\nvar flat = function (arr, n) {\\n    \\n    // An array for store flatten elements\\n    const result = [];\\n\\n\\n    function recurs(arr, dep){$$O(n)$$\\n        arr.forEach(e=>{\\n\\n            // Checking that the element is an array and the depth is not equal to zero\\n            if(Array.isArray(e) && dep>0){\\n\\n                // Each time the function is called again, we go down one depth\\n                recurs(e, dep-1);\\n            }else{\\n\\n                // Directly push elements to result array\\n                result.push(e)\\n            }\\n        })\\n    }\\n    recurs(arr, n);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832904,
                "title": "simple-readeble-recursive-solution",
                "content": "\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nconst flat = function (arr: MultiDimensionalArray, n: number): MultiDimensionalArray {\\n  if (n === 0) return arr;\\n  const result: any[] = [];\\n  for (const element of arr) {\\n    if (Array.isArray(element)) result.push(...flat(element, n - 1));\\n    else result.push(element);\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nconst flat = function (arr: MultiDimensionalArray, n: number): MultiDimensionalArray {\\n  if (n === 0) return arr;\\n  const result: any[] = [];\\n  for (const element of arr) {\\n    if (Array.isArray(element)) result.push(...flat(element, n - 1));\\n    else result.push(element);\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821951,
                "title": "simple-typescript-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    if (!n) {\\n        return arr;\\n    }\\n\\n    const result: MultiDimensionalArray = [];\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            result.push(...flat(arr[i] as MultiDimensionalArray, n - 1));\\n        } else {\\n            result.push(arr[i]);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    if (!n) {\\n        return arr;\\n    }\\n\\n    const result: MultiDimensionalArray = [];\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i])) {\\n            result.push(...flat(arr[i] as MultiDimensionalArray, n - 1));\\n        } else {\\n            result.push(arr[i]);\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820335,
                "title": "javascript-recursion-solution-o-m",
                "content": "# Intuition\\nRecursion is the key.\\n\\n# Approach\\n1. Took the liberty of taking one extra default argument in the function ( just for better storage of output )\\n2. Iterate over the array and write the logic to check if the item is an array.\\n3. If yes, call the flat function again, with reduced value of n, item as array and output reference (this is the beauty). Now we know that n is getting reduced and we only want to continue recursion till n reaches 0, so modify the if condition and add n!== 0 comparision with && operator.\\n4. If no, simply push the item to output array.\\n5. Outside of the iteration, return output.\\n\\n# Complexity\\n- Time complexity:\\nO(m) | m = number of input elements\\n\\n- Space complexity:\\nO(m) | m = number of input elements\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = (arr, n, output = []) => {\\n    arr.forEach(item => {\\n        if(n !== 0 && Array.isArray(item)){\\n            flat(item, n-1 ,output)\\n        }\\n        else{\\n            output.push(item)\\n        }\\n    })\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = (arr, n, output = []) => {\\n    arr.forEach(item => {\\n        if(n !== 0 && Array.isArray(item)){\\n            flat(item, n-1 ,output)\\n        }\\n        else{\\n            output.push(item)\\n        }\\n    })\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820328,
                "title": "simple-and-clean-using-flat-method",
                "content": "\\n\\n# Code\\n```\\nconst  flat = (arr, n)=> arr.flat(n)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst  flat = (arr, n)=> arr.flat(n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813332,
                "title": "efficient-recursive-flattening-beat-99-in-runtime-and-81-in-memory",
                "content": "# Hint\\n\\n- The function `flat` takes two parameters: an array `arr` and a number `n` representing the depth of flattening.\\n\\n- It uses recursion to flatten the input array `arr` up to `n` levels deep.\\n\\n- The function `flattenedArray` is a helper function responsible for recursive flattening.\\n\\n- For each element in the array `arr`, it checks if the element is an array and the current depth (`n`) is greater than zero.\\n\\n- If both conditions are true, it recursively calls `flattenedArray` with the nested array and `n-1` as the new depth.\\n\\n- If the element is not an array or the depth (`n`) is zero, it pushes the element into the `flattened` array.\\n\\n- After the recursive process, the `flattened` array contains the flattened elements of the input array `arr` up to `n` levels deep.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const flattened = [];\\n    const flattenedArray = (arr,n)=>{\\n        for(const items of arr){\\n            if(Array.isArray(items) & n > 0){\\n                flattenedArray(items,n-1);\\n            }else{\\n                flattened.push(items);\\n            }\\n        }\\n    }\\n    flattenedArray(arr,n);\\n    return flattened;\\n};\\n```\\n# Appeal:\\nIf you found this efficient recursive solution helpful, please consider giving it an upvote! Let\\'s celebrate the power of recursion and optimize our code together. Happy coding! \\uD83D\\uDE80\\uD83C\\uDF1F",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const flattened = [];\\n    const flattenedArray = (arr,n)=>{\\n        for(const items of arr){\\n            if(Array.isArray(items) & n > 0){\\n                flattenedArray(items,n-1);\\n            }else{\\n                flattened.push(items);\\n            }\\n        }\\n    }\\n    flattenedArray(arr,n);\\n    return flattened;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811893,
                "title": "simple-javascript-solution-explained",
                "content": "# Approach\\n- If n=0;return original array.\\n- Loop through array .\\n- If n>0 and the element is array,then push that array to new array and call recursive function so,that other sub arrays within that sub array be also pushed\\n- Finally,if original array just has an element,push into new array.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n==0){\\n      return arr;\\n    }\\n    const flattenedarray=[];\\n\\n    for(let i = 0;i<arr.length;i++){\\n      if(n>0 && Array.isArray(arr[i])){\\n        flattenedarray.push(...flat(arr[i],n-1))\\n      }\\n      else{\\n        flattenedarray.push(arr[i])\\n      }\\n    }\\n    return flattenedarray;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n==0){\\n      return arr;\\n    }\\n    const flattenedarray=[];\\n\\n    for(let i = 0;i<arr.length;i++){\\n      if(n>0 && Array.isArray(arr[i])){\\n        flattenedarray.push(...flat(arr[i],n-1))\\n      }\\n      else{\\n        flattenedarray.push(arr[i])\\n      }\\n    }\\n    return flattenedarray;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810876,
                "title": "javascript-solution-beats-96-84",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  let output = [];\\n  let currentLvl = 1;\\n  const flatArray = (arr, output, level) => {\\n    for (let i = 0; i < arr.length; i++) {\\n      const element = arr[i];\\n      if (Array.isArray(element) && currentLvl <= level) {\\n        flatArray(element, output, level, currentLvl++);\\n      } else {\\n        output.push(element);\\n      }\\n    }\\n    return --currentLvl;\\n  };\\n  flatArray(arr, output, n);\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  let output = [];\\n  let currentLvl = 1;\\n  const flatArray = (arr, output, level) => {\\n    for (let i = 0; i < arr.length; i++) {\\n      const element = arr[i];\\n      if (Array.isArray(element) && currentLvl <= level) {\\n        flatArray(element, output, level, currentLvl++);\\n      } else {\\n        output.push(element);\\n      }\\n    }\\n    return --currentLvl;\\n  };\\n  flatArray(arr, output, n);\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809485,
                "title": "using-recursion",
                "content": "# Intuition\\nWe iterate over each item in the array.\\nFor each item we pass it to recursively to the function.\\nThen we check if the item in the functional call stack is an array or not. If it is not, we return it as an array of that number.\\nIf the n becomes 0 we just return the array.\\nWhen we return the item, as its going to be an array, we destrucutre it and push it to the output array and return it.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    \\n    const flattenArray = (item,n) =>{\\n\\n        if (!Array.isArray(item)){\\n            return [item]\\n        }\\n\\n        if (!n){\\n            return item\\n        }\\n\\n        let output= [];\\n        \\n        for (let i = 0; i < item.length;i++){            \\n            const child = item[i];\\n            let result = flattenArray(child,n-1)                              \\n            output.push(...result)            \\n        }\\n        return output;\\n    }\\n\\n    return flattenArray(arr,n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    \\n    const flattenArray = (item,n) =>{\\n\\n        if (!Array.isArray(item)){\\n            return [item]\\n        }\\n\\n        if (!n){\\n            return item\\n        }\\n\\n        let output= [];\\n        \\n        for (let i = 0; i < item.length;i++){            \\n            const child = item[i];\\n            let result = flattenArray(child,n-1)                              \\n            output.push(...result)            \\n        }\\n        return output;\\n    }\\n\\n    return flattenArray(arr,n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799073,
                "title": "recursive-helper-function-solution",
                "content": "# Intuition\\nMy first intuition when solving this problem was to call a recursive function to copy the array at the proper depth.\\n\\n# Approach\\nVisiting each element of the array, recurse into the function when an Array is encountered, otherwise push non-Array elements.\\n\\nHowever, I didn\\'t like the fact that I was creating and throwing away garbage by generating new arrays via concat, so I created a separate helper function that would accept a \"global\" array that would be appended to.\\n\\nAlthough suitable for this coding challange, a practical problem with my  solution is that array references are getting pushed when depth is 0. Instead it would seem to be best to recursively make shallow copies instead of simply pushing their references.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nfunction flat (arr, depth) {\\n    const flattened = [];\\n\\n    flatImpl(arr, depth, flattened);\\n\\n    return flattened;\\n};\\n\\nfunction flatImpl(arr, depth, appendTo) {\\n    for (let i = 0; i < arr.length; ++i) {\\n        if (Array.isArray(arr[i]) && depth)\\n            flatImpl(arr[i], depth - 1, appendTo);\\n        else\\n            appendTo.push(arr[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nfunction flat (arr, depth) {\\n    const flattened = [];\\n\\n    flatImpl(arr, depth, flattened);\\n\\n    return flattened;\\n};\\n\\nfunction flatImpl(arr, depth, appendTo) {\\n    for (let i = 0; i < arr.length; ++i) {\\n        if (Array.isArray(arr[i]) && depth)\\n            flatImpl(arr[i], depth - 1, appendTo);\\n        else\\n            appendTo.push(arr[i]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795301,
                "title": "intuitive-solution-using-recursion-explanation-included",
                "content": "# Note\\nI recomend trying to implement the algorithm first before looking at the code. Personally, it helps me get the idea more effectively. If there is something that is still ambiguous, feel free to leave it in the comments!\\n\\nHappy coding!\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the question asks for you to flatten the array, we can think of each nested array as a smaller version of the problem. \\n\\nSomething like this: \\n```\\n[1, [2, 3, [4, 5]], 8]\\n```\\nWe can traverse through the array and keep track of the depth to make sure it doesn\\'t exceed n when we reach a nested array.\\n```\\n[1, [arr], 8]\\n=>[2, 3, [arr]]\\n==>[4, 5]\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize an array res, and create a helper function called flatten. \\n\\nThis function should take 2 parameters: The current depth, and the array it wants to process. We loop thorough ``array``, and for each element, we check if it is another array using ``typeof``. \\n\\n> NOTE: typeof array returns OBJECT, not array.\\n\\nIf it is an object and the current depth is less than n, we call the function again passing the array as the first parameter, and passing ```depth + 1``` as the second. otherwise, we just push it to res. Finally, we can call the function passing in the input ```array``` and ```depth``` as 0.\\n\\n```return res```.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n- Space complexity: $$O(n)$$ (recursive stack)\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    var res = [];\\n    function flatten(array, depth) {\\n        \\n        for(var i = 0; i < array.length; i++) {\\n            if(typeof array[i] == \"object\" && depth < n) {\\n                flatten(array[i], depth + 1)\\n            } else {\\n                res.push(array[i])\\n            }\\n        }\\n    }\\n    flatten(arr, 0)\\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n[1, [2, 3, [4, 5]], 8]\\n```\n```\\n[1, [arr], 8]\\n=>[2, 3, [arr]]\\n==>[4, 5]\\n```\n```depth + 1```\n```array```\n```depth```\n```return res```\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    var res = [];\\n    function flatten(array, depth) {\\n        \\n        for(var i = 0; i < array.length; i++) {\\n            if(typeof array[i] == \"object\" && depth < n) {\\n                flatten(array[i], depth + 1)\\n            } else {\\n                res.push(array[i])\\n            }\\n        }\\n    }\\n    flatten(arr, 0)\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794980,
                "title": "very-easy-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n\\n  let array=[];\\n  while(n--){\\n    arr.forEach(el=>{\\n      \\n      if(Array.isArray(el)){\\n        el.forEach(it=>array.push(it));\\n      }\\n      else array.push(el);\\n    })\\n    arr=array;\\n    array=[];\\n  }\\n  array=arr;\\n  return array;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n\\n  let array=[];\\n  while(n--){\\n    arr.forEach(el=>{\\n      \\n      if(Array.isArray(el)){\\n        el.forEach(it=>array.push(it));\\n      }\\n      else array.push(el);\\n    })\\n    arr=array;\\n    array=[];\\n  }\\n  array=arr;\\n  return array;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789251,
                "title": "easy-recursion-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursion.\\nProvide every level a number n.\\nSolve for that level number only.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n//zero level case: \\n\\n    if (n === 0) {\\n        return arr;\\n    }\\n    //function to fill result array when there is another level present in array\\n\\n    const fillArray = (array, result,n) => {\\n        result.pop();\\n        for(let i of array){\\n            result.push(i);\\n            if(n!==1 && typeof(i) === \\'object\\'){\\n                n--;    //next level number\\n                fillArray(i,result,n);\\n                n++;    //back to previous level number;\\n            }\\n        }\\n    }\\n\\n    let result = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        result.push(arr[i]);\\n        if(n!==0 && typeof(arr[i]) === \\'object\\'){\\n            fillArray(arr[i],result,n);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n//zero level case: \\n\\n    if (n === 0) {\\n        return arr;\\n    }\\n    //function to fill result array when there is another level present in array\\n\\n    const fillArray = (array, result,n) => {\\n        result.pop();\\n        for(let i of array){\\n            result.push(i);\\n            if(n!==1 && typeof(i) === \\'object\\'){\\n                n--;    //next level number\\n                fillArray(i,result,n);\\n                n++;    //back to previous level number;\\n            }\\n        }\\n    }\\n\\n    let result = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        result.push(arr[i]);\\n        if(n!==0 && typeof(arr[i]) === \\'object\\'){\\n            fillArray(arr[i],result,n);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781895,
                "title": "one-line-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781894,
                "title": "one-line-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770433,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nvar flat = function (arr, n) {\\n    if (n == 0) return arr;\\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        if (Array.isArray(arr[i])) {\\n            arr.splice(i, 1, ...arr[i]);\\n        }\\n    }\\n    return flat(arr, n - 1);    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flat = function (arr, n) {\\n    if (n == 0) return arr;\\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        if (Array.isArray(arr[i])) {\\n            arr.splice(i, 1, ...arr[i]);\\n        }\\n    }\\n    return flat(arr, n - 1);    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766414,
                "title": "js-solution",
                "content": "Use lodash.\\n\\n```\\nlet flat = (A, K) => _.flattenDepth(A, K);\\n```",
                "solutionTags": [],
                "code": "```\\nlet flat = (A, K) => _.flattenDepth(A, K);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761504,
                "title": "typescript-following-the-hints",
                "content": "# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    let ret: MultiDimensionalArray = []\\n    if(n===0) return arr\\n    else {\\n        for(const e of arr) {\\n            if(Array.isArray(e)) {\\n                ret.push(...flat(e, n-1))\\n            } else {\\n                ret.push(e)\\n            }\\n        }\\n    }\\n    return ret\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    let ret: MultiDimensionalArray = []\\n    if(n===0) return arr\\n    else {\\n        for(const e of arr) {\\n            if(Array.isArray(e)) {\\n                ret.push(...flat(e, n-1))\\n            } else {\\n                ret.push(e)\\n            }\\n        }\\n    }\\n    return ret\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760365,
                "title": "flatten-deeply-nested-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) { \\n  if(n === 0){\\n    return arr\\n  }\\n\\n  let result_arr = [];\\n  for (let i = 0; i < arr.length; i++) {\\n  let element = arr[i];\\n \\n    if (Array.isArray(element)) {\\n      let count = n - 1;  \\n      let flat_arr = flat(element, count);\\n      \\n      for(let i = 0; i < flat_arr.length; i++){\\n        result_arr.push(flat_arr[i])\\n    }\\n    continue;\\n  }\\n\\n  result_arr[result_arr.length] = element;\\n  }\\n  return result_arr;\\n  }\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) { \\n  if(n === 0){\\n    return arr\\n  }\\n\\n  let result_arr = [];\\n  for (let i = 0; i < arr.length; i++) {\\n  let element = arr[i];\\n \\n    if (Array.isArray(element)) {\\n      let count = n - 1;  \\n      let flat_arr = flat(element, count);\\n      \\n      for(let i = 0; i < flat_arr.length; i++){\\n        result_arr.push(flat_arr[i])\\n    }\\n    continue;\\n  }\\n\\n  result_arr[result_arr.length] = element;\\n  }\\n  return result_arr;\\n  }\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754059,
                "title": "please-share-your-opinions-on-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used recursive function to check if the element is an array and if the depth is already reached. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let final = [];\\n    function recur(item, depth = 0) {\\n        let final = [];\\n        if (Array.isArray(item) && depth < n) {\\n            for (let i = 0; i < item.length; i++) {\\n                final.push(...recur(item[i], depth + 1));\\n            }\\n        } else {\\n            final.push(item);\\n        }\\n\\n        return final;\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        final.push(...recur(arr[i]));\\n    }\\n\\n    return final;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let final = [];\\n    function recur(item, depth = 0) {\\n        let final = [];\\n        if (Array.isArray(item) && depth < n) {\\n            for (let i = 0; i < item.length; i++) {\\n                final.push(...recur(item[i], depth + 1));\\n            }\\n        } else {\\n            final.push(item);\\n        }\\n\\n        return final;\\n    }\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        final.push(...recur(arr[i]));\\n    }\\n\\n    return final;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754025,
                "title": "javascript-solution-in-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n + m)\\nn=total number of elements in the array\\nm=maximum nesting depth\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\n\\nvar flat = function (arr, n) {\\n  const res = [];\\n\\n  const flatArr = (nestedArr, level) => {\\n    if(level>n){\\n      res.push(nestedArr)\\n      return\\n    } \\n    for (let j = 0; j < nestedArr.length; j++) {\\n    if (typeof nestedArr[j] !== \"number\") flatArr(nestedArr[j], level+1); //if current is array. call the flatArr function\\n    else res.push(nestedArr[j]);\\n    }\\n  };\\n\\n\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (typeof arr[i] !== \"number\") flatArr(arr[i], 1); //if current is array. call the flatArr function\\n    else res.push(arr[i]);\\n  }\\n\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\n\\nvar flat = function (arr, n) {\\n  const res = [];\\n\\n  const flatArr = (nestedArr, level) => {\\n    if(level>n){\\n      res.push(nestedArr)\\n      return\\n    } \\n    for (let j = 0; j < nestedArr.length; j++) {\\n    if (typeof nestedArr[j] !== \"number\") flatArr(nestedArr[j], level+1); //if current is array. call the flatArr function\\n    else res.push(nestedArr[j]);\\n    }\\n  };\\n\\n\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (typeof arr[i] !== \"number\") flatArr(arr[i], 1); //if current is array. call the flatArr function\\n    else res.push(arr[i]);\\n  }\\n\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734831,
                "title": "siiimppple-solution-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734829,
                "title": "easyyyyyyy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729337,
                "title": "easy-and-simple-recursion",
                "content": "# Complexity\\n- Time complexity: 0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n==0) return arr;\\n    let temp = [];\\n    for(let item of arr){\\n        if(Array.isArray(item)&&n>0){\\n            temp.push(...flat(item,n-1));\\n        }else{\\n            temp.push(item);\\n        }\\n    }\\n    return temp;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n==0) return arr;\\n    let temp = [];\\n    for(let item of arr){\\n        if(Array.isArray(item)&&n>0){\\n            temp.push(...flat(item,n-1));\\n        }else{\\n            temp.push(item);\\n        }\\n    }\\n    return temp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728435,
                "title": "typescript-recursive-solution",
                "content": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    if(n==0) return arr;\\n    const res:MultiDimensionalArray=[]\\n    arr.forEach(item=>{\\n        if(typeof item==\"number\"){\\n            res.push(item)\\n        }else{\\n            res.push(...flat(item,n-1))\\n        }\\n    })\\n    return res;\\n};",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    if(n==0) return arr;\\n    const res:MultiDimensionalArray=[]\\n    arr.forEach(item=>{\\n        if(typeof item==\"number\"){\\n            res.push(item)\\n        }else{\\n            res.push(...flat(item,n-1))\\n        }\\n    })\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3724969,
                "title": "javascript-easy-method-beats-100-faster-beginner-s-friendly",
                "content": "```\\nconst flat = function (arr, n) {\\n   return arr.flat(n);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nconst flat = function (arr, n) {\\n   return arr.flat(n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715822,
                "title": "recursive-approach-using-2-base-cases-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thoughts about solving this type of problem is either through recursive approach or by using a stack based approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach has to first be able to flatten the array , that can just be done by remving `Base Case - 2` condition, array will be flattened. Now ir order to be able to ignore those cases wherein the depth of array is greater than `n` , I have introduced `Base Case - 2` condition, it will simply insert the whole array inside of `ans` variable.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  let ans = [];\\n  const convert = (arr, flatCount) => {\\n    console.log(flatCount, arr);\\n\\n    // Base Case - 1\\n    if (!Array.isArray(arr)) {\\n      ans.push(arr);\\n      return;\\n    }\\n\\n    // Base Case - 2\\n    if (flatCount > n) {\\n      ans.push(arr);\\n      return;\\n    }\\n\\n    arr.forEach((it) => {\\n      convert(it, flatCount + 1);\\n    });\\n  };\\n\\n  convert(arr, 0);\\n  console.log(\"ans: \", ans);\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  let ans = [];\\n  const convert = (arr, flatCount) => {\\n    console.log(flatCount, arr);\\n\\n    // Base Case - 1\\n    if (!Array.isArray(arr)) {\\n      ans.push(arr);\\n      return;\\n    }\\n\\n    // Base Case - 2\\n    if (flatCount > n) {\\n      ans.push(arr);\\n      return;\\n    }\\n\\n    arr.forEach((it) => {\\n      convert(it, flatCount + 1);\\n    });\\n  };\\n\\n  convert(arr, 0);\\n  console.log(\"ans: \", ans);\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715173,
                "title": "flatten-deeply-nested-array-javascript-is-powerfull-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = function (arr, n) {\\n    return arr.flat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713865,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\nvar flat = function (arr, n) {\\n    if(n == 0){\\n        return arr;\\n    }\\n    let answer = [];\\n    for(let i=0; i<arr.length; i++){\\n        if(n>0 && Array.isArray(arr[i])){\\n            answer.push(...flat(arr[i], n-1));\\n        }\\n        else{\\n            answer.push(arr[i]);\\n        }\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flat = function (arr, n) {\\n    if(n == 0){\\n        return arr;\\n    }\\n    let answer = [];\\n    for(let i=0; i<arr.length; i++){\\n        if(n>0 && Array.isArray(arr[i])){\\n            answer.push(...flat(arr[i], n-1));\\n        }\\n        else{\\n            answer.push(arr[i]);\\n        }\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702391,
                "title": "iterative-stack-solution-inorder-approach-no-reverse",
                "content": "Haven\\'t seen someone post a solution similar to this. Thought I would share.\\n\\n# Intuition\\nIterative Inorder DFS-like solution.\\nUtilise a stack to keep track of the depth as well as to maintain a snapshot of where we need to resume iterating\\n\\n# Approach\\nDFS-like approach with the usual bound checks\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\ntype Elem = {\\n    data: MultiDimensionalArray\\n    resumeIdx: number\\n}\\n\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    const stack = [{ data: arr, resumeIdx: 0 }]\\n    const result = []\\n\\n    while (stack.length > 0) {\\n        const { data, resumeIdx } = stack.pop()\\n\\n        if (stack.length === n + 1) {\\n            result.push(data)\\n            continue\\n        }\\n\\n        if (resumeIdx === data.length) {\\n            continue\\n        }\\n\\n        const val = data[resumeIdx]\\n\\n        // Since we popped off at the beginning of this iteration,\\n        // we\\'ll need to add it back to keep track of where we are\\n        stack.push({ data, resumeIdx: resumeIdx + 1 })\\n\\n        if (Array.isArray(val)) {\\n            stack.push({ data: val, resumeIdx: 0 })\\n        } else {\\n            result.push(val)\\n        }\\n\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\ntype Elem = {\\n    data: MultiDimensionalArray\\n    resumeIdx: number\\n}\\n\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    const stack = [{ data: arr, resumeIdx: 0 }]\\n    const result = []\\n\\n    while (stack.length > 0) {\\n        const { data, resumeIdx } = stack.pop()\\n\\n        if (stack.length === n + 1) {\\n            result.push(data)\\n            continue\\n        }\\n\\n        if (resumeIdx === data.length) {\\n            continue\\n        }\\n\\n        const val = data[resumeIdx]\\n\\n        // Since we popped off at the beginning of this iteration,\\n        // we\\'ll need to add it back to keep track of where we are\\n        stack.push({ data, resumeIdx: resumeIdx + 1 })\\n\\n        if (Array.isArray(val)) {\\n            stack.push({ data: val, resumeIdx: 0 })\\n        } else {\\n            result.push(val)\\n        }\\n\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3701530,
                "title": "javascript-single-line-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3699619,
                "title": "clear",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  if (n == 0) return arr;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n   \\n    if (Array.isArray(arr[i]) ) {\\n        let  temp=i;\\n        let arrLen=arr[i].length-1;\\n        arr.splice(i, 1, ...arr[i]);\\n        i=temp+ arrLen\\n    }\\n  }\\n  flat(arr,n-1)\\n \\n\\n\\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  if (n == 0) return arr;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n   \\n    if (Array.isArray(arr[i]) ) {\\n        let  temp=i;\\n        let arrLen=arr[i].length-1;\\n        arr.splice(i, 1, ...arr[i]);\\n        i=temp+ arrLen\\n    }\\n  }\\n  flat(arr,n-1)\\n \\n\\n\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696460,
                "title": "javascript-solution",
                "content": "```/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\n\\n\\nvar flat = function (arr, n) {\\n    \\n    if(n == 0) return arr;\\n    \\n    const ans = [];\\n    \\n    for(let element of arr){\\n        \\n        if(Array.isArray(element)){\\n            \\n            let ansSubarray = flat(element,n-1);\\n            for(let n of ansSubarray){\\n                ans.push(n);\\n            }\\n            \\n            \\n        } else {\\n            ans.push(element);\\n        }\\n        \\n    }\\n    \\n    return ans;\\n    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\n\\n\\nvar flat = function (arr, n) {\\n    \\n    if(n == 0) return arr;\\n    \\n    const ans = [];\\n    \\n    for(let element of arr){\\n        \\n        if(Array.isArray(element)){\\n            \\n            let ansSubarray = flat(element,n-1);\\n            for(let n of ansSubarray){\\n                ans.push(n);\\n            }\\n            \\n            \\n        } else {\\n            ans.push(element);\\n        }\\n        \\n    }\\n    \\n    return ans;\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3693321,
                "title": "simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = (arr, maxDepth = 0) => {\\n\\tconst res = [];\\n\\tconst flatten = (arr, depth = 0) => {\\n\\t\\tfor (let n of arr) Array.isArray(n) && depth < maxDepth ? flatten(n, depth + 1) : res.push(n);\\n\\t};\\n\\tflatten(arr);\\n\\treturn res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nconst flat = (arr, maxDepth = 0) => {\\n\\tconst res = [];\\n\\tconst flatten = (arr, depth = 0) => {\\n\\t\\tfor (let n of arr) Array.isArray(n) && depth < maxDepth ? flatten(n, depth + 1) : res.push(n);\\n\\t};\\n\\tflatten(arr);\\n\\treturn res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691771,
                "title": "solution-flatten-deeply-nested-array",
                "content": "# Intuition\\n- Recursively flatten the given multi-dimensional array while considering the depth constraint\\n\\n# Approach\\n- Approach used here is DFS - Depth First Traversal of the input Array.  \\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n- $$O(N)$$\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\n// var flat = function (arr, n) {\\n    \\n// };\\nfunction flat(arr, depth){\\n    const result = [];\\n    flatten(arr, depth, result);\\n    return result;\\n}\\nfunction flatten(arr, depth, result){\\n    for(let i = 0; i < arr.length; i++){\\n        if(Array.isArray(arr[i]) && depth > 0){\\n            flatten(arr[i], depth -1, result);\\n        } else {\\n            result.push(arr[i]);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\n// var flat = function (arr, n) {\\n    \\n// };\\nfunction flat(arr, depth){\\n    const result = [];\\n    flatten(arr, depth, result);\\n    return result;\\n}\\nfunction flatten(arr, depth, result){\\n    for(let i = 0; i < arr.length; i++){\\n        if(Array.isArray(arr[i]) && depth > 0){\\n            flatten(arr[i], depth -1, result);\\n        } else {\\n            result.push(arr[i]);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685207,
                "title": "flatten-array-using-reduce-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n\\n    return arr.reduce((res, item) => {\\n        if (Array.isArray(item)) {\\n            flat(item, n - 1).forEach((e) => {\\n                res.push(e);\\n            })\\n        } else {\\n            res.push(item);\\n        }\\n\\n        return res;\\n    }, []);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n\\n    return arr.reduce((res, item) => {\\n        if (Array.isArray(item)) {\\n            flat(item, n - 1).forEach((e) => {\\n                res.push(e);\\n            })\\n        } else {\\n            res.push(item);\\n        }\\n\\n        return res;\\n    }, []);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685186,
                "title": "flatten-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n\\n    return arr.reduce((res, item) => {\\n        if (Array.isArray(item)) {\\n            flat(item, n - 1).forEach((e) => {\\n                res.push(e);\\n            })\\n        } else {\\n            res.push(item);\\n        }\\n\\n        return res;\\n    }, []);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n\\n    return arr.reduce((res, item) => {\\n        if (Array.isArray(item)) {\\n            flat(item, n - 1).forEach((e) => {\\n                res.push(e);\\n            })\\n        } else {\\n            res.push(item);\\n        }\\n\\n        return res;\\n    }, []);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3673038,
                "title": "recursive-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nconst flat = (\\n  arr: MultiDimensionalArray,\\n  depth: number\\n): MultiDimensionalArray => {\\n  const result: MultiDimensionalArray = [];\\n\\n  const flatten = (\\n    nestedArray: MultiDimensionalArray,\\n    currentDepth: number\\n  ) => {\\n    for (const element of nestedArray) {\\n      if (Array.isArray(element) && currentDepth > 0 && currentDepth <= depth) {\\n        flatten(element, currentDepth - 1);\\n      } else {\\n        result.push(element);\\n      }\\n    }\\n  };\\n\\n  flatten(arr, depth);\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nconst flat = (\\n  arr: MultiDimensionalArray,\\n  depth: number\\n): MultiDimensionalArray => {\\n  const result: MultiDimensionalArray = [];\\n\\n  const flatten = (\\n    nestedArray: MultiDimensionalArray,\\n    currentDepth: number\\n  ) => {\\n    for (const element of nestedArray) {\\n      if (Array.isArray(element) && currentDepth > 0 && currentDepth <= depth) {\\n        flatten(element, currentDepth - 1);\\n      } else {\\n        result.push(element);\\n      }\\n    }\\n  };\\n\\n  flatten(arr, depth);\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667103,
                "title": "recursive-approach-simple-and-intuitive",
                "content": "\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let output=[]\\n    function flattening(arr,d){\\n        for(let i=0;i<arr.length;i++){\\n            ele=arr[i]\\n            if(Array.isArray(ele)){\\n                d++\\n                if(d<n) {\\n                    flattening(ele,d)\\n                    d--;\\n                }\\n                else{ // implies d==n\\n                    output.push(...ele)                    \\n                }\\n            }\\n            else{\\n                output.push(ele)               \\n           }\\n        }\\n    }\\n    if(n==0) return arr\\n    flattening(arr,0)\\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let output=[]\\n    function flattening(arr,d){\\n        for(let i=0;i<arr.length;i++){\\n            ele=arr[i]\\n            if(Array.isArray(ele)){\\n                d++\\n                if(d<n) {\\n                    flattening(ele,d)\\n                    d--;\\n                }\\n                else{ // implies d==n\\n                    output.push(...ele)                    \\n                }\\n            }\\n            else{\\n                output.push(ele)               \\n           }\\n        }\\n    }\\n    if(n==0) return arr\\n    flattening(arr,0)\\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666981,
                "title": "faster-recursive-solution",
                "content": "\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\nvar flat = function (arr, n) {\\n    if(n===0) return arr;\\n    let newArr = [];\\n    for(var i=0; i<arr.length; i++) {\\n        if(Array.isArray(arr[i])) {\\n            newArr.push(...flat(arr[i], n-1));\\n        } else {\\n            newArr.push(arr[i]);\\n        }\\n    }\\n    return newArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar flat = function (arr, n) {\\n    if(n===0) return arr;\\n    let newArr = [];\\n    for(var i=0; i<arr.length; i++) {\\n        if(Array.isArray(arr[i])) {\\n            newArr.push(...flat(arr[i], n-1));\\n        } else {\\n            newArr.push(arr[i]);\\n        }\\n    }\\n    return newArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666262,
                "title": "easiest-solution-heavily-explained",
                "content": "# Approach\\nThe base case is checked first: if `n` is 0 or every item in `arr` is not an array, we return `arr` as it is.\\n\\nThen we create an empty array `result` to store the flattened result.\\n\\nWe iterate over each element in `arr`.\\n\\nIf the current element is an array, we spread its elements and push them into the result array.\\n\\nIf the current element is not an array, we simply push it into the result array.\\n\\nFinally, we recursively call the `flat` function on the result array with `n` decremented by 1.\\n\\n\\n# Complexity\\n\\nThe time complexity of the `flat` function is `O(n * k)`, where `n` is the length of the input array and `k` is the maximum number of nested arrays.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    // Base case: if n is 0 or every item in arr is not an array, return arr as it is\\n    if (n === 0 || arr.every(item => !Array.isArray(item))) {\\n        return arr;\\n    }\\n\\n    // Create an empty array to store the flattened result\\n    const result = [];\\n\\n    // Iterate over each element in arr\\n    for (let i = 0; i < arr.length; i++) {\\n        // Check if the current element is an array\\n        if (Array.isArray(arr[i])) {\\n            // If it is an array, spread its elements and push them into the result array\\n            result.push(...arr[i]);\\n        } else {\\n            // If it is not an array, simply push the element into the result array\\n            result.push(arr[i]);\\n        }\\n    }\\n\\n    // Recursively call flat on the result array with n decremented by 1\\n    return flat(result, n - 1);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    // Base case: if n is 0 or every item in arr is not an array, return arr as it is\\n    if (n === 0 || arr.every(item => !Array.isArray(item))) {\\n        return arr;\\n    }\\n\\n    // Create an empty array to store the flattened result\\n    const result = [];\\n\\n    // Iterate over each element in arr\\n    for (let i = 0; i < arr.length; i++) {\\n        // Check if the current element is an array\\n        if (Array.isArray(arr[i])) {\\n            // If it is an array, spread its elements and push them into the result array\\n            result.push(...arr[i]);\\n        } else {\\n            // If it is not an array, simply push the element into the result array\\n            result.push(arr[i]);\\n        }\\n    }\\n\\n    // Recursively call flat on the result array with n decremented by 1\\n    return flat(result, n - 1);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659187,
                "title": "javascript-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar flat = function (arr, n) {\\n    \\n    let ans = [];\\n    req(arr,n);\\n    return ans;\\n\\n    function req(array,d){\\n\\n        for(let val of array){\\n\\n            if(d>0 && typeof val === \"object\"){\\n                req(val,d-1);\\n            }\\n            else{ ans.push(val); }\\n\\n        }\\n\\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar flat = function (arr, n) {\\n    \\n    let ans = [];\\n    req(arr,n);\\n    return ans;\\n\\n    function req(array,d){\\n\\n        for(let val of array){\\n\\n            if(d>0 && typeof val === \"object\"){\\n                req(val,d-1);\\n            }\\n            else{ ans.push(val); }\\n\\n        }\\n\\n    }\\n};\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643924,
                "title": "very-easy-to-understand-three-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    while (n>0){\\n        arr = arr.flat(n)\\n        n =0\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    while (n>0){\\n        arr = arr.flat(n)\\n        n =0\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3637265,
                "title": "recursive-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    var res = [];\\n    flatN(arr, n);\\n    function flatN(arr, k) {\\n        if(k <= 0) {\\n            res = res.concat(arr);\\n            return;\\n        }\\n        arr?.map((e)=> {\\n            if(typeof e === \\'number\\') res.push(e);\\n            else flatN(e, k-1);\\n        });\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    var res = [];\\n    flatN(arr, n);\\n    function flatN(arr, k) {\\n        if(k <= 0) {\\n            res = res.concat(arr);\\n            return;\\n        }\\n        arr?.map((e)=> {\\n            if(typeof e === \\'number\\') res.push(e);\\n            else flatN(e, k-1);\\n        });\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631924,
                "title": "js-recursive-solution-beats-84-3",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    \\n    let answer = []\\n    function flatten (arr,n){\\n        if (n <= 0){\\n            answer = [...answer, ...arr]\\n            return\\n        }\\n        else {\\n            arr.forEach(ele => {\\n                if (Array.isArray(ele)){\\n                    flatten(ele,n-1)\\n                }\\n                else {\\n                    answer.push(ele)\\n                }\\n            })\\n        }\\n        return answer\\n    }\\n    flatten(arr,n)\\n    return answer\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    \\n    let answer = []\\n    function flatten (arr,n){\\n        if (n <= 0){\\n            answer = [...answer, ...arr]\\n            return\\n        }\\n        else {\\n            arr.forEach(ele => {\\n                if (Array.isArray(ele)){\\n                    flatten(ele,n-1)\\n                }\\n                else {\\n                    answer.push(ele)\\n                }\\n            })\\n        }\\n        return answer\\n    }\\n    flatten(arr,n)\\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625070,
                "title": "js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    function helper(arr, depth) {\\n        const newArr = [];\\n\\n        if(depth == n) {\\n            return { shouldSpread: false, returnedArr: arr };\\n        }\\n\\n        for(let i=0; i<arr.length; i++) {\\n            if(Array.isArray(arr[i])) {\\n                const { shouldSpread, returnedArr } = helper(arr[i], depth + 1);\\n\\n                if(shouldSpread) {\\n                    newArr.push(...returnedArr);\\n                } else {\\n                    newArr.push(returnedArr);\\n                }\\n            } else {\\n                newArr.push(arr[i]);\\n            }\\n        }\\n\\n        return { shouldSpread: true, returnedArr: newArr };\\n    }\\n\\n    const { returnedArr } = helper(arr, -1);\\n\\n    return returnedArr;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    function helper(arr, depth) {\\n        const newArr = [];\\n\\n        if(depth == n) {\\n            return { shouldSpread: false, returnedArr: arr };\\n        }\\n\\n        for(let i=0; i<arr.length; i++) {\\n            if(Array.isArray(arr[i])) {\\n                const { shouldSpread, returnedArr } = helper(arr[i], depth + 1);\\n\\n                if(shouldSpread) {\\n                    newArr.push(...returnedArr);\\n                } else {\\n                    newArr.push(returnedArr);\\n                }\\n            } else {\\n                newArr.push(arr[i]);\\n            }\\n        }\\n\\n        return { shouldSpread: true, returnedArr: newArr };\\n    }\\n\\n    const { returnedArr } = helper(arr, -1);\\n\\n    return returnedArr;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623609,
                "title": "runtime-96-ms-beats-95-memory-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is required to flatten every subarray that is less than or equl to the depth of n.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor the depth relevant questions, the best solution is considering use recursion. Once we knew that, the only question is what is the edge case that we need to `quit the recursion`, and what we should do when `during this recursion`. \\n`Quit the recursion: ` \\nFor this question, we need to quit when the count of depth is larger than the n(the depth that indicated), and save the array into the result. \\n`During the recursion:` \\n1. if the item we read now is an array, pass the array to the next recursion, and increase the count with 1. \\n2. if the item is not an array, save this item into the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), n is length of all the items in the array\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2), as we need to use a res list to save the result, and some other space for use to recursive the subarrays, that part is depends on how many subarrays we have. In the worst case, for example, [1,[2,[3,[4,[5]]]]], it could be O(n^2). \\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n\\n    let res = []\\n    const flatFunction = (list, count) => {\\n        if (count > n) {\\n            res.push(list)\\n            return\\n        }\\n        let len = list.length\\n        for (let i = 0; i < len; i++) {\\n            if (typeof list[i] === \\'object\\') {\\n                flatFunction(list[i], count+1)\\n            } else {\\n                res.push(list[i])\\n            }   \\n        }\\n    }\\n    flatFunction(arr, 0)\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n\\n    let res = []\\n    const flatFunction = (list, count) => {\\n        if (count > n) {\\n            res.push(list)\\n            return\\n        }\\n        let len = list.length\\n        for (let i = 0; i < len; i++) {\\n            if (typeof list[i] === \\'object\\') {\\n                flatFunction(list[i], count+1)\\n            } else {\\n                res.push(list[i])\\n            }   \\n        }\\n    }\\n    flatFunction(arr, 0)\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607923,
                "title": "easy-solution-using-in-built-flat-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.flat(n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3604895,
                "title": "recursion-o-n-time-and-o-n-memory",
                "content": "Based on recursion. Algorithm iterates over array and call `flat(arr[i], n - 1)` function again if `Array.isArray(arr[i]) === true`. And finally return arr if reached target depth.\\n\\n# Complexity\\n- Time complexity: O(n) - we iterate over each element only once.\\n\\n- Space complexity: O(n) - in place array modifications based on element index\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  if (!n) return arr;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const flattened = flat(arr[i], n - 1);\\n      arr.splice(i, 1, ...flattened);\\n      i += flattened.length - 1;\\n    }\\n  }\\n\\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  if (!n) return arr;\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    if (Array.isArray(arr[i])) {\\n      const flattened = flat(arr[i], n - 1);\\n      arr.splice(i, 1, ...flattened);\\n      i += flattened.length - 1;\\n    }\\n  }\\n\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600665,
                "title": "simple-solution-for-flattening",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const res = [];\\n    function sol(arr,n1){\\n        for (const val of arr){\\n            if (typeof val === \\'object\\' && n1 < n){\\n                sol(val,n1+1)\\n            }\\n            else{res.push(val);} \\n        }\\n        return res\\n    }\\n    return sol(arr,0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const res = [];\\n    function sol(arr,n1){\\n        for (const val of arr){\\n            if (typeof val === \\'object\\' && n1 < n){\\n                sol(val,n1+1)\\n            }\\n            else{res.push(val);} \\n        }\\n        return res\\n    }\\n    return sol(arr,0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596275,
                "title": "easy-recursive-solution-using-array-spread-syntax",
                "content": "# Approach\\nloop over each element of the array, check if it is an array and if it is, then recursive call flat() for that element decrementing the value of n. (value of n is decremented then passed to record the depth)\\n\\n# Complexity\\n- Time complexity: O(n) where n is the total number of primitives (numbers) in the given input.\\n\\n\\n- Space complexity: flat() is called recursively for each depth level. Thus space complexity is O(n) where n is the maximum depth.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n==0) return arr;\\n    let res = [];\\n    for(let i = 0; i < arr.length; i++){\\n        if(arr[i] instanceof Array) res.push(...flat(arr[i],n-1));\\n        else res.push(arr[i]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n==0) return arr;\\n    let res = [];\\n    for(let i = 0; i < arr.length; i++){\\n        if(arr[i] instanceof Array) res.push(...flat(arr[i],n-1));\\n        else res.push(arr[i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594798,
                "title": "simplest-solution",
                "content": "using native flat function of javascript\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\nconst result=[]\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\nreturn arr.flat(n)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\nconst result=[]\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\nreturn arr.flat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594696,
                "title": "recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGoing to keep this short, my intuition told me this would be a O(n) complexity where I would have to check if an element was an array and make a decision from there. I also felt like I needed auxiliary storage because of the cost of insertion that are assosiated with dynamic arrays in javascript.\\n# Approach\\nI made a recursive function called flatten. It iterates through every element of the array and if element is an array and n > 0 then recursively calls itself with n = n-1 else it pushes elements to the auxiliary array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis complexity is $$O(n)$$ because n is the size of the array and we more or less have to go through every element of the array arguement. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ because the auxiliary array will be the size of the arguement array times some coefficient.\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    const flatten = function (arr,n,result){\\n      arr.forEach(el => {\\n        Array.isArray(el) && n > 0 ? flatten(el,n-1,result) : result.push(el);\\n      });\\n    }\\n    flatten(arr,n,result);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = [];\\n    const flatten = function (arr,n,result){\\n      arr.forEach(el => {\\n        Array.isArray(el) && n > 0 ? flatten(el,n-1,result) : result.push(el);\\n      });\\n    }\\n    flatten(arr,n,result);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594389,
                "title": "recursion-moderate-day-22",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function flat takes an input array arr and a n as parameters.\\n2. If the n equals 0, the function reaches the base case where no further flattening is required. In this case, the function returns the array.\\n3. If the n is greater than 0, the function proceeds with flattening the array.\\n4. The function initializes an empty array called res to store the flattened elements.\\n5. It iterates through each element of the input array using a forof loop.\\n6. For each element, it checks if it is an array using Array.isArray(val).\\n7. If the element is an array, it recursively calls the flat function with the nested array (val) and a decreased n (n - 1).\\n8. The result of the recursive call is nested array and we use ... spread operator to concatenate the elements of the nested array into the res array.\\n9. If the element is not an array, it is a single value, so it is directly pushed into the flattened array.\\n10. After iterating through all the elements, the function returns the res array as the final result.\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0)\\n        return arr;\\n    let res = [];\\n    for (let val of arr) {\\n        if (Array.isArray(val))\\n            res.push(...flat(val, n - 1));\\n        else\\n            res.push(val);\\n    }\\n    return res;    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0)\\n        return arr;\\n    let res = [];\\n    for (let val of arr) {\\n        if (Array.isArray(val))\\n            res.push(...flat(val, n - 1));\\n        else\\n            res.push(val);\\n    }\\n    return res;    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594278,
                "title": "typescript-recursive-solution",
                "content": "# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function(arr: MultiDimensionalArray, n: number): MultiDimensionalArray {\\n    if (n === 0) return arr.slice();\\n    \\n    const ans = [];\\n\\n    for (let i = 0, x = arr.length; i < x; i++)\\n        Array.isArray(arr[i])\\n            ? ans.push(...flat(arr[i] as MultiDimensionalArray, n - 1))\\n            : ans.push(arr[i]);\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function(arr: MultiDimensionalArray, n: number): MultiDimensionalArray {\\n    if (n === 0) return arr.slice();\\n    \\n    const ans = [];\\n\\n    for (let i = 0, x = arr.length; i < x; i++)\\n        Array.isArray(arr[i])\\n            ? ans.push(...flat(arr[i] as MultiDimensionalArray, n - 1))\\n            : ans.push(arr[i]);\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593412,
                "title": "simple-solution-recursion-array-push",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n === 0){\\n        return arr;\\n    }\\n    else{\\n        return arr.reduce((accumulated, elem) => {\\n            if(Array.isArray(elem)){\\n                accumulated.push(...flat(elem, n-1));\\n                return accumulated;\\n            }\\n            accumulated.push(elem);\\n            return accumulated;\\n        }, []);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n === 0){\\n        return arr;\\n    }\\n    else{\\n        return arr.reduce((accumulated, elem) => {\\n            if(Array.isArray(elem)){\\n                accumulated.push(...flat(elem, n-1));\\n                return accumulated;\\n            }\\n            accumulated.push(elem);\\n            return accumulated;\\n        }, []);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588931,
                "title": "the-clean-and-concise-solution",
                "content": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = []\\n    \\n    for (const a of arr) {\\n      if (Array.isArray(a) && n > 0) result.push(...flat(a, n - 1))\\n      else result.push(a)\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const result = []\\n    \\n    for (const a of arr) {\\n      if (Array.isArray(a) && n > 0) result.push(...flat(a, n - 1))\\n      else result.push(a)\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588314,
                "title": "day-22-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  if (n === 0) return arr;\\n\\n  let res = [];\\n\\n  for (let i = 0; i < arr.length; ++i) {\\n    if (Array.isArray(arr[i])) {\\n      const flatArr = n === 1 ? arr[i] : flat(arr[i], n - 1);\\n      for (let j = 0; j < flatArr.length; ++j) {\\n        res.push(flatArr[j]);\\n      }\\n    } else {\\n      res.push(arr[i]);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n  if (n === 0) return arr;\\n\\n  let res = [];\\n\\n  for (let i = 0; i < arr.length; ++i) {\\n    if (Array.isArray(arr[i])) {\\n      const flatArr = n === 1 ? arr[i] : flat(arr[i], n - 1);\\n      for (let j = 0; j < flatArr.length; ++j) {\\n        res.push(flatArr[j]);\\n      }\\n    } else {\\n      res.push(arr[i]);\\n    }\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583898,
                "title": "an-easy-way-to-solve-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n\\n    const result = [];\\n\\n    arr.forEach(item => {\\n      if (Array.isArray(item)) result.push(...flat(item, n - 1))\\n      else result.push(item);\\n    });\\n\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n\\n    const result = [];\\n\\n    arr.forEach(item => {\\n      if (Array.isArray(item)) result.push(...flat(item, n - 1))\\n      else result.push(item);\\n    });\\n\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583099,
                "title": "simple-typescript-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is The simple iterative aproch\\n# Complexity\\n- Time complexity: O(n^d) where d is depth n is average length of each array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n- \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    if(n==0) return arr;\\n     let ans: MultiDimensionalArray = [];\\n    for (let i = 0; i < n; i++) {\\n        ans = [];\\n        for (let e of arr)\\n            if (typeof e==\"object\")\\n                ans.push(...e);\\n            else\\n                ans.push(e);\\n        arr = ans;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    if(n==0) return arr;\\n     let ans: MultiDimensionalArray = [];\\n    for (let i = 0; i < n; i++) {\\n        ans = [];\\n        for (let e of arr)\\n            if (typeof e==\"object\")\\n                ans.push(...e);\\n            else\\n                ans.push(e);\\n        arr = ans;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582642,
                "title": "using-reduce-and-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can use array.reduce method because we need to convert in single value\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing reduce \\n\\u2705\\u2705 Please Upvote if you find it useful \\u2705\\u2705\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n===0){\\n        return arr\\n    }\\n    return arr.reduce((acc,each)=>{\\n        if(each.length>=0){\\n            acc.push(...flat(each,n-1)) \\n        }\\n        else{\\n            acc.push(each)\\n        }\\n        return acc;\\n    },[])\\n};\\n```\\n\\u2705\\u2705 Please Upvote if you find it useful \\u2705\\u2705",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n===0){\\n        return arr\\n    }\\n    return arr.reduce((acc,each)=>{\\n        if(each.length>=0){\\n            acc.push(...flat(each,n-1)) \\n        }\\n        else{\\n            acc.push(each)\\n        }\\n        return acc;\\n    },[])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576117,
                "title": "js-recursion-time-190ms-42-space-100mb-24",
                "content": "# Approach\\nWe recursively traverse the nested arrays, up to the maximum depth, and flatten the elements.\\n\\n# Complexity\\n- Time complexity:\\nO(n) *, where n is the number of elements in the flattened array*\\n\\n- Space complexity:\\nO(n) *, where n is the number of elements in the flattened array*\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n <= 0 || !Array.isArray(arr)) {\\n        return arr;\\n    }\\n    else { // for arrays\\n        let out = [];\\n        for (const elem of arr) {\\n            let flatt = flat(elem, n - 1);\\n            if (!Array.isArray(flatt)) out.push(flatt);\\n            else out.push(...flatt);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n <= 0 || !Array.isArray(arr)) {\\n        return arr;\\n    }\\n    else { // for arrays\\n        let out = [];\\n        for (const elem of arr) {\\n            let flatt = flat(elem, n - 1);\\n            if (!Array.isArray(flatt)) out.push(flatt);\\n            else out.push(...flatt);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572148,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n == 0){\\n        return arr;\\n    }\\n    else{\\n         let resultarr = [];\\n    for(let i=0; i<arr.length; i++){\\n        if(n>0 && Array.isArray(arr[i])){\\n            resultarr.push(...flat(arr[i], n-1));\\n                  }\\n        else{\\n            resultarr.push(arr[i]);\\n             }\\n        }\\n     return resultarr;\\n        }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n == 0){\\n        return arr;\\n    }\\n    else{\\n         let resultarr = [];\\n    for(let i=0; i<arr.length; i++){\\n        if(n>0 && Array.isArray(arr[i])){\\n            resultarr.push(...flat(arr[i], n-1));\\n                  }\\n        else{\\n            resultarr.push(arr[i]);\\n             }\\n        }\\n     return resultarr;\\n        }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569714,
                "title": "simple-solution-using-recursion-o-n-time-o-n-d-space",
                "content": "# Complexity\\n- Time complexity: **O(n)** - where **n** is the total number of elements in the input array\\n- Space complexity: **O(n + d)** - where **n** is the total number of elements in the input array and **d** is the maximum depth specified which is input n\\n\\n# Code\\n```\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n    return recursiveHelper(arr, n, 0, []);\\n};\\n\\nfunction recursiveHelper(arr, maxDepth, curDepth, result) {\\n    if (curDepth > maxDepth) {\\n        result.push(arr);\\n        return result;\\n    }\\n    \\n    for (const element of arr) {\\n        if (Array.isArray(element)) {\\n            recursiveHelper(element, maxDepth, curDepth + 1, result);\\n        } else {\\n            result.push(element);\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flat = function (arr, n) {\\n    if (n === 0) return arr;\\n    return recursiveHelper(arr, n, 0, []);\\n};\\n\\nfunction recursiveHelper(arr, maxDepth, curDepth, result) {\\n    if (curDepth > maxDepth) {\\n        result.push(arr);\\n        return result;\\n    }\\n    \\n    for (const element of arr) {\\n        if (Array.isArray(element)) {\\n            recursiveHelper(element, maxDepth, curDepth + 1, result);\\n        } else {\\n            result.push(element);\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567869,
                "title": "array-to-recursin-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n===0) return arr;\\n\\n    function flat(array, deth=1) {\\n            let result = [];\\n            (function flattener (list, dp) {\\n      for (let el of list) {\\n          if (Array.isArray(el) && dp) {\\n              flattener(el, dp-1)\\n          } else {\\n              result.push(el)\\n          }\\n      }\\n            })(array, deth);\\n            return result;\\n    }\\nreturn flat(arr, n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if (n===0) return arr;\\n\\n    function flat(array, deth=1) {\\n            let result = [];\\n            (function flattener (list, dp) {\\n      for (let el of list) {\\n          if (Array.isArray(el) && dp) {\\n              flattener(el, dp-1)\\n          } else {\\n              result.push(el)\\n          }\\n      }\\n            })(array, deth);\\n            return result;\\n    }\\nreturn flat(arr, n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567509,
                "title": "recursive-and-iterative-approach",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n === 0) {\\n        return arr;\\n    }\\n    \\n    let re = []\\n    for(let el of arr) {\\n        if(Array.isArray(el)) {\\n            re.push(...flat(el, n-1)) ;\\n        }else {\\n            re.push(el)\\n        }\\n    }\\n\\n    return re\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n === 0) {\\n        return arr;\\n    }\\n    \\n    let re = []\\n    for(let el of arr) {\\n        if(Array.isArray(el)) {\\n            re.push(...flat(el, n-1)) ;\\n        }else {\\n            re.push(el)\\n        }\\n    }\\n\\n    return re\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566855,
                "title": "javascript-authentic-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n\\n    let res = [];\\n\\n    // base case \\n    function flatten(arr , n){\\n        if(!Array.isArray(arr)){\\n        res.push(arr);\\n        return\\n    }\\n    if(n==0) {res.push(...arr); return;}\\n   for(let i=0;i<arr.length;i++){\\n     flatten(arr[i] , n-1);\\n   }\\n   }\\n\\n  flatten(arr , n);\\n\\n  return res;\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n\\n    let res = [];\\n\\n    // base case \\n    function flatten(arr , n){\\n        if(!Array.isArray(arr)){\\n        res.push(arr);\\n        return\\n    }\\n    if(n==0) {res.push(...arr); return;}\\n   for(let i=0;i<arr.length;i++){\\n     flatten(arr[i] , n-1);\\n   }\\n   }\\n\\n  flatten(arr , n);\\n\\n  return res;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565860,
                "title": "beats-97-simple-solution-with-comments",
                "content": "# Approach\\nGo through every element of an array recursively until the highest recursive depth is reached or non-array is met. Then push it to results.\\n\\n# Code\\n```\\nconst flat = function (arr, n) {\\n    const ret = [];\\n    const f = (a, k) => {\\n        // if we\\'re allowed to flatten deeper and an array is given\\n        if(k > 0 && Array.isArray(a)){\\n            a.forEach(x => f(x, k - 1))\\n        // if we\\'ve reached the highest available depth or non-array is provided\\n        } else {\\n            ret.push(a);\\n        }\\n    }\\n    arr.forEach(x => f(x, n))\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst flat = function (arr, n) {\\n    const ret = [];\\n    const f = (a, k) => {\\n        // if we\\'re allowed to flatten deeper and an array is given\\n        if(k > 0 && Array.isArray(a)){\\n            a.forEach(x => f(x, k - 1))\\n        // if we\\'ve reached the highest available depth or non-array is provided\\n        } else {\\n            ret.push(a);\\n        }\\n    }\\n    arr.forEach(x => f(x, n))\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565787,
                "title": "simple-solution-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe function takes an array `arr` and a depth `n` as input parameters. It flattens the array by concatenating all nested arrays up to the given depth `n` into a single flat array. The function recursively explores each element in the input array and handles nested arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty array `res` to store the flattened elements.\\n2. Iterate over each element in the input array `arr`.\\n3. For each element, check if it is an array and if the depth `n` is greater than `0`. If both conditions are true, recursively call the `flat` function on the nested array with a reduced depth (`n - 1`).\\n    - This recursive call will flatten the nested array up to the desired depth.\\n    - Use the spread operator (`...`) to push the flattened nested array\\'s elements into the `res` array.\\n    - Continue to the next iteration of the loop.\\n4. If the current element is not an array or the depth `n` is 0, push the element itself into the `res` array.\\n5. Repeat steps 3-4 for all elements in the input array.\\n6. Return the `res` array, which contains all the flattened elements.\\n\\n# Code\\n``` javascript []\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let res = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i]) && n) {\\n            res.push(...flat(arr[i], n - 1));\\n            continue;\\n        }\\n        res.push(arr[i]);\\n    }\\n\\n    return res;\\n};\\n```\\n``` typescript []\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    let res: MultiDimensionalArray = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i]) && n) {\\n            res.push(...flat(arr[i] as MultiDimensionalArray, n - 1));\\n            continue;\\n        }\\n        res.push(arr[i]);\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Recursion"
                ],
                "code": "``` javascript []\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    let res = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i]) && n) {\\n            res.push(...flat(arr[i], n - 1));\\n            continue;\\n        }\\n        res.push(arr[i]);\\n    }\\n\\n    return res;\\n};\\n```\n``` typescript []\\ntype MultiDimensionalArray = (number | MultiDimensionalArray)[];\\n\\nvar flat = function (arr:  MultiDimensionalArray, n: number):  MultiDimensionalArray {\\n    let res: MultiDimensionalArray = [];\\n    for (let i = 0; i < arr.length; i++) {\\n        if (Array.isArray(arr[i]) && n) {\\n            res.push(...flat(arr[i] as MultiDimensionalArray, n - 1));\\n            continue;\\n        }\\n        res.push(arr[i]);\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565729,
                "title": "beat-99-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Make this main function recursive and add extra `res` array as a parameter to hold the result\\n- Iterate through the array\\n- if n is 0, push the whole element to the `res`\\n- if n is not 0, check the element is array or not and call recursive function\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n, res=[]) {\\n    for(let elem of arr) {\\n        if(n===0) {\\n            res.push(elem);\\n        } else {\\n            if(elem instanceof Array) flat(elem, n-1, res);\\n            else res.push(elem);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n, res=[]) {\\n    for(let elem of arr) {\\n        if(n===0) {\\n            res.push(elem);\\n        } else {\\n            if(elem instanceof Array) flat(elem, n-1, res);\\n            else res.push(elem);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565721,
                "title": "2625-flatten-deeply-nested-array-javascript-day-22",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const res=[];\\n    function helper(arr,d){\\n      for(const val of arr){\\n        if (typeof(val)===\"object\" && d<n){\\n          helper(val,d+1);\\n        }\\n        else{\\n          res.push(val);\\n        }\\n      }\\n      return res;\\n    }\\n    return helper(arr,0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    const res=[];\\n    function helper(arr,d){\\n      for(const val of arr){\\n        if (typeof(val)===\"object\" && d<n){\\n          helper(val,d+1);\\n        }\\n        else{\\n          res.push(val);\\n        }\\n      }\\n      return res;\\n    }\\n    return helper(arr,0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565708,
                "title": "javascript-easy-to-understand-solution-beating-99",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (o, n) {\\n   const res = []\\n\\n    const helper = (o, n) => {\\n        for (const val of o) {\\n            if (typeof val === \\'object\\' && n > 0) {\\n                helper(val, n - 1)\\n            } else {\\n                res.push(val)\\n            }\\n        }\\n        return res\\n    }\\n   \\n    return helper(o, n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (o, n) {\\n   const res = []\\n\\n    const helper = (o, n) => {\\n        for (const val of o) {\\n            if (typeof val === \\'object\\' && n > 0) {\\n                helper(val, n - 1)\\n            } else {\\n                res.push(val)\\n            }\\n        }\\n        return res\\n    }\\n   \\n    return helper(o, n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565690,
                "title": "easiest-explanation",
                "content": "\\n# Code\\n``` javaScript []\\nvar flat = function (arr, n) {\\n    \\n    // No need for flattening\\n    if(n == 0) return arr;\\n    \\n    // Resultant array\\n    let result = [];\\n    \\n\\n    for(let i = 0; i < arr.length; ++i) {\\n        \\n        // depth is greater than 0\\n        // check if element array itself\\n        if(n > 0 && Array.isArray(arr[i]))\\n            \\n            // call recursively\\n            // keep pushing the flattened array to the resultant array\\n            result.push(...flat(arr[i], n-1));\\n\\n        // else directy push the current array\\n        else result.push(arr[i]);\\n\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar flat = function (arr, n) {\\n    \\n    // No need for flattening\\n    if(n == 0) return arr;\\n    \\n    // Resultant array\\n    let result = [];\\n    \\n\\n    for(let i = 0; i < arr.length; ++i) {\\n        \\n        // depth is greater than 0\\n        // check if element array itself\\n        if(n > 0 && Array.isArray(arr[i]))\\n            \\n            // call recursively\\n            // keep pushing the flattened array to the resultant array\\n            result.push(...flat(arr[i], n-1));\\n\\n        // else directy push the current array\\n        else result.push(arr[i]);\\n\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565660,
                "title": "ts-js-solution-flattened-array-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- if n==0 return original array\\n- else run a while loop till the depth variable < n\\n- store all the results in a result array\\n- inside the while loop, have a for loop that checks if each element is again an array(nested array) or not .\\n- if an array, flaten it and push. if not, push the element into result\\n- after every for loop assign arr=result\\n- finally return the arr\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n     let result; \\n     let depth=0;\\n    if(n == 0)\\n     return arr;\\n    else{\\n      while(depth<n){\\n          result=[];\\n        for(var i=0;i<arr.length;i++){\\n            if(Array.isArray(arr[i])){\\n                result.push(...arr[i])\\n            }\\n            else{\\n                result.push(arr[i]);\\n            }\\n        }\\n        arr=[...result];\\n        depth++;\\n     }\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n     let result; \\n     let depth=0;\\n    if(n == 0)\\n     return arr;\\n    else{\\n      while(depth<n){\\n          result=[];\\n        for(var i=0;i<arr.length;i++){\\n            if(Array.isArray(arr[i])){\\n                result.push(...arr[i])\\n            }\\n            else{\\n                result.push(arr[i]);\\n            }\\n        }\\n        arr=[...result];\\n        depth++;\\n     }\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565607,
                "title": "clean-recursive-solution-with-reduce",
                "content": "# Intuition\\nRecursive solution like shown in the editorial but using the `.reduce()` Array method instead of a result and an internal callback function. I personally think it reads a lot better and is more functional.\\n\\n\\n# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.reduce((acc, ele) => {\\n      if(Array.isArray(ele) && n > 0){\\n        acc.push(...flat(ele, n - 1))\\n      }else{\\n        acc.push(ele);\\n      }\\n\\n      return acc;\\n    }, [])\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    return arr.reduce((acc, ele) => {\\n      if(Array.isArray(ele) && n > 0){\\n        acc.push(...flat(ele, n - 1))\\n      }else{\\n        acc.push(ele);\\n      }\\n\\n      return acc;\\n    }, [])\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565588,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat=function (arr,n){\\n    if(n==0){\\n        return arr;\\n    }\\n    let ans=[];\\n    let m=arr.length;\\n    \\n    for(let i=0;i<m;i++){\\n        if(n>0 && Array.isArray(arr[i])){\\n            ans.push(...flat(arr[i],n-1));\\n        }else{\\n            ans.push(arr[i]);\\n        }\\n    }\\n    \\n    return ans \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat=function (arr,n){\\n    if(n==0){\\n        return arr;\\n    }\\n    let ans=[];\\n    let m=arr.length;\\n    \\n    for(let i=0;i<m;i++){\\n        if(n>0 && Array.isArray(arr[i])){\\n            ans.push(...flat(arr[i],n-1));\\n        }else{\\n            ans.push(arr[i]);\\n        }\\n    }\\n    \\n    return ans \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565522,
                "title": "simple-recursive-solution",
                "content": "# Code\\n```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n === 0) return arr;\\n    let res = [];\\n    for(let i = 0; i < arr.length; i++){\\n        if(Array.isArray(arr[i])){\\n            const next = flat(arr[i], n - 1);\\n            res.push(...next);\\n        }\\n        else res.push(arr[i]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {any[]} arr\\n * @param {number} depth\\n * @return {any[]}\\n */\\nvar flat = function (arr, n) {\\n    if(n === 0) return arr;\\n    let res = [];\\n    for(let i = 0; i < arr.length; i++){\\n        if(Array.isArray(arr[i])){\\n            const next = flat(arr[i], n - 1);\\n            res.push(...next);\\n        }\\n        else res.push(arr[i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1905663,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "I find the part  `This flattening operation should only be done if the current depth of nesting is less than n` a bit confusing. I think depth should be `less than or equal to N`. Because it says `The depth of the elements in the first array are considered to be 0.`. I suppose the 'first array' is the input array, so:\n\nIn the first example we flatten elements 1,2,3 even though they are at a depth 0 == N (not < N)\nIn the second example we flatten elements 4,5,6 even though they are at a depth 1 == N  not < N)\n\nSo, if the base elements are considered to be at depth -1, then it should be `The depth of the elements in the first *nested* array are considered to be 0.` Or we change it so we consider base elements to be at depth = 0, and then we flatten elements if their depth <= N (like lodash flattenDepth)."
                    },
                    {
                        "username": "abhion",
                        "content": "Can someone please explain why this works in [codesandbox](https://codesandbox.io/s/happy-wilson-hkfj3g), but not when I submit. I see different results for the exact same code in leetcode and codesandbox. \nfor this input - `[[1,2],[3,[4,[5,[6]]],7],[8,9,10]]`\n\nIn codesandbox I get the correct output `[1, 2, 3, 4, 5, [6], 7, 8, 9, 10]` but in leet code the output is\n\n`[1,2,3,4,5,6,7,8,9,10]`\n\nWth is happening?"
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "i think because you have recursive solution"
                    },
                    {
                        "username": "kshyr",
                        "content": "love this one\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "My code gets accepted. but fails for this valid testCase: \\n[[[[[]]]]]\\n1000\\n\\neither the testCase should be invalid or it should be added to the set (I\\'ve also contributed the testcase)."
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "you can add test case you failing to pass by clicking \"Use Testcase\"\\ni think your solution has recursion so that\\'s why you cannot pass that case\\njust supposing, because my solution has recursion and also failing this one )))"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Also this testCase:\\n[424,653,123,[345,867],[[0]],[[]]]\\n1000"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#day22 : Done Solving Today\\'s Question \\uD83D\\uDE01"
                    },
                    {
                        "username": "ccmbike",
                        "content": "Next question: implement a function. Please solve it without javascript's built-in function.\n"
                    },
                    {
                        "username": "user6944TF",
                        "content": "Has origin method `flat([n])` already"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)"
                    }
                ]
            },
            {
                "id": 1962696,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "I find the part  `This flattening operation should only be done if the current depth of nesting is less than n` a bit confusing. I think depth should be `less than or equal to N`. Because it says `The depth of the elements in the first array are considered to be 0.`. I suppose the 'first array' is the input array, so:\n\nIn the first example we flatten elements 1,2,3 even though they are at a depth 0 == N (not < N)\nIn the second example we flatten elements 4,5,6 even though they are at a depth 1 == N  not < N)\n\nSo, if the base elements are considered to be at depth -1, then it should be `The depth of the elements in the first *nested* array are considered to be 0.` Or we change it so we consider base elements to be at depth = 0, and then we flatten elements if their depth <= N (like lodash flattenDepth)."
                    },
                    {
                        "username": "abhion",
                        "content": "Can someone please explain why this works in [codesandbox](https://codesandbox.io/s/happy-wilson-hkfj3g), but not when I submit. I see different results for the exact same code in leetcode and codesandbox. \nfor this input - `[[1,2],[3,[4,[5,[6]]],7],[8,9,10]]`\n\nIn codesandbox I get the correct output `[1, 2, 3, 4, 5, [6], 7, 8, 9, 10]` but in leet code the output is\n\n`[1,2,3,4,5,6,7,8,9,10]`\n\nWth is happening?"
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "i think because you have recursive solution"
                    },
                    {
                        "username": "kshyr",
                        "content": "love this one\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "My code gets accepted. but fails for this valid testCase: \\n[[[[[]]]]]\\n1000\\n\\neither the testCase should be invalid or it should be added to the set (I\\'ve also contributed the testcase)."
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "you can add test case you failing to pass by clicking \"Use Testcase\"\\ni think your solution has recursion so that\\'s why you cannot pass that case\\njust supposing, because my solution has recursion and also failing this one )))"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Also this testCase:\\n[424,653,123,[345,867],[[0]],[[]]]\\n1000"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#day22 : Done Solving Today\\'s Question \\uD83D\\uDE01"
                    },
                    {
                        "username": "ccmbike",
                        "content": "Next question: implement a function. Please solve it without javascript's built-in function.\n"
                    },
                    {
                        "username": "user6944TF",
                        "content": "Has origin method `flat([n])` already"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)"
                    }
                ]
            },
            {
                "id": 1927251,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "I find the part  `This flattening operation should only be done if the current depth of nesting is less than n` a bit confusing. I think depth should be `less than or equal to N`. Because it says `The depth of the elements in the first array are considered to be 0.`. I suppose the 'first array' is the input array, so:\n\nIn the first example we flatten elements 1,2,3 even though they are at a depth 0 == N (not < N)\nIn the second example we flatten elements 4,5,6 even though they are at a depth 1 == N  not < N)\n\nSo, if the base elements are considered to be at depth -1, then it should be `The depth of the elements in the first *nested* array are considered to be 0.` Or we change it so we consider base elements to be at depth = 0, and then we flatten elements if their depth <= N (like lodash flattenDepth)."
                    },
                    {
                        "username": "abhion",
                        "content": "Can someone please explain why this works in [codesandbox](https://codesandbox.io/s/happy-wilson-hkfj3g), but not when I submit. I see different results for the exact same code in leetcode and codesandbox. \nfor this input - `[[1,2],[3,[4,[5,[6]]],7],[8,9,10]]`\n\nIn codesandbox I get the correct output `[1, 2, 3, 4, 5, [6], 7, 8, 9, 10]` but in leet code the output is\n\n`[1,2,3,4,5,6,7,8,9,10]`\n\nWth is happening?"
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "i think because you have recursive solution"
                    },
                    {
                        "username": "kshyr",
                        "content": "love this one\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "My code gets accepted. but fails for this valid testCase: \\n[[[[[]]]]]\\n1000\\n\\neither the testCase should be invalid or it should be added to the set (I\\'ve also contributed the testcase)."
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "you can add test case you failing to pass by clicking \"Use Testcase\"\\ni think your solution has recursion so that\\'s why you cannot pass that case\\njust supposing, because my solution has recursion and also failing this one )))"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Also this testCase:\\n[424,653,123,[345,867],[[0]],[[]]]\\n1000"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#day22 : Done Solving Today\\'s Question \\uD83D\\uDE01"
                    },
                    {
                        "username": "ccmbike",
                        "content": "Next question: implement a function. Please solve it without javascript's built-in function.\n"
                    },
                    {
                        "username": "user6944TF",
                        "content": "Has origin method `flat([n])` already"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)"
                    }
                ]
            },
            {
                "id": 1910082,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "I find the part  `This flattening operation should only be done if the current depth of nesting is less than n` a bit confusing. I think depth should be `less than or equal to N`. Because it says `The depth of the elements in the first array are considered to be 0.`. I suppose the 'first array' is the input array, so:\n\nIn the first example we flatten elements 1,2,3 even though they are at a depth 0 == N (not < N)\nIn the second example we flatten elements 4,5,6 even though they are at a depth 1 == N  not < N)\n\nSo, if the base elements are considered to be at depth -1, then it should be `The depth of the elements in the first *nested* array are considered to be 0.` Or we change it so we consider base elements to be at depth = 0, and then we flatten elements if their depth <= N (like lodash flattenDepth)."
                    },
                    {
                        "username": "abhion",
                        "content": "Can someone please explain why this works in [codesandbox](https://codesandbox.io/s/happy-wilson-hkfj3g), but not when I submit. I see different results for the exact same code in leetcode and codesandbox. \nfor this input - `[[1,2],[3,[4,[5,[6]]],7],[8,9,10]]`\n\nIn codesandbox I get the correct output `[1, 2, 3, 4, 5, [6], 7, 8, 9, 10]` but in leet code the output is\n\n`[1,2,3,4,5,6,7,8,9,10]`\n\nWth is happening?"
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "i think because you have recursive solution"
                    },
                    {
                        "username": "kshyr",
                        "content": "love this one\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "My code gets accepted. but fails for this valid testCase: \\n[[[[[]]]]]\\n1000\\n\\neither the testCase should be invalid or it should be added to the set (I\\'ve also contributed the testcase)."
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "you can add test case you failing to pass by clicking \"Use Testcase\"\\ni think your solution has recursion so that\\'s why you cannot pass that case\\njust supposing, because my solution has recursion and also failing this one )))"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Also this testCase:\\n[424,653,123,[345,867],[[0]],[[]]]\\n1000"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#day22 : Done Solving Today\\'s Question \\uD83D\\uDE01"
                    },
                    {
                        "username": "ccmbike",
                        "content": "Next question: implement a function. Please solve it without javascript's built-in function.\n"
                    },
                    {
                        "username": "user6944TF",
                        "content": "Has origin method `flat([n])` already"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)"
                    }
                ]
            },
            {
                "id": 1905920,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "I find the part  `This flattening operation should only be done if the current depth of nesting is less than n` a bit confusing. I think depth should be `less than or equal to N`. Because it says `The depth of the elements in the first array are considered to be 0.`. I suppose the 'first array' is the input array, so:\n\nIn the first example we flatten elements 1,2,3 even though they are at a depth 0 == N (not < N)\nIn the second example we flatten elements 4,5,6 even though they are at a depth 1 == N  not < N)\n\nSo, if the base elements are considered to be at depth -1, then it should be `The depth of the elements in the first *nested* array are considered to be 0.` Or we change it so we consider base elements to be at depth = 0, and then we flatten elements if their depth <= N (like lodash flattenDepth)."
                    },
                    {
                        "username": "abhion",
                        "content": "Can someone please explain why this works in [codesandbox](https://codesandbox.io/s/happy-wilson-hkfj3g), but not when I submit. I see different results for the exact same code in leetcode and codesandbox. \nfor this input - `[[1,2],[3,[4,[5,[6]]],7],[8,9,10]]`\n\nIn codesandbox I get the correct output `[1, 2, 3, 4, 5, [6], 7, 8, 9, 10]` but in leet code the output is\n\n`[1,2,3,4,5,6,7,8,9,10]`\n\nWth is happening?"
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "i think because you have recursive solution"
                    },
                    {
                        "username": "kshyr",
                        "content": "love this one\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "My code gets accepted. but fails for this valid testCase: \\n[[[[[]]]]]\\n1000\\n\\neither the testCase should be invalid or it should be added to the set (I\\'ve also contributed the testcase)."
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "you can add test case you failing to pass by clicking \"Use Testcase\"\\ni think your solution has recursion so that\\'s why you cannot pass that case\\njust supposing, because my solution has recursion and also failing this one )))"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Also this testCase:\\n[424,653,123,[345,867],[[0]],[[]]]\\n1000"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#day22 : Done Solving Today\\'s Question \\uD83D\\uDE01"
                    },
                    {
                        "username": "ccmbike",
                        "content": "Next question: implement a function. Please solve it without javascript's built-in function.\n"
                    },
                    {
                        "username": "user6944TF",
                        "content": "Has origin method `flat([n])` already"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)"
                    }
                ]
            },
            {
                "id": 2074820,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "I find the part  `This flattening operation should only be done if the current depth of nesting is less than n` a bit confusing. I think depth should be `less than or equal to N`. Because it says `The depth of the elements in the first array are considered to be 0.`. I suppose the 'first array' is the input array, so:\n\nIn the first example we flatten elements 1,2,3 even though they are at a depth 0 == N (not < N)\nIn the second example we flatten elements 4,5,6 even though they are at a depth 1 == N  not < N)\n\nSo, if the base elements are considered to be at depth -1, then it should be `The depth of the elements in the first *nested* array are considered to be 0.` Or we change it so we consider base elements to be at depth = 0, and then we flatten elements if their depth <= N (like lodash flattenDepth)."
                    },
                    {
                        "username": "abhion",
                        "content": "Can someone please explain why this works in [codesandbox](https://codesandbox.io/s/happy-wilson-hkfj3g), but not when I submit. I see different results for the exact same code in leetcode and codesandbox. \nfor this input - `[[1,2],[3,[4,[5,[6]]],7],[8,9,10]]`\n\nIn codesandbox I get the correct output `[1, 2, 3, 4, 5, [6], 7, 8, 9, 10]` but in leet code the output is\n\n`[1,2,3,4,5,6,7,8,9,10]`\n\nWth is happening?"
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "i think because you have recursive solution"
                    },
                    {
                        "username": "kshyr",
                        "content": "love this one\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "My code gets accepted. but fails for this valid testCase: \\n[[[[[]]]]]\\n1000\\n\\neither the testCase should be invalid or it should be added to the set (I\\'ve also contributed the testcase)."
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "you can add test case you failing to pass by clicking \"Use Testcase\"\\ni think your solution has recursion so that\\'s why you cannot pass that case\\njust supposing, because my solution has recursion and also failing this one )))"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Also this testCase:\\n[424,653,123,[345,867],[[0]],[[]]]\\n1000"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#day22 : Done Solving Today\\'s Question \\uD83D\\uDE01"
                    },
                    {
                        "username": "ccmbike",
                        "content": "Next question: implement a function. Please solve it without javascript's built-in function.\n"
                    },
                    {
                        "username": "user6944TF",
                        "content": "Has origin method `flat([n])` already"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)"
                    }
                ]
            },
            {
                "id": 1906923,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "I find the part  `This flattening operation should only be done if the current depth of nesting is less than n` a bit confusing. I think depth should be `less than or equal to N`. Because it says `The depth of the elements in the first array are considered to be 0.`. I suppose the 'first array' is the input array, so:\n\nIn the first example we flatten elements 1,2,3 even though they are at a depth 0 == N (not < N)\nIn the second example we flatten elements 4,5,6 even though they are at a depth 1 == N  not < N)\n\nSo, if the base elements are considered to be at depth -1, then it should be `The depth of the elements in the first *nested* array are considered to be 0.` Or we change it so we consider base elements to be at depth = 0, and then we flatten elements if their depth <= N (like lodash flattenDepth)."
                    },
                    {
                        "username": "abhion",
                        "content": "Can someone please explain why this works in [codesandbox](https://codesandbox.io/s/happy-wilson-hkfj3g), but not when I submit. I see different results for the exact same code in leetcode and codesandbox. \nfor this input - `[[1,2],[3,[4,[5,[6]]],7],[8,9,10]]`\n\nIn codesandbox I get the correct output `[1, 2, 3, 4, 5, [6], 7, 8, 9, 10]` but in leet code the output is\n\n`[1,2,3,4,5,6,7,8,9,10]`\n\nWth is happening?"
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "i think because you have recursive solution"
                    },
                    {
                        "username": "kshyr",
                        "content": "love this one\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "My code gets accepted. but fails for this valid testCase: \\n[[[[[]]]]]\\n1000\\n\\neither the testCase should be invalid or it should be added to the set (I\\'ve also contributed the testcase)."
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "you can add test case you failing to pass by clicking \"Use Testcase\"\\ni think your solution has recursion so that\\'s why you cannot pass that case\\njust supposing, because my solution has recursion and also failing this one )))"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Also this testCase:\\n[424,653,123,[345,867],[[0]],[[]]]\\n1000"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#day22 : Done Solving Today\\'s Question \\uD83D\\uDE01"
                    },
                    {
                        "username": "ccmbike",
                        "content": "Next question: implement a function. Please solve it without javascript's built-in function.\n"
                    },
                    {
                        "username": "user6944TF",
                        "content": "Has origin method `flat([n])` already"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)"
                    }
                ]
            },
            {
                "id": 1861162,
                "content": [
                    {
                        "username": "rcomesan",
                        "content": "I find the part  `This flattening operation should only be done if the current depth of nesting is less than n` a bit confusing. I think depth should be `less than or equal to N`. Because it says `The depth of the elements in the first array are considered to be 0.`. I suppose the 'first array' is the input array, so:\n\nIn the first example we flatten elements 1,2,3 even though they are at a depth 0 == N (not < N)\nIn the second example we flatten elements 4,5,6 even though they are at a depth 1 == N  not < N)\n\nSo, if the base elements are considered to be at depth -1, then it should be `The depth of the elements in the first *nested* array are considered to be 0.` Or we change it so we consider base elements to be at depth = 0, and then we flatten elements if their depth <= N (like lodash flattenDepth)."
                    },
                    {
                        "username": "abhion",
                        "content": "Can someone please explain why this works in [codesandbox](https://codesandbox.io/s/happy-wilson-hkfj3g), but not when I submit. I see different results for the exact same code in leetcode and codesandbox. \nfor this input - `[[1,2],[3,[4,[5,[6]]],7],[8,9,10]]`\n\nIn codesandbox I get the correct output `[1, 2, 3, 4, 5, [6], 7, 8, 9, 10]` but in leet code the output is\n\n`[1,2,3,4,5,6,7,8,9,10]`\n\nWth is happening?"
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "i think because you have recursive solution"
                    },
                    {
                        "username": "kshyr",
                        "content": "love this one\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "My code gets accepted. but fails for this valid testCase: \\n[[[[[]]]]]\\n1000\\n\\neither the testCase should be invalid or it should be added to the set (I\\'ve also contributed the testcase)."
                    },
                    {
                        "username": "kas_elvirov",
                        "content": "you can add test case you failing to pass by clicking \"Use Testcase\"\\ni think your solution has recursion so that\\'s why you cannot pass that case\\njust supposing, because my solution has recursion and also failing this one )))"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Also this testCase:\\n[424,653,123,[345,867],[[0]],[[]]]\\n1000"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#day22 : Done Solving Today\\'s Question \\uD83D\\uDE01"
                    },
                    {
                        "username": "ccmbike",
                        "content": "Next question: implement a function. Please solve it without javascript's built-in function.\n"
                    },
                    {
                        "username": "user6944TF",
                        "content": "Has origin method `flat([n])` already"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem is very similar to [341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)"
                    }
                ]
            }
        ]
    }
]