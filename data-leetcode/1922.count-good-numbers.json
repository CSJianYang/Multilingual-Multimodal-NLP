[
    {
        "title": "Print in Order",
        "question_content": "Suppose we have a class:\n\npublic class Foo {\n  public void first() { print(\"first\"); }\n  public void second() { print(\"second\"); }\n  public void third() { print(\"third\"); }\n}\n\nThe same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().\nNote:\nWe do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests' comprehensiveness.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: \"firstsecondthird\"\nExplanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). \"firstsecondthird\" is the correct output.\n\nExample 2:\n\nInput: nums = [1,3,2]\nOutput: \"firstsecondthird\"\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output.\n\n&nbsp;\nConstraints:\n\n\tnums is a permutation of [1, 2, 3].",
        "solutions": [
            {
                "id": 335939,
                "title": "5-python-threading-solutions-barrier-lock-event-semaphore-condition-with-explanation",
                "content": "\\nRaise two barriers. Both wait for two threads to reach them.\\n\\nFirst thread can print before reaching the first barrier. Second thread can print before reaching the second barrier. Third thread can print after the second barrier.\\n\\n```\\nfrom threading import Barrier\\n\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n            \\n    def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n        \\n    def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n            \\n    def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n ```\\n \\nStart with two locked locks. First thread unlocks the first lock that the second thread is waiting on. Second thread unlocks the second lock that the third thread is waiting on.\\n\\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```        \\nSet events from first and second threads when they are done. Have the second thread wait for first one to set its event. Have the third thread wait on the second thread to raise its event.\\n\\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.done = (Event(),Event())\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.done[0].set()\\n        \\n    def second(self, printSecond):\\n        self.done[0].wait()\\n        printSecond()\\n        self.done[1].set()\\n            \\n    def third(self, printThird):\\n        self.done[1].wait()\\n        printThird()\\n\\n```        \\nStart with two closed gates represented by 0-value semaphores. Second and third thread are waiting behind these gates. When the first thread prints, it opens the gate for the second thread. When the second thread prints, it opens the gate for the third thread.\\n\\n```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n            \\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n\\n ```        \\n\\nHave all three threads attempt to acquire an RLock via Condition. The first thread can always acquire a lock, while the other two have to wait for the `order` to be set to the right value. First thread sets the order after printing which signals for the second thread to run. Second thread does the same for the third.\\n\\n```\\nfrom threading import Condition\\n\\nclass Foo:\\n    def __init__(self):\\n        self.exec_condition = Condition()\\n        self.order = 0\\n        self.first_finish = lambda: self.order == 1\\n        self.second_finish = lambda: self.order == 2\\n\\n    def first(self, printFirst):\\n        with self.exec_condition:\\n            printFirst()\\n            self.order = 1\\n            self.exec_condition.notify(2)\\n\\n    def second(self, printSecond):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.first_finish)\\n            printSecond()\\n            self.order = 2\\n            self.exec_condition.notify()\\n\\n    def third(self, printThird):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.second_finish)\\n            printThird()\\n```\\n            \\n",
                "solutionTags": [],
                "code": "```\\nfrom threading import Barrier\\n\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n            \\n    def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n        \\n    def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n            \\n    def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n ```\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.done = (Event(),Event())\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.done[0].set()\\n        \\n    def second(self, printSecond):\\n        self.done[0].wait()\\n        printSecond()\\n        self.done[1].set()\\n            \\n    def third(self, printThird):\\n        self.done[1].wait()\\n        printThird()\\n\\n```\n```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n            \\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n\\n ```\n```\\nfrom threading import Condition\\n\\nclass Foo:\\n    def __init__(self):\\n        self.exec_condition = Condition()\\n        self.order = 0\\n        self.first_finish = lambda: self.order == 1\\n        self.second_finish = lambda: self.order == 2\\n\\n    def first(self, printFirst):\\n        with self.exec_condition:\\n            printFirst()\\n            self.order = 1\\n            self.exec_condition.notify(2)\\n\\n    def second(self, printSecond):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.first_finish)\\n            printSecond()\\n            self.order = 2\\n            self.exec_condition.notify()\\n\\n    def third(self, printThird):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.second_finish)\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332890,
                "title": "java-basic-semaphore-solution-8ms-36mb",
                "content": "\"Semaphore is a bowl of marbles\" - Professor Stark\\n\\n1. Semaphore is a bowl of marbles (or locks in this case). If you need a marble, and there are none, you wait. You wait until there is one marble and then you take it. If you release(), you will add one marble to the bowl (from thin air). If you release(100), you will add 100 marbles to the bowl. **run2.release();** will add one **\"run2\"** marble to the **\"run2 bowl\"**.\\n2. The thread calling **third()** will wait until the end of **second()** when it releases a **\\'run3\\'** marble. The **second()** will wait until the end of **first() **when it releases a **\\'run2\\'** marble. Since **first()** never acquires anything, it will never wait. There is a forced wait ordering.\\n3. With semaphores, you can start out with 1 marble or 0 marbles or 100 marbles. A thread can take marbles (up until it\\'s empty) or put many marbles at a time.\\n\\nYou can solve this using other solutions (check bottom), but if you wake up a thread and make it spin in a loop and wait for some condition, it is a waste of CPU. You can make the thread go to sleep and wait for someone to notify it to wake up.\\n\\nUpvote and check out my other concurrency solutions.\\n```\\nimport java.util.concurrent.*;\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        run2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire(); \\n        printThird.run();\\n    }\\n}\\n```\\n\\n---\\n\\nSide note:\\n**ruzveld83** has pointed something out.\\n\"According to JMM there\\'s no guarantee that a thread will see values assigned during construction of an object in another thread. There is no guarantee that some thread can\\'t see version of Foo that is not fully constructed. It\\'s possible to see Foo.run2 or Foo.run3 as nulls. And thread-safety of Semaphore class does not make any difference. The final keyword should fix this. See https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5\"\\n\\nI could argue that *maybe* Foo is being synchronized to allow for proper value visibility. But we can\\'t see the entire program so... \\xAF\\\\\\\\_(\\u30C4)_/\\xAF\\n\\n---\\n\\nHere\\'s another solution that requires 1 semaphore. It is 19ms. There is some \"waking and waiting\" due to the loops, so that causes some CPU waste. I should also note that we need **tryAcquire(number)** because it will try to get \"all or nothing.\" So if you **tryAcquire(3)**, it will try to \"get all 3 if all present and return true\" or \"grab nothing and return false.\" If you use **acquire(3)**, if there isn\\'t enough, it will grab 1 or 2 and then wait for the remainder. You may expect it to \"get 3 or wait for 3\" but it doesn\\'t do this and you may be in for a surprise.\\n```\\nclass Foo {\\n\\n    Semaphore semaphore1;\\n    public Foo() {\\n        semaphore1 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(1));\\n        \\n        printSecond.run();\\n        semaphore1.release(2);\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(2));\\n        \\n        printThird.run();\\n    }\\n}\\n```\\n---\\nFor new learners, you can also solve this using:\\n- **volatile** keyword.\\n- locks\\n- conditions (they are like sub-locks)\\n- atomic variables\\n- java\\'s concurrent data structures\\n\\nUse what works and is simple.",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        run2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire(); \\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n\\n    Semaphore semaphore1;\\n    public Foo() {\\n        semaphore1 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(1));\\n        \\n        printSecond.run();\\n        semaphore1.release(2);\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(2));\\n        \\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343384,
                "title": "c-why-most-of-the-solutions-using-mutex-are-wrong-solution",
                "content": "I actually started learning about threads recently only and even my first attempt was to take 2 mutex and lock/unlock them in order desired by us. That solution is actually accepted in leetcode.\\n\\nHowever, while researching for difference between mutex and conditional_variable usage, i realised that the way mutex are being used here are totally wrong.\\n\\nSome points that must be taken note of are: \\n* **Mutex** are used for **mutual exclusion** i.e to safe gaurd the critical sections of a code.\\n* **Semaphone/condition_variable** are used for **thread synchronisation**(which is what we want to achieve here).\\n* **Mutex have ownership assigned with them**, that is to say, *the thread that locks a mutex must only unlock it.* Also, we must not unlock a mutex that has not been locked **(This is what most programs have got wrong)**.\\n* If the mutex is not used as said above, **the behavior is undefined**, which however in our case produces the required result.\\n\\nReferences:\\n1. [If the mutex is not currently locked by the calling thread, it causes undefined behavior.](http://www.cplusplus.com/reference/mutex/mutex/unlock/)\\n2. [The precondition for calling unlock is holding an ownership of the mutex, according to (std)30.4.1.2](https://stackoverflow.com/questions/43487357/how-stdmutex-got-unlocked-in-different-thread)\\n\\nI did read few more places the same thing, but i think these do put the point across :)\\n\\nNow my solution using a condition_variable:\\n\\n```\\nclass Foo {\\npublic:\\n    int count = 0;\\n    mutex mtx;\\n    condition_variable cv;\\n    Foo() {\\n        count = 1;\\n        //cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        unique_lock<mutex> lck(mtx);\\n\\t\\t// No point of this wait as on start count will be 1, we need to make the other threads wait.\\n        // while(count != 1){\\n        //     cv.wait(lck);\\n        // }\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n\\n        printFirst();\\n        count = 2;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 2){\\n            cv.wait(lck);\\n        }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count = 3;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 3){\\n            cv.wait(lck);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**Disclaimer**:  I am still learning :P. So, please do enlighten me if you think my understanding of this topic is wrong/misleading.\\nThanks for reading :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    int count = 0;\\n    mutex mtx;\\n    condition_variable cv;\\n    Foo() {\\n        count = 1;\\n        //cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        unique_lock<mutex> lck(mtx);\\n\\t\\t// No point of this wait as on start count will be 1, we need to make the other threads wait.\\n        // while(count != 1){\\n        //     cv.wait(lck);\\n        // }\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n\\n        printFirst();\\n        count = 2;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 2){\\n            cv.wait(lck);\\n        }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count = 3;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 3){\\n            cv.wait(lck);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893827,
                "title": "java-synchronized-lock-semaphore-condition-variable",
                "content": "Synchronized Method:\\n```\\nclass Foo {\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        oneDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while (!oneDone) {\\n            wait();\\n        }\\n        printSecond.run();\\n        twoDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while (!twoDone) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```\\n\\nSynchronized on Object:\\n```\\nclass Foo {\\n    private Object lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!oneDone) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!twoDone) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\\nSynchronized on Two Objects (not needed for this question, just put it here in case someone wants to use one object to protect one variable):\\n```\\nclass Foo {\\n    private Object lock1;\\n    private Object lock2;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock1 = new Object();\\n        lock2 = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock1) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock1.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock1) {\\n            synchronized (lock2) {\\n                while (!oneDone) {\\n                    lock1.wait();\\n                }\\n                printSecond.run();\\n                twoDone = true;\\n                lock2.notifyAll();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock2) {\\n            while (!twoDone) {\\n                lock2.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\\nSemaphore:\\n```\\nclass Foo {\\n    private Semaphore s2;\\n    private Semaphore s3;\\n    \\n    public Foo() {\\n        s2 = new Semaphore(0);\\n        s3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        printThird.run();\\n    }\\n}\\n```\\nCondition Variable:\\n```\\nclass Foo {\\n    private Lock lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    private Condition one;\\n    private Condition two;\\n    \\n    public Foo() {\\n        lock = new ReentrantLock();\\n        one = lock.newCondition();\\n        two = lock.newCondition();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            oneDone = true;\\n            one.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!oneDone) {\\n                one.await();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            two.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!twoDone) {\\n                two.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        oneDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while (!oneDone) {\\n            wait();\\n        }\\n        printSecond.run();\\n        twoDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while (!twoDone) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Object lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!oneDone) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!twoDone) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Object lock1;\\n    private Object lock2;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock1 = new Object();\\n        lock2 = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock1) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock1.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock1) {\\n            synchronized (lock2) {\\n                while (!oneDone) {\\n                    lock1.wait();\\n                }\\n                printSecond.run();\\n                twoDone = true;\\n                lock2.notifyAll();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock2) {\\n            while (!twoDone) {\\n                lock2.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Semaphore s2;\\n    private Semaphore s3;\\n    \\n    public Foo() {\\n        s2 = new Semaphore(0);\\n        s3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Lock lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    private Condition one;\\n    private Condition two;\\n    \\n    public Foo() {\\n        lock = new ReentrantLock();\\n        one = lock.newCondition();\\n        two = lock.newCondition();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            oneDone = true;\\n            one.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!oneDone) {\\n                one.await();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            two.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!twoDone) {\\n                two.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333513,
                "title": "c-using-std-promise",
                "content": "```C++\\nclass Foo {\\nprivate:\\n  std::promise<void> p1;\\n  std::promise<void> p2;\\n\\npublic:\\n  void first(function<void()> printFirst) {\\n    printFirst();\\n    p1.set_value();\\n  }\\n\\n  void second(function<void()> printSecond) {\\n    p1.get_future().wait();\\n    printSecond();\\n    p2.set_value();\\n  }\\n\\n  void third(function<void()> printThird) {\\n    p2.get_future().wait();\\n    printThird();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Foo {\\nprivate:\\n  std::promise<void> p1;\\n  std::promise<void> p2;\\n\\npublic:\\n  void first(function<void()> printFirst) {\\n    printFirst();\\n    p1.set_value();\\n  }\\n\\n  void second(function<void()> printSecond) {\\n    p1.get_future().wait();\\n    printSecond();\\n    p2.set_value();\\n  }\\n\\n  void third(function<void()> printThird) {\\n    p2.get_future().wait();\\n    printThird();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333562,
                "title": "python-3-semaphore",
                "content": "```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.two = Semaphore(0)\\n        self.three = Semaphore(0)\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.two.release()\\n\\n    def second(self, printSecond):\\n        with self.two:\\n            printSecond()\\n            self.three.release()\\n\\n    def third(self, printThird):\\n        with self.three:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.two = Semaphore(0)\\n        self.three = Semaphore(0)\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.two.release()\\n\\n    def second(self, printSecond):\\n        with self.two:\\n            printSecond()\\n            self.three.release()\\n\\n    def third(self, printThird):\\n        with self.three:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394392,
                "title": "python-3-56ms-lock-vs-event",
                "content": "The fastest solution for the problem is to use Lock mechanism. See the following code with comments:\\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# create lock to control sequence between first and second functions\\n        self.lock1 = threading.Lock()\\n\\t\\tself.lock1.acquire()\\n\\t\\t\\n\\t\\t# create another lock to control sequence between second and third functions\\n        self.lock2 = threading.Lock()\\n        self.lock2.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t\\n\\t\\t# since second function is waiting for the lock1, let\\'s release it\\n        self.lock1.release()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for first funtion to finish\\n        self.lock1.acquire()\\n        \\n\\t\\tprintSecond()\\n\\t\\t\\n\\t\\t# let\\'s release lock2, so third function can run\\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for second funtion to finish\\n        self.lock2.acquire()\\n\\t\\t\\n        printThird()\\n```\\nNow, when I was solving the problem the result was showing only 76 ms, which is far from the fastest. If you encounter similar issue take into account that you are working with threading and the timing is very unpredictable when CPU decides to switch threads. This can cause different timing results.\\n\\nAs an alternative you can use other synchronization mechanisms, such as Semaphore or Event. If you peek into CPython code you will see both Event and Semaphore are using Lock inside. That means that technically Lock solution is the fastest.\\n\\nBut for the reference here is solution with Event synchronization. In my opinion it looks little better:\\n\\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1 = threading.Event()\\n        self.event2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# create lock to control sequence between first and second functions\\n        self.lock1 = threading.Lock()\\n\\t\\tself.lock1.acquire()\\n\\t\\t\\n\\t\\t# create another lock to control sequence between second and third functions\\n        self.lock2 = threading.Lock()\\n        self.lock2.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t\\n\\t\\t# since second function is waiting for the lock1, let\\'s release it\\n        self.lock1.release()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for first funtion to finish\\n        self.lock1.acquire()\\n        \\n\\t\\tprintSecond()\\n\\t\\t\\n\\t\\t# let\\'s release lock2, so third function can run\\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for second funtion to finish\\n        self.lock2.acquire()\\n\\t\\t\\n        printThird()\\n```\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1 = threading.Event()\\n        self.event2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333446,
                "title": "java-solution-beats-100-in-both-time-and-space",
                "content": "```\\nclass Foo {\\n    \\n    private volatile boolean onePrinted;\\n    private volatile boolean twoPrinted;\\n\\n    public Foo() {\\n        onePrinted = false;\\n        twoPrinted = false;        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        onePrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(!onePrinted) {\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        twoPrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(!twoPrinted) {\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private volatile boolean onePrinted;\\n    private volatile boolean twoPrinted;\\n\\n    public Foo() {\\n        onePrinted = false;\\n        twoPrinted = false;        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        onePrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(!onePrinted) {\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        twoPrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(!twoPrinted) {\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342306,
                "title": "java-simple-countdownlatch-solution",
                "content": "CountDownLatch seems a good fit for this, from java doc \" A synchronization aid that allows one or more threads to wait until, a set of operations being performed in other threads completes. \"\\n\\n```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    \\n    private final CountDownLatch l2;\\n    private final CountDownLatch l3;\\n    \\n    public Foo() {\\n        l2 = new CountDownLatch(1);\\n        l3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        l2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        l2.await();\\n        printSecond.run();\\n        l3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        l3.await();\\n        printThird.run();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    \\n    private final CountDownLatch l2;\\n    private final CountDownLatch l3;\\n    \\n    public Foo() {\\n        l2 = new CountDownLatch(1);\\n        l3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        l2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        l2.await();\\n        printSecond.run();\\n        l3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        l3.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343487,
                "title": "python-simple-working-solution",
                "content": "```python\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        \\n        self.lock1.acquire()\\n        self.lock2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        \\n        self.lock1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lock1.acquire() # Wait unti first finishes\\n        \\n        printSecond()\\n        \\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lock2.acquire() # Wait unti second finishes\\n        \\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        \\n        self.lock1.acquire()\\n        self.lock2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        \\n        self.lock1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lock1.acquire() # Wait unti first finishes\\n        \\n        printSecond()\\n        \\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lock2.acquire() # Wait unti second finishes\\n        \\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332979,
                "title": "c-2-mutex",
                "content": "Idea is grab and release locks in order.\\n```\\nclass Foo {   \\n    mutex m1, m2;\\npublic:\\n    Foo() {\\n        m1.lock(), m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {   \\n    mutex m1, m2;\\npublic:\\n    Foo() {\\n        m1.lock(), m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856697,
                "title": "c-semaphore-based-solution",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly Semaphore first = new Semaphore(1, 1);\\n    private readonly Semaphore second = new Semaphore(0, 1);\\n    private readonly Semaphore third = new Semaphore(0, 1);\\n\\n    public void First(Action printFirst) {\\n        first.WaitOne();\\n        printFirst();\\n        second.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        second.WaitOne();\\n        printSecond();\\n        third.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        third.WaitOne();\\n        printThird();\\n        first.Release();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly Semaphore first = new Semaphore(1, 1);\\n    private readonly Semaphore second = new Semaphore(0, 1);\\n    private readonly Semaphore third = new Semaphore(0, 1);\\n\\n    public void First(Action printFirst) {\\n        first.WaitOne();\\n        printFirst();\\n        second.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        second.WaitOne();\\n        printSecond();\\n        third.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        third.WaitOne();\\n        printThird();\\n        first.Release();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333253,
                "title": "clean-and-easy-java-solution",
                "content": "```\\nimport java.util.concurrent.Semaphore;\\n\\nclass Foo {\\n\\n    final Semaphore hasFirstRun = new Semaphore(0);\\n    final Semaphore hasSecondRun = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        hasFirstRun.release(); // Allows second() to run, and wakes it if it\\'s sleeping.\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        /*\\n            hasFirstRun is initialized to 0. This means that if second() is executed\\n            before first(), it can\\'t get the lock and goes to sleep. In this case, it\\n            will be waked up by first().\\n            \\n            If second() is executed after first(), then it can acquire the semaphore immediately\\n            and execute its code.\\n        */\\n        hasFirstRun.acquire(); \\n        printSecond.run();\\n        hasSecondRun.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        hasSecondRun.acquire(); // same logic as second()\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.concurrent.Semaphore;\\n\\nclass Foo {\\n\\n    final Semaphore hasFirstRun = new Semaphore(0);\\n    final Semaphore hasSecondRun = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        hasFirstRun.release(); // Allows second() to run, and wakes it if it\\'s sleeping.\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        /*\\n            hasFirstRun is initialized to 0. This means that if second() is executed\\n            before first(), it can\\'t get the lock and goes to sleep. In this case, it\\n            will be waked up by first().\\n            \\n            If second() is executed after first(), then it can acquire the semaphore immediately\\n            and execute its code.\\n        */\\n        hasFirstRun.acquire(); \\n        printSecond.run();\\n        hasSecondRun.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        hasSecondRun.acquire(); // same logic as second()\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846704,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-without-using-mutex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\n    promise<void> p1,p2;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        p1.get_future().wait();\\n        printSecond();\\n        p2.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        p2.get_future().wait();\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    promise<void> p1,p2;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        p1.get_future().wait();\\n        printSecond();\\n        p2.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        p2.get_future().wait();\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340233,
                "title": "java-two-methods-cas-ans-synchronized",
                "content": "**1. CAS**\\n```\\nimport java.util.concurrent.atomic.AtomicInteger;\\n\\nclass Foo {\\n\\n\\tAtomicInteger count = new AtomicInteger();\\n\\n\\tpublic Foo() {\\n\\t\\tcount.set(0);\\n\\t}\\n\\n\\tpublic void first(Runnable printFirst) throws InterruptedException {\\n\\n\\t\\twhile (!count.compareAndSet(0, 4)) {\\n\\t\\t\\t// printFirst.run() outputs \"first\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintFirst.run();\\n\\t\\tcount.set(1);\\n\\t}\\n\\n\\tpublic void second(Runnable printSecond) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(1, 4)) {\\n\\t\\t\\t// printSecond.run() outputs \"second\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintSecond.run();\\n\\t\\tcount.set(2);\\n\\n\\t}\\n\\n\\tpublic void third(Runnable printThird) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(2, 4)) {\\n\\t\\t\\t// printThird.run() outputs \"third\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintThird.run();\\n\\t\\tcount.set(3);\\n\\t}\\n}\\n```\\n\\n\\n**2. Synchronized**\\n```\\nimport java.util.concurrent.locks.*;\\n\\nclass Foo {\\n\\n    int count = 0;\\n    \\n    public Foo() {\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        \\n        printFirst.run();\\n        count++;\\n        this.notifyAll();\\n\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(count != 1){\\n           this.wait();\\n        }\\n        printSecond.run();\\n        count++;\\n        this.notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n\\n        while(count != 2){\\n          this.wait();\\n        }\\n        printThird.run();\\n        count++;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.atomic.AtomicInteger;\\n\\nclass Foo {\\n\\n\\tAtomicInteger count = new AtomicInteger();\\n\\n\\tpublic Foo() {\\n\\t\\tcount.set(0);\\n\\t}\\n\\n\\tpublic void first(Runnable printFirst) throws InterruptedException {\\n\\n\\t\\twhile (!count.compareAndSet(0, 4)) {\\n\\t\\t\\t// printFirst.run() outputs \"first\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintFirst.run();\\n\\t\\tcount.set(1);\\n\\t}\\n\\n\\tpublic void second(Runnable printSecond) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(1, 4)) {\\n\\t\\t\\t// printSecond.run() outputs \"second\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintSecond.run();\\n\\t\\tcount.set(2);\\n\\n\\t}\\n\\n\\tpublic void third(Runnable printThird) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(2, 4)) {\\n\\t\\t\\t// printThird.run() outputs \"third\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintThird.run();\\n\\t\\tcount.set(3);\\n\\t}\\n}\\n```\n```\\nimport java.util.concurrent.locks.*;\\n\\nclass Foo {\\n\\n    int count = 0;\\n    \\n    public Foo() {\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        \\n        printFirst.run();\\n        count++;\\n        this.notifyAll();\\n\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(count != 1){\\n           this.wait();\\n        }\\n        printSecond.run();\\n        count++;\\n        this.notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n\\n        while(count != 2){\\n          this.wait();\\n        }\\n        printThird.run();\\n        count++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786578,
                "title": "c-minimal-code",
                "content": "```\\ntypedef struct {\\n    // User defined data is declared here.\\n    // using \\'volatile\\' to prevent compiler from playing god and optimize out this critical variable\\n    // this is mutex variable, duh \\n    volatile int turn;\\n} Foo;\\n\\nvoid wait(Foo* obj, int my_turn) {\\n    // blocking this thread till my turn\\n    while(obj->turn != my_turn) pthread_yield(NULL); // Nope Gotta wait \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n    \\n    // Aha!! free at last guess I will return now\\n}\\n\\nvoid signal(Foo* obj) {\\n    ++obj->turn; // pass it to next in line (psst: for the future generations)\\n}\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    obj->turn = 1; // first will be executed first, lol \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid second(Foo* obj) {\\n    wait(obj, 2); // Ok I will wait till my (2) turn (\\u2565\\uFE4F\\u2565)\\n    printSecond();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid third(Foo* obj) {\\n    wait(obj, 3); // Ok I will wait till my (3) turn (\\u2565\\uFE4F\\u2565)\\n    printThird(); \\n    // Oh! no one else left to signal, I guess this ends with me now, *sigh* \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // I am a resposible citizen I clean up after me \\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    // User defined data is declared here.\\n    // using \\'volatile\\' to prevent compiler from playing god and optimize out this critical variable\\n    // this is mutex variable, duh \\n    volatile int turn;\\n} Foo;\\n\\nvoid wait(Foo* obj, int my_turn) {\\n    // blocking this thread till my turn\\n    while(obj->turn != my_turn) pthread_yield(NULL); // Nope Gotta wait \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n    \\n    // Aha!! free at last guess I will return now\\n}\\n\\nvoid signal(Foo* obj) {\\n    ++obj->turn; // pass it to next in line (psst: for the future generations)\\n}\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    obj->turn = 1; // first will be executed first, lol \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid second(Foo* obj) {\\n    wait(obj, 2); // Ok I will wait till my (2) turn (\\u2565\\uFE4F\\u2565)\\n    printSecond();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid third(Foo* obj) {\\n    wait(obj, 3); // Ok I will wait till my (3) turn (\\u2565\\uFE4F\\u2565)\\n    printThird(); \\n    // Oh! no one else left to signal, I guess this ends with me now, *sigh* \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // I am a resposible citizen I clean up after me \\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1028030,
                "title": "4-python-solutions",
                "content": "**Solution 1:**\\n```\\nfrom threading import Event\\nclass Foo:\\ndef __init__(self):\\n\\tself.done = (Event(),Event())\\n\\ndef first(self, printFirst):\\n\\tprintFirst()\\n\\tself.done[0].set()\\n\\ndef second(self, printSecond):\\n\\tself.done[0].wait()\\n\\tprintSecond()\\n\\tself.done[1].set()\\n\\ndef third(self, printThird):\\n\\tself.done[1].wait()\\n\\tprintThird()\\n```\\n\\n**Solution 2:**\\n```\\nfrom threading import Barrier\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n     def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n     def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n     def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n```\\n\\n**Solution 3:**\\n```\\nfrom threading import Lock\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n     def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n     def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\\n\\n**Solution 4:**\\n```\\nfrom threading import Semaphore\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Event\\nclass Foo:\\ndef __init__(self):\\n\\tself.done = (Event(),Event())\\n\\ndef first(self, printFirst):\\n\\tprintFirst()\\n\\tself.done[0].set()\\n\\ndef second(self, printSecond):\\n\\tself.done[0].wait()\\n\\tprintSecond()\\n\\tself.done[1].set()\\n\\ndef third(self, printThird):\\n\\tself.done[1].wait()\\n\\tprintThird()\\n```\n```\\nfrom threading import Barrier\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n     def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n     def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n     def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n```\n```\\nfrom threading import Lock\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n     def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n     def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\n```\\nfrom threading import Semaphore\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926614,
                "title": "python3-solution-using-5-primitives-lock-semaphore-condition-event-barrier",
                "content": "# Approach \\\\#1. Lock\\n- `RLock` is not suitable in this case. \\n\\n<iframe src=\"https://leetcode.com/playground/mgRcT2DB/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#2. Semaphore\\n- `Semaphore(1)` is equivalent to `Lock()`\\n<iframe src=\"https://leetcode.com/playground/c4bkiTBr/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#3. Condition\\n<iframe src=\"https://leetcode.com/playground/Z2up2An3/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>\\n\\n# Approach \\\\#4. Event \\n<iframe src=\"https://leetcode.com/playground/hTnE2h6z/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#5. Barrier\\n<iframe src=\"https://leetcode.com/playground/RxQpksKT/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n",
                "solutionTags": [
                    "Python3",
                    "Concurrency"
                ],
                "code": "# Approach \\\\#1. Lock\\n- `RLock` is not suitable in this case. \\n\\n<iframe src=\"https://leetcode.com/playground/mgRcT2DB/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#2. Semaphore\\n- `Semaphore(1)` is equivalent to `Lock()`\\n<iframe src=\"https://leetcode.com/playground/c4bkiTBr/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#3. Condition\\n<iframe src=\"https://leetcode.com/playground/Z2up2An3/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>\\n\\n# Approach \\\\#4. Event \\n<iframe src=\"https://leetcode.com/playground/hTnE2h6z/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#5. Barrier\\n<iframe src=\"https://leetcode.com/playground/RxQpksKT/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 339055,
                "title": "c-three-versions-condition-variables-semaphores-simple-bools-fastest-124ms",
                "content": "Version 1: One mutex lock + two condition variables\\n* 124 ms\\n* faster than 89.41%\\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_cond_t cv1 = PTHREAD_COND_INITIALIZER;\\n    pthread_cond_t cv2 = PTHREAD_COND_INITIALIZER;\\n\\t\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        pthread_mutex_lock(&m);\\n        firstRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) { \\n            pthread_cond_wait(&cv1, &m);\\n        }\\n\\t\\t\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        secondRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) {\\n             pthread_cond_wait(&cv1, &m);\\n        }\\n        while (!secondRan) {\\n             pthread_cond_wait(&cv2, &m);\\n        }\\n\\t\\t\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        pthread_mutex_unlock(&m);\\n    }\\n};\\n```\\n\\nVersion 2: Two semaphores\\n* 132 ms\\n* Faster than 82.37%\\n```\\n#include <semaphore.h>\\n\\nclass Foo {\\npublic:\\n    sem_t s1;\\n    sem_t s2;\\n    Foo() {\\n        sem_init(&s1, 0, 0);\\n        sem_init(&s2, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&s1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&s1);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&s2);\\n        \\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&s2);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\nVersion 3: Simple bools\\n* 1400 ms\\n* Faster than 8.13%\\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        firstRan = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!firstRan) { }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondRan = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (!(firstRan && secondRan))  { }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\nLet me know if anyone finds better ways to do what I did!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_cond_t cv1 = PTHREAD_COND_INITIALIZER;\\n    pthread_cond_t cv2 = PTHREAD_COND_INITIALIZER;\\n\\t\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        pthread_mutex_lock(&m);\\n        firstRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) { \\n            pthread_cond_wait(&cv1, &m);\\n        }\\n\\t\\t\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        secondRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) {\\n             pthread_cond_wait(&cv1, &m);\\n        }\\n        while (!secondRan) {\\n             pthread_cond_wait(&cv2, &m);\\n        }\\n\\t\\t\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        pthread_mutex_unlock(&m);\\n    }\\n};\\n```\n```\\n#include <semaphore.h>\\n\\nclass Foo {\\npublic:\\n    sem_t s1;\\n    sem_t s2;\\n    Foo() {\\n        sem_init(&s1, 0, 0);\\n        sem_init(&s2, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&s1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&s1);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&s2);\\n        \\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&s2);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        firstRan = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!firstRan) { }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondRan = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (!(firstRan && secondRan))  { }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 620623,
                "title": "c-using-autoreset",
                "content": "```csharp\\nusing System.Threading;    \\n\\npublic class Foo \\n{\\n    private EventWaitHandle waitFirst;\\n    private EventWaitHandle waitSecond;\\n\\n    public Foo() \\n    {\\n        waitFirst = new AutoResetEvent(initialState: false);\\n        waitSecond = new AutoResetEvent(initialState: false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {   \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        waitFirst.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        waitFirst.WaitOne();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        waitSecond.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        waitSecond.WaitOne();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\nusing System.Threading;    \\n\\npublic class Foo \\n{\\n    private EventWaitHandle waitFirst;\\n    private EventWaitHandle waitSecond;\\n\\n    public Foo() \\n    {\\n        waitFirst = new AutoResetEvent(initialState: false);\\n        waitSecond = new AutoResetEvent(initialState: false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {   \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        waitFirst.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        waitFirst.WaitOne();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        waitSecond.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        waitSecond.WaitOne();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062271,
                "title": "3-c-solutions-promises-condition-variables-atomic-bools",
                "content": "If you liked it please upvote!\\n\\n**C++ promise/future:**\\n1 of the 2 fastest (second one is the condition_variable)\\n```\\nclass Foo {\\nprivate:\\n    std::promise<void> prom_first;\\n    std::promise<void> prom_second;\\n    std::future<void> fut_first;\\n    std::future<void> fut_second;\\npublic:\\n    Foo() {\\n        fut_first = prom_first.get_future();\\n        fut_second = prom_second.get_future();\\n    }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        prom_first.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        fut_first.wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        prom_second.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        fut_second.wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**C++ condition variable**\\n1 of the 2 fastest (second one is the promises/futures)\\n```\\nclass Foo {\\nprivate:\\n    std::mutex mutex1, mutex2, mutex3;\\n    std::condition_variable cv2, cv3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        {\\n            std::lock_guard lock(mutex1);\\n            second_unlocked = true;\\n        }\\n        cv2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock lock(mutex2);\\n        cv2.wait(lock, [this] { return second_unlocked; });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n        lock.unlock();\\n        cv3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock lock(mutex3);\\n        cv3.wait(lock, [this] { return third_unlocked; });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**C++ atomic bools**\\nSimplest but obviously the slowest solution\\n```\\nclass Foo {\\nprivate:\\n    std::atomic<bool> second_unlocked = false, third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        second_unlocked = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!second_unlocked)\\n            ;\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        while(!third_unlocked)\\n            ;\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\nprivate:\\n    std::promise<void> prom_first;\\n    std::promise<void> prom_second;\\n    std::future<void> fut_first;\\n    std::future<void> fut_second;\\npublic:\\n    Foo() {\\n        fut_first = prom_first.get_future();\\n        fut_second = prom_second.get_future();\\n    }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        prom_first.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        fut_first.wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        prom_second.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        fut_second.wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\nprivate:\\n    std::mutex mutex1, mutex2, mutex3;\\n    std::condition_variable cv2, cv3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        {\\n            std::lock_guard lock(mutex1);\\n            second_unlocked = true;\\n        }\\n        cv2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock lock(mutex2);\\n        cv2.wait(lock, [this] { return second_unlocked; });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n        lock.unlock();\\n        cv3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock lock(mutex3);\\n        cv3.wait(lock, [this] { return third_unlocked; });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\nprivate:\\n    std::atomic<bool> second_unlocked = false, third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        second_unlocked = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!second_unlocked)\\n            ;\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        while(!third_unlocked)\\n            ;\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425597,
                "title": "c-the-most-correct-solution",
                "content": "``` csharp\\nusing System.Threading.Tasks;\\n\\npublic class Foo\\n{\\n    private TaskCompletionSource<bool> semaphore1 = new TaskCompletionSource<bool>();\\n    private TaskCompletionSource<bool> semaphore2 = new TaskCompletionSource<bool>();\\n\\n    public Foo()\\n    {\\n\\n    }\\n\\n    public void First(Action printFirst)\\n    {\\n        printFirst();\\n        semaphore1.SetResult(true);\\n    }\\n\\n    public void Second(Action printSecond)\\n    {\\n        semaphore1.Task.Wait();\\n        printSecond();\\n        semaphore2.SetResult(true);\\n    }\\n\\n    public void Third(Action printThird)\\n    {\\n        semaphore2.Task.Wait();\\n        printThird();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "``` csharp\\nusing System.Threading.Tasks;\\n\\npublic class Foo\\n{\\n    private TaskCompletionSource<bool> semaphore1 = new TaskCompletionSource<bool>();\\n    private TaskCompletionSource<bool> semaphore2 = new TaskCompletionSource<bool>();\\n\\n    public Foo()\\n    {\\n\\n    }\\n\\n    public void First(Action printFirst)\\n    {\\n        printFirst();\\n        semaphore1.SetResult(true);\\n    }\\n\\n    public void Second(Action printSecond)\\n    {\\n        semaphore1.Task.Wait();\\n        printSecond();\\n        semaphore2.SetResult(true);\\n    }\\n\\n    public void Third(Action printThird)\\n    {\\n        semaphore2.Task.Wait();\\n        printThird();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878544,
                "title": "python-simple-and-elegant-event-based",
                "content": "**Solution**:\\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1, self.event2 = Event(), Event()\\n\\n    def first(self, f):\\n        f()\\n        self.event1.set()\\n\\n    def second(self, f):\\n        self.event1.wait()\\n        f()\\n        self.event2.set()\\n\\n    def third(self, f):\\n        self.event2.wait()\\n        f()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1, self.event2 = Event(), Event()\\n\\n    def first(self, f):\\n        f()\\n        self.event1.set()\\n\\n    def second(self, f):\\n        self.event1.wait()\\n        f()\\n        self.event2.set()\\n\\n    def third(self, f):\\n        self.event2.wait()\\n        f()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212596,
                "title": "java-with-two-semaphores",
                "content": "```\\nclass Foo {\\n\\n    private Semaphore second;\\n    private Semaphore third;\\n\\n    public Foo() {\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private Semaphore second;\\n    private Semaphore third;\\n\\n    public Foo() {\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760743,
                "title": "java-4-different-solutions-w-explanation",
                "content": "## 0. Analysis\\nHere we have 3 threads and all we want to achieve is to make sure the 3 threads run in a specific order. To achieve this, we need coordination among the threads, which means accessing and managing some common objects/resources. I think the most important point to achieve is about **visibility**: the other threads should be able to know the state change of some commonly accessed objects/values used for the coordination.\\n\\nTo achieve this, we can either use some ready-to-use utility classes in `java.util.concurrent` package, or managing the visibility and status with some Java language features. \\n\\nBelow are a few possible solutions:\\n\\n## 1.  The volatile keyword\\nIn summary, the Java `volatile` keyword **guarantees visibility of changes** to variables across threads (from [this article](http://tutorials.jenkov.com/java-concurrency/volatile.html)), and that\\'s literally all we need here so that when` first()` and `second()` increment the `flag` value, the next methods (in other threads) are able to capture the updated value so that the execution condition can be met (i.e., the `while` loop will exit).\\n\\nSo we have the solution like below:\\n```\\nclass Foo {\\n    private static volatile int flag;\\n    \\n    public Foo() {\\n        flag = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag++; // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag != 2){} // wait until the flag turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag++; // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag != 3){} // wait until the flag turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 2. AtomicInteger\\nThe `AtomicXXX` classes are located in `java.util.concurrent` package. The main feature for those classes is that they ensure ***atomic actions*** on the instances, which in simple terms means that only a single thread will be able to access the object at a time, and the updated value will be visible to other threads. It\\'s achieved using CAS (compare and swap) strategy.\\n\\nSo the solution is like below:\\n```\\nclass Foo {\\n    private static AtomicInteger flag;\\n    \\n    public Foo() {\\n        flag = new AtomicInteger(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag.incrementAndGet(); // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag.get() != 2){} // wait until the flag value turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag.incrementAndGet();  // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag.get() != 3){} // wait until the flag value turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 3. Semaphore\\nA `Semaphore` manages a set of  virtual  permits; the  initial number of permits  is passed to the Semaphore constructor. Activities can `acquire` permits (as long as some remain) and `release` permits when they are done with them. If no permit is available, acquire blocks until one is (or until interrupted or the operation times out). The `release` method returns a permit to the semaphore. (from the book [Java Concurrency in Practice](https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601))\\n\\nSo we use 2 Semaphore objects, one to control when the` second()` method can proceed, the other to control when the `third()` method can proceed. Solution is like below:\\n\\n```\\nclass Foo {\\n    private static Semaphore sem2;\\n    private static Semaphore sem3;\\n    \\n    public Foo() {\\n        sem2 = new Semaphore(0);\\n        sem3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        sem2.release(); // release a sem2 permit so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        sem2.acquire();  // will block until any Semaphore permit is available\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        sem3.release(); // release a sem3 permit so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       sem3.acquire(); // will block until any Semaphore permit is available\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 4. CountDownLatch\\n`CountDownLatch` is another type of synchronizer. It can delay the progress of threads until it reaches its terminal state, i.e., when it counts down to 0. \\n\\nMuch like solution 3 with `Semaphore`, we use 2 `CountDownLatch` instances. One to control when the` second()` method can proceed, the other to control when the `third()` method can proceed. Solution is like below:\\n\\n```\\nclass Foo {\\n    private static CountDownLatch latch2;\\n    private static CountDownLatch latch3;\\n    \\n    public Foo() {\\n        latch2 = new CountDownLatch(1);\\n        latch3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown(); // count down latch2 to 0 so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await(); // wait until latch2 counts down to 0\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown(); // count down latche to 0 so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       latch3.await(); // wait until latch3 counts down to 0\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private static volatile int flag;\\n    \\n    public Foo() {\\n        flag = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag++; // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag != 2){} // wait until the flag turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag++; // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag != 3){} // wait until the flag turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static AtomicInteger flag;\\n    \\n    public Foo() {\\n        flag = new AtomicInteger(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag.incrementAndGet(); // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag.get() != 2){} // wait until the flag value turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag.incrementAndGet();  // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag.get() != 3){} // wait until the flag value turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static Semaphore sem2;\\n    private static Semaphore sem3;\\n    \\n    public Foo() {\\n        sem2 = new Semaphore(0);\\n        sem3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        sem2.release(); // release a sem2 permit so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        sem2.acquire();  // will block until any Semaphore permit is available\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        sem3.release(); // release a sem3 permit so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       sem3.acquire(); // will block until any Semaphore permit is available\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static CountDownLatch latch2;\\n    private static CountDownLatch latch3;\\n    \\n    public Foo() {\\n        latch2 = new CountDownLatch(1);\\n        latch3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown(); // count down latch2 to 0 so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await(); // wait until latch2 counts down to 0\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown(); // count down latche to 0 so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       latch3.await(); // wait until latch3 counts down to 0\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520552,
                "title": "c-future-promise",
                "content": "Using C++ 11 feature and locking the object automatically with future-promise idiom. \\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n    std::promise<void> one, two;\\n    \\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        one.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        one.get_future().get();\\n        printSecond();\\n        two.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        two.get_future().get();\\n        printThird();\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n    std::promise<void> one, two;\\n    \\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        one.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        one.get_future().get();\\n        printSecond();\\n        two.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        two.get_future().get();\\n        printThird();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430388,
                "title": "c-condition-variable-96-also-explaining-how-condition-variable-works",
                "content": "How `condition_variable` works:\\n1. First, you need to acquire a `mutex` using `unique_lock`. We need a unique_lock because before putting the thread to sleep, condition_variable will need to release the mutex and unique_lock provides that flexibility.\\n2. Next, you call the `wait` function of condition_variable with the above lock and optionally a `predicate`. It causes the current thread to block (sleep). The thread is unblocked when `notify_all` or `notify_one` is executed on some other thread. \\n4. It might also be unblocked *spuriously* that\\'s where the predicate comes handy. So, whenever there are spurious wake-ups, condition_variable will acquire the mutex and check the predicate. **If** the predicate returns true, thread will proceed further and mutex will stay acquired, **otherwise** it will release the mutex and sleep again.\\n5. When the thread has completed its work, it\\'s *generally* a better idea to release the lock before notifying other threads, if need be.\\n\\n```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst) {\\n        // first doesn\\'t have to wait for anyone and it doesn\\'t acquire any lock either\\n        printFirst();  \\n        // firstPrinted is atomic because second might be trying to read while this thread is modifying it.\\n        firstPrinted = true;\\n        // notify waiting threads\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // acquire lock, C++17 way\\n        unique_lock guard(m);\\n        // condition to wait for is => first should have printed.\\n        cv.wait(guard, [this] { return this->firstPrinted == true; });\\n        // now print\\n        printSecond();\\n        // secondPrinted need not be atomic, because its access is already protected by mutex in both second and third. \\n        secondPrinted = true;\\n        // release mutex before notifying\\n        guard.unlock();\\n        // notify\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // acquire lock\\n        unique_lock guard(m);\\n        // condition to wait for is => second should have printed. \\n        cv.wait(guard, [this] { return secondPrinted == true; });\\n        // now print\\n        printThird();\\n    }\\n    \\nprivate:\\n    condition_variable cv;\\n    mutex m;\\n    atomic_bool firstPrinted = false;\\n    bool secondPrinted = false;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst) {\\n        // first doesn\\'t have to wait for anyone and it doesn\\'t acquire any lock either\\n        printFirst();  \\n        // firstPrinted is atomic because second might be trying to read while this thread is modifying it.\\n        firstPrinted = true;\\n        // notify waiting threads\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // acquire lock, C++17 way\\n        unique_lock guard(m);\\n        // condition to wait for is => first should have printed.\\n        cv.wait(guard, [this] { return this->firstPrinted == true; });\\n        // now print\\n        printSecond();\\n        // secondPrinted need not be atomic, because its access is already protected by mutex in both second and third. \\n        secondPrinted = true;\\n        // release mutex before notifying\\n        guard.unlock();\\n        // notify\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // acquire lock\\n        unique_lock guard(m);\\n        // condition to wait for is => second should have printed. \\n        cv.wait(guard, [this] { return secondPrinted == true; });\\n        // now print\\n        printThird();\\n    }\\n    \\nprivate:\\n    condition_variable cv;\\n    mutex m;\\n    atomic_bool firstPrinted = false;\\n    bool secondPrinted = false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333018,
                "title": "naive-solution-without-using-built-in-libraries",
                "content": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.called = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        while self.called != 0:\\n            continue\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.called = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.called != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.called = 2\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.called != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```\\n\\nNot sure if it meets the goal of this problem, but it passed..",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.called = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        while self.called != 0:\\n            continue\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.called = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.called != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.called = 2\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.called != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961766,
                "title": "java-94-runtime-efficiency-using-synchronized-wait-and-notify-explained",
                "content": "Although I consider myself proficient in Java, this was a great refresher on synchronized, wait, and notify.  I did some research.  Based on Sonar, any wait() call should check a condition in a while loop, so I have two booleans to indicate if the first and second have been printed.  I declared two objects, firstObject and secondObject to use for synchronization.  Method first synchronizes on firstObject and can then run printFirst(), and does a notify on firstObject to signal completion of the first method.  Method second is synchronized on firstObject, has a while loop on !first, and waits for the notify on firstObject.  When the while loop is exited, it synchronizes on secondObject, prints second, sets second to true, and does a notify on secondObject to signal completion of the second method.  Method third does the same things, synchronizing on secondObject, looping while !second, and waits for the notify on secondObject.  When the loop is exited, printThird can be run. \\n\\nIf you like this post, please upvote!\\n```\\nclass Foo {\\n\\n    public Foo() {\\n        first = false;\\n        second = false;\\n    }\\n\\n    Object firstObject = new Object();\\n    Object secondObject = new Object();\\n    \\n    boolean first = false;\\n    boolean second = false;\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(firstObject) {\\n\\t\\t    // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            first = true;\\n            firstObject.notify();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(firstObject) {\\n            while (!first) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    firstObject.wait();\\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n            synchronized(secondObject) {\\n                // printSecond.run() outputs \"second\". Do not change or remove this line.\\n                printSecond.run();\\n                second = true;\\n                secondObject.notify();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(secondObject) {\\n            while (!second) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    secondObject.wait();  \\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line\\n        printThird.run();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Although I consider myself proficient in Java, this was a great refresher on synchronized, wait, and notify.  I did some research.  Based on Sonar, any wait() call should check a condition in a while loop, so I have two booleans to indicate if the first and second have been printed.  I declared two objects, firstObject and secondObject to use for synchronization.  Method first synchronizes on firstObject and can then run printFirst(), and does a notify on firstObject to signal completion of the first method.  Method second is synchronized on firstObject, has a while loop on !first, and waits for the notify on firstObject.  When the while loop is exited, it synchronizes on secondObject, prints second, sets second to true, and does a notify on secondObject to signal completion of the second method.  Method third does the same things, synchronizing on secondObject, looping while !second, and waits for the notify on secondObject.  When the loop is exited, printThird can be run. \\n\\nIf you like this post, please upvote!\\n```\\nclass Foo {\\n\\n    public Foo() {\\n        first = false;\\n        second = false;\\n    }\\n\\n    Object firstObject = new Object();\\n    Object secondObject = new Object();\\n    \\n    boolean first = false;\\n    boolean second = false;\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(firstObject) {\\n\\t\\t    // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            first = true;\\n            firstObject.notify();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(firstObject) {\\n            while (!first) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    firstObject.wait();\\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n            synchronized(secondObject) {\\n                // printSecond.run() outputs \"second\". Do not change or remove this line.\\n                printSecond.run();\\n                second = true;\\n                secondObject.notify();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(secondObject) {\\n            while (!second) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    secondObject.wait();  \\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line\\n        printThird.run();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 762759,
                "title": "boring-c-mutex-solution",
                "content": "```\\nclass Foo {\\n    mutex m1;\\n    mutex m2;\\npublic:\\n    Foo() {\\n        m1.lock();\\n        m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    mutex m1;\\n    mutex m2;\\npublic:\\n    Foo() {\\n        m1.lock();\\n        m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516472,
                "title": "semaphore",
                "content": "```\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        run2.release();\\n\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        run2.release();\\n\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440979,
                "title": "python3-solution-via-threading-event-36-ms-13-mb",
                "content": "```\\nfrom threading import Event\\n\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# Initialize events for threads\\n        self.event1 = Event()\\n        self.event2 = Event()\\n        \\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t# set flag\\n        self.event1.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event1.wait()\\n        printSecond()\\n\\t\\t# set flag\\n        self.event2.set()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event2.wait()\\n        printThird()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom threading import Event\\n\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# Initialize events for threads\\n        self.event1 = Event()\\n        self.event2 = Event()\\n        \\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t# set flag\\n        self.event1.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event1.wait()\\n        printSecond()\\n\\t\\t# set flag\\n        self.event2.set()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428095,
                "title": "c-autoresetevent-beats-100",
                "content": "```\\n    public class Foo\\n    {\\n        private static AutoResetEvent event_1 = new AutoResetEvent(false);\\n        private static AutoResetEvent event_2 = new AutoResetEvent(false);\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            event_1.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            event_1.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            event_2.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            event_2.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Foo\\n    {\\n        private static AutoResetEvent event_1 = new AutoResetEvent(false);\\n        private static AutoResetEvent event_2 = new AutoResetEvent(false);\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            event_1.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            event_1.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            event_2.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            event_2.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347706,
                "title": "c-2-solutions-with-or-without-thread",
                "content": "#1 with thead\\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) System.Threading.Thread.Sleep(1);\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) System.Threading.Thread.Sleep(1);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```\\n\\n#2 without thread\\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) continue;\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) continue;\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) System.Threading.Thread.Sleep(1);\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) System.Threading.Thread.Sleep(1);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) continue;\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) continue;\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693063,
                "title": "easy-java-solution",
                "content": "```\\nclass Foo {\\n\\n        private final CountDownLatch firstLatch;\\n        private final CountDownLatch secondLatch;\\n\\n        public Foo() {\\n            firstLatch = new CountDownLatch(1);\\n            secondLatch = new CountDownLatch(1);\\n        }\\n\\n        public void first(Runnable printFirst) throws InterruptedException {\\n            printFirst.run();\\n            firstLatch.countDown();\\n        }\\n\\n        public void second(Runnable printSecond) throws InterruptedException {\\n            firstLatch.await();\\n            printSecond.run();\\n            secondLatch.countDown();\\n        }\\n\\n        public void third(Runnable printThird) throws InterruptedException {\\n            secondLatch.await();\\n            printThird.run();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n        private final CountDownLatch firstLatch;\\n        private final CountDownLatch secondLatch;\\n\\n        public Foo() {\\n            firstLatch = new CountDownLatch(1);\\n            secondLatch = new CountDownLatch(1);\\n        }\\n\\n        public void first(Runnable printFirst) throws InterruptedException {\\n            printFirst.run();\\n            firstLatch.countDown();\\n        }\\n\\n        public void second(Runnable printSecond) throws InterruptedException {\\n            firstLatch.await();\\n            printSecond.run();\\n            secondLatch.countDown();\\n        }\\n\\n        public void third(Runnable printThird) throws InterruptedException {\\n            secondLatch.await();\\n            printThird.run();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825386,
                "title": "c-shortest-code-using-promise-class",
                "content": "```\\nclass Foo {\\n    \\nprivate:    \\n    promise<void> p1, p2;    \\n    \\npublic:\\n    Foo() {}\\n    void first(function<void()> printFirst)         {\\n        printFirst()                                ;\\n        p1.set_value()                              ;\\n                                                    }\\n    void second(function<void()> printSecond)       {\\n        p1.get_future().wait()                      ;\\n        printSecond()                               ;\\n        p2.set_value()                              ;}\\n\\n    void third(function<void()> printThird)         {\\n        p2.get_future().wait()                      ;\\n        printThird()                                ;}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    \\nprivate:    \\n    promise<void> p1, p2;    \\n    \\npublic:\\n    Foo() {}\\n    void first(function<void()> printFirst)         {\\n        printFirst()                                ;\\n        p1.set_value()                              ;\\n                                                    }\\n    void second(function<void()> printSecond)       {\\n        p1.get_future().wait()                      ;\\n        printSecond()                               ;\\n        p2.set_value()                              ;}\\n\\n    void third(function<void()> printThird)         {\\n        p2.get_future().wait()                      ;\\n        printThird()                                ;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140864,
                "title": "simple-python-solution",
                "content": "```\\nclass Foo(object):\\n    def __init__(self):\\n        self.x = 0\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.x += 1\\n\\n    def second(self, printSecond):\\n        while self.x < 1:\\n            pass\\n        printSecond()\\n        self.x += 1\\n            \\n    def third(self, printThird):\\n        while self.x < 2:\\n            pass\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo(object):\\n    def __init__(self):\\n        self.x = 0\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.x += 1\\n\\n    def second(self, printSecond):\\n        while self.x < 1:\\n            pass\\n        printSecond()\\n        self.x += 1\\n            \\n    def third(self, printThird):\\n        while self.x < 2:\\n            pass\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997508,
                "title": "python-using-events",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.first_event = threading.Event()\\n        self.second_event = threading.Event()\\n       \\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.first_event.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.first_event.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.second_event.set()\\n            \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.second_event.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.first_event = threading.Event()\\n        self.second_event = threading.Event()\\n       \\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.first_event.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.first_event.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.second_event.set()\\n            \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.second_event.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751895,
                "title": "java-simple-solution",
                "content": "```\\nclass Foo {\\n    \\n    CountDownLatch latchForSecond = new CountDownLatch(1);\\n    CountDownLatch latchForThird = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchForSecond.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchForSecond.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchForThird.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchForThird.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    CountDownLatch latchForSecond = new CountDownLatch(1);\\n    CountDownLatch latchForThird = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchForSecond.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchForSecond.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchForThird.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchForThird.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541307,
                "title": "c-semaphore-based-simple-and-short",
                "content": "```\\ntypedef struct {\\n    sem_t sem_a;\\n    sem_t sem_b;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = malloc(sizeof (Foo));\\n    sem_init(&obj->sem_a, 0, 0);\\n    sem_init(&obj->sem_b, 0, 0);\\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    sem_post(&obj->sem_a);\\n}\\n\\nvoid second(Foo* obj) {\\n    sem_wait(&obj->sem_a);\\n    printSecond();\\n    sem_post(&obj->sem_b);\\n}\\n\\nvoid third(Foo* obj) {\\n    sem_wait(&obj->sem_b);\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    sem_t sem_a;\\n    sem_t sem_b;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = malloc(sizeof (Foo));\\n    sem_init(&obj->sem_a, 0, 0);\\n    sem_init(&obj->sem_b, 0, 0);\\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    sem_post(&obj->sem_a);\\n}\\n\\nvoid second(Foo* obj) {\\n    sem_wait(&obj->sem_a);\\n    printSecond();\\n    sem_post(&obj->sem_b);\\n}\\n\\nvoid third(Foo* obj) {\\n    sem_wait(&obj->sem_b);\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 402339,
                "title": "accepted-c-using-autoresetevent",
                "content": "```\\nusing System.Threading;    \\n\\npublic class Foo\\n    {\\n        private EventWaitHandle _waitFirst;\\n        private EventWaitHandle _waitSecond;\\n\\n        public Foo()\\n        {\\n            _waitFirst = new AutoResetEvent(false);\\n            _waitSecond = new AutoResetEvent(false);\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            _waitFirst.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            _waitFirst.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            _waitSecond.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            _waitSecond.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;    \\n\\npublic class Foo\\n    {\\n        private EventWaitHandle _waitFirst;\\n        private EventWaitHandle _waitSecond;\\n\\n        public Foo()\\n        {\\n            _waitFirst = new AutoResetEvent(false);\\n            _waitSecond = new AutoResetEvent(false);\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            _waitFirst.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            _waitFirst.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            _waitSecond.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            _waitSecond.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376571,
                "title": "simple-java-solution-using-booleans-for-locking",
                "content": "class Foo {\\n    \\n        private volatile boolean executedFirst,executedSecond;\\n        public Foo() {}\\n    \\n        public void first(Runnable printFirst) throws InterruptedException {\\n            executedFirst = true;\\n            printFirst.run();\\n        }\\n    \\n        public void second(Runnable printSecond) throws InterruptedException {\\n    \\n            while (!executedFirst);\\n            executedSecond = true;\\n            printSecond.run();\\n        }\\n    \\n        public void third(Runnable printThird) throws InterruptedException {\\n            while (!executedSecond);\\n            printThird.run();\\n        }",
                "solutionTags": [],
                "code": "class Foo {\\n    \\n        private volatile boolean executedFirst,executedSecond;\\n        public Foo() {}\\n    \\n        public void first(Runnable printFirst) throws InterruptedException {\\n            executedFirst = true;\\n            printFirst.run();\\n        }\\n    \\n        public void second(Runnable printSecond) throws InterruptedException {\\n    \\n            while (!executedFirst);\\n            executedSecond = true;\\n            printSecond.run();\\n        }\\n    \\n        public void third(Runnable printThird) throws InterruptedException {\\n            while (!executedSecond);\\n            printThird.run();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 370780,
                "title": "java-solution-using-wait-and-notifyall",
                "content": "A lot of solutions on here are using busy waits or sleeps - which are only slightly better. That is essentially a \\'fail\\' w.r.t. this question on threads. Here\\'s the solution I believe an interviewer would be looking for that uses wait() and notifyAll() with a liveness check inside a synchronized block. The locking object instance used in this code is the instance of Foo. I.e. \\'this\\'. Using wait() and notifyAll() means that the processors aren\\'t spinning and unnecessarily burning through compute power! \\n\\nAlso - notice that the thread coordination logic happens inside a synchronized block. Without that, there is no guarantee that the JVM memory model will communicate the state of the variables between threads. Always, put this kind of thread-coordination logic inside synchronized blocks. \\n\\nAlso - the Java seed code for this question is incorrectly using the Runnable interface. You never call run() on a runnable! That is for the JVM to call in a new thread when it is started. \\n\\n```\\nclass Foo {\\n    private boolean firstDone = false;\\n    private boolean secondDone = false;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this) {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            firstDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this) {\\n            while (!firstDone) {\\n                this.wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            this.secondDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this) {\\n            while (!secondDone) {\\n                this.wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private boolean firstDone = false;\\n    private boolean secondDone = false;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this) {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            firstDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this) {\\n            while (!firstDone) {\\n                this.wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            this.secondDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this) {\\n            while (!secondDone) {\\n                this.wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281277,
                "title": "c-use-mutex",
                "content": "# Intuition\\nUse condition variable and count variable and based on the count value , the desigenated thread will be running accordingly \\n\\n\\n```\\nclass Foo {\\npublic:\\n\\n    std::mutex m; \\n    std::condition_variable cv;\\n    int count; \\n \\n    Foo():count{0} {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        std::unique_lock<std::mutex> lock(m);\\n\\n        count++;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 1 ? true : false;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count++;\\n        lock.unlock(); \\n        cv.notify_all();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 2 ? true : false;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n\\n    std::mutex m; \\n    std::condition_variable cv;\\n    int count; \\n \\n    Foo():count{0} {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        std::unique_lock<std::mutex> lock(m);\\n\\n        count++;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 1 ? true : false;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count++;\\n        lock.unlock(); \\n        cv.notify_all();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 2 ? true : false;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988841,
                "title": "using-manual-reset-event-set-wait-methods",
                "content": "# Intuition\\nWe need to synchronize the method execution in multi threaded environment so same can be achived using ManualResetEventslim class.  \\n\\n# Approach\\nWe can have two slim events, one to synchronize the call for first and second method to ensure that first always executed before second method. \\nAnd second slim event is to make sure that second method gets executed before the third method. \\nSo, we can intialize these instance in the constructions with disabled state. Till the time we enable them by calling Set method. The thread will wait on Wait method. \\nAfter priting first, we can set the first slim event. If a thread is waiting at Wait method in second method will get notified about its status change and now will resume its work. Same will happen for second slim event. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing System.Threading;\\n\\npublic class Foo {\\n\\n     public ManualResetEventSlim slimEvent { get; set; }\\n     public ManualResetEventSlim secondslimEvent { get; set; }\\n\\n    public Foo() \\n    {\\n        slimEvent = new ManualResetEventSlim(false);\\n        secondslimEvent = new ManualResetEventSlim(false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        slimEvent.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        slimEvent.Wait();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondslimEvent.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        secondslimEvent.Wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n\\n     public ManualResetEventSlim slimEvent { get; set; }\\n     public ManualResetEventSlim secondslimEvent { get; set; }\\n\\n    public Foo() \\n    {\\n        slimEvent = new ManualResetEventSlim(false);\\n        secondslimEvent = new ManualResetEventSlim(false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        slimEvent.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        slimEvent.Wait();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondslimEvent.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        secondslimEvent.Wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028788,
                "title": "simple-c-solution-with-mutex",
                "content": "```\\nclass Foo {\\npublic:\\n    mutex a, b;\\n    Foo() {\\n        a.lock();\\n        b.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        a.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        a.lock();\\n        printSecond();\\n        b.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        b.lock();\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    mutex a, b;\\n    Foo() {\\n        a.lock();\\n        b.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        a.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        a.lock();\\n        printSecond();\\n        b.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        b.lock();\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987717,
                "title": "java-simplest-solution-using-volatile-variable",
                "content": "Here, `volatile` keyword makes the variable threadsafe and making it visible to all threads works.\\n\\n```Java\\nclass Foo {\\n\\n    volatile int methodCompleted;\\n    \\n    public Foo() {\\n        methodCompleted = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        methodCompleted =  1;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (methodCompleted != 1) ;\\n        printSecond.run();\\n        methodCompleted =  2;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (methodCompleted != 2) ;\\n        printThird.run();\\n        methodCompleted =  3;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Foo {\\n\\n    volatile int methodCompleted;\\n    \\n    public Foo() {\\n        methodCompleted = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        methodCompleted =  1;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (methodCompleted != 1) ;\\n        printSecond.run();\\n        methodCompleted =  2;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (methodCompleted != 2) ;\\n        printThird.run();\\n        methodCompleted =  3;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894371,
                "title": "java-countdownlatch-simple-solution",
                "content": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n\\n    private final CountDownLatch firstLatch = new CountDownLatch(1);\\n    private final CountDownLatch secondLatch = new CountDownLatch(1);\\n\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n\\n    private final CountDownLatch firstLatch = new CountDownLatch(1);\\n    private final CountDownLatch secondLatch = new CountDownLatch(1);\\n\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844607,
                "title": "java-semaphore-solution",
                "content": "```\\nclass Foo {\\n    \\n    private final Semaphore second = new Semaphore(0);\\n    private final Semaphore third = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    private final Semaphore second = new Semaphore(0);\\n    private final Semaphore third = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631053,
                "title": "python-simple-solution-without-any-lib",
                "content": "\\tclass Foo:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.seq = 0\\n\\n\\t\\tdef first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\tprintFirst()\\n\\t\\t\\tself.seq = 1\\n\\n\\t\\tdef second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 1:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintSecond()\\n\\t\\t\\tself.seq = 2\\n\\n\\t\\tdef third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintThird()",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Foo:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.seq = 0\\n\\n\\t\\tdef first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\tprintFirst()\\n\\t\\t\\tself.seq = 1\\n\\n\\t\\tdef second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 1:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintSecond()\\n\\t\\t\\tself.seq = 2\\n\\n\\t\\tdef third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintThird()",
                "codeTag": "Java"
            },
            {
                "id": 907002,
                "title": "py3-runtime-32-ms-faster-than-93-93",
                "content": "Using thread lock and lock `first` and `second` first at the begining, then release `first` when `printFirst` being called, and release `second` when `printSecond` being called. After all `printThird` will be called.\\n\\n```class Foo:\\n    def __init__(self):\\n        self.tl1 = threading.Lock()\\n        self.tl2 = threading.Lock()\\n        self.tl1.acquire()\\n        self.tl2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.tl1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.tl1.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.tl2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.tl2.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        ```\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Foo:\\n    def __init__(self):\\n        self.tl1 = threading.Lock()\\n        self.tl2 = threading.Lock()\\n        self.tl1.acquire()\\n        self.tl2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.tl1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.tl1.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.tl2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.tl2.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 809116,
                "title": "java-solution-with-synchronized-methods",
                "content": "Code with a runtime of 10ms :\\n\\n```\\nclass Foo {\\n    public int count;\\n    \\n    public Foo() {\\n        this.count = 1;\\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        while(count != 1) wait();\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while(this.count != 2) wait();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while(this.count != 3) wait();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    public int count;\\n    \\n    public Foo() {\\n        this.count = 1;\\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        while(count != 1) wait();\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while(this.count != 2) wait();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while(this.count != 3) wait();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777380,
                "title": "python-loop-and-flag",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.f = True\\n        self.s = False\\n        self.t = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.s = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        while 1:\\n          if self.s:\\n            break\\n        printSecond()\\n        self.t = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        while 1:\\n          if self.t:\\n            break\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.f = True\\n        self.s = False\\n        self.t = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.s = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        while 1:\\n          if self.s:\\n            break\\n        printSecond()\\n        self.t = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        while 1:\\n          if self.t:\\n            break\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769363,
                "title": "java-simple-solution-using-volatile-97-faster",
                "content": "```\\nclass Foo {\\n\\n    public volatile int order;\\n    public Foo() {\\n        order= 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        order++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(order!=1);\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        order++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(order!=2);\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    public volatile int order;\\n    public Foo() {\\n        order= 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        order++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(order!=1);\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        order++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(order!=2);\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706604,
                "title": "python-use-2-queue-to-synchronize",
                "content": "```\\nfrom Queue import Queue\\n\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.q1 = Queue()\\n        self.q2 = Queue()\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.q1.put(1)\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.q1.get()\\n        printSecond()\\n        self.q2.put(1)\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.q2.get()\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom Queue import Queue\\n\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.q1 = Queue()\\n        self.q2 = Queue()\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.q1.put(1)\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.q1.get()\\n        printSecond()\\n        self.q2.put(1)\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.q2.get()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640143,
                "title": "simple-6-lines-java-explained-solution",
                "content": "Intutuion\\n1. Use volatile variable which will update variable \\'a\\' in different caches of multi core system. Note - It is only required if this code runs on multi core environment.\\n2. Run printFirst.run only when a=1;\\n3. Run printSecond.run only when a=2; \\n4. Similarly printThird.run only when a=3l\\n```\\nclass Foo {\\n    volatile int a;\\n    public Foo() {\\n        a=1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        while(a!=1);\\n        printFirst.run();\\n        a=2;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(a!=2);\\n        printSecond.run();\\n        a=3;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        while(a!=3);\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    volatile int a;\\n    public Foo() {\\n        a=1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        while(a!=1);\\n        printFirst.run();\\n        a=2;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(a!=2);\\n        printSecond.run();\\n        a=3;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        while(a!=3);\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485268,
                "title": "c-w-promise-124ms-92-14-9-4mb-100",
                "content": "* Runtime: 124 ms, faster than 92.14% of C++ online submissions for Print in Order.\\n* Memory Usage: 9.4 MB, less than 100.00% of C++ online submissions for Print in Order.\\n\\nThis is a simple task. I did try writing one solution with a condition_variable and one using future/promise.\\nThe performance was fairly close, with promise performing slightly better.\\n\\nIf the task was larger in some dimension, I could walk through the program to show where time is being wasted.  This is as simple as it gets and there ought to be a tight cluster of results, where relative performance is honestly random.\\n\\nMy reason for using promise is that it avoids synchronizing mutex locks between many threads, but there isn\\'t much tradeoff between memory or performance no matter what you choose.\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {}\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    promise<bool> p1;\\n    promise<bool> p2;\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {}\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    promise<bool> p1;\\n    promise<bool> p2;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355038,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nUse `Guarded Block`\\nhttps://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html\\n\\nBasically, adding `synchronized` keyword to all the methods will require any thread to acquire intrisic lock of the object of `Foo` (which is used by all the three thread below).\\nNow on this lock, we can conditionally block the threads based on current `counter` value. Only unblock the thread for which the condition that it was waiting for is met and rest of the threads will be blocked (their execution is suspended by the `wait()` call). \\n\\n```\\nclass Foo {\\n    int counter = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(counter != 1){\\n            wait();\\n        }\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(counter != 2){\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(counter != 3){\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    int counter = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(counter != 1){\\n            wait();\\n        }\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(counter != 2){\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(counter != 3){\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348334,
                "title": "c-autoresetevent-116ms",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    EventWaitHandle evnt1 = null;\\n    EventWaitHandle evnt2 = null;\\n    public Foo() {\\n        evnt1 = new AutoResetEvent(false);\\n        evnt2 = new AutoResetEvent(false);\\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        evnt1.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        evnt1.WaitOne();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        evnt2.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        evnt2.WaitOne();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        evnt2.Set();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    EventWaitHandle evnt1 = null;\\n    EventWaitHandle evnt2 = null;\\n    public Foo() {\\n        evnt1 = new AutoResetEvent(false);\\n        evnt2 = new AutoResetEvent(false);\\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        evnt1.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        evnt1.WaitOne();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        evnt2.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        evnt2.WaitOne();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        evnt2.Set();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339796,
                "title": "java-using-semaphores",
                "content": "```\\nimport java.util.concurrent.Semaphore;\\nclass Foo {\\n\\n    private final Semaphore second;\\n    private final Semaphore third;\\n    \\n    public Foo() {        \\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.Semaphore;\\nclass Foo {\\n\\n    private final Semaphore second;\\n    private final Semaphore third;\\n    \\n    public Foo() {        \\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333235,
                "title": "python-3-submission-with-threading-condition-beats-100-100",
                "content": "```\\nimport threading\\n\\n\\nclass Foo:\\n    def __init__(self):\\n        self.condition = threading.Condition()\\n        self.first_was_printed = False\\n        self.second_was_printed = False\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            printFirst()            \\n            self.first_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.first_was_printed\\n            )\\n            printSecond()\\n            self.second_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.second_was_printed\\n            )\\n            printThird()\\n            self.condition.notifyAll()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\n\\n\\nclass Foo:\\n    def __init__(self):\\n        self.condition = threading.Condition()\\n        self.first_was_printed = False\\n        self.second_was_printed = False\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            printFirst()            \\n            self.first_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.first_was_printed\\n            )\\n            printSecond()\\n            self.second_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.second_was_printed\\n            )\\n            printThird()\\n            self.condition.notifyAll()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511261,
                "title": "c-one-line-solution-with-std-atomic",
                "content": "# Intuition\\nWe use a variable (`turn`) to keep track of turns.\\n\\n# Approach\\nWe use `std::atomic` to prevent data race. Plus, we use `yield` to prevent busy waiting.\\n\\n# Code\\n```\\nclass Foo {\\n    std::atomic<int> turn = 1;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        while(turn!=1)\\n            this_thread::yield();\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn++;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(turn!=2)\\n            this_thread::yield();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn++;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(turn!=3)\\n            this_thread::yield();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    std::atomic<int> turn = 1;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        while(turn!=1)\\n            this_thread::yield();\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn++;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(turn!=2)\\n            this_thread::yield();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn++;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(turn!=3)\\n            this_thread::yield();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454807,
                "title": "semaphore-solution-simple-java-code",
                "content": "```\\nclass Foo {\\n\\n    private Semaphore forTwo;\\n    private Semaphore forThree;\\n    \\n    public Foo() {\\n        forTwo = new Semaphore(0);\\n        forThree = new Semaphore(0);\\n    }\\n\\n\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        forTwo.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        forTwo.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        forThree.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        \\n        forThree.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private Semaphore forTwo;\\n    private Semaphore forThree;\\n    \\n    public Foo() {\\n        forTwo = new Semaphore(0);\\n        forThree = new Semaphore(0);\\n    }\\n\\n\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        forTwo.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        forTwo.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        forThree.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        \\n        forThree.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147615,
                "title": "a-simple-solution-in-java",
                "content": "```\\nclass Foo {\\n    \\n    CountDownLatch second;\\n    CountDownLatch third;\\n\\n    public Foo() {\\n        second = new CountDownLatch(1);\\n        third = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    CountDownLatch second;\\n    CountDownLatch third;\\n\\n    public Foo() {\\n        second = new CountDownLatch(1);\\n        third = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013481,
                "title": "brainless-solution-using-time-sleep",
                "content": "Here is my simplest and brainless solution using time.sleep. Why and How did I think of it? People use this approach in automation where I work.\\n\\n```Python3\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        sleep(0.05)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        sleep(0.1)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python3\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        sleep(0.05)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        sleep(0.1)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856298,
                "title": "2-lines-python-solution-75-faster-memory-less-than-95",
                "content": "```\\nclass Foo:\\n    is_first_executed=False\\n    is_second_executed=False\\n    def __init__(self):\\n        pass\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.is_first_executed=True\\n\\n    def second(self, printSecond):\\n        while not self.is_first_executed: continue     \\n        printSecond()\\n        self.is_second_executed=True\\n                      \\n    def third(self, printThird):\\n        while not self.is_second_executed: continue\\n        printThird()\\n```\\n\\n-----------------\\n### ***Another Solution***\\n```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.event1=Event()\\n        self.event2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    is_first_executed=False\\n    is_second_executed=False\\n    def __init__(self):\\n        pass\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.is_first_executed=True\\n\\n    def second(self, printSecond):\\n        while not self.is_first_executed: continue     \\n        printSecond()\\n        self.is_second_executed=True\\n                      \\n    def third(self, printThird):\\n        while not self.is_second_executed: continue\\n        printThird()\\n```\n```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.event1=Event()\\n        self.event2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719686,
                "title": "c-zero-semaphore-with-comments",
                "content": "```\\n#include<semaphore.h>\\nclass Foo {\\npublic:\\n    sem_t sem1;\\n    sem_t sem2;\\n    Foo() {\\n        sem_init(&sem1,0,0);\\n        sem_init(&sem2,0,0);\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        printFirst();\\n        sem_post(&sem1);// increased the value to 1 so now two can be executed\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        sem_wait(&sem1);//see  if the value of the semaphore is > 0 or not if it is then one already was printed\\n        printSecond();\\n        sem_post(&sem2);// printed two so now increased the value of the semaphore sem2\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        sem_wait(&sem2);// if the value of the sem2 > 0 them two was already printed \\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<semaphore.h>\\nclass Foo {\\npublic:\\n    sem_t sem1;\\n    sem_t sem2;\\n    Foo() {\\n        sem_init(&sem1,0,0);\\n        sem_init(&sem2,0,0);\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        printFirst();\\n        sem_post(&sem1);// increased the value to 1 so now two can be executed\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        sem_wait(&sem1);//see  if the value of the semaphore is > 0 or not if it is then one already was printed\\n        printSecond();\\n        sem_post(&sem2);// printed two so now increased the value of the semaphore sem2\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        sem_wait(&sem2);// if the value of the sem2 > 0 them two was already printed \\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1548013,
                "title": "explanation-of-the-solution-in-java",
                "content": "You can use a countdownlatch, semaphore, regular mutex or lock object. I noticed a solution that relied upon volatile only but that is not right. A solution without wait/notify will cause CPU churns and spinning so you must introduce that if you are serious about MT safe programming. If you choose to go with CountDownLatch or Semaphores, you can create 2 indepent ones and there is an ordering one after another. I chose to use a lock object to demonstrate in detail how we enforce the ordering. Note that you must have a while loop to protect against the spurious wakeups. \\n\\n```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    private final Lock lock = new ReentrantLock();\\n    private final Condition secondThread = lock.newCondition();\\n    private final Condition thirdThread = lock.newCondition();\\n    private int step = 1;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();  \\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            // signal 2nd.\\n            step = 2;\\n            secondThread.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step != 2) {\\n                // protect against spurious wakeups.\\n                secondThread.await();        \\n            }\\n            printSecond.run();\\n            thirdThread.signal();\\n            step = 3;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step !=3) {\\n                // protect against spurious wakeups.\\n                thirdThread.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    private final Lock lock = new ReentrantLock();\\n    private final Condition secondThread = lock.newCondition();\\n    private final Condition thirdThread = lock.newCondition();\\n    private int step = 1;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();  \\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            // signal 2nd.\\n            step = 2;\\n            secondThread.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step != 2) {\\n                // protect against spurious wakeups.\\n                secondThread.await();        \\n            }\\n            printSecond.run();\\n            thirdThread.signal();\\n            step = 3;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step !=3) {\\n                // protect against spurious wakeups.\\n                thirdThread.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182618,
                "title": "simple-java-solution",
                "content": "Using wait and notifyAll to print in order. \\n``` \\nvolatile int loc = 0;\\n    public Foo() {\\n      loc = 0;   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            while(loc != 0){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 1){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printSecond.run();\\n         }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 2){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printThird.run();\\n         }\\n    }",
                "solutionTags": [],
                "code": "Using wait and notifyAll to print in order. \\n``` \\nvolatile int loc = 0;\\n    public Foo() {\\n      loc = 0;   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            while(loc != 0){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 1){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printSecond.run();\\n         }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 2){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printThird.run();\\n         }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1152634,
                "title": "c-mutex-and-condition-variable-12ms",
                "content": "```\\nclass Foo {\\n    mutex m;\\n    condition_variable firstCond;\\n    condition_variable secondCond;\\n    condition_variable thirdCond;\\n    int chance;\\npublic:\\n    Foo() {\\n        chance=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> locker(m);\\n        \\n        firstCond.wait(locker,[&](){\\n            return chance==1;\\n        });\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        chance=2;\\n        secondCond.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> locker(m);\\n        \\n        secondCond.wait(locker,[&](){\\n            return chance==2;\\n        });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        chance=3;\\n        thirdCond.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> locker(m);\\n        \\n        thirdCond.wait(locker,[&](){\\n            return chance==3;\\n        });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    mutex m;\\n    condition_variable firstCond;\\n    condition_variable secondCond;\\n    condition_variable thirdCond;\\n    int chance;\\npublic:\\n    Foo() {\\n        chance=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> locker(m);\\n        \\n        firstCond.wait(locker,[&](){\\n            return chance==1;\\n        });\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        chance=2;\\n        secondCond.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> locker(m);\\n        \\n        secondCond.wait(locker,[&](){\\n            return chance==2;\\n        });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        chance=3;\\n        thirdCond.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> locker(m);\\n        \\n        thirdCond.wait(locker,[&](){\\n            return chance==3;\\n        });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122967,
                "title": "c-simple-atomics-with-memory-order",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a1.store(true, memory_order_release);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!a1.load(std::memory_order_acquire)) this_thread::yield();\\n        printSecond();\\n        a2.store(true, memory_order_release);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(!a2.load(std::memory_order_acquire)) this_thread::yield();\\n        printThird();\\n    }\\nprivate:\\n    atomic<bool> a1{false};\\n    atomic<bool> a2{false};\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a1.store(true, memory_order_release);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!a1.load(std::memory_order_acquire)) this_thread::yield();\\n        printSecond();\\n        a2.store(true, memory_order_release);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(!a2.load(std::memory_order_acquire)) this_thread::yield();\\n        printThird();\\n    }\\nprivate:\\n    atomic<bool> a1{false};\\n    atomic<bool> a2{false};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055949,
                "title": "c-using-semaphores-short-with-comments",
                "content": "```\\n#include <semaphore.h>\\nclass Foo {\\n    sem_t firstSem;\\n    sem_t secondSem;\\npublic:\\n    Foo() {\\n\\t//init two semaphores with counter = 0\\n        sem_init(&firstSem, 0, 0);\\n        sem_init(&secondSem, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&firstSem); //increase firstSem counter to one to indicate printFirst() was finish \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&firstSem); //wait for printFirst() to finish\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&secondSem);  //increase secondSem counter to one to indicate printSecond() was finish \\n    }\\n\\n    void third(function<void()> printThird) {\\n         sem_wait(&secondSem); //wait for printSecond() to finish\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <semaphore.h>\\nclass Foo {\\n    sem_t firstSem;\\n    sem_t secondSem;\\npublic:\\n    Foo() {\\n\\t//init two semaphores with counter = 0\\n        sem_init(&firstSem, 0, 0);\\n        sem_init(&secondSem, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&firstSem); //increase firstSem counter to one to indicate printFirst() was finish \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&firstSem); //wait for printFirst() to finish\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&secondSem);  //increase secondSem counter to one to indicate printSecond() was finish \\n    }\\n\\n    void third(function<void()> printThird) {\\n         sem_wait(&secondSem); //wait for printSecond() to finish\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1033792,
                "title": "c-condition-variable-clean-code-easy-to-understand",
                "content": "```C++\\nclass Foo {\\n    atomic<int> cur;\\n    mutex mtx;\\n    condition_variable cv;\\nprotected:\\n    void do_work(function<void()> printS, function<bool()> check) {\\n        std::unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return check();});\\n        \\n        cur = (cur+1)%4;\\n        printS();\\n        cv.notify_all();\\n    }\\n    \\npublic:\\n    Foo() {\\n       this->cur = 1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        do_work(printFirst, [&]{return cur == 1;});\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        do_work(printSecond, [&]{return cur == 2;});\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n       do_work(printThird, [&]{return cur == 3;});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\nclass Foo {\\n    atomic<int> cur;\\n    mutex mtx;\\n    condition_variable cv;\\nprotected:\\n    void do_work(function<void()> printS, function<bool()> check) {\\n        std::unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return check();});\\n        \\n        cur = (cur+1)%4;\\n        printS();\\n        cv.notify_all();\\n    }\\n    \\npublic:\\n    Foo() {\\n       this->cur = 1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        do_work(printFirst, [&]{return cur == 1;});\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        do_work(printSecond, [&]{return cur == 2;});\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n       do_work(printThird, [&]{return cur == 3;});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008159,
                "title": "java-fastest-using-volatile-boolean-and-while-poll",
                "content": "```\\nclass Foo {\\n    volatile boolean waitTwo = true;\\n    volatile boolean waitThree = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        waitTwo = false;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(waitTwo){}\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        waitThree = false;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        while(waitThree){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    volatile boolean waitTwo = true;\\n    volatile boolean waitThree = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        waitTwo = false;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(waitTwo){}\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        waitThree = false;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        while(waitThree){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961280,
                "title": "python-solution-without-using-additional-libraries",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self._first = False\\n        self._second = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self._first = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while not self._first:\\n            pass\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self._second = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while not self._second:\\n            pass\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self._first = False\\n        self._second = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self._first = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while not self._first:\\n            pass\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self._second = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while not self._second:\\n            pass\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941730,
                "title": "countdownlatch-java",
                "content": "```\\nclass Foo {\\n\\n    private CountDownLatch latch1 = new CountDownLatch(1);\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n  \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n       \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        latch2.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private CountDownLatch latch1 = new CountDownLatch(1);\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n  \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n       \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        latch2.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940759,
                "title": "c-solution-using-2-mutexes",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        pthread_mutex_lock(&m_second);\\n        pthread_mutex_lock(&m_third);\\n    }\\n    \\n    ~Foo() {\\n        pthread_mutex_destroy(&m_second);\\n        pthread_mutex_destroy(&m_third);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        pthread_mutex_unlock(&m_second);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_second);\\n        printSecond();\\n        pthread_mutex_unlock(&m_third);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_third);\\n        printThird();\\n    }\\nprivate:\\n    pthread_mutex_t m_second = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_mutex_t m_third = PTHREAD_MUTEX_INITIALIZER;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        pthread_mutex_lock(&m_second);\\n        pthread_mutex_lock(&m_third);\\n    }\\n    \\n    ~Foo() {\\n        pthread_mutex_destroy(&m_second);\\n        pthread_mutex_destroy(&m_third);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        pthread_mutex_unlock(&m_second);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_second);\\n        printSecond();\\n        pthread_mutex_unlock(&m_third);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_third);\\n        printThird();\\n    }\\nprivate:\\n    pthread_mutex_t m_second = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_mutex_t m_third = PTHREAD_MUTEX_INITIALIZER;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850599,
                "title": "java-semaphore-simple-implementation",
                "content": "```\\nclass Foo {\\n    \\n    Semaphore second = new Semaphore(0);\\n    Semaphore third = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    Semaphore second = new Semaphore(0);\\n    Semaphore third = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757587,
                "title": "c-132ms-7-2mb-using-std-condition-variable-in-a-proper-way",
                "content": "Example with test cases\\nhttps://github.com/jimmy-park/leetcode-cpp-solution/blob/master/Concurrency/1114-Print-in-Order.h\\n\\n```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst)\\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n        {\\n            // prevent lost wakeup and spurious wakeup\\n            // and with CTAD (since C++17), you don\\'t need to type std::mutex as template argument\\n            std::lock_guard lock { mutex_ };\\n            done_first_ = true;\\n        }\\n\\n        cv_.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_first_; });\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        {\\n            std::lock_guard lock { mutex_ };\\n            done_second_ = true;\\n        }\\n        \\n        cv_.notify_one();\\n    }\\n\\n    void third(function<void()> printThird)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_second_; });\\n        }\\n\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    bool done_first_ { false };\\n    bool done_second_ { false };\\n    mutable std::mutex mutex_;\\n    std::condition_variable cv_;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst)\\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n        {\\n            // prevent lost wakeup and spurious wakeup\\n            // and with CTAD (since C++17), you don\\'t need to type std::mutex as template argument\\n            std::lock_guard lock { mutex_ };\\n            done_first_ = true;\\n        }\\n\\n        cv_.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_first_; });\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        {\\n            std::lock_guard lock { mutex_ };\\n            done_second_ = true;\\n        }\\n        \\n        cv_.notify_one();\\n    }\\n\\n    void third(function<void()> printThird)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_second_; });\\n        }\\n\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    bool done_first_ { false };\\n    bool done_second_ { false };\\n    mutable std::mutex mutex_;\\n    std::condition_variable cv_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567213,
                "title": "java-countdownlatch-solution",
                "content": "```\\nclass Foo {\\n\\n    CountDownLatch first = new CountDownLatch(1);\\n    CountDownLatch second = new CountDownLatch(1);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    CountDownLatch first = new CountDownLatch(1);\\n    CountDownLatch second = new CountDownLatch(1);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512327,
                "title": "python3-threading-using-lock",
                "content": "Algorithm:\\nUse two locks `self.lock1` and `self.lock2` to maintain the order of executions of 3 methods. \\n\\nImplementation (32ms, 90%): \\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        self.lock1.acquire() #lock\\n        self.lock2.acquire() #lock\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.lock1.release() #unlocked\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.lock1:\\n            # printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond()\\n            self.lock2.release() #unlocked\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.lock2:\\n            # printThird() outputs \"third\". Do not change or remove this line.\\n            printThird()\\n```\\n\\nThere is a very nice summary by @mereck in this [thread](https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation) of Python synchronization primitives.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        self.lock1.acquire() #lock\\n        self.lock2.acquire() #lock\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.lock1.release() #unlocked\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.lock1:\\n            # printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond()\\n            self.lock2.release() #unlocked\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.lock2:\\n            # printThird() outputs \"third\". Do not change or remove this line.\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477201,
                "title": "countdownlatch-java-100-100",
                "content": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    CountDownLatch latch1;\\n    CountDownLatch latch2;\\n    \\n    public Foo() {\\n        latch1 = new CountDownLatch(1);\\n        latch2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    CountDownLatch latch1;\\n    CountDownLatch latch2;\\n    \\n    public Foo() {\\n        latch1 = new CountDownLatch(1);\\n        latch2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476741,
                "title": "java-using-lock-synchronized-wait-notifyall-solution",
                "content": "```java\\nclass Foo {\\n    private final AtomicInteger i = new AtomicInteger();\\n    private final Object lock = new Object();\\n\\n    public Foo() {\\n        i.set(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 0) {\\n                lock.wait();\\n            }\\n            printFirst.run();\\n            i.set(1);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 1) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            i.set(2);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 2) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n            i.set(3);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    private final AtomicInteger i = new AtomicInteger();\\n    private final Object lock = new Object();\\n\\n    public Foo() {\\n        i.set(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 0) {\\n                lock.wait();\\n            }\\n            printFirst.run();\\n            i.set(1);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 1) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            i.set(2);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 2) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n            i.set(3);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456220,
                "title": "c-with-spinwait",
                "content": "```\\nusing System.Threading;\\npublic class Foo {\\n    private int _state = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        _state = 2; \\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==2);\\n        printSecond();\\n        _state=3;\\n    }\\n\\n    public void Third(Action printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==3);\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\npublic class Foo {\\n    private int _state = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        _state = 2; \\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==2);\\n        printSecond();\\n        _state=3;\\n    }\\n\\n    public void Third(Action printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==3);\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447099,
                "title": "simple-java-solution",
                "content": "```\\nclass Foo {\\n    CountDownLatch lock1;\\n    CountDownLatch lock2;\\n    public Foo() {\\n        lock1 = new CountDownLatch(1);\\n        lock2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        lock1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        lock2.countDown();\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock1.await();\\n        lock2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    CountDownLatch lock1;\\n    CountDownLatch lock2;\\n    public Foo() {\\n        lock1 = new CountDownLatch(1);\\n        lock2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        lock1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        lock2.countDown();\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock1.await();\\n        lock2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440715,
                "title": "why-sem-t-is-unknown-for-c",
                "content": "When I include semaphore.h in C code and use sem_t sem, it gives unknown data type sem_t?\\nerror:\\nLine 10: Char 5: error: unknown type name \\'sem_t\\'\\n     sem_t sem;\\n\\n#include <semaphore.h>\\n#include <pthread.h>\\n#include <unistd.h> \\n#include <sys/types.h>\\n\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int data;\\n    sem_t sem;\\n} Foo;\\n",
                "solutionTags": [],
                "code": "When I include semaphore.h in C code and use sem_t sem, it gives unknown data type sem_t?\\nerror:\\nLine 10: Char 5: error: unknown type name \\'sem_t\\'\\n     sem_t sem;\\n\\n#include <semaphore.h>\\n#include <pthread.h>\\n#include <unistd.h> \\n#include <sys/types.h>\\n\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int data;\\n    sem_t sem;\\n} Foo;\\n",
                "codeTag": "C++"
            },
            {
                "id": 436919,
                "title": "c-solution-no-need-a-lock",
                "content": "```\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int val;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    \\n    // Initialize user defined data here.\\n    obj->val = 0;\\n    \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    \\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    \\n    obj->val++;\\n}\\n\\nvoid second(Foo* obj) {\\n    while (obj->val < 1) {\\n       sched_yield();\\n    }\\n    \\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    \\n    obj->val++;\\n}\\n\\nvoid third(Foo* obj) {\\n    while (obj->val < 2) {\\n       sched_yield();\\n    }\\n    \\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // User defined data may be cleaned up here.\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int val;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    \\n    // Initialize user defined data here.\\n    obj->val = 0;\\n    \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    \\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    \\n    obj->val++;\\n}\\n\\nvoid second(Foo* obj) {\\n    while (obj->val < 1) {\\n       sched_yield();\\n    }\\n    \\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    \\n    obj->val++;\\n}\\n\\nvoid third(Foo* obj) {\\n    while (obj->val < 2) {\\n       sched_yield();\\n    }\\n    \\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // User defined data may be cleaned up here.\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 360882,
                "title": "c-super-simple-implementation-90",
                "content": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    int state;\\n    condition_variable cv;\\npublic:\\n    Foo(): state{0}{}\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==0;});\\n        state=1;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==1;});\\n        state=2;\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==2;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    int state;\\n    condition_variable cv;\\npublic:\\n    Foo(): state{0}{}\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==0;});\\n        state=1;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==1;});\\n        state=2;\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==2;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356791,
                "title": "c-future-promise-or-mutex-condition-variable",
                "content": "Solution 1: \\nfuture + promise.\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    std::promise<int> p1;\\n    std::promise<int> p2;\\n};\\n```\\n\\nsolution 2:\\nmutex + condition_variable\\n```\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        b1 = false;\\n        b2 = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        b1 = true;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b1;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        b2 = true;\\n        lk.unlock();\\n        cv.notify_one();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b2; });\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lk.unlock();\\n    }\\nprivate:    \\n    std::mutex mtx;\\n    bool b1, b2;\\n    condition_variable cv;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    std::promise<int> p1;\\n    std::promise<int> p2;\\n};\\n```\n```\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        b1 = false;\\n        b2 = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        b1 = true;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b1;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        b2 = true;\\n        lk.unlock();\\n        cv.notify_one();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b2; });\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lk.unlock();\\n    }\\nprivate:    \\n    std::mutex mtx;\\n    bool b1, b2;\\n    condition_variable cv;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353129,
                "title": "java-solution-with-single-semaphore",
                "content": "```\\nclass Foo {\\n\\n    java.util.concurrent.Semaphore semaphore = new java.util.concurrent.Semaphore(2);\\n    \\n    public Foo() {\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(semaphore.availablePermits() != 2){}\\n        \\n        printFirst.run();\\n\\n        semaphore.acquire();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(semaphore.availablePermits() != 1){}\\n        \\n        printSecond.run();        \\n\\n        semaphore.acquire();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(semaphore.availablePermits() != 0){}\\n        \\n        printThird.run();\\n\\n        semaphore.release(2);\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    java.util.concurrent.Semaphore semaphore = new java.util.concurrent.Semaphore(2);\\n    \\n    public Foo() {\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(semaphore.availablePermits() != 2){}\\n        \\n        printFirst.run();\\n\\n        semaphore.acquire();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(semaphore.availablePermits() != 1){}\\n        \\n        printSecond.run();        \\n\\n        semaphore.acquire();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(semaphore.availablePermits() != 0){}\\n        \\n        printThird.run();\\n\\n        semaphore.release(2);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 347584,
                "title": "java-compareandset",
                "content": "```java\\nimport java.util.concurrent.atomic.AtomicInteger;\\nclass Foo {\\n\\n    private AtomicInteger integer;\\n    \\n    public Foo() {\\n        integer = new AtomicInteger();    \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(!integer.compareAndSet(0, 1));\\n        printFirst.run();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!integer.compareAndSet(1, 2));\\n        printSecond.run();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!integer.compareAndSet(2, 3));\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.util.concurrent.atomic.AtomicInteger;\\nclass Foo {\\n\\n    private AtomicInteger integer;\\n    \\n    public Foo() {\\n        integer = new AtomicInteger();    \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(!integer.compareAndSet(0, 1));\\n        printFirst.run();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!integer.compareAndSet(1, 2));\\n        printSecond.run();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!integer.compareAndSet(2, 3));\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336394,
                "title": "java-volatile-9ms",
                "content": "```\\nclass Foo {\\n    private  volatile Integer a;\\n    public Foo() {\\n        a = 0;\\n    }\\n    public void first(Runnable printFirst) throws InterruptedException {\\n         printFirst.run();\\n         a++;\\n    }\\n    public void second(Runnable printSecond) throws InterruptedException {\\n         while(a%3 != 1){}\\n         printSecond.run();\\n         a++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n          while(a%3 != 2){}\\n          printThird.run();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private  volatile Integer a;\\n    public Foo() {\\n        a = 0;\\n    }\\n    public void first(Runnable printFirst) throws InterruptedException {\\n         printFirst.run();\\n         a++;\\n    }\\n    public void second(Runnable printSecond) throws InterruptedException {\\n         while(a%3 != 1){}\\n         printSecond.run();\\n         a++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n          while(a%3 != 2){}\\n          printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332954,
                "title": "java-go-implements",
                "content": "Interesting, wish leetcode provide Go lang soon.\\n\\n**Java**\\n```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    Semaphore semaphore1 = new Semaphore(0);\\n    Semaphore semaphore2 = new Semaphore(0);\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        semaphore1.acquire();\\n        printSecond.run();\\n        semaphore2.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        semaphore2.acquire();        \\n        printThird.run();\\n    }\\n}\\n```\\n\\n**Go**\\n```\\npackage main\\n\\nimport \"fmt\"\\n\\nvar oneDone = make(chan bool)\\nvar twoDone = make(chan bool)\\n\\nfunc first() {\\n\\tfmt.Println(\"one\")\\n\\toneDone <- true\\n}\\n\\nfunc second() {\\n\\t<-oneDone\\n\\tfmt.Println(\"two\")\\n\\ttwoDone <- true\\n}\\n\\nfunc third() {\\n\\t<-twoDone\\n\\tfmt.Println(\"three\")\\n}\\n\\nfunc main() {\\n\\tgo second()\\n\\tgo third()\\n\\tgo first()\\n\\n\\tfmt.Scanln()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    Semaphore semaphore1 = new Semaphore(0);\\n    Semaphore semaphore2 = new Semaphore(0);\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        semaphore1.acquire();\\n        printSecond.run();\\n        semaphore2.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        semaphore2.acquire();        \\n        printThird.run();\\n    }\\n}\\n```\n```\\npackage main\\n\\nimport \"fmt\"\\n\\nvar oneDone = make(chan bool)\\nvar twoDone = make(chan bool)\\n\\nfunc first() {\\n\\tfmt.Println(\"one\")\\n\\toneDone <- true\\n}\\n\\nfunc second() {\\n\\t<-oneDone\\n\\tfmt.Println(\"two\")\\n\\ttwoDone <- true\\n}\\n\\nfunc third() {\\n\\t<-twoDone\\n\\tfmt.Println(\"three\")\\n}\\n\\nfunc main() {\\n\\tgo second()\\n\\tgo third()\\n\\tgo first()\\n\\n\\tfmt.Scanln()\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022323,
                "title": "c-mutex-condition-variable-simple-code",
                "content": "# Note\\n\\n* We don\\'t need any wait for printing 1. Hence, no condition variable wait\\n* We don\\'t need to notify anyone after printing 3. Hence, no notify after printing 3.\\n* My code doesn\\'t work when I do \\n`if(currentPrint!=2) cv.wait(lock)`\\nbut works only when I do \\n`cv.wait(lock,[&](){return currentPrint==2;});`\\n\\nIt is best to pass the boolean expression as part of wait. Otherwise, there is a timeout.\\n\\n\\n# Code\\n```\\nclass Foo {\\n    condition_variable cv;\\n    mutex mtx;\\n    int currentPrint;\\npublic:\\n    Foo() {\\n        currentPrint=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex>lock(mtx);\\n        currentPrint=2;\\n        printFirst();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==2;});\\n        currentPrint=3;\\n        printSecond();\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==3;});\\n        printThird();\\n    }\\n};\\n```\\n\\n\\nPlease let me know if there are any feedbacks on this. Happy coding (^-^)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    condition_variable cv;\\n    mutex mtx;\\n    int currentPrint;\\npublic:\\n    Foo() {\\n        currentPrint=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex>lock(mtx);\\n        currentPrint=2;\\n        printFirst();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==2;});\\n        currentPrint=3;\\n        printSecond();\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==3;});\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475728,
                "title": "only-used-vector-no-lock-semaphore-low-level-objects",
                "content": "# Approach\\nNot a fan of low level stuff (even for easy questions), so here\\'s a solution using nothing but a vector.\\n\\nI made the class have a vector, printed, which contains bool values of whether any given print function executed. Since the same instance will be passed to each thread, all threads can update this vector so that other threads can see.\\n\\nAdditonally, since each thread calls a different function (Thread A calls first(), Thread B second(), Thread C third()), they will all manipulate a different section of the Foo object (Thread A printed[0], Thread B printed[1], Thread C printed[2]), so race conditions are taken into account in this solution.\\n\\nThis solution has a high run time (beats 9.36% of solutions), and is not anything remotely like any reasonable expected solution. This solution is for the software engineers that ventured into the land of concurrency out of curiosity, like me.\\n\\n\\n# Code\\n```\\nclass Foo {\\nprivate:\\n    vector<bool> printed; // keeps track of which print funcs executed\\npublic:\\n    Foo() : printed(3, false) {}\\n\\n    void first(function<void()> printFirst) {\\n        printFirst(); // this should always print first\\n        printed[0] = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (!printed[0]) {} // second will never print first, wait for first\\n        printSecond();\\n        printed[1] = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // no need to explicitly wait for first, since second should never execute before first\\n        // besides, waiting for first and second creates a race condition, since two threads are reading the same piece of data\\n        while (!printed[1]) {} // wait for second\\n        printThird();\\n        printed[2] = true;\\n    }\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Concurrency"
                ],
                "code": "```\\nclass Foo {\\nprivate:\\n    vector<bool> printed; // keeps track of which print funcs executed\\npublic:\\n    Foo() : printed(3, false) {}\\n\\n    void first(function<void()> printFirst) {\\n        printFirst(); // this should always print first\\n        printed[0] = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (!printed[0]) {} // second will never print first, wait for first\\n        printSecond();\\n        printed[1] = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // no need to explicitly wait for first, since second should never execute before first\\n        // besides, waiting for first and second creates a race condition, since two threads are reading the same piece of data\\n        while (!printed[1]) {} // wait for second\\n        printThird();\\n        printed[2] = true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203351,
                "title": "c-simple-solution-using-only-this-thread-yield",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    int order = 1;\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n       if (order == 1) {\\n         order = 2;\\n       } \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (order != 2) {\\n          std::this_thread::yield();\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        if (order == 2) {\\n          order = 3;\\n        } \\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (order != 3) {\\n          std::this_thread::yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    int order = 1;\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n       if (order == 1) {\\n         order = 2;\\n       } \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (order != 2) {\\n          std::this_thread::yield();\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        if (order == 2) {\\n          order = 3;\\n        } \\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (order != 3) {\\n          std::this_thread::yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135932,
                "title": "java-reentrant-lock",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\n\\n    private final ReentrantLock lock = new ReentrantLock();\\n\\n    private final Condition condition1 = lock.newCondition();\\n\\n    private final Condition condition2 = lock.newCondition();\\n\\n    private boolean waitOne = true;\\n\\n    private boolean waitTwo = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            waitOne = false;\\n            condition1.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitOne) {\\n                condition1.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            waitTwo = false;\\n            condition2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitTwo) {\\n                condition2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printThird.run();\\n            waitOne = true;\\n            waitTwo = true;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n    private final ReentrantLock lock = new ReentrantLock();\\n\\n    private final Condition condition1 = lock.newCondition();\\n\\n    private final Condition condition2 = lock.newCondition();\\n\\n    private boolean waitOne = true;\\n\\n    private boolean waitTwo = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            waitOne = false;\\n            condition1.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitOne) {\\n                condition1.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            waitTwo = false;\\n            condition2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitTwo) {\\n                condition2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printThird.run();\\n            waitOne = true;\\n            waitTwo = true;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086543,
                "title": "java-solution-approach-1-using-object-lock-approach-2-using-countdown-latch",
                "content": "# Intuition\\nWe need to suspend the thread printing second until first completes, and third until second completes.\\n\\n# Approach 1 - Using Object lock\\nUse `synchronsed` block to guard the block of code, and suspend the thread using `buzy waiting` method until `first`, `second` is not printed in order.\\n\\n\\n# Code\\n```java\\nclass Foo {\\n    private int currentNum;\\n\\n    public Foo() {\\n        this.currentNum = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 1) {\\n                wait();\\n            }\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 2) {\\n                wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n         synchronized (this) {\\n            while (currentNum != 3) {\\n                wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n}\\n```\\n\\n\\n# Approach 2 - Using CountDownLatch\\nHere we make use of two countdown latches, \\nthe second thread waits on first latch to countDown to 0, and third thread waits on second latch to countDown to 0.\\n<br>\\nThe code is self explanatory.\\n\\n# Code\\n```java\\nclass Foo {\\n    private CountDownLatch firstLatch;\\n    private CountDownLatch secondLatch;\\n\\n    public Foo() {\\n        this.firstLatch = new CountDownLatch(1);\\n        this.secondLatch = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) {\\n        printFirst.run();\\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        printSecond.run();\\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Foo {\\n    private int currentNum;\\n\\n    public Foo() {\\n        this.currentNum = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 1) {\\n                wait();\\n            }\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 2) {\\n                wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n         synchronized (this) {\\n            while (currentNum != 3) {\\n                wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n}\\n```\n```java\\nclass Foo {\\n    private CountDownLatch firstLatch;\\n    private CountDownLatch secondLatch;\\n\\n    public Foo() {\\n        this.firstLatch = new CountDownLatch(1);\\n        this.secondLatch = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) {\\n        printFirst.run();\\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        printSecond.run();\\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823042,
                "title": "java-solution-using-semaphore",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Foo {\\n\\n    Semaphore first;\\n    Semaphore second;\\n    Semaphore third;\\n    public Foo() {\\n        first = new Semaphore(1);\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        first.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        first.release();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n    Semaphore first;\\n    Semaphore second;\\n    Semaphore third;\\n    public Foo() {\\n        first = new Semaphore(1);\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        first.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        first.release();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790990,
                "title": "java-phaser",
                "content": "# Code\\n```\\nclass Foo {\\n    private Phaser phaser = new Phaser(3);\\n\\n    public Foo() { }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (phaser.getPhase() != 1) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (phaser.getPhase() != 2) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private Phaser phaser = new Phaser(3);\\n\\n    public Foo() { }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (phaser.getPhase() != 1) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (phaser.getPhase() != 2) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755956,
                "title": "c-blocking-threads-with-autoresetevent-primitives",
                "content": "# Intuition\\nFirst thing that came to my mind was to block second, then third method until prefious will be completed\\n\\n# Approach\\nI decided to block set blockers in second and third methods. We create 2 blockers in nonsignal state, that means the method WaitOne() will block threads. \\n\\nMethod First() without blockers, after running printFirst() we transfer _secondBlocker in signal state by running method Set(), so _secondBlocker unblocks blocked threads. The same with method Third()\\n\\n# Code\\n```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly AutoResetEvent _secondBlocker = new AutoResetEvent(false);\\n    private readonly AutoResetEvent _thirdBlocker = new AutoResetEvent(false);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _secondBlocker.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _secondBlocker.WaitOne();\\n        printSecond();\\n        _thirdBlocker.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _thirdBlocker.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly AutoResetEvent _secondBlocker = new AutoResetEvent(false);\\n    private readonly AutoResetEvent _thirdBlocker = new AutoResetEvent(false);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _secondBlocker.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _secondBlocker.WaitOne();\\n        printSecond();\\n        _thirdBlocker.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _thirdBlocker.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716544,
                "title": "c-0ms-100",
                "content": "![image](https://assets.leetcode.com/users/images/65577e65-fc51-4d55-a6ff-ad0c635d4717_1666065469.4353917.png)\\n```\\ntypedef struct\\n{\\n    // User defined data may be declared here.\\n    int turn;\\n    pthread_mutex_t lock;\\n    pthread_cond_t cond;\\n} Foo;\\n\\nFoo* fooCreate()\\n{\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    // init mutex and cond\\n    pthread_mutex_init(&(obj->lock), NULL);\\n    pthread_cond_init(&(obj->cond), NULL);\\n    obj->turn = 1;\\n    return obj;\\n}\\n\\nvoid first(Foo* obj)\\n{\\n    // take lock\\n    pthread_mutex_lock(&(obj->lock));\\n    // while not my turn\\n    while(obj->turn != 1)\\n    {\\n        // wait and unlock\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    obj->turn = 2;\\n    // unlock\\n    pthread_mutex_unlock(&(obj->lock));\\n    // broadcast\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid second(Foo* obj)\\n{\\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 2)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock));\\n    }\\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    obj->turn = 3;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid third(Foo* obj)\\n{    \\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 3)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n    obj->turn = 1;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid fooFree(Foo* obj)\\n{\\n    // User defined data may be cleaned up here.\\n    free(obj);\\n}\\n```\\n\\u2B06\\uFE0Fplease upvote if helpful :)\\u2B06\\uFE0F",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct\\n{\\n    // User defined data may be declared here.\\n    int turn;\\n    pthread_mutex_t lock;\\n    pthread_cond_t cond;\\n} Foo;\\n\\nFoo* fooCreate()\\n{\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    // init mutex and cond\\n    pthread_mutex_init(&(obj->lock), NULL);\\n    pthread_cond_init(&(obj->cond), NULL);\\n    obj->turn = 1;\\n    return obj;\\n}\\n\\nvoid first(Foo* obj)\\n{\\n    // take lock\\n    pthread_mutex_lock(&(obj->lock));\\n    // while not my turn\\n    while(obj->turn != 1)\\n    {\\n        // wait and unlock\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    obj->turn = 2;\\n    // unlock\\n    pthread_mutex_unlock(&(obj->lock));\\n    // broadcast\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid second(Foo* obj)\\n{\\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 2)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock));\\n    }\\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    obj->turn = 3;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid third(Foo* obj)\\n{    \\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 3)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n    obj->turn = 1;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid fooFree(Foo* obj)\\n{\\n    // User defined data may be cleaned up here.\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2533398,
                "title": "java-real-simple-solution",
                "content": "```\\nclass Foo {\\n    private volatile int num = 1;\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(num != 1){\\n        }\\n\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        num++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(num != 2){\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        num++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(num != 3){\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        num++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private volatile int num = 1;\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(num != 1){\\n        }\\n\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        num++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(num != 2){\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        num++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(num != 3){\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        num++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403054,
                "title": "python-easy-solution",
                "content": "```\\nimport time\\nclass Foo:\\n    def __init__(self):\\n        self.state = [False,False,False]\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.state[0] = True\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.state[0]==False: time.sleep(0.001)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.state[1] = True\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.state[1]==False: time.sleep(0.001)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.state[2] = True\\n```",
                "solutionTags": [],
                "code": "```\\nimport time\\nclass Foo:\\n    def __init__(self):\\n        self.state = [False,False,False]\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.state[0] = True\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.state[0]==False: time.sleep(0.001)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.state[1] = True\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.state[1]==False: time.sleep(0.001)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.state[2] = True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356900,
                "title": "using-event",
                "content": "```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.t1=Event()\\n        self.t2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        printFirst()\\n        self.t1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.t1.wait()\\n        printSecond()\\n        self.t2.set()\\n        \\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.t2.wait()\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.t1=Event()\\n        self.t2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        printFirst()\\n        self.t1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.t1.wait()\\n        printSecond()\\n        self.t2.set()\\n        \\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.t2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313189,
                "title": "java-easy-solution",
                "content": "```\\nclass Foo {\\n    CountDownLatch c;\\n    CountDownLatch b;\\n\\n    public Foo() {\\n        b = new CountDownLatch(1);\\n        c = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        b.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        b.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        c.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        c.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    CountDownLatch c;\\n    CountDownLatch b;\\n\\n    public Foo() {\\n        b = new CountDownLatch(1);\\n        c = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        b.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        b.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        c.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        c.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265427,
                "title": "c-using-mutex-and-conditional-variable",
                "content": "In this solution I have used mutex and conditional variable. Also used an additional variable turn which will keep in track of which thread\\'s turn it is.\\n\\n```\\n// All the three threads got CPU and are running parallely. We don\\'t know which will run 1st, 2nd ...\\n\\n// Object of class Foo will be created. Foo --> foo1\\n// T1 = foo1.first\\n// T2 = foo1.second\\n// T3 = foo1.third\\n\\n// T2 will be waiting on some condition, which will become true when T1 has been executed\\n// T1 will make it true after printing first\\n\\n// Will use mutex and condition variable, and a variable turn to know who\\'s turn it is\\n// All the threads will shoot parallely. First turn = 0\\n\\nclass Foo {\\n    int turn;\\n    condition_variable(cv);\\n    mutex m;\\npublic:\\n    Foo() { // constructor\\n        turn = 0;\\n    }\\n\\n    void first(function<void()> printFirst) { // No condition on this as T1 will come first and execute it\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn = 1; // next turn is of T2\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(m);\\n        while(turn != 1){\\n            cv.wait(lock); // If it\\'s not turn of T2, thread will wait\\n        }\\n        // when signalled by T1, will go in while loop and check if turn == 1, if not then again wait.\\n        // else print second\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn = 2; // next turn is of T3\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(m);\\n        // When T1 will signal, CPU will come and check T3 also but due to condition of while loop it will again wait\\n        while(turn != 2){\\n            cv.wait(lock);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// All the three threads got CPU and are running parallely. We don\\'t know which will run 1st, 2nd ...\\n\\n// Object of class Foo will be created. Foo --> foo1\\n// T1 = foo1.first\\n// T2 = foo1.second\\n// T3 = foo1.third\\n\\n// T2 will be waiting on some condition, which will become true when T1 has been executed\\n// T1 will make it true after printing first\\n\\n// Will use mutex and condition variable, and a variable turn to know who\\'s turn it is\\n// All the threads will shoot parallely. First turn = 0\\n\\nclass Foo {\\n    int turn;\\n    condition_variable(cv);\\n    mutex m;\\npublic:\\n    Foo() { // constructor\\n        turn = 0;\\n    }\\n\\n    void first(function<void()> printFirst) { // No condition on this as T1 will come first and execute it\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn = 1; // next turn is of T2\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(m);\\n        while(turn != 1){\\n            cv.wait(lock); // If it\\'s not turn of T2, thread will wait\\n        }\\n        // when signalled by T1, will go in while loop and check if turn == 1, if not then again wait.\\n        // else print second\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn = 2; // next turn is of T3\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(m);\\n        // When T1 will signal, CPU will come and check T3 also but due to condition of while loop it will again wait\\n        while(turn != 2){\\n            cv.wait(lock);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064377,
                "title": "c-unique-lock-and-condition-variable-concurrency-in-c-notes",
                "content": "Tracking the last executed function using an integer. Then used a `condition_variable::wait` with a lambda expression to wait for the integer to change.\\n\\nConcurrency in C++ notes: https://github.com/akormous/dsa/tree/master/9_Concurrency\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        lastExecutedFunction = 0;   // initially\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);  // acquire lock\\n        cv.wait(lock, [&]{return lastExecutedFunction == 0;});  // wait until last executed function is 0, initial condition\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        lastExecutedFunction = 1;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 1;});  // wait until last exec function is first()\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        lastExecutedFunction = 2;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 2;});  // wait until last exec function is second()\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        lastExecutedFunction = 0;\\n        cv.notify_all();\\n    }\\nprivate:\\n    mutex mtx;\\n    condition_variable cv;\\n    int lastExecutedFunction;   // 0 (initial), 1, 2, or 3\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        lastExecutedFunction = 0;   // initially\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);  // acquire lock\\n        cv.wait(lock, [&]{return lastExecutedFunction == 0;});  // wait until last executed function is 0, initial condition\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        lastExecutedFunction = 1;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 1;});  // wait until last exec function is first()\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        lastExecutedFunction = 2;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 2;});  // wait until last exec function is second()\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        lastExecutedFunction = 0;\\n        cv.notify_all();\\n    }\\nprivate:\\n    mutex mtx;\\n    condition_variable cv;\\n    int lastExecutedFunction;   // 0 (initial), 1, 2, or 3\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908213,
                "title": "pthread-h-mutex-cond",
                "content": "```c\\ntypedef struct {\\n        int flag;\\n        pthread_mutex_t mtx;\\n        pthread_cond_t cnd;\\n} Foo;\\n\\nFoo *\\nfooCreate()\\n{\\n        Foo *foo;\\n        foo = malloc(sizeof(*foo));\\n        foo->flag = 0;\\n        pthread_mutex_init(&foo->mtx, NULL);\\n        pthread_cond_init(&foo->cnd, NULL);\\n        return foo;\\n}\\n\\nvoid\\nsignal(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        foo->flag = val;\\n        pthread_cond_broadcast(&foo->cnd);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nwait(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        while (foo->flag != val)\\n                pthread_cond_wait(&foo->cnd, &foo->mtx);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nfirst(Foo *foo)\\n{\\n        printFirst();\\n        signal(foo, 1);\\n}\\n\\nvoid\\nsecond(Foo *foo)\\n{\\n        wait(foo, 1);\\n        printSecond();\\n        signal(foo, 2);\\n}\\n\\nvoid\\nthird(Foo *foo)\\n{\\n        wait(foo, 2);\\n        printThird();\\n}\\n\\nvoid\\nfooFree(Foo *foo)\\n{\\n        pthread_mutex_destroy(&foo->mtx);\\n        pthread_cond_destroy(&foo->cnd);\\n        free(foo);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\ntypedef struct {\\n        int flag;\\n        pthread_mutex_t mtx;\\n        pthread_cond_t cnd;\\n} Foo;\\n\\nFoo *\\nfooCreate()\\n{\\n        Foo *foo;\\n        foo = malloc(sizeof(*foo));\\n        foo->flag = 0;\\n        pthread_mutex_init(&foo->mtx, NULL);\\n        pthread_cond_init(&foo->cnd, NULL);\\n        return foo;\\n}\\n\\nvoid\\nsignal(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        foo->flag = val;\\n        pthread_cond_broadcast(&foo->cnd);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nwait(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        while (foo->flag != val)\\n                pthread_cond_wait(&foo->cnd, &foo->mtx);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nfirst(Foo *foo)\\n{\\n        printFirst();\\n        signal(foo, 1);\\n}\\n\\nvoid\\nsecond(Foo *foo)\\n{\\n        wait(foo, 1);\\n        printSecond();\\n        signal(foo, 2);\\n}\\n\\nvoid\\nthird(Foo *foo)\\n{\\n        wait(foo, 2);\\n        printThird();\\n}\\n\\nvoid\\nfooFree(Foo *foo)\\n{\\n        pthread_mutex_destroy(&foo->mtx);\\n        pthread_cond_destroy(&foo->cnd);\\n        free(foo);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1896980,
                "title": "java-object-wait-notify-solution",
                "content": "As the same Foo instance passed to all threads, we can use the instance as a lock and use an index as identifier to arrange the correct order for printing.\\n```\\nclass Foo {\\n    private int index;\\n    public Foo() {\\n        index = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 0)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printFirst.run();\\n            index++;\\n            this.notifyAll();\\n            \\n        }\\n       \\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 1)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printSecond.run();\\n            index++;\\n            this.notifyAll();\\n       }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 2)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            index++;\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private int index;\\n    public Foo() {\\n        index = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 0)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printFirst.run();\\n            index++;\\n            this.notifyAll();\\n            \\n        }\\n       \\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 1)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printSecond.run();\\n            index++;\\n            this.notifyAll();\\n       }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 2)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            index++;\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839215,
                "title": "python3-using-3-locks-60ms",
                "content": "from threading import Thread, Lock\\n\\n```\\nclass Foo:\\n    def __init__(self):\\n        self.lockFirst = Lock()\\n        self.lockSecond = Lock()\\n        self.lockThird = Lock()\\n        self.lockSecond.acquire()\\n        self.lockThird.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.lockFirst.acquire()\\n        printFirst()\\n        self.lockSecond.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lockSecond.acquire()\\n        printSecond()\\n        self.lockThird.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lockThird.acquire()\\n        printThird()\\n        self.lockFirst.release()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.lockFirst = Lock()\\n        self.lockSecond = Lock()\\n        self.lockThird = Lock()\\n        self.lockSecond.acquire()\\n        self.lockThird.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.lockFirst.acquire()\\n        printFirst()\\n        self.lockSecond.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lockSecond.acquire()\\n        printSecond()\\n        self.lockThird.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lockThird.acquire()\\n        printThird()\\n        self.lockFirst.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748867,
                "title": "python-solution",
                "content": "```\\nfrom threading import Lock\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.locks[0].release()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.locks[1]:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Lock\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.locks[0].release()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.locks[1]:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606754,
                "title": "java-synchronized-on-the-foo-object",
                "content": "I\\'ve seen some more exotic solutions posted here. Is this standard or in any way problematic?\\n```class Foo {\\n    private static enum PrintState {\\n        ZERO, DID1, DID2\\n    }\\n    private PrintState printState = PrintState.ZERO;\\n    \\n    public Foo() {}\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(printState != PrintState.ZERO) wait();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        printState = PrintState.DID1;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(printState != PrintState.DID1) wait();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        printState = PrintState.DID2;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(printState != PrintState.DID2) wait();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        printState = PrintState.ZERO;\\n        notifyAll();\\n    }\\n}",
                "solutionTags": [],
                "code": "I\\'ve seen some more exotic solutions posted here. Is this standard or in any way problematic?\\n```class Foo {\\n    private static enum PrintState {\\n        ZERO, DID1, DID2\\n    }\\n    private PrintState printState = PrintState.ZERO;\\n    \\n    public Foo() {}\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(printState != PrintState.ZERO) wait();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        printState = PrintState.DID1;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(printState != PrintState.DID1) wait();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        printState = PrintState.DID2;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(printState != PrintState.DID2) wait();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        printState = PrintState.ZERO;\\n        notifyAll();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1569063,
                "title": "python-mutex",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        from threading import Lock\\n\\n        self._mutex1 = Lock()\\n        self._mutex2 = Lock()\\n        self._mutex1.acquire()\\n        self._mutex2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self._mutex1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self._mutex1.acquire()\\n        printSecond()\\n        self._mutex1.release()\\n        self._mutex2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:        \\n        self._mutex2.acquire()\\n        printThird()\\n        self._mutex2.release()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        from threading import Lock\\n\\n        self._mutex1 = Lock()\\n        self._mutex2 = Lock()\\n        self._mutex1.acquire()\\n        self._mutex2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self._mutex1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self._mutex1.acquire()\\n        printSecond()\\n        self._mutex1.release()\\n        self._mutex2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:        \\n        self._mutex2.acquire()\\n        printThird()\\n        self._mutex2.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405854,
                "title": "scalable-c-solution-without-mutexes-and-convars",
                "content": "Scalable c++ solution without mutexes and convars. We just wait untill n is equal 1,2,...\\n\\n```\\nclass Foo {\\npublic:\\n    std::atomic<std::size_t> n{0};\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        n.fetch_add(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(n.load() != 1) {\\n            std::this_thread::yield();\\n        }\\n        printSecond();\\n        n.fetch_add(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(n.load() != 2) {\\n            std::this_thread::yield();\\n        }\\n        printThird();\\n    }\\n};",
                "solutionTags": [],
                "code": "Scalable c++ solution without mutexes and convars. We just wait untill n is equal 1,2,...\\n\\n```\\nclass Foo {\\npublic:\\n    std::atomic<std::size_t> n{0};\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        n.fetch_add(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(n.load() != 1) {\\n            std::this_thread::yield();\\n        }\\n        printSecond();\\n        n.fetch_add(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(n.load() != 2) {\\n            std::this_thread::yield();\\n        }\\n        printThird();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1335161,
                "title": "java-java-lang-concurrency-synchronized-without-active-waiting",
                "content": "```\\nclass Foo {\\n    private boolean isFirstDone = false;\\n    private boolean isSecondDone = false;\\n    \\n    private Object firstMonitor = new Object();\\n    private Object secondMonitor = new Object();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            isFirstDone = true;\\n            firstMonitor.notify();\\n            \\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            while (!isFirstDone) {\\n                firstMonitor.wait();\\n            }\\n        }\\n        \\n        synchronized (secondMonitor) {\\n            isSecondDone = true;\\n            secondMonitor.notify();\\n            \\n            printSecond.run();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (secondMonitor) {\\n            while (!isSecondDone) {\\n                secondMonitor.wait();\\n            }\\n        }\\n\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private boolean isFirstDone = false;\\n    private boolean isSecondDone = false;\\n    \\n    private Object firstMonitor = new Object();\\n    private Object secondMonitor = new Object();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            isFirstDone = true;\\n            firstMonitor.notify();\\n            \\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            while (!isFirstDone) {\\n                firstMonitor.wait();\\n            }\\n        }\\n        \\n        synchronized (secondMonitor) {\\n            isSecondDone = true;\\n            secondMonitor.notify();\\n            \\n            printSecond.run();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (secondMonitor) {\\n            while (!isSecondDone) {\\n                secondMonitor.wait();\\n            }\\n        }\\n\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314293,
                "title": "c-solution",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    ManualResetEvent _second = new ManualResetEvent(false);\\n    ManualResetEvent _third = new ManualResetEvent(false);\\n    \\n    public Foo() {\\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _second.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _second.WaitOne();\\n        printSecond();\\n        _third.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _third.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    ManualResetEvent _second = new ManualResetEvent(false);\\n    ManualResetEvent _third = new ManualResetEvent(false);\\n    \\n    public Foo() {\\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _second.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _second.WaitOne();\\n        printSecond();\\n        _third.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _third.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100106,
                "title": "c-linux-semaphores",
                "content": "```\\n#include <semaphore.h>\\n \\nclass Foo {\\npublic:\\n    Foo() {\\n        sem_init(&_first_job_done, 0, 0);\\n        sem_init(&_second_job_done, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&_first_job_done);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&_first_job_done);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&_second_job_done);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&_second_job_done);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    sem_t _first_job_done{0};\\n    sem_t _second_job_done{0};\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <semaphore.h>\\n \\nclass Foo {\\npublic:\\n    Foo() {\\n        sem_init(&_first_job_done, 0, 0);\\n        sem_init(&_second_job_done, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&_first_job_done);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&_first_job_done);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&_second_job_done);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&_second_job_done);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    sem_t _first_job_done{0};\\n    sem_t _second_job_done{0};\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1078156,
                "title": "c-solution-with-condition-variable-and-mutex",
                "content": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    condition_variable produce2, produce3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    \\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<std::mutex> lck(mtx);\\n        printFirst();\\n        second_unlocked = true;\\n        produce2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce2.wait(lck, [this] {return second_unlocked;});\\n        printSecond();\\n        third_unlocked = true;\\n        produce3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce3.wait(lck, [this] {return third_unlocked;});\\n        printThird();\\n        lck.unlock();\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    condition_variable produce2, produce3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    \\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<std::mutex> lck(mtx);\\n        printFirst();\\n        second_unlocked = true;\\n        produce2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce2.wait(lck, [this] {return second_unlocked;});\\n        printSecond();\\n        third_unlocked = true;\\n        produce3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce3.wait(lck, [this] {return third_unlocked;});\\n        printThird();\\n        lck.unlock();\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1066739,
                "title": "java-just-volatile",
                "content": "```\\nclass Foo {\\n    \\n    private volatile int i = 0;\\n\\n    public Foo() {   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        i = 1;\\n        Thread.yield();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(i!=1){\\n            Thread.yield();\\n        }\\n        printSecond.run();\\n        i = 2;\\n        Thread.yield();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(i!=2){\\n            Thread.yield();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private volatile int i = 0;\\n\\n    public Foo() {   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        i = 1;\\n        Thread.yield();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(i!=1){\\n            Thread.yield();\\n        }\\n        printSecond.run();\\n        i = 2;\\n        Thread.yield();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(i!=2){\\n            Thread.yield();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020495,
                "title": "java-leverage-countdownlatch",
                "content": "```java\\nclass Foo {\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n    private CountDownLatch latch3 = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch3.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n    private CountDownLatch latch3 = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch3.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009752,
                "title": "c-monitor-wait-pulseall",
                "content": "```\\nusing System.Threading; \\n\\npublic class Foo\\n    {\\n        class Lock\\n        {\\n           public int Step;\\n        }\\n\\n        static Lock _Lock = new Lock(){ Step = 0 };\\n\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            lock (_Lock)\\n            {\\n                // printFirst() outputs \"first\". Do not change or remove this line.\\n                printFirst();\\n                _Lock.Step = 1;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            lock (_Lock)\\n            {\\n                while (_Lock.Step!= 1)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printSecond() outputs \"second\". Do not change or remove this line.\\n                printSecond();\\n                _Lock.Step = 2;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            lock (_Lock)\\n            {\\n                while(_Lock.Step!=2)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printThird() outputs \"third\". Do not change or remove this line.                \\n                printThird();\\n                _Lock.Step = 3;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading; \\n\\npublic class Foo\\n    {\\n        class Lock\\n        {\\n           public int Step;\\n        }\\n\\n        static Lock _Lock = new Lock(){ Step = 0 };\\n\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            lock (_Lock)\\n            {\\n                // printFirst() outputs \"first\". Do not change or remove this line.\\n                printFirst();\\n                _Lock.Step = 1;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            lock (_Lock)\\n            {\\n                while (_Lock.Step!= 1)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printSecond() outputs \"second\". Do not change or remove this line.\\n                printSecond();\\n                _Lock.Step = 2;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            lock (_Lock)\\n            {\\n                while(_Lock.Step!=2)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printThird() outputs \"third\". Do not change or remove this line.                \\n                printThird();\\n                _Lock.Step = 3;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006405,
                "title": "faster-then-100-java-countdownlatch",
                "content": "```\\nclass Foo {\\n    \\n    private final CountDownLatch first;\\n    private final CountDownLatch second;\\n\\n    public Foo() {\\n        first = new CountDownLatch(1);\\n        second = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private final CountDownLatch first;\\n    private final CountDownLatch second;\\n\\n    public Foo() {\\n        first = new CountDownLatch(1);\\n        second = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968990,
                "title": "c-1-mutex-1-condition-variable-simple-solution",
                "content": "Just check if the counter is equal to itself, if not then release lock and wait.\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        now = 0;        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 0;\\n            });\\n            ++now;\\n            printFirst();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 1;\\n            });\\n            ++now;\\n            printSecond();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 2;\\n            });\\n            ++now;\\n            printThird();\\n        }\\n        cv.notify_all();\\n    }\\n    condition_variable cv;\\n    mutex mtx;\\n    int now;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        now = 0;        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 0;\\n            });\\n            ++now;\\n            printFirst();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 1;\\n            });\\n            ++now;\\n            printSecond();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 2;\\n            });\\n            ++now;\\n            printThird();\\n        }\\n        cv.notify_all();\\n    }\\n    condition_variable cv;\\n    mutex mtx;\\n    int now;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960489,
                "title": "c-using-semaphore",
                "content": "```\\n\\n    private static Semaphore _First = new Semaphore(0,1);\\n    private static Semaphore _Second = new Semaphore(0,1);\\n    \\n    public void First(Action printFirst) {\\n        printFirst();\\n        _First.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _First.WaitOne();\\n        printSecond();\\n        _Second.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _Second.WaitOne();\\n        printThird();\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    private static Semaphore _First = new Semaphore(0,1);\\n    private static Semaphore _Second = new Semaphore(0,1);\\n    \\n    public void First(Action printFirst) {\\n        printFirst();\\n        _First.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _First.WaitOne();\\n        printSecond();\\n        _Second.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _Second.WaitOne();\\n        printThird();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 943530,
                "title": "simple-and-does-the-work-for-beginners",
                "content": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.call = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.   \\n        printFirst()\\n        self.call = 1\\n        \\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.call != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.call = 2\\n            \\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.call != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.call = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.   \\n        printFirst()\\n        self.call = 1\\n        \\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.call != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.call = 2\\n            \\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.call != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 899019,
                "title": "java-3-semaphore-solution",
                "content": "```java\\nclass Foo {\\n    \\n    private Semaphore s1 = new Semaphore(1);\\n    private Semaphore s2 = new Semaphore(0);\\n    private Semaphore s3 = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        s1.acquire();\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        s3.acquire();\\n        printThird.run();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    \\n    private Semaphore s1 = new Semaphore(1);\\n    private Semaphore s2 = new Semaphore(0);\\n    private Semaphore s3 = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        s1.acquire();\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        s3.acquire();\\n        printThird.run();\\n        \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 808148,
                "title": "java-solution-using-atomic-integer",
                "content": "```\\nclass Foo {\\n\\n    private AtomicInteger firstJobDone = new AtomicInteger(0);\\n    private AtomicInteger secondJobDone = new AtomicInteger(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstJobDone.incrementAndGet();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(firstJobDone.get()!=1){}\\n        printSecond.run();\\n        secondJobDone.incrementAndGet();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(secondJobDone.get() != 1){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private AtomicInteger firstJobDone = new AtomicInteger(0);\\n    private AtomicInteger secondJobDone = new AtomicInteger(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstJobDone.incrementAndGet();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(firstJobDone.get()!=1){}\\n        printSecond.run();\\n        secondJobDone.incrementAndGet();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(secondJobDone.get() != 1){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798189,
                "title": "python3-fastest-and-simplest-solution",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.firstlock = threading.Lock()\\n        self.secondlock = threading.Lock()\\n        self.thirdlock = threading.Lock()\\n        \\n        self.firstlock.acquire()\\n        self.secondlock.acquire()\\n        self.thirdlock.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.firstlock.release()\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.secondlock.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.secondlock.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.thirdlock.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.thirdlock.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.thirdlock.release()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.firstlock = threading.Lock()\\n        self.secondlock = threading.Lock()\\n        self.thirdlock = threading.Lock()\\n        \\n        self.firstlock.acquire()\\n        self.secondlock.acquire()\\n        self.thirdlock.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.firstlock.release()\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.secondlock.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.secondlock.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.thirdlock.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.thirdlock.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.thirdlock.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744073,
                "title": "py-soln-using-sleep-simple-and-fast",
                "content": "This simple solution was faster than 95.4% solutiions (32ms runtime)\\n```\\n\\n\\nclass Foo:\\n#flag variables \\n    calledFirst = 0\\n    calledSecond = 0\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        #print and set flag\\n        printFirst()\\n        self.calledFirst = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t#wait for 0.01s and then check for the condition again \\n        while(not self.calledFirst):\\n            time.sleep(0.01)\\n        printSecond()\\n\\t\\t#flag for second function\\n        self.calledSecond = 1\\n      \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n       \\n        while(not self.calledSecond):        \\n            time.sleep(0.01)\\n        printThird()\\n        \\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n\\nclass Foo:\\n#flag variables \\n    calledFirst = 0\\n    calledSecond = 0\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        #print and set flag\\n        printFirst()\\n        self.calledFirst = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t#wait for 0.01s and then check for the condition again \\n        while(not self.calledFirst):\\n            time.sleep(0.01)\\n        printSecond()\\n\\t\\t#flag for second function\\n        self.calledSecond = 1\\n      \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n       \\n        while(not self.calledSecond):        \\n            time.sleep(0.01)\\n        printThird()\\n        \\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 671719,
                "title": "java-locks-conditional",
                "content": "```\\nclass Foo {\\n    \\n    private int currentThreadNum = 1;\\n    private ReentrantLock locker = new ReentrantLock();\\n    private Condition condition = locker.newCondition();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            printFirst.run();\\n            currentThreadNum = 2;\\n            condition.signalAll();\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 2) {\\n                condition.await();\\n            }\\n            printSecond.run();\\n            currentThreadNum = 3;\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 3) {\\n                condition.await();\\n            }\\n            printThird.run();\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private int currentThreadNum = 1;\\n    private ReentrantLock locker = new ReentrantLock();\\n    private Condition condition = locker.newCondition();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            printFirst.run();\\n            currentThreadNum = 2;\\n            condition.signalAll();\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 2) {\\n                condition.await();\\n            }\\n            printSecond.run();\\n            currentThreadNum = 3;\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 3) {\\n                condition.await();\\n            }\\n            printThird.run();\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632100,
                "title": "java-with-countdown-latch",
                "content": "```\\nclass Foo {\\n\\n    private CountDownLatch firstFinished = new CountDownLatch(1);\\n    private CountDownLatch secondFinished = new CountDownLatch(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstFinished.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstFinished.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        secondFinished.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondFinished.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private CountDownLatch firstFinished = new CountDownLatch(1);\\n    private CountDownLatch secondFinished = new CountDownLatch(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstFinished.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstFinished.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        secondFinished.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondFinished.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601183,
                "title": "volatile-counter-java",
                "content": "```\\nclass Foo {\\n    volatile int count ;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        count++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(count!=1) {}\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        count++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(count!=2) {}\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    volatile int count ;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        count++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(count!=1) {}\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        count++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(count!=2) {}\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598546,
                "title": "java-lock-condition",
                "content": "```\\nclass Foo {\\n\\n    private final Lock lock;\\n    private final Condition c2;\\n    private final Condition c3;\\n    private boolean printed1 = false;\\n    private boolean printed2 = false;\\n\\n    public Foo() {\\n        lock = new ReentrantLock();\\n        c2 = lock.newCondition();\\n        c3 = lock.newCondition();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            printed1 = true;\\n            c2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed1) {\\n                c2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            printed2 = true;\\n            c3.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed2) {\\n                c3.await();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private final Lock lock;\\n    private final Condition c2;\\n    private final Condition c3;\\n    private boolean printed1 = false;\\n    private boolean printed2 = false;\\n\\n    public Foo() {\\n        lock = new ReentrantLock();\\n        c2 = lock.newCondition();\\n        c3 = lock.newCondition();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            printed1 = true;\\n            c2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed1) {\\n                c2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            printed2 = true;\\n            c3.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed2) {\\n                c3.await();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561105,
                "title": "java-most-efficient",
                "content": "```\\nclass Foo {\\n\\n    private int x = 0;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        x = x + 1;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while (x < 1) {\\n            wait();\\n        }\\n        printSecond.run();\\n        x = x + 1;                \\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while (x < 2) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private int x = 0;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        x = x + 1;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while (x < 1) {\\n            wait();\\n        }\\n        printSecond.run();\\n        x = x + 1;                \\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while (x < 2) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499799,
                "title": "python-solution-with-driver-code",
                "content": "Here\\'s the solution with driver code, so you can run it on your own machine.\\n```\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.second_lock = threading.Lock()\\n        self.second_lock.acquire()\\n        self.third_lock = threading.Lock()\\n        self.third_lock.acquire()\\n\\n    def first(self):\\n\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        print(\\'first\\')\\n        self.second_lock.release()\\n\\n    def second(self):\\n\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.second_lock:\\n            print(\\'second_lock\\')\\n            self.third_lock.release()\\n\\n    def third(self):\\n\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.third_lock:\\n            print(\\'third_lock\\')\\n\\na = Foo()\\nt1 = threading.Thread(target=a.third)\\nt2 = threading.Thread(target=a.second)\\nt3 = threading.Thread(target=a.first)\\n\\nt1.start()\\nt2.start()\\nt3.start()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.second_lock = threading.Lock()\\n        self.second_lock.acquire()\\n        self.third_lock = threading.Lock()\\n        self.third_lock.acquire()\\n\\n    def first(self):\\n\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        print(\\'first\\')\\n        self.second_lock.release()\\n\\n    def second(self):\\n\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.second_lock:\\n            print(\\'second_lock\\')\\n            self.third_lock.release()\\n\\n    def third(self):\\n\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.third_lock:\\n            print(\\'third_lock\\')\\n\\na = Foo()\\nt1 = threading.Thread(target=a.third)\\nt2 = threading.Thread(target=a.second)\\nt3 = threading.Thread(target=a.first)\\n\\nt1.start()\\nt2.start()\\nt3.start()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493520,
                "title": "non-blocking-solution-9ms",
                "content": "```\\nclass Foo {\\n    private volatile boolean firstCompleted;\\n    private volatile boolean secondCompleted;\\n\\t\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n      printFirst.run();\\n      firstCompleted = true;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n      while (!firstCompleted) {\\n        \\n      }\\n      printSecond.run();\\n      secondCompleted = true;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n      while (!secondCompleted) {\\n\\n      }\\n      printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private volatile boolean firstCompleted;\\n    private volatile boolean secondCompleted;\\n\\t\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n      printFirst.run();\\n      firstCompleted = true;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n      while (!firstCompleted) {\\n        \\n      }\\n      printSecond.run();\\n      secondCompleted = true;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n      while (!secondCompleted) {\\n\\n      }\\n      printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474102,
                "title": "simple-java-solution-using-wait-and-notify",
                "content": "```\\nclass Foo {\\n    \\n\\n    int count = 1;\\n    public Foo() {   \\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            printFirst.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        synchronized(this){\\n            while(count != 2){\\n                this.wait();\\n            }\\n            printSecond.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n\\n        synchronized(this){\\n            while(count != 3){\\n                this.wait();\\n            }\\n            printThird.run();\\n        }\\n   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n\\n    int count = 1;\\n    public Foo() {   \\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            printFirst.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        synchronized(this){\\n            while(count != 2){\\n                this.wait();\\n            }\\n            printSecond.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n\\n        synchronized(this){\\n            while(count != 3){\\n                this.wait();\\n            }\\n            printThird.run();\\n        }\\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472228,
                "title": "c-same-pattern-for-all-3-functions-using-condition-variable",
                "content": "Extracted a run_step function that can be called by all three original functions. This can be easily extended to more steps.\\n\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        cur_step = 0;\\n    }\\n    \\n    void run_step(int step, function<void()> func) {\\n        std::unique_lock<std::mutex> lk(mtx);\\n        cv.wait(lk, [&]{return cur_step == step;}); // keep waiting until cur_step == step.\\n        func();\\n        cur_step++; // safely increasing cur_step.\\n        cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        run_step(0, printFirst);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        run_step(1, printSecond);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        run_step(2, printThird);\\n    }\\n\\nprivate:\\n    std::condition_variable cv;\\n    std::mutex mtx;\\n    volatile int cur_step;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        cur_step = 0;\\n    }\\n    \\n    void run_step(int step, function<void()> func) {\\n        std::unique_lock<std::mutex> lk(mtx);\\n        cv.wait(lk, [&]{return cur_step == step;}); // keep waiting until cur_step == step.\\n        func();\\n        cur_step++; // safely increasing cur_step.\\n        cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        run_step(0, printFirst);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        run_step(1, printSecond);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        run_step(2, printThird);\\n    }\\n\\nprivate:\\n    std::condition_variable cv;\\n    std::mutex mtx;\\n    volatile int cur_step;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467281,
                "title": "python-condition-readable-code",
                "content": "```\\nfrom threading import Condition\\nclass FooBar:\\n    def __init__(self, n):\\n        self.n = n\\n        self.condition = Condition()\\n        self.order = 1\\n        self.output_foo = lambda: self.order == 1\\n        self.output_bar = lambda: self.order == 2\\n\\n\\n    def foo(self, printFoo: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_foo)\\n                # printFoo() outputs \"foo\". Do not change or remove this line.\\n                printFoo()\\n                self.order += 1\\n                self.condition.notify()\\n\\n\\n    def bar(self, printBar: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_bar)\\n                # printBar() outputs \"bar\". Do not change or remove this line.\\n                printBar()\\n                self.order -= 1\\n                self.condition.notify()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Condition\\nclass FooBar:\\n    def __init__(self, n):\\n        self.n = n\\n        self.condition = Condition()\\n        self.order = 1\\n        self.output_foo = lambda: self.order == 1\\n        self.output_bar = lambda: self.order == 2\\n\\n\\n    def foo(self, printFoo: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_foo)\\n                # printFoo() outputs \"foo\". Do not change or remove this line.\\n                printFoo()\\n                self.order += 1\\n                self.condition.notify()\\n\\n\\n    def bar(self, printBar: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_bar)\\n                # printBar() outputs \"bar\". Do not change or remove this line.\\n                printBar()\\n                self.order -= 1\\n                self.condition.notify()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459232,
                "title": "java-simple-version-with-two-semaphores",
                "content": "```\\nclass Foo {\\n    \\n    private Semaphore firstSem;\\n    \\n    private Semaphore secondSem;\\n\\n    public Foo() {\\n        this.firstSem = new Semaphore(0);\\n        this.secondSem = new Semaphore(0); \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.firstSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        this.firstSem.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.secondSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        this.secondSem.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private Semaphore firstSem;\\n    \\n    private Semaphore secondSem;\\n\\n    public Foo() {\\n        this.firstSem = new Semaphore(0);\\n        this.secondSem = new Semaphore(0); \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.firstSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        this.firstSem.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.secondSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        this.secondSem.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457292,
                "title": "python-without-mutex-and-semaphore-only-1-counter",
                "content": "All threads are independent! We can create counter, which will show actual threads. It\\'s safe, therefore all threads modified counter only after printing + GIL makes operaion += atomary.\\n\\n```\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        self.counter = 0\\n\\n\\t# first thread will be called automaticly, without any conditions\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        \\n\\t\\t# open way for second thread\\n        self.counter += 1\\n\\n\\n\\t# second thread firstly wait finishing of 1st thread, and after printing text it can incriment counter for 3rd thread\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 1:\\n            sleep(0.01)\\n            \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        \\n        self.counter += 1\\n\\n\\n\\t# 3rd thread wait finish of 2nd, and doesn\\'t incerement counter, therefore it\\'s redundent.\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 2:\\n            sleep(0.01)\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        self.counter = 0\\n\\n\\t# first thread will be called automaticly, without any conditions\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        \\n\\t\\t# open way for second thread\\n        self.counter += 1\\n\\n\\n\\t# second thread firstly wait finishing of 1st thread, and after printing text it can incriment counter for 3rd thread\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 1:\\n            sleep(0.01)\\n            \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        \\n        self.counter += 1\\n\\n\\n\\t# 3rd thread wait finish of 2nd, and doesn\\'t incerement counter, therefore it\\'s redundent.\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 2:\\n            sleep(0.01)\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452975,
                "title": "simple-python-with-two-events",
                "content": "```\\nimport threading\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.second_cv = threading.Event() \\n        self.third_cv = threading.Event()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.second_cv.set()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.second_cv.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.third_cv.set()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.third_cv.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.second_cv = threading.Event() \\n        self.third_cv = threading.Event()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.second_cv.set()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.second_cv.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.third_cv.set()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.third_cv.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452783,
                "title": "2-c-solution-lock-2-mutex-lock-free-sched-yield",
                "content": "***Lock version - 2 mutex lock***\\nmtx1 is the lock indicating **first()** should be exec before **second()**.\\nmtx2 is the lock indicating **second()** should be exec before **third()**.\\n\\nUse **sched_yield()** to release the processor, when **second()** and **third()** does not have the lock.\\n**usleep(0)** would have the same effect, but it would be a little bit slower than **sched_yield()**.\\n```\\nclass Foo {\\n    mutex mtx1, mtx2;\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        mtx1.lock();\\n\\t\\t\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n        mtx1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        mtx2.lock();\\n        \\n        // try until runSecond set to true\\n        mtx1.lock();\\n        while (!runSecond) {\\n            mtx1.unlock();\\n            sched_yield();\\n            mtx1.lock();\\n        }\\n        mtx1.unlock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n        mtx2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        mtx2.lock();\\n        while (!runThird) {\\n            mtx2.unlock();\\n            sched_yield();\\n            mtx2.lock();\\n        }\\n        mtx2.unlock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n***Lock-free version***\\nWithout using lock, I thought it would be faster than previous version at first, but it seems not.\\nI\\'m still wondering why...\\n```\\nclass Foo {\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // try until runSecond set to true\\n        while (!runSecond) {\\n            sched_yield();\\n        }\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        while (!runThird) {\\n            sched_yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    mutex mtx1, mtx2;\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        mtx1.lock();\\n\\t\\t\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n        mtx1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        mtx2.lock();\\n        \\n        // try until runSecond set to true\\n        mtx1.lock();\\n        while (!runSecond) {\\n            mtx1.unlock();\\n            sched_yield();\\n            mtx1.lock();\\n        }\\n        mtx1.unlock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n        mtx2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        mtx2.lock();\\n        while (!runThird) {\\n            mtx2.unlock();\\n            sched_yield();\\n            mtx2.lock();\\n        }\\n        mtx2.unlock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // try until runSecond set to true\\n        while (!runSecond) {\\n            sched_yield();\\n        }\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        while (!runThird) {\\n            sched_yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432171,
                "title": "c-super-simple-solution-with-only-mutex",
                "content": "```\\n#include <mutex>\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        this->mtx_second.lock();\\n        this->mtx_third.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        this->mtx_second.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // std::cout << \"first: waiting...\" << std::endl;\\n        \\n        this->mtx_second.lock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        this->mtx_second.unlock();\\n        this->mtx_third.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        this->mtx_third.lock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        this->mtx_third.unlock();\\n    }\\n    \\nprivate:\\n    std::mutex mtx_second;\\n    std::mutex mtx_third;\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <mutex>\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        this->mtx_second.lock();\\n        this->mtx_third.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        this->mtx_second.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // std::cout << \"first: waiting...\" << std::endl;\\n        \\n        this->mtx_second.lock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        this->mtx_second.unlock();\\n        this->mtx_third.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        this->mtx_third.lock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        this->mtx_third.unlock();\\n    }\\n    \\nprivate:\\n    std::mutex mtx_second;\\n    std::mutex mtx_third;\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 431477,
                "title": "java-using-semaphores-runtime-10-ms-memory-usage-35-6-mb",
                "content": "class Foo {\\n    \\n    private final Semaphore bSem = new Semaphore(1);\\n    private final Semaphore cSem = new Semaphore(1);\\n\\n    public Foo() {\\n        bSem.drainPermits();\\n        cSem.drainPermits();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        bSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        bSem.acquire();\\n        printSecond.run();\\n        cSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        cSem.acquire();\\n        printThird.run();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Foo {\\n    \\n    private final Semaphore bSem = new Semaphore(1);\\n    private final Semaphore cSem = new Semaphore(1);\\n\\n    public Foo() {\\n        bSem.drainPermits();\\n        cSem.drainPermits();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        bSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        bSem.acquire();\\n        printSecond.run();\\n        cSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        cSem.acquire();\\n        printThird.run();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 413239,
                "title": "python-threading-event-implementation",
                "content": "```\\nimport threading\\nclass Foo:\\n    def __init__(self):\\n        self.ev1 = threading.Event()\\n        self.ev2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None: \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.ev1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:      \\n        self.ev1.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.ev2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:      \\n        self.ev2.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\nclass Foo:\\n    def __init__(self):\\n        self.ev1 = threading.Event()\\n        self.ev2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None: \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.ev1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:      \\n        self.ev1.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.ev2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:      \\n        self.ev2.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404181,
                "title": "java-very-simple-and-straight-solution-based-on-semaphore",
                "content": "```\\nclass Foo {\\n\\n    Semaphore s1= new Semaphore(1);\\n    Semaphore s2= new Semaphore(0);\\n    Semaphore s3= new Semaphore(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        s1.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    Semaphore s1= new Semaphore(1);\\n    Semaphore s2= new Semaphore(0);\\n    Semaphore s3= new Semaphore(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        s1.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393279,
                "title": "without-lock-related-function-simple-c-solution",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        a[0] = a[1] = 0;\\n    }\\n    \\n    int a[2];\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a[0] = 1;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(a[0] == 0);\\n        printSecond();\\n        a[1] = 1;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(a[1] == 0);\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        a[0] = a[1] = 0;\\n    }\\n    \\n    int a[2];\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a[0] = 1;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(a[0] == 0);\\n        printSecond();\\n        a[1] = 1;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(a[1] == 0);\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378965,
                "title": "java-solution-using-blockingqueue",
                "content": "- Second always runs after first because blockingQueue1.take() waits for blockingQueue1.add(\"done\");\\n- Third always runs after second using the same machenism with blockingQueue2.\\n\\n\\nimport java.util.concurrent.BlockingQueue;\\nimport java.util.concurrent.LinkedBlockingDeque;\\nclass Foo {\\n\\n    BlockingQueue<String> blockingQueue1 = new LinkedBlockingDeque<>(1);\\n    BlockingQueue<String> blockingQueue2 = new LinkedBlockingDeque<>(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        \\n        printFirst.run();\\n        blockingQueue1.add(\"done\");\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        String done = blockingQueue1.take();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        blockingQueue2.add(\"done\");\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        String done = blockingQueue2.take();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "- Second always runs after first because blockingQueue1.take() waits for blockingQueue1.add(\"done\");\\n- Third always runs after second using the same machenism with blockingQueue2.\\n\\n\\nimport java.util.concurrent.BlockingQueue;\\nimport java.util.concurrent.LinkedBlockingDeque;\\nclass Foo {\\n\\n    BlockingQueue<String> blockingQueue1 = new LinkedBlockingDeque<>(1);\\n    BlockingQueue<String> blockingQueue2 = new LinkedBlockingDeque<>(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        \\n        printFirst.run();\\n        blockingQueue1.add(\"done\");\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        String done = blockingQueue1.take();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        blockingQueue2.add(\"done\");\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        String done = blockingQueue2.take();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        \\n    }\\n}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565694,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565769,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568225,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566312,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569719,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568188,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1703405,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569562,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1806869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565694,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565769,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568225,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566312,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569719,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568188,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1703405,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569562,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1806869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Cost to Connect Two Groups of Points",
        "question_content": "<p>You are given two groups of points where the first group has <code>size<sub>1</sub></code> points, the second group has <code>size<sub>2</sub></code> points, and <code>size<sub>1</sub> &gt;= size<sub>2</sub></code>.</p>\n\n<p>The <code>cost</code> of the connection between any two points are given in an <code>size<sub>1</sub> x size<sub>2</sub></code> matrix where <code>cost[i][j]</code> is the cost of connecting point <code>i</code> of the first group and point <code>j</code> of the second group. The groups are connected if <strong>each point in both groups is connected to one or more points in the opposite group</strong>. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.</p>\n\n<p>Return <em>the minimum cost it takes to connect the two groups</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/ex1.jpg\" style=\"width: 322px; height: 243px;\" />\n<pre>\n<strong>Input:</strong> cost = [[15, 96], [36, 2]]\n<strong>Output:</strong> 17\n<strong>Explanation</strong>: The optimal way of connecting the groups is:\n1--A\n2--B\nThis results in a total cost of 17.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/ex2.jpg\" style=\"width: 322px; height: 403px;\" />\n<pre>\n<strong>Input:</strong> cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n<strong>Output:</strong> 4\n<strong>Explanation</strong>: The optimal way of connecting the groups is:\n1--A\n2--B\n2--C\n3--A\nThis results in a total cost of 4.\nNote that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n<strong>Output:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>size<sub>1</sub> == cost.length</code></li>\n\t<li><code>size<sub>2</sub> == cost[i].length</code></li>\n\t<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>\n\t<li><code>size<sub>1</sub> &gt;= size<sub>2</sub></code></li>\n\t<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 855041,
                "title": "c-python-dp-using-mask",
                "content": "#### Intuition\\nAs usual, it pays to analyze problem constraints. Since we only have up to 12 points, we can track which ones are connected using a bit mask.\\n\\n#### Solution\\nStaightforward top-down DP for the first group. At the same time, we track which elements from the second group were connected in `mask`.\\n\\nAfter finishing with the first group, we detect elements in group 2 that are still disconnected, and connect them with the \"cheapest\" node in the first group.\\n\\n**Python**\\n```python\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n    sz1, sz2 = len(cost), len(cost[0])\\n    min_sz2 = [min([cost[i][j] for i in range(sz1)]) for j in range(sz2)]\\n    @lru_cache(None)\\n    def dfs(i: int, mask: int):\\n        res = 0 if i >= sz1 else float(\\'inf\\')\\n        if i >= sz1:\\n            for j in range(sz2):\\n                if mask & (1 << j) == 0:\\n                    res += min_sz2[j]\\n        else:\\n            for j in range(sz2):\\n                res = min(res, cost[i][j] + dfs(i + 1, mask | (1 << j)))\\n        return res\\n    return dfs(0, 0)\\n```\\n**C++**\\n```cpp\\nint dp[13][4096] = {};\\nint dfs(vector<vector<int>>& cost, vector<int> &min_sz2, int i, int mask) {\\n    if (dp[i][mask])\\n        return dp[i][mask] - 1;    \\n    int res = i >= cost.size() ? 0 : INT_MAX;\\n    if (i >= cost.size())\\n        for (auto j = 0; j < cost[0].size(); ++j)\\n            res += min_sz2[j] * ((mask & (1 << j)) == 0);\\n    else\\n        for (auto j = 0; j < cost[0].size(); ++j)\\n            res = min(res, cost[i][j] + dfs(cost, min_sz2, i + 1, mask | (1 << j)));\\n    dp[i][mask] = res + 1;\\n    return res;\\n}\\nint connectTwoGroups(vector<vector<int>>& cost) {\\n    vector<int> min_sz2(cost[0].size(), INT_MAX);\\n    for (int j = 0; j < min_sz2.size(); ++j)\\n        for (int i = 0; i < cost.size(); ++i)\\n            min_sz2[j] = min(min_sz2[j], cost[i][j]);\\n    return dfs(cost, min_sz2, 0, 0);\\n}\\n```\\n**Complexity Analysis**\\n- Time:  O((n * 2 ^ m) * m) - it takes `m` to compute one state.\\n- Memory: O(n * 2 ^ m) states to compute",
                "solutionTags": [],
                "code": "```python\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n    sz1, sz2 = len(cost), len(cost[0])\\n    min_sz2 = [min([cost[i][j] for i in range(sz1)]) for j in range(sz2)]\\n    @lru_cache(None)\\n    def dfs(i: int, mask: int):\\n        res = 0 if i >= sz1 else float(\\'inf\\')\\n        if i >= sz1:\\n            for j in range(sz2):\\n                if mask & (1 << j) == 0:\\n                    res += min_sz2[j]\\n        else:\\n            for j in range(sz2):\\n                res = min(res, cost[i][j] + dfs(i + 1, mask | (1 << j)))\\n        return res\\n    return dfs(0, 0)\\n```\n```cpp\\nint dp[13][4096] = {};\\nint dfs(vector<vector<int>>& cost, vector<int> &min_sz2, int i, int mask) {\\n    if (dp[i][mask])\\n        return dp[i][mask] - 1;    \\n    int res = i >= cost.size() ? 0 : INT_MAX;\\n    if (i >= cost.size())\\n        for (auto j = 0; j < cost[0].size(); ++j)\\n            res += min_sz2[j] * ((mask & (1 << j)) == 0);\\n    else\\n        for (auto j = 0; j < cost[0].size(); ++j)\\n            res = min(res, cost[i][j] + dfs(cost, min_sz2, i + 1, mask | (1 << j)));\\n    dp[i][mask] = res + 1;\\n    return res;\\n}\\nint connectTwoGroups(vector<vector<int>>& cost) {\\n    vector<int> min_sz2(cost[0].size(), INT_MAX);\\n    for (int j = 0; j < min_sz2.size(); ++j)\\n        for (int i = 0; i < cost.size(); ++i)\\n            min_sz2[j] = min(min_sz2[j], cost[i][j]);\\n    return dfs(cost, min_sz2, 0, 0);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 855686,
                "title": "c-4ms-beats-100-bipartite-graph-maximum-weight-matching",
                "content": "I just found most people solve this problem via bit mask DP, which runs in *expoential* time. Here, I give a *polynomial* time solution.\\n\\n**Explanation**:\\nThis problem is called *minimum-cost edge cover* for bipartite graph. We show how to reduce this to a matching problem.\\nWe note that some edge will cover both of endpoints, and some edge will only cover of their endpoints. If the edge only covers one of their endpoints, then this edge must be the edge with minimum weight incident to that particular endpoint. Let c_v be the cost of the minimum weight edge incident to vertex v, and w_(u,v) be the weight of edge (u,v), then the cost of a solution is \\n![image](https://assets.leetcode.com/users/images/e04f65c8-0d40-4262-81ce-3ff85efd75e9_1600669162.3114378.png)\\n\\n\\nWe note that the first sum is fixed, and the second we want maximum the second sum. Hence, the problem becomes find a maximum weight matching with edge weight c_v+c_u-w_(u,v). Using Hungarian algorithm, we can find such matching for bipartite graph in O(n^3).\\n\\n**Implementation**:\\n```\\nclass Solution {\\npublic:\\n   #define getL(x) (x+2)\\n   #define getR(x) (2+Lmin.size()+x) \\n\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        vector<int> Lmin(cost.size());\\n        vector<int> Rmin(cost[0].size());\\n        int ans = 0;\\n        for(int i = 0; i < cost.size();++i) {\\n            Lmin[i] = INT_MAX;\\n            for(int j = 0; j < Rmin.size(); ++j) {\\n                Lmin[i] = min(Lmin[i], cost[i][j]);\\n            }\\n            ans += Lmin[i];\\n        }\\n        for(int j = 0; j < Rmin.size();++j) {\\n            Rmin[j] = INT_MAX;\\n            for(int i = 0; i < Lmin.size(); ++i) {\\n                Rmin[j] = min(Rmin[j],cost[i][j]);\\n            }\\n            ans += Rmin[j];\\n        }\\n        hungarian<int> H(Lmin.size(),Rmin.size());\\n        for(int i = 0; i < Lmin.size(); ++i) {\\n            for(int j = 0; j < Rmin.size(); ++j) {\\n                H.addEdge(i,j,-1*(cost[i][j]-Lmin[i]-Rmin[j]));\\n            }\\n        }\\n        int ret = H.solve();\\n        ans = ans - ret;\\n        return ans;\\n    }\\n};\\n```\\n\\nTemplate for Hungarian Algorithm (Kuhn\\u2013Munkres algorithm):\\n```\\ntemplate <typename T>\\nstruct hungarian\\n{ // km\\n    int n;\\n    vector<int> matchx;\\n    vector<int> matchy;\\n    vector<int> pre;\\n    vector<bool> visx;\\n    vector<bool> visy;\\n    vector<T> lx;\\n    vector<T> ly;\\n    vector<vector<T>> g;\\n    vector<T> slack;\\n    T inf;\\n    T res;\\n    queue<int> q;\\n    int org_n;\\n    int org_m;\\n\\n    hungarian(int _n, int _m)\\n    {\\n        org_n = _n;\\n        org_m = _m;\\n        n = max(_n, _m);\\n        inf = numeric_limits<T>::max();\\n        res = 0;\\n        g = vector<vector<T>>(n, vector<T>(n));\\n        matchx = vector<int>(n, -1);\\n        matchy = vector<int>(n, -1);\\n        pre = vector<int>(n);\\n        visx = vector<bool>(n);\\n        visy = vector<bool>(n);\\n        lx = vector<T>(n, -inf);\\n        ly = vector<T>(n);\\n        slack = vector<T>(n);\\n    }\\n\\n    void addEdge(int u, int v, int w)\\n    {\\n        g[u][v] = max(w, 0); \\n    }\\n\\n    bool check(int v)\\n    {\\n        visy[v] = true;\\n        if (matchy[v] != -1)\\n        {\\n            q.push(matchy[v]);\\n            visx[matchy[v]] = true;\\n            return false;\\n        }\\n        while (v != -1)\\n        {\\n            matchy[v] = pre[v];\\n            swap(v, matchx[pre[v]]);\\n        }\\n        return true;\\n    }\\n\\n    void bfs(int i)\\n    {\\n        while (!q.empty())\\n        {\\n            q.pop();\\n        }\\n        q.push(i);\\n        visx[i] = true;\\n        while (true)\\n        {\\n            while (!q.empty())\\n            {\\n                int u = q.front();\\n                q.pop();\\n                for (int v = 0; v < n; v++)\\n                {\\n                    if (!visy[v])\\n                    {\\n                        T delta = lx[u] + ly[v] - g[u][v];\\n                        if (slack[v] >= delta)\\n                        {\\n                            pre[v] = u;\\n                            if (delta)\\n                            {\\n                                slack[v] = delta;\\n                            }\\n                            else if (check(v))\\n                            {\\n                                return;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            T a = inf;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (!visy[j])\\n                {\\n                    a = min(a, slack[j]);\\n                }\\n            }\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (visx[j])\\n                { // S\\n                    lx[j] -= a;\\n                }\\n                if (visy[j])\\n                { // T\\n                    ly[j] += a;\\n                }\\n                else\\n                { // T\\'\\n                    slack[j] -= a;\\n                }\\n            }\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (!visy[j] && slack[j] == 0 && check(j))\\n                {\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    int solve()\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                lx[i] = max(lx[i], g[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            fill(slack.begin(), slack.end(), inf);\\n            fill(visx.begin(), visx.end(), false);\\n            fill(visy.begin(), visy.end(), false);\\n            bfs(i);\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (g[i][matchx[i]] > 0)\\n            {\\n                res += g[i][matchx[i]];\\n            }\\n            else\\n            {\\n                matchx[i] = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   #define getL(x) (x+2)\\n   #define getR(x) (2+Lmin.size()+x) \\n\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        vector<int> Lmin(cost.size());\\n        vector<int> Rmin(cost[0].size());\\n        int ans = 0;\\n        for(int i = 0; i < cost.size();++i) {\\n            Lmin[i] = INT_MAX;\\n            for(int j = 0; j < Rmin.size(); ++j) {\\n                Lmin[i] = min(Lmin[i], cost[i][j]);\\n            }\\n            ans += Lmin[i];\\n        }\\n        for(int j = 0; j < Rmin.size();++j) {\\n            Rmin[j] = INT_MAX;\\n            for(int i = 0; i < Lmin.size(); ++i) {\\n                Rmin[j] = min(Rmin[j],cost[i][j]);\\n            }\\n            ans += Rmin[j];\\n        }\\n        hungarian<int> H(Lmin.size(),Rmin.size());\\n        for(int i = 0; i < Lmin.size(); ++i) {\\n            for(int j = 0; j < Rmin.size(); ++j) {\\n                H.addEdge(i,j,-1*(cost[i][j]-Lmin[i]-Rmin[j]));\\n            }\\n        }\\n        int ret = H.solve();\\n        ans = ans - ret;\\n        return ans;\\n    }\\n};\\n```\n```\\ntemplate <typename T>\\nstruct hungarian\\n{ // km\\n    int n;\\n    vector<int> matchx;\\n    vector<int> matchy;\\n    vector<int> pre;\\n    vector<bool> visx;\\n    vector<bool> visy;\\n    vector<T> lx;\\n    vector<T> ly;\\n    vector<vector<T>> g;\\n    vector<T> slack;\\n    T inf;\\n    T res;\\n    queue<int> q;\\n    int org_n;\\n    int org_m;\\n\\n    hungarian(int _n, int _m)\\n    {\\n        org_n = _n;\\n        org_m = _m;\\n        n = max(_n, _m);\\n        inf = numeric_limits<T>::max();\\n        res = 0;\\n        g = vector<vector<T>>(n, vector<T>(n));\\n        matchx = vector<int>(n, -1);\\n        matchy = vector<int>(n, -1);\\n        pre = vector<int>(n);\\n        visx = vector<bool>(n);\\n        visy = vector<bool>(n);\\n        lx = vector<T>(n, -inf);\\n        ly = vector<T>(n);\\n        slack = vector<T>(n);\\n    }\\n\\n    void addEdge(int u, int v, int w)\\n    {\\n        g[u][v] = max(w, 0); \\n    }\\n\\n    bool check(int v)\\n    {\\n        visy[v] = true;\\n        if (matchy[v] != -1)\\n        {\\n            q.push(matchy[v]);\\n            visx[matchy[v]] = true;\\n            return false;\\n        }\\n        while (v != -1)\\n        {\\n            matchy[v] = pre[v];\\n            swap(v, matchx[pre[v]]);\\n        }\\n        return true;\\n    }\\n\\n    void bfs(int i)\\n    {\\n        while (!q.empty())\\n        {\\n            q.pop();\\n        }\\n        q.push(i);\\n        visx[i] = true;\\n        while (true)\\n        {\\n            while (!q.empty())\\n            {\\n                int u = q.front();\\n                q.pop();\\n                for (int v = 0; v < n; v++)\\n                {\\n                    if (!visy[v])\\n                    {\\n                        T delta = lx[u] + ly[v] - g[u][v];\\n                        if (slack[v] >= delta)\\n                        {\\n                            pre[v] = u;\\n                            if (delta)\\n                            {\\n                                slack[v] = delta;\\n                            }\\n                            else if (check(v))\\n                            {\\n                                return;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            T a = inf;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (!visy[j])\\n                {\\n                    a = min(a, slack[j]);\\n                }\\n            }\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (visx[j])\\n                { // S\\n                    lx[j] -= a;\\n                }\\n                if (visy[j])\\n                { // T\\n                    ly[j] += a;\\n                }\\n                else\\n                { // T\\'\\n                    slack[j] -= a;\\n                }\\n            }\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (!visy[j] && slack[j] == 0 && check(j))\\n                {\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    int solve()\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                lx[i] = max(lx[i], g[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            fill(slack.begin(), slack.end(), inf);\\n            fill(visx.begin(), visx.end(), false);\\n            fill(visy.begin(), visy.end(), false);\\n            bfs(i);\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (g[i][matchx[i]] > 0)\\n            {\\n                res += g[i][matchx[i]];\\n            }\\n            else\\n            {\\n                matchx[i] = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855188,
                "title": "python-clean-dp-bitmask-solution-with-explaination",
                "content": "**Idea**\\n\\nThere are basically two steps:\\n1. Connect all group1 nodes to group2. Each group1 node only sends out 1 edge.\\n2. For all the unconnected nodes in group2, connect them with their min-cost counterparty in group1.\\n\\nWe use DP + Bitmask to achieve this. The step 1 above is the DP transition step and the step 2 above is the DP base case.\\n\\n<br />\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        min_arr = [min(x) for x in zip(*cost)]\\n        \\n        @lru_cache(None)\\n        def dp(i, mask):\\n            if i == m:\\n                ans = 0\\n                for j in range(n):\\n                    if not mask & (1 << j):\\n                        ans += min_arr[j]\\n                return ans\\n            \\n            ans = float(\\'inf\\')\\n            for j in range(n):\\n                ans = min(ans, cost[i][j] + dp(i + 1, mask | (1 << j)))\\n            return ans\\n        \\n        return dp(0, 0)\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        min_arr = [min(x) for x in zip(*cost)]\\n        \\n        @lru_cache(None)\\n        def dp(i, mask):\\n            if i == m:\\n                ans = 0\\n                for j in range(n):\\n                    if not mask & (1 << j):\\n                        ans += min_arr[j]\\n                return ans\\n            \\n            ans = float(\\'inf\\')\\n            for j in range(n):\\n                ans = min(ans, cost[i][j] + dp(i + 1, mask | (1 << j)))\\n            return ans\\n        \\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855425,
                "title": "java-bottom-up-dp-with-bit-mask",
                "content": "1, to make groups connect, we just need to make the cost[][] mattrix has 1 or more connection for each row and each column;\\n2, take a look at size1 and size2 both < 12, then we can use bit mask to memorize the intermidiate status, to avoid duplicate calculation.\\n3, Suppose cnt of Cols > cnt > rows. We count from the left most col, to the most right col, for each previous mask, we just try to add each of the new value in the new col to make new mask, and save the min cost to achieve mask to dp;\\n```\\n    public int connectTwoGroups(List<List<Integer>> cs) {\\n        int m = cs.size(), n = cs.get(0).size(), msk = 1 << m, dp[] = new int[msk];\\n        for (int i = 0; i < msk; i++) dp[i] = Integer.MAX_VALUE;\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            int[] tmp = new int[msk];\\n            for (int l = 0; l < msk; l++) tmp[l] = Integer.MAX_VALUE;\\n            // tmp[0] = 0; // you can not leave the previous lines without connections.\\n            for (int k = 0; k < msk; k++) {\\n                for (int j = 0; j < m; j++) {\\n                    int mask = k | (1 << j);\\n                    if (dp[k] != Integer.MAX_VALUE) tmp[mask] = Math.min(tmp[mask], dp[k] + cs.get(j).get(i));\\n                    if ((k & (1 << j)) == 0) {\\n                        if (tmp[k] != Integer.MAX_VALUE)  tmp[mask] = Math.min(tmp[mask], tmp[k] + cs.get(j).get(i));\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        return dp[msk - 1];\\n    }\\n```\\n\\nFor readers to be curious of looping orders, see @venkim\\'s [solution](https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/discuss/855425/Java-bottom-up-DP-with-bit-mask/704737) in comments.",
                "solutionTags": [],
                "code": "```\\n    public int connectTwoGroups(List<List<Integer>> cs) {\\n        int m = cs.size(), n = cs.get(0).size(), msk = 1 << m, dp[] = new int[msk];\\n        for (int i = 0; i < msk; i++) dp[i] = Integer.MAX_VALUE;\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            int[] tmp = new int[msk];\\n            for (int l = 0; l < msk; l++) tmp[l] = Integer.MAX_VALUE;\\n            // tmp[0] = 0; // you can not leave the previous lines without connections.\\n            for (int k = 0; k < msk; k++) {\\n                for (int j = 0; j < m; j++) {\\n                    int mask = k | (1 << j);\\n                    if (dp[k] != Integer.MAX_VALUE) tmp[mask] = Math.min(tmp[mask], dp[k] + cs.get(j).get(i));\\n                    if ((k & (1 << j)) == 0) {\\n                        if (tmp[k] != Integer.MAX_VALUE)  tmp[mask] = Math.min(tmp[mask], tmp[k] + cs.get(j).get(i));\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        return dp[msk - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855509,
                "title": "why-minimum-spanning-tree-algorithm-dosen-t-work-here",
                "content": "I tried using Kruskal\\u2019s Minimum Spanning Tree Algorithm\\n\\n```\\nstruct Connection{\\n    int source;\\n    int destination;\\n    int cost;\\n    Connection(int s,int d,int c){\\n        source=s;\\n        destination=d;\\n        cost = c;\\n    }\\n};\\n\\nstruct cmpConnection{\\n    bool operator()(Connection const& c1, Connection const& c2) \\n    { \\n        return c1.cost>c2.cost; \\n    } \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        priority_queue<Connection,vector<Connection>,cmpConnection> costHeap;\\n        for(int i=0;i<cost.size();i++){\\n            for(int j=0;j<cost[i].size();j++){\\n                Connection conn(i,j,cost[i][j]);\\n                costHeap.push(conn);\\n            }\\n        }\\n        vector<bool> visitedS(cost.size());\\n        vector<bool> visitedT(cost[0].size());\\n        fill(visitedS.begin(),visitedS.end(),false);\\n        fill(visitedT.begin(),visitedT.end(),false);\\n        int SLeft = visitedS.size();\\n        int TLeft = visitedT.size();\\n        \\n        int costIncur = 0;\\n        while(SLeft>0 || TLeft>0){ //Until all the nodes are visited\\n            \\n            Connection conn = costHeap.top();\\n            costHeap.pop();\\n            if(!visitedS[conn.source] || !visitedT[conn.destination]){\\n                //Mark visited and add in cost\\n                cout<<\"Adding in:\"<<conn.source+1<<\",\"<<conn.destination+1<<\",cost:\"<<conn.cost<<endl;\\n                if(!visitedS[conn.source])\\n                    SLeft--;\\n                if(!visitedT[conn.destination])\\n                    TLeft--;\\n                \\n                costIncur+=conn.cost;\\n                visitedS[conn.source]=true;\\n                visitedT[conn.destination]=true;\\n            }\\n        }\\n        \\n        \\n        return costIncur;\\n    }\\n};\\n```\\n\\nBut it failed on 3rd Sample Test Case:\\nInput: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\\nOutput: 10\\nMy Output: 12\\n\\nI am unable to get output of 10 by hand . can anyone explain why this dosen\\'t work?",
                "solutionTags": [],
                "code": "```\\nstruct Connection{\\n    int source;\\n    int destination;\\n    int cost;\\n    Connection(int s,int d,int c){\\n        source=s;\\n        destination=d;\\n        cost = c;\\n    }\\n};\\n\\nstruct cmpConnection{\\n    bool operator()(Connection const& c1, Connection const& c2) \\n    { \\n        return c1.cost>c2.cost; \\n    } \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        priority_queue<Connection,vector<Connection>,cmpConnection> costHeap;\\n        for(int i=0;i<cost.size();i++){\\n            for(int j=0;j<cost[i].size();j++){\\n                Connection conn(i,j,cost[i][j]);\\n                costHeap.push(conn);\\n            }\\n        }\\n        vector<bool> visitedS(cost.size());\\n        vector<bool> visitedT(cost[0].size());\\n        fill(visitedS.begin(),visitedS.end(),false);\\n        fill(visitedT.begin(),visitedT.end(),false);\\n        int SLeft = visitedS.size();\\n        int TLeft = visitedT.size();\\n        \\n        int costIncur = 0;\\n        while(SLeft>0 || TLeft>0){ //Until all the nodes are visited\\n            \\n            Connection conn = costHeap.top();\\n            costHeap.pop();\\n            if(!visitedS[conn.source] || !visitedT[conn.destination]){\\n                //Mark visited and add in cost\\n                cout<<\"Adding in:\"<<conn.source+1<<\",\"<<conn.destination+1<<\",cost:\"<<conn.cost<<endl;\\n                if(!visitedS[conn.source])\\n                    SLeft--;\\n                if(!visitedT[conn.destination])\\n                    TLeft--;\\n                \\n                costIncur+=conn.cost;\\n                visitedS[conn.source]=true;\\n                visitedT[conn.destination]=true;\\n            }\\n        }\\n        \\n        \\n        return costIncur;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 855035,
                "title": "c-dp-bit-manipulation-solution-with-detailed-explanation",
                "content": "### C++ DP + bit manipulation solution with detailed explanation\\n\\nSince `size1 >= size2`, We can iterater through all `index1` (count: `O(size1)`) in the first group and use `state2`(count: `O(2 ^ size2)`) to represent whether an element in the second group is selected.\\n\\nOne Optimization: We can pre-calculate the cost for `index1` in the first group, and it select `the combination of elements in the second group` (represented in binary bit).\\n\\nThis is a solution, however it got `TLE`, we will try to optimize it.\\n\\n```cpp\\nint f[14][4100];\\nint pre[14][4100];\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        this->c = cost;\\n        this->n = cost.size(), this->m = cost[0].size();\\n        this->m1 = (1 << n) - 1, this->m2 = (1 << m) - 1;\\n        \\n        memset(pre, 0, sizeof pre);\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i <= m2; i++) {\\n                int cur = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (i & (1 << j)) cur += cost[k][j];\\n                }\\n                pre[k][i] = cur;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= m2; j++) {\\n                f[i][j] = -1;\\n            }\\n        }\\n        return dfs(0, 0);\\n    }\\nprivate:\\n    vector<vector<int>> c;\\n    \\n    int n, m;\\n    int m1, m2;\\n    int dfs(int a, int state2) {\\n        if (a == n) {\\n            if (state2 == m2) return 0;\\n            else return 9999999;\\n        }\\n        int& val = f[a][state2];\\n        if (val != -1) return val;\\n        \\n        int ans = 9999999;\\n        for (int i = 1; i <= m2; i++) {\\n            int curcost = pre[a][i];\\n            ans = min(ans, curcost + dfs(a + 1, state2 | i));\\n        }\\n        return val = ans;\\n    }\\n};\\n```\\n\\nWe can rethink this problem.\\n\\nOne observation: \\n\\n1. If an element in the first group select a used element in the second group, it can only select one, otherwise, the cost is not minium\\n\\n2. Otherwise, the element in the first group should select a subset of the complement set of the state2\\n\\nWe can apply this observation into codes and pass all the test cases.\\n\\n```cpp\\nint f[14][4100];\\nint pre[14][4100];\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        this->c = cost;\\n        this->n = cost.size(), this->m = cost[0].size();\\n        this->m1 = (1 << n) - 1, this->m2 = (1 << m) - 1;\\n        \\n        memset(pre, 0, sizeof pre);\\n        memset(f, 0xff, sizeof f);\\n        \\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i <= m2; i++) {\\n                int cur = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (i & (1 << j)) cur += cost[k][j];\\n                }\\n                pre[k][i] = cur;\\n            }\\n        }\\n        \\n        return dfs(0, 0);\\n    }\\nprivate:\\n    vector<vector<int>> c;\\n    \\n    int n, m;\\n    int m1, m2;\\n    int dfs(int a, int state2) {\\n        if (a == n) {\\n            if (state2 == m2) return 0;\\n            else return 9999999;\\n        }\\n        int& val = f[a][state2];\\n        if (val != -1) return val;\\n        \\n        int ans = 9999999;\\n        for (int i = 0; i < m; i++) {\\n            if (state2 & (1 << i)) ans = min(ans, pre[a][1 << i] + dfs(a + 1, state2));\\n        }\\n        \\n        const int sub = (~state2) & m2;\\n        for (int i = sub; i > 0; i = (i - 1) & sub) {\\n            ans = min(ans, pre[a][i] + dfs(a + 1, state2 | i));\\n        }\\n        \\n        return val = ans;\\n    }\\n    \\n    int lowbit(int x) {\\n        return x&(-x);\\n    }\\n};\\n```\\n\\n\\nSpace complexity: `O(N * 2^N)`\\n\\nTime complexity: `O(N * 2^N * 2^N)`, however, by applying the second optimization, the upper bound of the time complexity of my solution is not very tight",
                "solutionTags": [],
                "code": "```cpp\\nint f[14][4100];\\nint pre[14][4100];\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        this->c = cost;\\n        this->n = cost.size(), this->m = cost[0].size();\\n        this->m1 = (1 << n) - 1, this->m2 = (1 << m) - 1;\\n        \\n        memset(pre, 0, sizeof pre);\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i <= m2; i++) {\\n                int cur = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (i & (1 << j)) cur += cost[k][j];\\n                }\\n                pre[k][i] = cur;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= m2; j++) {\\n                f[i][j] = -1;\\n            }\\n        }\\n        return dfs(0, 0);\\n    }\\nprivate:\\n    vector<vector<int>> c;\\n    \\n    int n, m;\\n    int m1, m2;\\n    int dfs(int a, int state2) {\\n        if (a == n) {\\n            if (state2 == m2) return 0;\\n            else return 9999999;\\n        }\\n        int& val = f[a][state2];\\n        if (val != -1) return val;\\n        \\n        int ans = 9999999;\\n        for (int i = 1; i <= m2; i++) {\\n            int curcost = pre[a][i];\\n            ans = min(ans, curcost + dfs(a + 1, state2 | i));\\n        }\\n        return val = ans;\\n    }\\n};\\n```\n```cpp\\nint f[14][4100];\\nint pre[14][4100];\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        this->c = cost;\\n        this->n = cost.size(), this->m = cost[0].size();\\n        this->m1 = (1 << n) - 1, this->m2 = (1 << m) - 1;\\n        \\n        memset(pre, 0, sizeof pre);\\n        memset(f, 0xff, sizeof f);\\n        \\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i <= m2; i++) {\\n                int cur = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (i & (1 << j)) cur += cost[k][j];\\n                }\\n                pre[k][i] = cur;\\n            }\\n        }\\n        \\n        return dfs(0, 0);\\n    }\\nprivate:\\n    vector<vector<int>> c;\\n    \\n    int n, m;\\n    int m1, m2;\\n    int dfs(int a, int state2) {\\n        if (a == n) {\\n            if (state2 == m2) return 0;\\n            else return 9999999;\\n        }\\n        int& val = f[a][state2];\\n        if (val != -1) return val;\\n        \\n        int ans = 9999999;\\n        for (int i = 0; i < m; i++) {\\n            if (state2 & (1 << i)) ans = min(ans, pre[a][1 << i] + dfs(a + 1, state2));\\n        }\\n        \\n        const int sub = (~state2) & m2;\\n        for (int i = sub; i > 0; i = (i - 1) & sub) {\\n            ans = min(ans, pre[a][i] + dfs(a + 1, state2 | i));\\n        }\\n        \\n        return val = ans;\\n    }\\n    \\n    int lowbit(int x) {\\n        return x&(-x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860779,
                "title": "c-dp-with-bitmasking",
                "content": "Thinking of a recursive solution :  lets say we are on the point i from the first set then we can pair it with any other point of the second set and mark that point as visited and recursively do the same untill all the points from the first set are exhausted. Lets say at the end we have some points from the second set that are not paired yet so how can we pair them? we can simply pair each point to that point is set 1 such that the corresponding cost is minimum. Now to improve the time complexity we can save our states i.e the index we are at and the mask (track of point visited in second set) in a dp table.\\nTIME REQUIRED : O(n * 2^m * m)\\n\\n```\\n    int we_can[13];\\n    int rec(int i,int mask,vector<vector<int> >&cost,vector<vector<int> >&dp){\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        if(i == cost.size()){\\n            int take = 0;\\n            for(int j=0;j<m;j++){\\n                if((mask & (1 << j)) == 0){\\n                    take += we_can[j];\\n                \\n                }\\n            }\\n            \\n            return take;\\n        }\\n        if(dp[i][mask] != -1){\\n            return dp[i][mask];\\n        }\\n        int ans = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            ans = min(ans,cost[i][j] + rec(i+1,mask | (1 << j),cost,dp));\\n        }\\n        dp[i][mask] = ans;\\n        return ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        int n = cost.size();\\n        int m = cost[0].size();\\n        for(int j=0;j<m;j++){\\n            we_can[j] = 500;\\n        }\\n        vector<vector<int> >dp(n,vector<int>((1 << m)+1,-1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n              //  cout << cost[i][j] << endl;\\n                we_can[j] = min(we_can[j],cost[i][j]);\\n            }\\n        }\\n        return rec(0,0,cost,dp);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int we_can[13];\\n    int rec(int i,int mask,vector<vector<int> >&cost,vector<vector<int> >&dp){\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        if(i == cost.size()){\\n            int take = 0;\\n            for(int j=0;j<m;j++){\\n                if((mask & (1 << j)) == 0){\\n                    take += we_can[j];\\n                \\n                }\\n            }\\n            \\n            return take;\\n        }\\n        if(dp[i][mask] != -1){\\n            return dp[i][mask];\\n        }\\n        int ans = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            ans = min(ans,cost[i][j] + rec(i+1,mask | (1 << j),cost,dp));\\n        }\\n        dp[i][mask] = ans;\\n        return ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        int n = cost.size();\\n        int m = cost[0].size();\\n        for(int j=0;j<m;j++){\\n            we_can[j] = 500;\\n        }\\n        vector<vector<int> >dp(n,vector<int>((1 << m)+1,-1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n              //  cout << cost[i][j] << endl;\\n                we_can[j] = min(we_can[j],cost[i][j]);\\n            }\\n        }\\n        return rec(0,0,cost,dp);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 855352,
                "title": "the-idea-is-brute-force-dfs",
                "content": "**Explanation:**\\n\\nI got stuck while thinking it hard, my mind leads me to Heap or Floyd-Warshall Algorithm. However, this problem is actually solved by brute force DFS(). \\n\\nSince the left-group always longer than right-group, we keep a dp of right-group, just remember the closest distance for each point in right-group. \\n\\nBrute force dfs() with left-group, each time increment left-count for 1, for each round, just try all the point in right-group, with the help of bit-mask, we will know each point in right-group being connected or not(if not, in the end, we needs to connect them!). \\n\\nDon\\'t forgot to use a lru_cache, it works like a advanced memory for avoiding repeat.\\n\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m, dp = len(cost), len(cost[0]), {}\\n        for j in range(m): dp[j] = min(cost[i][j] for i in range(n)) \\n\\n        @lru_cache(maxsize = None)\\n        def dfs(left, right):\\n            if left == n: return sum(dp[j] for j in range(m) if right & 1<<j == 0)\\n            return min(cost[left][j] + dfs(left+1, right | 1<<j) for j in range(m))\\n\\n        return dfs(0, 0)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m, dp = len(cost), len(cost[0]), {}\\n        for j in range(m): dp[j] = min(cost[i][j] for i in range(n)) \\n\\n        @lru_cache(maxsize = None)\\n        def dfs(left, right):\\n            if left == n: return sum(dp[j] for j in range(m) if right & 1<<j == 0)\\n            return min(cost[left][j] + dfs(left+1, right | 1<<j) for j in range(m))\\n\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855316,
                "title": "c-short-iterative-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int sz1 = cost.size();\\n        int sz2 = cost[0].size();\\n        vector<vector<int>> dp(sz1 + 1, vector<int>(1 << sz2, 1e9));\\n        dp[sz1][(1 << sz2) - 1] = 0;\\n        for(int i = sz1 - 1; i >= 0; --i) {\\n            for(int mask = (1 << sz2) - 1; mask >= 0; --mask) {\\n                for(int j = 0; j < sz2; ++j) {\\n                    dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i + 1][mask | (1 << j)]);\\n                    if(!(mask & (1 << j))) {\\n                        dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i][mask | (1 << j)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int sz1 = cost.size();\\n        int sz2 = cost[0].size();\\n        vector<vector<int>> dp(sz1 + 1, vector<int>(1 << sz2, 1e9));\\n        dp[sz1][(1 << sz2) - 1] = 0;\\n        for(int i = sz1 - 1; i >= 0; --i) {\\n            for(int mask = (1 << sz2) - 1; mask >= 0; --mask) {\\n                for(int j = 0; j < sz2; ++j) {\\n                    dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i + 1][mask | (1 << j)]);\\n                    if(!(mask & (1 << j))) {\\n                        dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i][mask | (1 << j)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855222,
                "title": "java-brute-force",
                "content": "We know 1 <= size1, size2 <= 12, so it is possible to brute force it, \\nEach time hanlde one point, util complete process all points.\\nInclude two part:\\nIf current point is in group1, just try dfs connect to every group2 situation.\\nIf current point is in group2, just find the min cost connect to group1.\\n\\n```\\nclass Solution {\\n\\tprivate int minCost;\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tminCost = Integer.MAX_VALUE;\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n\\t\\tboolean[] connected = new boolean[gp1Size + gp2Size];\\n\\t\\tdfs(0, 0, cost, connected);\\n\\t\\treturn minCost;\\n\\t}\\n\\tprivate void dfs(int idx, int sum, List<List<Integer>> cost, boolean[] connected){\\n\\t\\tif (idx == gp1Size + gp2Size) { \\n\\t\\t\\tminCost = Math.min(minCost, sum);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        //pruning\\n\\t\\tif (sum >= minCost) {\\n            return; \\n        }\\n\\t\\tif (idx < gp1Size) {\\n\\t\\t\\t//in group 1\\n\\t\\t\\tconnected[idx] = true; \\n            //brute force try connect to every point in group 2\\n\\t\\t\\tfor(int i = 0; i < gp2Size; i++){\\n                boolean oldVal = connected[i+gp1Size];\\n\\t\\t\\t\\tconnected[i+gp1Size] = true;\\n\\t\\t\\t\\tdfs(idx+1, sum + cost.get(idx).get(i), cost, connected);\\n                connected[i+gp1Size] = oldVal;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//in group 2\\n\\t\\t\\tif (!connected[idx]) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i = 0; i < gp1Size; i++){\\n\\t\\t\\t\\t\\tmin = Math.min(min, cost.get(i).get(idx-gp1Size));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdfs(idx+1, sum + min, cost, connected);\\n\\t\\t\\t} else {\\n                //if already connect, no need to connect to group 1 again\\n\\t\\t\\t\\tdfs(idx+1, sum, cost, connected);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nTime spend is about 397ms, since it is brute force probably not very fast.\\nTo improve is using the bit mask just as other discuss mentioned, then it will be able to cache the minCost for all the connected status.\\n```\\nclass Solution {\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n    private Map<Integer, Integer> cache;\\n    private int[] right;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n        cache = new HashMap<>();\\n\\t\\tint mask = 0;\\n\\t\\treturn dfs(0, cost, mask);\\n\\t}\\n\\tprivate int dfs(int idx, List<List<Integer>> cost, int mask){\\n\\t\\tif(idx == gp1Size + gp2Size) { \\n\\t\\t\\treturn 0;\\n\\t\\t}\\n        int key = mask;\\n        if(cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        int min = Integer.MAX_VALUE;\\n\\t\\tif(idx < gp1Size) {\\n\\t\\t\\t//in group 1\\n            mask = mask | (1 << idx);\\n\\t\\t\\tfor(int i = 0; i < gp2Size; i++){\\n                int newMask = mask | (1 << (i + gp1Size));\\n\\t\\t\\t    min = Math.min(min, dfs(idx+1, cost, newMask) + cost.get(idx).get(i));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//in group 2\\n\\t\\t\\tif((mask & (1 << idx)) == 0){\\n\\t\\t\\t\\tint minVal = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i = 0; i < gp1Size; i++){\\n\\t\\t\\t\\t    minVal = Math.min(minVal, cost.get(i).get(idx-gp1Size));\\n\\t\\t\\t\\t}\\n                min = dfs(idx+1, cost, mask) + minVal;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmin = dfs(idx+1, cost, mask);\\n\\t\\t\\t}\\n\\t\\t}\\n        cache.put(key, min);\\n        return min;\\n\\t}\\n}\\n```\\nAfter cache, time cost is reduce to 75ms",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\tprivate int minCost;\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tminCost = Integer.MAX_VALUE;\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n\\t\\tboolean[] connected = new boolean[gp1Size + gp2Size];\\n\\t\\tdfs(0, 0, cost, connected);\\n\\t\\treturn minCost;\\n\\t}\\n\\tprivate void dfs(int idx, int sum, List<List<Integer>> cost, boolean[] connected){\\n\\t\\tif (idx == gp1Size + gp2Size) { \\n\\t\\t\\tminCost = Math.min(minCost, sum);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        //pruning\\n\\t\\tif (sum >= minCost) {\\n            return; \\n        }\\n\\t\\tif (idx < gp1Size) {\\n\\t\\t\\t//in group 1\\n\\t\\t\\tconnected[idx] = true; \\n            //brute force try connect to every point in group 2\\n\\t\\t\\tfor(int i = 0; i < gp2Size; i++){\\n                boolean oldVal = connected[i+gp1Size];\\n\\t\\t\\t\\tconnected[i+gp1Size] = true;\\n\\t\\t\\t\\tdfs(idx+1, sum + cost.get(idx).get(i), cost, connected);\\n                connected[i+gp1Size] = oldVal;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//in group 2\\n\\t\\t\\tif (!connected[idx]) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i = 0; i < gp1Size; i++){\\n\\t\\t\\t\\t\\tmin = Math.min(min, cost.get(i).get(idx-gp1Size));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdfs(idx+1, sum + min, cost, connected);\\n\\t\\t\\t} else {\\n                //if already connect, no need to connect to group 1 again\\n\\t\\t\\t\\tdfs(idx+1, sum, cost, connected);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n    private Map<Integer, Integer> cache;\\n    private int[] right;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n        cache = new HashMap<>();\\n\\t\\tint mask = 0;\\n\\t\\treturn dfs(0, cost, mask);\\n\\t}\\n\\tprivate int dfs(int idx, List<List<Integer>> cost, int mask){\\n\\t\\tif(idx == gp1Size + gp2Size) { \\n\\t\\t\\treturn 0;\\n\\t\\t}\\n        int key = mask;\\n        if(cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        int min = Integer.MAX_VALUE;\\n\\t\\tif(idx < gp1Size) {\\n\\t\\t\\t//in group 1\\n            mask = mask | (1 << idx);\\n\\t\\t\\tfor(int i = 0; i < gp2Size; i++){\\n                int newMask = mask | (1 << (i + gp1Size));\\n\\t\\t\\t    min = Math.min(min, dfs(idx+1, cost, newMask) + cost.get(idx).get(i));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//in group 2\\n\\t\\t\\tif((mask & (1 << idx)) == 0){\\n\\t\\t\\t\\tint minVal = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i = 0; i < gp1Size; i++){\\n\\t\\t\\t\\t    minVal = Math.min(minVal, cost.get(i).get(idx-gp1Size));\\n\\t\\t\\t\\t}\\n                min = dfs(idx+1, cost, mask) + minVal;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmin = dfs(idx+1, cost, mask);\\n\\t\\t\\t}\\n\\t\\t}\\n        cache.put(key, min);\\n        return min;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075430,
                "title": "c-python-legit-dp-bitmask-explanation-bottom-up-and-top-down",
                "content": "Since we can multiply connect nodes, this is NOT an MST (minimal spanning tree) solution. For example suppose on the left, it cost [0,100,100] to connect any right node, and the same for the left. We would get a solution where L!->R1, L2->R1, L3->R1 and on the right R1->L1, R2->L1, R3->L1. We have more than the minimal 3 required, but it is much much cheaper to be redundant here (zero cost vs 200 cost).\\n\\nThe DP bitmask solution is very tricky. The optimal subproblems are actually not well defined subproblems! They only make sense at the very end.\\n\\nWe do the following: first solve a different problem. Suppose we have hooked up all *m* left nodes to some node on the right. Further assume that that procedure was __zero cost__. Now, what would be the cost to connect the right nodes?\\n\\nSince the left nodes are fixed, we just assign the *remaining* right nodes to their lowest costs. This is the base case of the recursion. We have to hard compute these minimal costs once and for all up front. They are just the minimum values in each column.\\n\\nThere are _2^n_ possible base cases. One for each possible configuration of \"already hooked up\" right nodes (the left nodes were zero cost, so we don\\'t care about that, hence _2^n_ and not _2^(mn)_).The DP matrix is thus of size _(m,2^n)_.\\n\\nNow we peel off the last connection on the left. There are now (m-1) zero cost connections on the left, leading to, again, any of _2^n_ possibilities on the right. To reconnect this final left node, it is the sum of two costs:\\n\\n1. `cost[i][j]``. Simply the cost of the left node\\'s connection\\n2. d[i+1][constrained mask]. The minimal cost for the right nodes to connect (our base case), but with an added constraint. We only allow states on the right where whatever right node that the left node connected to is marked as NOT free. This is redundantly imposed by turning on its bit `mask | 1<<k` for the _k_th right node.\\n\\nThe final cost is the sum over all _n_ possible costs, one for each possible right node that the final left node may connect to.\\n\\nWe can now state the final problem. We want to wittle the DP matrix down to the value `d[0][0]`. This means that we have attached __0__ nodes on the left, and there are currently __0__ blocked nodes on the right. By including the cost in item 2, our DP algorithm insures that we appropriately build up the costs of connecting each left nodes!\\n\\nThe tricky part of this solution was having faith that our optimal subproblems would suddenly blossom into a well-defined optimal problem.\\n\\nHere\\'s the bottoms-up C++ code\\n\\n```cpp\\nint connectTwoGroups(vector<vector<int>>& cost) {\\n\\n    int m=cost.size(), n=cost[0].size();\\n\\n    vector <int> rc(n, numeric_limits<int>::max());\\n    for (int i=0; i<m; ++i)\\n        for (int j=0; j<n; ++j)\\n            rc[j] = min(rc[j], cost[i][j]);\\n\\n    int d[13][1<<12]{};\\n    for (int i=m; i>=0; --i) {\\n        for (int j=0; j<1<<12; ++j) {\\n            if (i==m)\\n                for (int k=0; k<n; ++k)\\n                    d[i][j] += !(j&1<<k) ? rc[k] : 0;\\n            else {\\n                d[i][j] = numeric_limits<int>::max();\\n                for (int k=0; k<n; ++k)\\n                    d[i][j] = min(d[i][j], d[i+1][j|1<<k] + cost[i][k]);\\n            }\\n        }\\n    }\\n    return d[0][0];\\n}\\n```\\n\\nSince there was a redundancy in the bitmask constraint as we discussed, the top-down DP solution will actually be faster. It only queries the dictionary as needed. Here\\'s a python implemenation.\\n\\n```python\\ndef connectTwoGroups(cost) {\\n  m, n = len(cost), len(cost[0])\\n  rc = [min(x) for x in zip(*cost)] # right costs\\n\\n  # The recursive call tells us what the additional cost is, provided we already connected num_left_connected on the left and num_right_connected on the right.\\n  @lru_cache(maxsize=None)\\n  def aux(i, states):\\n      if i == m:\\n          return sum(rc[x] for x in range(n) if states & 1<<x == 0)\\n      return min(cost[i][j] + aux(i+1, states | 1<<j) for j in range(n))\\n\\n  # return the cost for 0 initial left connections and 0 intial right connections\\n  return aux(0,0)\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint connectTwoGroups(vector<vector<int>>& cost) {\\n\\n    int m=cost.size(), n=cost[0].size();\\n\\n    vector <int> rc(n, numeric_limits<int>::max());\\n    for (int i=0; i<m; ++i)\\n        for (int j=0; j<n; ++j)\\n            rc[j] = min(rc[j], cost[i][j]);\\n\\n    int d[13][1<<12]{};\\n    for (int i=m; i>=0; --i) {\\n        for (int j=0; j<1<<12; ++j) {\\n            if (i==m)\\n                for (int k=0; k<n; ++k)\\n                    d[i][j] += !(j&1<<k) ? rc[k] : 0;\\n            else {\\n                d[i][j] = numeric_limits<int>::max();\\n                for (int k=0; k<n; ++k)\\n                    d[i][j] = min(d[i][j], d[i+1][j|1<<k] + cost[i][k]);\\n            }\\n        }\\n    }\\n    return d[0][0];\\n}\\n```\n```python\\ndef connectTwoGroups(cost) {\\n  m, n = len(cost), len(cost[0])\\n  rc = [min(x) for x in zip(*cost)] # right costs\\n\\n  # The recursive call tells us what the additional cost is, provided we already connected num_left_connected on the left and num_right_connected on the right.\\n  @lru_cache(maxsize=None)\\n  def aux(i, states):\\n      if i == m:\\n          return sum(rc[x] for x in range(n) if states & 1<<x == 0)\\n      return min(cost[i][j] + aux(i+1, states | 1<<j) for j in range(n))\\n\\n  # return the cost for 0 initial left connections and 0 intial right connections\\n  return aux(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 855275,
                "title": "why-is-this-approach-not-working-add-all-costs-sort-them-and-then-remove-one-by-one",
                "content": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int[] groupACounts = new int[cost.get(0).size()];\\n        int[] groupBCounts = new int[cost.size()];\\n        Arrays.fill(groupACounts, cost.size());\\n        Arrays.fill(groupBCounts, cost.get(0).size());\\n        TreeMap<Integer, List<List<Integer>>> tm = new TreeMap<>(Collections.reverseOrder());\\n        for (int i = 0; i < cost.size(); i++) {\\n            for (int j = 0; j < cost.get(i).size(); j++) {\\n                int currCost = cost.get(i).get(j);\\n                if (!tm.containsKey(currCost)) {\\n                    tm.put(currCost, new ArrayList<List<Integer>>());\\n                } \\n                tm.get(currCost).add(new ArrayList<Integer>(List.of(i, j)));\\n            }\\n        }\\n        int costt = 0;\\n        for(Map.Entry<Integer,List<List<Integer>>> entry : tm.entrySet()) {\\n            Integer key = entry.getKey();\\n            List<List<Integer>> pairs = entry.getValue();\\n            if (pairs.size() > 1) {\\n                List<Integer> temp = pairs.get(0);\\n                pairs.set(0, pairs.get(1));\\n                pairs.set(1, temp);\\n            }\\n            for (List<Integer> pair : pairs) {\\n                if (groupACounts[pair.get(1)] > 1 && groupBCounts[pair.get(0)] > 1) {\\n                    groupACounts[pair.get(1)]--;\\n                    groupBCounts[pair.get(0)]--;\\n                } else {\\n                    costt += cost.get(pair.get(0)).get(pair.get(1));\\n                }\\n            }\\n        }\\n        return costt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int[] groupACounts = new int[cost.get(0).size()];\\n        int[] groupBCounts = new int[cost.size()];\\n        Arrays.fill(groupACounts, cost.size());\\n        Arrays.fill(groupBCounts, cost.get(0).size());\\n        TreeMap<Integer, List<List<Integer>>> tm = new TreeMap<>(Collections.reverseOrder());\\n        for (int i = 0; i < cost.size(); i++) {\\n            for (int j = 0; j < cost.get(i).size(); j++) {\\n                int currCost = cost.get(i).get(j);\\n                if (!tm.containsKey(currCost)) {\\n                    tm.put(currCost, new ArrayList<List<Integer>>());\\n                } \\n                tm.get(currCost).add(new ArrayList<Integer>(List.of(i, j)));\\n            }\\n        }\\n        int costt = 0;\\n        for(Map.Entry<Integer,List<List<Integer>>> entry : tm.entrySet()) {\\n            Integer key = entry.getKey();\\n            List<List<Integer>> pairs = entry.getValue();\\n            if (pairs.size() > 1) {\\n                List<Integer> temp = pairs.get(0);\\n                pairs.set(0, pairs.get(1));\\n                pairs.set(1, temp);\\n            }\\n            for (List<Integer> pair : pairs) {\\n                if (groupACounts[pair.get(1)] > 1 && groupBCounts[pair.get(0)] > 1) {\\n                    groupACounts[pair.get(1)]--;\\n                    groupBCounts[pair.get(0)]--;\\n                } else {\\n                    costt += cost.get(pair.get(0)).get(pair.get(1));\\n                }\\n            }\\n        }\\n        return costt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855104,
                "title": "python-bitmask-dfs",
                "content": "Use bitmask to record the status of group 2. \\n\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        dic = {}\\n        for i in range(n):\\n            dic[i] = min(cost[j][i] for j in range(m))\\n        \\n        @lru_cache(None)\\n        def dfs(left, right):\\n            b = bin(right)[2:]\\n            delta = n - len(b)\\n            b = delta * \\'0\\' + b\\n            cur = 0\\n            if left == m:\\n                for i in range(n):\\n                    if b[i] == \\'0\\':\\n                        cur += dic[i]\\n                return cur\\n            ret = float(\\'inf\\')\\n            for i in range(n):\\n                right |= (1 << (n - 1 - i))\\n                nxt = dfs(left + 1, right)\\n                cur = cost[left][i] + nxt\\n                ret = min(ret, cur)\\n                if b[i] == \\'0\\':\\n                    right &= ~(1 << (n - 1 - i))\\n            return ret\\n\\n        return dfs(0, 0)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        dic = {}\\n        for i in range(n):\\n            dic[i] = min(cost[j][i] for j in range(m))\\n        \\n        @lru_cache(None)\\n        def dfs(left, right):\\n            b = bin(right)[2:]\\n            delta = n - len(b)\\n            b = delta * \\'0\\' + b\\n            cur = 0\\n            if left == m:\\n                for i in range(n):\\n                    if b[i] == \\'0\\':\\n                        cur += dic[i]\\n                return cur\\n            ret = float(\\'inf\\')\\n            for i in range(n):\\n                right |= (1 << (n - 1 - i))\\n                nxt = dfs(left + 1, right)\\n                cur = cost[left][i] + nxt\\n                ret = min(ret, cur)\\n                if b[i] == \\'0\\':\\n                    right &= ~(1 << (n - 1 - i))\\n            return ret\\n\\n        return dfs(0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855233,
                "title": "python-dp-with-explanation",
                "content": "Finished after contest -o-\\nThe dp equation is the following.\\nDefine dp(i,S) as the min cost to let the first up to i-th elements in group 1 and a subset S of group 2 to be connnected. Then, we have\\ndp(i,S)=min_k (dp(i-1,s\\\\k)+cost(i,k))\\nHere i is incremented from 0 to len(cost)-1\\nS denotes a subset of the second group\\nThe really tricky part for me is to get what dp(i,S) really means. The initial condition dp(-1,S) is tricky.\\nIt is easy to think dp(-1,S)=0 as no point in group needs to be connected. Yet, by definition, S in group 2 needs to be connected, and each point can connect to any point in group 1. It takes me some time to realize this. Interesting!!\\n\\nTime complexity: O(n*m*2^m), where n=len(group 1) and m=len(group2)\\n\\n\\n\\n```\\nINF=float(\\'inf\\')\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        \\n        def get_set(size):\\n            \\n            if size==1:\\n                return [tuple([0]),tuple([1])]        \\n            else:\\n                \\n                L=get_set(size-1)\\n                \\n                res=[]\\n                \\n                for status in L:\\n                    \\n                    res.append(status+tuple([0]))\\n                    res.append(status+tuple([1]))\\n                \\n                return res   \\n        \\n        dp={}\\n        \\n        \\n        L=get_set(len(cost[0]))\\n        \\n        for status in L:\\n            tem=0\\n            for j in range(len(status)):\\n                if status[j]==1:\\n                    min_tem=INF\\n                    for i in range(len(cost)):\\n                        min_tem=min(min_tem,cost[i][j])\\n                    tem+=min_tem\\n            \\n            dp[(-1,status)]=tem\\n       \\n        for i in range(0,len(cost)):\\n            \\n            for status in L:\\n                \\n                cur_min=INF\\n                for k in range(len(cost[0])):\\n                    \\n\\n                    new_stats=status[:k]+tuple([0])+status[k+1:]\\n                    \\n                    cur_min=min(cur_min,dp[(i-1,new_stats)]+cost[i][k])\\n                \\n                dp[(i,status)]=cur_min\\n        \\n        return dp[(len(cost)-1,tuple([1 for i in range(len(cost[0]))]))]\\n```",
                "solutionTags": [],
                "code": "```\\nINF=float(\\'inf\\')\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        \\n        def get_set(size):\\n            \\n            if size==1:\\n                return [tuple([0]),tuple([1])]        \\n            else:\\n                \\n                L=get_set(size-1)\\n                \\n                res=[]\\n                \\n                for status in L:\\n                    \\n                    res.append(status+tuple([0]))\\n                    res.append(status+tuple([1]))\\n                \\n                return res   \\n        \\n        dp={}\\n        \\n        \\n        L=get_set(len(cost[0]))\\n        \\n        for status in L:\\n            tem=0\\n            for j in range(len(status)):\\n                if status[j]==1:\\n                    min_tem=INF\\n                    for i in range(len(cost)):\\n                        min_tem=min(min_tem,cost[i][j])\\n                    tem+=min_tem\\n            \\n            dp[(-1,status)]=tem\\n       \\n        for i in range(0,len(cost)):\\n            \\n            for status in L:\\n                \\n                cur_min=INF\\n                for k in range(len(cost[0])):\\n                    \\n\\n                    new_stats=status[:k]+tuple([0])+status[k+1:]\\n                    \\n                    cur_min=min(cur_min,dp[(i-1,new_stats)]+cost[i][k])\\n                \\n                dp[(i,status)]=cur_min\\n        \\n        return dp[(len(cost)-1,tuple([1 for i in range(len(cost[0]))]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260447,
                "title": "java-with-dp-bitmask-recursion",
                "content": "```\\nclass Solution {\\n    int Asize=0;\\n    int[][][] map;\\n    int resultMask=0;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        Asize=cost.get(0).size();\\n        resultMask=(1<<(Asize))-1;\\n        map=new int[cost.get(0).size()][cost.size()][resultMask+1];\\n        return helper(cost,0,0,0);\\n    }\\n    \\n    int helper(List<List<Integer>> cost,int i,int j,int mask){\\n    \\n        if(i==cost.size() && mask==resultMask){\\n            return 0;\\n        }\\n        int ans=150000;\\n        if(j==Asize || i==cost.size()){\\n            return ans;\\n        }\\n       \\n        if(map[j][i][mask]!=0){\\n            return map[j][i][mask];\\n        }\\n        int temp1=cost.get(i).get(j)+helper(cost,i+1,0,getMask(mask,j));\\n        int temp2=helper(cost,i,j+1,mask);\\n        int temp3=cost.get(i).get(j)+helper(cost,i,j+1,getMask(mask,j));\\n     \\n        ans=Math.min(temp3,Math.min(temp1,temp2));\\n        map[j][i][mask]=ans;\\n        return ans;\\n    }\\n    \\n    int getMask(int mask,int j){\\n        int temp=1<<j;\\n        mask=mask|temp;\\n        return mask;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int Asize=0;\\n    int[][][] map;\\n    int resultMask=0;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        Asize=cost.get(0).size();\\n        resultMask=(1<<(Asize))-1;\\n        map=new int[cost.get(0).size()][cost.size()][resultMask+1];\\n        return helper(cost,0,0,0);\\n    }\\n    \\n    int helper(List<List<Integer>> cost,int i,int j,int mask){\\n    \\n        if(i==cost.size() && mask==resultMask){\\n            return 0;\\n        }\\n        int ans=150000;\\n        if(j==Asize || i==cost.size()){\\n            return ans;\\n        }\\n       \\n        if(map[j][i][mask]!=0){\\n            return map[j][i][mask];\\n        }\\n        int temp1=cost.get(i).get(j)+helper(cost,i+1,0,getMask(mask,j));\\n        int temp2=helper(cost,i,j+1,mask);\\n        int temp3=cost.get(i).get(j)+helper(cost,i,j+1,getMask(mask,j));\\n     \\n        ans=Math.min(temp3,Math.min(temp1,temp2));\\n        map[j][i][mask]=ans;\\n        return ans;\\n    }\\n    \\n    int getMask(int mask,int j){\\n        int temp=1<<j;\\n        mask=mask|temp;\\n        return mask;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046425,
                "title": "short-python-dp",
                "content": "```python\\nfrom functools import lru_cache\\n\\n\\nclass Solution(object):\\n    def connectTwoGroups(self, cost):\\n        n, m = len(cost), len(cost[0])\\n        @lru_cache(None)\\n        def f(n, msk):\\n            if n == 0:\\n                return msk and float(\\'inf\\')\\n            res = f(n-1, msk) + min(cost[n-1])\\n            for i  in range(m):\\n                if (msk>>i) & 1 :\\n                    res = min(res, min(f(n-1, msk ^(1<<i)), f(n, msk^(1<<i))) + cost[n-1][i])\\n            return res\\n        return f(n, (1<<m)-1)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\n\\n\\nclass Solution(object):\\n    def connectTwoGroups(self, cost):\\n        n, m = len(cost), len(cost[0])\\n        @lru_cache(None)\\n        def f(n, msk):\\n            if n == 0:\\n                return msk and float(\\'inf\\')\\n            res = f(n-1, msk) + min(cost[n-1])\\n            for i  in range(m):\\n                if (msk>>i) & 1 :\\n                    res = min(res, min(f(n-1, msk ^(1<<i)), f(n, msk^(1<<i))) + cost[n-1][i])\\n            return res\\n        return f(n, (1<<m)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972844,
                "title": "c-solution-following-the-hints",
                "content": "Following the hints, let dp[i][j] denote the minimum cost when first i left nodes are connected to the right nodes represented by mask j; then the DP relations is:\\n```\\ndp[i][j] = min {\\n\\t\\t\\tdp[i-1][j] + (min cost between node i and a node within j),\\n\\t\\t\\tdp[i-1][k] + (sum of cost between node i and nodes in j ^ k) for different subsets k of j\\n\\t\\t\\t}\\n```\\nIn another word, the general idea is: iterate the left nodes one by one; for new left node, there can be 2 cases:\\n1) its degree can be 1, which means it will follow some other right side node, which is the first term in the above relation;\\n2) its degree is greater than 1, which means it\\'s a leader and have a subset of right nodes uniquely belonging to it, which is the second term in the above relation.\\n\\n```\\nclass Solution {\\n    \\n    int m,n;\\n    int dp[12][1<<12]{};\\n    int withinmin[12][1<<12]{};\\n    int withinsum[12][1<<12]{};\\n    \\npublic:\\n    \\n    void prepare(vector<vector<int>>& co) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                withinsum[i][1<<j] = dp[i][1<<j] = co[i][j];\\n            }\\n            \\n            for(int j = 3; j < (1 << n); j++) {\\n                if(withinsum[i][j]) continue;\\n                withinsum[i][j] = withinsum[i][j&-j] + withinsum[i][j-(j&-j)];\\n            }\\n            \\n            vector<int> x(n);\\n            iota(x.begin(), x.end(), 0);\\n            auto f=[&co, &i](int j, int k){return co[i][j] < co[i][k];};\\n            std::sort(x.begin(), x.end(), f);\\n            \\n            int ind = (1 << n) - 1, inc;\\n            for(int j : x) {\\n                inc = 1 << j;\\n                ind ^= inc;\\n                for(int k = ind;;k = (k - 1)&ind) {\\n                    withinmin[i][k|inc] = co[i][j];\\n                    if(!k)break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size();\\n        n = cost[0].size();\\n        \\n        prepare(cost);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < (1<<n); j++) {\\n                if(i == 0) dp[i][j] = dp[i][j&-j] + dp[i][j-(j&-j)];\\n                else {\\n                    dp[i][j] = dp[i-1][j] + withinmin[i][j]; // case 1)\\n                    for(int k = j-1; k; k = (k-1)&j) { // case 2)\\n                        dp[i][j] = min(dp[i][j], withinsum[i][k] + dp[i-1][j^k]); \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][(1<<n)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = min {\\n\\t\\t\\tdp[i-1][j] + (min cost between node i and a node within j),\\n\\t\\t\\tdp[i-1][k] + (sum of cost between node i and nodes in j ^ k) for different subsets k of j\\n\\t\\t\\t}\\n```\n```\\nclass Solution {\\n    \\n    int m,n;\\n    int dp[12][1<<12]{};\\n    int withinmin[12][1<<12]{};\\n    int withinsum[12][1<<12]{};\\n    \\npublic:\\n    \\n    void prepare(vector<vector<int>>& co) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                withinsum[i][1<<j] = dp[i][1<<j] = co[i][j];\\n            }\\n            \\n            for(int j = 3; j < (1 << n); j++) {\\n                if(withinsum[i][j]) continue;\\n                withinsum[i][j] = withinsum[i][j&-j] + withinsum[i][j-(j&-j)];\\n            }\\n            \\n            vector<int> x(n);\\n            iota(x.begin(), x.end(), 0);\\n            auto f=[&co, &i](int j, int k){return co[i][j] < co[i][k];};\\n            std::sort(x.begin(), x.end(), f);\\n            \\n            int ind = (1 << n) - 1, inc;\\n            for(int j : x) {\\n                inc = 1 << j;\\n                ind ^= inc;\\n                for(int k = ind;;k = (k - 1)&ind) {\\n                    withinmin[i][k|inc] = co[i][j];\\n                    if(!k)break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size();\\n        n = cost[0].size();\\n        \\n        prepare(cost);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < (1<<n); j++) {\\n                if(i == 0) dp[i][j] = dp[i][j&-j] + dp[i][j-(j&-j)];\\n                else {\\n                    dp[i][j] = dp[i-1][j] + withinmin[i][j]; // case 1)\\n                    for(int k = j-1; k; k = (k-1)&j) { // case 2)\\n                        dp[i][j] = min(dp[i][j], withinsum[i][k] + dp[i-1][j^k]); \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][(1<<n)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959516,
                "title": "dp-bitmask-faster-than-98-94-space-less-than-65-85-o-n-m-2-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int mn_cost[13];\\n    int cache[(1 << 12) + 1];\\n    int dp[13][(1 << 12) + 1];\\n    int n, m;\\n    int suff[13];\\n    const int inf = 1e9;\\n    vector<vector<int>>cst;\\n    int solve(int ind, int mask){\\n        if(mask == (1 << m) - 1){\\n            return suff[ind];\\n        }\\n        if(ind == n){\\n            return cache[mask];\\n        }\\n        if(dp[ind][mask] != -1)return dp[ind][mask];\\n        int ret = inf;\\n        for(int i = 0; i < m; ++i){\\n            ret = min(ret, cst[ind][i] + solve(ind + 1, mask | (1 << i)));\\n        }\\n        return dp[ind][mask] = ret;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        cst.assign(cost.begin(), cost.end());\\n        n = (int)cost.size();\\n        m = (int)cost[0].size();\\n        for(int i = 0; i < 13; ++i)mn_cost[i] = inf;\\n        for(int j = 0; j < m; ++j){\\n            for(int i = 0; i < n; ++i){\\n                mn_cost[j] = min(mn_cost[j], cost[i][j]);\\n            }\\n        }\\n        for(int i = 0; i < (1 << m); ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(!((i >> j) & 1))cache[i] += mn_cost[j];\\n            }\\n        }\\n        for(int i = n - 1; i >= 0; --i){\\n            if(i < n - 1)suff[i] = suff[i + 1];\\n            suff[i] += *min_element(cost[i].begin(), cost[i].end());\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mn_cost[13];\\n    int cache[(1 << 12) + 1];\\n    int dp[13][(1 << 12) + 1];\\n    int n, m;\\n    int suff[13];\\n    const int inf = 1e9;\\n    vector<vector<int>>cst;\\n    int solve(int ind, int mask){\\n        if(mask == (1 << m) - 1){\\n            return suff[ind];\\n        }\\n        if(ind == n){\\n            return cache[mask];\\n        }\\n        if(dp[ind][mask] != -1)return dp[ind][mask];\\n        int ret = inf;\\n        for(int i = 0; i < m; ++i){\\n            ret = min(ret, cst[ind][i] + solve(ind + 1, mask | (1 << i)));\\n        }\\n        return dp[ind][mask] = ret;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        cst.assign(cost.begin(), cost.end());\\n        n = (int)cost.size();\\n        m = (int)cost[0].size();\\n        for(int i = 0; i < 13; ++i)mn_cost[i] = inf;\\n        for(int j = 0; j < m; ++j){\\n            for(int i = 0; i < n; ++i){\\n                mn_cost[j] = min(mn_cost[j], cost[i][j]);\\n            }\\n        }\\n        for(int i = 0; i < (1 << m); ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(!((i >> j) & 1))cache[i] += mn_cost[j];\\n            }\\n        }\\n        for(int i = n - 1; i >= 0; --i){\\n            if(i < n - 1)suff[i] = suff[i + 1];\\n            suff[i] += *min_element(cost[i].begin(), cost[i].end());\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862980,
                "title": "dp-with-bitmask-in-c",
                "content": "LEETCODE-1595\\n$$\\u7528dp[i][j]\\u6765\\u8868\\u793A\\u5DE6\\u8FB9\\u524Di\\u4E2A\\u70B9\\u548C\\u53F3\\u8FB9\\u524Dj\\u4E2A\\u70B9\\u6765\\u8868\\u793A\\u5F53\\u524D\\u94FE\\u63A5\\u7684\\u6700\\u5C0Fcost\\u5E76\\u4E0D\\u5408\\u9002\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u51FA\\u73B0\\u4EA4\\u53C9\\u7684\\u60C5\\u51B5\\uFF0C\\u6BD4\\u5982\\u6700\\u4F18\\u7684\\u60C5\\u51B5\\u5982\\u4E0B\\uFF1A\\n1\\u2014\\u2014a\\n2\\tb\\n3\\tc\\n\\u5176\\u4E2D1-a,2-c,3-b\\uFF0C\\u8FD9\\u6837\\u5C31\\u4F1A\\u51FA\\u73B0\\u4EA4\\u53C9\\uFF0C\\u5728dp[i][j]\\u7684\\u8FED\\u4EE3\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u5E76\\u4E0D\\u80FD\\u4ECEdp[2][2]\\u5230\\u8FBEdp[3][3]\\u5E76\\u4E0D\\u7B26\\u5408\\u60C5\\u51B5\\uFF0C\\u56E0\\u4E3A\\u6CA1\\u529E\\u6CD5\\u5220\\u9664dp[2][2]\\u4E2D\\u7684\\u8FDE\\u7EBF\\u3002\\n$$\\u8003\\u8651\\u53E6\\u5916\\u4E00\\u79CD\\u65B9\\u6CD5\\uFF1A\\n\\u7528dp[i][s]\\u6765\\u8868\\u793A\\u5DE6\\u8FB9\\u524Di\\u4E2A\\u70B9\\uFF0C\\u53F3\\u8FB9\\u662F\\u4E00\\u4E2As\\u5BF9\\u5E94\\u4E00\\u4E2Abitmask\\uFF0Cs\\u53EF\\u4EE5\\u8868\\u793A\\u53F3\\u8FB9\\u94FE\\u63A5\\u7684\\u70B9\\u7684\\u6240\\u6709\\u60C5\\u51B5\\u3002\\n\\u6BD4\\u5982\\u53F3\\u8FB9\\u6709 a b\\u4E24\\u4E2A\\u70B9\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u8868\\u793A\\u4E3A\\u56DB\\u79CD\\u60C5\\u51B5\\uFF1A01 10 11 00\\uFF1B\\n\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\uFF1Adp[i+1][s | 1<<j]=min(dp[i+1][s | 1<<j] ,\\n\\t\\t\\t\\t\\tdp[i][s]\\uFF0C  //\\u524Di\\u4E2A\\u70B9\\u6709\\u4E9B\\u70B9\\u88AB\\u91CD\\u590D\\u4F7F\\u7528\\uFF1B\\n\\t\\t\\t\\t\\tdp[i+1][s]);  //\\u589E\\u52A0\\u4E86\\u4E00\\u4E2A\\u65B0\\u7684\\u70B9\\uFF1B\\n\\u5176\\u4E2Di\\u8868\\u793A\\u5DE6\\u8FB9\\u524Di\\u4E2A\\u70B9\\u3002s | 1<<j \\u8868\\u793A\\u7B2Cj\\u4E2A\\u70B9\\u88AB\\u8FDE\\u63A5\\u7684\\u65F6\\u5019\\uFF0C\\u53BB\\u7528\\u6240\\u6709s\\u66F4\\u65B0\\u6240\\u6709\\u7684s | i<<j\\u3002\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        constexpr int kinf=1e9;\\n        const int m = cost.size();\\n        const int n = cost[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(1<<n,kinf));\\n        \\n        dp[0][0]=0;\\n        \\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                for(int s=0;s< 1<<n;++s){\\n                    dp[i+1][s|1<<j]=min({dp[i+1][s|1<<j],\\n                               dp[i][s]+cost[i][j],\\n                               dp[i+1][s]+cost[i][j]});\\n                }\\n            }\\n        }\\n        \\n        \\n        return dp[m].back();\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        constexpr int kinf=1e9;\\n        const int m = cost.size();\\n        const int n = cost[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(1<<n,kinf));\\n        \\n        dp[0][0]=0;\\n        \\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                for(int s=0;s< 1<<n;++s){\\n                    dp[i+1][s|1<<j]=min({dp[i+1][s|1<<j],\\n                               dp[i][s]+cost[i][j],\\n                               dp[i+1][s]+cost[i][j]}",
                "codeTag": "Java"
            },
            {
                "id": 858187,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        mn = [min(x) for x in zip(*cost)] # min cost of connecting points in 2nd group \\n        \\n        @lru_cache(None)\\n        def fn(i, mask):\\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\\n            if i == m: return sum(mn[j] for j in range(n) if not (mask & (1<<j)))\\n            return min(cost[i][j] + fn(i+1, mask | 1<<j) for j in range(n))\\n                \\n        return fn(0, 0)\\n```\\n\\nor symmetrically \\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        mn = [min(x) for x in cost] # min cost of connecting points in 1st group \\n        \\n        @lru_cache(None)\\n        def fn(j, mask):\\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\\n            if j == n: return sum(mn[i] for i in range(m) if not (mask & (1<<i)))\\n            return min(cost[i][j] + fn(j+1, mask | 1<<i) for i in range(m))\\n                \\n        return fn(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        mn = [min(x) for x in zip(*cost)] # min cost of connecting points in 2nd group \\n        \\n        @lru_cache(None)\\n        def fn(i, mask):\\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\\n            if i == m: return sum(mn[j] for j in range(n) if not (mask & (1<<j)))\\n            return min(cost[i][j] + fn(i+1, mask | 1<<j) for j in range(n))\\n                \\n        return fn(0, 0)\\n```\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        mn = [min(x) for x in cost] # min cost of connecting points in 1st group \\n        \\n        @lru_cache(None)\\n        def fn(j, mask):\\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\\n            if j == n: return sum(mn[i] for i in range(m) if not (mask & (1<<i)))\\n            return min(cost[i][j] + fn(j+1, mask | 1<<i) for i in range(m))\\n                \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857089,
                "title": "java-top-down-dp-with-bit-mask",
                "content": "use mask to track which element is group2 (or b) is connected\\n1 calculate min cost from group2 to group1 for each node in group2\\n2 dfs + mem on each possible group1 node connection to group2 node\\n3 for the remaining unconnected nodes in group2, connect back to group1 with their minimal costs\\n```\\nInteger[][] mem;\\n    int aLen, bLen;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        mem = new Integer[13][1 << 12];\\n        aLen = cost.size();\\n        bLen = cost.get(0).size();\\n        int[] minCostFromBtoA = new int[bLen];\\n        Arrays.fill(minCostFromBtoA, Integer.MAX_VALUE);\\n        int res = 0;\\n        for (int b = 0; b < bLen; b++) {\\n            for (int a = 0; a < aLen; a++) {\\n                minCostFromBtoA[b] = Math.min(minCostFromBtoA[b], cost.get(a).get(b));\\n            }\\n        }\\n        return dfs(cost, minCostFromBtoA, 0, 0);\\n    }\\n\\n    private int dfs(List<List<Integer>> cost, int[] minCostFromBtoA, int a, int mask) {\\n        if (a == aLen) {\\n            int res = 0;\\n            for (int b = 0; b < bLen; b++) {\\n                if ((mask & (1 << b)) == 0) {\\n                    res += minCostFromBtoA[b];\\n                }\\n            }\\n            return mem[a][mask] = res;\\n        }\\n        if (mem[a][mask] != null) {\\n            return mem[a][mask];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int b = 0; b < bLen; b++) {\\n            res = Math.min(res, cost.get(a).get(b) + dfs(cost, minCostFromBtoA, a + 1, mask | (1 << b)));\\n        }\\n        return mem[a][mask] = res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nInteger[][] mem;\\n    int aLen, bLen;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        mem = new Integer[13][1 << 12];\\n        aLen = cost.size();\\n        bLen = cost.get(0).size();\\n        int[] minCostFromBtoA = new int[bLen];\\n        Arrays.fill(minCostFromBtoA, Integer.MAX_VALUE);\\n        int res = 0;\\n        for (int b = 0; b < bLen; b++) {\\n            for (int a = 0; a < aLen; a++) {\\n                minCostFromBtoA[b] = Math.min(minCostFromBtoA[b], cost.get(a).get(b));\\n            }\\n        }\\n        return dfs(cost, minCostFromBtoA, 0, 0);\\n    }\\n\\n    private int dfs(List<List<Integer>> cost, int[] minCostFromBtoA, int a, int mask) {\\n        if (a == aLen) {\\n            int res = 0;\\n            for (int b = 0; b < bLen; b++) {\\n                if ((mask & (1 << b)) == 0) {\\n                    res += minCostFromBtoA[b];\\n                }\\n            }\\n            return mem[a][mask] = res;\\n        }\\n        if (mem[a][mask] != null) {\\n            return mem[a][mask];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int b = 0; b < bLen; b++) {\\n            res = Math.min(res, cost.get(a).get(b) + dfs(cost, minCostFromBtoA, a + 1, mask | (1 << b)));\\n        }\\n        return mem[a][mask] = res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855055,
                "title": "dp-bitmasks-c",
                "content": "# **DP BITMASKS**\\nwe have in `mask_a` and `mask_b` the the numbers which haven\\u2019t been paired yet\\nso we find a number and find the best pairing with other set\\n\\nif `i`th bit is set in `mask` means `i`th number is not paired yet \\n\\n## **TRANSITIONS**\\n`dp[mask_a][mask_b] -> cost[i][j] + dp[unset i th bit in mask_a][unset j th bit in mask_b]`\\n\\n## **BASE CASE**\\n`dp[0][0] = 0`\\n\\n## **TIME COMPLEXITY**\\n`O(2^n * 2^m)`\\n\\n## **SPACE COMPLEXITY**\\n`O(2^n * 2^m)`\\n\\n## **CODE**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int go(vector<vector<int>> &cost, int mask_a, int mask_b)\\n    {\\n        if (mask_a == 0 and mask_b == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[mask_a][mask_b] != -1)\\n            return dp[mask_a][mask_b];\\n\\n        int ans = 1e9;\\n        if (mask_a != 0) {\\n\\t\\t\\t// last set bit in a\\n            int last_a = mask_a & - mask_a;\\n            int i = log2(last_a);\\n            for (int j = 0; j < cost[0].size(); j++) {\\n                if ((mask_a & last_a) != 0 or (mask_b & (1 << j)) != 0) {\\n                    int new_mask_a = mask_a & (((1 << 30) - 1) ^ last_a);\\n                    int new_mask_b = mask_b & (((1 << 30) - 1) ^ (1 << j));\\n                    ans = min(ans, cost[i][j] + go(cost, new_mask_a, new_mask_b));\\n                }\\n            }\\n        }\\n        if (mask_b != 0) {\\n\\t\\t\\t// last set bit in mask_b\\n            int last_b = mask_b & - mask_b;\\n            int j = log2(last_b);\\n            for (int i = 0; i < cost.size(); i++) {\\n                if ((mask_b & last_b) != 0 or (mask_a & (1 << i)) != 0) {\\n                    int new_mask_a = mask_a & (((1 << 30) - 1) ^ (1<<i));\\n                    int new_mask_b = mask_b & (((1 << 30) - 1) ^ (1 << j));\\n                    ans = min(ans, cost[i][j] + go(cost, new_mask_a, new_mask_b));\\n                }\\n            }\\n        }\\n        return dp[mask_a][mask_b] = ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        dp = vector<vector<int>> (1<<n, vector<int> (1<<m, -1));\\n        \\n        return go(cost, (1<<n) - 1, (1<<m) - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int go(vector<vector<int>> &cost, int mask_a, int mask_b)\\n    {\\n        if (mask_a == 0 and mask_b == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[mask_a][mask_b] != -1)\\n            return dp[mask_a][mask_b];\\n\\n        int ans = 1e9;\\n        if (mask_a != 0) {\\n\\t\\t\\t// last set bit in a\\n            int last_a = mask_a & - mask_a;\\n            int i = log2(last_a);\\n            for (int j = 0; j < cost[0].size(); j++) {\\n                if ((mask_a & last_a) != 0 or (mask_b & (1 << j)) != 0) {\\n                    int new_mask_a = mask_a & (((1 << 30) - 1) ^ last_a);\\n                    int new_mask_b = mask_b & (((1 << 30) - 1) ^ (1 << j));\\n                    ans = min(ans, cost[i][j] + go(cost, new_mask_a, new_mask_b));\\n                }\\n            }\\n        }\\n        if (mask_b != 0) {\\n\\t\\t\\t// last set bit in mask_b\\n            int last_b = mask_b & - mask_b;\\n            int j = log2(last_b);\\n            for (int i = 0; i < cost.size(); i++) {\\n                if ((mask_b & last_b) != 0 or (mask_a & (1 << i)) != 0) {\\n                    int new_mask_a = mask_a & (((1 << 30) - 1) ^ (1<<i));\\n                    int new_mask_b = mask_b & (((1 << 30) - 1) ^ (1 << j));\\n                    ans = min(ans, cost[i][j] + go(cost, new_mask_a, new_mask_b));\\n                }\\n            }\\n        }\\n        return dp[mask_a][mask_b] = ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        dp = vector<vector<int>> (1<<n, vector<int> (1<<m, -1));\\n        \\n        return go(cost, (1<<n) - 1, (1<<m) - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861834,
                "title": "java-dp-with-bitmask",
                "content": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size(); // size of set1\\n        int n = cost.get(0).size(); // size of set 2;\\n        \\n        int mask = 1 << m;\\n        int[] record = new int[mask]; // min cost to connect nodes in set 1 (of different states);\\n        Arrays.fill(record, Integer.MAX_VALUE);\\n        // since we use record to get the min cost of connecting nodes in set 1\\n        // we shall go through nodes in set 2 one by one, to make sure they are connected\\n        \\n        // base case:\\n        record[0] = 0;\\n        for (int col = 0; col < n; col ++){\\n            int[] tmpRecord = new int[mask];\\n            Arrays.fill(tmpRecord, Integer.MAX_VALUE);\\n            // try connection with each of the node in set 1 \\n            for (int row = 0; row < m; row++){           \\n                for (int msk = 0; msk < mask; msk++){\\n                    // the new min cost should be based on the cost record of connecting previous node in set 2;\\n                    int newMask =  msk | (1 << row);\\n                \\n                    if (record[msk] != Integer.MAX_VALUE){\\n                        tmpRecord[newMask] = Math.min(tmpRecord[newMask], record[msk] + cost.get(row).get(col));\\n                    }\\n                    \\n                    // if row nodes in this state has not been connected yet, and the msk is achievable by connecting the current node\\n                    // then check whether connect the current node multiple times will benefit the cost\\n                    if ((msk & (1 << row)) == 0 && tmpRecord[msk] != Integer.MAX_VALUE){\\n                        tmpRecord[newMask] = Math.min(tmpRecord[newMask], tmpRecord[msk] + cost.get(row).get(col));\\n                    }\\n                }\\n            }\\n            // use tmpRecord to update record\\n            record = tmpRecord;\\n        \\n        }\\n        \\n        return record[(1 << m) - 1];\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size(); // size of set1\\n        int n = cost.get(0).size(); // size of set 2;\\n        \\n        int mask = 1 << m;\\n        int[] record = new int[mask]; // min cost to connect nodes in set 1 (of different states);\\n        Arrays.fill(record, Integer.MAX_VALUE);\\n        // since we use record to get the min cost of connecting nodes in set 1\\n        // we shall go through nodes in set 2 one by one, to make sure they are connected\\n        \\n        // base case:\\n        record[0] = 0;\\n        for (int col = 0; col < n; col ++){\\n            int[] tmpRecord = new int[mask];\\n            Arrays.fill(tmpRecord, Integer.MAX_VALUE);\\n            // try connection with each of the node in set 1 \\n            for (int row = 0; row < m; row++){           \\n                for (int msk = 0; msk < mask; msk++){\\n                    // the new min cost should be based on the cost record of connecting previous node in set 2;\\n                    int newMask =  msk | (1 << row);\\n                \\n                    if (record[msk] != Integer.MAX_VALUE){\\n                        tmpRecord[newMask] = Math.min(tmpRecord[newMask], record[msk] + cost.get(row).get(col));\\n                    }\\n                    \\n                    // if row nodes in this state has not been connected yet, and the msk is achievable by connecting the current node\\n                    // then check whether connect the current node multiple times will benefit the cost\\n                    if ((msk & (1 << row)) == 0 && tmpRecord[msk] != Integer.MAX_VALUE){\\n                        tmpRecord[newMask] = Math.min(tmpRecord[newMask], tmpRecord[msk] + cost.get(row).get(col));\\n                    }\\n                }\\n            }\\n            // use tmpRecord to update record\\n            record = tmpRecord;\\n        \\n        }\\n        \\n        return record[(1 << m) - 1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538737,
                "title": "bitmask-dp-java-easy-to-understand-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    /*\\n        Idea :  For each point in first group:\\n                    try all possibilities to connect this point to some point in the second group.\\n                \\n                Now since \"each point in the second group must be connected to at least one point in the first group\", \\n                for each of points in second group which are not yet connected to any of the point in first group,\\n                connect it greedily (whose cost is minimum).\\n    \\n        Complexity : \\n        \\n        Let N be the size of first group.\\n        Let M be the size of second group.\\n        \\n        Time  : O(N * 2^M * M + M) ==> O(N * M * 2^M).\\n        Space : O(N * 2^M + M) ==> O(N * 2^M).\\n    */\\n    \\n    \\n    // map(j, cost) -> stores the min cost to connect jth point in the second group, to any of the point in first group.\\n    static Map<Integer, Integer> map = new HashMap<>(); \\n    static int[][] memo = new int[15][5000];\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        int m = cost.get(0).size();\\n        for (int j = 0; j < m; j++) {\\n            int min = Integer.MAX_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                min = Math.min(min, cost.get(i).get(j));\\n            }\\n            map.put(j, min);\\n        }\\n        for (int i = 0; i < 15; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return dp(cost, n, m, 0, 0);\\n    }\\n    private static int dp(List<List<Integer>> cost, int n, int m, int index, int mask) {\\n        if (memo[index][mask] != -1) {\\n            return memo[index][mask];\\n        }\\n        if (index == n) {\\n            // We have connected all points from the first group to some points in second group.\\n            // now, if some point in second group is not connected to any point in first group, we can connect it greedily.\\n            int costToConnectRemaining = 0;\\n            for (int j = 0; j < m; j++) {\\n                if ((mask & (1 << j)) == 0) {\\n                    costToConnectRemaining += map.get(j);\\n                }\\n            }\\n            return memo[index][mask] = costToConnectRemaining;\\n        }\\n        int minCost = Integer.MAX_VALUE;\\n        // try to connect ith point from first group to any of the point in second group, such that cost is minimized.\\n        for (int j = 0; j < m; j++) {\\n            int newMask = mask | (1 << j);\\n            int tempCost = dp(cost, n, m, index + 1, newMask) + cost.get(index).get(j);\\n            minCost = Math.min(minCost, tempCost);\\n        }\\n        return memo[index][mask] = minCost;\\n    }\\n}\\n```\\n\\nIf you like the solution, please Upvote \\uD83D\\uDC4D!!\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n        Idea :  For each point in first group:\\n                    try all possibilities to connect this point to some point in the second group.\\n                \\n                Now since \"each point in the second group must be connected to at least one point in the first group\", \\n                for each of points in second group which are not yet connected to any of the point in first group,\\n                connect it greedily (whose cost is minimum).\\n    \\n        Complexity : \\n        \\n        Let N be the size of first group.\\n        Let M be the size of second group.\\n        \\n        Time  : O(N * 2^M * M + M) ==> O(N * M * 2^M).\\n        Space : O(N * 2^M + M) ==> O(N * 2^M).\\n    */\\n    \\n    \\n    // map(j, cost) -> stores the min cost to connect jth point in the second group, to any of the point in first group.\\n    static Map<Integer, Integer> map = new HashMap<>(); \\n    static int[][] memo = new int[15][5000];\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        int m = cost.get(0).size();\\n        for (int j = 0; j < m; j++) {\\n            int min = Integer.MAX_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                min = Math.min(min, cost.get(i).get(j));\\n            }\\n            map.put(j, min);\\n        }\\n        for (int i = 0; i < 15; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return dp(cost, n, m, 0, 0);\\n    }\\n    private static int dp(List<List<Integer>> cost, int n, int m, int index, int mask) {\\n        if (memo[index][mask] != -1) {\\n            return memo[index][mask];\\n        }\\n        if (index == n) {\\n            // We have connected all points from the first group to some points in second group.\\n            // now, if some point in second group is not connected to any point in first group, we can connect it greedily.\\n            int costToConnectRemaining = 0;\\n            for (int j = 0; j < m; j++) {\\n                if ((mask & (1 << j)) == 0) {\\n                    costToConnectRemaining += map.get(j);\\n                }\\n            }\\n            return memo[index][mask] = costToConnectRemaining;\\n        }\\n        int minCost = Integer.MAX_VALUE;\\n        // try to connect ith point from first group to any of the point in second group, such that cost is minimized.\\n        for (int j = 0; j < m; j++) {\\n            int newMask = mask | (1 << j);\\n            int tempCost = dp(cost, n, m, index + 1, newMask) + cost.get(index).get(j);\\n            minCost = Math.min(minCost, tempCost);\\n        }\\n        return memo[index][mask] = minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379410,
                "title": "c-recursion-memoization-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<int>>dp;\\n    \\n    \\n    int recurs(vector<vector<int>>& cost,vector<int>&v,int i,int mask)\\n    {\\n        \\n        if(dp[i][mask]!=-1)\\n            return dp[i][mask];\\n        \\n        if(i<cost.size())\\n        {\\n            int res=INT_MAX;\\n            for(int j=0;j<cost[0].size();j++)\\n                res=min(res,recurs(cost,v,i+1,(mask|(1<<j)))+cost[i][j]);\\n            return dp[i][mask]=res;\\n        }\\n        else\\n        {\\n            int res=0;\\n            for(int  j=0;j<cost[0].size();j++)\\n                res+=v[j]*(!(mask&(1<<j)));\\n            return dp[i][mask]=res;   \\n        }\\n    }\\n    \\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        \\n        dp.resize(cost.size()+1,vector<int>(5000,-1));\\n        \\n        vector<int>v(cost[0].size(),0);\\n        \\n        for(int j=0;j<cost[0].size();j++)\\n        {\\n            int m=INT_MAX;\\n            for(int i=0;i<cost.size();i++)\\n                 m=min(m,cost[i][j]);\\n            v[j]=m;\\n        }\\n        \\n        \\n        return recurs(cost,v,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<int>>dp;\\n    \\n    \\n    int recurs(vector<vector<int>>& cost,vector<int>&v,int i,int mask)\\n    {\\n        \\n        if(dp[i][mask]!=-1)\\n            return dp[i][mask];\\n        \\n        if(i<cost.size())\\n        {\\n            int res=INT_MAX;\\n            for(int j=0;j<cost[0].size();j++)\\n                res=min(res,recurs(cost,v,i+1,(mask|(1<<j)))+cost[i][j]);\\n            return dp[i][mask]=res;\\n        }\\n        else\\n        {\\n            int res=0;\\n            for(int  j=0;j<cost[0].size();j++)\\n                res+=v[j]*(!(mask&(1<<j)));\\n            return dp[i][mask]=res;   \\n        }\\n    }\\n    \\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        \\n        dp.resize(cost.size()+1,vector<int>(5000,-1));\\n        \\n        vector<int>v(cost[0].size(),0);\\n        \\n        for(int j=0;j<cost[0].size();j++)\\n        {\\n            int m=INT_MAX;\\n            for(int i=0;i<cost.size();i++)\\n                 m=min(m,cost[i][j]);\\n            v[j]=m;\\n        }\\n        \\n        \\n        return recurs(cost,v,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114805,
                "title": "python-bfs-with-heapq-and-bit-tricks-90ms-beats-100",
                "content": "The special size handling at the top makes things a bit faster; taking all the zero-cost edges before BFS gives about 50% speed boost as well, although the code still beats 100% without those.\\n\\nThere are 3 optimizations over other BFS or DFS solutions that are big:\\n1. ```if first_mask != mask_i: ``` splits the case where the first group is matched, so we can greedily take the minimum cost edge for each second group vertex and add a \\'fully matched\\' entry to the queue.\\n2. ```i = ((first_mask + 1) & (-first_mask - 1)) ``` looks crazy if you\\'ve never seen it. This sets i to the least significant zero bit of first_mask. I highly suggest checking out Fenwick trees, since their implementation uses this trick. This works because: (x & -x) gives you the least significant bit of x, AND the LSB of x+1 is the first zero bit of x.\\n3. There are two types of edges we consider adding if we\\'ve chosen a vertex i in the first group: Edges (i, j) where j is also unmatched, or edges (i, j) where cost[i][j] is the smallest cost in row cost[i]\\n\\nFull code:\\n\\n```python\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tsize_i, size_j = len(cost), len(cost[0])\\n\\n\\t# Optimizations if we have <=2 columns\\n\\tif size_j == 1:\\n\\t\\treturn sum(row[0] for row in cost)\\n\\tif size_j == 2:\\n\\t\\ttot = min(cost[0])\\n\\t\\tused = (1 if tot==cost[0][0] else 2)  # bitmask for which column we\\'ve used\\n\\t\\tmin_extra = max(cost[0]) - tot  # extra cost to use the max value in this row\\n\\n\\t\\tfor j in range(1, size_i):\\n\\t\\t\\tmin_in_row = min(cost[j])\\n\\t\\t\\ttot += min_in_row\\n\\t\\t\\tmin_extra = min(min_in_row, max(cost[j])-min_in_row)\\n\\t\\t\\tused |= (1 if min_in_row == cost[j][0] else 2)\\n\\n\\t\\tif used == 3:  # used both cols already\\n\\t\\t\\treturn tot\\n\\t\\telse:  # One row needs to use a non-min element\\n\\t\\t\\treturn tot+min_extra\\n\\n\\tmask_i = (1 << size_i) - 1\\n\\tmask_j = (1 << size_j) - 1\\n\\tfully_connected = (mask_i, mask_j)\\n\\n\\tstart_row, start_col = 0, 0\\n\\tmin_by_col = [min([cost[i][col] for i in range(size_i)]) for col in range(size_j)] # Min value by column\\n\\n\\t# Always take any cost 0 edges\\n\\tfor j in range(size_j):\\n\\t\\tif min_by_col[j] == 0:\\n\\t\\t\\tstart_col += (1 << j)\\n\\tmin_by_row = [min(row) for row in cost]\\n\\tfor i in range(size_i):\\n\\t\\tif min_by_row[i] == 0:\\n\\t\\t\\tstart_row += (1 << i)\\n\\n\\tvisited = set()\\n\\tQ = [(0, start_row, start_col)]\\n\\n\\theapqpop = heapq.heappop\\n\\theapqpush = heapq.heappush\\n\\twhile True:\\n\\t\\ttotal_cost, first_mask, second_mask = heapqpop(Q)\\n\\n\\t\\tif (first_mask, second_mask) == fully_connected:\\n\\t\\t\\treturn total_cost\\n\\n\\t\\tif (first_mask, second_mask) in visited:\\n\\t\\t\\tcontinue\\n\\n\\t\\tvisited.add((first_mask, second_mask))\\n\\n\\t\\tif first_mask != mask_i:\\n\\t\\t\\ti = ((first_mask + 1) & (-first_mask - 1)) # Get the smallest unset bit of first_mask\\n\\t\\t\\tfirst_mask += i\\n\\t\\t\\ti = i.bit_length() - 1  # Convert bit to index\\n\\t\\t\\tshifted = 1\\n\\t\\t\\tfor j in range(size_j):\\n\\t\\t\\t\\tif (second_mask & shifted) == 0:  # If jth col is currently edgeless\\n\\t\\t\\t\\t\\theapqpush(Q, (total_cost + cost[i][j], first_mask, second_mask + shifted))\\n\\t\\t\\t\\telif cost[i][j] == min_by_row[i]:  # Or else (i,j) is i\\'s minimum weight edge\\n\\t\\t\\t\\t\\theapqpush(Q, (total_cost + min_by_row[i], first_mask, second_mask))\\n\\t\\t\\t\\tshifted += shifted\\n\\n\\t\\telse:  # group 1 all matched, find cost to fill rest of the graph\\n\\t\\t\\tshifted = 1\\n\\t\\t\\tfor j in range(size_j):\\n\\t\\t\\t\\tif (second_mask & shifted) == 0:\\n\\t\\t\\t\\t\\ttotal_cost += min_by_col[j]\\n\\t\\t\\t\\tshifted += shifted\\n\\t\\t\\theapqpush(Q, (total_cost, mask_i, mask_j))\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```if first_mask != mask_i: ```\n```i = ((first_mask + 1) & (-first_mask - 1)) ```\n```python\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tsize_i, size_j = len(cost), len(cost[0])\\n\\n\\t# Optimizations if we have <=2 columns\\n\\tif size_j == 1:\\n\\t\\treturn sum(row[0] for row in cost)\\n\\tif size_j == 2:\\n\\t\\ttot = min(cost[0])\\n\\t\\tused = (1 if tot==cost[0][0] else 2)  # bitmask for which column we\\'ve used\\n\\t\\tmin_extra = max(cost[0]) - tot  # extra cost to use the max value in this row\\n\\n\\t\\tfor j in range(1, size_i):\\n\\t\\t\\tmin_in_row = min(cost[j])\\n\\t\\t\\ttot += min_in_row\\n\\t\\t\\tmin_extra = min(min_in_row, max(cost[j])-min_in_row)\\n\\t\\t\\tused |= (1 if min_in_row == cost[j][0] else 2)\\n\\n\\t\\tif used == 3:  # used both cols already\\n\\t\\t\\treturn tot\\n\\t\\telse:  # One row needs to use a non-min element\\n\\t\\t\\treturn tot+min_extra\\n\\n\\tmask_i = (1 << size_i) - 1\\n\\tmask_j = (1 << size_j) - 1\\n\\tfully_connected = (mask_i, mask_j)\\n\\n\\tstart_row, start_col = 0, 0\\n\\tmin_by_col = [min([cost[i][col] for i in range(size_i)]) for col in range(size_j)] # Min value by column\\n\\n\\t# Always take any cost 0 edges\\n\\tfor j in range(size_j):\\n\\t\\tif min_by_col[j] == 0:\\n\\t\\t\\tstart_col += (1 << j)\\n\\tmin_by_row = [min(row) for row in cost]\\n\\tfor i in range(size_i):\\n\\t\\tif min_by_row[i] == 0:\\n\\t\\t\\tstart_row += (1 << i)\\n\\n\\tvisited = set()\\n\\tQ = [(0, start_row, start_col)]\\n\\n\\theapqpop = heapq.heappop\\n\\theapqpush = heapq.heappush\\n\\twhile True:\\n\\t\\ttotal_cost, first_mask, second_mask = heapqpop(Q)\\n\\n\\t\\tif (first_mask, second_mask) == fully_connected:\\n\\t\\t\\treturn total_cost\\n\\n\\t\\tif (first_mask, second_mask) in visited:\\n\\t\\t\\tcontinue\\n\\n\\t\\tvisited.add((first_mask, second_mask))\\n\\n\\t\\tif first_mask != mask_i:\\n\\t\\t\\ti = ((first_mask + 1) & (-first_mask - 1)) # Get the smallest unset bit of first_mask\\n\\t\\t\\tfirst_mask += i\\n\\t\\t\\ti = i.bit_length() - 1  # Convert bit to index\\n\\t\\t\\tshifted = 1\\n\\t\\t\\tfor j in range(size_j):\\n\\t\\t\\t\\tif (second_mask & shifted) == 0:  # If jth col is currently edgeless\\n\\t\\t\\t\\t\\theapqpush(Q, (total_cost + cost[i][j], first_mask, second_mask + shifted))\\n\\t\\t\\t\\telif cost[i][j] == min_by_row[i]:  # Or else (i,j) is i\\'s minimum weight edge\\n\\t\\t\\t\\t\\theapqpush(Q, (total_cost + min_by_row[i], first_mask, second_mask))\\n\\t\\t\\t\\tshifted += shifted\\n\\n\\t\\telse:  # group 1 all matched, find cost to fill rest of the graph\\n\\t\\t\\tshifted = 1\\n\\t\\t\\tfor j in range(size_j):\\n\\t\\t\\t\\tif (second_mask & shifted) == 0:\\n\\t\\t\\t\\t\\ttotal_cost += min_by_col[j]\\n\\t\\t\\t\\tshifted += shifted\\n\\t\\t\\theapqpush(Q, (total_cost, mask_i, mask_j))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1057230,
                "title": "simple-bitmask",
                "content": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        \\n        \\n        min_j = [1e9]*len(cost[0])\\n        \\n        for i in range (0, len(cost)):\\n            for j in range (0, len(cost[0])):\\n                min_j[j] = min(min_j[j], cost[i][j])\\n        \\n                \\n        @lru_cache(None )\\n        def recurse (i, mask):\\n            \\n            if i >= len(cost):\\n                total = 0 \\n                for j in range (0, len(cost[0])):\\n                    if mask & (1 << j) == 0: \\n                        total += min_j[j]\\n                return total\\n            \\n            \\n            total = 1e9\\n            for j in range (0, len(cost[0])):\\n                mask_ = mask | (1 << j) \\n                total = min(total, cost[i][j] + recurse(i+1, mask_))\\n            \\n            return total\\n        \\n        return recurse (0, 0)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        \\n        \\n        min_j = [1e9]*len(cost[0])\\n        \\n        for i in range (0, len(cost)):\\n            for j in range (0, len(cost[0])):\\n                min_j[j] = min(min_j[j], cost[i][j])\\n        \\n                \\n        @lru_cache(None )\\n        def recurse (i, mask):\\n            \\n            if i >= len(cost):\\n                total = 0 \\n                for j in range (0, len(cost[0])):\\n                    if mask & (1 << j) == 0: \\n                        total += min_j[j]\\n                return total\\n            \\n            \\n            total = 1e9\\n            for j in range (0, len(cost[0])):\\n                mask_ = mask | (1 << j) \\n                total = min(total, cost[i][j] + recurse(i+1, mask_))\\n            \\n            return total\\n        \\n        return recurse (0, 0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 932796,
                "title": "java-solution-dp-bitmask",
                "content": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size();\\n        int n = cost.get(0).size();\\n        int[][] f = new int[m + 1][1 << n];\\n        for (int i = 0; i <= m; i++) {\\n            Arrays.fill(f[i], Integer.MAX_VALUE / 2);\\n        }\\n        f[0][0] = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int s = 0; s < 1 << n; s++) {\\n                for (int j = 0; j < n; j++) {\\n                    f[i + 1][s | 1 << j] = Math.min(\\n                        f[i + 1][s | 1 << j], \\n                        Math.min(\\n                            f[i + 1][s] + cost.get(i).get(j), \\n                            f[i][s] + cost.get(i).get(j)\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n        return f[m][(1 << n) - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size();\\n        int n = cost.get(0).size();\\n        int[][] f = new int[m + 1][1 << n];\\n        for (int i = 0; i <= m; i++) {\\n            Arrays.fill(f[i], Integer.MAX_VALUE / 2);\\n        }\\n        f[0][0] = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int s = 0; s < 1 << n; s++) {\\n                for (int j = 0; j < n; j++) {\\n                    f[i + 1][s | 1 << j] = Math.min(\\n                        f[i + 1][s | 1 << j], \\n                        Math.min(\\n                            f[i + 1][s] + cost.get(i).get(j), \\n                            f[i][s] + cost.get(i).get(j)\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n        return f[m][(1 << n) - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880518,
                "title": "o-s1-3-s2-s2-using-bitmask-and-submask-trick",
                "content": "Quite astonished by people who managed to give O(2^{s2}*s1*s2) solutions. That\\'s worth reading.\\n\\nBut, here is one solution which requires less thinking, though I have to use submask trick introduced https://cp-algorithms.com/algebra/all-submasks.html. It can enumerate the submasks of all masks in O(3^n) time, not O(2^n*2^n)=O(4^n).\\n\\nThe idea is we maintain the min cost to cover each subset of S2. Initially, it\\'s {0,INF,INF,...}.\\nOnce we have the answer for first i elements of S1, we compute the answer for first i + 1 elements. We basically need to cover the diff of the new larger subset and the old smaller subset. Hence, for each new mask, we need to enumerate all submasks, this is where the submask enumeration trick comes in.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int s1 = cost.size(), s2 = cost[0].size();\\n        int INF=1E9;\\n        vector<int> mask_dp((1<<s2),INF);\\n        mask_dp[0] = 0;\\n        for (int i = 0; i < s1; ++i) {\\n            vector<int> new_mask_dp((1<<s2),INF);\\n            for (int new_mask = 0; new_mask < (1 << s2); ++new_mask) {\\n                for(int mask = new_mask;;mask=(mask-1)&new_mask){\\n                    int totcost = 0;\\n                    if (new_mask == mask) {\\n                        totcost = INF;\\n                        for (int j = 0; j < s2; ++j) {\\n                            if (mask & (1<<j)){\\n                                totcost = min(totcost, cost[i][j]);\\n                            }\\n                        }\\n                    }else{\\n                    for (int j = 0; j < s2; ++j) {\\n                        if (mask & (1 << j)) {\\n                            if ((new_mask & (1 << j)) == 0) {\\n                                totcost = INF;\\n                                break;\\n                            }\\n                        } else if (new_mask & (1 << j)) {\\n                            totcost += cost[i][j];\\n                        }\\n                    }\\n                    }\\n                    new_mask_dp[new_mask] = min(new_mask_dp[new_mask], mask_dp[mask] + totcost);\\n                    if(mask==0)break;\\n                }\\n            }\\n            mask_dp=new_mask_dp;\\n        }\\n        return mask_dp[(1<<s2)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int s1 = cost.size(), s2 = cost[0].size();\\n        int INF=1E9;\\n        vector<int> mask_dp((1<<s2),INF);\\n        mask_dp[0] = 0;\\n        for (int i = 0; i < s1; ++i) {\\n            vector<int> new_mask_dp((1<<s2),INF);\\n            for (int new_mask = 0; new_mask < (1 << s2); ++new_mask) {\\n                for(int mask = new_mask;;mask=(mask-1)&new_mask){\\n                    int totcost = 0;\\n                    if (new_mask == mask) {\\n                        totcost = INF;\\n                        for (int j = 0; j < s2; ++j) {\\n                            if (mask & (1<<j)){\\n                                totcost = min(totcost, cost[i][j]);\\n                            }\\n                        }\\n                    }else{\\n                    for (int j = 0; j < s2; ++j) {\\n                        if (mask & (1 << j)) {\\n                            if ((new_mask & (1 << j)) == 0) {\\n                                totcost = INF;\\n                                break;\\n                            }\\n                        } else if (new_mask & (1 << j)) {\\n                            totcost += cost[i][j];\\n                        }\\n                    }\\n                    }\\n                    new_mask_dp[new_mask] = min(new_mask_dp[new_mask], mask_dp[mask] + totcost);\\n                    if(mask==0)break;\\n                }\\n            }\\n            mask_dp=new_mask_dp;\\n        }\\n        return mask_dp[(1<<s2)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857938,
                "title": "c-dp-using-bit-masking-easy-to-understand",
                "content": "the idea is same as https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/discuss/855041/C%2B%2BPython-DP-using-mask\\n\\n\\n```\\nconst int INF = 1e9;\\n\\ntemplate <typename T>\\ninline void change_min(T& a, T b) {\\n  if (a > b) {\\n    a = b;\\n  }\\n}\\n\\nclass Solution {\\n public:\\n  int connectTwoGroups(vector<vector<int>>& cost) {\\n    int N1 = cost.size();\\n    int N2 = cost[0].size();\\n\\n    vector<int> min_cost_from_two(N2, INF);\\n\\n    for (int i1 = 0; i1 < N1; ++i1) {\\n      for (int i2 = 0; i2 < N2; ++i2) {\\n        change_min(min_cost_from_two[i2], cost[i1][i2]);\\n      }\\n    }\\n\\n    vector<int> dp(1 << N2, INF);\\n    dp[0] = 0;\\n\\n    for (int i1 = 0; i1 < N1; ++i1) {\\n      vector<int> next_dp(1 << N2, INF);\\n\\n      for (int bit = 0; bit < 1 << N2; ++bit) {\\n        for (int i2 = 0; i2 < N2; ++i2) {\\n          change_min(next_dp[bit | (1 << i2)], dp[bit] + cost[i1][i2]);\\n        }\\n      }\\n\\n      swap(dp, next_dp);\\n    }\\n\\n    int res = INF;\\n\\n    for (int bit = 0; bit < 1 << N2; ++bit) {\\n      int r = dp[bit];\\n\\n      for (int i2 = 0; i2 < N2; ++i2) {\\n        if ((bit & (1 << i2)) == 0) {\\n          r += min_cost_from_two[i2];\\n        }\\n      }\\n\\n      change_min(res, r);\\n    }\\n\\n    return res;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nconst int INF = 1e9;\\n\\ntemplate <typename T>\\ninline void change_min(T& a, T b) {\\n  if (a > b) {\\n    a = b;\\n  }\\n}\\n\\nclass Solution {\\n public:\\n  int connectTwoGroups(vector<vector<int>>& cost) {\\n    int N1 = cost.size();\\n    int N2 = cost[0].size();\\n\\n    vector<int> min_cost_from_two(N2, INF);\\n\\n    for (int i1 = 0; i1 < N1; ++i1) {\\n      for (int i2 = 0; i2 < N2; ++i2) {\\n        change_min(min_cost_from_two[i2], cost[i1][i2]);\\n      }\\n    }\\n\\n    vector<int> dp(1 << N2, INF);\\n    dp[0] = 0;\\n\\n    for (int i1 = 0; i1 < N1; ++i1) {\\n      vector<int> next_dp(1 << N2, INF);\\n\\n      for (int bit = 0; bit < 1 << N2; ++bit) {\\n        for (int i2 = 0; i2 < N2; ++i2) {\\n          change_min(next_dp[bit | (1 << i2)], dp[bit] + cost[i1][i2]);\\n        }\\n      }\\n\\n      swap(dp, next_dp);\\n    }\\n\\n    int res = INF;\\n\\n    for (int bit = 0; bit < 1 << N2; ++bit) {\\n      int r = dp[bit];\\n\\n      for (int i2 = 0; i2 < N2; ++i2) {\\n        if ((bit & (1 << i2)) == 0) {\\n          r += min_cost_from_two[i2];\\n        }\\n      }\\n\\n      change_min(res, r);\\n    }\\n\\n    return res;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855333,
                "title": "python-dp-top-down",
                "content": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        import functools\\n        \\n        src_size = len(cost)\\n        tgt_size = len(cost[0])\\n        tgt_mask = (1 << tgt_size) - 1\\n        INFTY = 1e19\\n        \\n        @functools.lru_cache(None)\\n        def find(n: int, taken: bool, idx: int, mask: int) -> int:\\n            if n == src_size:\\n                return INFTY if (mask & tgt_mask) != tgt_mask else 0\\n            if idx == tgt_size:\\n                return INFTY if not taken else find(n + 1, False, 0, mask)\\n            \\n            curr = find(n, taken, idx + 1, mask)\\n            sub_cost = find(n, True, idx + 1, (mask | (1 << idx)))\\n            if sub_cost < INFTY:\\n                curr = min(cost[n][idx] + sub_cost, curr)\\n            return curr\\n        \\n        return find(0, False, 0, 0)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        import functools\\n        \\n        src_size = len(cost)\\n        tgt_size = len(cost[0])\\n        tgt_mask = (1 << tgt_size) - 1\\n        INFTY = 1e19\\n        \\n        @functools.lru_cache(None)\\n        def find(n: int, taken: bool, idx: int, mask: int) -> int:\\n            if n == src_size:\\n                return INFTY if (mask & tgt_mask) != tgt_mask else 0\\n            if idx == tgt_size:\\n                return INFTY if not taken else find(n + 1, False, 0, mask)\\n            \\n            curr = find(n, taken, idx + 1, mask)\\n            sub_cost = find(n, True, idx + 1, (mask | (1 << idx)))\\n            if sub_cost < INFTY:\\n                curr = min(cost[n][idx] + sub_cost, curr)\\n            return curr\\n        \\n        return find(0, False, 0, 0)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 855173,
                "title": "simple-c-dp-solution",
                "content": "```\\n public class Solution\\n    {\\n        private void Helper(IList<IList<int>> cost, int?[,] dp, int idx, int maskRight)\\n        {\\n            checked\\n            {\\n\\n                if (dp[idx, maskRight].HasValue)\\n                {\\n                    return;\\n                }\\n\\n                int n = cost.Count;\\n                int m = cost[0].Count;\\n\\n                int powM = 1 << m;\\n\\n                if (idx == n && maskRight == powM - 1)\\n                {\\n                    dp[idx, maskRight] = 0;\\n                    return;\\n                }\\n\\n                if (idx == n && maskRight != powM - 1)\\n                {\\n                    dp[idx, maskRight] = int.MaxValue;\\n                    return;\\n                }\\n\\n                int res = int.MaxValue;\\n\\n                for (int j = 0; j < m; j++)\\n                {\\n                    var newRightMask = maskRight | (1 << j);\\n                    var costThis = cost[idx][j];\\n                    Helper(cost, dp, idx + 1, newRightMask);\\n\\n                    var inner = dp[idx + 1, newRightMask].Value;\\n                    if (inner != int.MaxValue)\\n                    {\\n                        res = Math.Min(res, costThis + inner);\\n                    }\\n\\n                    if (newRightMask != maskRight)\\n                    {\\n                        Helper(cost, dp, idx, newRightMask);\\n                        var cand = dp[idx, newRightMask].Value;\\n                        if (cand != int.MaxValue)\\n                        {\\n                            res = Math.Min(res, costThis + cand);\\n                        }\\n                    }\\n                }\\n\\n\\n                dp[idx, maskRight] = res;\\n            }\\n        }\\n\\n        public int ConnectTwoGroups(IList<IList<int>> cost)\\n        {\\n            int n = cost.Count;\\n            int m = cost[0].Count;\\n\\n            int powM = 1 << m;\\n\\n            int?[,] dp = new int?[n + 1,powM];\\n            Helper(cost, dp, 0, 0);\\n            return dp[0, 0].Value;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n public class Solution\\n    {\\n        private void Helper(IList<IList<int>> cost, int?[,] dp, int idx, int maskRight)\\n        {\\n            checked\\n            {\\n\\n                if (dp[idx, maskRight].HasValue)\\n                {\\n                    return;\\n                }\\n\\n                int n = cost.Count;\\n                int m = cost[0].Count;\\n\\n                int powM = 1 << m;\\n\\n                if (idx == n && maskRight == powM - 1)\\n                {\\n                    dp[idx, maskRight] = 0;\\n                    return;\\n                }\\n\\n                if (idx == n && maskRight != powM - 1)\\n                {\\n                    dp[idx, maskRight] = int.MaxValue;\\n                    return;\\n                }\\n\\n                int res = int.MaxValue;\\n\\n                for (int j = 0; j < m; j++)\\n                {\\n                    var newRightMask = maskRight | (1 << j);\\n                    var costThis = cost[idx][j];\\n                    Helper(cost, dp, idx + 1, newRightMask);\\n\\n                    var inner = dp[idx + 1, newRightMask].Value;\\n                    if (inner != int.MaxValue)\\n                    {\\n                        res = Math.Min(res, costThis + inner);\\n                    }\\n\\n                    if (newRightMask != maskRight)\\n                    {\\n                        Helper(cost, dp, idx, newRightMask);\\n                        var cand = dp[idx, newRightMask].Value;\\n                        if (cand != int.MaxValue)\\n                        {\\n                            res = Math.Min(res, costThis + cand);\\n                        }\\n                    }\\n                }\\n\\n\\n                dp[idx, maskRight] = res;\\n            }\\n        }\\n\\n        public int ConnectTwoGroups(IList<IList<int>> cost)\\n        {\\n            int n = cost.Count;\\n            int m = cost[0].Count;\\n\\n            int powM = 1 << m;\\n\\n            int?[,] dp = new int?[n + 1,powM];\\n            Helper(cost, dp, 0, 0);\\n            return dp[0, 0].Value;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855079,
                "title": "dp-bitmasking-top-down-approach",
                "content": "```\\n\\tdef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n    \\n        \\n        @lru_cache(None)\\n        def helper(i, rem):   # rem represents cols which we have not matched yet, i represents current index (row)\\n            if i==rows:\\n                ans = 0\\n                for j in range(cols):\\n                    if not rem & 1<<j:          # check colums whose bits are not set\\n                        m = float(\\'inf\\')\\n                        for r in range(0, rows):\\n                            m = min(m, cost[r][int(j)])\\n                        ans += m\\n                return ans\\n            \\n            ans = float(\\'inf\\')\\n            for j in range(0, cols):       # try matching ith row with any col\\n                nrem = rem | 1<<j           # when a column is matched, set its bit\\n                ans = min(ans, cost[i][j]+helper(i+1, nrem))\\n            \\n            return ans\\n        \\n        \\n        return helper(0, 0)",
                "solutionTags": [],
                "code": "```\\n\\tdef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n    \\n        \\n        @lru_cache(None)\\n        def helper(i, rem):   # rem represents cols which we have not matched yet, i represents current index (row)\\n            if i==rows:\\n                ans = 0\\n                for j in range(cols):\\n                    if not rem & 1<<j:          # check colums whose bits are not set\\n                        m = float(\\'inf\\')\\n                        for r in range(0, rows):\\n                            m = min(m, cost[r][int(j)])\\n                        ans += m\\n                return ans\\n            \\n            ans = float(\\'inf\\')\\n            for j in range(0, cols):       # try matching ith row with any col\\n                nrem = rem | 1<<j           # when a column is matched, set its bit\\n                ans = min(ans, cost[i][j]+helper(i+1, nrem))\\n            \\n            return ans\\n        \\n        \\n        return helper(0, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 4050908,
                "title": "bitsmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int size1 = cost.size();\\n        int size2 = cost[0].size();\\n        \\n        vector<vector<int>> dp(size1, vector<int>(1 << size2, -1));\\n        \\n        function<int(int, int)> dfs = [&](int p1, int mask) -> int {\\n            if (p1 == size1) {\\n                int total_cost = 0;\\n                for (int p2 = 0; p2 < size2; ++p2) {\\n                    if (!(mask & (1 << p2))) {\\n                        int min_cost = INT_MAX;\\n                        for (int p1 = 0; p1 < size1; ++p1) {\\n                            min_cost = min(min_cost, cost[p1][p2]);\\n                        }\\n                        total_cost += min_cost;\\n                    }\\n                }\\n                cout<<mask<<\" \"<<total_cost<<endl;\\n                return total_cost;\\n            }\\n            \\n            if (dp[p1][mask] != -1) {\\n                return dp[p1][mask];\\n            }\\n            \\n            int result = INT_MAX;\\n            for (int p2 = 0; p2 < size2; ++p2) {\\n                result = min(result, cost[p1][p2] + dfs(p1 + 1, mask | (1 << p2)));\\n            }\\n            \\n            dp[p1][mask] = result;\\n            return result;\\n        };\\n        \\n        return dfs(0, 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int size1 = cost.size();\\n        int size2 = cost[0].size();\\n        \\n        vector<vector<int>> dp(size1, vector<int>(1 << size2, -1));\\n        \\n        function<int(int, int)> dfs = [&](int p1, int mask) -> int {\\n            if (p1 == size1) {\\n                int total_cost = 0;\\n                for (int p2 = 0; p2 < size2; ++p2) {\\n                    if (!(mask & (1 << p2))) {\\n                        int min_cost = INT_MAX;\\n                        for (int p1 = 0; p1 < size1; ++p1) {\\n                            min_cost = min(min_cost, cost[p1][p2]);\\n                        }\\n                        total_cost += min_cost;\\n                    }\\n                }\\n                cout<<mask<<\" \"<<total_cost<<endl;\\n                return total_cost;\\n            }\\n            \\n            if (dp[p1][mask] != -1) {\\n                return dp[p1][mask];\\n            }\\n            \\n            int result = INT_MAX;\\n            for (int p2 = 0; p2 < size2; ++p2) {\\n                result = min(result, cost[p1][p2] + dfs(p1 + 1, mask | (1 << p2)));\\n            }\\n            \\n            dp[p1][mask] = result;\\n            return result;\\n        };\\n        \\n        return dfs(0, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4038898,
                "title": "easy-to-understand-c-bitmask-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int g1ind,int mask,vector<vector<int>>& cost,vector<int> &g2cost,int n,int m,vector<vector<int>> &dp){\\n        if(g1ind==n){\\n            int s=0;\\n            for(int j=0;j<m;j++){\\n                if((mask & (1<<j))==0){\\n                    s+=g2cost[j];\\n\\n                }\\n            }\\n            return s;\\n        }\\n        if(dp[g1ind][mask]!=-1)return dp[g1ind][mask];\\n\\n        int sumcost=INT_MAX;\\n        for(int j=0;j<m;j++){\\n                int pick=cost[g1ind][j];\\n                sumcost=min(sumcost,pick+dfs(g1ind+1,mask | (1<<j),cost,g2cost,n,m,dp));\\n        }\\n        return dp[g1ind][mask]=sumcost;\\n\\n    }\\n\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        vector<int> g2cost(m,500);\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i<n;i++){\\n                g2cost[j]=min(g2cost[j],cost[i][j]);\\n            }\\n        }\\n        vector<vector<int>> dp(n+1,vector<int>((1<<m),-1));\\n    //    dfs(0,0,cost,g2cost,n,m);\\n   //     for(auto it:g2cost)cout<<it<<\" \";\\n        return dfs(0,0,cost,g2cost,n,m,dp);;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int g1ind,int mask,vector<vector<int>>& cost,vector<int> &g2cost,int n,int m,vector<vector<int>> &dp){\\n        if(g1ind==n){\\n            int s=0;\\n            for(int j=0;j<m;j++){\\n                if((mask & (1<<j))==0){\\n                    s+=g2cost[j];\\n\\n                }\\n            }\\n            return s;\\n        }\\n        if(dp[g1ind][mask]!=-1)return dp[g1ind][mask];\\n\\n        int sumcost=INT_MAX;\\n        for(int j=0;j<m;j++){\\n                int pick=cost[g1ind][j];\\n                sumcost=min(sumcost,pick+dfs(g1ind+1,mask | (1<<j),cost,g2cost,n,m,dp));\\n        }\\n        return dp[g1ind][mask]=sumcost;\\n\\n    }\\n\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        vector<int> g2cost(m,500);\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i<n;i++){\\n                g2cost[j]=min(g2cost[j],cost[i][j]);\\n            }\\n        }\\n        vector<vector<int>> dp(n+1,vector<int>((1<<m),-1));\\n    //    dfs(0,0,cost,g2cost,n,m);\\n   //     for(auto it:g2cost)cout<<it<<\" \";\\n        return dfs(0,0,cost,g2cost,n,m,dp);;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4035650,
                "title": "c-python-bitmask-dp-solution-with-explanation",
                "content": "\\n### bitmask dp\\ndp[i][mask] is min cost when first i element of group n (row) and bitmask of group m (column) have matched, a bit of 1 means a element is matched.\\n\\nWe can use i-th element to match a element in the other group.\\n\\nWe have 3 choice,\\n\\nif i-th element have matched, we can match it again with a element is not matched, \\ndp[i][mask ^ (1 << j)] + cost[i][j] where mask ^ (1 << j) is to remove a matched element.\\n\\nif i-th element is not matched, we can match it with a element is not matched, \\ndp[i-1][mask ^ (1 << j)] + cost[i][j] where mask ^ (1 << j) is to remove a matched element.\\n\\nor, match it with a element have matched, \\ndp[i-1][mask] + cost[i][j].\\n\\nAnd choose min cost.\\n\\nWe can use 2 1-d arrays to indicate dp[i] and dp[i-1].\\n\\ntc is O(n * m * 2^m), sc is O(2^m)\\ndp[-1][0] = 0, dp[-1][.] = inf.\\ndp[i][.] = inf.\\n### python\\n```python\\ninf = int(1e9+7)\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m = len(cost), len(cost[0])\\n        dp_0 = [inf] * (1 << m)\\n        dp_1 = [inf] * (1 << m)\\n        dp_0[0] = 0\\n        for i in range(n):\\n            for mask in range(1, 1 << m):\\n                for j in range(m):\\n                    if mask >> j & 1:\\n                        dp_1[mask] = min(dp_1[mask], dp_0[mask ^ (1 << j)] + cost[i][j], dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])\\n            dp_0, dp_1 = dp_1, dp_0\\n            for mask in range(1 << m): dp_1[mask] = inf\\n        return dp_0[(1 << m) - 1]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size(), m = cost[0].size();\\n        vector<int> dp_0 (1 << m, 1e9+7), dp_1 (1 << m, 1e9+7);\\n        dp_0[0] = 0;\\n        for (int i = 0; i < n; i+=1) {\\n            for (int mask = 1; mask < 1 << m; mask+=1) {\\n                for (int j = 0; j < m; j+=1) {\\n                    if (mask >> j & 1)\\n                        dp_1[mask] = min(dp_1[mask], min(dp_0[mask ^ (1 << j)] + cost[i][j], min(dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])));\\n                }\\n            }\\n            swap(dp_0, dp_1);\\n            for (int j = 0; j < 1 << m; j+=1) dp_1[j] = 1e9+7;\\n        }\\n        return dp_0[(1 << m) - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```python\\ninf = int(1e9+7)\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m = len(cost), len(cost[0])\\n        dp_0 = [inf] * (1 << m)\\n        dp_1 = [inf] * (1 << m)\\n        dp_0[0] = 0\\n        for i in range(n):\\n            for mask in range(1, 1 << m):\\n                for j in range(m):\\n                    if mask >> j & 1:\\n                        dp_1[mask] = min(dp_1[mask], dp_0[mask ^ (1 << j)] + cost[i][j], dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])\\n            dp_0, dp_1 = dp_1, dp_0\\n            for mask in range(1 << m): dp_1[mask] = inf\\n        return dp_0[(1 << m) - 1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size(), m = cost[0].size();\\n        vector<int> dp_0 (1 << m, 1e9+7), dp_1 (1 << m, 1e9+7);\\n        dp_0[0] = 0;\\n        for (int i = 0; i < n; i+=1) {\\n            for (int mask = 1; mask < 1 << m; mask+=1) {\\n                for (int j = 0; j < m; j+=1) {\\n                    if (mask >> j & 1)\\n                        dp_1[mask] = min(dp_1[mask], min(dp_0[mask ^ (1 << j)] + cost[i][j], min(dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])));\\n                }\\n            }\\n            swap(dp_0, dp_1);\\n            for (int j = 0; j < 1 << m; j+=1) dp_1[j] = 1e9+7;\\n        }\\n        return dp_0[(1 << m) - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031976,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec (int ind,int mask,vector<vector<int>>& cost,vector<vector<int>>&dp,vector<int>&mini)\\n    {\\n       if (dp[ind][mask]!=-1) return dp[ind][mask];\\n       int res=ind>=cost.size()?0:1e8;\\n       if (ind>=cost.size())\\n       {\\n           for (int j=0;j<cost[0].size();j++)\\n           {\\n               if ((mask&(1<<j))==0)\\n               {\\n                   res+=mini[j];\\n               }\\n           }\\n       }\\n       else {\\n           for (int j=0;j<cost[0].size();j++)\\n           {\\n               res=min(res,cost[ind][j]+rec(ind+1,mask | (1<<j),cost,dp,mini));\\n           }\\n       }\\n       return dp[ind][mask]=res;\\n\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        vector<vector<int>>dp(13,vector<int>(4096,-1));\\n        vector<int>mini(cost[0].size(),INT_MAX);\\n        for (int j=0;j<cost[0].size();j++)\\n        {\\n            for (int i=0;i<cost.size();i++)\\n            {\\n                mini[j]=min(mini[j],cost[i][j]);\\n            }\\n        }\\n        return rec(0,0,cost,dp,mini);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec (int ind,int mask,vector<vector<int>>& cost,vector<vector<int>>&dp,vector<int>&mini)\\n    {\\n       if (dp[ind][mask]!=-1) return dp[ind][mask];\\n       int res=ind>=cost.size()?0:1e8;\\n       if (ind>=cost.size())\\n       {\\n           for (int j=0;j<cost[0].size();j++)\\n           {\\n               if ((mask&(1<<j))==0)\\n               {\\n                   res+=mini[j];\\n               }\\n           }\\n       }\\n       else {\\n           for (int j=0;j<cost[0].size();j++)\\n           {\\n               res=min(res,cost[ind][j]+rec(ind+1,mask | (1<<j),cost,dp,mini));\\n           }\\n       }\\n       return dp[ind][mask]=res;\\n\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        vector<vector<int>>dp(13,vector<int>(4096,-1));\\n        vector<int>mini(cost[0].size(),INT_MAX);\\n        for (int j=0;j<cost[0].size();j++)\\n        {\\n            for (int i=0;i<cost.size();i++)\\n            {\\n                mini[j]=min(mini[j],cost[i][j]);\\n            }\\n        }\\n        return rec(0,0,cost,dp,mini);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848233,
                "title": "lru-cache-for-speed-memo-if-memory-pick-your-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA recursive solution can work well if you start to break down what the problem asks in concrete steps \\n\\nFor any graph of costs, there exists a min cost per column \\nIf we know the min cost per column, then we can map out our cheapest connection via graph exploration \\n\\nThis is an iterative depth first based approach, and so needs memoization \\n\\nIf you have memory to spare, deepen as needed and use the lru cache. This will optimize time. If you don\\'t have memory to spare, deepen while storing results in a memo. This will optimize space. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet dimension of graphical space in rows and cols. \\nGet min value in column using zip and * to unpack cost into a min list\\nMake a memo \\n\\nUse lru cache if speed is important \\n\\ndfs takes a row index and bitmask \\n- if (rowindex, bitmask) in memo return that \\n- elif row index is rows, calc as described in approach and memoize\\n    - return memoized value  \\n- else calc min of cost at row index, col index + dfs(row index + 1, bitmask | (1 << col_index)) for col index in range cols and memoize \\n    - return memoized value \\n\\nTo solve, do dfs based approach from root of 0, 0 \\n\\n\\n# Complexity\\n- Time complexity : O(N log N)\\n    - We end up exploring subtrees of size N log N due to memoization \\n\\n\\n- Space complexity : O(N log N)\\n    - As above but for storage of results  \\n\\nOne interesting takeaway is that various memo values at the end of one of the top runs could have union find done on them to speed up valuations later on. This may be of interest to some. \\n\\nDetailed walkthrough of example 3 in the code. \\n\\n# Code\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        # set result as min cost in each cost set -> histogram intersection style \\n        min_value_in_column = [min(costs_i) for costs_i in zip(*cost)]\\n        self.memo = dict()\\n\\n        @lru_cache(None)\\n        def dfs(row_index, bitmask) : \\n            if (row_index, bitmask) in self.memo :\\n                return self.memo[(row_index, bitmask)] \\n            elif row_index == rows : \\n                # return sum of min values in column for col index not in bitmask  \\n                # bitmask & 1 << col_index == 0 -> least significant bit is 0 \\n                # this means that bitmask & (1 << col_i) match up -> this means we have this col index \\n                self.memo[(row_index, bitmask)] = sum(min_value_in_column[col_i] for col_i in range(cols) if not (bitmask & (1 << col_i)))\\n                return self.memo[(row_index, bitmask)]\\n            else : \\n                # otherwise, return minimum of cost at row index and col index + dfs(row_index + 1, mask union with (1 << col_index)) \\n                # which means, return cost found at row and col + dfs result of next row index if we join this col index to our bitmask (adds if not present) \\n                # which is done for col index in range cols \\n                # this means we take value at row and col and add to it the recursive value of the next row if we take the col index into the bitmask\\n                # this is done for each col index in range cols -> this finds the minimum then of this row item values plus next row items values recursively   \\n                self.memo[(row_index, bitmask)] = min(cost[row_index][col_index] + dfs(row_index + 1, bitmask | (1 << col_index)) for col_index in range(cols))\\n                return self.memo[(row_index, bitmask)]\\n        # from the first row index with an empty mask \\n        # go until the last row index where \\n            # along the way to the last row index \\n            # for each row index consider each col index elements value with each next row index to rows \\n                # where upon reaching the last row in this manner you return the sum of the minimal items \\n                    # for which you have selected such a mask as you go along \\n        \\'\\'\\'\\n            Example 3 \\n            result -> [2, 1, 1]\\n\\n            2   5   1       0 row index, 0 bitmask goes in, must find following \\n            3   4   7       find min of (2 + dfs(1, 1), 5 + dfs(1, 2), 1 + dfs(1, 4))\\n            8   1   2   ->  dfs(1, 1) -> find min (3 + dfs(2, 1), 4 + dfs(2, 3), 7 + dfs(2, 5))\\n            6   2   4           dfs(2, 1) -> find min (8 + dfs(3, 1), 1 + dfs(3, 3), 2 + dfs(3, 5))\\n            3   8   8               dfs(3, 1) -> find min (6 + dfs(4, 1), 2 + dfs(4, 3), 4 + dfs(4, 5))\\n                                        dfs(4, 1) -> find min (3 + 2, 8 + 2, 8 + 4)\\n                                            dfs(5, 1) -> for col 0, 1 has a value in col 0, so bitmask & (1 << col_i) is 1 -> so we skip this value. But other two we would get 0, so we add them for 2. \\n                                            dfs(5, 3) -> for col 1, b1 does not have value in col 1 which is like saying it does not have the second column -> add this value  -> result is 2 \\n                                            dfs(5, 5) -> as above for col 2 -> total is now 2 for the first, and 2 for the other two, total is 4\\n                                            dfs(5, 7) -> 0 \\n                                        dfs(4, 1) -> so our first result is 3 + 2 is 5 \\n                                        dfs(4, 2) -> min(3 + 2, 8 + dfs(5, 2), 8 + dfs(5, 6)) -> 5 \\n                                        dfs(4, 3) -> min(3 + dfs(5, 3), 8 + dfs(5, 3), 8 + dfs(5, 7)) -> min (3 + 2, 8 + 2, 8 + 0) -> result is 5\\n                                        dfs(4, 4) -> min(3 + dfs(5, 5), 8 + dfs(5, 4), 8 + dfs(5, 6)) -> 7\\n                                        dfs(4, 6) -> min(3 + dfs(5, 7), 8 + dfs(5, 6), 8 + dfs(5, 6)) -> result is 3\\n                                        dfs(4, 5) -> min(3 + dfs(5, 5), 8 + dfs(5, 7), 8 + dfs(5, 5)) -> min (3 + 4, 8 + 0, 8 + 4) -> result is 7\\n                                        dfs(4, 7) -> min(3 + dfs(5, 7),  8 + dfs(5, 7), 8 + dfs(5, 7)) -> min (3, 8, 8) -> 3 \\n                                    dfs(3, 1) -> min (6 + 5, 2 + 5, 4 + 7) -> 7 \\n                                    dfs(3, 2) -> min (6 + 5, 2 + 5, 4+3) -> 7\\n                                    dfs(3, 3) -> min (6 + dfs(4, 3), 2 + dfs(4, 3), 4 + dfs(4, 7))\\n                                              -> min (6 + 5, 2 + 5, 4 + 3) -> 7\\n                                    dfs(3, 4) -> min (6 + 7, 2 + 7, 4+3) -> 7 \\n                                    dfs(3, 5) -> min(6 + dfs(4, 5), 2 + dfs(4, 7), 4 + dfs(4, 5))\\n                                              -> min(6 + 7, 2 + 3, 4 + 7) -> 5\\n                                    dfs(3, 6) -> min(6 + 3, 2 + 3, 4 + 3) -> 5\\n                                    dfs(3, 7) -> min(6 + dfs(4, 7), 2 + dfs(4, 7), 4+dfs(4, 7))\\n                                              -> min(6 + 3, 2 + 3, 4 + 3) -> 5  \\n                                dfs(2, 1) -> (8 + 7, 1 + 7, 2 + 5) -> 7 \\n                                dfs(2, 3) -> find min (8 + dfs(3, 3), 1 + dfs(3, 3), 2 + dfs(3, 7))\\n                                          ->      min (8 + 7, 1 + 7, 2 + 5) -> 7\\n                                dfs(2, 4) -> (8 + 5, 1 + 5, 2 + 7) -> 6\\n                                dfs(2, 5) -> find min (8 + dfs(3, 5), 1 + dfs(3, 7), 2 + dfs(3, 5))\\n                                          ->      min (8 + 5, 1 + 5, 2 + 5) -> 6\\n                                dfs(2, 2)         min (8 + dfs(3, 3), 1 + dfs(3, 2), 2 + dfs(3, 6))\\n                                                  min (8 + 7, 1 + 7, 2 + 5) -> 7\\n                                dfs(2, 6) ->      min (8 + dfs(3, 7), 1 + dfs(3, 6), 2 + dfs(3, 6))\\n                                                  min (8 + 5, 1 + 5, 2 + 5) -> 6\\n                                dfs(2, 7) ->      min (8 + dfs(3, 7), 1 + dfs(3, 7), 2 + dfs(3, 7)) -> 6\\n                            dfs(1, 1) -> min(3 + 7, 4 + 7, 7 + 6) -> 10 \\n                        dfs(0, 0) -> min(2 + 10, 5 + dfs(1, 2), 1 + dfs(1, 4))\\n                            dfs(1, 2) -> min(3 + dfs(2, 3), 4 + dfs(2, 2), 7+ dfs(2, 6))\\n                                      -> min(3 + 7, 4 + 7, 7 + 6) -> 10\\n                        dfs(0, 0) -> min(2 + 10, 5 + 10, 1 + dfs(1, 4)) \\n                            dfs(1, 4) -> min(3 + 6, 4 + 6, 7 +  6) -> 9 \\n                        dfs(0, 0) -> min(2 + 10, 5 + 10, 1 + 9) -> 10\\n        \\'\\'\\'        \\n\\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        # set result as min cost in each cost set -> histogram intersection style \\n        min_value_in_column = [min(costs_i) for costs_i in zip(*cost)]\\n        self.memo = dict()\\n\\n        @lru_cache(None)\\n        def dfs(row_index, bitmask) : \\n            if (row_index, bitmask) in self.memo :\\n                return self.memo[(row_index, bitmask)] \\n            elif row_index == rows : \\n                # return sum of min values in column for col index not in bitmask  \\n                # bitmask & 1 << col_index == 0 -> least significant bit is 0 \\n                # this means that bitmask & (1 << col_i) match up -> this means we have this col index \\n                self.memo[(row_index, bitmask)] = sum(min_value_in_column[col_i] for col_i in range(cols) if not (bitmask & (1 << col_i)))\\n                return self.memo[(row_index, bitmask)]\\n            else : \\n                # otherwise, return minimum of cost at row index and col index + dfs(row_index + 1, mask union with (1 << col_index)) \\n                # which means, return cost found at row and col + dfs result of next row index if we join this col index to our bitmask (adds if not present) \\n                # which is done for col index in range cols \\n                # this means we take value at row and col and add to it the recursive value of the next row if we take the col index into the bitmask\\n                # this is done for each col index in range cols -> this finds the minimum then of this row item values plus next row items values recursively   \\n                self.memo[(row_index, bitmask)] = min(cost[row_index][col_index] + dfs(row_index + 1, bitmask | (1 << col_index)) for col_index in range(cols))\\n                return self.memo[(row_index, bitmask)]\\n        # from the first row index with an empty mask \\n        # go until the last row index where \\n            # along the way to the last row index \\n            # for each row index consider each col index elements value with each next row index to rows \\n                # where upon reaching the last row in this manner you return the sum of the minimal items \\n                    # for which you have selected such a mask as you go along \\n        \\'\\'\\'\\n            Example 3 \\n            result -> [2, 1, 1]\\n\\n            2   5   1       0 row index, 0 bitmask goes in, must find following \\n            3   4   7       find min of (2 + dfs(1, 1), 5 + dfs(1, 2), 1 + dfs(1, 4))\\n            8   1   2   ->  dfs(1, 1) -> find min (3 + dfs(2, 1), 4 + dfs(2, 3), 7 + dfs(2, 5))\\n            6   2   4           dfs(2, 1) -> find min (8 + dfs(3, 1), 1 + dfs(3, 3), 2 + dfs(3, 5))\\n            3   8   8               dfs(3, 1) -> find min (6 + dfs(4, 1), 2 + dfs(4, 3), 4 + dfs(4, 5))\\n                                        dfs(4, 1) -> find min (3 + 2, 8 + 2, 8 + 4)\\n                                            dfs(5, 1) -> for col 0, 1 has a value in col 0, so bitmask & (1 << col_i) is 1 -> so we skip this value. But other two we would get 0, so we add them for 2. \\n                                            dfs(5, 3) -> for col 1, b1 does not have value in col 1 which is like saying it does not have the second column -> add this value  -> result is 2 \\n                                            dfs(5, 5) -> as above for col 2 -> total is now 2 for the first, and 2 for the other two, total is 4\\n                                            dfs(5, 7) -> 0 \\n                                        dfs(4, 1) -> so our first result is 3 + 2 is 5 \\n                                        dfs(4, 2) -> min(3 + 2, 8 + dfs(5, 2), 8 + dfs(5, 6)) -> 5 \\n                                        dfs(4, 3) -> min(3 + dfs(5, 3), 8 + dfs(5, 3), 8 + dfs(5, 7)) -> min (3 + 2, 8 + 2, 8 + 0) -> result is 5\\n                                        dfs(4, 4) -> min(3 + dfs(5, 5), 8 + dfs(5, 4), 8 + dfs(5, 6)) -> 7\\n                                        dfs(4, 6) -> min(3 + dfs(5, 7), 8 + dfs(5, 6), 8 + dfs(5, 6)) -> result is 3\\n                                        dfs(4, 5) -> min(3 + dfs(5, 5), 8 + dfs(5, 7), 8 + dfs(5, 5)) -> min (3 + 4, 8 + 0, 8 + 4) -> result is 7\\n                                        dfs(4, 7) -> min(3 + dfs(5, 7),  8 + dfs(5, 7), 8 + dfs(5, 7)) -> min (3, 8, 8) -> 3 \\n                                    dfs(3, 1) -> min (6 + 5, 2 + 5, 4 + 7) -> 7 \\n                                    dfs(3, 2) -> min (6 + 5, 2 + 5, 4+3) -> 7\\n                                    dfs(3, 3) -> min (6 + dfs(4, 3), 2 + dfs(4, 3), 4 + dfs(4, 7))\\n                                              -> min (6 + 5, 2 + 5, 4 + 3) -> 7\\n                                    dfs(3, 4) -> min (6 + 7, 2 + 7, 4+3) -> 7 \\n                                    dfs(3, 5) -> min(6 + dfs(4, 5), 2 + dfs(4, 7), 4 + dfs(4, 5))\\n                                              -> min(6 + 7, 2 + 3, 4 + 7) -> 5\\n                                    dfs(3, 6) -> min(6 + 3, 2 + 3, 4 + 3) -> 5\\n                                    dfs(3, 7) -> min(6 + dfs(4, 7), 2 + dfs(4, 7), 4+dfs(4, 7))\\n                                              -> min(6 + 3, 2 + 3, 4 + 3) -> 5  \\n                                dfs(2, 1) -> (8 + 7, 1 + 7, 2 + 5) -> 7 \\n                                dfs(2, 3) -> find min (8 + dfs(3, 3), 1 + dfs(3, 3), 2 + dfs(3, 7))\\n                                          ->      min (8 + 7, 1 + 7, 2 + 5) -> 7\\n                                dfs(2, 4) -> (8 + 5, 1 + 5, 2 + 7) -> 6\\n                                dfs(2, 5) -> find min (8 + dfs(3, 5), 1 + dfs(3, 7), 2 + dfs(3, 5))\\n                                          ->      min (8 + 5, 1 + 5, 2 + 5) -> 6\\n                                dfs(2, 2)         min (8 + dfs(3, 3), 1 + dfs(3, 2), 2 + dfs(3, 6))\\n                                                  min (8 + 7, 1 + 7, 2 + 5) -> 7\\n                                dfs(2, 6) ->      min (8 + dfs(3, 7), 1 + dfs(3, 6), 2 + dfs(3, 6))\\n                                                  min (8 + 5, 1 + 5, 2 + 5) -> 6\\n                                dfs(2, 7) ->      min (8 + dfs(3, 7), 1 + dfs(3, 7), 2 + dfs(3, 7)) -> 6\\n                            dfs(1, 1) -> min(3 + 7, 4 + 7, 7 + 6) -> 10 \\n                        dfs(0, 0) -> min(2 + 10, 5 + dfs(1, 2), 1 + dfs(1, 4))\\n                            dfs(1, 2) -> min(3 + dfs(2, 3), 4 + dfs(2, 2), 7+ dfs(2, 6))\\n                                      -> min(3 + 7, 4 + 7, 7 + 6) -> 10\\n                        dfs(0, 0) -> min(2 + 10, 5 + 10, 1 + dfs(1, 4)) \\n                            dfs(1, 4) -> min(3 + 6, 4 + 6, 7 +  6) -> 9 \\n                        dfs(0, 0) -> min(2 + 10, 5 + 10, 1 + 9) -> 10\\n        \\'\\'\\'        \\n\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763960,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i,int j,int si,int size,int val,vector<vector<int>>& cost,vector<vector<vector<vector<int>>>>& dp,int ct)\\n    {\\n        if(i==si && val==((1<<size)-1))\\n        return 0;\\n        if(i==si)\\n        return 1e9;\\n        if(j==size)\\n        {\\n            if(ct>0)\\n            return find(i+1,0,si,size,val,cost,dp,0);\\n            else\\n            return 1e9;\\n        }\\n        if(dp[i][j][val][ct]!=-1)\\n        return dp[i][j][val][ct];\\n        int a=find(i,j+1,si,size,val | (1<<j),cost,dp,ct+1)+cost[i][j];\\n        int b=find(i,j+1,si,size,val,cost,dp,ct);\\n        return dp[i][j][val][ct]=min(a,b);\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int si=cost.size(),size=cost[0].size();\\n        vector<vector<vector<vector<int>>>> dp(si,vector<vector<vector<int>>>(size,vector<vector<int>>((1<<size),vector<int>(size+1,-1))));\\n        return find(0,0,si,size,0,cost,dp,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i,int j,int si,int size,int val,vector<vector<int>>& cost,vector<vector<vector<vector<int>>>>& dp,int ct)\\n    {\\n        if(i==si && val==((1<<size)-1))\\n        return 0;\\n        if(i==si)\\n        return 1e9;\\n        if(j==size)\\n        {\\n            if(ct>0)\\n            return find(i+1,0,si,size,val,cost,dp,0);\\n            else\\n            return 1e9;\\n        }\\n        if(dp[i][j][val][ct]!=-1)\\n        return dp[i][j][val][ct];\\n        int a=find(i,j+1,si,size,val | (1<<j),cost,dp,ct+1)+cost[i][j];\\n        int b=find(i,j+1,si,size,val,cost,dp,ct);\\n        return dp[i][j][val][ct]=min(a,b);\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int si=cost.size(),size=cost[0].size();\\n        vector<vector<vector<vector<int>>>> dp(si,vector<vector<vector<int>>>(size,vector<vector<int>>((1<<size),vector<int>(size+1,-1))));\\n        return find(0,0,si,size,0,cost,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731847,
                "title": "dp-with-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // group1[i...] with group2 points occupied in mask\\n    int solve(int ith, int mask, vector<vector<int>>& cost,\\n              vector<int>& min2, vector<vector<int>>& mem) {\\n        if (mem[ith][mask] != -1) {\\n            return mem[ith][mask];\\n        }\\n\\n        int m = cost.size(), n = cost[0].size(), ans;\\n        if (ith == m) {\\n            // connect each unoccupied group2 point\\n            ans = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (!(mask & (1 << j))) {\\n                    ans += min2[j];\\n                }\\n            }\\n        } else {\\n            ans = INT_MAX;\\n            // connect group1[ith] to each point in group2\\n            for (int j = 0; j < n; j++) {\\n                int val = cost[ith][j] + solve(ith + 1, mask | (1 << j), cost, min2, mem);\\n                ans = min(ans, val);\\n            }\\n        }\\n\\n        return mem[ith][mask] = ans;\\n    }\\npublic:\\n    /*\\n    Observations:\\n    1. group1 and group2 has different number of points,\\n       suppose their size m and n, we know m >= n.\\n    2. A point in group1 can connect to any point in group2.\\n       All points in group1 can connect to 1/2/.../n points\\n       in group2. Let\\'s say dp[i][mask] denote the min cost\\n       to connect group1[i...m-1] to group2, with mask denote\\n       unused group2 points as 0 and used as 1. We have:\\n\\n       dp[i][mask] = min(cost[i][j] + dp[i+1][mask | (1 << j)]), j in [0, n-1]\\n\\n       Basically group1[i] can connect to any point in group2,\\n       regardless of whether this point has been used before.\\n    3. In the end some group2 points might be 0 in mask,\\n       connect such point to its lowest cost connection in\\n       group1, and sum up the cost for all such points.\\n\\n       bitmask dp;\\n       O(m * 2^n * n) time O(m * 2^n) space, can be optimized to O(2^n) space;\\n    */\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int m = cost.size(), n = cost[0].size();\\n        // minimum cost for each group2 point\\n        vector<int> min2(n, 101);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                min2[j] = min(min2[j], cost[i][j]);\\n            }\\n        }\\n\\n        int N = 1 << n;\\n        // mem[m] is used in the end, to handle unoccupied points in group2\\n        vector<vector<int>> mem(m + 1, vector<int>(N, -1));\\n        return solve(0, 0, cost, min2, mem);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // group1[i...] with group2 points occupied in mask\\n    int solve(int ith, int mask, vector<vector<int>>& cost,\\n              vector<int>& min2, vector<vector<int>>& mem) {\\n        if (mem[ith][mask] != -1) {\\n            return mem[ith][mask];\\n        }\\n\\n        int m = cost.size(), n = cost[0].size(), ans;\\n        if (ith == m) {\\n            // connect each unoccupied group2 point\\n            ans = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (!(mask & (1 << j))) {\\n                    ans += min2[j];\\n                }\\n            }\\n        } else {\\n            ans = INT_MAX;\\n            // connect group1[ith] to each point in group2\\n            for (int j = 0; j < n; j++) {\\n                int val = cost[ith][j] + solve(ith + 1, mask | (1 << j), cost, min2, mem);\\n                ans = min(ans, val);\\n            }\\n        }\\n\\n        return mem[ith][mask] = ans;\\n    }\\npublic:\\n    /*\\n    Observations:\\n    1. group1 and group2 has different number of points,\\n       suppose their size m and n, we know m >= n.\\n    2. A point in group1 can connect to any point in group2.\\n       All points in group1 can connect to 1/2/.../n points\\n       in group2. Let\\'s say dp[i][mask] denote the min cost\\n       to connect group1[i...m-1] to group2, with mask denote\\n       unused group2 points as 0 and used as 1. We have:\\n\\n       dp[i][mask] = min(cost[i][j] + dp[i+1][mask | (1 << j)]), j in [0, n-1]\\n\\n       Basically group1[i] can connect to any point in group2,\\n       regardless of whether this point has been used before.\\n    3. In the end some group2 points might be 0 in mask,\\n       connect such point to its lowest cost connection in\\n       group1, and sum up the cost for all such points.\\n\\n       bitmask dp;\\n       O(m * 2^n * n) time O(m * 2^n) space, can be optimized to O(2^n) space;\\n    */\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int m = cost.size(), n = cost[0].size();\\n        // minimum cost for each group2 point\\n        vector<int> min2(n, 101);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                min2[j] = min(min2[j], cost[i][j]);\\n            }\\n        }\\n\\n        int N = 1 << n;\\n        // mem[m] is used in the end, to handle unoccupied points in group2\\n        vector<vector<int>> mem(m + 1, vector<int>(N, -1));\\n        return solve(0, 0, cost, min2, mem);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698523,
                "title": "java-bitmask-dp",
                "content": "1. states: i-th bit represents that has the i-th number in second group been chosen\\n2. dp[i][s]: the minimum cost for the first i number in first group, with chosen pattern in s for the second group\\n3. dp[i][s] = Min(dp[i][s], dp[i - 1][s] + cost, dp[i -1][s - subset] + cost) for subset in range [0, s]\\n\\nWhy?   \\nThe first goal is to fill states of the second group to all 1-bit, but it is likely that the costs of current number in first group with any 0-bit number in second group are greater than the costs of current number in first group with already 1-bit number in second group.\\n\\nIn other words, if i-th number in second group is already chosen, but for the j-th number in first group, it costs less to get them connect than connect to any numbers that have not chosen in second group.\\n```\\nclass Solution {\\n    int m;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        this.m = cost.get(0).size();\\n        int nState = 1 << m;\\n        int[][] dp = new int[n + 1][nState];\\n        int[][] costsOfNSecondGroupForOneFirstGroup = new int[n][nState];\\n        for (int i = 0; i < n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                costsOfNSecondGroupForOneFirstGroup[i][state] = getCostsForOneToN(cost, i, state);\\n            }\\n        }\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                for (int subset = state; subset > 0; subset = (subset - 1) & state) {\\n                    dp[i][state] = Math.min(dp[i][state], Math.min(dp[i - 1][state], dp[i - 1][state - subset]) + costsOfNSecondGroupForOneFirstGroup[i - 1][subset]);\\n                }\\n            }\\n        }\\n        return dp[n][nState - 1];\\n    }\\n\\n    private int getCostsForOneToN(List<List<Integer>> cost, int first_group_index, int state) {\\n        int count = 0;\\n        for (int i = 0; i < m; i++) {\\n            if (state % 2 == 1) {\\n                count += cost.get(first_group_index).get(i);\\n            }\\n            state /= 2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        this.m = cost.get(0).size();\\n        int nState = 1 << m;\\n        int[][] dp = new int[n + 1][nState];\\n        int[][] costsOfNSecondGroupForOneFirstGroup = new int[n][nState];\\n        for (int i = 0; i < n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                costsOfNSecondGroupForOneFirstGroup[i][state] = getCostsForOneToN(cost, i, state);\\n            }\\n        }\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                for (int subset = state; subset > 0; subset = (subset - 1) & state) {\\n                    dp[i][state] = Math.min(dp[i][state], Math.min(dp[i - 1][state], dp[i - 1][state - subset]) + costsOfNSecondGroupForOneFirstGroup[i - 1][subset]);\\n                }\\n            }\\n        }\\n        return dp[n][nState - 1];\\n    }\\n\\n    private int getCostsForOneToN(List<List<Integer>> cost, int first_group_index, int state) {\\n        int count = 0;\\n        for (int i = 0; i < m; i++) {\\n            if (state % 2 == 1) {\\n                count += cost.get(first_group_index).get(i);\\n            }\\n            state /= 2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391178,
                "title": "javascript-memoization-with-bitmask",
                "content": "```\\n// Helper function\\nconst memoize = (fn) => {\\n  \\n  const memo = new Map();\\n  return (...args) => {\\n\\n    const key = args.map(JSON.stringify).join(\",\");\\n    if (memo.has(key)) return memo.get(key);\\n\\n    const result = fn(...args);\\n    memo.set(key, result);\\n\\n    return result;\\n  }\\n}\\n\\nvar connectTwoGroups = function(cost) {\\n\\n  const n = cost.length;\\n  const m = cost[0].length;\\n\\n  const baseNumber = 2 ** m - 1;\\n\\n  const setBit = (num, index) => {\\n    const mask = 1 << index;\\n    return num | mask;\\n  }\\n\\n  const f = memoize((i, usedLeft, j, bitMask) => {\\n\\n    if (i === n) return bitMask === baseNumber ? 0 : Infinity;\\n    if (j === m) return usedLeft ? f(i + 1, false, 0, bitMask) : Infinity;\\n  \\n    const connect = f(i, true, j + 1, setBit(bitMask, j)) + cost[i][j];\\n    const noConnect = f(i, usedLeft, j + 1, bitMask);\\n\\n    return Math.min(connect, noConnect);\\n  });\\n\\n  return f(0, false, 0, 0);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Helper function\\nconst memoize = (fn) => {\\n  \\n  const memo = new Map();\\n  return (...args) => {\\n\\n    const key = args.map(JSON.stringify).join(\",\");\\n    if (memo.has(key)) return memo.get(key);\\n\\n    const result = fn(...args);\\n    memo.set(key, result);\\n\\n    return result;\\n  }\\n}\\n\\nvar connectTwoGroups = function(cost) {\\n\\n  const n = cost.length;\\n  const m = cost[0].length;\\n\\n  const baseNumber = 2 ** m - 1;\\n\\n  const setBit = (num, index) => {\\n    const mask = 1 << index;\\n    return num | mask;\\n  }\\n\\n  const f = memoize((i, usedLeft, j, bitMask) => {\\n\\n    if (i === n) return bitMask === baseNumber ? 0 : Infinity;\\n    if (j === m) return usedLeft ? f(i + 1, false, 0, bitMask) : Infinity;\\n  \\n    const connect = f(i, true, j + 1, setBit(bitMask, j)) + cost[i][j];\\n    const noConnect = f(i, usedLeft, j + 1, bitMask);\\n\\n    return Math.min(connect, noConnect);\\n  });\\n\\n  return f(0, false, 0, 0);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230238,
                "title": "python-simple-dp-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost):\\n        m, n = len(cost), len(cost[0])\\n\\n        ans = [min(i) for i in zip(*cost)]\\n\\n        @lru_cache(None)\\n        def dfs(i,mask):\\n            if i == m: return sum(ans[j] for j in range(n) if not (mask & (1<<j)))\\n            return min(cost[i][j] + dfs(i+1,mask|(1<<j)) for j in range(n))\\n\\n        return dfs(0,0)\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost):\\n        m, n = len(cost), len(cost[0])\\n\\n        ans = [min(i) for i in zip(*cost)]\\n\\n        @lru_cache(None)\\n        def dfs(i,mask):\\n            if i == m: return sum(ans[j] for j in range(n) if not (mask & (1<<j)))\\n            return min(cost[i][j] + dfs(i+1,mask|(1<<j)) for j in range(n))\\n\\n        return dfs(0,0)\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175220,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn connect_two_groups(cost: Vec<Vec<i32>>) -> i32 {\\n        let cost: Vec<Vec<_>> = cost.iter().map(|v| v.iter().map(|&x| x as i64).collect()).collect();\\n        let (sz1, sz2) = (cost.len(), cost[0].len());\\n        let mut dp = vec![vec![1_000_000_007; 1 << sz2]; sz1 + 1];\\n        dp[sz1][(1 << sz2) - 1] = 0;\\n        for i in (0..sz1).rev() {\\n            for mask in (0..(1 << sz2)).rev() {\\n                for j in 0..sz2 {\\n                    dp[i][mask] = dp[i][mask].min(cost[i][j] + dp[i + 1][mask | (1 << j)]);\\n                    if mask & (1 << j) == 0 {\\n                        dp[i][mask] = dp[i][mask].min(cost[i][j] + dp[i][mask | (1 << j)]);\\n                    }\\n                }\\n            }\\n        }\\n        dp[0][0] as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn connect_two_groups(cost: Vec<Vec<i32>>) -> i32 {\\n        let cost: Vec<Vec<_>> = cost.iter().map(|v| v.iter().map(|&x| x as i64).collect()).collect();\\n        let (sz1, sz2) = (cost.len(), cost[0].len());\\n        let mut dp = vec![vec![1_000_000_007; 1 << sz2]; sz1 + 1];\\n        dp[sz1][(1 << sz2) - 1] = 0;\\n        for i in (0..sz1).rev() {\\n            for mask in (0..(1 << sz2)).rev() {\\n                for j in 0..sz2 {\\n                    dp[i][mask] = dp[i][mask].min(cost[i][j] + dp[i + 1][mask | (1 << j)]);\\n                    if mask & (1 << j) == 0 {\\n                        dp[i][mask] = dp[i][mask].min(cost[i][j] + dp[i][mask | (1 << j)]);\\n                    }\\n                }\\n            }\\n        }\\n        dp[0][0] as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172467,
                "title": "c-super-short-dfs-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& C) {\\n         int m = C.size(), n = C[0].size(), dp[13][4097]{}, min2[13] = {[0 ... 12] = INT_MAX};\\n         for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) min2[j] = min(min2[j], C[i][j]);\\n         function<int(int, int)> dfs = [&] (int i, int mask) {\\n             if(dp[i][mask]) return dp[i][mask];\\n             int res = (i >= m ? 0 : INT_MAX);\\n             for(int j = 0; j < n; j++) {\\n                 if(i >= m) res += min2[j]*(!(mask&(1 << j)));\\n                 else res = min(res, C[i][j]+ dfs(i+1, mask | (1 << j)));\\n             }\\n             return dp[i][mask] = res;\\n         };\\n         return dfs(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& C) {\\n         int m = C.size(), n = C[0].size(), dp[13][4097]{}, min2[13] = {[0 ... 12] = INT_MAX};\\n         for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) min2[j] = min(min2[j], C[i][j]);\\n         function<int(int, int)> dfs = [&] (int i, int mask) {\\n             if(dp[i][mask]) return dp[i][mask];\\n             int res = (i >= m ? 0 : INT_MAX);\\n             for(int j = 0; j < n; j++) {\\n                 if(i >= m) res += min2[j]*(!(mask&(1 << j)));\\n                 else res = min(res, C[i][j]+ dfs(i+1, mask | (1 << j)));\\n             }\\n             return dp[i][mask] = res;\\n         };\\n         return dfs(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915301,
                "title": "dfs-with-memo-bitmask-for-right-state",
                "content": "Big thanks to the @hjscoder [solution](https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/solutions/855352/the-idea-is-brute-force-dfs/).\\n# Code\\n```\\npublic class Solution {\\n    private int[] _dp;\\n    private int[][] _memo;\\n    private IList<IList<int>> _cost;\\n\\n    public int ConnectTwoGroups(IList<IList<int>> cost) {\\n        _cost = cost;\\n        CalculateMinCostForEachRightComponent();\\n        InitCacheArray();\\n        return Recurse(0, 0);\\n    }\\n\\n    private void CalculateMinCostForEachRightComponent()\\n    {\\n        _dp = new int[_cost[0].Count];\\n        Array.Fill(_dp, int.MaxValue);\\n        for(var j = 0; j < _dp.Length; j++)\\n        {\\n            for (var i = 0; i < _cost.Count; i++)\\n            {\\n                _dp[j] = Math.Min(_dp[j], _cost[i][j]);\\n            }\\n        }\\n    }\\n\\n    private void InitCacheArray()\\n    {\\n        _memo = new int[_cost.Count + 1][];\\n\\n        var length = (1 << _cost[0].Count);\\n        for (var i = 0; i < _memo.Length; i++)\\n        {\\n            _memo[i] = new int[length];\\n            Array.Fill(_memo[i], -1);\\n        }\\n    }\\n\\n    private int Recurse(int left, int right)\\n    {\\n        if (_memo[left][right] != -1)\\n            return _memo[left][right];\\n\\n        if (left == _cost.Count)\\n        {\\n            // Here we state that all components from left are connected. \\n            // Then we need to sum all minimal costs of the right elements that have not been considered yet in the \"right\" state\\n            // That is why we check the states to be 0, not 1\\n            var sum = 0;\\n            for (var j = 0; j < _dp.Length; j++)\\n            {\\n                if (((1 << j) & right) == 0)\\n                    sum += _dp[j];\\n            }\\n            return _memo[left][right] = sum;\\n        }\\n        \\n        var result = int.MaxValue;\\n        // Traverse all states and try to include them in the final result\\n        for (var j = 0; j < _dp.Length; j++)\\n        {\\n            var newState = (1 << j) | right;\\n            result = Math.Min(result, _cost[left][j] + Recurse(left + 1, newState));\\n        }\\n\\n        // Save the achieved result \\n        return _memo[left][right] = result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking",
                    "Depth-First Search",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\npublic class Solution {\\n    private int[] _dp;\\n    private int[][] _memo;\\n    private IList<IList<int>> _cost;\\n\\n    public int ConnectTwoGroups(IList<IList<int>> cost) {\\n        _cost = cost;\\n        CalculateMinCostForEachRightComponent();\\n        InitCacheArray();\\n        return Recurse(0, 0);\\n    }\\n\\n    private void CalculateMinCostForEachRightComponent()\\n    {\\n        _dp = new int[_cost[0].Count];\\n        Array.Fill(_dp, int.MaxValue);\\n        for(var j = 0; j < _dp.Length; j++)\\n        {\\n            for (var i = 0; i < _cost.Count; i++)\\n            {\\n                _dp[j] = Math.Min(_dp[j], _cost[i][j]);\\n            }\\n        }\\n    }\\n\\n    private void InitCacheArray()\\n    {\\n        _memo = new int[_cost.Count + 1][];\\n\\n        var length = (1 << _cost[0].Count);\\n        for (var i = 0; i < _memo.Length; i++)\\n        {\\n            _memo[i] = new int[length];\\n            Array.Fill(_memo[i], -1);\\n        }\\n    }\\n\\n    private int Recurse(int left, int right)\\n    {\\n        if (_memo[left][right] != -1)\\n            return _memo[left][right];\\n\\n        if (left == _cost.Count)\\n        {\\n            // Here we state that all components from left are connected. \\n            // Then we need to sum all minimal costs of the right elements that have not been considered yet in the \"right\" state\\n            // That is why we check the states to be 0, not 1\\n            var sum = 0;\\n            for (var j = 0; j < _dp.Length; j++)\\n            {\\n                if (((1 << j) & right) == 0)\\n                    sum += _dp[j];\\n            }\\n            return _memo[left][right] = sum;\\n        }\\n        \\n        var result = int.MaxValue;\\n        // Traverse all states and try to include them in the final result\\n        for (var j = 0; j < _dp.Length; j++)\\n        {\\n            var newState = (1 << j) | right;\\n            result = Math.Min(result, _cost[left][j] + Recurse(left + 1, newState));\\n        }\\n\\n        // Save the achieved result \\n        return _memo[left][right] = result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776570,
                "title": "python-beats-100-hungarian-algorithm",
                "content": "I wanted to use this problem to try and understand and implement Hungarian using python which is not a very common resource out there.\\n\\nThis explains the intuition behind the solution\\n- https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/discuss/855686/C%2B%2B-4ms-beats-100-Bipartite-graph-maximum-weight-matching\\n\\nHowever the Hungarian algorithm used is different and is adapted from this C++ source\\n- https://github.com/mpfeifer1/Kattis/blob/master/cordonbleu.cpp\\n\\n```py\\n\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        Lmin = [0 for _ in range(rows)]\\n        Rmin = [0 for _ in range(cols)]\\n\\n        ans = 0\\n        for i in range(rows):\\n            Lmin[i] = float(\\'inf\\')\\n            for j in range(cols):\\n                Lmin[i] = min(Lmin[i], cost[i][j])\\n            ans += Lmin[i]\\n        \\n        for j in range(cols):\\n            Rmin[j] = float(\\'inf\\')\\n            for i in range(rows):\\n                Rmin[j] = min(Rmin[j], cost[i][j])\\n            ans += Rmin[j]\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                cost[i][j] = max(-1*(cost[i][j] - Lmin[i] - Rmin[j]), 0)\\n                \\n\\n        res = hungarianMatch(cost, False)\\n        return ans - res\\n\\n\\n\\n# matrix[i][j] is cost of job i done by worker j\\ndef hungarianMatch(matrix, minimize=True):\\n    \\n    # ensure that rows always <= cols\\n    if len(matrix) > len(matrix[0]):\\n        matrix = list(map(list, zip(*matrix)))\\n    \\n    \\n    rows = len(matrix)\\n    cols = len(matrix[0])\\n    \\n    # flip weights if \\n    if not minimize:\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] *= -1\\n\\n    u = [0 for _ in range(rows+1)]\\n    v = [0 for _ in range(cols+1)]\\n    p = [0 for _ in range(cols+1)]\\n    way = [0 for _ in range(cols+1)]\\n    for i in range(1,rows+1):\\n        p[0] = i \\n\\n        minv = [float(\\'inf\\') for _ in range(cols+1)]\\n        used = [False for _ in range(cols+1)]\\n\\n        j0 = 0\\n\\n        while True:\\n            used[j0] = True\\n            \\n            i0 = p[j0]\\n            delta = float(\\'inf\\')\\n            j1 = None\\n\\n            for j in range(1,cols+1):\\n                if not used[j]:\\n                    cur = matrix[i0-1][j-1] - u[i0] - v[j]\\n                    if cur < minv[j]:\\n                        minv[j] = cur \\n                        way[j] = j0\\n                    if minv[j] < delta:\\n                        delta = minv[j]\\n                        j1 = j\\n            \\n            for j in range(cols+1):\\n                if used[j]:\\n                    u[p[j]] += delta \\n                    v[j] -= delta \\n                else:\\n                    minv[j] -= delta \\n            \\n            j0 = j1\\n\\n            if p[j0] == 0: break\\n\\n        while True:\\n            j1 = way[j0]\\n            p[j0] = p[j1]\\n            j0 = j1\\n            if not j0:\\n                break\\n    \\n    if not minimize: return v[0]\\n    return -v[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        Lmin = [0 for _ in range(rows)]\\n        Rmin = [0 for _ in range(cols)]\\n\\n        ans = 0\\n        for i in range(rows):\\n            Lmin[i] = float(\\'inf\\')\\n            for j in range(cols):\\n                Lmin[i] = min(Lmin[i], cost[i][j])\\n            ans += Lmin[i]\\n        \\n        for j in range(cols):\\n            Rmin[j] = float(\\'inf\\')\\n            for i in range(rows):\\n                Rmin[j] = min(Rmin[j], cost[i][j])\\n            ans += Rmin[j]\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                cost[i][j] = max(-1*(cost[i][j] - Lmin[i] - Rmin[j]), 0)\\n                \\n\\n        res = hungarianMatch(cost, False)\\n        return ans - res\\n\\n\\n\\n# matrix[i][j] is cost of job i done by worker j\\ndef hungarianMatch(matrix, minimize=True):\\n    \\n    # ensure that rows always <= cols\\n    if len(matrix) > len(matrix[0]):\\n        matrix = list(map(list, zip(*matrix)))\\n    \\n    \\n    rows = len(matrix)\\n    cols = len(matrix[0])\\n    \\n    # flip weights if \\n    if not minimize:\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] *= -1\\n\\n    u = [0 for _ in range(rows+1)]\\n    v = [0 for _ in range(cols+1)]\\n    p = [0 for _ in range(cols+1)]\\n    way = [0 for _ in range(cols+1)]\\n    for i in range(1,rows+1):\\n        p[0] = i \\n\\n        minv = [float(\\'inf\\') for _ in range(cols+1)]\\n        used = [False for _ in range(cols+1)]\\n\\n        j0 = 0\\n\\n        while True:\\n            used[j0] = True\\n            \\n            i0 = p[j0]\\n            delta = float(\\'inf\\')\\n            j1 = None\\n\\n            for j in range(1,cols+1):\\n                if not used[j]:\\n                    cur = matrix[i0-1][j-1] - u[i0] - v[j]\\n                    if cur < minv[j]:\\n                        minv[j] = cur \\n                        way[j] = j0\\n                    if minv[j] < delta:\\n                        delta = minv[j]\\n                        j1 = j\\n            \\n            for j in range(cols+1):\\n                if used[j]:\\n                    u[p[j]] += delta \\n                    v[j] -= delta \\n                else:\\n                    minv[j] -= delta \\n            \\n            j0 = j1\\n\\n            if p[j0] == 0: break\\n\\n        while True:\\n            j1 = way[j0]\\n            p[j0] = p[j1]\\n            j0 = j1\\n            if not j0:\\n                break\\n    \\n    if not minimize: return v[0]\\n    return -v[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732975,
                "title": "c-bottom-up",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        vector<vector<ll int>>dp(n,vector<ll int>(1<<m,1e12));\\n        vector<vector<ll int>>pre(n,vector<ll int>(1<<m,1e12));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int mask=1;mask<(1<<m);mask++)\\n            {\\n                ll int curr=0;\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(mask&(1<<j))\\n                    {\\n                        curr+=cost[i][j];\\n                    }\\n                }\\n                pre[i][mask]=curr;\\n            }\\n        }\\n        for(int mask=1;mask<(1<<m);mask++)\\n        {\\n            dp[0][mask]=pre[0][mask];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int mask=1;mask<(1<<m);mask++)\\n            {\\n                for(int s=mask;s;s=(s-1)&mask)\\n                {\\n                    int xmask=mask^s;\\n                    if(dp[i-1][xmask]!=1e12)\\n                        dp[i][mask]=min(dp[i][mask],dp[i-1][xmask]+pre[i][s]);\\n                    dp[i][mask]=min(dp[i][mask],dp[i-1][mask]+pre[i][s]);\\n                }\\n                    \\n            }\\n        }\\n        return dp[n-1][(1<<m)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        vector<vector<ll int>>dp(n,vector<ll int>(1<<m,1e12));\\n        vector<vector<ll int>>pre(n,vector<ll int>(1<<m,1e12));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int mask=1;mask<(1<<m);mask++)\\n            {\\n                ll int curr=0;\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(mask&(1<<j))\\n                    {\\n                        curr+=cost[i][j];\\n                    }\\n                }\\n                pre[i][mask]=curr;\\n            }\\n        }\\n        for(int mask=1;mask<(1<<m);mask++)\\n        {\\n            dp[0][mask]=pre[0][mask];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int mask=1;mask<(1<<m);mask++)\\n            {\\n                for(int s=mask;s;s=(s-1)&mask)\\n                {\\n                    int xmask=mask^s;\\n                    if(dp[i-1][xmask]!=1e12)\\n                        dp[i][mask]=min(dp[i][mask],dp[i-1][xmask]+pre[i][s]);\\n                    dp[i][mask]=min(dp[i][mask],dp[i-1][mask]+pre[i][s]);\\n                }\\n                    \\n            }\\n        }\\n        return dp[n-1][(1<<m)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720012,
                "title": "c-bit-mask-o-n-m-2-m",
                "content": "```\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        const int n = cost.size(), m = cost[0].size(), m2 = pow(2, m), Big = 1e9;\\n        vector<int> pre(m2, Big), cur(m2, Big);\\n        pre[0] = 0;\\n        for(int i=0;i<n;i++){            \\n            for(int j=0;j<m;j++){\\n                int cos = cost[i][j];\\n                for(int mask = 0; mask < m2; mask++){\\n                    if(pre[mask] == Big) continue;\\n                    int newMask = mask | (1<<j);\\n                    cur[newMask] = min(cur[newMask], pre[mask] + cos);\\n                }\\n            }\\n            pre = move(cur);\\n            cur = vector(m2, Big);\\n        }        \\n\\n        vector<int> vmin(m, Big);\\n        for(int j=0;j<m;j++) for(int i=0;i<n;i++)\\n            vmin[j] = min(vmin[j], cost[i][j]);\\n        \\n        // for all the mask, if b_i is not connected, add the min cost to conect b_i\\n        int res = pre[m2-1];        \\n        for(int i=0;i<m2-1;i++){\\n            bitset<12> mask(i);\\n            int sum = pre[i];\\n            for(int i=0;i<m;i++) if(!mask[i]) sum += vmin[i];\\n            res = min(res, sum);\\n        }       \\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        const int n = cost.size(), m = cost[0].size(), m2 = pow(2, m), Big = 1e9;\\n        vector<int> pre(m2, Big), cur(m2, Big);\\n        pre[0] = 0;\\n        for(int i=0;i<n;i++){            \\n            for(int j=0;j<m;j++){\\n                int cos = cost[i][j];\\n                for(int mask = 0; mask < m2; mask++){\\n                    if(pre[mask] == Big) continue;\\n                    int newMask = mask | (1<<j);\\n                    cur[newMask] = min(cur[newMask], pre[mask] + cos);\\n                }\\n            }\\n            pre = move(cur);\\n            cur = vector(m2, Big);\\n        }        \\n\\n        vector<int> vmin(m, Big);\\n        for(int j=0;j<m;j++) for(int i=0;i<n;i++)\\n            vmin[j] = min(vmin[j], cost[i][j]);\\n        \\n        // for all the mask, if b_i is not connected, add the min cost to conect b_i\\n        int res = pre[m2-1];        \\n        for(int i=0;i<m2-1;i++){\\n            bitset<12> mask(i);\\n            int sum = pre[i];\\n            for(int i=0;i<m;i++) if(!mask[i]) sum += vmin[i];\\n            res = min(res, sum);\\n        }       \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2716071,
                "title": "python-short-dfs-solution-bitmask",
                "content": "```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tm, n = len(cost), len(cost[0])\\n\\tmin_cost = [min(col) for col in zip(*cost)]\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(i, mask):\\n\\t\\tif i==m:\\n\\t\\t\\treturn sum(min_cost[j] for j in range(n) if not mask&(1<<j))\\n\\t\\treturn min(cost[i][j]+dfs(i+1, mask|(1<<j)) for j in range(n))\\n\\n\\treturn dfs(0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tm, n = len(cost), len(cost[0])\\n\\tmin_cost = [min(col) for col in zip(*cost)]\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(i, mask):\\n\\t\\tif i==m:\\n\\t\\t\\treturn sum(min_cost[j] for j in range(n) if not mask&(1<<j))\\n\\t\\treturn min(cost[i][j]+dfs(i+1, mask|(1<<j)) for j in range(n))\\n\\n\\treturn dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2600213,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll m, n;\\n    vi(ll)cols;\\n    vi(vi(ll))dp;\\n    ll func(const vi(vi(int))& v, ll in, ll bm) {\\n        if (in == m) {\\n            ll ans = 0;\\n            for (ll c = 0;c < n;++c) { // for those columns (set2 elements), that remain disconnected, connect them with the least weighted rows, i.e. set1 elements (already prepared in prefix)\\n                if (!((bm >> c) & 1)) {\\n                    ans += cols[c];\\n                }\\n            }\\n            return ans;\\n        }\\n        ll& ans = dp[in][bm];\\n        if (ans == -1) {\\n            ans = LLONG_MAX;\\n            for (ll c = 0;c < n;++c) {\\n                ans = min(ans, v[in][c] + func(v, in + 1, bm | (1 << c)));\\n            }\\n        }\\n        return ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& v) {\\n        m = v.size(), n = v[0].size();\\n        dp.assign(m, vi(ll)(1 << n, -1));\\n        cols.assign(n, LLONG_MAX); // cols[i] stores the min element among all rows in column i\\n        for (ll j = 0;j < n;++j) {\\n            for (ll i = 0;i < m;++i) {\\n                cols[j] = min(cols[j], ll(v[i][j]));\\n            }\\n        }\\n        return func(v, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll m, n;\\n    vi(ll)cols;\\n    vi(vi(ll))dp;\\n    ll func(const vi(vi(int))& v, ll in, ll bm) {\\n        if (in == m) {\\n            ll ans = 0;\\n            for (ll c = 0;c < n;++c) { // for those columns (set2 elements), that remain disconnected, connect them with the least weighted rows, i.e. set1 elements (already prepared in prefix)\\n                if (!((bm >> c) & 1)) {\\n                    ans += cols[c];\\n                }\\n            }\\n            return ans;\\n        }\\n        ll& ans = dp[in][bm];\\n        if (ans == -1) {\\n            ans = LLONG_MAX;\\n            for (ll c = 0;c < n;++c) {\\n                ans = min(ans, v[in][c] + func(v, in + 1, bm | (1 << c)));\\n            }\\n        }\\n        return ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& v) {\\n        m = v.size(), n = v[0].size();\\n        dp.assign(m, vi(ll)(1 << n, -1));\\n        cols.assign(n, LLONG_MAX); // cols[i] stores the min element among all rows in column i\\n        for (ll j = 0;j < n;++j) {\\n            for (ll i = 0;i < m;++i) {\\n                cols[j] = min(cols[j], ll(v[i][j]));\\n            }\\n        }\\n        return func(v, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593102,
                "title": "simple-dp-bitmask-w-explanation-python",
                "content": "```\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m = len(cost); n = len(cost[0])\\n        \\n        #this problem reminds me of N queens problem, where you have to place N queens on an N*N chess board\\n        #in each row, u consider every col as part of the solution, but as soon as u choose a col, go to the next row\\n        #because u need to choose only 1 from each row\\n        #after you are done with rows go to coulmns, if a column hasnt been connected, choose the min avail option\\n        #you can keep track of what cols havent been chosen by using a bit mask\\n\\n        #the solution would work even if u did cols first then rows, but there are more rows so doing rows first is faster\\n        \\n        minAvail = [min([cost[r][c] for r in range(m)]) for c in range(n)]\\n        @lru_cache(None)\\n        #Time -> (m*(2^n))*n, Space -> m*(2^n)\\n        def dfs(row, mask):\\n            res = math.inf if row < m else 0\\n            \\n            if row >= m:\\n                for c in range(n):\\n                    if mask&(1<<c) == 0:\\n                        res += minAvail[c]\\n            else:\\n                for c in range(n):\\n                    res = min(res, cost[row][c] + dfs(row+1, mask|(1<<c)))        \\n            return res\\n        \\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m = len(cost); n = len(cost[0])\\n        \\n        #this problem reminds me of N queens problem, where you have to place N queens on an N*N chess board\\n        #in each row, u consider every col as part of the solution, but as soon as u choose a col, go to the next row\\n        #because u need to choose only 1 from each row\\n        #after you are done with rows go to coulmns, if a column hasnt been connected, choose the min avail option\\n        #you can keep track of what cols havent been chosen by using a bit mask\\n\\n        #the solution would work even if u did cols first then rows, but there are more rows so doing rows first is faster\\n        \\n        minAvail = [min([cost[r][c] for r in range(m)]) for c in range(n)]\\n        @lru_cache(None)\\n        #Time -> (m*(2^n))*n, Space -> m*(2^n)\\n        def dfs(row, mask):\\n            res = math.inf if row < m else 0\\n            \\n            if row >= m:\\n                for c in range(n):\\n                    if mask&(1<<c) == 0:\\n                        res += minAvail[c]\\n            else:\\n                for c in range(n):\\n                    res = min(res, cost[row][c] + dfs(row+1, mask|(1<<c)))        \\n            return res\\n        \\n        return dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2532608,
                "title": "javascript-dp-w-bitmasks",
                "content": "**Solution: DP w/ Bitmasks**\\n\\nMemoize each `dp(i, mask)`, where\\n  `i = index in group1`\\n  `mask = bitmask of points connected in group2`\\n\\nFirst, connect every point in group1 with a point in group2. Try every combination and record the best result.\\nThen, connect every unconnected point in group2 with the points in group1 with the cheapest connection cost.\\n\\n`n = size of group1`, `m = size of group2`\\nTime Complexity: `O(n * 2^m * m)` 161ms\\nSpace Complexity: `O(n * 2^m)` 44.5MB\\n```\\nvar connectTwoGroups = function(cost) {\\n  let n = cost.length, m = cost[0].length; // n = size of group1, m = size of group2\\n  let minCost = Array(m).fill(Infinity); // minCost[j] = minimum cost to connect point j (from group2) to a point in group1\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      minCost[j] = Math.min(minCost[j], cost[i][j]);\\n    }\\n  }\\n  let memo = Array(n).fill(0).map(() => Array(1 << m).fill(-1));\\n  return dp(0, 0);\\n  \\n  function dp(i, mask) {\\n    if (i === n) {\\n      let cost = 0;\\n      for (let j = 0; j < m; j++) {\\n        if (((mask >> j) & 1) === 0) cost += minCost[j];\\n      }\\n      return cost;\\n    }\\n    if (memo[i][mask] !== -1) return memo[i][mask];\\n    \\n    let ans = Infinity;\\n    for (let j = 0; j < m; j++) {\\n      ans = Math.min(ans, dp(i + 1, mask | (1 << j)) + cost[i][j]);\\n    }\\n    return memo[i][mask] = ans;\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar connectTwoGroups = function(cost) {\\n  let n = cost.length, m = cost[0].length; // n = size of group1, m = size of group2\\n  let minCost = Array(m).fill(Infinity); // minCost[j] = minimum cost to connect point j (from group2) to a point in group1\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      minCost[j] = Math.min(minCost[j], cost[i][j]);\\n    }\\n  }\\n  let memo = Array(n).fill(0).map(() => Array(1 << m).fill(-1));\\n  return dp(0, 0);\\n  \\n  function dp(i, mask) {\\n    if (i === n) {\\n      let cost = 0;\\n      for (let j = 0; j < m; j++) {\\n        if (((mask >> j) & 1) === 0) cost += minCost[j];\\n      }\\n      return cost;\\n    }\\n    if (memo[i][mask] !== -1) return memo[i][mask];\\n    \\n    let ans = Infinity;\\n    for (let j = 0; j < m; j++) {\\n      ans = Math.min(ans, dp(i + 1, mask | (1 << j)) + cost[i][j]);\\n    }\\n    return memo[i][mask] = ans;\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403921,
                "title": "python-3-dp-bitmask",
                "content": "\\tclass Solution:\\n\\t\\tdef connectTwoGroups(self, cost: List[List[int]]) -> int:        \\n\\t\\t\\tn,m=len(cost),len(cost[0])\\n\\t\\t\\tmini=[min([cost[i][j] for i in range(n)]) for j in range(m)]\\n\\n\\t\\t\\t@cache\\n\\t\\t\\tdef solve(i,mask2):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\ta=0\\n\\t\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\t\\tif mask2&(1<<j):\\n\\t\\t\\t\\t\\t\\t\\ta+=mini[j]\\n\\t\\t\\t\\t\\treturn a \\n\\t\\t\\t\\tb=float(\\'inf\\')\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tb=min(b,cost[i][j]+solve(i+1,mask2&~(1<<j)))\\n\\t\\t\\t\\treturn b\\n\\t\\t\\treturn solve(0,2**m-1)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef connectTwoGroups(self, cost: List[List[int]]) -> int:        \\n\\t\\t\\tn,m=len(cost),len(cost[0])\\n\\t\\t\\tmini=[min([cost[i][j] for i in range(n)]) for j in range(m)]\\n\\n\\t\\t\\t@cache\\n\\t\\t\\tdef solve(i,mask2):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\ta=0\\n\\t\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\t\\tif mask2&(1<<j):\\n\\t\\t\\t\\t\\t\\t\\ta+=mini[j]\\n\\t\\t\\t\\t\\treturn a \\n\\t\\t\\t\\tb=float(\\'inf\\')\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tb=min(b,cost[i][j]+solve(i+1,mask2&~(1<<j)))\\n\\t\\t\\t\\treturn b\\n\\t\\t\\treturn solve(0,2**m-1)",
                "codeTag": "Java"
            },
            {
                "id": 2351266,
                "title": "go-dp-top-down-100-fast-and-100-mem",
                "content": "![image](https://assets.leetcode.com/users/images/49042c88-175a-47b4-82a8-3f65e4bdaaf3_1659163097.5933464.png)\\n\\n```\\nfunc connectTwoGroups(cost [][]int) int {\\n\\trbm := 0\\n\\tfor i := range cost[0] {\\n\\t\\trbm |= 1 << i\\n\\t}\\n\\tMX := 1 << 62\\n\\tmem := make([][]int, len(cost))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, rbm+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tvar dp func(i, bmj int) int\\n\\tdp = func(i, bmj int) int {\\n\\t\\tif i >= len(cost) {\\n\\t\\t\\tif bmj == rbm {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\n\\t\\tif mem[i][bmj] != -1 {\\n\\t\\t\\treturn mem[i][bmj]\\n\\t\\t}\\n\\n\\t\\ta := MX\\n\\t\\tf := false\\n\\t\\tfor j := range cost[i] {\\n\\t\\t\\tx := 1 << j\\n\\t\\t\\tv1 := dp(i+1, bmj|x)\\n\\t\\t\\tif v1 >= 0 {\\n\\t\\t\\t\\tra := v1 + cost[i][j]\\n\\t\\t\\t\\tif ra < a {\\n\\t\\t\\t\\t\\ta = ra\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tf = true\\n\\t\\t\\t}\\n\\t\\t\\tif (bmj & x) != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tv1 = dp(i, bmj|x)\\n\\t\\t\\tif v1 >= 0 {\\n\\t\\t\\t\\tra := v1 + cost[i][j]\\n\\t\\t\\t\\tif ra < a {\\n\\t\\t\\t\\t\\ta = ra\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tf = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tmem[i][bmj] = a\\n\\t\\tif !f {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\treturn dp(0, 0)\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc connectTwoGroups(cost [][]int) int {\\n\\trbm := 0\\n\\tfor i := range cost[0] {\\n\\t\\trbm |= 1 << i\\n\\t}\\n\\tMX := 1 << 62\\n\\tmem := make([][]int, len(cost))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, rbm+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tvar dp func(i, bmj int) int\\n\\tdp = func(i, bmj int) int {\\n\\t\\tif i >= len(cost) {\\n\\t\\t\\tif bmj == rbm {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\n\\t\\tif mem[i][bmj] != -1 {\\n\\t\\t\\treturn mem[i][bmj]\\n\\t\\t}\\n\\n\\t\\ta := MX\\n\\t\\tf := false\\n\\t\\tfor j := range cost[i] {\\n\\t\\t\\tx := 1 << j\\n\\t\\t\\tv1 := dp(i+1, bmj|x)\\n\\t\\t\\tif v1 >= 0 {\\n\\t\\t\\t\\tra := v1 + cost[i][j]\\n\\t\\t\\t\\tif ra < a {\\n\\t\\t\\t\\t\\ta = ra\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tf = true\\n\\t\\t\\t}\\n\\t\\t\\tif (bmj & x) != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tv1 = dp(i, bmj|x)\\n\\t\\t\\tif v1 >= 0 {\\n\\t\\t\\t\\tra := v1 + cost[i][j]\\n\\t\\t\\t\\tif ra < a {\\n\\t\\t\\t\\t\\ta = ra\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tf = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tmem[i][bmj] = a\\n\\t\\tif !f {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\treturn dp(0, 0)\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329362,
                "title": "java-from-hints-submask",
                "content": "I had a really hard time visualizing this problem, but I was able to solve it after checking the hints. \\n\\n```\\nHint 1:\\nEach point on the left would either be connected to exactly point already connected to some left node, \\nor a subset of the nodes on the right which are not connected to any node\\n```\\nThe hint is vaguely worded, but I took it to mean that for every group A (left), we have 2 options:\\n1. Connect it to a subset of unconnected nodes\\n2. Connect it to the min cost node. \\n\\n1st option is easy to figure out: `dp[i][j] = min of all (dp[i-1][sub] + sum[j^sub]))`, but\\n\\nI struggled a ton with the 2nd option. Intuitively, I know it is like `dp[i][j] = min cost + dp[i-1][???]`, but it took me a while and multiple WAs to figure out what that `???` should be. It should be `j`. the min cost is the base cost that will incur for all masks. We must ensure that it is there. I was trying to set the bit according to the min cost index but it was incorrect.\\n\\nso then we have: `dp[i][j] = min(dp[i-1][j] + min cost, min of all (dp[i-1][sub] + sum[j^sub]))`\\n\\n#### Java\\n\\n```Java\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size(), n = cost.get(0).size(), INF = (int)1e9;\\n        int[] dp = new int[1<<n];\\n        Arrays.fill(dp, INF);\\n        dp[0]=0;\\n        for (int i = 0; i < m; i++){\\n            int[] ndp = new int[1<<n];\\n            int[] sum = new int[1<<n];\\n            int min = INF;\\n            for (int j = 0; j < n; j++){\\n                sum[1<<j]=cost.get(i).get(j);\\n                min = Math.min(sum[1<<j], min);\\n            }\\n            for (int j = 0; j < 1<<n; j++){\\n                sum[j]=sum[j&-j]+sum[j&(j-1)];\\n            }\\n            for (int j = 0; j < 1<<n; j++){\\n                ndp[j]=min+dp[j]; // option 2\\n                for (int sub = j-1; sub >= 0; sub=(sub-1)&j){ // option 1.\\n                    ndp[j]=Math.min(ndp[j], dp[sub]+sum[j^sub]);\\n                    if (sub == 0){\\n                        break;\\n                    }\\n                }\\n            }\\n            dp=ndp;\\n        }\\n        return dp[(1<<n)-1];\\n    }\\n}\\n\\n// [1, 3, 5]\\n// [4, 1, 1]\\n// [1, 5, 3]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nHint 1:\\nEach point on the left would either be connected to exactly point already connected to some left node, \\nor a subset of the nodes on the right which are not connected to any node\\n```\n```Java\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size(), n = cost.get(0).size(), INF = (int)1e9;\\n        int[] dp = new int[1<<n];\\n        Arrays.fill(dp, INF);\\n        dp[0]=0;\\n        for (int i = 0; i < m; i++){\\n            int[] ndp = new int[1<<n];\\n            int[] sum = new int[1<<n];\\n            int min = INF;\\n            for (int j = 0; j < n; j++){\\n                sum[1<<j]=cost.get(i).get(j);\\n                min = Math.min(sum[1<<j], min);\\n            }\\n            for (int j = 0; j < 1<<n; j++){\\n                sum[j]=sum[j&-j]+sum[j&(j-1)];\\n            }\\n            for (int j = 0; j < 1<<n; j++){\\n                ndp[j]=min+dp[j]; // option 2\\n                for (int sub = j-1; sub >= 0; sub=(sub-1)&j){ // option 1.\\n                    ndp[j]=Math.min(ndp[j], dp[sub]+sum[j^sub]);\\n                    if (sub == 0){\\n                        break;\\n                    }\\n                }\\n            }\\n            dp=ndp;\\n        }\\n        return dp[(1<<n)-1];\\n    }\\n}\\n\\n// [1, 3, 5]\\n// [4, 1, 1]\\n// [1, 5, 3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246033,
                "title": "c-dp-bitmask",
                "content": "* Solution Inspired By [This Post](https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/discuss/860779/C%2B%2B-DP-with-Bitmasking)\\n* Aim is to pick every element from `size1 or r` and `size2 or c` and finding minimum cost .\\n\\n* We try to pick only single element from each row and calculate the minimum cost of that configuration. This ensures that each element of `size1` or `r` has been dealt with. \\n\\n* But each element of `size2` or `c` **may not** have been dealt with.\\n\\n* `mask` tells us about the chosen configurations of elements from `size2` or  `c`. Eg-> if after `row >= r` , we have `mask == 0110` then this means `1,2` were picked but `0 , 3` still remain.\\n\\n* Now we add the remaining elements cost , By precomputing the best cost for each element from `size2` in `colMin` .\\n```\\nclass Solution {\\npublic:\\n    int r , c , dp[12][(1 << 12)] ; \\n    vector<int> colMin ; \\n    \\n    int solve(int row , int mask , vector<vector<int>> &cost){\\n        if(row >= r){\\n            int rem = 0 ;\\n            for(int j = 0 ; j < c ; ++j ){\\n                //take the remaining ones which were not in the mask \\n                if( !((1 << j) & mask)) rem += colMin[j] ;\\n            }\\n            return rem ;\\n        }\\n        if(dp[row][mask] != -1) return dp[row][mask] ;\\n        int ans = INT_MAX ;\\n        \\n        for(int j = 0 ; j < c; ++j ) ans = min(ans,cost[row][j] + solve(row + 1 , mask|(1 << j) , cost )) ;\\n        return dp[row][mask] = ans ;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        r = cost.size() , c = cost[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        colMin.resize(c,INT_MAX) ;\\n        \\n        for(int i = 0 ; i < r ; ++i )\\n            for(int j = 0 ; j < c ; ++j )\\n                colMin[j] = min(colMin[j] ,cost[i][j]) ;\\n        \\n        return solve(0,0,cost) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r , c , dp[12][(1 << 12)] ; \\n    vector<int> colMin ; \\n    \\n    int solve(int row , int mask , vector<vector<int>> &cost){\\n        if(row >= r){\\n            int rem = 0 ;\\n            for(int j = 0 ; j < c ; ++j ){\\n                //take the remaining ones which were not in the mask \\n                if( !((1 << j) & mask)) rem += colMin[j] ;\\n            }\\n            return rem ;\\n        }\\n        if(dp[row][mask] != -1) return dp[row][mask] ;\\n        int ans = INT_MAX ;\\n        \\n        for(int j = 0 ; j < c; ++j ) ans = min(ans,cost[row][j] + solve(row + 1 , mask|(1 << j) , cost )) ;\\n        return dp[row][mask] = ans ;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        r = cost.size() , c = cost[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        colMin.resize(c,INT_MAX) ;\\n        \\n        for(int i = 0 ; i < r ; ++i )\\n            for(int j = 0 ; j < c ; ++j )\\n                colMin[j] = min(colMin[j] ,cost[i][j]) ;\\n        \\n        return solve(0,0,cost) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204940,
                "title": "c-dp-with-bit-masking",
                "content": "```\\nclass Solution {\\nprivate:\\n    //memoization table with two variables:-\\n    //index->defines a point in group 1\\n    //config->is a bitmask used to keep a track of the points in group 2 which have been paired\\n    vector<vector<int>>mem;\\n    //stores the minimum cost required to connect a point in group 2 to any point in group 1\\n    vector<int>minCostForColumn;\\n    int solve(vector<vector<int>>&cost,int index,int config){\\n        int size1=cost.size(),size2=cost[0].size();\\n        if(index==size1){\\n            //all the group one points have been connected, the group two points which remain\\n            //will be connected to those points which have the least cost\\n            int ans=0;\\n            for(int i=0;i<size2;i++){\\n                if(((config>>i)&1)==0){\\n                    ans+=minCostForColumn[i];\\n                }\\n            }\\n            return ans;\\n        } else if(mem[index][config]!=-1){\\n            return mem[index][config];\\n        } else {\\n            int ans=1e9;\\n            //every point in group 1 is connected to atleast one point in group 2. Here we \\n            //brute force all possible options\\n            for(int i=0;i<size2;i++){\\n                ans=min(ans,cost[index][i]+solve(cost,index+1,config|(1<<i)));\\n            }\\n            return mem[index][config]=ans;\\n        }\\n    }\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int size1=cost.size(),size2=cost[0].size();\\n        minCostForColumn=vector<int>(size2,1e9);\\n        mem=vector<vector<int>>(size1,vector<int>(1<<size2,-1));\\n        //storing the minimum cost for each element in the second group of points\\n        for(int j=0;j<size2;j++){\\n            for(int i=0;i<size1;i++){\\n                minCostForColumn[j]=min(minCostForColumn[j],cost[i][j]);\\n            }\\n        }\\n        return solve(cost,0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\nprivate:\\n    //memoization table with two variables:-\\n    //index->defines a point in group 1\\n    //config->is a bitmask used to keep a track of the points in group 2 which have been paired\\n    vector<vector<int>>mem;\\n    //stores the minimum cost required to connect a point in group 2 to any point in group 1\\n    vector<int>minCostForColumn;\\n    int solve(vector<vector<int>>&cost,int index,int config){\\n        int size1=cost.size(),size2=cost[0].size();\\n        if(index==size1){\\n            //all the group one points have been connected, the group two points which remain\\n            //will be connected to those points which have the least cost\\n            int ans=0;\\n            for(int i=0;i<size2;i++){\\n                if(((config>>i)&1)==0){\\n                    ans+=minCostForColumn[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2169235,
                "title": "python-recursion-bit-manipulation-lru-cache",
                "content": "```\\nclass Solution:\\n    def connectTwoGroups(self, x: List[List[int]]) -> int:\\n        m,n=len(x),len(x[0])\\n        @lru_cache(None)\\n        def f(i,v):\\n            if i==m:\\n                return 0 if v==2**n-1 else inf\\n            ans=inf\\n            for j in range(n):\\n                if v&(1<<j)==0:\\n                    ans=min(ans,x[i][j]+min(f(i+1,(v|(1<<j))),f(i,(v|(1<<j)))))\\n                else:\\n                    ans=min(ans,x[i][j]+f(i+1,v))\\n            return ans\\n        return f(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, x: List[List[int]]) -> int:\\n        m,n=len(x),len(x[0])\\n        @lru_cache(None)\\n        def f(i,v):\\n            if i==m:\\n                return 0 if v==2**n-1 else inf\\n            ans=inf\\n            for j in range(n):\\n                if v&(1<<j)==0:\\n                    ans=min(ans,x[i][j]+min(f(i+1,(v|(1<<j))),f(i,(v|(1<<j)))))\\n                else:\\n                    ans=min(ans,x[i][j]+f(i+1,v))\\n            return ans\\n        return f(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106264,
                "title": "recursive-with-memorization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m,dp[13][4096],mn[13];\\n    \\n    int sol(int i,int mask,vector<vector<int>>& cost)\\n    {\\n        if(i==n)\\n        {\\n            int extra=0;\\n            for(int j=0;j<m;j++)\\n                if((mask & (1<<j)) == 0)\\n                    extra+=mn[j];\\n            return extra;\\n        }\\n        \\n        int ans=dp[i][mask];\\n        if(ans!=-1) return ans;\\n        ans=1e9;\\n        \\n        for(int j=0;j<m;j++)\\n            ans=min(ans,cost[i][j]+sol(i+1,mask|(1<<j),cost));\\n        \\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        n=cost.size(); m=cost[0].size();\\n        \\n        for(int j=0;j<13;j++) mn[j]=1e9;\\n        for(int j=0;j<m;j++)\\n            for(int i=0;i<n;i++)\\n                mn[j]=min(mn[j],cost[i][j]);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,cost);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,dp[13][4096],mn[13];\\n    \\n    int sol(int i,int mask,vector<vector<int>>& cost)\\n    {\\n        if(i==n)\\n        {\\n            int extra=0;\\n            for(int j=0;j<m;j++)\\n                if((mask & (1<<j)) == 0)\\n                    extra+=mn[j];\\n            return extra;\\n        }\\n        \\n        int ans=dp[i][mask];\\n        if(ans!=-1) return ans;\\n        ans=1e9;\\n        \\n        for(int j=0;j<m;j++)\\n            ans=min(ans,cost[i][j]+sol(i+1,mask|(1<<j),cost));\\n        \\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        n=cost.size(); m=cost[0].size();\\n        \\n        for(int j=0;j<13;j++) mn[j]=1e9;\\n        for(int j=0;j<m;j++)\\n            for(int i=0;i<n;i++)\\n                mn[j]=min(mn[j],cost[i][j]);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,cost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079486,
                "title": "c-dp-with-bitmask-this-was-kinda-hard-for-me-even-after-reading-the-solutions",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\t// let us set the unpaired guy to 1 (1 means that guy is not paired with anyone)\\n\\n\\t/*\\n\\t\\tfirst understand the information given by mask :\\n\\t\\tmask tells us which node from the 2nd group is paired and which node from the second group is not paired\\n\\n\\t\\tfor example, if mask is 1001010 it means that the 0, 2, 4, 5 nodes [in the second group] are paired\\n\\t\\twith someone or the other in first group, and those indices which are 1 are still unpaired\\n\\n\\t\\tdp[i][mask] : the minimum cost to pair every node in the first group, starting from the i\\'th node, such that\\n\\t\\tthe state of the second group is given by mask\\n\\n\\t\\tnow the base case is when all the nodes in the group 1 have been paired, so in this case, we will simply\\n\\t\\tpair the unpaired nodes of the second group using each node\\'s minimum weight (the minimum weight which is connected to every node)\\n\\n\\t*/\\n\\n\\n\\tvector<int> minCost;\\n\\tint dp[13][((1 << 12) + 1)] = {{ -1}};\\n\\n\\tint solve(vector<vector<int>>& cost, int i, int maskB) {\\n\\n\\t\\t// cout << i << \\'\\\\n\\';\\n\\t\\tif (i == cost.size()) {\\n\\t\\t\\tint baseAns = 0;\\n\\n\\t\\t\\twhile (maskB) {\\n\\t\\t\\t\\tint j = maskB & -maskB;\\n\\t\\t\\t\\tint idx = log2(j);\\n\\t\\t\\t\\tbaseAns += minCost[idx];\\n\\t\\t\\t\\tmaskB -= j;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn baseAns;\\n\\t\\t}\\n\\n\\t\\tif (dp[i][maskB] != -1) return dp[i][maskB];\\n\\n\\t\\tint ans = 1e9;\\n\\t\\tfor (int j = 0; j < cost[0].size(); j++) {\\n\\n\\t\\t\\tans = min(ans, cost[i][j] + solve(cost, i + 1, (maskB & (~(1 << j)))));\\n\\t\\t}\\n\\n\\t\\treturn dp[i][maskB] = ans;\\n\\t}\\n\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n\\t\\tint m = cost.size();\\n\\t\\tint n = cost[0].size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\n\\t\\tminCost.resize(n, INT_MAX);\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tminCost[j] = min(minCost[j], cost[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn solve(cost, 0, ((1 << n) - 1));\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\t// let us set the unpaired guy to 1 (1 means that guy is not paired with anyone)\\n\\n\\t/*\\n\\t\\tfirst understand the information given by mask :\\n\\t\\tmask tells us which node from the 2nd group is paired and which node from the second group is not paired\\n\\n\\t\\tfor example, if mask is 1001010 it means that the 0, 2, 4, 5 nodes [in the second group] are paired\\n\\t\\twith someone or the other in first group, and those indices which are 1 are still unpaired\\n\\n\\t\\tdp[i][mask] : the minimum cost to pair every node in the first group, starting from the i\\'th node, such that\\n\\t\\tthe state of the second group is given by mask\\n\\n\\t\\tnow the base case is when all the nodes in the group 1 have been paired, so in this case, we will simply\\n\\t\\tpair the unpaired nodes of the second group using each node\\'s minimum weight (the minimum weight which is connected to every node)\\n\\n\\t*/\\n\\n\\n\\tvector<int> minCost;\\n\\tint dp[13][((1 << 12) + 1)] = {{ -1}};\\n\\n\\tint solve(vector<vector<int>>& cost, int i, int maskB) {\\n\\n\\t\\t// cout << i << \\'\\\\n\\';\\n\\t\\tif (i == cost.size()) {\\n\\t\\t\\tint baseAns = 0;\\n\\n\\t\\t\\twhile (maskB) {\\n\\t\\t\\t\\tint j = maskB & -maskB;\\n\\t\\t\\t\\tint idx = log2(j);\\n\\t\\t\\t\\tbaseAns += minCost[idx];\\n\\t\\t\\t\\tmaskB -= j;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn baseAns;\\n\\t\\t}\\n\\n\\t\\tif (dp[i][maskB] != -1) return dp[i][maskB];\\n\\n\\t\\tint ans = 1e9;\\n\\t\\tfor (int j = 0; j < cost[0].size(); j++) {\\n\\n\\t\\t\\tans = min(ans, cost[i][j] + solve(cost, i + 1, (maskB & (~(1 << j)))));\\n\\t\\t}\\n\\n\\t\\treturn dp[i][maskB] = ans;\\n\\t}\\n\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n\\t\\tint m = cost.size();\\n\\t\\tint n = cost[0].size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\n\\t\\tminCost.resize(n, INT_MAX);\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tminCost[j] = min(minCost[j], cost[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn solve(cost, 0, ((1 << n) - 1));\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1983370,
                "title": "dp-with-bitmask-100-memory",
                "content": "Since the dp transition only depends on last row, we can shrink the dp dimension to just 2. (Previous row and current row) And update after each loop.\\n```\\nclass Solution {\\n    int sz1, sz2;\\n    const static int upper = 1 << 12;\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost)\\n    {\\n        sz1 = cost.size(), sz2 = cost[0].size(); \\n        const int mask_sz = 1 << sz2;\\n        int dp_pre[upper], dp_cur[upper];\\n        fill(dp_pre, dp_pre + mask_sz, 0);\\n        fill(dp_cur, dp_cur + mask_sz, INT_MAX);\\n        for(int j = 1; j < mask_sz; j++) //compute result for connecting first node on left\\n            for(int k = 0; k < sz2; k++)\\n                if(j & (1<<k))\\n                    dp_pre[j] += cost[0][k];                               \\n        \\n        for(int i = 1; i < sz1; i++){\\n            for(int j = 1; j < mask_sz; j++) //start 1 since 0 is impossible. Some on the right must included already\\n                for(int e = 0; e < sz2; e++)\\n                    dp_cur[j | (1 << e)] = min(dp_cur[j|(1<<e)], cost[i][e] + min(dp_pre[j], dp_cur[j]);\\n                \\n            swap(dp_pre, dp_cur);\\n            fill(dp_cur, dp_cur + mask_sz, INT_MAX);\\n        }\\n        \\n        return dp_pre[mask_sz - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int sz1, sz2;\\n    const static int upper = 1 << 12;\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost)\\n    {\\n        sz1 = cost.size(), sz2 = cost[0].size(); \\n        const int mask_sz = 1 << sz2;\\n        int dp_pre[upper], dp_cur[upper];\\n        fill(dp_pre, dp_pre + mask_sz, 0);\\n        fill(dp_cur, dp_cur + mask_sz, INT_MAX);\\n        for(int j = 1; j < mask_sz; j++) //compute result for connecting first node on left\\n            for(int k = 0; k < sz2; k++)\\n                if(j & (1<<k))\\n                    dp_pre[j] += cost[0][k];                               \\n        \\n        for(int i = 1; i < sz1; i++){\\n            for(int j = 1; j < mask_sz; j++) //start 1 since 0 is impossible. Some on the right must included already\\n                for(int e = 0; e < sz2; e++)\\n                    dp_cur[j | (1 << e)] = min(dp_cur[j|(1<<e)], cost[i][e] + min(dp_pre[j], dp_cur[j]);\\n                \\n            swap(dp_pre, dp_cur);\\n            fill(dp_cur, dp_cur + mask_sz, INT_MAX);\\n        }\\n        \\n        return dp_pre[mask_sz - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784196,
                "title": "dp",
                "content": "```\\nconst int N = 13, M = 1 << N;\\n\\nclass Solution {\\n    int f[N][M];\\n    \\npublic:\\n    // time: O(nm*2^m)\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size(), m = cost[0].size();\\n        memset(f, 0x3f, sizeof f);\\n        \\n        f[0][0] = 0;\\n        for (int i = 1; i <= n; ++ i) // n\\n        {\\n            for (int j = 0; j < (1 << m); ++ j) // 2^m\\n            {\\n                for (int k = 0; k < m; ++ k) // m\\n                {\\n                    f[i][j|(1<<k)] = min(f[i][j|(1<<k)], f[i][j] + cost[i-1][k]);   // \\u53EF\\u4EE5\\u9009\\u62E9\\u7EE7\\u7EED\\u7528\\u5F53\\u524D\\u70B9match \\n                    f[i][j|(1<<k)] = min(f[i][j|(1<<k)], f[i-1][j] + cost[i-1][k]); // \\u53EF\\u4EE5\\u9009\\u62E9\\u8F6C\\u79FB\\u5230\\u4E0B\\u4E00\\u4E2A\\u70B9\\u8FDB\\u884Cmatch\\n                }\\n            }\\n        }\\n        \\n        return f[n][(1<<m)-1];\\n    }\\n};\\n\\n\\n// \\u8BFB\\u9898\\uFF1A\\u6570\\u7EC4\\u957F\\u5EA6\\u4E0D\\u540C\\uFF0C\\u6570\\u636E\\u8303\\u56F4\\u53EF\\u4EE5\\u72B6\\u6001\\u538B\\u7F29\\uFF0C \\u4E00\\u4E2A\\u70B9\\u53EF\\u4EE5\\u5339\\u914D\\u591A\\u4E2A\\u70B9\\uFF0C\\u4FDD\\u8BC1\\u6BCF\\u4E2A\\u70B9\\u81F3\\u5C11\\u6709\\u4E00\\u4E2A\\u5339\\u914D\\uFF0C\\n\\n\\n// dp:\\n//     \\u72B6\\u6001\\uFF1Af[i][j]: \\u7B2C\\u4E8C\\u7EC4\\u7684\\u72B6\\u6001\\u662Fi\\uFF0C\\u53EF\\u4EE5\\u5339\\u914D\\u6240\\u6709\\u7B2C\\u4E00\\u7EC4\\u7684\\u524Dj\\u4E2A\\u6570\\uFF0C\\u6700\\u5C0F\\u7684\\u82B1\\u8D39\\n//     \\u8F6C\\u79FB\\uFF1A \\n        \\n        \\n// 12 * 2^12 = 49152\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 13, M = 1 << N;\\n\\nclass Solution {\\n    int f[N][M];\\n    \\npublic:\\n    // time: O(nm*2^m)\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size(), m = cost[0].size();\\n        memset(f, 0x3f, sizeof f);\\n        \\n        f[0][0] = 0;\\n        for (int i = 1; i <= n; ++ i) // n\\n        {\\n            for (int j = 0; j < (1 << m); ++ j) // 2^m\\n            {\\n                for (int k = 0; k < m; ++ k) // m\\n                {\\n                    f[i][j|(1<<k)] = min(f[i][j|(1<<k)], f[i][j] + cost[i-1][k]);   // \\u53EF\\u4EE5\\u9009\\u62E9\\u7EE7\\u7EED\\u7528\\u5F53\\u524D\\u70B9match \\n                    f[i][j|(1<<k)] = min(f[i][j|(1<<k)], f[i-1][j] + cost[i-1][k]); // \\u53EF\\u4EE5\\u9009\\u62E9\\u8F6C\\u79FB\\u5230\\u4E0B\\u4E00\\u4E2A\\u70B9\\u8FDB\\u884Cmatch\\n                }\\n            }\\n        }\\n        \\n        return f[n][(1<<m)-1];\\n    }\\n};\\n\\n\\n// \\u8BFB\\u9898\\uFF1A\\u6570\\u7EC4\\u957F\\u5EA6\\u4E0D\\u540C\\uFF0C\\u6570\\u636E\\u8303\\u56F4\\u53EF\\u4EE5\\u72B6\\u6001\\u538B\\u7F29\\uFF0C \\u4E00\\u4E2A\\u70B9\\u53EF\\u4EE5\\u5339\\u914D\\u591A\\u4E2A\\u70B9\\uFF0C\\u4FDD\\u8BC1\\u6BCF\\u4E2A\\u70B9\\u81F3\\u5C11\\u6709\\u4E00\\u4E2A\\u5339\\u914D\\uFF0C\\n\\n\\n// dp:\\n//     \\u72B6\\u6001\\uFF1Af[i][j]: \\u7B2C\\u4E8C\\u7EC4\\u7684\\u72B6\\u6001\\u662Fi\\uFF0C\\u53EF\\u4EE5\\u5339\\u914D\\u6240\\u6709\\u7B2C\\u4E00\\u7EC4\\u7684\\u524Dj\\u4E2A\\u6570\\uFF0C\\u6700\\u5C0F\\u7684\\u82B1\\u8D39\\n//     \\u8F6C\\u79FB\\uFF1A \\n        \\n        \\n// 12 * 2^12 = 49152\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722206,
                "title": "easiest-solution-to-understand-with-explanation-comments-c",
                "content": "-> We traverse through points in Group 1(assume g1) one by one and try to connect that particular point to all possible subsets in Group 2.(assume g2)\\n\\n***-> 2 important observations in this question is that :\\n\\n1. We can either connect the current point in G1 to a subset of points in G2 which are not already visited by any previous point.\\n2. GREEDY POINT : We can connect the current point P1 in G1 to exactly one point P2 which is already visited by any previous point in G1 and only if distance P1-P2 has to be shortest amongst all edges starting from P1. *\\n\\n=> Why ? Because P2 does not need P1 , it\\'s already connected to group 1 , so if any other edge exists starting from P1 (let\\'s say to some point P3 in group 2) whose weight is lesser than edge from P1-P2, then it makes sense to connect P1 and P3 , as here we are able to connect 2 unvisited points P1 and P3, with lesser edge weight , but if we connect P1 and P2, we connect only 1 unvisited point which is P1 and that too with more weight. \\n\\n=> So the only case in which we join P1 and P2 is  if distance of edge P1-P2 is shortest amongst all edges starting from P1. \\n\\n ```\\n So, dp[i][bitmask] = min(\\n\\t\\tdp[i+1][bitmask] + cost[i][node with shortest distance from i] , \\n\\t\\tminimum over ALL (dp[i+1][s] + Sum Of distances from node number i to the new subset of nodes we visted from i ) for all possible submasks \\'s\\' of current bitmask)\\n\\t\\t);\\n ```\\n\\n=> Initially bitmask = All 1s , where 1 denoted a node in Group 2 to be \"yet not connected \" and 0 indicates \"already connected\".\\n=> So we can actually use \"Submask Enumeration\" to generate all submasks of current bitmask. A Submask means \"All 0s remain 0s(connected remains connected), a subset of 1s in bitmask gets flipped to 0\".\\n\\n**Time Complexity : O( n*(2^m) )**\\n**Space Complexity : O( n*(2^m) )**\\n\\n```\\nclass Solution {\\npublic:\\n    const int INF = 100000;\\n    \\n    int dp[12][1<<12];\\n    \\n    int helper(int cur, int bitmask, vector<vector<int>>& cost,vector<int>& minCostFrom, vector<vector<int>>& preCost, vector<int> &Friend, int n, int m){\\n        if(cur==n){ \\n            if(bitmask==0)\\n                return 0;\\n            else\\n                return INF;\\n        }\\n        \\n        if(dp[cur][bitmask] != -1)\\n            return dp[cur][bitmask];\\n        \\n        // If you are joining \\'cur\\' node in group one with exactly one node in group 2, it doesn\\'t matter, whether that node in group 2 is already visited or not. Don\\'t forget to FLIP THE BIT.\\n        int ans = minCostFrom[cur] + helper(cur+1,bitmask & (~(1<<Friend[cur])),cost,minCostFrom,preCost,Friend,n,m);\\n        \\n        //Given a bitmask , you want to efficiently iterate through all of its submasks, that is, masks  in which only bits that were included in mask  are set, which is basically \"SUBMASK ENUMERATION\".\\n        int tmp_bitmask = bitmask;\\n        \\n        while(tmp_bitmask){\\n            //(tmp_bitmask-1) sets rightmost set bit 0 and all bits after it become 1. ANDing it with bitmask will generate next submask in descending. Learn in detail on CP algorithms website.\\n            tmp_bitmask = (tmp_bitmask-1) & bitmask; \\n            // 0s will remain 0 in submask , but some 1s turn to 0, to find out which 1s turn to 0, we take the difference So only the bits which changed from 1 to 0 will be SET , rest all will be 0s, so now just flip the bits using XOR.\\n            int tmp_bitmask2 = (bitmask - tmp_bitmask) ^ ((1<<m)-1);\\n            \\n            ans = min(ans,preCost[cur][tmp_bitmask2] + helper(cur+1,tmp_bitmask,cost,minCostFrom,preCost,Friend,n,m));\\n        }\\n        \\n        return dp[cur][bitmask] = ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        \\n        vector<int> minCostFrom(n,INT_MAX);\\n        vector<int> Friend(n);\\n        \\n        // Pre-store the weight of the shortest edge from every node \\'i\\'.\\n        //Friend[i] means the node in group 2 with shortest edge weight from \\'i\\'.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(cost[i][j] < minCostFrom[i]){\\n                    minCostFrom[i] = cost[i][j];\\n                    Friend[i] = j;\\n                }\\n            }\\n        }\\n        \\n        // Precalculate the Sum of Edges from every node \\'i\\' to all possible subsets in group 2.\\n        // If the ith bit from LSB in the bitmask is 1, that means that the ith node in the 2nd group is still not visited.\\n        vector<vector<int>> preCost(n,vector<int>(1<<m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(1<<m);j++){\\n                int sum = 0;\\n                for(int k=0; k<m;k++){\\n                    if(((1<<k) & j) == 0){\\n                        sum+=cost[i][k];\\n                    }\\n                }\\n                preCost[i][j] = sum;\\n            }\\n        }\\n        \\n        for(int i=0;i<12;i++){\\n            for(int j=0; j<(1<<12); j++){\\n                dp[i][j] = -1;\\n            }    \\n        }\\n\\n        return helper(0,(1<<m)-1,cost,minCostFrom,preCost,Friend,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n So, dp[i][bitmask] = min(\\n\\t\\tdp[i+1][bitmask] + cost[i][node with shortest distance from i] , \\n\\t\\tminimum over ALL (dp[i+1][s] + Sum Of distances from node number i to the new subset of nodes we visted from i ) for all possible submasks \\'s\\' of current bitmask)\\n\\t\\t);\\n ```\n```\\nclass Solution {\\npublic:\\n    const int INF = 100000;\\n    \\n    int dp[12][1<<12];\\n    \\n    int helper(int cur, int bitmask, vector<vector<int>>& cost,vector<int>& minCostFrom, vector<vector<int>>& preCost, vector<int> &Friend, int n, int m){\\n        if(cur==n){ \\n            if(bitmask==0)\\n                return 0;\\n            else\\n                return INF;\\n        }\\n        \\n        if(dp[cur][bitmask] != -1)\\n            return dp[cur][bitmask];\\n        \\n        // If you are joining \\'cur\\' node in group one with exactly one node in group 2, it doesn\\'t matter, whether that node in group 2 is already visited or not. Don\\'t forget to FLIP THE BIT.\\n        int ans = minCostFrom[cur] + helper(cur+1,bitmask & (~(1<<Friend[cur])),cost,minCostFrom,preCost,Friend,n,m);\\n        \\n        //Given a bitmask , you want to efficiently iterate through all of its submasks, that is, masks  in which only bits that were included in mask  are set, which is basically \"SUBMASK ENUMERATION\".\\n        int tmp_bitmask = bitmask;\\n        \\n        while(tmp_bitmask){\\n            //(tmp_bitmask-1) sets rightmost set bit 0 and all bits after it become 1. ANDing it with bitmask will generate next submask in descending. Learn in detail on CP algorithms website.\\n            tmp_bitmask = (tmp_bitmask-1) & bitmask; \\n            // 0s will remain 0 in submask , but some 1s turn to 0, to find out which 1s turn to 0, we take the difference So only the bits which changed from 1 to 0 will be SET , rest all will be 0s, so now just flip the bits using XOR.\\n            int tmp_bitmask2 = (bitmask - tmp_bitmask) ^ ((1<<m)-1);\\n            \\n            ans = min(ans,preCost[cur][tmp_bitmask2] + helper(cur+1,tmp_bitmask,cost,minCostFrom,preCost,Friend,n,m));\\n        }\\n        \\n        return dp[cur][bitmask] = ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        \\n        vector<int> minCostFrom(n,INT_MAX);\\n        vector<int> Friend(n);\\n        \\n        // Pre-store the weight of the shortest edge from every node \\'i\\'.\\n        //Friend[i] means the node in group 2 with shortest edge weight from \\'i\\'.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(cost[i][j] < minCostFrom[i]){\\n                    minCostFrom[i] = cost[i][j];\\n                    Friend[i] = j;\\n                }\\n            }\\n        }\\n        \\n        // Precalculate the Sum of Edges from every node \\'i\\' to all possible subsets in group 2.\\n        // If the ith bit from LSB in the bitmask is 1, that means that the ith node in the 2nd group is still not visited.\\n        vector<vector<int>> preCost(n,vector<int>(1<<m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(1<<m);j++){\\n                int sum = 0;\\n                for(int k=0; k<m;k++){\\n                    if(((1<<k) & j) == 0){\\n                        sum+=cost[i][k];\\n                    }\\n                }\\n                preCost[i][j] = sum;\\n            }\\n        }\\n        \\n        for(int i=0;i<12;i++){\\n            for(int j=0; j<(1<<12); j++){\\n                dp[i][j] = -1;\\n            }    \\n        }\\n\\n        return helper(0,(1<<m)-1,cost,minCostFrom,preCost,Friend,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638973,
                "title": "golang-dp-w-bitmask",
                "content": "if we use a bitmask representation, can reduce to 12 * 2^12 space\\n\\nnumber of ways to represent the 12 bits = 2^12 = 4096\\n\\nidea is to just try out every combination of choosing an element in group 1 to connect to an element in group 2.\\n\\nthen when all elements in group 1 is connected to group 2, for all elements unconnected in group 2, connect it to group 1 with the min cost to connect to an element in group 1. \\n\\nbitmask is used to indicate which element in group 2 has been connected.\\n\\nnot my idea, read from other solutions, posting this as reference for golang implementation\\n\\n\\n```\\nfunc connectTwoGroups(cost [][]int) int {\\n    // dp problem, try out every possibility\\n    size1, size2 := len(cost), len(cost[0])\\n    \\n    cache := make([][]*int, size1)\\n    for i := range cache {\\n        cache[i] = make([]*int, 1 << size2)\\n    }\\n    \\n    minCost2To1 := make([]int, size2)\\n    for j := range cost[0] {\\n        m := math.MaxInt32\\n        for i := range cost {\\n            m = min(m, cost[i][j])\\n        }\\n        minCost2To1[j] = m\\n    }\\n    \\n    return dfs(&cache, minCost2To1, cost, 0, 0)\\n}\\n\\n// mask keeps track of which element in second group is not yet connected\\nfunc dfs(cache *[][]*int, minCost2To1 []int, cost [][]int, i, mask int) int {\\n    if i == len(cost) {  // all in group 1 is connected\\n        res := 0\\n        // connect all group 2 that are not yet connect\\n        for j := range cost[0] {\\n            if mask & (1 << j) == 0 {  // bit unset at index j means element j in group 2 not yet connected\\n                res += minCost2To1[j]  // add the min cost\\n            }\\n        }\\n        return res\\n    }\\n    \\n    if (*cache)[i][mask] != nil {\\n        return *(*cache)[i][mask]\\n    }\\n    \\n    res := math.MaxInt32\\n    for j := range cost[i] {  // try to connect i (an element in group 1) to 1 of the elements in group 2\\n        res = min(res, dfs(cache, minCost2To1, cost, i+1, mask | (1 << j)) + cost[i][j])\\n    }\\n    \\n    (*cache)[i][mask] = &res\\n    \\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc connectTwoGroups(cost [][]int) int {\\n    // dp problem, try out every possibility\\n    size1, size2 := len(cost), len(cost[0])\\n    \\n    cache := make([][]*int, size1)\\n    for i := range cache {\\n        cache[i] = make([]*int, 1 << size2)\\n    }\\n    \\n    minCost2To1 := make([]int, size2)\\n    for j := range cost[0] {\\n        m := math.MaxInt32\\n        for i := range cost {\\n            m = min(m, cost[i][j])\\n        }\\n        minCost2To1[j] = m\\n    }\\n    \\n    return dfs(&cache, minCost2To1, cost, 0, 0)\\n}\\n\\n// mask keeps track of which element in second group is not yet connected\\nfunc dfs(cache *[][]*int, minCost2To1 []int, cost [][]int, i, mask int) int {\\n    if i == len(cost) {  // all in group 1 is connected\\n        res := 0\\n        // connect all group 2 that are not yet connect\\n        for j := range cost[0] {\\n            if mask & (1 << j) == 0 {  // bit unset at index j means element j in group 2 not yet connected\\n                res += minCost2To1[j]  // add the min cost\\n            }\\n        }\\n        return res\\n    }\\n    \\n    if (*cache)[i][mask] != nil {\\n        return *(*cache)[i][mask]\\n    }\\n    \\n    res := math.MaxInt32\\n    for j := range cost[i] {  // try to connect i (an element in group 1) to 1 of the elements in group 2\\n        res = min(res, dfs(cache, minCost2To1, cost, i+1, mask | (1 << j)) + cost[i][j])\\n    }\\n    \\n    (*cache)[i][mask] = &res\\n    \\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582370,
                "title": "python-o-n-3-m",
                "content": "Our state is, we are choosing connections for i-th node of the 1st group, while already picked connections for some subset of 2nd group represented in bits. We can pick one connection for i-th node from already picked ones, in this case our subset represented as bits doesn\\'t change. Or we pick some subset of node from complement of already picked, which are subsets of bits ^ (2 ** m - 1). Number of such subsets for each possible bits value in total is 3 ^ m. Thus our complexity. To speed up we precompute some sums and minimums, and also write dp non-recursively.\\n\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost):\\n        n, m = len(cost), len(cost[0])\\n        p2m = 1 << m\\n        inf = 10 ** 9\\n\\n        pc_summs = [[0 for __ in range(p2m)] for _ in range(n)]\\n        pc_mins = [[inf for __ in range(p2m)] for _ in range(n)]\\n\\n        for i in range(n):\\n            for bits in range(p2m):\\n                for b in range(m):\\n                    if (1 << b) & bits:\\n                        pc_summs[i][bits] += cost[i][b]\\n                        pc_mins[i][bits] = min(pc_mins[i][bits], cost[i][b])\\n\\n        dp = [[inf for __ in range(p2m)] for _ in range(n + 1)]\\n        dp[n][p2m - 1] = 0\\n\\n        for i in range(n - 1, -1, -1):\\n            for bits in range(p2m):\\n                if i == 0 and bits > 0: break\\n                if bits != 0:\\n                    dp[i][bits] = pc_mins[i][bits] + dp[i + 1][bits]\\n\\n                mask = bits ^ (p2m - 1)\\n                x = mask\\n                while x != 0:\\n                    mn = pc_summs[i][x] + dp[i + 1][bits | x]\\n                    dp[i][bits] = min(dp[i][bits] , mn)\\n                    x = (x - 1) & mask\\n\\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost):\\n        n, m = len(cost), len(cost[0])\\n        p2m = 1 << m\\n        inf = 10 ** 9\\n\\n        pc_summs = [[0 for __ in range(p2m)] for _ in range(n)]\\n        pc_mins = [[inf for __ in range(p2m)] for _ in range(n)]\\n\\n        for i in range(n):\\n            for bits in range(p2m):\\n                for b in range(m):\\n                    if (1 << b) & bits:\\n                        pc_summs[i][bits] += cost[i][b]\\n                        pc_mins[i][bits] = min(pc_mins[i][bits], cost[i][b])\\n\\n        dp = [[inf for __ in range(p2m)] for _ in range(n + 1)]\\n        dp[n][p2m - 1] = 0\\n\\n        for i in range(n - 1, -1, -1):\\n            for bits in range(p2m):\\n                if i == 0 and bits > 0: break\\n                if bits != 0:\\n                    dp[i][bits] = pc_mins[i][bits] + dp[i + 1][bits]\\n\\n                mask = bits ^ (p2m - 1)\\n                x = mask\\n                while x != 0:\\n                    mn = pc_summs[i][x] + dp[i + 1][bits | x]\\n                    dp[i][bits] = min(dp[i][bits] , mn)\\n                    x = (x - 1) & mask\\n\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529616,
                "title": "c-dp-bitmask-t-c-s-c-o-n-m-2-min-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[13][13][(1<<12)+1][2];\\n    long long go(int n1,int n2,int a,vector<vector<int>>& cost,bool f)\\n    {\\n        if(n2==cost[0].size())\\n        {\\n            if(f==0)  return INT_MAX;\\n            return go(n1+1,0,a,cost,0);\\n        }\\n        if(n1==cost.size())\\n        {\\n            if(a==(1<<cost[0].size())-1) return 0;\\n            return INT_MAX;\\n        }\\n        if(dp[n1][n2][a][f]!=-1) return dp[n1][n2][a][f];\\n        return dp[n1][n2][a][f]=min(go(n1,n2+1,a|(1<<n2),cost,1)+cost[n1][n2],go(n1,n2+1,a,cost,f));\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        memset(dp,-1,sizeof(dp));\\n        return go(0,0,0,cost,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[13][13][(1<<12)+1][2];\\n    long long go(int n1,int n2,int a,vector<vector<int>>& cost,bool f)\\n    {\\n        if(n2==cost[0].size())\\n        {\\n            if(f==0)  return INT_MAX;\\n            return go(n1+1,0,a,cost,0);\\n        }\\n        if(n1==cost.size())\\n        {\\n            if(a==(1<<cost[0].size())-1) return 0;\\n            return INT_MAX;\\n        }\\n        if(dp[n1][n2][a][f]!=-1) return dp[n1][n2][a][f];\\n        return dp[n1][n2][a][f]=min(go(n1,n2+1,a|(1<<n2),cost,1)+cost[n1][n2],go(n1,n2+1,a,cost,f));\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        memset(dp,-1,sizeof(dp));\\n        return go(0,0,0,cost,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465826,
                "title": "python-recursive-solutions-with-a-boolean-array-or-bitmask",
                "content": "__Solution 1__: First make all connection from group A (size1) to group B (size2). Finaly, we need to add the cost for the still unconnected nodes in group B. In order to solve this issue, we keep track of the connected nodes in group B with a boolean array. \\n```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tdef dfs(i, valid):\\n\\t\\tif i == size1: return sum([(not v)*d for v,d in zip(valid, dist)])        \\n\\t\\ttup = (i, tuple(valid)) # we need an immutable object for caching\\n\\t\\tif tup in memo: return memo[tup]\\n\\t\\t\\t   \\n\\t\\tans = float(\\'inf\\')\\n\\t\\t# loop over all possibilities\\n\\t\\tfor j in range(size2):\\n\\t\\t\\ttemp = valid[j]\\n\\t\\t\\tvalid[j]=True\\n\\t\\t\\tans = min(ans, cost[i][j] + dfs(i+1, valid))\\n\\t\\t\\tif not temp:\\n\\t\\t\\t\\tvalid[j]=False\\n\\t\\tmemo[tup] = ans\\n\\t\\treturn ans\\n\\t\\n\\t# declare\\n\\tsize1, size2 = len(cost), len(cost[0])\\n\\tvalid = [False]*size2 # to keep track which node in size2 is already assigned\\n\\tmemo = {}    \\n\\tdist = [0]*size2\\n\\t\\t\\n\\t# precomputed minimum sum to connect final points in size2. \\n\\tfor j in range(size2):\\n\\t\\tdist[j] = min(cost[i][j] for i in range(size1))\\n\\t\\t\\n\\treturn dfs(0, valid)\\n```\\n__Solution 2__: Now we will use a bitmask instead of an array. The principle is the same as before.\\n```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:        \\n\\t @lru_cache(None)\\n\\t def dfs(i, mask):\\n\\t\\t if i == size1: return sum((not(mask & (1 << j)))*dist[j] for j in range(size2))\\n\\t\\t ans = float(\\'inf\\')\\n\\t\\t for j in range(size2):\\n\\t\\t\\t ans = min(ans, cost[i][j]+dfs(i+1, mask | (1<<j)))\\n\\t\\t return ans\\n\\t size1, size2 = len(cost), len(cost[0])\\n\\t dist = [0]*size2\\n\\t for j in range(size2):\\n\\t\\t dist[j] = min(cost[i][j] for i in range(size1))\\n\\t return dfs(0, 0)\\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tdef dfs(i, valid):\\n\\t\\tif i == size1: return sum([(not v)*d for v,d in zip(valid, dist)])        \\n\\t\\ttup = (i, tuple(valid)) # we need an immutable object for caching\\n\\t\\tif tup in memo: return memo[tup]\\n\\t\\t\\t   \\n\\t\\tans = float(\\'inf\\')\\n\\t\\t# loop over all possibilities\\n\\t\\tfor j in range(size2):\\n\\t\\t\\ttemp = valid[j]\\n\\t\\t\\tvalid[j]=True\\n\\t\\t\\tans = min(ans, cost[i][j] + dfs(i+1, valid))\\n\\t\\t\\tif not temp:\\n\\t\\t\\t\\tvalid[j]=False\\n\\t\\tmemo[tup] = ans\\n\\t\\treturn ans\\n\\t\\n\\t# declare\\n\\tsize1, size2 = len(cost), len(cost[0])\\n\\tvalid = [False]*size2 # to keep track which node in size2 is already assigned\\n\\tmemo = {}    \\n\\tdist = [0]*size2\\n\\t\\t\\n\\t# precomputed minimum sum to connect final points in size2. \\n\\tfor j in range(size2):\\n\\t\\tdist[j] = min(cost[i][j] for i in range(size1))\\n\\t\\t\\n\\treturn dfs(0, valid)\\n```\n```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:        \\n\\t @lru_cache(None)\\n\\t def dfs(i, mask):\\n\\t\\t if i == size1: return sum((not(mask & (1 << j)))*dist[j] for j in range(size2))\\n\\t\\t ans = float(\\'inf\\')\\n\\t\\t for j in range(size2):\\n\\t\\t\\t ans = min(ans, cost[i][j]+dfs(i+1, mask | (1<<j)))\\n\\t\\t return ans\\n\\t size1, size2 = len(cost), len(cost[0])\\n\\t dist = [0]*size2\\n\\t for j in range(size2):\\n\\t\\t dist[j] = min(cost[i][j] for i in range(size1))\\n\\t return dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1348758,
                "title": "c-dp-bitmask-o-n-2-m-m",
                "content": "```\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        int dp[n+1][1<<m];\\n        for(int i=n;i>=0;i--){\\n            for(int j=0;j<(1<<m);j++){\\n                if(i==n){\\n                    dp[i][j]=0;\\n                    for(int k=0;k<m;k++){\\n                        if(!(j&(1<<k))){\\n                            int best=cost[0][k];\\n                            for(int l=1;l<n;l++){\\n                                best=min(best,cost[l][k]);\\n                            }\\n                            dp[i][j]+=best;\\n                        }\\n                    }\\n                }else{\\n                    dp[i][j]=INT_MAX;\\n                    for(int k=0;k<m;k++){\\n                        dp[i][j]=min(dp[i][j],cost[i][k]+dp[i+1][j|(1<<k)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        int dp[n+1][1<<m];\\n        for(int i=n;i>=0;i--){\\n            for(int j=0;j<(1<<m);j++){\\n                if(i==n){\\n                    dp[i][j]=0;\\n                    for(int k=0;k<m;k++){\\n                        if(!(j&(1<<k))){\\n                            int best=cost[0][k];\\n                            for(int l=1;l<n;l++){\\n                                best=min(best,cost[l][k]);\\n                            }\\n                            dp[i][j]+=best;\\n                        }\\n                    }\\n                }else{\\n                    dp[i][j]=INT_MAX;\\n                    for(int k=0;k<m;k++){\\n                        dp[i][j]=min(dp[i][j],cost[i][k]+dp[i+1][j|(1<<k)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333592,
                "title": "very-clean-code-by-memoization-dfs-with-bit-mask-scala",
                "content": "```scala\\n\\n  def connectTwoGroups(cost: List[List[Int]]): Int = {\\n    type int = Int\\n    val m  = cost.length\\n    val n  = cost(0).length\\n    var rm = 0\\n    (0 until n).foreach(x => rm = rm | (1 << x))\\n\\n    val tab = Array.ofDim[int](m, n, rm + 1)\\n\\n    def f(leftIdx: int, rightIdx: int, right: int): int = {\\n\\n      if (leftIdx == m && right == rm) return 0\\n      if (rightIdx == n || leftIdx == m) return Integer.MAX_VALUE\\n      if (tab(leftIdx)(rightIdx)(right) == 0) {\\n        var a = f(leftIdx, rightIdx + 1, right | (1 << rightIdx))\\n        var b = f(leftIdx + 1, 0, right | (1 << rightIdx))\\n        tab(leftIdx)(rightIdx)(right) = f(leftIdx, rightIdx + 1, right)\\n        if (a != Integer.MAX_VALUE)\\n          tab(leftIdx)(rightIdx)(right) =\\n            Math.min(tab(leftIdx)(rightIdx)(right), a + cost(leftIdx)(rightIdx))\\n        if (b != Integer.MAX_VALUE)\\n          tab(leftIdx)(rightIdx)(right) =\\n            Math.min(tab(leftIdx)(rightIdx)(right), b + cost(leftIdx)(rightIdx))\\n      }\\n      tab(leftIdx)(rightIdx)(right)\\n    }\\n\\n    f(0, 0, 0)\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n\\n  def connectTwoGroups(cost: List[List[Int]]): Int = {\\n    type int = Int\\n    val m  = cost.length\\n    val n  = cost(0).length\\n    var rm = 0\\n    (0 until n).foreach(x => rm = rm | (1 << x))\\n\\n    val tab = Array.ofDim[int](m, n, rm + 1)\\n\\n    def f(leftIdx: int, rightIdx: int, right: int): int = {\\n\\n      if (leftIdx == m && right == rm) return 0\\n      if (rightIdx == n || leftIdx == m) return Integer.MAX_VALUE\\n      if (tab(leftIdx)(rightIdx)(right) == 0) {\\n        var a = f(leftIdx, rightIdx + 1, right | (1 << rightIdx))\\n        var b = f(leftIdx + 1, 0, right | (1 << rightIdx))\\n        tab(leftIdx)(rightIdx)(right) = f(leftIdx, rightIdx + 1, right)\\n        if (a != Integer.MAX_VALUE)\\n          tab(leftIdx)(rightIdx)(right) =\\n            Math.min(tab(leftIdx)(rightIdx)(right), a + cost(leftIdx)(rightIdx))\\n        if (b != Integer.MAX_VALUE)\\n          tab(leftIdx)(rightIdx)(right) =\\n            Math.min(tab(leftIdx)(rightIdx)(right), b + cost(leftIdx)(rightIdx))\\n      }\\n      tab(leftIdx)(rightIdx)(right)\\n    }\\n\\n    f(0, 0, 0)\\n\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1109167,
                "title": "explanation-of-test-case",
                "content": "Can someone explain how the answer for this test case is 4.\\n[[1, 3, 5], [4, 1, 1], [1, 5, 3]]\\n\\nAccording to me the answer should be 5.\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1077612,
                "title": "java-dp-using-bitmask-different-recursive-approach-time-o-n-m-2-m",
                "content": "```\\nclass Solution {\\n\\n    private static int FULL_BITMASK;\\n    \\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        FULL_BITMASK = (1 << cost.get(0).size()) - 1;        \\n        int[][][] memo = new int[cost.size()][FULL_BITMASK + 1][2];\\n        \\n        return find(memo, cost, 0, 0, -1, -1);\\n    }\\n    \\n    private int find(int[][][] memo, List<List<Integer>> cost, int posA, int usedB, int lastA, int lastB) {\\n        if(posA == cost.size())\\n            return usedB == FULL_BITMASK ? 0 : Integer.MAX_VALUE;\\n        \\n        // we have two state from each (posA, usedB)\\n        // first state is if we reached (posA, usedB) from a previous A point\\n        // second state is if we reached (posA, usedB) from the same A point\\n        int token = (posA == lastA) ? 0 : 1;\\n        \\n        if(memo[posA][usedB][token] != 0)\\n            return memo[posA][usedB][token];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < cost.get(posA).size(); i++) {            \\n            int mask = 1 << i;  \\n            int res;\\n            \\n            // Connection from current A point -> B point (i)\\n            // Continue to add edges from current A point to other B points\\n            if((usedB & mask) == 0 && (posA != lastA || lastB < i)) {\\n                res = find(memo, cost, posA, usedB | mask, posA, i);\\n                if(res != Integer.MAX_VALUE)\\n                    min = Math.min(min, res + cost.get(posA).get(i));\\n            }\\n            \\n            // Connection from current A point -> B point (i)\\n            // Do not add futher connections from current A point, go to next A point\\n            res = find(memo, cost, posA + 1, usedB | mask, posA, i);\\n            if(res != Integer.MAX_VALUE)\\n                min = Math.min(min, res + cost.get(posA).get(i));\\n        }\\n        \\n        memo[posA][usedB][token] = min;\\n        return min;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private static int FULL_BITMASK;\\n    \\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        FULL_BITMASK = (1 << cost.get(0).size()) - 1;        \\n        int[][][] memo = new int[cost.size()][FULL_BITMASK + 1][2];\\n        \\n        return find(memo, cost, 0, 0, -1, -1);\\n    }\\n    \\n    private int find(int[][][] memo, List<List<Integer>> cost, int posA, int usedB, int lastA, int lastB) {\\n        if(posA == cost.size())\\n            return usedB == FULL_BITMASK ? 0 : Integer.MAX_VALUE;\\n        \\n        // we have two state from each (posA, usedB)\\n        // first state is if we reached (posA, usedB) from a previous A point\\n        // second state is if we reached (posA, usedB) from the same A point\\n        int token = (posA == lastA) ? 0 : 1;\\n        \\n        if(memo[posA][usedB][token] != 0)\\n            return memo[posA][usedB][token];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < cost.get(posA).size(); i++) {            \\n            int mask = 1 << i;  \\n            int res;\\n            \\n            // Connection from current A point -> B point (i)\\n            // Continue to add edges from current A point to other B points\\n            if((usedB & mask) == 0 && (posA != lastA || lastB < i)) {\\n                res = find(memo, cost, posA, usedB | mask, posA, i);\\n                if(res != Integer.MAX_VALUE)\\n                    min = Math.min(min, res + cost.get(posA).get(i));\\n            }\\n            \\n            // Connection from current A point -> B point (i)\\n            // Do not add futher connections from current A point, go to next A point\\n            res = find(memo, cost, posA + 1, usedB | mask, posA, i);\\n            if(res != Integer.MAX_VALUE)\\n                min = Math.min(min, res + cost.get(posA).get(i));\\n        }\\n        \\n        memo[posA][usedB][token] = min;\\n        return min;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061269,
                "title": "top-down-memorization",
                "content": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    Map<Integer, Integer> minCostForGroupB;\\n    int[][] mem;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        m = cost.size();\\n        n = cost.get(0).size();\\n        boolean[] visited = new boolean[n];\\n        minCostForGroupB = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int j=0; j<m; j++){\\n                min = Math.min(min, cost.get(j).get(i));\\n            }\\n            minCostForGroupB.put(i, min);\\n        }\\n        mem = new int[13][4096];\\n        for(int[] val : mem){\\n            Arrays.fill(val, -1);\\n        }\\n        return dfs(cost, 0, visited);\\n    }\\n    \\n    private int dfs(List<List<Integer>> cost, int current, boolean[] visited){\\n        int mask = getMask(visited);\\n        if(mem[current][mask]!=-1){\\n            return mem[current][mask];\\n        }\\n        if(current==m){\\n            //search through all unvisited element in B, and pick smallest cost\\n            int sum = 0;\\n            for(int i=0; i<n; i++){\\n                if(visited[i]){\\n                    continue;\\n                }\\n                sum += minCostForGroupB.get(i);\\n            }\\n            mem[current][mask] = sum;\\n            return sum;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            boolean oldValue = visited[i];\\n            visited[i] = true;\\n            int temp = cost.get(current).get(i) + dfs(cost, current+1, visited);\\n            min = Math.min(min, temp);\\n            visited[i] = oldValue;\\n        }\\n        mem[current][mask] = min;\\n        return min;\\n    }\\n    \\n    private int getMask(boolean[] visited){\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum *= 2;\\n            if(visited[i]){\\n                sum += 1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    Map<Integer, Integer> minCostForGroupB;\\n    int[][] mem;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        m = cost.size();\\n        n = cost.get(0).size();\\n        boolean[] visited = new boolean[n];\\n        minCostForGroupB = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int j=0; j<m; j++){\\n                min = Math.min(min, cost.get(j).get(i));\\n            }\\n            minCostForGroupB.put(i, min);\\n        }\\n        mem = new int[13][4096];\\n        for(int[] val : mem){\\n            Arrays.fill(val, -1);\\n        }\\n        return dfs(cost, 0, visited);\\n    }\\n    \\n    private int dfs(List<List<Integer>> cost, int current, boolean[] visited){\\n        int mask = getMask(visited);\\n        if(mem[current][mask]!=-1){\\n            return mem[current][mask];\\n        }\\n        if(current==m){\\n            //search through all unvisited element in B, and pick smallest cost\\n            int sum = 0;\\n            for(int i=0; i<n; i++){\\n                if(visited[i]){\\n                    continue;\\n                }\\n                sum += minCostForGroupB.get(i);\\n            }\\n            mem[current][mask] = sum;\\n            return sum;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            boolean oldValue = visited[i];\\n            visited[i] = true;\\n            int temp = cost.get(current).get(i) + dfs(cost, current+1, visited);\\n            min = Math.min(min, temp);\\n            visited[i] = oldValue;\\n        }\\n        mem[current][mask] = min;\\n        return min;\\n    }\\n    \\n    private int getMask(boolean[] visited){\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum *= 2;\\n            if(visited[i]){\\n                sum += 1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974882,
                "title": "p23-5",
                "content": "Hins\\nUse bitmask\\nFrom left we can go either to\\n1 - a node in right which is already assigned or\\n2 - subste of non-assigned nodes on right sid\\nFor all possible subsets on right which have not yet been assigned is\\nall x(from 1 to (1<<size2)-1) and also (x&(bm) == 0)",
                "solutionTags": [],
                "code": "Hins\\nUse bitmask\\nFrom left we can go either to\\n1 - a node in right which is already assigned or\\n2 - subste of non-assigned nodes on right sid\\nFor all possible subsets on right which have not yet been assigned is\\nall x(from 1 to (1<<size2)-1) and also (x&(bm) == 0)",
                "codeTag": "Unknown"
            },
            {
                "id": 924995,
                "title": "python-solution",
                "content": "idea : https://www.youtube.com/watch?v=hq0IVf1Falk\\n\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def solve(index ,mask):\\n            if index == size1:\\n                ans2 = 0\\n                for j in range(size2):\\n                    if (mask & (1<<j)) == 0:\\n                        ans2+=mincost[j]\\n                return ans2\\n            ans = sys.maxsize\\n            for j in range(size2):\\n                ans = min(ans,cost[index][j] + solve(index+1 , mask | (1<<j)))\\n            return ans\\n        size1 = len(cost)\\n        size2 = len(cost[0])\\n        mincost = [sys.maxsize]*size2\\n        for j in range(size2):\\n            for i in range(size1):\\n                mincost[j] = min(mincost[j] , cost[i][j])\\n        return solve(0,0)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def solve(index ,mask):\\n            if index == size1:\\n                ans2 = 0\\n                for j in range(size2):\\n                    if (mask & (1<<j)) == 0:\\n                        ans2+=mincost[j]\\n                return ans2\\n            ans = sys.maxsize\\n            for j in range(size2):\\n                ans = min(ans,cost[index][j] + solve(index+1 , mask | (1<<j)))\\n            return ans\\n        size1 = len(cost)\\n        size2 = len(cost[0])\\n        mincost = [sys.maxsize]*size2\\n        for j in range(size2):\\n            for i in range(size1):\\n                mincost[j] = min(mincost[j] , cost[i][j])\\n        return solve(0,0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 920138,
                "title": "java-dp-bitmask-33-ms-faster-than-59-93-36-6-mb-less-than-5-11",
                "content": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size();\\n        int n = cost.get(0).size();\\n        int t = 1 << n;\\n        int[][] dp = new int[2][t];\\n        Arrays.fill(dp[0], Integer.MAX_VALUE);\\n        int old = 0;\\n        int now = 0;\\n        dp[now][0] = 0;\\n        for (int i = 0; i < m; ++i) {\\n            old = now;\\n            now = 1 - now;\\n            Arrays.fill(dp[now], Integer.MAX_VALUE);\\n            for (int j = 0; j < t; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    int mask = j | (1 << k);\\n                    if (dp[old][j] != Integer.MAX_VALUE) {\\n                        dp[now][mask] = Math.min(dp[now][mask], dp[old][j] + cost.get(i).get(k));\\n                    }\\n                    if ((j & (1 << k)) == 0 && dp[now][j] != Integer.MAX_VALUE) {\\n                        dp[now][mask] = Math.min(dp[now][mask], dp[now][j] + cost.get(i).get(k));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[now][t - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size();\\n        int n = cost.get(0).size();\\n        int t = 1 << n;\\n        int[][] dp = new int[2][t];\\n        Arrays.fill(dp[0], Integer.MAX_VALUE);\\n        int old = 0;\\n        int now = 0;\\n        dp[now][0] = 0;\\n        for (int i = 0; i < m; ++i) {\\n            old = now;\\n            now = 1 - now;\\n            Arrays.fill(dp[now], Integer.MAX_VALUE);\\n            for (int j = 0; j < t; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    int mask = j | (1 << k);\\n                    if (dp[old][j] != Integer.MAX_VALUE) {\\n                        dp[now][mask] = Math.min(dp[now][mask], dp[old][j] + cost.get(i).get(k));\\n                    }\\n                    if ((j & (1 << k)) == 0 && dp[now][j] != Integer.MAX_VALUE) {\\n                        dp[now][mask] = Math.min(dp[now][mask], dp[now][j] + cost.get(i).get(k));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[now][t - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900063,
                "title": "ruby-dfs-bitmask-beats-100",
                "content": "1. @hash[i][bits] means the cost for (0..i) left group matched with right group.\\n2. Initialy, @hash[i][bits] come from the @hash[i-1][bits].\\n3. @hash[i][bits1] come from @hash[i][bits] by add @cost[i][j], and the **bits1 = bits | (1 << j)**.\\n\\n```\\ndef dfs(i, cur, from)\\n  @cost[i].each_with_index do |tmp, j|\\n    state = cur | (1 << j)\\n    cost = @hash[from][cur] + @cost[i][j]\\n    next if @hash[i][state] && cost >= @hash[i][state] || @hash[i][@key] && cost > @hash[i][@key]\\n    @hash[i][state] = cost\\n    dfs(i, state, i)\\n  end\\nend\\n\\n# @param {Integer[][]} cost\\n# @return {Integer}\\ndef connect_two_groups(cost)\\n  @cost, @n, @m, @hash = cost, cost.size, cost[0].size, { -1 => {0 => 0} }\\n  @key = (1 << @m) - 1\\n\\n  (0..@n-1).each do |i|\\n    @hash[i] = {}\\n    @hash[i-1].each { |cur, total| dfs(i, cur, i-1) }\\n  end\\n  @hash[@n-1][@key]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef dfs(i, cur, from)\\n  @cost[i].each_with_index do |tmp, j|\\n    state = cur | (1 << j)\\n    cost = @hash[from][cur] + @cost[i][j]\\n    next if @hash[i][state] && cost >= @hash[i][state] || @hash[i][@key] && cost > @hash[i][@key]\\n    @hash[i][state] = cost\\n    dfs(i, state, i)\\n  end\\nend\\n\\n# @param {Integer[][]} cost\\n# @return {Integer}\\ndef connect_two_groups(cost)\\n  @cost, @n, @m, @hash = cost, cost.size, cost[0].size, { -1 => {0 => 0} }\\n  @key = (1 << @m) - 1\\n\\n  (0..@n-1).each do |i|\\n    @hash[i] = {}\\n    @hash[i-1].each { |cur, total| dfs(i, cur, i-1) }\\n  end\\n  @hash[@n-1][@key]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 875137,
                "title": "c-dp-bitmasking-comments-with-explaination",
                "content": "```\\nclass Solution {\\n#define inf 1e6\\npublic:\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n\\t\\tint n = cost.size();\\n\\t\\tint m = cost[0].size();\\n\\t\\tint allDone = (1 << m) - 1;\\n\\t\\tint dp[n + 1][allDone + 2];\\n\\t\\tint score[allDone + 2];\\n\\t\\tint mi[m];\\n\\n\\t\\t// calculating the minimum incoming edge for each person in grp b\\n\\t\\t// This is handy in below loop\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tmi[i] = inf;\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t\\tmi[i] = min(mi[i], cost[j][i]);\\n\\t\\t}\\n\\n\\t\\t// precomputing the scores of each leftover people mask\\n\\t\\t// This would come handy in the base case (again below loop :\\\\)\\n\\t\\tfor (int i = 0; i <= allDone + 1; i++) {\\n\\t\\t\\tint &ans = score[i];\\n\\t\\t\\tans = 0;\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (i & (1 << j)) ans += mi[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// actual bottom up dp\\n\\t\\tfor (int i = n;  i >= 0; i--) {\\n\\t\\t\\tfor (int mask = 0; mask <= allDone; mask++) {\\n\\t\\t\\t\\tif (i == n) { \\n                    // all people that are left over needs to be matched with the min cost edges (we calculated this above)\\n\\t\\t\\t\\t\\tint left = allDone ^ mask;\\n\\t\\t\\t\\t\\tdp[i][mask] = score[left];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][mask] = inf;\\n\\t\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t\\t\\tdp[i][mask] = min(dp[i + 1][mask | (1 << j)] + cost[i][j], dp[i][mask]); \\n                    // matching the ith person in grp a to a person in grp b\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define inf 1e6\\npublic:\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n\\t\\tint n = cost.size();\\n\\t\\tint m = cost[0].size();\\n\\t\\tint allDone = (1 << m) - 1;\\n\\t\\tint dp[n + 1][allDone + 2];\\n\\t\\tint score[allDone + 2];\\n\\t\\tint mi[m];\\n\\n\\t\\t// calculating the minimum incoming edge for each person in grp b\\n\\t\\t// This is handy in below loop\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tmi[i] = inf;\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t\\tmi[i] = min(mi[i], cost[j][i]);\\n\\t\\t}\\n\\n\\t\\t// precomputing the scores of each leftover people mask\\n\\t\\t// This would come handy in the base case (again below loop :\\\\)\\n\\t\\tfor (int i = 0; i <= allDone + 1; i++) {\\n\\t\\t\\tint &ans = score[i];\\n\\t\\t\\tans = 0;\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (i & (1 << j)) ans += mi[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// actual bottom up dp\\n\\t\\tfor (int i = n;  i >= 0; i--) {\\n\\t\\t\\tfor (int mask = 0; mask <= allDone; mask++) {\\n\\t\\t\\t\\tif (i == n) { \\n                    // all people that are left over needs to be matched with the min cost edges (we calculated this above)\\n\\t\\t\\t\\t\\tint left = allDone ^ mask;\\n\\t\\t\\t\\t\\tdp[i][mask] = score[left];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][mask] = inf;\\n\\t\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t\\t\\tdp[i][mask] = min(dp[i + 1][mask | (1 << j)] + cost[i][j], dp[i][mask]); \\n                    // matching the ith person in grp a to a person in grp b\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870494,
                "title": "c-detailed-explaination-good-dp-with-bit-masking",
                "content": "We need to try judisiously all possible combinations in one dimension (preferabily in horizontal as n >= m) then in other direction we will find and add the minimum value to fulfil the consition.\\n\\nwe will fill one value per row, in a manner so as to cover all the combinations of columns that can be covered (mask on columns). this means for every mask on column we calculate using DP the minimum value of the sum of elements in each row. than in rows left (111111...-mask) we will find the minimum values and add them to it.\\n\\nour DP will be something like coin change one :\\n\\ndp[index][mask] \\n= min (dp[index+1][mask] + minimum value in index row for all columns where mask is 1,\\n    for every column place where mask is 1 -> dp[index+1][mask ^ 1] + cost [index][i])\\n\\nnow for every mask value of this dp with index 0 add the minimum column wise value to get the answer candidate, minimum such candidate is the answer.\\n\\n\\nint dp[20][20000];\\n    int topDown (int ind, int mask, vector<vector<int>>& cost, int m, int n) {\\n        if (dp[ind][mask] != -1) return dp[ind][mask];\\n        if (ind == n-1) {\\n            int sum = 0;\\n            for (int i = 0; i < m; i++) {\\n                if ((mask & (1 << i)) != 0) {\\n                    sum += cost[ind][m-i-1];\\n                }\\n            }\\n            dp[ind][mask] = sum;\\n            return sum;\\n        }        \\n        int mini = 100000;\\n        int minis = 100000;\\n        for (int i = 0; i < m; i++) {\\n           if ((mask & (1 << i)) != 0) {\\n               mini = min(mini, cost[ind][m-i-1]);\\n               int y = mask;\\n               y = y ^ (1 << i);\\n               minis = min (minis, cost[ind][m-i-1] + topDown(ind+1,y,cost,m,n));\\n           }\\n        }\\n        int t = mini + topDown(ind+1,mask,cost,m,n);\\n        dp[ind][mask] = min(t,minis);\\n        return dp[ind][mask];\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        int mini[m+1];\\n        for (int i = 0; i < m; i++) {\\n            mini[i] = INT_MAX;\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mini[i] = min(mini[i], cost[j][i]);\\n            }\\n        }\\n        int p = pow(2,m);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < p; j++) {\\n                if (j == 0) dp[i][j] = 100000;\\n                else\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int minis = INT_MAX;\\n        int sum = 0;\\n        for (int i = 1; i < p; i++) {\\n            sum = 0;\\n            for (int j = 0; j < m; j++) {\\n                if ((i & (1 << j)) == 0) {\\n                    sum += mini[m-j-1];\\n                }\\n            }\\n            int y = topDown(0,i,cost,m,n);\\n            minis = min(minis, sum + y);\\n        }\\n        return minis;\\n    }",
                "solutionTags": [],
                "code": "We need to try judisiously all possible combinations in one dimension (preferabily in horizontal as n >= m) then in other direction we will find and add the minimum value to fulfil the consition.\\n\\nwe will fill one value per row, in a manner so as to cover all the combinations of columns that can be covered (mask on columns). this means for every mask on column we calculate using DP the minimum value of the sum of elements in each row. than in rows left (111111...-mask) we will find the minimum values and add them to it.\\n\\nour DP will be something like coin change one :\\n\\ndp[index][mask] \\n= min (dp[index+1][mask] + minimum value in index row for all columns where mask is 1,\\n    for every column place where mask is 1 -> dp[index+1][mask ^ 1] + cost [index][i])\\n\\nnow for every mask value of this dp with index 0 add the minimum column wise value to get the answer candidate, minimum such candidate is the answer.\\n\\n\\nint dp[20][20000];\\n    int topDown (int ind, int mask, vector<vector<int>>& cost, int m, int n) {\\n        if (dp[ind][mask] != -1) return dp[ind][mask];\\n        if (ind == n-1) {\\n            int sum = 0;\\n            for (int i = 0; i < m; i++) {\\n                if ((mask & (1 << i)) != 0) {\\n                    sum += cost[ind][m-i-1];\\n                }\\n            }\\n            dp[ind][mask] = sum;\\n            return sum;\\n        }        \\n        int mini = 100000;\\n        int minis = 100000;\\n        for (int i = 0; i < m; i++) {\\n           if ((mask & (1 << i)) != 0) {\\n               mini = min(mini, cost[ind][m-i-1]);\\n               int y = mask;\\n               y = y ^ (1 << i);\\n               minis = min (minis, cost[ind][m-i-1] + topDown(ind+1,y,cost,m,n));\\n           }\\n        }\\n        int t = mini + topDown(ind+1,mask,cost,m,n);\\n        dp[ind][mask] = min(t,minis);\\n        return dp[ind][mask];\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        int mini[m+1];\\n        for (int i = 0; i < m; i++) {\\n            mini[i] = INT_MAX;\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mini[i] = min(mini[i], cost[j][i]);\\n            }\\n        }\\n        int p = pow(2,m);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < p; j++) {\\n                if (j == 0) dp[i][j] = 100000;\\n                else\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int minis = INT_MAX;\\n        int sum = 0;\\n        for (int i = 1; i < p; i++) {\\n            sum = 0;\\n            for (int j = 0; j < m; j++) {\\n                if ((i & (1 << j)) == 0) {\\n                    sum += mini[m-j-1];\\n                }\\n            }\\n            int y = topDown(0,i,cost,m,n);\\n            minis = min(minis, sum + y);\\n        }\\n        return minis;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 869024,
                "title": "c-dp-bitmasking-with-detailed-intuitive-explanation",
                "content": "First we need to understand the solution structure. \\nLet us say we have all nodes in first group connected and only a subset of nodes from the second group are connected. Then we can greedily assign each unconnected node from the second group with its minumum edge.\\n\\nLet dp[i][mask]  = minimum cost so that the first \\'i\\' nodes from the first group are connected and only 0 nodes (bit positions that are 0 in mask) from the second group are connected. \\nSince we want the first \\'i\\' in G1 to be connected , the ith node sould be connected to at least one node in G2. We can iterate over this node - let us call it j. There are two cases - \\n1) The jth node is already connected - dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i-1][mask])\\n2) The jth node is not connected - dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i-1][mask^(1<<j)] - here we set jth bit to 0 since we are connecing it to the ith node.\\n\\nThe tricky part (at least for me) here is that when we say for dp[i][mask] - the first i nodes are connected, we **do not** make the rest of the nodes from i+1...n **unavailable**. They may still be connected depending on whether some j in G2 has a minimum edge with one of them. It only means that the first i nodes are connected for sure, but the rest are still available.\\nThus the final answer is dp[n][0xfff..]\\n\\nFollowing is my code. Note that I use 0 indexing in the code.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int connectTwoGroups(vector<vector<int>>& c) {\\n        int n = c.size(), m = c[0].size();\\n        vector<int> dp(4101,0), minc(m,INT_MAX);\\n        for (int j = 0; j < m; ++j){\\n            for (int i = 0; i < n; ++i){\\n                minc[j] = min(minc[j], c[i][j]);\\n            }\\n        }\\n        for (int mask = 0; mask < (1<<m); ++mask){\\n            for (int j = 0; j < m; ++j){\\n                if ((mask>>j)&1){\\n                    dp[mask] += minc[j];\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; ++i){\\n            vector<int> dp_nxt(4101,INT_MAX);\\n            for (int mask = 0; mask < (1<<m); ++mask){\\n                for (int j = 0; j < m; ++j){\\n                    if ((mask>>j)&1){\\n                        dp_nxt[mask] = min(dp_nxt[mask], c[i][j] + dp[mask^(1<<j)]);\\n                    }\\n                    else{\\n                        dp_nxt[mask] = min(dp_nxt[mask], c[i][j] + dp[mask]);\\n                    }\\n                }\\n            }\\n            dp = dp_nxt;\\n        }\\n        return dp[(1<<m)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int connectTwoGroups(vector<vector<int>>& c) {\\n        int n = c.size(), m = c[0].size();\\n        vector<int> dp(4101,0), minc(m,INT_MAX);\\n        for (int j = 0; j < m; ++j){\\n            for (int i = 0; i < n; ++i){\\n                minc[j] = min(minc[j], c[i][j]);\\n            }\\n        }\\n        for (int mask = 0; mask < (1<<m); ++mask){\\n            for (int j = 0; j < m; ++j){\\n                if ((mask>>j)&1){\\n                    dp[mask] += minc[j];\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; ++i){\\n            vector<int> dp_nxt(4101,INT_MAX);\\n            for (int mask = 0; mask < (1<<m); ++mask){\\n                for (int j = 0; j < m; ++j){\\n                    if ((mask>>j)&1){\\n                        dp_nxt[mask] = min(dp_nxt[mask], c[i][j] + dp[mask^(1<<j)]);\\n                    }\\n                    else{\\n                        dp_nxt[mask] = min(dp_nxt[mask], c[i][j] + dp[mask]);\\n                    }\\n                }\\n            }\\n            dp = dp_nxt;\\n        }\\n        return dp[(1<<m)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863826,
                "title": "c-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>>dp;\\n    vector<int>price;\\n    int solve(int idx, int x, vector<vector<int>>& cost)\\n    {\\n        if(dp[idx][x] != -1)return dp[idx][x];\\n        int ans;\\n        if(idx == m)\\n        {\\n            ans = 0;\\n            for(int i = 0; i < n; i++)\\n                if((x & (1 << i)) == 0)\\n                    ans += price[i];\\n        }\\n        else\\n        {\\n            ans = INT_MAX;\\n            for(int i = 0; i < n; i++)\\n            {\\n                ans = min(ans, solve(idx + 1, (x | (1 << i)), cost) + cost[idx][i]);\\n            }\\n        }\\n        return dp[idx][x] = ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size();\\n        n = cost[0].size();\\n        dp.resize(m + 1, vector<int>((1 << n), -1));\\n        price.resize(n, INT_MAX);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                price[i] = min(price[i], cost[j][i]);\\n        return solve(0, 0, cost);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>>dp;\\n    vector<int>price;\\n    int solve(int idx, int x, vector<vector<int>>& cost)\\n    {\\n        if(dp[idx][x] != -1)return dp[idx][x];\\n        int ans;\\n        if(idx == m)\\n        {\\n            ans = 0;\\n            for(int i = 0; i < n; i++)\\n                if((x & (1 << i)) == 0)\\n                    ans += price[i];\\n        }\\n        else\\n        {\\n            ans = INT_MAX;\\n            for(int i = 0; i < n; i++)\\n            {\\n                ans = min(ans, solve(idx + 1, (x | (1 << i)), cost) + cost[idx][i]);\\n            }\\n        }\\n        return dp[idx][x] = ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size();\\n        n = cost[0].size();\\n        dp.resize(m + 1, vector<int>((1 << n), -1));\\n        price.resize(n, INT_MAX);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                price[i] = min(price[i], cost[j][i]);\\n        return solve(0, 0, cost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863803,
                "title": "why-heap-based-solution-dijkstra-bitmasks-gives-tle",
                "content": "This is a basic set-cover problem. I can\\'t figure out why heap-based solution gives TLE?\\nWe treat this problem as graph problem, where we need to find the minimal path from state, where all bits set to one, to state, where all bits are set to zero.\\n\\n```\\nstruct state\\n{\\n\\tint left = 0;\\n\\tint right = 0;\\n\\tint cost = 0;\\n\\n\\tbool operator>(state s) const\\n\\t{\\n\\t\\treturn cost > s.cost;\\n\\t}\\n};\\n\\nint connectTwoGroups(vector<vector<int>>& cost) \\n{\\n\\tstate s;\\n\\n\\tfor (int i = 0; i < cost.size(); ++i)\\n\\t\\tfor (int j = 0; j < cost[i].size(); ++j)\\n\\t\\t\\ts.left |= 1 << i, s.right |= 1 << j;\\n\\n\\tpriority_queue<state, vector<state>, greater<state>> pq;\\n\\tpq.push(s);\\n\\n\\twhile (!pq.empty())\\n\\t{\\n\\t\\tauto cur = pq.top();\\n\\t\\tpq.pop();\\n\\n\\t\\tif (!cur.left && !cur.right)\\n\\t\\t\\treturn cur.cost;\\n\\n\\t\\tfor (int i = 0; i < cost.size(); ++i)\\n\\t\\t\\tfor (int j = 0; j < cost[i].size(); ++j)\\n\\t\\t\\t\\tif (cur.left & 1 << i || cur.right & 1 << j)\\n\\t\\t\\t\\t\\tpq.push({ cur.left & ~(1 << i), cur.right & ~(1 << j), cur.cost + cost[i][j] });\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct state\\n{\\n\\tint left = 0;\\n\\tint right = 0;\\n\\tint cost = 0;\\n\\n\\tbool operator>(state s) const\\n\\t{\\n\\t\\treturn cost > s.cost;\\n\\t}\\n};\\n\\nint connectTwoGroups(vector<vector<int>>& cost) \\n{\\n\\tstate s;\\n\\n\\tfor (int i = 0; i < cost.size(); ++i)\\n\\t\\tfor (int j = 0; j < cost[i].size(); ++j)\\n\\t\\t\\ts.left |= 1 << i, s.right |= 1 << j;\\n\\n\\tpriority_queue<state, vector<state>, greater<state>> pq;\\n\\tpq.push(s);\\n\\n\\twhile (!pq.empty())\\n\\t{\\n\\t\\tauto cur = pq.top();\\n\\t\\tpq.pop();\\n\\n\\t\\tif (!cur.left && !cur.right)\\n\\t\\t\\treturn cur.cost;\\n\\n\\t\\tfor (int i = 0; i < cost.size(); ++i)\\n\\t\\t\\tfor (int j = 0; j < cost[i].size(); ++j)\\n\\t\\t\\t\\tif (cur.left & 1 << i || cur.right & 1 << j)\\n\\t\\t\\t\\t\\tpq.push({ cur.left & ~(1 << i), cur.right & ~(1 << j), cur.cost + cost[i][j] });\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 860909,
                "title": "java-easy-bitmask-solution-very-fast",
                "content": "```\\nclass Solution {\\n    \\n    static long maxx(int ind,List<List<Integer>> cost,int val,int flag){\\n        if(ind>=cost.size()){\\n            for(int i=0;i<cost.get(0).size();i++){\\n                int j=(1<<i) & val;\\n                if(j==0){return Integer.MAX_VALUE;}\\n            }\\n            return 0;}\\n        if(aa[ind][val][flag]!=-1){return aa[ind][val][flag];}\\n        long min=Integer.MAX_VALUE;\\n        if(flag==0){\\n        for(int j=0;j<cost.get(ind).size();j++){\\n           \\n                min=Math.min(min,maxx(ind,cost,(1<<j)|val,1)+cost.get(ind).get(j));\\n          \\n        }\\n        }\\n        else{\\n            for(int j=0;j<cost.get(ind).size();j++){\\n            int i=(1<<j) & val;\\n            if(i==0){\\n                min=Math.min(min,maxx(ind,cost,(1<<j)|val,1)+cost.get(ind).get(j));\\n            }\\n            }\\n            min=Math.min(min,maxx(ind+1,cost,val,0 ));\\n        }\\n        return aa[ind][val][flag]=min;\\n    }\\n    static long[][][] aa;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        aa=new long[cost.size()][(int)Math.pow(2,cost.get(0).size())+1][2];\\n        for(int j=0;j<aa.length;j++){\\n            for(int i=0;i<aa[0].length;i++){\\n                for(int k=0;k<2;k++){\\n                aa[j][i][k]=-1;\\n                }\\n            }\\n        }\\n        return (int)maxx(0,cost,0,0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static long maxx(int ind,List<List<Integer>> cost,int val,int flag){\\n        if(ind>=cost.size()){\\n            for(int i=0;i<cost.get(0).size();i++){\\n                int j=(1<<i) & val;\\n                if(j==0){return Integer.MAX_VALUE;}\\n            }\\n            return 0;}\\n        if(aa[ind][val][flag]!=-1){return aa[ind][val][flag];}\\n        long min=Integer.MAX_VALUE;\\n        if(flag==0){\\n        for(int j=0;j<cost.get(ind).size();j++){\\n           \\n                min=Math.min(min,maxx(ind,cost,(1<<j)|val,1)+cost.get(ind).get(j));\\n          \\n        }\\n        }\\n        else{\\n            for(int j=0;j<cost.get(ind).size();j++){\\n            int i=(1<<j) & val;\\n            if(i==0){\\n                min=Math.min(min,maxx(ind,cost,(1<<j)|val,1)+cost.get(ind).get(j));\\n            }\\n            }\\n            min=Math.min(min,maxx(ind+1,cost,val,0 ));\\n        }\\n        return aa[ind][val][flag]=min;\\n    }\\n    static long[][][] aa;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        aa=new long[cost.size()][(int)Math.pow(2,cost.get(0).size())+1][2];\\n        for(int j=0;j<aa.length;j++){\\n            for(int i=0;i<aa[0].length;i++){\\n                for(int k=0;k<2;k++){\\n                aa[j][i][k]=-1;\\n                }\\n            }\\n        }\\n        return (int)maxx(0,cost,0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860083,
                "title": "can-anyone-point-out-my-mistake-i-am-getting-different-value-than-expected-in-some-test-cases",
                "content": "Here is my code:-\\n\\n\\n```\\nclass Solution \\n{\\n    int g1size,g2size;\\n    int dp[13][4096] = {};\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        int i,j;\\n        g1size=cost.size();\\n        g2size=cost[0].size();\\n        \\n            \\n        \\n        vector<int>g2mini(g2size,INT_MAX);\\n        for(i=0;i<g2size;i++)\\n        {\\n            for(j=0;j<g1size;j++)\\n            {\\n                g2mini[i]=min(g2mini[i],cost[j][i]);\\n            }\\n        }\\n        return helper(cost,g2mini,0,0);\\n    }\\npublic: int helper(vector<vector<int>>&cost,vector<int>&g2mini,int gindex,int group2)\\n{\\n    \\n    if(dp[gindex][group2]!=NULL) return dp[gindex][group2];\\n    int i,j;\\n    int sumcost=(gindex>=g1size)?0:INT_MAX;\\n    if(gindex>=g1size)\\n    {\\n        \\n        for(i=0;i<g2size;++i)\\n        {\\n            sumcost+=g2mini[i]*((group2 && (1<<i))==0);\\n        }\\n    }\\n    else\\n    {\\n        \\n        for(i=0;i<g2size;i++)\\n        {\\n            sumcost=min(sumcost,cost[gindex][i]+helper(cost,g2mini,gindex+1,group2|(1<<i)));\\n            \\n        }\\n    }\\n    dp[gindex][group2]=sumcost;\\n    return sumcost;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    int g1size,g2size;\\n    int dp[13][4096] = {};\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        int i,j;\\n        g1size=cost.size();\\n        g2size=cost[0].size();\\n        \\n            \\n        \\n        vector<int>g2mini(g2size,INT_MAX);\\n        for(i=0;i<g2size;i++)\\n        {\\n            for(j=0;j<g1size;j++)\\n            {\\n                g2mini[i]=min(g2mini[i],cost[j][i]);\\n            }\\n        }\\n        return helper(cost,g2mini,0,0);\\n    }\\npublic: int helper(vector<vector<int>>&cost,vector<int>&g2mini,int gindex,int group2)\\n{\\n    \\n    if(dp[gindex][group2]!=NULL) return dp[gindex][group2];\\n    int i,j;\\n    int sumcost=(gindex>=g1size)?0:INT_MAX;\\n    if(gindex>=g1size)\\n    {\\n        \\n        for(i=0;i<g2size;++i)\\n        {\\n            sumcost+=g2mini[i]*((group2 && (1<<i))==0);\\n        }\\n    }\\n    else\\n    {\\n        \\n        for(i=0;i<g2size;i++)\\n        {\\n            sumcost=min(sumcost,cost[gindex][i]+helper(cost,g2mini,gindex+1,group2|(1<<i)));\\n            \\n        }\\n    }\\n    dp[gindex][group2]=sumcost;\\n    return sumcost;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858162,
                "title": "c-dp-with-bit-masking-with-comments",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size(), n = cost[0].size();\\n        dp.resize(m + 1, vector<int>(1<<n, -1));       // dp of [index of i\\'th element set1][n bits for set2]\\n        minCol.resize(n, INT_MAX);\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++)\\n            minCol[j] = min(minCol[j], cost[i][j]);       // min for each column\\n        \\n        return solve(0, 0, cost);       // no element is yet connected\\n    }\\n    \\n\\n// considering each element of set1 one by one, and at the end(idx == m) if some of the elements of set2 are still\\n// not connected, we connect them using the min weight edge from them\\n    \\n    int solve(int idx, int mask2, vector<vector<int>>& cost) {\\n        if(dp[idx][mask2] != -1) return dp[idx][mask2];\\n        \\n        int ans = (idx == m ? 0: INT_MAX);\\n        \\n        if(idx == m) {          // set1 elements already connected, we will only check set 2 elements (columns)\\n            for(int j=0; j<n; j++) if((mask2&(1<<j)) == 0)      // not yet selected\\n                ans += minCol[j];      // choose the min edge to connect this\\n        }\\n        else {\\n            for(int j=0; j<n; j++)\\n                ans = min(ans, cost[idx][j] + solve(idx + 1, mask2|(1<<j), cost));  // connecting i\\'th with j\\'th\\n        }\\n        \\n        return dp[idx][mask2] = ans;\\n    }\\n\\nprivate:\\n    int m, n, done1, done2;\\n    vector<vector<int>> dp;            // [12] * [4096] max\\n    vector<int> minCol;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size(), n = cost[0].size();\\n        dp.resize(m + 1, vector<int>(1<<n, -1));       // dp of [index of i\\'th element set1][n bits for set2]\\n        minCol.resize(n, INT_MAX);\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++)\\n            minCol[j] = min(minCol[j], cost[i][j]);       // min for each column\\n        \\n        return solve(0, 0, cost);       // no element is yet connected\\n    }\\n    \\n\\n// considering each element of set1 one by one, and at the end(idx == m) if some of the elements of set2 are still\\n// not connected, we connect them using the min weight edge from them\\n    \\n    int solve(int idx, int mask2, vector<vector<int>>& cost) {\\n        if(dp[idx][mask2] != -1) return dp[idx][mask2];\\n        \\n        int ans = (idx == m ? 0: INT_MAX);\\n        \\n        if(idx == m) {          // set1 elements already connected, we will only check set 2 elements (columns)\\n            for(int j=0; j<n; j++) if((mask2&(1<<j)) == 0)      // not yet selected\\n                ans += minCol[j];      // choose the min edge to connect this\\n        }\\n        else {\\n            for(int j=0; j<n; j++)\\n                ans = min(ans, cost[idx][j] + solve(idx + 1, mask2|(1<<j), cost));  // connecting i\\'th with j\\'th\\n        }\\n        \\n        return dp[idx][mask2] = ans;\\n    }\\n\\nprivate:\\n    int m, n, done1, done2;\\n    vector<vector<int>> dp;            // [12] * [4096] max\\n    vector<int> minCol;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858092,
                "title": "python3-full-explanation-plus-how-to-use-a-bitmask",
                "content": "\\n# Explanation\\nFor those wondering, this is a greedy solution problem.\\n\\nAll connections are found by connecting one side to the other, say the left. Then connecting the remaining unconnected nodes (if any) on the right.\\n\\nHow do we know which side to connect first? The side that goes second is deterministic, like in a 2-player game. It will always attach to the minimum cost. This is why it\\'s a greedy problem. The side that goes first, we need to loop over all possible ways to connect. Each node on the 1st side can connect to any on the 2nd, so there will be 2nd^1st number of ways to do this. We should thus connect the larger side first.\\n\\nNote: to prove this, we need to determine if x > y, is x^y > y^x? for equality, x=y has to be true. So, test out the case of x=3 and y=2. we find (2^3=8) < (3^2=9), thus if x>y we should always pick x^y. Exponents are powerful\\n\\n## algorithm steps\\nFirst, we need the info for the deterministic connections. Find the min cost for each element on the right side (the right side is always smaller). \\n\\nTo loop over all ways to connect the left to the right, we use a bit mask and DP. For the inductive step, assume that all m+1 left nodes have been connected to the right. This is backwards compared to usual. The reason being, we know exactly how the right side connects if the left is fully connected. Therefore left==m is our base case.\\n\\nWe can keep track of which nodes on the right have a connection using a 1 for connected and 0 for not connected. This is represented as a bit string 101110....01 etc. This is the bitmask. To connect the mth node, we create n bitmasks, each with a 1 inserted (if there\\'s already a 1 do nothing) at the ith entry of the bitmask. This is the bitwise & operation with each bit. Each index is like a basis vector, and index i can be represented as 1<<i. Finally, the cost of the ith bitmask is equal to the cost to connect our left node to i, plus the cost of connecting all the right nodes given that bitmask.\\n\\n## bitmasks and lru_cache fun\\nFinal note. The bitmasks work like this: 1<<n yields a unit vector. 3D example - 1<<0 = 001. 1<<1 = 010. and 1<<2 = 100. << moves the leading bit (1) leftwards by (...) digits. The & operator checks if the bitmask has a 1 where the unit vector has a 1. If not, it gives 0, meaning no connection. The | operator says if either the bitmask or our new unit vector has a 1, then the final result has a 1 in that location. Hence it adds a connection.\\n\\nFinal final note: The lru_cache() decorator is seriously amazing. It basically implements top-down DP automatically. Just put in a recursive function and it will keep track of duplicates in the cache, then readily supply the answer. For fun, try typing in lru_cache.cache_info() after you run the code. It tells you how often the lru_cache found a previous answer, and you can get an idea how efficient it is!\\n\\n## Code\\n\\n```\\ndef min_cost(cost):\\n\\t#The zip function just makes every column into an array. Numpy equivalent is cost[:,i].\\n\\tm, n = len(cost), len(cost[0])\\n\\tright_cost = [min(x) for x in zip(*cost)]\\n\\n\\t# The recursive call tells us what the additional cost is, provided we already connected num_left_connected on the left and num_right_connected on the right.\\n\\t@lru_cache(maxsize=None)\\n\\tdef aux(num_left_connected, num_right_connected):\\n\\t\\ti, bitmask = num_left_connected, num_right_connected\\n\\t\\tif i == m:\\n\\t\\t\\treturn sum(right_cost[x] for x in range(n) if bitmask & 1<<x == 0)\\n\\t\\treturn min(cost[i][j] + aux(i+1, bitmask | 1<<j) for j in range(n))\\n\\n\\t# return the cost for 0 initial left connections and 0 intial right connections\\n\\treturn aux(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef min_cost(cost):\\n\\t#The zip function just makes every column into an array. Numpy equivalent is cost[:,i].\\n\\tm, n = len(cost), len(cost[0])\\n\\tright_cost = [min(x) for x in zip(*cost)]\\n\\n\\t# The recursive call tells us what the additional cost is, provided we already connected num_left_connected on the left and num_right_connected on the right.\\n\\t@lru_cache(maxsize=None)\\n\\tdef aux(num_left_connected, num_right_connected):\\n\\t\\ti, bitmask = num_left_connected, num_right_connected\\n\\t\\tif i == m:\\n\\t\\t\\treturn sum(right_cost[x] for x in range(n) if bitmask & 1<<x == 0)\\n\\t\\treturn min(cost[i][j] + aux(i+1, bitmask | 1<<j) for j in range(n))\\n\\n\\t# return the cost for 0 initial left connections and 0 intial right connections\\n\\treturn aux(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 857422,
                "title": "c-top-down-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m;\\n    vector<vector<int> > c;\\n    vector<int> mi;\\n    vector<vector<int> > dp;\\n    \\n    int util(int i, int mask){\\n        if(i>=n){\\n            int res=0;\\n            for(int j=0; j<m; j++)\\n                if(!(mask&(1<<j))) res+=mi[j];\\n            return res;\\n        }\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n        int ans=2000000000;\\n        for(int j=0; j<m; j++) ans=min(ans, c[i][j]+util(i+1, mask|(1<<j)));\\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        c=cost, n=c.size(), m=c[0].size();\\n        dp=vector<vector<int> >(n, vector<int>(1<<m, -1));\\n        mi=vector<int>(m);\\n        for(int j=0; j<m; j++){\\n            mi[j]=c[0][j];\\n            for(int i=1; i<n; i++) mi[j]=min(mi[j], c[i][j]);\\n        }\\n        return util(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m;\\n    vector<vector<int> > c;\\n    vector<int> mi;\\n    vector<vector<int> > dp;\\n    \\n    int util(int i, int mask){\\n        if(i>=n){\\n            int res=0;\\n            for(int j=0; j<m; j++)\\n                if(!(mask&(1<<j))) res+=mi[j];\\n            return res;\\n        }\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n        int ans=2000000000;\\n        for(int j=0; j<m; j++) ans=min(ans, c[i][j]+util(i+1, mask|(1<<j)));\\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        c=cost, n=c.size(), m=c[0].size();\\n        dp=vector<vector<int> >(n, vector<int>(1<<m, -1));\\n        mi=vector<int>(m);\\n        for(int j=0; j<m; j++){\\n            mi[j]=c[0][j];\\n            for(int i=1; i<n; i++) mi[j]=min(mi[j], c[i][j]);\\n        }\\n        return util(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857053,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\n    const int INF = 1234567890;\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        const int m = cost.size(), n = cost[0].size();\\n        vector<int> best(n, INF);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                best[i] = min(best[i], cost[j][i]);\\n            }\\n        }\\n        vector<int> dp(1 << n, INF);\\n        dp[0] = 0;\\n        for (const auto& c : cost) {\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                const int temp = dp[i];\\n                dp[i] = INF;\\n                if (temp >= INF) {\\n                    continue;\\n                }\\n                for (int j = 0; j < n; ++j) {\\n                    const int s = i | (1 << j);\\n                    dp[s] = min(dp[s], temp + c[j]);\\n                }\\n                \\n            }\\n        }\\n        int r = INF;\\n        for (int i = 0; i < dp.size(); ++i) {\\n            if (dp[i] == INF) {\\n                continue;\\n            }\\n            int c = dp[i];\\n            for (int j = 0; c < r && j < n; ++j) {\\n                if ((i & (1 << j)) == 0) {\\n                    c += best[j];\\n                }\\n               \\n            }\\n            r = min(r, c);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int INF = 1234567890;\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        const int m = cost.size(), n = cost[0].size();\\n        vector<int> best(n, INF);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                best[i] = min(best[i], cost[j][i]);\\n            }\\n        }\\n        vector<int> dp(1 << n, INF);\\n        dp[0] = 0;\\n        for (const auto& c : cost) {\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                const int temp = dp[i];\\n                dp[i] = INF;\\n                if (temp >= INF) {\\n                    continue;\\n                }\\n                for (int j = 0; j < n; ++j) {\\n                    const int s = i | (1 << j);\\n                    dp[s] = min(dp[s], temp + c[j]);\\n                }\\n                \\n            }\\n        }\\n        int r = INF;\\n        for (int i = 0; i < dp.size(); ++i) {\\n            if (dp[i] == INF) {\\n                continue;\\n            }\\n            int c = dp[i];\\n            for (int j = 0; c < r && j < n; ++j) {\\n                if ((i & (1 << j)) == 0) {\\n                    c += best[j];\\n                }\\n               \\n            }\\n            r = min(r, c);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856771,
                "title": "dfs-solution-java-100ms-python-not-very-simple",
                "content": "```\\nclass Solution(object):\\n    def connectTwoGroups(self, cost):\\n        \"\"\"\\n        :type cost: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.cost = cost if len(cost) >= len(cost[0]) else [[cost[j][i] for j in range(len(cost))] for i in range(len(cost[0]))]\\n        self.select = [[False for j in range(len(self.cost[0]))] for i in range(len(self.cost))]\\n        # fast pruning\\n        self.select_cost = float(\\'inf\\')\\n        self.select_cols = [False for i in range(len(self.cost[0]))]\\n        self.partition(0, 0)\\n        for i in range(len(self.cost[0]), len(self.cost)):\\n            self.select_cost += min(self.cost[i])\\n        # dfs\\n        self.align_row = [min(self.cost[i]) for i in range(len(self.cost))]\\n        for i in range(len(self.cost) - 2, -1, -1):\\n            self.align_row[i] += self.align_row[i + 1]\\n        self.cols_rowfull = [False for i in range(len(self.cost[0]))]\\n        self.cols_counts = [0 for i in range(len(self.cost[0]))]\\n        self.backtracking(0, 0)\\n        return self.select_cost\\n    def backtracking(self, row, cost):\\n        if row == len(self.cost):\\n            # check columns\\n            for j in range(len(self.cost[0])):\\n                count = 0\\n                for i in range(len(self.cost)):\\n                    if self.select[i][j]:\\n                        count += 1\\n                if count == 0:\\n                    return\\n            self.select_cost = cost\\n            return\\n        self.choice(row, 0, 0, cost)\\n    # choices\\n    def choice(self, row, j, before, cost):\\n        if row < len(self.cost) - 1 and cost + self.align_row[row + 1] >= self.select_cost:\\n            return\\n        if cost >= self.select_cost:\\n            return\\n        if j == len(self.cost[0]):\\n            if before == 1:\\n                self.backtracking(row + 1, cost)\\n            elif before > 1:\\n                temp = self.cols_rowfull[:]\\n                for k in range(len(self.cost[0])):\\n                    if self.select[row][k]:\\n                        self.cols_rowfull[k] = True\\n                self.backtracking(row + 1, cost)\\n                self.cols_rowfull = temp\\n            return\\n        self.choice(row, j + 1, before, cost)\\n        if not self.cols_rowfull[j]:\\n            self.select[row][j] = True\\n            # check cols_counts\\n            if self.cols_counts[j] == 0 or before == 0:\\n                self.cols_counts[j] += 1\\n                self.choice(row, j + 1, before + 1, cost + self.cost[row][j])\\n                self.cols_counts[j] -= 1\\n            self.select[row][j] = False\\n    def partition(self, row, cost):\\n        if cost >= self.select_cost:\\n            return\\n        if row == len(self.cost[0]):\\n            self.select_cost = cost\\n            return\\n        for j in range(len(self.cost[0])):\\n            if not self.select_cols[j]:\\n                self.select[row][j] = True\\n                self.select_cols[j] = True\\n                self.partition(row + 1, cost + self.cost[row][j])\\n                self.select_cols[j] = False\\n                self.select[row][j] = False\\n```\\n\\t\\t\\t\\t\\nThe problem can be translated into:\\nFind a selection set of elements that:\\n(i) each row must have at least one selected\\n(ii) each column must have at least one selected\\n(iii) if a row has more than two selected, then in each coloumn of the selected element, there are no more selection.\\n(iv) if a column has more than two selected, then in each row of the selected element, there are no more selection.\\n\\nNote that (iii) and (iv) are used for improving pruning.\\nThe dfs solution dives per row, and the choices are the coloumns.\\nTherefore we need global variables \"cols_rowfull\" and \"cols_counts\" to detect whether a specific row or column contains more than one elements selected already.\\n\\nTo improve pruning even better, the initial value of \"select_cost\" is important to be efficiently small enough.\\nThe function partition() uses dfs to find the minimal \"select_cost\" that satisfies the following:\\nFirst transpose the marix if necessary, to make the length <= the height. Then find a selection set in [length * length] that:\\n(i) each row has exactly one selected\\n(ii) each column has exactly one selected\\nThen add \"selected_cost\" with the minimum value of each row left.\\nThe value of \"selected_cost\" thus is minimized the most.\\n\\nIn the main backtracking function, the ending condition is that: check if the current cost **plus the sum of minimum value of each row left** is no less than select_cost.\\n\\nHere is the Java translation: (It is dumb)\\n```\\nclass Solution {\\n    int[][] cost;\\n    boolean[][] select;\\n    int select_cost;\\n    boolean[] select_cols;\\n    int[] align_row;\\n    boolean[] cols_rowfull;\\n    int[] cols_counts;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        if (cost.size() >= cost.get(0).size()) {\\n            this.cost = new int[cost.size()][cost.get(0).size()];\\n            for (int i = 0; i < cost.size(); i++)\\n                for (int j = 0; j < cost.get(0).size(); j++)\\n                    this.cost[i][j] = cost.get(i).get(j);\\n        }\\n        else {\\n            this.cost = new int[cost.get(0).size()][cost.size()];\\n            for (int i = 0; i < cost.size(); i++)\\n                for (int j = 0; j < cost.get(0).size(); j++)\\n                    this.cost[j][i] = cost.get(i).get(j);\\n        }\\n        this.select = new boolean[this.cost.length][this.cost[0].length];\\n        this.select_cost = Integer.MAX_VALUE;\\n        // fast pruning\\n        this.select_cols = new boolean[this.cost[0].length];\\n        partition(0, 0);\\n        this.align_row = new int[this.cost.length];\\n        for (int i = 0; i < this.cost.length; i++) {\\n            int min = this.cost[i][0];\\n            for (int next : this.cost[i])\\n                if (next < min) min = next;\\n            this.align_row[i] = min;\\n        }\\n        for (int i = this.cost[0].length; i < this.cost.length; i++)\\n            this.select_cost += this.align_row[i];\\n        for (int i = this.cost.length - 2; i >= 0; i--)\\n            this.align_row[i] += this.align_row[i + 1];\\n        // dfs\\n        this.cols_rowfull = new boolean[this.cost[0].length];\\n        this.cols_counts = new int[this.cost[0].length];\\n        backtracking(0, 0);\\n        return this.select_cost;\\n    }\\n    private void backtracking(int row, int cost) {\\n        if (row == this.cost.length) {\\n            // check columns\\n            for (int j = 0; j < this.cost[0].length; j++) {\\n                int count = 0;\\n                for (int i = 0; i < this.cost.length; i++)\\n                    if (this.select[i][j]) count++;\\n                if (count == 0) return;\\n            }\\n            this.select_cost = cost;\\n            return;\\n        }\\n        choice(row, 0, 0, cost);\\n    }\\n    private void choice(int row, int j, int before, int cost) {\\n        if (row < this.cost.length - 1 && cost + this.align_row[row + 1] >= this.select_cost) return;\\n        if (cost >= this.select_cost) return;\\n        if (j == this.cost[0].length) {\\n            if (before == 1) backtracking(row + 1, cost);\\n            else if (before > 1) {\\n                boolean[] temp = this.cols_rowfull.clone();\\n                for (int k = 0; k < this.cost[0].length; k++)\\n                    if (this.select[row][k]) this.cols_rowfull[k] = true;\\n                backtracking(row + 1, cost);\\n                this.cols_rowfull = temp;\\n            }\\n            return;\\n        }\\n        choice(row, j + 1, before, cost);\\n        if (!this.cols_rowfull[j]) {\\n            this.select[row][j] = true;\\n            if (this.cols_counts[j] == 0 || before == 0) {\\n                this.cols_counts[j] += 1;\\n                choice(row, j + 1, before + 1, cost + this.cost[row][j]);\\n                this.cols_counts[j] -= 1;\\n            }\\n            this.select[row][j] = false;\\n        }\\n    }\\n    \\n    private void partition(int row, int cost) {\\n        if (cost >= this.select_cost) return;\\n        if (row == this.cost[0].length) {\\n            this.select_cost = cost;\\n            return;\\n        }\\n        for (int j = 0; j < this.cost[0].length; j++)\\n            if (!this.select_cols[j]) {\\n                this.select[row][j] = true;\\n                this.select_cols[j] = true;\\n                partition(row + 1, cost + this.cost[row][j]);\\n                this.select_cols[j] = false;\\n                this.select[row][j] = false;\\n            }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def connectTwoGroups(self, cost):\\n        \"\"\"\\n        :type cost: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.cost = cost if len(cost) >= len(cost[0]) else [[cost[j][i] for j in range(len(cost))] for i in range(len(cost[0]))]\\n        self.select = [[False for j in range(len(self.cost[0]))] for i in range(len(self.cost))]\\n        # fast pruning\\n        self.select_cost = float(\\'inf\\')\\n        self.select_cols = [False for i in range(len(self.cost[0]))]\\n        self.partition(0, 0)\\n        for i in range(len(self.cost[0]), len(self.cost)):\\n            self.select_cost += min(self.cost[i])\\n        # dfs\\n        self.align_row = [min(self.cost[i]) for i in range(len(self.cost))]\\n        for i in range(len(self.cost) - 2, -1, -1):\\n            self.align_row[i] += self.align_row[i + 1]\\n        self.cols_rowfull = [False for i in range(len(self.cost[0]))]\\n        self.cols_counts = [0 for i in range(len(self.cost[0]))]\\n        self.backtracking(0, 0)\\n        return self.select_cost\\n    def backtracking(self, row, cost):\\n        if row == len(self.cost):\\n            # check columns\\n            for j in range(len(self.cost[0])):\\n                count = 0\\n                for i in range(len(self.cost)):\\n                    if self.select[i][j]:\\n                        count += 1\\n                if count == 0:\\n                    return\\n            self.select_cost = cost\\n            return\\n        self.choice(row, 0, 0, cost)\\n    # choices\\n    def choice(self, row, j, before, cost):\\n        if row < len(self.cost) - 1 and cost + self.align_row[row + 1] >= self.select_cost:\\n            return\\n        if cost >= self.select_cost:\\n            return\\n        if j == len(self.cost[0]):\\n            if before == 1:\\n                self.backtracking(row + 1, cost)\\n            elif before > 1:\\n                temp = self.cols_rowfull[:]\\n                for k in range(len(self.cost[0])):\\n                    if self.select[row][k]:\\n                        self.cols_rowfull[k] = True\\n                self.backtracking(row + 1, cost)\\n                self.cols_rowfull = temp\\n            return\\n        self.choice(row, j + 1, before, cost)\\n        if not self.cols_rowfull[j]:\\n            self.select[row][j] = True\\n            # check cols_counts\\n            if self.cols_counts[j] == 0 or before == 0:\\n                self.cols_counts[j] += 1\\n                self.choice(row, j + 1, before + 1, cost + self.cost[row][j])\\n                self.cols_counts[j] -= 1\\n            self.select[row][j] = False\\n    def partition(self, row, cost):\\n        if cost >= self.select_cost:\\n            return\\n        if row == len(self.cost[0]):\\n            self.select_cost = cost\\n            return\\n        for j in range(len(self.cost[0])):\\n            if not self.select_cols[j]:\\n                self.select[row][j] = True\\n                self.select_cols[j] = True\\n                self.partition(row + 1, cost + self.cost[row][j])\\n                self.select_cols[j] = False\\n                self.select[row][j] = False\\n```\n```\\nclass Solution {\\n    int[][] cost;\\n    boolean[][] select;\\n    int select_cost;\\n    boolean[] select_cols;\\n    int[] align_row;\\n    boolean[] cols_rowfull;\\n    int[] cols_counts;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        if (cost.size() >= cost.get(0).size()) {\\n            this.cost = new int[cost.size()][cost.get(0).size()];\\n            for (int i = 0; i < cost.size(); i++)\\n                for (int j = 0; j < cost.get(0).size(); j++)\\n                    this.cost[i][j] = cost.get(i).get(j);\\n        }\\n        else {\\n            this.cost = new int[cost.get(0).size()][cost.size()];\\n            for (int i = 0; i < cost.size(); i++)\\n                for (int j = 0; j < cost.get(0).size(); j++)\\n                    this.cost[j][i] = cost.get(i).get(j);\\n        }\\n        this.select = new boolean[this.cost.length][this.cost[0].length];\\n        this.select_cost = Integer.MAX_VALUE;\\n        // fast pruning\\n        this.select_cols = new boolean[this.cost[0].length];\\n        partition(0, 0);\\n        this.align_row = new int[this.cost.length];\\n        for (int i = 0; i < this.cost.length; i++) {\\n            int min = this.cost[i][0];\\n            for (int next : this.cost[i])\\n                if (next < min) min = next;\\n            this.align_row[i] = min;\\n        }\\n        for (int i = this.cost[0].length; i < this.cost.length; i++)\\n            this.select_cost += this.align_row[i];\\n        for (int i = this.cost.length - 2; i >= 0; i--)\\n            this.align_row[i] += this.align_row[i + 1];\\n        // dfs\\n        this.cols_rowfull = new boolean[this.cost[0].length];\\n        this.cols_counts = new int[this.cost[0].length];\\n        backtracking(0, 0);\\n        return this.select_cost;\\n    }\\n    private void backtracking(int row, int cost) {\\n        if (row == this.cost.length) {\\n            // check columns\\n            for (int j = 0; j < this.cost[0].length; j++) {\\n                int count = 0;\\n                for (int i = 0; i < this.cost.length; i++)\\n                    if (this.select[i][j]) count++;\\n                if (count == 0) return;\\n            }\\n            this.select_cost = cost;\\n            return;\\n        }\\n        choice(row, 0, 0, cost);\\n    }\\n    private void choice(int row, int j, int before, int cost) {\\n        if (row < this.cost.length - 1 && cost + this.align_row[row + 1] >= this.select_cost) return;\\n        if (cost >= this.select_cost) return;\\n        if (j == this.cost[0].length) {\\n            if (before == 1) backtracking(row + 1, cost);\\n            else if (before > 1) {\\n                boolean[] temp = this.cols_rowfull.clone();\\n                for (int k = 0; k < this.cost[0].length; k++)\\n                    if (this.select[row][k]) this.cols_rowfull[k] = true;\\n                backtracking(row + 1, cost);\\n                this.cols_rowfull = temp;\\n            }\\n            return;\\n        }\\n        choice(row, j + 1, before, cost);\\n        if (!this.cols_rowfull[j]) {\\n            this.select[row][j] = true;\\n            if (this.cols_counts[j] == 0 || before == 0) {\\n                this.cols_counts[j] += 1;\\n                choice(row, j + 1, before + 1, cost + this.cost[row][j]);\\n                this.cols_counts[j] -= 1;\\n            }\\n            this.select[row][j] = false;\\n        }\\n    }\\n    \\n    private void partition(int row, int cost) {\\n        if (cost >= this.select_cost) return;\\n        if (row == this.cost[0].length) {\\n            this.select_cost = cost;\\n            return;\\n        }\\n        for (int j = 0; j < this.cost[0].length; j++)\\n            if (!this.select_cols[j]) {\\n                this.select[row][j] = true;\\n                this.select_cols[j] = true;\\n                partition(row + 1, cost + this.cost[row][j]);\\n                this.select_cols[j] = false;\\n                this.select[row][j] = false;\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856189,
                "title": "c-top-down-dynamic-programing-solution-with-brief-explanation",
                "content": "```\\nclass Solution {\\n    \\n    #define LM 4100\\n    int hi, wi;\\n    vector<vector<int>> cost;\\n    int dp[12][LM];\\n    \\n    int sol(int idx, int wimsk) {\\n        if(idx == hi && wimsk == ((1<<wi)-1)) {\\n            return 0;\\n        }\\n        \\n        if(idx >= hi) {\\n            // all the member of the first group is used but \\n            // there are unmatched group member at the second group\\n            return 1e9+7;\\n        }\\n        \\n        int &res = dp[idx][wimsk];\\n        \\n        if(~res)\\n            return res;\\n        \\n        res = 1e9+7;\\n        \\n        for(int j = 0;j < wi; ++j) {\\n            // try to connect more than one member from the \\n            // second group with the idx th member of the first group  \\n            res = min(res,sol(idx,wimsk|(1<<j))+cost[idx][j]);\\n            \\n            // try to use the remaining member from the first group\\n            res = min(res,sol(idx+1,wimsk|(1<<j))+cost[idx][j]);\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        hi = cost.size(), wi = cost[0].size();\\n        this->cost = cost;\\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    #define LM 4100\\n    int hi, wi;\\n    vector<vector<int>> cost;\\n    int dp[12][LM];\\n    \\n    int sol(int idx, int wimsk) {\\n        if(idx == hi && wimsk == ((1<<wi)-1)) {\\n            return 0;\\n        }\\n        \\n        if(idx >= hi) {\\n            // all the member of the first group is used but \\n            // there are unmatched group member at the second group\\n            return 1e9+7;\\n        }\\n        \\n        int &res = dp[idx][wimsk];\\n        \\n        if(~res)\\n            return res;\\n        \\n        res = 1e9+7;\\n        \\n        for(int j = 0;j < wi; ++j) {\\n            // try to connect more than one member from the \\n            // second group with the idx th member of the first group  \\n            res = min(res,sol(idx,wimsk|(1<<j))+cost[idx][j]);\\n            \\n            // try to use the remaining member from the first group\\n            res = min(res,sol(idx+1,wimsk|(1<<j))+cost[idx][j]);\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        hi = cost.size(), wi = cost[0].size();\\n        this->cost = cost;\\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574518,
                "content": [
                    {
                        "username": "MrsBectors",
                        "content": "In real interview will they give the constraints that everyone is exploiting to get the solution accepted?"
                    },
                    {
                        "username": "Chilliou",
                        "content": "Hey,\\nI think there is an error or I do not understand very well.\\nYou must have the shortest path among [[93,56,92],[53,44,18],[86,44,69],[54,60,30]].\\nSo logically the answer would be\\n1--B\\n2--C\\n3--B\\n4--C\\nSo output 56+18+44+30 = 148\\nHowever the expected output is 172.\\nI would like a clarification ?"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "in your answer A is not connected to can of first group point"
                    }
                ]
            },
            {
                "id": 1895316,
                "content": [
                    {
                        "username": "MrsBectors",
                        "content": "In real interview will they give the constraints that everyone is exploiting to get the solution accepted?"
                    },
                    {
                        "username": "Chilliou",
                        "content": "Hey,\\nI think there is an error or I do not understand very well.\\nYou must have the shortest path among [[93,56,92],[53,44,18],[86,44,69],[54,60,30]].\\nSo logically the answer would be\\n1--B\\n2--C\\n3--B\\n4--C\\nSo output 56+18+44+30 = 148\\nHowever the expected output is 172.\\nI would like a clarification ?"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "in your answer A is not connected to can of first group point"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Good Numbers",
        "question_content": "<p>A digit string is <strong>good</strong> if the digits <strong>(0-indexed)</strong> at <strong>even</strong> indices are <strong>even</strong> and the digits at <strong>odd</strong> indices are <strong>prime</strong> (<code>2</code>, <code>3</code>, <code>5</code>, or <code>7</code>).</p>\n\n<ul>\n\t<li>For example, <code>&quot;2582&quot;</code> is good because the digits (<code>2</code> and <code>8</code>) at even positions are even and the digits (<code>5</code> and <code>2</code>) at odd positions are prime. However, <code>&quot;3245&quot;</code> is <strong>not</strong> good because <code>3</code> is at an even index but is not even.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>the <strong>total</strong> number of good digit strings of length </em><code>n</code>. Since the answer may be large, <strong>return it modulo </strong><code>10<sup>9</sup> + 7</code>.</p>\n\n<p>A <strong>digit string</strong> is a string consisting of digits <code>0</code> through <code>9</code> that may contain leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The good numbers of length 1 are &quot;0&quot;, &quot;2&quot;, &quot;4&quot;, &quot;6&quot;, &quot;8&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 400\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 50\n<strong>Output:</strong> 564908303\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>15</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1314319,
                "title": "c-full-explanation-power-fast-power-modular-power",
                "content": "We can see it\\'s fairly easy problem, hard step was calculating power efficently and using modulas\\n\\n# Power functions full analysis\\n\\nExponentiation is a mathematical operation that is expressed as `x^n` and computed as `x^n = x.x.x....x(n times)`.\\nWe have two methods for calculating exponents, recursive and iterative.\\n\\nHere, I will talk about recursive approaches, you can try iterative this will be your homework ;P \\n\\n# Basic method\\n\\nWhile calculating `x^n`, the most basic solution is broken down into `x.x^(n-1)`. The new problem is `x^(n-1)`, which is similar to the original problem. Therefore, like in original problem, it is further broken down to x.x.x^(n-2).\\n\\nThis is the recursive approach to find `x^n`.           \\nAlso we know base case will be, `n == 0` `here ans = 1`      \\n\\n```\\nint recursivePower(int x,int n) {\\n    if(n == 0) return 1;\\n    return x*recursivePower(x,n-1);\\n}\\n```\\n\\n*Time complexity:*    \\nWith respect to time complexity, it is a fairly efficient `O(n)` solution.     \\nHowever, when it comes to finding , where  can be as large as `10^15` , *this solution will not be suitable*.       \\n\\n<br />\\n\\n# Optimized method\\n\\nWhile calculating `x^n`, `n` can be odd or even.   \\n\\nIf `n` is even, then `n` can be broken down to (x^2)^(n/2). Finding `x^2` is a one-step process.   \\nHowever, finding `(A)^(n/2)` will take some time `here A = x^2`.   \\n\\nWhen `x^n` is odd, we can convert it into an even value. `x^n` can be written as `x.x^(n-1)`.   \\nThis ensures that `(n-1)` is even. So it can be again broken down to `(n-1)/2` in next step.  \\n\\n\\nNotice how the computation steps were reduced from `n` to `n/2` in just one step.    \\nYou can continue to divide the power by `2` as long as it is even or if it\\'s odd make it even.      \\n\\n## Approach has two steps:    \\n- If `n` is even, replace `x^n` by `(x^2)^(n/2)`.\\n- If `n` is odd, replace `x^n` by `x.x^(n-1)`. `n-1` becomes even and you can apply the relevant formula again.\\n\\n\\n## Example:\\nWe need to find `5^10`\\n\\nNaive approach will be, \\n```\\n5^10 = 5.5^9\\n     = 5.5.5^8\\n     = 5.5.5^7\\n     = 5.5.5.5^6\\n     = 5.5.5.5.5^5\\n     = 5.5.5.5.5.5^4\\n     = 5.5.5.5.5.5.5^3\\n     = 5.5.5.5.5.5.5.5^2\\n     = 5.5.5.5.5.5.5.5.5^1\\n     = 5.5.5.5.5.5.5.5.5.1\\n```\\nWe can see it took us `n steps` to find `5^n`\\n\\nOptimal Approach\\n```\\n5^10 = (5^2)^5\\n     = 25.25^4\\n     = 25.(25^2)^2\\n     = 25.(625)^2\\n     = 25.625.625\\n```\\n\\nThis is an efficient method and the ten-step process of determining `5^10` is reduced to a four-step process. At every step, `n` is divided by `2`. \\n\\n*Time Complexity*\\nTherefore, the time complexity is O(log N).\\n\\n```\\nint binaryExponentiation(int x,int n) {\\n    if(n==0) return 1;\\n    //n is even\\n    else if(n%2 == 0)        \\n        return binaryExponentiation(x*x,n/2);\\n    //n is odd\\n    else                             \\n        return x*binaryExponentiation(x*x,(n-1)/2);\\n}\\n```\\n\\n# Modulo Exponetiation\\n\\nHowever, storing answers that are too large for their respective datatypes is an issue with this method.   \\nIn such instances, you must use modulus (%). Instead of finding `x^n`, you must find `(x^n) % M`.\\nFor example, run the implementation of the method to find . The  solution will timeout, while the  solution will run in time but it will produce garbage values.\\n\\nIf we needed to find `2^(10^5)` or something big, then approach will run in `O(logn)` time, but produces garbage values as ans.\\n\\n```\\nint modularExponentiation(int x, int n, int M) {\\n    if(n==0) return 1;\\n    //n is even\\n    else if(n%2 == 0)        \\n        return modularExponentiation((x*x) % M, n/2, M);\\n    //n is odd\\n    else                             \\n        return (x*modularExponentiation((x*x) % M, (n-1)/2, M)) % M;\\n}\\n```\\n\\nTime complexity: `O(log N)`\\nMemory complexity: `O(log N)` because a function call consumes memory and `log N` recursive function calls are made\\n\\n> Note: Iterative ways more optimal, because recursive solutions require stack memory.     \\n> Also sometimes, (x*x) even can run out of int limit\\n\\n\\n<br />\\n\\n# Question Approach\\n\\nNow, we know we have 4 primes = {2, 3, 5, 7} and 5 evens = {0, 2, 4, 6, 8}\\n\\nif `index == 0`    \\nthen there can be any of one evens at even position, so 5 ways  \\nans = 5     \\n\\nif `index == 1`   \\nthen there was 1 even at index = 0, and at this odd index there can be one of 4 primes\\nans = 5* 4(this pos)   \\n\\nif `index == 2`   \\nthen at this even index there can be one of 5 evens\\nans = (5*4) * 5(this pos)    \\n\\nso, continuing the pattern we can see, it\\'s like, `5*4*5*4*5*4*5..... ans so on`\\nhere no. of 4s = no. of odd positions = n/2\\nno. of 5s = no. of even positions = (n-n/2)\\n\\n`ans = pow(4,count4) * pow(5,count5)`\\n\\n# Solution:\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    // evens  = 0, 2, 4, 6, 8  => 5 evens\\n    // primes = 2, 3, 5, 7     => 4 primes\\n  \\n    int p = 1e9 + 7;\\n    \\n    // calculating x^y efficeiently\\n    ll power(long long x, long long y) {\\n      long long res = 1;    \\n\\n      x = x % p; // Update x if it is more than or equal to p\\n      if (x == 0) return 0; \\n\\n      while (y > 0) {\\n        // If y is odd, multiply x with result\\n        if (y & 1) res = (res*x) % p;\\n        \\n        // we have did the odd step is it was odd, now do the even step\\n        y = y>>1; // dividing y by 2, y>>1 is same as y/2\\n        x = (x*x) % p;\\n      }\\n      return res;\\n    }\\n  \\n    int countGoodNumbers(long long n) {\\n      ll count_of_4s = n/2;\\n      ll count_of_5s = n - count_of_4s;\\n      ll ans = ((power(4LL, count_of_4s) % p  * power(5LL, count_of_5s) % p) % p);\\n      return (int)ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint recursivePower(int x,int n) {\\n    if(n == 0) return 1;\\n    return x*recursivePower(x,n-1);\\n}\\n```\n```\\n5^10 = 5.5^9\\n     = 5.5.5^8\\n     = 5.5.5^7\\n     = 5.5.5.5^6\\n     = 5.5.5.5.5^5\\n     = 5.5.5.5.5.5^4\\n     = 5.5.5.5.5.5.5^3\\n     = 5.5.5.5.5.5.5.5^2\\n     = 5.5.5.5.5.5.5.5.5^1\\n     = 5.5.5.5.5.5.5.5.5.1\\n```\n```\\n5^10 = (5^2)^5\\n     = 25.25^4\\n     = 25.(25^2)^2\\n     = 25.(625)^2\\n     = 25.625.625\\n```\n```\\nint binaryExponentiation(int x,int n) {\\n    if(n==0) return 1;\\n    //n is even\\n    else if(n%2 == 0)        \\n        return binaryExponentiation(x*x,n/2);\\n    //n is odd\\n    else                             \\n        return x*binaryExponentiation(x*x,(n-1)/2);\\n}\\n```\n```\\nint modularExponentiation(int x, int n, int M) {\\n    if(n==0) return 1;\\n    //n is even\\n    else if(n%2 == 0)        \\n        return modularExponentiation((x*x) % M, n/2, M);\\n    //n is odd\\n    else                             \\n        return (x*modularExponentiation((x*x) % M, (n-1)/2, M)) % M;\\n}\\n```\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    // evens  = 0, 2, 4, 6, 8  => 5 evens\\n    // primes = 2, 3, 5, 7     => 4 primes\\n  \\n    int p = 1e9 + 7;\\n    \\n    // calculating x^y efficeiently\\n    ll power(long long x, long long y) {\\n      long long res = 1;    \\n\\n      x = x % p; // Update x if it is more than or equal to p\\n      if (x == 0) return 0; \\n\\n      while (y > 0) {\\n        // If y is odd, multiply x with result\\n        if (y & 1) res = (res*x) % p;\\n        \\n        // we have did the odd step is it was odd, now do the even step\\n        y = y>>1; // dividing y by 2, y>>1 is same as y/2\\n        x = (x*x) % p;\\n      }\\n      return res;\\n    }\\n  \\n    int countGoodNumbers(long long n) {\\n      ll count_of_4s = n/2;\\n      ll count_of_5s = n - count_of_4s;\\n      ll ans = ((power(4LL, count_of_4s) % p  * power(5LL, count_of_5s) % p) % p);\\n      return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317451,
                "title": "java-step-by-step-clear-explanation-with-pictures-o-logn",
                "content": "![image](https://assets.leetcode.com/users/images/5ed635fe-755b-4160-9f9e-0847aa38dd80_1625478983.5458512.png)\\n\\n![image](https://assets.leetcode.com/users/images/0e676e7c-9df8-46bb-8866-8210763a960f_1625479027.6679919.png)\\n\\n![image](https://assets.leetcode.com/users/images/e25011a3-432e-43d6-9062-3f3a8368ca3c_1625479075.4199393.png)\\n\\n![image](https://assets.leetcode.com/users/images/fb4f0702-e58c-414a-a10c-409be0650d1e_1625479112.91825.png)\\n\\n![image](https://assets.leetcode.com/users/images/af85bc7d-e8ee-449c-96b4-fb95fd6dd91e_1625479141.7977948.png)\\n\\n![image](https://assets.leetcode.com/users/images/4ffd7031-5a83-442b-8d04-d8e896a78f01_1625479180.9428902.png)\\n\\n![image](https://assets.leetcode.com/users/images/9790e014-b315-4e3b-982f-1c228bac2b73_1625479268.029513.png)\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    public int countGoodNumbers(long n) {\\n        long first=(n%2==0?(n/2):(n/2)+1);//deciding n/2 or n/2+1 depending on n is even or odd\\n        long second=n/2;//second power would be n/2 only irrespective of even or odd\\n        long mul1=power(5,first)%mod;//5 power n/2\\n        long mul2=power(4,second)%mod;//4 power n/2\\n        long ans=1;\\n        ans=(ans*mul1)%mod;//computing total product\\n        ans=(second!=0)?(ans*mul2)%mod:ans;//computing total product\\n        return (int)(ans%mod);\\n    }\\n    public long power(long x,long y){// this method computes pow(x,y) in O(logn) using divide & conquer\\n        long temp;\\n        if(y==0) return 1;//base case (x power 0 = 1)\\n        temp=power(x,y/2);//computing power for pow(x,y/2) -> divide & conquer step\\n        if(y%2==0) return (temp*temp)%mod; //using that result of subproblem (2 power 2 = 2 power 1 * 2 power 1)\\n        else return (x*temp*temp)%mod;//using that result of subproblem (2 power 3 = 2 power 1 * 2 power 1 * 2)\\n\\t\\t// if y is odd, x power y = x power y/2 * x power y/2 * x\\n\\t\\t// if y is even, x power y = x power y/2 * x power y/2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod=(int)1e9+7;\\n    public int countGoodNumbers(long n) {\\n        long first=(n%2==0?(n/2):(n/2)+1);//deciding n/2 or n/2+1 depending on n is even or odd\\n        long second=n/2;//second power would be n/2 only irrespective of even or odd\\n        long mul1=power(5,first)%mod;//5 power n/2\\n        long mul2=power(4,second)%mod;//4 power n/2\\n        long ans=1;\\n        ans=(ans*mul1)%mod;//computing total product\\n        ans=(second!=0)?(ans*mul2)%mod:ans;//computing total product\\n        return (int)(ans%mod);\\n    }\\n    public long power(long x,long y){// this method computes pow(x,y) in O(logn) using divide & conquer\\n        long temp;\\n        if(y==0) return 1;//base case (x power 0 = 1)\\n        temp=power(x,y/2);//computing power for pow(x,y/2) -> divide & conquer step\\n        if(y%2==0) return (temp*temp)%mod; //using that result of subproblem (2 power 2 = 2 power 1 * 2 power 1)\\n        else return (x*temp*temp)%mod;//using that result of subproblem (2 power 3 = 2 power 1 * 2 power 1 * 2)\\n\\t\\t// if y is odd, x power y = x power y/2 * x power y/2 * x\\n\\t\\t// if y is even, x power y = x power y/2 * x power y/2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314322,
                "title": "c-5-even-indices-4-odd-indices-with-explanation",
                "content": "```\\n/*\\nAt even indices there can be 5 values(0,2,4,6,8) i.e. all even numbers 0 to 9\\nAnd At odd indices there can 4 values(2,3,5,7) i.e. all prime numbers 0 to 9\\nSo we notice that there are 5 values which can be in even indices and 4 in odd indices.\\nSo now Logic is simple :-\\nTotal number of good digit strings would be  (5 ^ even indices) * (4 ^ odd indices)....We also need to return  % 10^9 + 7.\\nBut the other problem is the constraints which is way too big. So we need to calculate (5 ^ even indices) and  (4 ^ odd indices) in log(n) time, which is done by powerMod function.\\nNow lets understand the powerMod fuction :-\\n\\nWe know that a^b where b is 0 is 1. So thats our base case.\\nNow if b is not 0 :-\\nCase 1 - b is even\\na^b can written as (a^(b/2)) * (a ^ (b/2)) right?! So we just do an recursive call here\\n\\nCase 2 - b is odd\\nhere i would like to take b as 5 for explanation.\\na^5 can be written as a^(5/2) * a^(5/2) * a. Which can be re-written as (a^(b/2)) * (a^(b/2)) * a.\\nSo again we just do an recursive call again!\\n\\nNote 5/2 is 2.\\n\\nAlso if you liked the solution upvote, it really motivates me a lot.\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    long long powerMod(int a, long long b, int mod) {\\n        if(b == 0)\\n            return 1;\\n        long long x = powerMod(a, b/2, mod);\\n        if(b % 2 == 0)\\n            return (x * x) % mod;\\n        else\\n            return (((a * x) % mod) * x) % mod;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        int mod = 1e9+7;\\n        return (powerMod(5, (n + 1) / 2, mod) * powerMod(4, n / 2, mod)) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nAt even indices there can be 5 values(0,2,4,6,8) i.e. all even numbers 0 to 9\\nAnd At odd indices there can 4 values(2,3,5,7) i.e. all prime numbers 0 to 9\\nSo we notice that there are 5 values which can be in even indices and 4 in odd indices.\\nSo now Logic is simple :-\\nTotal number of good digit strings would be  (5 ^ even indices) * (4 ^ odd indices)....We also need to return  % 10^9 + 7.\\nBut the other problem is the constraints which is way too big. So we need to calculate (5 ^ even indices) and  (4 ^ odd indices) in log(n) time, which is done by powerMod function.\\nNow lets understand the powerMod fuction :-\\n\\nWe know that a^b where b is 0 is 1. So thats our base case.\\nNow if b is not 0 :-\\nCase 1 - b is even\\na^b can written as (a^(b/2)) * (a ^ (b/2)) right?! So we just do an recursive call here\\n\\nCase 2 - b is odd\\nhere i would like to take b as 5 for explanation.\\na^5 can be written as a^(5/2) * a^(5/2) * a. Which can be re-written as (a^(b/2)) * (a^(b/2)) * a.\\nSo again we just do an recursive call again!\\n\\nNote 5/2 is 2.\\n\\nAlso if you liked the solution upvote, it really motivates me a lot.\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    long long powerMod(int a, long long b, int mod) {\\n        if(b == 0)\\n            return 1;\\n        long long x = powerMod(a, b/2, mod);\\n        if(b % 2 == 0)\\n            return (x * x) % mod;\\n        else\\n            return (((a * x) % mod) * x) % mod;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        int mod = 1e9+7;\\n        return (powerMod(5, (n + 1) / 2, mod) * powerMod(4, n / 2, mod)) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209060,
                "title": "best-c-solution-ever-math-recursion-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Math + Recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(logN).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(logN), Recursion stack space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(logN), Recursion stack space.\\n\\n*/\\n\\n#define mod 1000000007\\nclass Solution {\\nprivate:\\n    long long power(long long x, long long n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        long long ans = power(x, n/2);\\n        ans *= ans;\\n        ans %= mod;\\n        if(n%2==1){\\n            ans *= x;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long numberOfOddPlaces = n/2;\\n        long long numberOfEvenPlaces = n/2 + n%2;\\n        return (power(5, numberOfEvenPlaces) * power(4, numberOfOddPlaces))%mod;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(logN), Recursion stack space.\\n\\n*/\\n\\n#define mod 1000000007\\nclass Solution {\\nprivate:\\n    long long power(long long x, long long n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        long long ans = power(x, n/2);\\n        ans *= ans;\\n        ans %= mod;\\n        if(n%2==1){\\n            ans *= x;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long numberOfOddPlaces = n/2;\\n        long long numberOfEvenPlaces = n/2 + n%2;\\n        return (power(5, numberOfEvenPlaces) * power(4, numberOfOddPlaces))%mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314505,
                "title": "modpow",
                "content": "The answer is `5 * 4 * 5 * 4 ... * 5 * 4 [ * 5]`, and we have `4` repeated `n / 2`  times, and `5` repeated `(n + 1) / 2` times (we have an extra `5` if `n` is odd). \\n\\nSince `n` can be very large, we need to use an efficient power operation. The `modPow` function below has logarithmic complexity and it\\'s mod-aware.\\n\\n> Update: see an optimized solution below.\\n\\n**C++**\\n```cpp\\nlong long modPow(long long x, long long y, int m = 1000000007)\\n{\\n    if (y == 0)\\n        return 1;\\n    auto p = modPow(x, y / 2, m);\\n    return p * p * (y % 2 ? x : 1) % m;\\n}\\nint countGoodNumbers(long long n) {\\n    return modPow(5, (n + 1) / 2) * modPow(4, n / 2) % 1000000007;\\n}  \\n```\\n**Java**\\n```java\\nlong modPow(long x, long y)\\n{\\n    if (y == 0)\\n        return 1;\\n    long p = modPow(x, y / 2);\\n    return p * p * (y % 2 > 0 ? x : 1) % 1000000007;\\n}\\npublic int countGoodNumbers(long n) {\\n    return (int)(modPow(5, (n + 1) / 2) * modPow(4, n / 2) % 1000000007);    \\n}\\n```\\n#### Optimized Solution\\nWe can just do `modPow(20, n / 2) * (n % 2 ? 5 : 1)` instead of two separate function calls, like [ZX007PI](https://leetcode.com/ZX007PI/) suggested. \\n**C++**\\n```cpp\\nlong long modPow(long long x, long long y, int mod = 1000000007)\\n{\\n    if (y == 0)\\n        return 1;\\n    auto p = modPow(x, y / 2);\\n    return p * p % mod * (y % 2 ? x : 1) % mod;\\n}\\nint countGoodNumbers(long long n) {\\n    return modPow(20, n / 2) * (n % 2 ? 5 : 1) % 1000000007;\\n}   \\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nlong long modPow(long long x, long long y, int m = 1000000007)\\n{\\n    if (y == 0)\\n        return 1;\\n    auto p = modPow(x, y / 2, m);\\n    return p * p * (y % 2 ? x : 1) % m;\\n}\\nint countGoodNumbers(long long n) {\\n    return modPow(5, (n + 1) / 2) * modPow(4, n / 2) % 1000000007;\\n}  \\n```\n```java\\nlong modPow(long x, long y)\\n{\\n    if (y == 0)\\n        return 1;\\n    long p = modPow(x, y / 2);\\n    return p * p * (y % 2 > 0 ? x : 1) % 1000000007;\\n}\\npublic int countGoodNumbers(long n) {\\n    return (int)(modPow(5, (n + 1) / 2) * modPow(4, n / 2) % 1000000007);    \\n}\\n```\n```cpp\\nlong long modPow(long long x, long long y, int mod = 1000000007)\\n{\\n    if (y == 0)\\n        return 1;\\n    auto p = modPow(x, y / 2);\\n    return p * p % mod * (y % 2 ? x : 1) % mod;\\n}\\nint countGoodNumbers(long long n) {\\n    return modPow(20, n / 2) * (n % 2 ? 5 : 1) % 1000000007;\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441676,
                "title": "java-100-faster-recursive-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/7a0c7be5-52f8-4607-a0b1-d139341d78d8_1682099222.9021685.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    // Define MOD as a class variable for easier reference and readability\\n    public long MOD = 1_000_000_007;\\n    \\n    public int countGoodNumbers(long n) {\\n        \\n        // Calculate the number of even and odd positions in the digit string\\n        long odd = n/2;\\n        long even = (n+1)/2;\\n        \\n        // Calculate the total number of good digit strings\\n        // multiplying 5 by even because there could only be 5 even numbers between 0-9\\n        // multiplying 4 by odd because there could only be 4 prime numbers between 0-9\\n        return (int)(pow(5,even) * pow(4,odd) % MOD);\\n    }\\n    \\n    public long pow(long x, long n){\\n        \\n        // Base case for the recursion\\n        if(n==0) \\n            return 1;\\n        \\n        // Recursively calculate x^(n/2)\\n        long temp = pow(x,n/2);\\n        \\n        // If n is even, return (x^(n/2))^2\\n        if(n%2==0){\\n            return (temp * temp)% MOD;\\n        }\\n        // If n is odd, return (x^(n/2))^2 * x\\n        else{\\n            return (x * temp * temp)% MOD;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Define MOD as a class variable for easier reference and readability\\n    public long MOD = 1_000_000_007;\\n    \\n    public int countGoodNumbers(long n) {\\n        \\n        // Calculate the number of even and odd positions in the digit string\\n        long odd = n/2;\\n        long even = (n+1)/2;\\n        \\n        // Calculate the total number of good digit strings\\n        // multiplying 5 by even because there could only be 5 even numbers between 0-9\\n        // multiplying 4 by odd because there could only be 4 prime numbers between 0-9\\n        return (int)(pow(5,even) * pow(4,odd) % MOD);\\n    }\\n    \\n    public long pow(long x, long n){\\n        \\n        // Base case for the recursion\\n        if(n==0) \\n            return 1;\\n        \\n        // Recursively calculate x^(n/2)\\n        long temp = pow(x,n/2);\\n        \\n        // If n is even, return (x^(n/2))^2\\n        if(n%2==0){\\n            return (temp * temp)% MOD;\\n        }\\n        // If n is odd, return (x^(n/2))^2 * x\\n        else{\\n            return (x * temp * temp)% MOD;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314363,
                "title": "java-python-3-iterative-o-logn-code-similar-to-lc50-pow-x-n-w-brief-explanation-and-analysis",
                "content": "1. For each even index, there are 5 options: `0`, `2`, `4`, `6`, `8`;\\n2. For each odd index, there are 4 options: `2`, `3`, `5`, `7`;\\n3. If `n` is even, the solution is `(4 * 5) ^ (n / 2)`; if odd, `(4 * 5) ^ (n / 2) * 5`.\\n\\n**Method 1: Bruteforce**\\n\\nThe input range is as large as `10 ^ 15`, hence the following bruteforec codes will get `TLE` (Time Limit Exceeded) without any surprise.\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        long good = n % 2 == 0 ? 1 : 5;\\n        for (long i = 0, x = 4 * 5; i < n / 2; ++i) {\\n            good = good * x % MOD;   \\n        }\\n        return (int)good;\\n    }\\n```\\n```python\\n    def countGoodNumbers(self, n: int) -> int:\\n        good, x = 5 ** (n % 2), 4 * 5\\n        for _ in range(n // 2):\\n            good = good * x % (10 ** 9 + 7)\\n        return good\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`.\\n\\n----\\n\\n**Method 2: fast power**\\n\\nOur main object is to compute `x ^ (n // 2)`. To deal with the large input of `10 ^ 15`, we can use fast power: \\n\\nDenote `n // 2` as `i`. \\n1. If `i` is even, increase `x` to `x ^ 2` and divide `i` by `2`;\\n2. If `i` is odd, multiply `good` by `x` and deduct `i` by `1`; now `i` is even, go to procedure `1`.\\n\\nRepeat the above till `i` decrease to `0`, and `good` is our solution. Please refer to the following recursive codes:\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        return (int)(countGood(n / 2, 4 * 5) * (n % 2 == 0 ? 1 : 5) % MOD);\\n    }\\n    private long countGood(long  power, long x) {\\n        if (power == 0) {\\n            return 1;\\n        }else if (power % 2 == 0) {\\n            return countGood(power / 2, x * x % MOD);\\n        } \\n        return x * countGood(power - 1, x) % MOD;\\n    }\\n```\\n```python\\n    def countGoodNumbers(self, n: int) -> int:\\n        \\n        def countGood(power: int, x: int) -> int:\\n            if power == 0:\\n                return 1  \\n            elif power % 2 == 0:\\n                return countGood(power // 2, x * x % MOD)\\n            return x * countGood(power - 1, x) % MOD\\n\\n        MOD = 10 ** 9 + 7\\n        return 5 ** (n % 2) * countGood(n // 2, 4 * 5) % MOD\\n```\\n**Analysis:**\\n\\nTime & space: `O(logn)`.\\n\\nWe can further change the above recursive versions into iterative ones:\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        long good = n % 2 == 0 ? 1 : 5;\\n        for (long i = n / 2, x = 4 * 5; i > 0; i /= 2, x = x * x % MOD) {\\n            if (i % 2 != 0) {\\n                good = good * x % MOD;\\n            }\\n        }\\n        return (int)good;\\n    }\\n```\\n```python\\n    def countGoodNumbers(self, n: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        good, x, i = 5 ** (n % 2), 4 * 5, n // 2\\n        while i > 0:\\n            if i % 2 == 1:\\n                good = good * x % MOD\\n            x = x * x % MOD\\n            i //= 2\\n        return good\\n```\\n\\n**Analysis:**\\n\\nTime: `O(logn)`, space: `O(1)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        long good = n % 2 == 0 ? 1 : 5;\\n        for (long i = 0, x = 4 * 5; i < n / 2; ++i) {\\n            good = good * x % MOD;   \\n        }\\n        return (int)good;\\n    }\\n```\n```python\\n    def countGoodNumbers(self, n: int) -> int:\\n        good, x = 5 ** (n % 2), 4 * 5\\n        for _ in range(n // 2):\\n            good = good * x % (10 ** 9 + 7)\\n        return good\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        return (int)(countGood(n / 2, 4 * 5) * (n % 2 == 0 ? 1 : 5) % MOD);\\n    }\\n    private long countGood(long  power, long x) {\\n        if (power == 0) {\\n            return 1;\\n        }else if (power % 2 == 0) {\\n            return countGood(power / 2, x * x % MOD);\\n        } \\n        return x * countGood(power - 1, x) % MOD;\\n    }\\n```\n```python\\n    def countGoodNumbers(self, n: int) -> int:\\n        \\n        def countGood(power: int, x: int) -> int:\\n            if power == 0:\\n                return 1  \\n            elif power % 2 == 0:\\n                return countGood(power // 2, x * x % MOD)\\n            return x * countGood(power - 1, x) % MOD\\n\\n        MOD = 10 ** 9 + 7\\n        return 5 ** (n % 2) * countGood(n // 2, 4 * 5) % MOD\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        long good = n % 2 == 0 ? 1 : 5;\\n        for (long i = n / 2, x = 4 * 5; i > 0; i /= 2, x = x * x % MOD) {\\n            if (i % 2 != 0) {\\n                good = good * x % MOD;\\n            }\\n        }\\n        return (int)good;\\n    }\\n```\n```python\\n    def countGoodNumbers(self, n: int) -> int:\\n        MOD = 10 ** 9 + 7\\n        good, x, i = 5 ** (n % 2), 4 * 5, n // 2\\n        while i > 0:\\n            if i % 2 == 1:\\n                good = good * x % MOD\\n            x = x * x % MOD\\n            i //= 2\\n        return good\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1314434,
                "title": "python-logarithmic-time-solution",
                "content": "Approach: Each even index numbers have 5 possibilites (0,2,4,6,8) and each odd index numbers have 4 possibilities(2,3,5,7).\\n\\nSo, \\nif n = 4, ans = 5 * 4 * 5 * 4 = 20 ^ (4/2) = 20 ^ 2\\nif n = 7, ans =  5 * 4 * 5 * 4 * 5 * 4 * 5 = (20 ^ (6/2)) * 5 = (20 ^ 3) * 5 \\n\\nClearly it is visible that, if the number n is even ans is 20 ^ (n/2) and if the number n is odd, then along with doing 20 ^ (n/2) we need to multiply 5 at the end.\\n\\nNow if we do it linearly, it will throw a TLE. But using **inbuilt pow funtion** in python, we can calucate the pow(a,b) in log2(b) time. \\n*Now, calculating power can exceed the size of variable, so pass a mod constant as 3rd parameter in pow funtion.*\\n\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        ans = 1\\n        rem = n % 2\\n        n -= rem\\n        ans = pow(20, n//2, 10**9 + 7)\\n        if rem == 1:\\n            ans *= 5\\n        return ans % (10**9 + 7)\\n```\\n**Note:** It can be solved in constant time, by using math.pow funtion.\\n\\nTime : O(log (n/2)) = O(logn)\\nSpace : O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        ans = 1\\n        rem = n % 2\\n        n -= rem\\n        ans = pow(20, n//2, 10**9 + 7)\\n        if rem == 1:\\n            ans *= 5\\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314325,
                "title": "python3-two-lines",
                "content": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        return pow(5, (n + 1) // 2, mod) * pow(4, n // 2, mod) % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        return pow(5, (n + 1) // 2, mod) * pow(4, n // 2, mod) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594770,
                "title": "java-easy-fastest-solution-with-full-explanation",
                "content": "There are 4 prime numbers (2, 3, 5, 7) and 5 even numbers (0, 2, 4, 6, 8) from 0 to 9.\\n\\nIf n is 0, then there can be any of one evens at even position, so 5 ways.\\nans = 5;\\n\\nif n is 1.\\nthen there was 1 even at index = 0, and at index==1 there can be one of 4 primes.\\nans = 5* 4;\\n\\nif n is 2, then at this index==2 there can be one of 5 evens.\\nans = (5*4) * 5;\\n\\nSo, continuing the pattern we can see, it\\'s like, 5*4*5*4*5*4*5..... ans so on.\\nHere no. of 4s = no. of odd positions = n/2;\\nno. of 5s = no. of even positions = (n+1)/2 or (n/2+n%2);\\n\\nans = pow(4,count4) * pow(5,count5);\\n\\n```\\nclass Solution {\\n    public long mod = 1000000007; //This is the mod value given in question.\\n    public int countGoodNumbers(long n) {\\n        \\n        //Indexing is 0 based according to the question.\\n        long odd = n/2; //It gives the number of odd indices starting from 1 to n. \\n        long even = (n+1)/2; //It gives number of even indices. It is basically n/2 + n%2;\\n        return (int)(pow(5, even)*pow(4, odd)%mod); //As there are 4 prime numbers and 5 even numbers\\n                                                    // from 0 to 9.\\n        \\n    }\\n    \\n    // To understand this pow function properly you can solve leetcode problem 50\\n    // where you will have to contruct it. I will attach the link above.\\n    public long pow(long x, long n) {\\n        \\n        if(n==0) return 1;\\n        \\n        long temp = pow(x,n/2);\\n        \\n        if(n%2==0){\\n            return (temp*temp)%mod;\\n        }\\n        else{\\n            return (x*temp*temp)%mod;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public long mod = 1000000007; //This is the mod value given in question.\\n    public int countGoodNumbers(long n) {\\n        \\n        //Indexing is 0 based according to the question.\\n        long odd = n/2; //It gives the number of odd indices starting from 1 to n. \\n        long even = (n+1)/2; //It gives number of even indices. It is basically n/2 + n%2;\\n        return (int)(pow(5, even)*pow(4, odd)%mod); //As there are 4 prime numbers and 5 even numbers\\n                                                    // from 0 to 9.\\n        \\n    }\\n    \\n    // To understand this pow function properly you can solve leetcode problem 50\\n    // where you will have to contruct it. I will attach the link above.\\n    public long pow(long x, long n) {\\n        \\n        if(n==0) return 1;\\n        \\n        long temp = pow(x,n/2);\\n        \\n        if(n%2==0){\\n            return (temp*temp)%mod;\\n        }\\n        else{\\n            return (x*temp*temp)%mod;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676368,
                "title": "c-explained-log-n-time-mathematics",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using simple concept of permutation :-\\n\\nlet us say we are given two type of items numberd 5 & 4 i.e number of item1 is 5 & number of item2 is 4, Now we are given 4 placeholder\\n\\n\\n                         --- --- --- ---\\n            positon:-     E   O   E   O\\n             \\nE:- Even position\\nO:- Odd Position\\n\\nit has given that at odd position we can fill with item2 & at even position we can fill it with item1 so we will start like :- at first position we can fill it in 5 ways, 2nd position can be fill in 4 ways , 3rd position can be fill in 5 ways & finally 4th position can be filled by 4 ways ,so using simple permutation this can be done 5x4x5x4 ways & this we need to return .\\nthis can be written as pow(5,2)*pow(4,2) => pow(5,n/2)*pow(4,n/2)\\n\\nout of 10 digits {0,2,4,6,8}->even digits => 5 in number, {2,3,5,7} -> prime digits 4 in number\\n\\nif number n is odd, return pow(5,n/2+1)*pow(4,n/2) otherwise return pow(5,n/2)*pow(4,n/2)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nn <=10^15 we need to define power(x,y) function that return modulus power\\n\\nApproch for power function:-\\n\\nif(y==0)\\nreturn 1;\\n\\nlong long int temp=power(x,y/2);\\n\\nif(y%2==0)//Even power\\nreturn temp*temp;\\n\\nelse\\nreturn temp*temp*x;\\n\\n\\nImportant property of modulus operator :-\\n\\n(A * B)%mod == (A%mod * B%mod)%mod\\n\\n(A + B)%mod == (A%mod + B%mod)%mod\\n\\n# Complexity\\n- Time complexity: O(Log(n)) // time complexity of power function\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) // constant if we ignore stack space use by recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution \\n{\\nprivate:\\n\\nlong long int modPower(int num,long long int ind)\\n{\\n    if(ind==0)\\n    {\\n        return 1;\\n    }\\n\\n    long long int temp=modPower(num,ind/2);\\n\\n    if(ind%2==0)\\n    {\\n        return (temp%mod * temp%mod)%mod;\\n    }\\n\\n\\n    return (((long long int)num%mod) * (temp%mod) * (temp%mod))%mod;\\n}\\n\\npublic:\\n    int countGoodNumbers(long long n) \\n    {\\n\\n        if(n%2==0)\\n        {\\n            (modPower(5,n/2)%mod *modPower(4,n/2)%mod)%mod;\\n        }\\n\\n        return (modPower(5,n/2+1)*modPower(4,n/2))%mod;\\n    }\\n};\\n```\\n\\n**please upvote if found useful & also put comment if you have any suggestion :)\\nthanks & regard\\nAKS**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution \\n{\\nprivate:\\n\\nlong long int modPower(int num,long long int ind)\\n{\\n    if(ind==0)\\n    {\\n        return 1;\\n    }\\n\\n    long long int temp=modPower(num,ind/2);\\n\\n    if(ind%2==0)\\n    {\\n        return (temp%mod * temp%mod)%mod;\\n    }\\n\\n\\n    return (((long long int)num%mod) * (temp%mod) * (temp%mod))%mod;\\n}\\n\\npublic:\\n    int countGoodNumbers(long long n) \\n    {\\n\\n        if(n%2==0)\\n        {\\n            (modPower(5,n/2)%mod *modPower(4,n/2)%mod)%mod;\\n        }\\n\\n        return (modPower(5,n/2+1)*modPower(4,n/2))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314522,
                "title": "well-explained-4-lines-97-faster-easily-understandable",
                "content": "## Idea :\\n\\uD83D\\uDC49 *find number of odd and  even places of from given n.*\\n\\uD83D\\uDC49 *each even places can take (0,2,4,6,8) 5 different numbers.*\\n\\uD83D\\uDC49 *each odd places can take (2,3,5,7) 4 different prime numbers.*\\n\\uD83D\\uDC49 *return the total combination of both even and odd places.*\\n\\n### **pow(a,b,c) = (a^b)%c**\\n\\ne.g. : n = 4\\n\\n_ _ _ _ _ _\\n\\tne = 2                        # n//2\\n\\tno = 2                       # n//2\\n\\tte  = (5**2)%MOD    #te=25\\n\\tto = (4**2)%MOD    # to=16\\n\\t\\n\\treturn   (25*16)%MOD     # 400\\n\\t\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        MOD = 10**9+7\\n\\t\\t\\n\\t\\t# No. of even places\\n        if n%2==0:\\n            ne=n//2\\n        else:\\n            ne=(n+1)//2\\n        # No. of odd places\\n        no=n//2\\n        \\n        te = pow(5,ne,MOD)      #Total number of even places combinations.\\n        tp = pow(4,no,MOD)      #Total number of odd/prime combinations.\\n        return (tp*te)%MOD\\n\\t\\t\\nIf you have any doubt feel free to ask. \\uD83E\\uDD17\\nIf you got any help then DO **upvote!!** \\uD83E\\uDD1E\\nThanks",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "## Idea :\\n\\uD83D\\uDC49 *find number of odd and  even places of from given n.*\\n\\uD83D\\uDC49 *each even places can take (0,2,4,6,8) 5 different numbers.*\\n\\uD83D\\uDC49 *each odd places can take (2,3,5,7) 4 different prime numbers.*\\n\\uD83D\\uDC49 *return the total combination of both even and odd places.*\\n\\n### **pow(a,b,c) = (a^b)%c**\\n\\ne.g. : n = 4\\n\\n_ _ _ _ _ _\\n\\tne = 2                        # n//2\\n\\tno = 2                       # n//2\\n\\tte  = (5**2)%MOD    #te=25\\n\\tto = (4**2)%MOD    # to=16\\n\\t\\n\\treturn   (25*16)%MOD     # 400\\n\\t\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        MOD = 10**9+7\\n\\t\\t\\n\\t\\t# No. of even places\\n        if n%2==0:\\n            ne=n//2\\n        else:\\n            ne=(n+1)//2\\n        # No. of odd places\\n        no=n//2\\n        \\n        te = pow(5,ne,MOD)      #Total number of even places combinations.\\n        tp = pow(4,no,MOD)      #Total number of odd/prime combinations.\\n        return (tp*te)%MOD\\n\\t\\t\\nIf you have any doubt feel free to ask. \\uD83E\\uDD17\\nIf you got any help then DO **upvote!!** \\uD83E\\uDD1E\\nThanks",
                "codeTag": "Java"
            },
            {
                "id": 2290129,
                "title": "c-tc-o-log-n-2-explained-with-comment",
                "content": "```\\n// Approach :-> This is question of combination \\n// if n as large no....\\n// 0   1   2   3   4   5   6   7   8   9   10  11 . . . . .  n\\n// 5 * 4 * 5 * 4 * 5 * 4 * 5 * 4 * 5 * 4 * 5 * 4  . . . . . n/4 times of 4 and n/4 times of 5;\\n//so calculate 5*4 = 20 -------> 20 * 20 * 20 * . . . . .. n/2 times \\n//so calcultae pow(20,n/2)\\n// if n is even return pow(20,n/2) \\n// if n is odd return 5*pow(20,n/2) beacause if n is odd then one 5 is left out \\n// we can easily calculate pow(x,y) in log(y) times \\n// durign calculation take care about mod \\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long solve(long long val,long long pow){ // calculatin pow in log(n) time\\n        if(pow==0) return 1;\\n        \\n        if(pow%2==0){\\n            return solve((val*val)%mod,pow/2)%mod;\\n        }\\n        else\\n            return (val*solve((val*val)%mod,pow/2))%mod;\\n        \\n    }\\n    int countGoodNumbers(long long n) {\\n        // even means 5 options \\n        // odd means 4 option \\n        \\n        long long pow = n/2; // calculate no of times 5*4 means 20 occurs\\n        \\n        long long ans = solve(20,pow); // calculate power(20,pow)\\n        \\n        if(n%2==0){ // if n is even then 5 and 4 occur same no of time n/2 \\n            return ans;\\n        }\\n        return ((5*ans) % mod);  // if n is odd then 5 occurs n/2+1 times means one extra times so return ans*5 and don\\'t forgot to mod\\n    }\\n};\\n```\\nIf You Like Please Upvote :)\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Approach :-> This is question of combination \\n// if n as large no....\\n// 0   1   2   3   4   5   6   7   8   9   10  11 . . . . .  n\\n// 5 * 4 * 5 * 4 * 5 * 4 * 5 * 4 * 5 * 4 * 5 * 4  . . . . . n/4 times of 4 and n/4 times of 5;\\n//so calculate 5*4 = 20 -------> 20 * 20 * 20 * . . . . .. n/2 times \\n//so calcultae pow(20,n/2)\\n// if n is even return pow(20,n/2) \\n// if n is odd return 5*pow(20,n/2) beacause if n is odd then one 5 is left out \\n// we can easily calculate pow(x,y) in log(y) times \\n// durign calculation take care about mod \\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long solve(long long val,long long pow){ // calculatin pow in log(n) time\\n        if(pow==0) return 1;\\n        \\n        if(pow%2==0){\\n            return solve((val*val)%mod,pow/2)%mod;\\n        }\\n        else\\n            return (val*solve((val*val)%mod,pow/2))%mod;\\n        \\n    }\\n    int countGoodNumbers(long long n) {\\n        // even means 5 options \\n        // odd means 4 option \\n        \\n        long long pow = n/2; // calculate no of times 5*4 means 20 occurs\\n        \\n        long long ans = solve(20,pow); // calculate power(20,pow)\\n        \\n        if(n%2==0){ // if n is even then 5 and 4 occur same no of time n/2 \\n            return ans;\\n        }\\n        return ((5*ans) % mod);  // if n is odd then 5 occurs n/2+1 times means one extra times so return ans*5 and don\\'t forgot to mod\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314640,
                "title": "easy-java-solution-just-calculation-of-pow-x-n",
                "content": "We have 5 choices for even-index position and 4 choices for odd-index. The number of those digits is fixed with a given `n`.\\n\\nThere should be `(n+1) / 2` even-indecies and `n / 2` odd-indecies. Thus, the result should be `pow(5, (n+1) / 2) * pow(4, n / 2)`\\n\\n```java\\nclass Solution {\\n    long mod = (int)1e9+7;\\n    \\n    public int countGoodNumbers(long n) {\\n        return (int) (helper(5, (n + 1) / 2) * helper(4, n / 2) % mod);\\n    }\\n    \\n    public long helper(int x, long n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return x;\\n        if (n % 2 == 1) {\\n            return (x * helper(x, n - 1)) % mod;\\n        }\\n        long half = helper(x, n / 2);\\n        return half * half % mod;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    long mod = (int)1e9+7;\\n    \\n    public int countGoodNumbers(long n) {\\n        return (int) (helper(5, (n + 1) / 2) * helper(4, n / 2) % mod);\\n    }\\n    \\n    public long helper(int x, long n) {\\n        if (n == 0) return 1;\\n        if (n == 1) return x;\\n        if (n % 2 == 1) {\\n            return (x * helper(x, n - 1)) % mod;\\n        }\\n        long half = helper(x, n / 2);\\n        return half * half % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314458,
                "title": "java-using-biginteger",
                "content": "```\\npublic int countGoodNumbers(long n) {\\n        int m = 1000000007;\\n        // making n even, if odd set flag=1\\n\\t\\tint flag=0;\\n        if(n%2==1){\\n            n--;\\n            flag=1;\\n        }\\n\\t\\t// converting n to n/2, because (5*4) is calculated as one unit...\\n\\t\\t// now simply do (20)^n \\n        n=n/2;\\n        String mm  = String.valueOf(m); \\n        BigInteger mod = new BigInteger(mm); //store modulus\\n        String num = String.valueOf(n);\\n        BigInteger x = new BigInteger(num); //store n\\n        BigInteger val = new BigInteger(\"20\");\\n        BigInteger result = val.modPow(x, mod);// calculate result\\n        \\n        long ans = result.longValue();\\n\\t\\t//if flag is 1, means we have converted odd n to even  n ,by making n--\\n\\t\\t//so, (ans*5) is remaining\\n        if(flag==1)\\n            ans = (ans*5)%m;\\n        return (int)ans; // required ans\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countGoodNumbers(long n) {\\n        int m = 1000000007;\\n        // making n even, if odd set flag=1\\n\\t\\tint flag=0;\\n        if(n%2==1){\\n            n--;\\n            flag=1;\\n        }\\n\\t\\t// converting n to n/2, because (5*4) is calculated as one unit...\\n\\t\\t// now simply do (20)^n \\n        n=n/2;\\n        String mm  = String.valueOf(m); \\n        BigInteger mod = new BigInteger(mm); //store modulus\\n        String num = String.valueOf(n);\\n        BigInteger x = new BigInteger(num); //store n\\n        BigInteger val = new BigInteger(\"20\");\\n        BigInteger result = val.modPow(x, mod);// calculate result\\n        \\n        long ans = result.longValue();\\n\\t\\t//if flag is 1, means we have converted odd n to even  n ,by making n--\\n\\t\\t//so, (ans*5) is remaining\\n        if(flag==1)\\n            ans = (ans*5)%m;\\n        return (int)ans; // required ans\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3703760,
                "title": "easy-iterative-binary-exponentiation-python-c-golang",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```python []\\nimport math\\n\\nclass Solution:\\n    MOD = int(1e9+7)\\n\\n    @staticmethod\\n    def binexp(a, b, MOD):\\n        a %= MOD\\n        res = 1\\n\\n        while b > 0:\\n            if b & 1:\\n                res = res * a % MOD\\n            a = a * a % MOD\\n            b >>= 1\\n\\n        return res\\n\\n    def countGoodNumbers(self, n: int) -> int:\\n        odds = math.floor(n/2)\\n        evens = math.ceil(n/2)\\n        return int(self.binexp(5, evens, self.MOD) * self.binexp(4, odds, self.MOD) % self.MOD)\\n```\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    static constexpr int MOD = 1e9 + 7;\\n\\n    static long long binexp(long long a, long long b, int MOD) {\\n        a %= MOD;\\n        int res = 1;\\n\\n        while (b > 0) {\\n            if (b & 1) {\\n                res = (res * 1LL * a) % MOD;\\n            }\\n            a = (a * 1LL * a) % MOD;\\n            b >>= 1;\\n        }\\n\\n        return res;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long odds = floor(n / 2.0);\\n        long long evens = ceil(n / 2.0);\\n        return (binexp(5, evens, MOD) * 1LL * binexp(4, odds, MOD)) % MOD;\\n    }\\n};\\n```\\n\\n``` Golang []\\nconst MOD = int(1e9 + 7)\\n\\nfunc binexp(a, b, MOD int) int {\\n\\ta %= MOD\\n\\tres := 1\\n\\n\\tfor b > 0 {\\n\\t\\tif b&1 == 1 {\\n\\t\\t\\tres = (res * a) % MOD\\n\\t\\t}\\n\\t\\ta = (a * a) % MOD\\n\\t\\tb >>= 1\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc countGoodNumbers(n int64) int {\\n\\todds := int(n / 2)\\n\\tevens := int((n + 1) / 2)\\n\\treturn (binexp(5, evens, MOD) * binexp(4, odds, MOD)) % MOD\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Go",
                    "Math"
                ],
                "code": "```python []\\nimport math\\n\\nclass Solution:\\n    MOD = int(1e9+7)\\n\\n    @staticmethod\\n    def binexp(a, b, MOD):\\n        a %= MOD\\n        res = 1\\n\\n        while b > 0:\\n            if b & 1:\\n                res = res * a % MOD\\n            a = a * a % MOD\\n            b >>= 1\\n\\n        return res\\n\\n    def countGoodNumbers(self, n: int) -> int:\\n        odds = math.floor(n/2)\\n        evens = math.ceil(n/2)\\n        return int(self.binexp(5, evens, self.MOD) * self.binexp(4, odds, self.MOD) % self.MOD)\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    static constexpr int MOD = 1e9 + 7;\\n\\n    static long long binexp(long long a, long long b, int MOD) {\\n        a %= MOD;\\n        int res = 1;\\n\\n        while (b > 0) {\\n            if (b & 1) {\\n                res = (res * 1LL * a) % MOD;\\n            }\\n            a = (a * 1LL * a) % MOD;\\n            b >>= 1;\\n        }\\n\\n        return res;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long odds = floor(n / 2.0);\\n        long long evens = ceil(n / 2.0);\\n        return (binexp(5, evens, MOD) * 1LL * binexp(4, odds, MOD)) % MOD;\\n    }\\n};\\n```\n``` Golang []\\nconst MOD = int(1e9 + 7)\\n\\nfunc binexp(a, b, MOD int) int {\\n\\ta %= MOD\\n\\tres := 1\\n\\n\\tfor b > 0 {\\n\\t\\tif b&1 == 1 {\\n\\t\\t\\tres = (res * a) % MOD\\n\\t\\t}\\n\\t\\ta = (a * a) % MOD\\n\\t\\tb >>= 1\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc countGoodNumbers(n int64) int {\\n\\todds := int(n / 2)\\n\\tevens := int((n + 1) / 2)\\n\\treturn (binexp(5, evens, MOD) * binexp(4, odds, MOD)) % MOD\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315465,
                "title": "easy-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long power(long long x, long long y, int mod) {\\n        if(y == 0)\\n            return 1;\\n        \\n       long long ans = power(x, y/2, mod);\\n        \\n        if(y % 2 == 0)\\n            // when y is even\\n            return (ans * ans) % mod;\\n        \\n        else\\n            // whwn y is odd\\n            return (((ans * ans) % mod) * x) % mod;\\n        \\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        // long long total=1;\\n       \\n//         // // But this apprach will give TLE for large value of n\\n//         // for(int i=0;i<n;i++){\\n//         //     if(i%2==0){\\n//         //         total*=5;\\n//         //         total=(total%mod);\\n//         //     }\\n//         //     else{\\n//         //         total*=4;\\n//         //         total=(total%mod);\\n//         //     }\\n//         // }\\n//         // return total%mod;\\n//         // return (pow(4,n/2))*pow(5,(n/2+n%2));\\n        // optimal Approach\\n        int mod = 1e9+7;\\n        long long even=(n/2)+(n%2);\\n        long long odd=(n/2);\\n        return (power(5, even, mod) * power(4, odd, mod)) % mod;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    long long power(long long x, long long y, int mod) {\\n        if(y == 0)\\n            return 1;\\n        \\n       long long ans = power(x, y/2, mod);\\n        \\n        if(y % 2 == 0)\\n            // when y is even\\n            return (ans * ans) % mod;\\n        \\n        else\\n            // whwn y is odd\\n            return (((ans * ans) % mod) * x) % mod;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1314484,
                "title": "python3-powermod-hack-3-lines",
                "content": "---\\n- ### the combinatorics part goes like this:\\n- there are ceil(n/2) even positions and floor(n/2) odd positions\\n- for each even positions the variations are (02,4,6,8). there are five variations for each even position.\\n- for each odd position the variations are (2,3,5,7). there are four variations for each odd position.\\n- thus, the total number of variations, aka the answer is 5^ceil(n/2) * 4^floor(n/2), up to the mod operation.\\n- this leads to the commented out naive solution, which is not fast enough.\\n---\\n- ### speedup\\n- there is a powermod operation that speeds the whole thing up.\\n- powermod calculates the second power mod the number, fourth power mod the number, eighth power mod the number, etc.\\n- then it converts the power into binary and simply multiply the powermod results where the power has a one bit.\\n- for example, to compute the fifth power of x mod y, first calculate x mod y, x^2 mod y, x^4 mod y.\\n- then realzing five in binary is \\'101\\' and multiply x^4 mod y with x mod y\\n- this has logarithmic time and space complexity with regards to the power\\n---\\n- ### the hack\\n- powermod is somewhat tricky to implement from scratch, especially during a contet\\n- so .. realizing the modern language of python has a implicit powermod implemented in ```pow```, why don\\'t we use that?\\n\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        \\'\\'\\'\\n        ans=1\\n        MOD=int(10**9+7)\\n        for i in range(n):\\n            if i%2==0:\\n                ans*=5\\n            else:\\n                ans*=4\\n            ans%=MOD\\n        return ans\\n        \\'\\'\\'\\n        MOD=int(10**9+7)\\n\\n        fives,fours=n//2+n%2,n//2\\n        # 5^fives*4^fours % MOD\\n        # = 5^fives % MOD * 4^fours % MOD\\n        return (pow(5,fives,MOD) * pow(4,fours,MOD)) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```pow```\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        \\'\\'\\'\\n        ans=1\\n        MOD=int(10**9+7)\\n        for i in range(n):\\n            if i%2==0:\\n                ans*=5\\n            else:\\n                ans*=4\\n            ans%=MOD\\n        return ans\\n        \\'\\'\\'\\n        MOD=int(10**9+7)\\n\\n        fives,fours=n//2+n%2,n//2\\n        # 5^fives*4^fours % MOD\\n        # = 5^fives % MOD * 4^fours % MOD\\n        return (pow(5,fives,MOD) * pow(4,fours,MOD)) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967148,
                "title": "c-solution-binary-exponentiation",
                "content": "\\n# Complexity\\n- Time complexity: $$O(logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\nlong long myPow(long long x, long long n,int mod) {\\n        if(n==0) return 1;\\n        if(n%2==0) return myPow((x*x)%mod,n/2,mod)%mod;\\n        else return x*myPow(x,n-1,mod) %mod;\\n    }\\n    long long countGoodNumbers(long long n) {\\n        int mod = 1e9+7;\\n        long long four = n/2;\\n        long long five =n/2+n%2;\\n        \\n    return (myPow(5,five,mod) * myPow(4,four,mod))%mod;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nlong long myPow(long long x, long long n,int mod) {\\n        if(n==0) return 1;\\n        if(n%2==0) return myPow((x*x)%mod,n/2,mod)%mod;\\n        else return x*myPow(x,n-1,mod) %mod;\\n    }\\n    long long countGoodNumbers(long long n) {\\n        int mod = 1e9+7;\\n        long long four = n/2;\\n        long long five =n/2+n%2;\\n        \\n    return (myPow(5,five,mod) * myPow(4,four,mod))%mod;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852544,
                "title": "100-faster-binary-exponentiation-c",
                "content": "Here we can use the concept of binary exponentiation.\\nAs 2^7==2^(0111) in binary.\\nso 2^7=(2^4)*(2^2)*(2^1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int binExpo(long long x,long long n){\\n        int ans=1;\\n        while(n){\\n            if(n&1){\\n                ans=(ans*x)%mod;\\n            }\\n            x=(x*x)%mod;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2+n%2,odd=n/2;\\n        int even_val=binExpo(5,even);\\n        int odd_val=binExpo(4,odd);\\n        return (1ll*even_val*odd_val)%mod;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int binExpo(long long x,long long n){\\n        int ans=1;\\n        while(n){\\n            if(n&1){\\n                ans=(ans*x)%mod;\\n            }\\n            x=(x*x)%mod;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2+n%2,odd=n/2;\\n        int even_val=binExpo(5,even);\\n        int odd_val=binExpo(4,odd);\\n        return (1ll*even_val*odd_val)%mod;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414791,
                "title": "c-modular-exponentiation-beats-100",
                "content": "The pattern is really simple here. It\\'s just pow(5,n/2) x pow(4,n/2) for n even and pow(5,n/2+1) x pow(4,n/2) for n odd. The question thus reduces down to how to calculate such large powers in a fast way. For that modular exponentiation technique is used.\\n````\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    long long int power(int x,long long int r){\\n        if(r==1)\\n            return x;\\n        if(!r)\\n            return 1;\\n        if(r&1){\\n            long long int R=power(x,r/2);\\n            return (R*R*x)%MOD;\\n        }\\n        else\\n        {\\n            long long int R=power(x,r/2);\\n            return (R*R)%MOD;\\n        }\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        if((n&1)==0)\\n            return (power(5,n/2) * power(4,n/2))%MOD;\\n        return (power(5,n/2+1) * power(4,n/2))%MOD;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long int power(int x,long long int r){\\n        if(r==1)\\n            return x;\\n        if(!r)\\n            return 1;\\n        if(r&1){\\n            long long int R=power(x,r/2);\\n            return (R*R*x)%MOD;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1373085,
                "title": "python3-purely-mathematical-and-play-with-and-pow",
                "content": "There are 5 even digits (which will occupy the even places) and 4 prime digits (which will occupy the odd places). Therefore the answer for every `n` is 5<sup>no. of even places</sup> * 4<sup>no. of odd places</sup>.\\n\\nUsing `**` operator utilizes O(logn) multiplications, so does the `pow()` inbuilt-function. Therefore using `**` operator or `pow(a, b)` function generates a TLE while handling bigIntegers.\\n\\nWe can optimize `pow()` function by adding a 3rd parameter to it, so that we consider only the modulo part while dealing with bigIntegers (which is also what the question demands)! So, there we have it.\\n\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        evenplaces = n // 2 if n % 2 == 0 else n // 2 + 1\\n        return (pow(5, evenplaces, 1000000007) * pow(4, n-evenplaces, 1000000007)) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        evenplaces = n // 2 if n % 2 == 0 else n // 2 + 1\\n        return (pow(5, evenplaces, 1000000007) * pow(4, n-evenplaces, 1000000007)) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250354,
                "title": "4-ms-simple-c-solution-using-modular-exponentiation-function",
                "content": "```\\n\\n# define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int countGoodNumbers(long long n) {\\n        \\n        return (modularExponentiation(4LL, n/2, mod) * modularExponentiation(5LL, n-n/2, mod)) % mod; \\n\\t\\t// you can pass 4LL or simply 4 as an argument\\n\\t\\t\\n    }\\n    \\n\\t// but here we have to use \\'long long x\\' to prevent signed integer overflow\\n    ll modularExponentiation(ll x, ll n, int mod) {\\n    if(n==0) return 1;\\n        \\n    if(n%2 == 0)        \\n        return modularExponentiation((x*x) % mod, n/2, mod);\\n    else                             \\n        return (x*modularExponentiation((x*x) % mod, (n-1)/2, mod)) % mod;\\n   }\\n    \\n};\\n// !!!!! happy coding !!!!!!\\n```",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n\\n# define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int countGoodNumbers(long long n) {\\n        \\n        return (modularExponentiation(4LL, n/2, mod) * modularExponentiation(5LL, n-n/2, mod)) % mod; \\n\\t\\t// you can pass 4LL or simply 4 as an argument\\n\\t\\t\\n    }\\n    \\n\\t// but here we have to use \\'long long x\\' to prevent signed integer overflow\\n    ll modularExponentiation(ll x, ll n, int mod) {\\n    if(n==0) return 1;\\n        \\n    if(n%2 == 0)        \\n        return modularExponentiation((x*x) % mod, n/2, mod);\\n    else                             \\n        return (x*modularExponentiation((x*x) % mod, (n-1)/2, mod)) % mod;\\n   }\\n    \\n};\\n// !!!!! happy coding !!!!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697897,
                "title": "python-without-pow-function-use-binary-approach",
                "content": "In this solution we will not use Python pow function, which Time complexity is O(log2(N)), because on interview interviewer can ask for it\\'s implementation. \\nImplement pow inside code\\n```\\nclass Solution:\\n    \\n    # Without pow function\\n    def countGoodNumbers(self, n: int) -> int:\\n        mod = 10**9 + 7\\n        ost = 1 if n % 2 == 0 else 5\\n        n = n // 2\\n        s = bin(n)[-1:1:-1]\\n        res = 1\\n        pow20 = 20\\n        for ch in s:\\n            if ch == \\'1\\':\\n                res = (res * pow20) % mod    \\n            pow20 = pow20**2 % mod\\n\\n        return (res*ost) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Without pow function\\n    def countGoodNumbers(self, n: int) -> int:\\n        mod = 10**9 + 7\\n        ost = 1 if n % 2 == 0 else 5\\n        n = n // 2\\n        s = bin(n)[-1:1:-1]\\n        res = 1\\n        pow20 = 20\\n        for ch in s:\\n            if ch == \\'1\\':\\n                res = (res * pow20) % mod    \\n            pow20 = pow20**2 % mod\\n\\n        return (res*ost) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321012,
                "title": "python-3-algorithm-explained",
                "content": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        \"\"\"\\n        Given an integer n, this program determines the count\\n        of good numbers modulo 10**9 + 7.\\n\\n        :param n: length of string\\n        :type n: int\\n        :return: count of good numbers modulo 10**9 + 7\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Algorithm:\\n        - Count of good numbers for even-indexed (0-based) digits is 5.\\n        - Count of good numbers for odd-indexed (0-based) digits is 4.\\n        - Count of good numbers for a pair of digits is 5 x 4 = 20.\\n        - For a string of length n, the count of good numbers is:\\n        \\n                20**(n // 2)        if n is even\\n                20**(n // 2) * 5    if n is odd\\n                \\n                - \\'//\\' represents integer division.\\n                - The extra factor of 5 accounts for the unpaired\\n                  even-indexed digit when n is odd.\\n        - To speed up the calculation, we take advantage of the fact\\n          that any positive integer is the sum of powers of 2. For\\n          example, if n = 50, n // 2 = 25 and is the sum of 16 + 8 + 1.\\n          The count of good numbers is 20**25, or 20 * 20**8 * 20**16.\\n        \"\"\"\\n        mod = 10**9 + 7\\n        answer = 5**(n & 1)\\n        n >>= 1\\n        even_factor = 20\\n        while n > 0:\\n            if n & 1:\\n                answer = (answer * even_factor) % mod\\n            n >>= 1\\n            even_factor = (even_factor**2) % mod\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        \"\"\"\\n        Given an integer n, this program determines the count\\n        of good numbers modulo 10**9 + 7.\\n\\n        :param n: length of string\\n        :type n: int\\n        :return: count of good numbers modulo 10**9 + 7\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Algorithm:\\n        - Count of good numbers for even-indexed (0-based) digits is 5.\\n        - Count of good numbers for odd-indexed (0-based) digits is 4.\\n        - Count of good numbers for a pair of digits is 5 x 4 = 20.\\n        - For a string of length n, the count of good numbers is:\\n        \\n                20**(n // 2)        if n is even\\n                20**(n // 2) * 5    if n is odd\\n                \\n                - \\'//\\' represents integer division.\\n                - The extra factor of 5 accounts for the unpaired\\n                  even-indexed digit when n is odd.\\n        - To speed up the calculation, we take advantage of the fact\\n          that any positive integer is the sum of powers of 2. For\\n          example, if n = 50, n // 2 = 25 and is the sum of 16 + 8 + 1.\\n          The count of good numbers is 20**25, or 20 * 20**8 * 20**16.\\n        \"\"\"\\n        mod = 10**9 + 7\\n        answer = 5**(n & 1)\\n        n >>= 1\\n        even_factor = 20\\n        while n > 0:\\n            if n & 1:\\n                answer = (answer * even_factor) % mod\\n            n >>= 1\\n            even_factor = (even_factor**2) % mod\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314493,
                "title": "c-easy-implementation-modular-arithmetic-pattern-observation",
                "content": "Approach: Given, use of only **5 even numbers** i.e., 0, 2, 4, 6, 8 and **4 prime numbers** i.e., 2, 3, 5, 7, there is a pattern involved with the powers of 4 and 5.\\nMoreover, using brute force we get a pattern like 5, 20, 100, 400, and so on...\\n\\n**Notes:** Use Modular Arithmetic\\n\\nThus, after observing the pattern carefully we get a formula:\\n```\\n#Use Modular Exponentiation since n is large\\nx = 5 ^ ((n + 1) / 2)\\ny = 4 ^ (n / 2)\\nprint x * y % MOD\\n```\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    long long power(long long x, long long y, long long p = 1000000007)\\n    {\\n        long long res = 1;\\n \\n        x = x % p;\\n  \\n        if (x == 0) return 0;\\n \\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x) % p;\\n            y = y>>1;\\n            x = (x*x) % p;\\n        }\\n        return res;\\n    }\\n    \\n    long long countGoodNumbers(long long n) {\\n        \\n        long long x = power(5, (n + 1) / 2);\\n        long long y = power(4, n / 2);\\n        long long ans = (x * y) % 1000000007;\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#Use Modular Exponentiation since n is large\\nx = 5 ^ ((n + 1) / 2)\\ny = 4 ^ (n / 2)\\nprint x * y % MOD\\n```\n```\\nclass Solution {\\npublic:\\n    long long power(long long x, long long y, long long p = 1000000007)\\n    {\\n        long long res = 1;\\n \\n        x = x % p;\\n  \\n        if (x == 0) return 0;\\n \\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x) % p;\\n            y = y>>1;\\n            x = (x*x) % p;\\n        }\\n        return res;\\n    }\\n    \\n    long long countGoodNumbers(long long n) {\\n        \\n        long long x = power(5, (n + 1) / 2);\\n        long long y = power(4, n / 2);\\n        long long ans = (x * y) % 1000000007;\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314465,
                "title": "python3-single-line",
                "content": "There are 5 even numbers between 1-10 (0,2,4,6,8) and 4 prime numbers (2,3,5,7).\\nthis means every even place can be filled in 5 ways and every odd place can be filed with 4 ways.\\nfor any n there would be (n+1)//2 even places and n//2 odd places.\\nso the code would be :\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return (pow(5,(n+1)//2,10**9+7)*pow(4,n//2,10**9+7))%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return (pow(5,(n+1)//2,10**9+7)*pow(4,n//2,10**9+7))%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314375,
                "title": "binary-exponentiation-o-logn",
                "content": "You can find the algorithm here - https://cp-algorithms.com/algebra/binary-exp.html\\nans = 5^(even places)*4^(odd places)\\n```\\nclass Solution {\\npublic:\\n    \\n    int countGoodNumbers(long long n) {\\n        int mod = 1000000007;\\n        long long int x = n/2;\\n        long long int ans = 1;\\n        long long int val = 20;\\n        while(x>0){\\n            if(x%2){\\n                ans = ((long long)ans*((long long)val%mod))%mod;\\n            }\\n            val = (((long long)val)*((long long)val))%mod;\\n            x>>=1;\\n        }\\n        if(n%2!=0){\\n            ans =(ans*(5))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countGoodNumbers(long long n) {\\n        int mod = 1000000007;\\n        long long int x = n/2;\\n        long long int ans = 1;\\n        long long int val = 20;\\n        while(x>0){\\n            if(x%2){\\n                ans = ((long long)ans*((long long)val%mod))%mod;\\n            }\\n            val = (((long long)val)*((long long)val))%mod;\\n            x>>=1;\\n        }\\n        if(n%2!=0){\\n            ans =(ans*(5))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314352,
                "title": "c-one-line-code",
                "content": "```\\ntypedef long long ll;\\nconst long long mod=1e9+7;\\nclass Solution {\\npublic:\\n    ll power(ll a, ll b) \\n    {   ll result=1;\\n    while(b)\\n    {   if(b%2) result=(result*a)%mod;\\n        a=(a*a)%mod;\\n        b/=2;\\n    }\\n    return result;\\n}\\n    int countGoodNumbers(long long n) {\\n        ll even=n/2;\\n        ll odd=n-even;\\n        ll ans=power(5,odd)*power(4,even);\\n        ans%=mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nconst long long mod=1e9+7;\\nclass Solution {\\npublic:\\n    ll power(ll a, ll b) \\n    {   ll result=1;\\n    while(b)\\n    {   if(b%2) result=(result*a)%mod;\\n        a=(a*a)%mod;\\n        b/=2;\\n    }\\n    return result;\\n}\\n    int countGoodNumbers(long long n) {\\n        ll even=n/2;\\n        ll odd=n-even;\\n        ll ans=power(5,odd)*power(4,even);\\n        ans%=mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844765,
                "title": "c-simple-12-line-code-begginers-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long power(int x,long long y,int k){\\n        if (y==0){return 1;}\\n        if (y==1){return x;}\\n        long z=power(x,y/2,k);\\n        long b=(z%k);\\n        if(y%2 !=0){return (((b*b)%k)*x)%k;\\n        }return (b*b)%k;}\\n    int countGoodNumbers(long long n) {\\n        int y=1000000007; \\n        if(n%2==0){\\n            return power(20,n/2,y) ;}\\n        else{return (power(20,n/2,y)*5)%y;}}};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long power(int x,long long y,int k){\\n        if (y==0){return 1;}\\n        if (y==1){return x;}\\n        long z=power(x,y/2,k);\\n        long b=(z%k);\\n        if(y%2 !=0){return (((b*b)%k)*x)%k;\\n        }return (b*b)%k;}\\n    int countGoodNumbers(long long n) {\\n        int y=1000000007; \\n        if(n%2==0){\\n            return power(20,n/2,y) ;}\\n        else{return (power(20,n/2,y)*5)%y;}}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768373,
                "title": "python-recursion-beats-81-running-time-44ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Spilt numbers of odd indexes and even indexes in separate variables.\\n- Using binary exponentiation to calculate the `5**even_indexes and 4**odd_indexes`\\n- Using Modulo at every multiplication to not let it overflow\\n\\n# Complexity\\n1. Time complexity: `O(log\\u2061n)`\\n- At each recursive call we reduce `n` by half, so we will make only `log n`number of calls for the `binaryExp` function, and the multiplication of two numbers is considered as a constant time operation.\\n- Thus, it will take overall `O(log\\u2061 n)` time.\\n\\n1. Space complexity: `O(log\\u2061n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The recursive stack can use at most `O(log\\u2061n)` space at any time.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        mod = 1000000007\\n        odd = n//2\\n        even = n//2 + n%2\\n        return (self.binaryExp(5, even)%mod *self.binaryExp(4, odd)%mod)%mod\\n    \\n    def binaryExp(self, x, n):\\n        mod = 1000000007\\n        if n==0:\\n            return 1\\n        if n < 0:\\n            return 1/self.binaryExp(x, -n)\\n        \\n        if n%2==0:\\n            return self.binaryExp((x*x)%mod, n//2)\\n        else:\\n            return x * self.binaryExp((x*x)%mod, (n-1)//2)\\n        \\n\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        mod = 1000000007\\n        odd = n//2\\n        even = n//2 + n%2\\n        return (self.binaryExp(5, even)%mod *self.binaryExp(4, odd)%mod)%mod\\n    \\n    def binaryExp(self, x, n):\\n        mod = 1000000007\\n        if n==0:\\n            return 1\\n        if n < 0:\\n            return 1/self.binaryExp(x, -n)\\n        \\n        if n%2==0:\\n            return self.binaryExp((x*x)%mod, n//2)\\n        else:\\n            return x * self.binaryExp((x*x)%mod, (n-1)//2)\\n        \\n\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751762,
                "title": "c-iterative-recursive-two-solutions-easy-explanation",
                "content": "# Approach - Recursive\\nThe approach uses recursive modular exponentiation to compute the power of a number efficiently with modulo operation.\\n\\nIn the power function, if the exponent y is 0, it returns 1. Otherwise, it recursively calculates res as the square of power(x, y/2), and then multiplies res by x if y is odd. Finally, it returns res modulo MOD.\\n\\nIn the countGoodNumbers function, it calculates the number of odd and even positions in the range from 1 to n. It then uses the power function to compute (5^even) % MOD and (4^odd) % MOD, and returns the product of these two values modulo MOD. This represents the count of good numbers in the given range.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity of the given code is O(log y) for the power function, where y is the exponent. This is because the power function uses a recursive approach and divides the exponent by 2 in each recursive call, resulting in a binary tree-like structure. Therefore, the number of recursive calls is proportional to the logarithm of y.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: In terms of space complexity, the code has a space complexity of O(log y) due to the recursive calls in the power function. Each recursive call requires additional space on the call stack to store the function arguments and return address. The maximum depth of the call stack is proportional to the logarithm of y, leading to a space complexity of O(log y).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// **************Recursive Modular Exponentiation*****************************\\n\\nclass Solution {\\npublic:\\n    const int MOD = 1000000007;\\n    \\n    long long int power(long long int x, long long int y){\\n        if(y==0) return 1;\\n        \\n        long long int res = power(x, y/2);\\n        res = (res * res)%MOD;\\n\\n        if(y%2==1) res = (res * x)%MOD;\\n        return res;\\n    }\\n\\n\\n    int countGoodNumbers(long long n) {        \\n        long long int odd = n/2;\\n        long long int even = n - odd;\\n\\n        return (power(5, even) * power(4, odd))%MOD;\\n    }\\n};\\n```\\n\\n# Approach - Iterative\\nThe given approach uses iterative modular exponentiation to efficiently compute the count of \"good\" numbers. It calculates the power of 5 for even positions (even) and the power of 4 for odd positions (odd) in the number sequence. The modulo operation is performed at each step to avoid overflow. Finally, it returns the product of the calculated powers, modulo 1000000007, which ensures the result is within the desired range.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity of the code is O(log n) because the power function performs exponentiation by squaring, which reduces the exponent by half in each iteration. This results in a logarithmic time complexity. The other operations in the code, such as modulo and multiplication, are constant time operations. Therefore, the dominant factor in terms of time complexity is the exponentiation process.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the given code is O(1) because it uses a fixed amount of additional memory to store variables and constants, regardless of the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// **************Iterative Modular Exponentiation*****************************\\n\\nclass Solution {\\npublic:\\n    const int MOD = 1000000007;\\n    \\n    long long int power(long long int x, long long int y){\\n        long long int res = 1;\\n        while(y){\\n            if(y%2==1) res =(res * x) % MOD;\\n            x = (x*x) % MOD;\\n            y /= 2;\\n        }\\n        return res;       \\n    }\\n\\n\\n    int countGoodNumbers(long long n) {        \\n        long long int odd = n/2;\\n        long long int even = n - odd;\\n\\n        return (power(5, even) * power(4, odd))%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// **************Recursive Modular Exponentiation*****************************\\n\\nclass Solution {\\npublic:\\n    const int MOD = 1000000007;\\n    \\n    long long int power(long long int x, long long int y){\\n        if(y==0) return 1;\\n        \\n        long long int res = power(x, y/2);\\n        res = (res * res)%MOD;\\n\\n        if(y%2==1) res = (res * x)%MOD;\\n        return res;\\n    }\\n\\n\\n    int countGoodNumbers(long long n) {        \\n        long long int odd = n/2;\\n        long long int even = n - odd;\\n\\n        return (power(5, even) * power(4, odd))%MOD;\\n    }\\n};\\n```\n```\\n// **************Iterative Modular Exponentiation*****************************\\n\\nclass Solution {\\npublic:\\n    const int MOD = 1000000007;\\n    \\n    long long int power(long long int x, long long int y){\\n        long long int res = 1;\\n        while(y){\\n            if(y%2==1) res =(res * x) % MOD;\\n            x = (x*x) % MOD;\\n            y /= 2;\\n        }\\n        return res;       \\n    }\\n\\n\\n    int countGoodNumbers(long long n) {        \\n        long long int odd = n/2;\\n        long long int even = n - odd;\\n\\n        return (power(5, even) * power(4, odd))%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716207,
                "title": "simple-code-using-recursion-and-pow-x-n-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    long long power(long long x,long long y)\\n    {\\n        if(y==0)return 1;\\n        else if(y%2==0)\\n        return power((x*x)%mod,y/2);\\n        else\\n        return (x*power(x,y-1))%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2;\\n        long long odd=n/2;\\n        if(n%2)even++;\\n        long long first=power(5,even);\\n        long long second=power(4,odd);\\n        long long ans= ((first)*(second))%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    long long power(long long x,long long y)\\n    {\\n        if(y==0)return 1;\\n        else if(y%2==0)\\n        return power((x*x)%mod,y/2);\\n        else\\n        return (x*power(x,y-1))%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2;\\n        long long odd=n/2;\\n        if(n%2)even++;\\n        long long first=power(5,even);\\n        long long second=power(4,odd);\\n        long long ans= ((first)*(second))%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640816,
                "title": "simple-c-solution-using-modular-arithmetic-with-intutuion-explianed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe know that there are 5 even digits -> {0, 2, 4, 6, 8} and 4 prime digits -> {2,3,5,7}. Hence if we find out the number of even positions in our string and the number of odd positions in our string then we can simple calculate the number of possibilites by applying the theory of combinations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApply modular exponentiation to decrease the time complexity\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(logN)$$ -> at max\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long power(long long x, long long y, long long p)\\n{\\n \\n    // Initialize answer\\n    long long res = 1;\\n \\n    // Check till the number becomes zero\\n    while (y > 0) {\\n \\n        // If y is odd, multiply x with result\\n        if (y % 2 == 1)\\n            res = (res * x)%p;\\n \\n        // y = y/2\\n        y = y >> 1;\\n \\n        // Change x to x^2\\n        x = (x * x)%p;\\n    }\\n    return res % p;\\n}\\n    int countGoodNumbers(long long n) {\\n        long long ans = 1;\\n        long long f=0,fiv  = 0;\\n        long long mod = 1000000007;\\n        if(n%2 ==0)\\n        {\\n            ans = power(20,n/2,mod);\\n        }\\n        else\\n        {\\n            long long f = n/2;\\n            // f -> number of odd positions\\n            long long fiv = n-f;\\n            // fiv -> number of even positions\\n            f = power(4,f,mod);\\n            fiv = power(5,fiv,mod);\\n            ans = (f*fiv)%mod;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long power(long long x, long long y, long long p)\\n{\\n \\n    // Initialize answer\\n    long long res = 1;\\n \\n    // Check till the number becomes zero\\n    while (y > 0) {\\n \\n        // If y is odd, multiply x with result\\n        if (y % 2 == 1)\\n            res = (res * x)%p;\\n \\n        // y = y/2\\n        y = y >> 1;\\n \\n        // Change x to x^2\\n        x = (x * x)%p;\\n    }\\n    return res % p;\\n}\\n    int countGoodNumbers(long long n) {\\n        long long ans = 1;\\n        long long f=0,fiv  = 0;\\n        long long mod = 1000000007;\\n        if(n%2 ==0)\\n        {\\n            ans = power(20,n/2,mod);\\n        }\\n        else\\n        {\\n            long long f = n/2;\\n            // f -> number of odd positions\\n            long long fiv = n-f;\\n            // fiv -> number of even positions\\n            f = power(4,f,mod);\\n            fiv = power(5,fiv,mod);\\n            ans = (f*fiv)%mod;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507431,
                "title": "simple-c-code-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long powFunction(long long x, long long n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        long long ans = powFunction(x, n/2);\\n        ans *= ans;\\n        ans %= 1000000007;\\n        if(n%2==1){\\n            ans *= x;\\n            ans %= 1000000007;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long odd = n/2;\\n        long long even = n/2 + n%2;\\n        return (powFunction(5, even) * powFunction(4, odd))%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long powFunction(long long x, long long n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        long long ans = powFunction(x, n/2);\\n        ans *= ans;\\n        ans %= 1000000007;\\n        if(n%2==1){\\n            ans *= x;\\n            ans %= 1000000007;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long odd = n/2;\\n        long long even = n/2 + n%2;\\n        return (powFunction(5, even) * powFunction(4, odd))%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306998,
                "title": "beats-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    long long pow(long long a,long long b){\\n        if(b==0)\\n            return 1;\\n        long long res=pow(a,b/2);\\n        res*=res;\\n        res%=MOD;\\n        if(b%2)\\n        res*=a;\\n        res%=MOD;\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even=n/2 + n%2;\\n        return (pow(5,even)*pow(4,odd))%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    long long pow(long long a,long long b){\\n        if(b==0)\\n            return 1;\\n        long long res=pow(a,b/2);\\n        res*=res;\\n        res%=MOD;\\n        if(b%2)\\n        res*=a;\\n        res%=MOD;\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even=n/2 + n%2;\\n        return (pow(5,even)*pow(4,odd))%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165566,
                "title": "python-solution-one-linear-easy-to-understand",
                "content": "```\\nfrom math import ceil,floor\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return (pow(5,ceil(n/2),1000_000_007) * pow(4,floor(n/2),1000_000_007))% 1000_000_007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nfrom math import ceil,floor\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return (pow(5,ceil(n/2),1000_000_007) * pow(4,floor(n/2),1000_000_007))% 1000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585224,
                "title": "100-faster-java-solution-with-explanation",
                "content": "#### Please Upvote if it helps!!\\n\\n\\n```\\nclass Solution {\\n    public int countGoodNumbers(long n) {\\n        // for n length digit there are n/2 odd indices\\n        long oddInds = n>>1;\\n        // for n length digit there are (n+1)/2 even indices\\n        long evenInds = (n+1)>>1;\\n    \\n        int mod = 1000000007;\\n        \\n        // the digits at odd indices are prime (2,3,5,7)\\n        // that mean in total 4 choices for each (n/2) places {i.e. 4^(n/2)}\\n        long oddPow = pow(4,oddInds, mod);\\n        // the digits (0-indexed) at even indices are even (0, 2, 4, 6, 8)\\n        // that mean in total 5 choices for each (n+1)/2 places {i.e. 5^((n+1)/2)}\\n        long evePow = pow(5, evenInds, mod);\\n        \\n        // overall combinations will be product of all even & odd places combinations\\n        long ans = (oddPow*evePow) %mod;\\n        return (int)ans;\\n    }\\n\\n// this method is known as binary exponentiation to get pow(a,b) in TC : O(logn)\\n    public long pow(int x, long p, int m) {\\n        if(p == 0)\\n            return 1L;\\n        \\n        long ans = pow(x, p>>1, m);\\n        \\n        if((p&1)==1)         // same as p%2 == 1\\n            return (ans * ans * x) % m;\\n        return (ans * ans) % m;   \\n    }\\n\\t\\n}\\n```\\n\\n----------------\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Count Good Numbers.\\nMemory Usage: 38.8 MB, less than 98.78% of Java online submissions for Count Good Numbers.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodNumbers(long n) {\\n        // for n length digit there are n/2 odd indices\\n        long oddInds = n>>1;\\n        // for n length digit there are (n+1)/2 even indices\\n        long evenInds = (n+1)>>1;\\n    \\n        int mod = 1000000007;\\n        \\n        // the digits at odd indices are prime (2,3,5,7)\\n        // that mean in total 4 choices for each (n/2) places {i.e. 4^(n/2)}\\n        long oddPow = pow(4,oddInds, mod);\\n        // the digits (0-indexed) at even indices are even (0, 2, 4, 6, 8)\\n        // that mean in total 5 choices for each (n+1)/2 places {i.e. 5^((n+1)/2)}\\n        long evePow = pow(5, evenInds, mod);\\n        \\n        // overall combinations will be product of all even & odd places combinations\\n        long ans = (oddPow*evePow) %mod;\\n        return (int)ans;\\n    }\\n\\n// this method is known as binary exponentiation to get pow(a,b) in TC : O(logn)\\n    public long pow(int x, long p, int m) {\\n        if(p == 0)\\n            return 1L;\\n        \\n        long ans = pow(x, p>>1, m);\\n        \\n        if((p&1)==1)         // same as p%2 == 1\\n            return (ans * ans * x) % m;\\n        return (ans * ans) % m;   \\n    }\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406051,
                "title": "c-solution-simple-power-finding-logic-recursive-approach",
                "content": "```\\n// If it help plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    long long Power(long long n,long long pow){\\n        // base case\\n        long long mod = 1e9 + 7;\\n        if(pow == 0){\\n            return 1;\\n        }\\n        \\n        if(pow == 1){\\n            return n;\\n        }\\n        \\n        long long halfAnswer = Power(n,pow/2) % mod;\\n        \\n        if(pow & 1){\\n            return (halfAnswer * halfAnswer * n) % mod;\\n        }\\n        \\n        return (halfAnswer * halfAnswer) % mod;\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long int ePow;\\n        long long int oPow;\\n        long long mod = 1e9 + 7;\\n        oPow = n / 2;\\n        \\n        // Finding power\\n        if(n & 1){\\n            ePow = (n / 2) + 1;\\n        }\\n        else{\\n            ePow = n / 2;\\n        }\\n        \\n        return (Power(5,ePow) *1LL* Power(4,oPow)) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n// If it help plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    long long Power(long long n,long long pow){\\n        // base case\\n        long long mod = 1e9 + 7;\\n        if(pow == 0){\\n            return 1;\\n        }\\n        \\n        if(pow == 1){\\n            return n;\\n        }\\n        \\n        long long halfAnswer = Power(n,pow/2) % mod;\\n        \\n        if(pow & 1){\\n            return (halfAnswer * halfAnswer * n) % mod;\\n        }\\n        \\n        return (halfAnswer * halfAnswer) % mod;\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long int ePow;\\n        long long int oPow;\\n        long long mod = 1e9 + 7;\\n        oPow = n / 2;\\n        \\n        // Finding power\\n        if(n & 1){\\n            ePow = (n / 2) + 1;\\n        }\\n        else{\\n            ePow = n / 2;\\n        }\\n        \\n        return (Power(5,ePow) *1LL* Power(4,oPow)) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566351,
                "title": "easy-c-explanation-number-theory",
                "content": "```\\neven numbers from 0-9 -> 0,2,4,6,8\\nprime numbers from 0-9-> 2,3,5,7\\n\\nfor 6:->\\n_ _ _ _ _ _\\n5 4 5 4 5 4\\n\\n1 -> 5\\n2 -> 5 * 2\\xB2\\n3 -> 5\\xB2 * 2\\xB2\\n4 -> 5\\xB2 * 2\\u2074\\n.\\n.\\n.\\nx => {\\n    even -> 5\\u02E3/\\xB2 * 2\\u02E3 => (10)\\u02E3/\\xB2 * 2\\u02E3/\\xB2\\n    odd -> 5\\u207D\\u02E3\\u207A\\xB9\\u207E/\\xB2 * 2\\u207D\\u02E3\\u207B\\xB9\\u207E => 5 * (10)\\u207D\\u02E3\\u207B\\xB9\\u207E/\\xB2 * 2\\u207D\\u02E3\\u207B\\xB9\\u207E/\\xB2\\n}\\n```\\n\\n\\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n\\t// Modular Exponentiation power function\\n    long power(long long x, long long y)\\n    {\\n        long res = 1;\\n\\n        x = x%MOD;\\n\\n        if (x == 0) return 0;\\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x)%MOD;\\n            y = y>>1;\\n            x = (x*x)%MOD;\\n        }\\n        return res%MOD;\\n    }\\n \\n    \\n    int countGoodNumbers(long long n) {\\n        if(n%2 == 0){\\n            long long d = n/2;\\n            return (power(10,d)%MOD * power(2,d)%MOD)%MOD;\\n        }\\n        else{\\n            long long d = (n-1)/2;\\n            return ((5*(power(10,d)%MOD)%MOD * power(2,d)%MOD)%MOD)%MOD;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\neven numbers from 0-9 -> 0,2,4,6,8\\nprime numbers from 0-9-> 2,3,5,7\\n\\nfor 6:->\\n_ _ _ _ _ _\\n5 4 5 4 5 4\\n\\n1 -> 5\\n2 -> 5 * 2\\xB2\\n3 -> 5\\xB2 * 2\\xB2\\n4 -> 5\\xB2 * 2\\u2074\\n.\\n.\\n.\\nx => {\\n    even -> 5\\u02E3/\\xB2 * 2\\u02E3 => (10)\\u02E3/\\xB2 * 2\\u02E3/\\xB2\\n    odd -> 5\\u207D\\u02E3\\u207A\\xB9\\u207E/\\xB2 * 2\\u207D\\u02E3\\u207B\\xB9\\u207E => 5 * (10)\\u207D\\u02E3\\u207B\\xB9\\u207E/\\xB2 * 2\\u207D\\u02E3\\u207B\\xB9\\u207E/\\xB2\\n}\\n```\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n\\t// Modular Exponentiation power function\\n    long power(long long x, long long y)\\n    {\\n        long res = 1;\\n\\n        x = x%MOD;\\n\\n        if (x == 0) return 0;\\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x)%MOD;\\n            y = y>>1;\\n            x = (x*x)%MOD;\\n        }\\n        return res%MOD;\\n    }\\n \\n    \\n    int countGoodNumbers(long long n) {\\n        if(n%2 == 0){\\n            long long d = n/2;\\n            return (power(10,d)%MOD * power(2,d)%MOD)%MOD;\\n        }\\n        else{\\n            long long d = (n-1)/2;\\n            return ((5*(power(10,d)%MOD)%MOD * power(2,d)%MOD)%MOD)%MOD;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323268,
                "title": "java-clean-solution-with-leetcode-50-mypow",
                "content": "As a reference: \\n* [50. Pow(x, n)](https://leetcode.com/problems/powx-n/)\\n```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        // even : 5 choices  ==>  5 ^ numE  where numE = (n + 1) / 2\\n        // odd  : 4 choices  ==>  4 ^ numO  where numO =  n / 2\\n        long resE = myPow(5L, (n + 1) / 2);\\n        long resO = myPow(4L, n / 2);\\n        \\n        return (int)(resE * resO % MOD);\\n    }\\n    \\n    private long myPow(long x, long n) {\\n        long res = 1L;\\n        while (n > 0) {\\n            if (n % 2 != 0) res = res * x % MOD;\\n            n /= 2;\\n            x = x * x % MOD;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        // even : 5 choices  ==>  5 ^ numE  where numE = (n + 1) / 2\\n        // odd  : 4 choices  ==>  4 ^ numO  where numO =  n / 2\\n        long resE = myPow(5L, (n + 1) / 2);\\n        long resO = myPow(4L, n / 2);\\n        \\n        return (int)(resE * resO % MOD);\\n    }\\n    \\n    private long myPow(long x, long n) {\\n        long res = 1L;\\n        while (n > 0) {\\n            if (n % 2 != 0) res = res * x % MOD;\\n            n /= 2;\\n            x = x * x % MOD;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314721,
                "title": "observation-and-explanation-simple-math-java-c",
                "content": "**Observation**\\nWe can imagine this question as one of those permuation and combination questions (which we used to do in 11th class maths)\\nwe can imagine some empty spaces (here, n empty spaces) and we have to put that how many ways are there to fill that empty gap.\\n\\n**Explanation**\\n*At even indices there can be 5 values(0,2,4,6,8)\\nAnd At odd indices there can 4 values(2,3,5,7)\\nSo we notice that there are 5 values which can be in even indices and 4 in odd indices.*\\n\\nSo that is How we calculatedd our answer\\n\\n*Total number of good digit strings would be  (5 ^ even indices) * (4 ^ odd indices)....We also need to return  % 10^9 + 7.\\nBut the other problem is the constraints which is way too big. So we need to calculate (5 ^ even indices) and  (4 ^ odd indices) in log(n) time, which is done by power function.*\\n\\n**Java**\\n```\\nclass Solution {\\n    int mod = (int)(1e9 + 7);\\n    public long power(int a, long b) {\\n        if (b == 0) return 1;\\n        long ans = power(a, b / 2);\\n        if (b % 2 == 0) {\\n            return (ans * ans) % mod;\\n        } else {\\n            return (((ans * ans) % mod) * a) % mod;\\n        }\\n    }\\n    public int countGoodNumbers(long n) {\\n        return (int)((power(5, (n + 1) / 2) * power(4, n / 2)) % mod);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long power(int a, long long b, int mod) {\\n        if (b == 0) return 1;\\n        long long ans = power(a, b / 2, mod);\\n        if (b % 2 == 0) {\\n            return (ans * ans) % mod;\\n        } else {\\n            return (((ans * ans) % mod) * a) % mod;\\n        }\\n    }\\n    int countGoodNumbers(long long n) {\\n        int mod = 1e9 + 7;\\n        return (power(5, (n + 1) / 2, mod) * power(4, n / 2, mod)) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)(1e9 + 7);\\n    public long power(int a, long b) {\\n        if (b == 0) return 1;\\n        long ans = power(a, b / 2);\\n        if (b % 2 == 0) {\\n            return (ans * ans) % mod;\\n        } else {\\n            return (((ans * ans) % mod) * a) % mod;\\n        }\\n    }\\n    public int countGoodNumbers(long n) {\\n        return (int)((power(5, (n + 1) / 2) * power(4, n / 2)) % mod);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long power(int a, long long b, int mod) {\\n        if (b == 0) return 1;\\n        long long ans = power(a, b / 2, mod);\\n        if (b % 2 == 0) {\\n            return (ans * ans) % mod;\\n        } else {\\n            return (((ans * ans) % mod) * a) % mod;\\n        }\\n    }\\n    int countGoodNumbers(long long n) {\\n        int mod = 1e9 + 7;\\n        return (power(5, (n + 1) / 2, mod) * power(4, n / 2, mod)) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314630,
                "title": "c-100-faster-0-ms-detailed-explanation-modpow-template-devide-conquer",
                "content": "**here for even place we have 5 options => \\'0\\' , \\'2\\', \\'4\\' , \\'6\\', \\'8\\'\\nhere for odd place we have 4 options => \\'2\\', \\'3\\' , \\'5\\', \\'7\\'**\\n\\n**so if n = even \\nthen ans = pow(5,(n/2)) * pow(4,(n/2))**\\n\\n**else if n = odd \\nthen ans = 5 * pow(5,((n-1)/2)) * pow(4,((n-1)/2))**\\nhere n-1 is even so for calculate ans for that and multiplies it with 5 as it will be on even position\\n\\n**and yes don\\'t forgot to do modulo with 10^9 + 7 of all in each step of multiplication**\\n\\n*If find solution Helpful Please Upvote it* **:)**\\n\\n```\\nclass Solution {\\npublic:\\n\\tint M = 1000000007;\\n\\t\\n\\t//you can add this template to your cp template file also\\n\\ttemplate <typename T>\\n\\tT modpow(T base, T exp) {\\n\\t\\tbase %= M;\\n\\t\\tT result = 1;\\n\\t\\twhile (exp > 0) {\\n\\t\\t\\tif (exp & 1) result = (result * base) % M;\\n\\t\\t\\tbase = (base * base) % M;\\n\\t\\t\\texp >>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tint countGoodNumbers(long long n) {\\n\\t\\tlong long int ans = 1;\\n\\t\\tif (n % 2 == 1)\\n\\t\\t{\\n\\t\\t\\tans = ((modpow(4ll, (n - 1) / 2) % M) * (modpow(5ll, (n - 1) / 2) % M)) % M;\\n\\t\\t\\tans = (ans * 5) % M;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tans = ((modpow(4ll, (n / 2)) % M) * (modpow(5ll, (n / 2)) % M)) % M;\\n\\t\\t}\\n\\t\\treturn ans % M;\\n\\t}\\n};\\n```\\n\\n**don\\'t want to use template ?**\\n**then simply make function for that also**\\n```\\nclass Solution {\\npublic:\\n\\tint M = 1000000007;\\n\\t\\n\\tint countGoodNumbers(long long n) {\\n\\t\\tlong long int ans = 1;\\n\\t\\tif (n % 2 == 1)\\n\\t\\t{\\n\\t\\t\\tans = ((modpow(4, (n - 1) / 2) % M) * (modpow(5, (n - 1) / 2) % M)) % M;\\n\\t\\t\\tans = (ans * 5) % M;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tans = ((modpow(4, (n / 2)) % M) * (modpow(5, (n / 2)) % M)) % M;\\n\\t\\t}\\n\\t\\treturn ans % M;\\n\\t}\\n\\t\\n\\tlong long int modpow(long long int base, long long int exp) {\\n\\t\\tbase %= M;\\n\\t\\tlong long int result = 1;\\n\\t\\twhile (exp > 0) {\\n\\t\\t\\tif (exp & 1) result = (result * base) % M;\\n\\t\\t\\tbase = (base * base) % M;\\n\\t\\t\\texp >>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```\\n\\n**Full Optimised Solution**\\n**Here we count 4^(n/2) * 5^(n/2) == 20^(n/2)\\nso we simply count 20^(n/2) and if n==even then multiply it by 5 again**\\n```\\nclass Solution {\\npublic:\\n\\tint M = 1000000007;\\n\\n\\tint countGoodNumbers(long long n) {\\n\\t\\tlong long int ans = modpow(20ll, (n / 2)) % M;\\n\\t\\tif (n % 2 == 1)\\n\\t\\t{\\n\\t\\t\\tans = (ans * 5) % M;\\n\\t\\t}\\n\\t\\treturn ans % M;\\n\\t}\\n    \\n\\tlong long int modpow(long long int base, long long int exp) {\\n\\t\\tbase %= M;\\n\\t\\tlong long int result = 1;\\n\\t\\twhile (exp > 0) \\n        {\\n\\t\\t\\tif (exp & 1) result = (result * base) % M;\\n\\t\\t\\tbase = (base * base) % M;\\n\\t\\t\\texp >>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```\\n\\n*If find solution Helpful Please Upvote it* **Thank You :)**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint M = 1000000007;\\n\\t\\n\\t//you can add this template to your cp template file also\\n\\ttemplate <typename T>\\n\\tT modpow(T base, T exp) {\\n\\t\\tbase %= M;\\n\\t\\tT result = 1;\\n\\t\\twhile (exp > 0) {\\n\\t\\t\\tif (exp & 1) result = (result * base) % M;\\n\\t\\t\\tbase = (base * base) % M;\\n\\t\\t\\texp >>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tint countGoodNumbers(long long n) {\\n\\t\\tlong long int ans = 1;\\n\\t\\tif (n % 2 == 1)\\n\\t\\t{\\n\\t\\t\\tans = ((modpow(4ll, (n - 1) / 2) % M) * (modpow(5ll, (n - 1) / 2) % M)) % M;\\n\\t\\t\\tans = (ans * 5) % M;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tans = ((modpow(4ll, (n / 2)) % M) * (modpow(5ll, (n / 2)) % M)) % M;\\n\\t\\t}\\n\\t\\treturn ans % M;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint M = 1000000007;\\n\\t\\n\\tint countGoodNumbers(long long n) {\\n\\t\\tlong long int ans = 1;\\n\\t\\tif (n % 2 == 1)\\n\\t\\t{\\n\\t\\t\\tans = ((modpow(4, (n - 1) / 2) % M) * (modpow(5, (n - 1) / 2) % M)) % M;\\n\\t\\t\\tans = (ans * 5) % M;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tans = ((modpow(4, (n / 2)) % M) * (modpow(5, (n / 2)) % M)) % M;\\n\\t\\t}\\n\\t\\treturn ans % M;\\n\\t}\\n\\t\\n\\tlong long int modpow(long long int base, long long int exp) {\\n\\t\\tbase %= M;\\n\\t\\tlong long int result = 1;\\n\\t\\twhile (exp > 0) {\\n\\t\\t\\tif (exp & 1) result = (result * base) % M;\\n\\t\\t\\tbase = (base * base) % M;\\n\\t\\t\\texp >>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint M = 1000000007;\\n\\n\\tint countGoodNumbers(long long n) {\\n\\t\\tlong long int ans = modpow(20ll, (n / 2)) % M;\\n\\t\\tif (n % 2 == 1)\\n\\t\\t{\\n\\t\\t\\tans = (ans * 5) % M;\\n\\t\\t}\\n\\t\\treturn ans % M;\\n\\t}\\n    \\n\\tlong long int modpow(long long int base, long long int exp) {\\n\\t\\tbase %= M;\\n\\t\\tlong long int result = 1;\\n\\t\\twhile (exp > 0) \\n        {\\n\\t\\t\\tif (exp & 1) result = (result * base) % M;\\n\\t\\t\\tbase = (base * base) % M;\\n\\t\\t\\texp >>= 1;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314573,
                "title": "c-o-log-n-power-mod",
                "content": "```csharp\\npublic int CountGoodNumbers(long n)\\n{\\n\\t// event count = 5:  0,2,4,6,8\\n\\t// odd count =  4: 2,3,5,7\\n\\tlong MOD = (long)(1E9) + 7L;\\n\\tint evenCount = 5, oddCount = 4;\\n\\tlong evens = (n + 1) / 2;\\n\\tlong odds = n - evens;\\n\\tlong result = 0;\\n\\n\\tchecked\\n\\t{                                \\n\\t\\tlong first = MODPower(evenCount, evens, MOD);\\n\\t\\tlong second = MODPower(oddCount, odds, MOD);\\n\\t\\tresult = (first * second) % MOD;\\n\\t}\\n\\n\\treturn (int)result;\\n}\\n\\nprivate long MODPower(long baseNum, long exponent, long MOD)\\n{\\n\\tlong result = 1;\\n\\n\\twhile (exponent > 0)\\n\\t{\\n\\t\\tif ((exponent & 1) == 1)\\n\\t\\t{\\n\\t\\t\\tresult = (result * baseNum) % MOD;\\n\\t\\t}\\n\\n\\t\\texponent >>= 1;\\n\\t\\tbaseNum = (baseNum * baseNum) % MOD;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int CountGoodNumbers(long n)\\n{\\n\\t// event count = 5:  0,2,4,6,8\\n\\t// odd count =  4: 2,3,5,7\\n\\tlong MOD = (long)(1E9) + 7L;\\n\\tint evenCount = 5, oddCount = 4;\\n\\tlong evens = (n + 1) / 2;\\n\\tlong odds = n - evens;\\n\\tlong result = 0;\\n\\n\\tchecked\\n\\t{                                \\n\\t\\tlong first = MODPower(evenCount, evens, MOD);\\n\\t\\tlong second = MODPower(oddCount, odds, MOD);\\n\\t\\tresult = (first * second) % MOD;\\n\\t}\\n\\n\\treturn (int)result;\\n}\\n\\nprivate long MODPower(long baseNum, long exponent, long MOD)\\n{\\n\\tlong result = 1;\\n\\n\\twhile (exponent > 0)\\n\\t{\\n\\t\\tif ((exponent & 1) == 1)\\n\\t\\t{\\n\\t\\t\\tresult = (result * baseNum) % MOD;\\n\\t\\t}\\n\\n\\t\\texponent >>= 1;\\n\\t\\tbaseNum = (baseNum * baseNum) % MOD;\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314377,
                "title": "python3-1-line",
                "content": "\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return pow(5, (n+1)//2, 1_000_000_007) * pow(4, n//2, 1_000_000_007) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return pow(5, (n+1)//2, 1_000_000_007) * pow(4, n//2, 1_000_000_007) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314350,
                "title": "java-fast-power",
                "content": "https://leetcode.com/problems/powx-n/\\nJust like Leetcode 50.\\nE.g 2^5 = 2^(2^0 + 2^2); here power is 5, mask = 1, 1&5 = 001 && 101 != 0 therefore we need to multiply 2^0, then mask = mask * 2 = 10, 010 & 101 == 0, we do not need to multiply mask this time, and finally mask = 100 or 4, mask & power = 100 & 101 != 0, therefore we need to multiply mask this time, so this process is what we call fast power, where we break the power to binary number, and use mask & power to check whether we should multiply to the answer.\\n```\\npublic int countGoodNumbers(long n) {\\n        final int MOD = 1000_000_007;\\n        long ans = 1;\\n        long powerEven = (n+1)/2;\\n        long powerOdd = n - powerEven;\\n        ans = (fastPower(5,powerEven) % MOD) * (fastPower(4,powerOdd)% MOD);\\n        return (int) (ans % MOD);\\n    }\\n    private long fastPower(long x, long power){\\n        long ans = 1;\\n        long mask = 1;\\n        while(mask <= power){\\n            if((power & mask) != 0){\\n                ans *= x;\\n                ans = ans % 1000_000_007;\\n            }\\n            mask = mask*2;\\n            x = x*x % 1000_000_007;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countGoodNumbers(long n) {\\n        final int MOD = 1000_000_007;\\n        long ans = 1;\\n        long powerEven = (n+1)/2;\\n        long powerOdd = n - powerEven;\\n        ans = (fastPower(5,powerEven) % MOD) * (fastPower(4,powerOdd)% MOD);\\n        return (int) (ans % MOD);\\n    }\\n    private long fastPower(long x, long power){\\n        long ans = 1;\\n        long mask = 1;\\n        while(mask <= power){\\n            if((power & mask) != 0){\\n                ans *= x;\\n                ans = ans % 1000_000_007;\\n            }\\n            mask = mask*2;\\n            x = x*x % 1000_000_007;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913980,
                "title": "easy-c-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long power(long long n,long long t){\\n        if(t == 0){\\n            return 1;\\n        }\\n        if(t % 2 == 0){\\n            long long key=power(n,t/2)%1000000007;\\n            return (key%1000000007)*(key%1000000007);\\n        }\\n        long long key=power(n,t-1)%1000000007;\\n        return (key*n)%1000000007;\\n    }\\n    long long countGoodNumbers(long long n) {\\n        long long even=5;\\n        long long prime=4;\\n        if(n % 2 == 0){\\n            long long e=n/2;\\n            return (power(5,e)%1000000007)*(power(4,e)%1000000007)%1000000007;\\n        }\\n        long long e=n/2;\\n        return (power(5,e+1)%1000000007)*(power(4,e)%1000000007)%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long power(long long n,long long t){\\n        if(t == 0){\\n            return 1;\\n        }\\n        if(t % 2 == 0){\\n            long long key=power(n,t/2)%1000000007;\\n            return (key%1000000007)*(key%1000000007);\\n        }\\n        long long key=power(n,t-1)%1000000007;\\n        return (key*n)%1000000007;\\n    }\\n    long long countGoodNumbers(long long n) {\\n        long long even=5;\\n        long long prime=4;\\n        if(n % 2 == 0){\\n            long long e=n/2;\\n            return (power(5,e)%1000000007)*(power(4,e)%1000000007)%1000000007;\\n        }\\n        long long e=n/2;\\n        return (power(5,e+1)%1000000007)*(power(4,e)%1000000007)%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788394,
                "title": "easy-to-understand-code-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return (pow(5,(n + 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return (pow(5,(n + 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649142,
                "title": "iterative-c-beats-100-clean-code",
                "content": "# Intuition\\nFor Better understanding refer below link: \\nhttps://cp-algorithms.com/algebra/binary-exp.html#algorithm\\nThis website is so useful...\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long powfunc(long long a, long long b, long long m)\\n    {\\n        long long res = 1;\\n        while (b > 0) \\n        {\\n            if (b & 1)  // or (b%2 != 0) ie odd position\\n            {\\n                res = res * a % m;\\n            }\\n            a = a * a % m;\\n            b = b/2;\\n        }\\n        return res;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n\\n       long long mod = 1000000007;\\n       long long odd = n/2 ;  // positions of 4\\n       long long even = n-odd; //positions of 5 \\n       long long MUL_odd = powfunc(4,odd,mod) ; // product of odd positions\\n       long long MUL_even= powfunc(5,even,mod); // product of even positions\\n\\n       return (MUL_odd * MUL_even) % mod  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long powfunc(long long a, long long b, long long m)\\n    {\\n        long long res = 1;\\n        while (b > 0) \\n        {\\n            if (b & 1)  // or (b%2 != 0) ie odd position\\n            {\\n                res = res * a % m;\\n            }\\n            a = a * a % m;\\n            b = b/2;\\n        }\\n        return res;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n\\n       long long mod = 1000000007;\\n       long long odd = n/2 ;  // positions of 4\\n       long long even = n-odd; //positions of 5 \\n       long long MUL_odd = powfunc(4,odd,mod) ; // product of odd positions\\n       long long MUL_even= powfunc(5,even,mod); // product of even positions\\n\\n       return (MUL_odd * MUL_even) % mod  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604936,
                "title": "modular-arithmetic",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    long long mod(long long x,long long m){\\n        return ((x % m + m) % m);\\n    }\\n    long long add(long long a,long long b,long long m){\\n        return mod(mod(a,m) + mod(b,m), m);\\n    }\\n    long long mul(long long a,long long b,long long m){\\n        return mod(mod(a,m) * mod(b,m), m);\\n    }\\n    long long binary_mul(long long a,long long b,long long m){\\n        long long ans = 0;\\n        while(b){\\n            if(b&1) ans = add(ans,a,m);\\n            a = add(a,a,m);\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    long long binary_exp(long long a,long long b,long long m){\\n        a %= m;\\n        long long ans = 1;\\n        while(b){\\n            if(b&1) ans = binary_mul(ans,a,m);\\n            a = binary_mul(a,a,m);\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        const int M = 1e9+7;\\n        long long even = (n>>1) + ((n&1) == 1 ? 1 : 0);\\n        long long odd = n>>1;\\n        return mul(binary_exp(5,even,M),binary_exp(4,odd,M),M);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long mod(long long x,long long m){\\n        return ((x % m + m) % m);\\n    }\\n    long long add(long long a,long long b,long long m){\\n        return mod(mod(a,m) + mod(b,m), m);\\n    }\\n    long long mul(long long a,long long b,long long m){\\n        return mod(mod(a,m) * mod(b,m), m);\\n    }\\n    long long binary_mul(long long a,long long b,long long m){\\n        long long ans = 0;\\n        while(b){\\n            if(b&1) ans = add(ans,a,m);\\n            a = add(a,a,m);\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    long long binary_exp(long long a,long long b,long long m){\\n        a %= m;\\n        long long ans = 1;\\n        while(b){\\n            if(b&1) ans = binary_mul(ans,a,m);\\n            a = binary_mul(a,a,m);\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        const int M = 1e9+7;\\n        long long even = (n>>1) + ((n&1) == 1 ? 1 : 0);\\n        long long odd = n>>1;\\n        return mul(binary_exp(5,even,M),binary_exp(4,odd,M),M);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375941,
                "title": "1922-count-good-numbers-java",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public long pow(int x,long y)\\n    {\\n        if(y==0)\\n            return 1;\\n        long ans=pow(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2==1)\\n            ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n    public int countGoodNumbers(long n) {\\n        long odd=n/2,even=(n+1)/2;\\n        long ans=   (pow(5,even)*pow(4,odd))%mod;\\n        return (int)ans;\\n    }\\n}   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public long pow(int x,long y)\\n    {\\n        if(y==0)\\n            return 1;\\n        long ans=pow(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2==1)\\n            ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n    public int countGoodNumbers(long n) {\\n        long odd=n/2,even=(n+1)/2;\\n        long ans=   (pow(5,even)*pow(4,odd))%mod;\\n        return (int)ans;\\n    }\\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149116,
                "title": "java-recursion-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O)(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(logn)\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public long power(long x, long y){\\n        if(y==0){\\n            return 1;\\n        }\\n        long  ans = power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2!=0){\\n            ans*=x;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n    public int countGoodNumbers(long n) {\\n        long odd = n/2;\\n        long even = n/2+n%2;\\n        long res = (power(4, odd)*power(5,even))%mod;\\n        return (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public long power(long x, long y){\\n        if(y==0){\\n            return 1;\\n        }\\n        long  ans = power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2!=0){\\n            ans*=x;\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n    public int countGoodNumbers(long n) {\\n        long odd = n/2;\\n        long even = n/2+n%2;\\n        long res = (power(4, odd)*power(5,even))%mod;\\n        return (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015004,
                "title": "python-tle-to-ac",
                "content": "* Recursion with Optimized Pow \\n\\n\\tMain Formula to Claculate Good  Nubmbers :   (4 * 5) ^ (n / 2); if odd, (4 * 5) ^ (n / 2) * 5.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\n\\t\\tMOD = 1000000007\\n\\t\\t#(4 * 5) ^ (n / 2); if odd, (4 * 5) ^ (n / 2) * 5.\\n\\t\\tdef power(self, m , n):\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tret = self.power(m*m,n//2) % self.MOD\\n\\t\\t\\tif n%2 == 0:\\n\\t\\t\\t\\treturn ret\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn (m*ret) % self.MOD\\n\\t\\t\\t\\t\\n    def countGoodNumbers(self, n: int) -> int:\\n        even_digits = [0,2,4,6,8]\\n        prime_digits = [2,3,5,7]\\n        \\n        ret = self.power((4*5),n//2)%self.MOD\\n        if n%2 != 0:\\n            return (5*ret) % self.MOD\\n        else:\\n            return ret\\t\\t\\n\\'\\'\\'\\n\\n* More Optimization to Fix TLE Pow\\n\\n\\tmain reason of TLE with above Power Method is that we were using big numbers to call power recursively on m*m \\nand just by covertint it to m and then using that half power to multiply itself and get total power value. \\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tMOD = 1000000007\\n\\t\\n\\t\\tdef power(self, m , n):\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tret = self.power(m,n//2) % self.MOD\\n\\t\\t\\tif n%2 == 0:\\n\\t\\t\\t\\treturn (ret*ret)%self.MOD\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn (((ret*ret)%self.MOD)*m) % self.MOD\\n        \\n\\t\\tdef countGoodNumbers(self, n: int) -> int:\\n\\t\\t\\teven_digits = [0,2,4,6,8]\\n\\t\\t\\tprime_digits = [2,3,5,7]\\n\\n\\t\\t\\tret = self.power((4*5),n//2)%self.MOD\\n\\t\\t\\tif n%2 != 0:\\n\\t\\t\\t\\treturn (5*ret) % self.MOD\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn ret\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "* Recursion with Optimized Pow \\n\\n\\tMain Formula to Claculate Good  Nubmbers :   (4 * 5) ^ (n / 2); if odd, (4 * 5) ^ (n / 2) * 5.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\n\\t\\tMOD = 1000000007\\n\\t\\t#(4 * 5) ^ (n / 2); if odd, (4 * 5) ^ (n / 2) * 5.\\n\\t\\tdef power(self, m , n):\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tret = self.power(m*m,n//2) % self.MOD\\n\\t\\t\\tif n%2 == 0:\\n\\t\\t\\t\\treturn ret\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn (m*ret) % self.MOD\\n\\t\\t\\t\\t\\n    def countGoodNumbers(self, n: int) -> int:\\n        even_digits = [0,2,4,6,8]\\n        prime_digits = [2,3,5,7]\\n        \\n        ret = self.power((4*5),n//2)%self.MOD\\n        if n%2 != 0:\\n            return (5*ret) % self.MOD\\n        else:\\n            return ret\\t\\t\\n\\'\\'\\'\\n\\n* More Optimization to Fix TLE Pow\\n\\n\\tmain reason of TLE with above Power Method is that we were using big numbers to call power recursively on m*m \\nand just by covertint it to m and then using that half power to multiply itself and get total power value. \\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tMOD = 1000000007\\n\\t\\n\\t\\tdef power(self, m , n):\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tret = self.power(m,n//2) % self.MOD\\n\\t\\t\\tif n%2 == 0:\\n\\t\\t\\t\\treturn (ret*ret)%self.MOD\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn (((ret*ret)%self.MOD)*m) % self.MOD\\n        \\n\\t\\tdef countGoodNumbers(self, n: int) -> int:\\n\\t\\t\\teven_digits = [0,2,4,6,8]\\n\\t\\t\\tprime_digits = [2,3,5,7]\\n\\n\\t\\t\\tret = self.power((4*5),n//2)%self.MOD\\n\\t\\t\\tif n%2 != 0:\\n\\t\\t\\t\\treturn (5*ret) % self.MOD\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn ret\\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 2974782,
                "title": "fast-multiplication-with-modulo",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long int fastm(int val,long long int n)\\n    {\\n        if(n<=0)\\n            return 1;\\n        if(n==1)\\n            return val;\\n        long long int res1 = (fastm(val,n/2))%mod;\\n        res1 = (((res1)%mod)*((res1)%mod))%mod;\\n        \\n        if(n%2)\\n        {\\n            res1 = ((res1%mod)* (val%mod))%mod;\\n        }\\n        \\n        return res1;\\n        \\n    }\\n    int countGoodNumbers(long long n) {\\n        long long int res=1,res2;\\n        res *= ((fastm(5,(n+1)/2))%mod)%mod;\\n        res2 = ((res%mod)*(fastm(4,n/2))%mod)%mod;\\n        return int(res2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    long long int fastm(int val,long long int n)\\n    {\\n        if(n<=0)\\n            return 1;\\n        if(n==1)\\n            return val;\\n        long long int res1 = (fastm(val,n/2))%mod;\\n        res1 = (((res1)%mod)*((res1)%mod))%mod;\\n        \\n        if(n%2)\\n        {\\n            res1 = ((res1%mod)* (val%mod))%mod;\\n        }\\n        \\n        return res1;\\n        \\n    }\\n    int countGoodNumbers(long long n) {\\n        long long int res=1,res2;\\n        res *= ((fastm(5,(n+1)/2))%mod)%mod;\\n        res2 = ((res%mod)*(fastm(4,n/2))%mod)%mod;\\n        return int(res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933569,
                "title": "java-simple-and-easy-explaination",
                "content": "\\n    public int countGoodNumbers(long N) {\\n        int mod = (int)Math.pow(10,9)+7;\\n        long even = 0 ;\\n        long prime =0 ;\\n\\t\\t\\n\\t\\t// Possible even and odd indices depending upon length \\n        if(N%2==0){\\n            even = N/2 ; prime = N/2; \\n        }else{\\n            even =(N+1)/2 ; prime = N-even;\\n        }\\n        // we know that there are 5 ways to fill the even indices and 4 ways for odd indices \\n        long even_places = pow(5,even);\\n        long odd_places = pow(4,prime);\\n        long ans = even_places*odd_places%mod;\\n        return (int) ans;\\n    }\\n    // Calculate power \\n    public long pow(int x , long n ){\\n        int mod = (int)Math.pow(10,9)+7;\\n        if(n==0){\\n            return 1 ;\\n        }\\n        \\n        long ans = pow(x,n/2);\\n        ans=ans*ans%mod;\\n        \\n        if(n%2==0) return ans;\\n        return (x*ans)%mod;\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\n    public int countGoodNumbers(long N) {\\n        int mod = (int)Math.pow(10,9)+7;\\n        long even = 0 ;\\n        long prime =0 ;\\n\\t\\t\\n\\t\\t// Possible even and odd indices depending upon length \\n        if(N%2==0){\\n            even = N/2 ; prime = N/2; \\n        }else{\\n            even =(N+1)/2 ; prime = N-even;\\n        }\\n        // we know that there are 5 ways to fill the even indices and 4 ways for odd indices \\n        long even_places = pow(5,even);\\n        long odd_places = pow(4,prime);\\n        long ans = even_places*odd_places%mod;\\n        return (int) ans;\\n    }\\n    // Calculate power \\n    public long pow(int x , long n ){\\n        int mod = (int)Math.pow(10,9)+7;\\n        if(n==0){\\n            return 1 ;\\n        }\\n        \\n        long ans = pow(x,n/2);\\n        ans=ans*ans%mod;\\n        \\n        if(n%2==0) return ans;\\n        return (x*ans)%mod;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2611258,
                "title": "c-easy-soluction",
                "content": "class Solution {\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long result =n%2==0? 1:5;\\n        int MOD=1e9+7;\\n        long x=20;\\n        \\n        for(long i=n/2;i>0;i=i/2)\\n        {\\n            if(i%2!=0) result=result*x%MOD;\\n            x=x*x%MOD;\\n        }\\n        \\n        return result;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long result =n%2==0? 1:5;\\n        int MOD=1e9+7;\\n        long x=20;\\n        \\n        for(long i=n/2;i>0;i=i/2)\\n        {\\n            if(i%2!=0) result=result*x%MOD;\\n            x=x*x%MOD;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578328,
                "title": "c-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7; \\n    int countGoodNumbers(long long n) {\\n        if(n & 1)\\n            return powFun(5, (n + 1) / 2) * powFun(4, n / 2) % mod;\\n        return powFun(5, n / 2) * powFun(4, n / 2) % mod;\\n    }\\n    long long powFun(long long x, long long n)\\n    {\\n        if(n == 0)\\n            return 1;\\n        long long p = powFun(x, n / 2);\\n        long long ans = p * p % mod;\\n        if(n & 1) \\n            ans = ans * x % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7; \\n    int countGoodNumbers(long long n) {\\n        if(n & 1)\\n            return powFun(5, (n + 1) / 2) * powFun(4, n / 2) % mod;\\n        return powFun(5, n / 2) * powFun(4, n / 2) % mod;\\n    }\\n    long long powFun(long long x, long long n)\\n    {\\n        if(n == 0)\\n            return 1;\\n        long long p = powFun(x, n / 2);\\n        long long ans = p * p % mod;\\n        if(n & 1) \\n            ans = ans * x % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519690,
                "title": "tle-in-o-1-python",
                "content": "Any Idea why am I geting TLE?\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        if n%2:\\n            #print(\"in\",n//2)\\n            ans = 5**(n//2+1)*4**(n//2)\\n        else:\\n            ans = 5**(n//2)*4**(n//2)\\n        return ans%(10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        if n%2:\\n            #print(\"in\",n//2)\\n            ans = 5**(n//2+1)*4**(n//2)\\n        else:\\n            ans = 5**(n//2)*4**(n//2)\\n        return ans%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401880,
                "title": "python-one-liner-100-memory",
                "content": "Each odd position has 4 options (2,3,5,7), each even position has 5 options (0,2,4,6,8). Simply multiply these for each digit taking modulo for odd and even positions separately as well to avoid tle.\\n\\n```\\ndef countGoodNumbers(self, n: int) -> int:        \\n        return (pow(4,(n//2),(10**9)+7)*pow(5,(n-n//2),(10**9)+7))%((10**9)+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countGoodNumbers(self, n: int) -> int:        \\n        return (pow(4,(n//2),(10**9)+7)*pow(5,(n-n//2),(10**9)+7))%((10**9)+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2369509,
                "title": "easy-bit-solution-using-permutation",
                "content": "class Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        \\n        def power(x,y,m,ans):\\n            if x == 1:\\n                return 1\\n            while y>0:\\n                if y&1:\\n                    ans = (x*ans)%m\\n                y>>=1\\n                x = (x*x)%m\\n            return ans\\n            \\n        res = 0\\n        mod = 1000000000+7\\n        if n % 2 == 0:\\n            res = power(5,(n//2),mod,1) * power(4,(n//2),mod,1)\\n            # print(5**n//2)\\n        else:\\n            res = power(5,((n//2)+1),mod,1) * power(4,(n//2),mod,1)\\n        return (res)%mod",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "class Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        \\n        def power(x,y,m,ans):\\n            if x == 1:\\n                return 1\\n            while y>0:\\n                if y&1:\\n                    ans = (x*ans)%m\\n                y>>=1\\n                x = (x*x)%m\\n            return ans\\n            \\n        res = 0\\n        mod = 1000000000+7\\n        if n % 2 == 0:\\n            res = power(5,(n//2),mod,1) * power(4,(n//2),mod,1)\\n            # print(5**n//2)\\n        else:\\n            res = power(5,((n//2)+1),mod,1) * power(4,(n//2),mod,1)\\n        return (res)%mod",
                "codeTag": "Java"
            },
            {
                "id": 2289588,
                "title": "without-formula-solution-using-modified-modular-exponentation-dp",
                "content": "I idea behind this is as follows ->\\n\\n![image](https://assets.leetcode.com/users/images/6fb7c952-d822-4955-b4c4-f345c63f8b30_1657963404.5361788.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    const int M = 1e9 + 7;\\n    unordered_map<int, unordered_map<bool, int>> dp;\\n    \\n    int go(long long n, bool flg){\\n        if(n == 1) return (flg ? 4 : 5);\\n        if(dp.find(n) != dp.end() && dp[n].find(flg) != dp[n].end()) return dp[n][flg];\\n        \\n        int tmp = ((long long)go(n/2, !flg) * go(n/2, flg)) % M;\\n        if(n&1) tmp = ((long long)tmp * (flg ? 4 : 5)) % M;\\n        return dp[n][flg] = tmp;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        return go(n, false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M = 1e9 + 7;\\n    unordered_map<int, unordered_map<bool, int>> dp;\\n    \\n    int go(long long n, bool flg){\\n        if(n == 1) return (flg ? 4 : 5);\\n        if(dp.find(n) != dp.end() && dp[n].find(flg) != dp[n].end()) return dp[n][flg];\\n        \\n        int tmp = ((long long)go(n/2, !flg) * go(n/2, flg)) % M;\\n        if(n&1) tmp = ((long long)tmp * (flg ? 4 : 5)) % M;\\n        return dp[n][flg] = tmp;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        return go(n, false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275192,
                "title": "c-solution-using-binary-exponentiation-and-binary-multiply",
                "content": "\\nclass Solution {\\npublic:\\n   long long int  binPow(long long int a, long long int b,long long int M)\\n    {\\n        a=a%M;\\n       long long int res=1;\\n        while(b>0)\\n        {\\n            if(b&1)\\n            {\\n                res=(res*1LL*a)%M;\\n            }\\n            a=(a*1LL*a)%M;\\n            b=b>>1;\\n        }\\n        return res;\\n    }\\n    int binMulti(long long int a,long long int b,long long int M)\\n    {\\n        int res=0;\\n        while(b>0)\\n        {\\n            if(b&1)\\n            {\\n                res=(res+a)%M;\\n            }\\n            a=(a+a)%M;\\n            b=b>>1;\\n        }\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long int  evenpos=0;\\n        long long int oddpos=0;\\n        long long int M=1e9+7;\\n        if(n%2==1)\\n        {\\n            evenpos=(n/2)+1;\\n            oddpos=n/2;\\n        }\\n        else{\\n            evenpos=n/2;\\n            oddpos=n/2;\\n        }\\n        long long int even_res=binPow(5,evenpos,M);\\n        long long int odd_res=binPow(4,oddpos,M);\\n        //cout<<even_res<<endl;\\n        //cout<<odd_res<<endl;\\n     int res= binMulti(even_res, odd_res, M);\\n      // cout<<res<<endl;\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   long long int  binPow(long long int a, long long int b,long long int M)\\n    {\\n        a=a%M;\\n       long long int res=1;\\n        while(b>0)\\n        {\\n            if(b&1)\\n            {\\n                res=(res*1LL*a)%M;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2218522,
                "title": "c-easy-approach-recursion",
                "content": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    long long power(long long x , long long y){\\n        if(y == 0) return 1;\\n        long long ans = power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2){\\n            ans*=x; // for the case x^7 (7/2 + 7/2) == 6 not 7\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        long long odd = n/2;\\n        long long even = n/2 + n%2;\\n        return (power(5,even)*power(4,odd))%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    long long power(long long x , long long y){\\n        if(y == 0) return 1;\\n        long long ans = power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2){\\n            ans*=x; // for the case x^7 (7/2 + 7/2) == 6 not 7\\n            ans%=mod;\\n        }\\n        return ans;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        long long odd = n/2;\\n        long long even = n/2 + n%2;\\n        return (power(5,even)*power(4,odd))%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217561,
                "title": "c-easy-recursive-approach",
                "content": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    long long solve(long long x, long long n){\\n        //base condition\\n        if(n==0){\\n            return 1;\\n        }\\n        long long ans = solve(x, n/2);\\n        if(n&1){\\n            ans = ans*ans*x;\\n            ans = ans%mod;\\n        }\\n        else{\\n            ans = ans*ans;\\n            ans = ans%mod;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        //long long oddPow =;\\n        long long res;\\n        if(n&1){\\n            // n is even \\n            res = (solve(5, n/2+1)*solve(4, n/2))%mod;\\n        }else{\\n            // n is odd\\n            res = (solve(5, n/2)*solve(4, n/2))%mod;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    long long solve(long long x, long long n){\\n        //base condition\\n        if(n==0){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2217102,
                "title": "javascript-solution-using-bigint-in-olog-n",
                "content": "I was trying this question without BigInt , but was getting wrong answers for large values, such as n=50,\\nSo tried with BigInt or n as shown below\\nwe have to convert every computation to BigInt and modulus it there itself to prevent some kind of overflow.\\n\\n```\\nvar countGoodNumbers = function(n) {\\n    \\n   let mod = 10**9+7\\n        \\n    function power(x,y){\\n\\n        let temp = BigInt(1)\\n        //same as 1n\\n        if( y === 0){\\n            return temp\\n        }\\n\\n        if( y%2 === 0 ){\\n            temp = power(x, Math.floor(y/2) )\\n            temp = BigInt(temp)\\n            return (temp%1000000007n)*(temp%1000000007n)\\n        }else{\\n            temp = power(x, Math.floor(y/2) )\\n            temp = BigInt(temp)\\n\\n            return BigInt(x)*(temp%1000000007n)*(temp%1000000007n)\\n        }\\n    }\\n    \\n    if( n%2 === 0){\\n            return (power(5,Math.floor(n/2)))*(power(4,Math.floor(n/2)) )%1000000007n\\n           }else{\\n               return BigInt(5)*(power(5,Math.floor(n/2)))*(power(4,Math.floor(n/2)))%1000000007n\\n           }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countGoodNumbers = function(n) {\\n    \\n   let mod = 10**9+7\\n        \\n    function power(x,y){\\n\\n        let temp = BigInt(1)\\n        //same as 1n\\n        if( y === 0){\\n            return temp\\n        }\\n\\n        if( y%2 === 0 ){\\n            temp = power(x, Math.floor(y/2) )\\n            temp = BigInt(temp)\\n            return (temp%1000000007n)*(temp%1000000007n)\\n        }else{\\n            temp = power(x, Math.floor(y/2) )\\n            temp = BigInt(temp)\\n\\n            return BigInt(x)*(temp%1000000007n)*(temp%1000000007n)\\n        }\\n    }\\n    \\n    if( n%2 === 0){\\n            return (power(5,Math.floor(n/2)))*(power(4,Math.floor(n/2)) )%1000000007n\\n           }else{\\n               return BigInt(5)*(power(5,Math.floor(n/2)))*(power(4,Math.floor(n/2)))%1000000007n\\n           }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086271,
                "title": "c-short-and-easy-to-understand-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9+7;\\n    long long power(long long x, long long n){\\n        if(n == 0) return 1;\\n        long long temp = power((x*x)%MOD, n/2);\\n        if(n%2) temp = (temp*x)%MOD;\\n        return temp%MOD;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        long long evens = (n+1)/2, odds = n-evens;\\n        long long res = 1;\\n        res = (res*power(5, evens))%MOD;\\n        res = (res*power(4, odds))%MOD;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9+7;\\n    long long power(long long x, long long n){\\n        if(n == 0) return 1;\\n        long long temp = power((x*x)%MOD, n/2);\\n        if(n%2) temp = (temp*x)%MOD;\\n        return temp%MOD;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        long long evens = (n+1)/2, odds = n-evens;\\n        long long res = 1;\\n        res = (res*power(5, evens))%MOD;\\n        res = (res*power(4, odds))%MOD;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976497,
                "title": "easiest-code-with-very-easy-and-clear-explanation-c",
                "content": "![image](https://assets.leetcode.com/users/images/2d922556-40fd-4596-8843-842d3dc4462d_1650758384.3169024.jpeg)\\n \\n\\n```\\n // Above i have give visualisation of recursive code and below i have implemented in iterative (as iterative is preferred over recursive)\\n\\nclass Solution {\\npublic:\\n    int p = 1e9 + 7;\\n    long long fastPow(long long x,long long y){\\n        long long ans = 1;\\n    while(y>0){\\n        if(y&1) ans *= x;       // checking that whether the power becomes odd at some moment (it will surely become odd at      \\n        x *= x;                // second last iteration i.e \"1\" so ans will surely updated)\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\n        x=x%p;\\n        y>>= 1;\\n        ans=ans%p;\\n    }\\n    return ans;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n       long long res = fastPow(4,(n)/2) % p;    // ans= (5^even) * (4^odd)   (permutation concept with repitition)\\n        res = res * fastPow(5,(n+1)/2) % p;     \\n        return (int)res;                        // even--> 0/2/4/6/8    prime--> 2/3/5/7        even           prime\\n    }                                                     ------------        ------------  --------------   ------------\\n};                                              //         even place          odd place     even place       odd place\\n```",
                "solutionTags": [],
                "code": "```\\n // Above i have give visualisation of recursive code and below i have implemented in iterative (as iterative is preferred over recursive)\\n\\nclass Solution {\\npublic:\\n    int p = 1e9 + 7;\\n    long long fastPow(long long x,long long y){\\n        long long ans = 1;\\n    while(y>0){\\n        if(y&1) ans *= x;       // checking that whether the power becomes odd at some moment (it will surely become odd at      \\n        x *= x;                // second last iteration i.e \"1\" so ans will surely updated)\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\uD83D\\uDE0E\\n        x=x%p;\\n        y>>= 1;\\n        ans=ans%p;\\n    }\\n    return ans;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n       long long res = fastPow(4,(n)/2) % p;    // ans= (5^even) * (4^odd)   (permutation concept with repitition)\\n        res = res * fastPow(5,(n+1)/2) % p;     \\n        return (int)res;                        // even--> 0/2/4/6/8    prime--> 2/3/5/7        even           prime\\n    }                                                     ------------        ------------  --------------   ------------\\n};                                              //         even place          odd place     even place       odd place\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794329,
                "title": "100-percent-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(long long a,long long b,long long M)\\n    {\\n        int res=1;\\n        while(b>0)\\n        {\\n            if(b&1){\\n                res=(res*a)%M;\\n            }\\n            a=(a*a)%M;\\n            b=b>>1;\\n\\n        }\\n        return res;\\n        \\n    }\\n    int countGoodNumbers(long long n) {\\n        long long res;\\n        long long M=1000000007;\\n        long long odd=n/2;\\n        long long even=n-odd;\\n        long long a=solve(4,odd,M);\\n        long long b=solve(5,even,M);\\n        res=((a%M)*(b%M))%M;\\n        return res;\\n    }\\n};****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solve(long long a,long long b,long long M)\\n    {\\n        int res=1;\\n        while(b>0)\\n        {\\n            if(b&1){\\n                res=(res*a)%M;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1760117,
                "title": "c-0ms-runtime",
                "content": "Easy to understand\\n\\n```\\n int val=1e9+7;\\n   long long answer(int num,long long power){\\n        if(power==0){\\n            return 1;\\n        }\\n       if(power==1){\\n           return num;\\n       }\\n       \\n       long long midans=answer(num,power/2);\\n       \\n       if(power%2==0)\\n           return (midans*midans)%val;\\n       return (((midans*num)%val)*midans)%val;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n       return ((answer(4,n/2))*answer(5,(n+1)/2))%val;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int val=1e9+7;\\n   long long answer(int num,long long power){\\n        if(power==0){\\n            return 1;\\n        }\\n       if(power==1){\\n           return num;\\n       }\\n       \\n       long long midans=answer(num,power/2);\\n       \\n       if(power%2==0)\\n           return (midans*midans)%val;\\n       return (((midans*num)%val)*midans)%val;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n       return ((answer(4,n/2))*answer(5,(n+1)/2))%val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1702085,
                "title": "binary-exponentiation-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7; \\n    //fuction to calculate power in o(logn) time\\n    long long power(int x, long long n)\\n    {\\n        if(n==0)\\n            return 1;\\n        long long temp=power(x,n/2);\\n        if(n%2==0)\\n            return (temp*temp)%mod;\\n        else\\n            return (((temp * temp) % mod) * x) % mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        //we have 4 prime numbers and 5 even numbers including 0\\n        //so 4^odd*5^even gives us all possible good numbers\\n        // long long odd =power(4,n/2);\\n        //long long even =power(5,(n+1)/2;\\n        //long long ans=(even*odd)%mod;\\n        //return ans;\\n        return ((power(4,n/2))*power(5,(n+1)/2))%mod;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9+7; \\n    //fuction to calculate power in o(logn) time\\n    long long power(int x, long long n)\\n    {\\n        if(n==0)\\n            return 1;\\n        long long temp=power(x,n/2);\\n        if(n%2==0)\\n            return (temp*temp)%mod;\\n        else\\n            return (((temp * temp) % mod) * x) % mod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1685400,
                "title": "easy-brief-implementation-c-modular-power",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n   long long int power(int a,long long b){\\n        if(b==0)\\n            return 1;\\n        long long x=power(a,b/2);\\n        if(b%2==0)\\n            return (x*x)%mod;\\n        return (((a*x)%mod)*x)%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n       return ((power(4,n/2))*power(5,(n+1)/2))%mod;\\n      \\n    }\\n};\\n```\\n// if you like plz upvote the post",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n   long long int power(int a,long long b){\\n        if(b==0)\\n            return 1;\\n        long long x=power(a,b/2);\\n        if(b%2==0)\\n            return (x*x)%mod;\\n        return (((a*x)%mod)*x)%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n       return ((power(4,n/2))*power(5,(n+1)/2))%mod;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644570,
                "title": "100-fast-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int power(int x, long long n) {\\n        if(n == 0)\\n            return 1;\\n        if(n==1)\\n            return x;\\n        long long p = power(x, n/2);\\n        int p2 = (p*1ll*p)%M;\\n        if(n%2 == 0)\\n            return p2;\\n        return (p2*1ll*x)%M;\\n    }\\n    int countGoodNumbers(long long n) {\\n        if(n == 1)\\n            return 5;\\n        long long oddPlacesCount = n/2; // candidates 4\\n        long long evenPlacesCount = n-oddPlacesCount; // candidates 5\\n        \\n        return power(5, evenPlacesCount)*1ll*power(4, oddPlacesCount))%M;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int power(int x, long long n) {\\n        if(n == 0)\\n            return 1;\\n        if(n==1)\\n            return x;\\n        long long p = power(x, n/2);\\n        int p2 = (p*1ll*p)%M;\\n        if(n%2 == 0)\\n            return p2;\\n        return (p2*1ll*x)%M;\\n    }\\n    int countGoodNumbers(long long n) {\\n        if(n == 1)\\n            return 5;\\n        long long oddPlacesCount = n/2; // candidates 4\\n        long long evenPlacesCount = n-oddPlacesCount; // candidates 5\\n        \\n        return power(5, evenPlacesCount)*1ll*power(4, oddPlacesCount))%M;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643453,
                "title": "easy-c-100-faster-solution-with-in-depth-explanation",
                "content": "The logic is quite simple based on the basic principles of Combination.\\n\\nAt every even position, (0- indexed), we need to have even numbers only. Se, we can have 5 possible values => 0, 2, 4, 6, 8. (0 is included at all places since leading zeroes are allowed).\\nSimilarly at every odd position, we need to have only prime numbers only. So, we can have 4 possible values => 2, 3, 5, 7.\\n\\nSo, now the task is just to find the total possible numbers, so for every even position, we multiply the result by 5 and for every odd position, we multiply the result by 4. At every step, we should check that overflow should not occur, so we use the property of modulo operator - (a * b) % m = ((a % m) * (b % m)) % m and thereby keep the result within limits.\\n\\nNow, upon observation we find two cases, as explained below:\\n\\nCase 1: If n is odd\\nLet say n = 7, \\nthen we have the even positions => 0, 2, 4, 6 => total 4 even positions (ceil(7 / 2) = 4)\\n& we have the odd positions => 1, 3, 5 => total 3 odd positions (floor(7 / 2)) = 3)\\n\\nCase 2: If n is even\\nLet say n = 8,\\nthen we have the even positions => 0, 2, 4, 6 => total 4 even positions (ceil(8 / 2) = 4)\\n& we have the odd positions => 1, 3, 5, 7 => total 4 odd positions (floor(8 / 2) = 4)\\n\\nThus, from the above observations we can conclude that regardless of the parity of n,\\n1. The number of even positions is ceil(n / 2)\\n2. The number of odd positions is floor(n / 2)\\n\\nSo our answer is power(5, ceil(n / 2)) * power(4, floor(n / 2)) (assuming the modulo thing is taken care of..)\\n\\nCODE -\\n```\\nconst int MOD = 1e9 + 7;\\n\\n#define mul(a, b) ((a % MOD) * (b % MOD)) % MOD;\\n\\nlong long power(long long a, long long b, int m = MOD) { \\n\\tlong long res = 1; a %= m;\\n\\twhile (b > 0) { \\n\\t\\tif (b & 1) \\n\\t\\t\\tres = (res * a) % m; \\n\\t\\ta = (a * a) % m; \\n\\t\\tb >>= 1; \\n\\t} \\n\\treturn res;\\n}\\n\\nclass Solution {\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long res = 1;\\n        res = mul(res, fastpow(5, ceil(n / 2.0)));\\n        res = mul(res, fastpow(4, n / 2));\\n        return (int) res % MOD;\\n    }\\n};\\n```\\n\\nHope this is helpful, please upvote if found useful :)",
                "solutionTags": [],
                "code": "```\\nconst int MOD = 1e9 + 7;\\n\\n#define mul(a, b) ((a % MOD) * (b % MOD)) % MOD;\\n\\nlong long power(long long a, long long b, int m = MOD) { \\n\\tlong long res = 1; a %= m;\\n\\twhile (b > 0) { \\n\\t\\tif (b & 1) \\n\\t\\t\\tres = (res * a) % m; \\n\\t\\ta = (a * a) % m; \\n\\t\\tb >>= 1; \\n\\t} \\n\\treturn res;\\n}\\n\\nclass Solution {\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long res = 1;\\n        res = mul(res, fastpow(5, ceil(n / 2.0)));\\n        res = mul(res, fastpow(4, n / 2));\\n        return (int) res % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594280,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodNumbers(long n) {\\n        long mod = 1000000007;\\n        long result= n%2==0?1:5;\\n        long x=20;\\n        for(long i=n/2; i>0; i/=2){\\n         if(i%2!=0) \\n             result=result*x%mod;\\n            x=x*x%mod;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodNumbers(long n) {\\n        long mod = 1000000007;\\n        long result= n%2==0?1:5;\\n        long x=20;\\n        for(long i=n/2; i>0; i/=2){\\n         if(i%2!=0) \\n             result=result*x%mod;\\n            x=x*x%mod;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397192,
                "title": "o-log-n-beats-100-0ms",
                "content": "```\\n#define mod 1000000007\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    ll modexp(ll a,ll b){\\n        ll ans=1;\\n        while(b){\\n            if(b&1)ans=(ans*a)%mod;\\n            b>>=1;\\n            a=(a*a)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        return (n&1)?((modexp(5,1+(n/2))*modexp(4,n/2))%mod):((modexp(5,n/2)*modexp(4,n/2))%mod);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define mod 1000000007\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    ll modexp(ll a,ll b){\\n        ll ans=1;\\n        while(b){\\n            if(b&1)ans=(ans*a)%mod;\\n            b>>=1;\\n            a=(a*a)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        return (n&1)?((modexp(5,1+(n/2))*modexp(4,n/2))%mod):((modexp(5,n/2)*modexp(4,n/2))%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386251,
                "title": "author-have-considered-0-at-0th-index-but-this-is-wrong-actual-code-look-like-this",
                "content": "class Solution {\\npublic:\\n    int powmod(long long a, long long n, long long m){\\n        \\n        if(n == 0) return 1;\\n        long long res = powmod(a, n/2, m);\\n        \\n        if(n & 1) return a * res * res % m;\\n        else return res * res % m;\\n    }\\n    int countGoodNumbers(long long n) {\\n        \\n        long long m = 1e9 + 7;\\n        if(n == 1) return 5;\\n        if(n & 1) return 4 * powmod(20, (n - 1)/2, m);\\n        else return 4 * 4 * powmod(20, (n - 2)/2, m);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int powmod(long long a, long long n, long long m){\\n        \\n        if(n == 0) return 1;\\n        long long res = powmod(a, n/2, m);\\n        \\n        if(n & 1) return a * res * res % m;\\n        else return res * res % m;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1353267,
                "title": "binary-exponentiation-c-iterative-recursive-explained",
                "content": "We have to calculate (a^b)%M while keeping the answer inside range.\\n\\n**Iterative**\\n\\nTo solve this, we can observe that we can break the power of number into power of 2s!\\nEg : In 7^45, \\n45 = 32 + 8 + 4 + 1, In Binary - 101101\\nSo the number can be written as - 7^32 * 7^8 * 7^4 * 7^1\\nWe start from int x = 7^1, Multiply it with itself, x = x * x = 7^2, again x = x * x = 7^2 * 7^2 = 7^4.\\n\\nSo, Finally. Starting from the right of 101101<- It represents the contribution of 7^1, so multiply 7^1 into result,\\nNext do x = x * x, you get 7^2, multiply into result if the second bit is set and so on...!\\n\\n\\tlong long int pow(long long int x, long long int n){\\n\\n\\t\\tlong long int res = 1;\\n\\t\\twhile(n>0){\\n\\n\\t\\t\\tif(n&1) res = (res*x)%M;\\n\\t\\t\\tn = n>>1;\\n\\t\\t\\tx=(x*x)%M;\\n\\n\\t\\t}\\n\\t\\treturn res;\\n\\n\\t}\\n\\n**Recursive**\\n\\nThis approach uses the idea that a^n = { a^(n/2) * a^(n/2) * a (if odd) } or { a^(n/2) * a^(n/2) (if even) }\\nSo we keep limiting the answer into the required range at every step during recursive calls.\\n\\n\\tlong long int pow(long long int x, long long int n){\\n\\n\\t\\tif(n==0) return 1;\\n\\n\\t\\tlong long int res = pow(x, n/2)%M;\\n\\n\\t\\tif(n&1)\\n\\t\\t\\treturn ( ((res*res)%M)*x )%M;\\n\\t\\telse\\n\\t\\t\\treturn (res*res)%M;\\n\\n\\t}",
                "solutionTags": [],
                "code": "We have to calculate (a^b)%M while keeping the answer inside range.\\n\\n**Iterative**\\n\\nTo solve this, we can observe that we can break the power of number into power of 2s!\\nEg : In 7^45, \\n45 = 32 + 8 + 4 + 1, In Binary - 101101\\nSo the number can be written as - 7^32 * 7^8 * 7^4 * 7^1\\nWe start from int x = 7^1, Multiply it with itself, x = x * x = 7^2, again x = x * x = 7^2 * 7^2 = 7^4.\\n\\nSo, Finally. Starting from the right of 101101<- It represents the contribution of 7^1, so multiply 7^1 into result,\\nNext do x = x * x, you get 7^2, multiply into result if the second bit is set and so on...!\\n\\n\\tlong long int pow(long long int x, long long int n){\\n\\n\\t\\tlong long int res = 1;\\n\\t\\twhile(n>0){\\n\\n\\t\\t\\tif(n&1) res = (res*x)%M;\\n\\t\\t\\tn = n>>1;\\n\\t\\t\\tx=(x*x)%M;\\n\\n\\t\\t}\\n\\t\\treturn res;\\n\\n\\t}\\n\\n**Recursive**\\n\\nThis approach uses the idea that a^n = { a^(n/2) * a^(n/2) * a (if odd) } or { a^(n/2) * a^(n/2) (if even) }\\nSo we keep limiting the answer into the required range at every step during recursive calls.\\n\\n\\tlong long int pow(long long int x, long long int n){\\n\\n\\t\\tif(n==0) return 1;\\n\\n\\t\\tlong long int res = pow(x, n/2)%M;\\n\\n\\t\\tif(n&1)\\n\\t\\t\\treturn ( ((res*res)%M)*x )%M;\\n\\t\\telse\\n\\t\\t\\treturn (res*res)%M;\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1347190,
                "title": "java-modular-power",
                "content": "```\\nclass Solution {\\n    static int MOD= 1_000_000_007;\\n    static int ev= 5, pr= 4;\\n\\n\\tpublic int countGoodNumbers(long n) {\\n        long powEv= n/2+(n%2==0 ? 0 : 1), powPr= n-powEv;\\n        return (int)((modPow(ev, powEv, MOD)*modPow(pr, powPr, MOD))%MOD);\\n    }\\n    \\n    long modPow(long b, long e, int m){\\n        if(m == 1) return 0;\\n        long res= 1;\\n        b= b % m;\\n        while(e>0){\\n            if(e%2 == 1) res= (res*b) % m;\\n            e = e >> 1; // e/= 2\\n            b = (b*b) % m;\\n        }\\n        return res;\\n    }    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int MOD= 1_000_000_007;\\n    static int ev= 5, pr= 4;\\n\\n\\tpublic int countGoodNumbers(long n) {\\n        long powEv= n/2+(n%2==0 ? 0 : 1), powPr= n-powEv;\\n        return (int)((modPow(ev, powEv, MOD)*modPow(pr, powPr, MOD))%MOD);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1331052,
                "title": "binary-exponentiation-c-solution",
                "content": "```\\n#define m 1000000007\\n\\nclass Solution {\\npublic:\\n    int countGoodNumbers(long long n) {\\n        if(n%2==0){                                                    // if n is even then no. of even and odd place will be n/2\\n            return (binaryExp(5,n/2)%m)*(binaryExp(4,n/2)%m)%m;\\n        }\\n        return (binaryExp(5,n/2+1)%m)*(binaryExp(4,n/2)%m)%m;          // else if n is odd then no. of even place will be n/2+1 and odd place will be n/2\\n    }\\n    \\n    long long binaryExp(long long num,long long pow){\\n        if(pow==1) return num;\\n        if(pow==0) return 1;\\n        long long result=binaryExp(num,pow/2)%m;\\n        if(pow%2==0) return ((result)*(result))%m;\\n        else return ((num%m)*(((result)*(result)%m)%m))%m;\\n    }\\n};\\n```\\n\\nTo know about binary exponentiationn in detail read this https://cp-algorithms.com/algebra/binary-exp.html .",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define m 1000000007\\n\\nclass Solution {\\npublic:\\n    int countGoodNumbers(long long n) {\\n        if(n%2==0){                                                    // if n is even then no. of even and odd place will be n/2\\n            return (binaryExp(5,n/2)%m)*(binaryExp(4,n/2)%m)%m;\\n        }\\n        return (binaryExp(5,n/2+1)%m)*(binaryExp(4,n/2)%m)%m;          // else if n is odd then no. of even place will be n/2+1 and odd place will be n/2\\n    }\\n    \\n    long long binaryExp(long long num,long long pow){\\n        if(pow==1) return num;\\n        if(pow==0) return 1;\\n        long long result=binaryExp(num,pow/2)%m;\\n        if(pow%2==0) return ((result)*(result))%m;\\n        else return ((num%m)*(((result)*(result)%m)%m))%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328267,
                "title": "java-fast-power-bitmanipulation-modular-power",
                "content": "For a given n we can have n/2(n even) or n/2+1(if n odd) positions as even numbers(0,2,4,6,8) = 5 and rest n/2 positions can have 1,3,5,7 = 4. Therefore total number of good numbers can be written as =\\n\\n\\tans =   5^n/2*4^n/2  n=even\\n\\t\\t\\t5^n/2+1*4^n/2 n=odd\\nFor example n=4\\n0th and 2nd position filled by 0,2,4,6,8 in 5^2 ways and 1st and 3rd position filled in 4^2 ways. \\nHence 25*16=400.\\nCode of same is below:\\n```\\nclass Solution\\n{\\n    long MOD = 1000000007;\\n    public int countGoodNumbers(long n) {\\n        long ans = 0;\\n        if(n%2==0)\\n           ans = ((fastPower(5,n/2)%MOD * fastPower(4,n/2)%MOD))%MOD;\\n        else\\n            ans = ((fastPower(5,n/2+1)%MOD  * (fastPower(4,n/2))%MOD))%MOD;\\n        return (int)ans;\\n    }\\n    public long fastPower(long a,long b)\\n    {\\n        long res = 1;\\n        long c = a;\\n        while (b!=0)\\n        {\\n            if ((b&1)!=0)\\n            {\\n                res = ((res)*(c%MOD))%MOD;\\n            }\\n            c = ((c%MOD) * (c%MOD))%MOD;\\n            b = b>>1;\\n        }\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n{\\n    long MOD = 1000000007;\\n    public int countGoodNumbers(long n) {\\n        long ans = 0;\\n        if(n%2==0)\\n           ans = ((fastPower(5,n/2)%MOD * fastPower(4,n/2)%MOD))%MOD;\\n        else\\n            ans = ((fastPower(5,n/2+1)%MOD  * (fastPower(4,n/2))%MOD))%MOD;\\n        return (int)ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1323092,
                "title": "c-faster-than-100",
                "content": "Finding power the smart way.\\n\\n\\t#define ll long long\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\tint m = 1e9 + 7;\\n\\t\\t\\tll power(ll a, ll n){\\n\\t\\t\\t\\tif (n == 0) return 1;\\n\\t\\t\\t\\tif (n == 1) return a;\\n\\t\\t\\t\\tint tmp = (a*a) % m;\\n\\t\\t\\t\\tif (n%2 == 1) return (a* power(tmp, n/2)) %m;\\n\\t\\t\\t\\telse return power(tmp, n/2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint countGoodNumbers(long long n) {\\n\\t\\t\\t\\treturn (power(4,n/2)* power(5,n-n/2)) % m;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\nThanks.",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\tint m = 1e9 + 7;\\n\\t\\t\\tll power(ll a, ll n){\\n\\t\\t\\t\\tif (n == 0) return 1;\\n\\t\\t\\t\\tif (n == 1) return a;\\n\\t\\t\\t\\tint tmp = (a*a) % m;\\n\\t\\t\\t\\tif (n%2 == 1) return (a* power(tmp, n/2)) %m;\\n\\t\\t\\t\\telse return power(tmp, n/2);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1319331,
                "title": "c-easy-faster-than-100-percent",
                "content": "class Solution {\\npublic:\\n    long long  power(long long x, long long int y)\\n{\\n        long long p = 1000000007;\\n    int res = 1;     // Initialize result\\n \\n    x = x % p; // Update x if it is more than or\\n                // equal to p\\n  \\n    if (x == 0) return 0; // In case x is divisible by p;\\n \\n    while (y > 0)\\n    {\\n        // If y is odd, multiply x with result\\n        if (y & 1)\\n            res = (res*x) % p;\\n \\n        // y must be even now\\n        y = y>>1; // y = y/2\\n        x = (x*x) % p;\\n    }\\n    return res;\\n}\\n \\n    int countGoodNumbers(long long n) {\\n        long long sum;\\n       \\n           sum= power(4,n/2)*power(5,(n+1)/2);\\n        // long long p =  7 +pow(10,9);\\n        sum = sum%1000000007;\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long  power(long long x, long long int y)\\n{\\n        long long p = 1000000007;\\n    int res = 1;     // Initialize result\\n \\n    x = x % p; // Update x if it is more than or\\n                // equal to p\\n  \\n    if (x == 0) return 0; // In case x is divisible by p;\\n \\n    while (y > 0)\\n    {\\n        // If y is odd, multiply x with result\\n        if (y & 1)\\n            res = (res*x) % p;\\n \\n        // y must be even now\\n        y = y>>1; // y = y/2\\n        x = (x*x) % p;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1315709,
                "title": "c-using-modpow",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long power(long long n, long long k){\\n        \\n        if(k<1)\\n            return 1;\\n        \\n        int mod = 1e9+7;\\n        \\n        long long x = power(n,k/2)%mod;\\n        \\n        if(k&1) \\n            return ((x%mod * x%mod)%mod  * n%mod)%mod;\\n        else\\n            return (x%mod * x%mod)%mod;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n\\n        \\n        int mod = 1e9+7;\\n        \\n        if(n&1)\\n            return (power(20,n/2)%mod * 5%mod)%mod;\\n        else\\n            return power(20,n/2)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long power(long long n, long long k){\\n        \\n        if(k<1)\\n            return 1;\\n        \\n        int mod = 1e9+7;\\n        \\n        long long x = power(n,k/2)%mod;\\n        \\n        if(k&1) \\n            return ((x%mod * x%mod)%mod  * n%mod)%mod;\\n        else\\n            return (x%mod * x%mod)%mod;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n\\n        \\n        int mod = 1e9+7;\\n        \\n        if(n&1)\\n            return (power(20,n/2)%mod * 5%mod)%mod;\\n        else\\n            return power(20,n/2)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315443,
                "title": "golang-0ms-solution",
                "content": "```go\\nfunc countGoodNumbers(n int64) int {\\n\\thash := make(map[int]int)\\n\\tfor i := 0; i <= 10; i++ {\\n\\t\\thash[i] = int(math.Pow(5, float64(i/2+i%2))*math.Pow(4, float64(i/2)))\\n\\t}\\n\\tin := int(n)\\n\\tresult := hash[in%10]\\n\\tfactor := hash[10]\\n\\tfor v := 10; v <= in; v*=10 {\\n\\t\\tfor i := 1; i <= in/v%10; i++ {\\n\\t\\t\\tresult = result * factor\\n\\t\\t\\tresult %= 1000000007\\n\\t\\t}\\n\\t\\tnextFactor := factor\\n\\t\\tfor i := 2; i <= 10; i++ {\\n\\t\\t\\tnextFactor *= factor\\n\\t\\t\\tnextFactor %= 1000000007\\n\\t\\t}\\n\\t\\tfactor = nextFactor\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc countGoodNumbers(n int64) int {\\n\\thash := make(map[int]int)\\n\\tfor i := 0; i <= 10; i++ {\\n\\t\\thash[i] = int(math.Pow(5, float64(i/2+i%2))*math.Pow(4, float64(i/2)))\\n\\t}\\n\\tin := int(n)\\n\\tresult := hash[in%10]\\n\\tfactor := hash[10]\\n\\tfor v := 10; v <= in; v*=10 {\\n\\t\\tfor i := 1; i <= in/v%10; i++ {\\n\\t\\t\\tresult = result * factor\\n\\t\\t\\tresult %= 1000000007\\n\\t\\t}\\n\\t\\tnextFactor := factor\\n\\t\\tfor i := 2; i <= 10; i++ {\\n\\t\\t\\tnextFactor *= factor\\n\\t\\t\\tnextFactor %= 1000000007\\n\\t\\t}\\n\\t\\tfactor = nextFactor\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315177,
                "title": "c-0-ms-solution-fast-power",
                "content": "If we see closely then the number of prime numbers on a certain position can only be ( 2,3,5,7) since they are the only unit digit primes and can take a place in the string.\\nNow number of even digits are 5 (0,2,4,6,8) so we can say that we have to find the permutation of 5 numbers of each of even index and 4 numbers on each of odd index.\\nSo from here we can conclude that if n is even ( **equal no of odd and even index**), we find 20^(n/2) since 5*4 are the no of combinations for a pair and if n is odd then we find 20^(n/2) and multiply it with 5 since we initially ignored one of the five when compution 20^(n/2).\\n```\\nlong long power(long long x,long long y, int p)\\n    {\\n        long long res = 1; \\n        x = x % p; \\n        if (x == 0) return 0;\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x) % p;\\n            y = y>>1;\\n            x = (x*x) % p;\\n        }\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long temp = power(20,n/2,1000000007);\\n        if(!(n&1))\\n        {\\n            return temp;\\n        }\\n        return (temp*5)%1000000007;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long power(long long x,long long y, int p)\\n    {\\n        long long res = 1; \\n        x = x % p; \\n        if (x == 0) return 0;\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x) % p;\\n            y = y>>1;\\n            x = (x*x) % p;\\n        }\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long temp = power(20,n/2,1000000007);\\n        if(!(n&1))\\n        {\\n            return temp;\\n        }\\n        return (temp*5)%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315144,
                "title": "java-easy-to-understand-recursive-power-function",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Count Good Numbers.\\nMemory Usage: 35.8 MB, less than 100.00% of Java online submissions for Count Good Numbers.**\\n```\\nclass Solution {\\n    long m = (int)1e9+7;\\n    public int countGoodNumbers(long n) {\\n        return (int)(helper(5, (n + 1) / 2) * helper(4, n / 2) % m);    \\n    }\\n    long helper(long x,long y){\\n        if(y == 0)return 1;\\n        if(y%2 == 0)return helper((x*x) % m,y/2);\\n        else return (x * helper((x*x) % m,(y-1)/2)) % m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long m = (int)1e9+7;\\n    public int countGoodNumbers(long n) {\\n        return (int)(helper(5, (n + 1) / 2) * helper(4, n / 2) % m);    \\n    }\\n    long helper(long x,long y){\\n        if(y == 0)return 1;\\n        if(y%2 == 0)return helper((x*x) % m,y/2);\\n        else return (x * helper((x*x) % m,(y-1)/2)) % m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314961,
                "title": "java-o-logn-100-time-memory-using-bitmasking-explained",
                "content": "***\\n* ### Explanation\\n***\\n```\\nNumber of digits that can be placed in even indexes are [0,2,4,6,8].\\nNumber of digits that can be placed in odd indexes are [2,3,5,7].\\n\\nlets assume Number of Good number in N digit is f(N).\\n\\nNumber of Good numbers in f(2^0)=f(1) is 5 {0,2,4,6,8} (base condition).\\nNumber of Good numbers in f(2^1)=f(2) is 20 {02,03,05,07,22,...} (base condition).\\nNumber of Good numbers in f(2^2)=f(4) is f(2^1)*f(2^1) = 20 * 20 = 400.\\nNumber of Good numbers in f(2^3)=f(8) is f(2^2)*f(2^2) = 400 * 400 = 160000.\\n.\\n.\\n.\\nNumber of Good number in f(2^N) is f(2^(N-1)) * f(2^(N-1)). \\n\\nA Number can be expressed as ((0|1) * 2^N) + ((0|1) * 2^N-1)+...+(0|1) * 2^0.\\n\\nSo if n= 100 = (2^6)+(2^5)+(2^2).\\n\\nNumber of good numbers in 100 will be f(2^6)*f(2^5)*f(2^2).\\n\\n* Precompute f(2^N) to get faster solution.\\n* Use %1000000007 to avoid overflow.\\n```\\n***\\n* ### Solution\\n***\\n\\n```java\\npublic class Solution {\\n    public int countGoodNumbers(long n) {\\n        long[] dp = new long[64];\\n        long mod = (long) (1e9 + 7);\\n\\t\\t\\n\\t\\t/* Base Condition */\\n        dp[0] = 5;\\n        dp[1] = 20;\\n\\n\\t\\t/* Precomputing f(2^N) */\\n        for (int i = 2; i < 64; i++) {\\n            long mask = 1L << i;\\n            if (mask > n)\\n                break;\\n            dp[i] = (dp[i-1]*dp[i-1]) % mod;\\n        }\\n        long result = 1;\\n\\t\\t\\n\\t\\t/* Getting answer from f(N) = \\u220F f(2^(Set bit index)) */\\n        for (int i = 0; i < 64; i++) {\\n            long mask = 1L << i;\\n            if (mask > n)\\n                break;\\n            if ((n & mask) > 0)\\n                result = (result * dp[i]) % mod;\\n        }\\n        return (int) result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nNumber of digits that can be placed in even indexes are [0,2,4,6,8].\\nNumber of digits that can be placed in odd indexes are [2,3,5,7].\\n\\nlets assume Number of Good number in N digit is f(N).\\n\\nNumber of Good numbers in f(2^0)=f(1) is 5 {0,2,4,6,8} (base condition).\\nNumber of Good numbers in f(2^1)=f(2) is 20 {02,03,05,07,22,...} (base condition).\\nNumber of Good numbers in f(2^2)=f(4) is f(2^1)*f(2^1) = 20 * 20 = 400.\\nNumber of Good numbers in f(2^3)=f(8) is f(2^2)*f(2^2) = 400 * 400 = 160000.\\n.\\n.\\n.\\nNumber of Good number in f(2^N) is f(2^(N-1)) * f(2^(N-1)). \\n\\nA Number can be expressed as ((0|1) * 2^N) + ((0|1) * 2^N-1)+...+(0|1) * 2^0.\\n\\nSo if n= 100 = (2^6)+(2^5)+(2^2).\\n\\nNumber of good numbers in 100 will be f(2^6)*f(2^5)*f(2^2).\\n\\n* Precompute f(2^N) to get faster solution.\\n* Use %1000000007 to avoid overflow.\\n```\n```java\\npublic class Solution {\\n    public int countGoodNumbers(long n) {\\n        long[] dp = new long[64];\\n        long mod = (long) (1e9 + 7);\\n\\t\\t\\n\\t\\t/* Base Condition */\\n        dp[0] = 5;\\n        dp[1] = 20;\\n\\n\\t\\t/* Precomputing f(2^N) */\\n        for (int i = 2; i < 64; i++) {\\n            long mask = 1L << i;\\n            if (mask > n)\\n                break;\\n            dp[i] = (dp[i-1]*dp[i-1]) % mod;\\n        }\\n        long result = 1;\\n\\t\\t\\n\\t\\t/* Getting answer from f(N) = \\u220F f(2^(Set bit index)) */\\n        for (int i = 0; i < 64; i++) {\\n            long mask = 1L << i;\\n            if (mask > n)\\n                break;\\n            if ((n & mask) > 0)\\n                result = (result * dp[i]) % mod;\\n        }\\n        return (int) result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314821,
                "title": "c-fast-power",
                "content": "```\\nint M = 1e9 + 7;\\nclass Solution {\\npublic:\\n\\n  long long pw(long long int a,long long int p=M-2,long long int MOD=M){\\n        int res=1;\\n      \\n        while(p){\\n            if(p&1){\\n                res= res * a % MOD;\\n            }\\n            a=a*a % MOD;\\n            p>>=1;\\n        }\\n        return res;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        long long int ans=0;\\n        long long int count4=n/2;\\n        long long int count5=n-count4;\\n            ans= (( (pw(5LL,count5) %M) * (pw(4LL,count4)%M)) % M);\\n        \\n        \\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint M = 1e9 + 7;\\nclass Solution {\\npublic:\\n\\n  long long pw(long long int a,long long int p=M-2,long long int MOD=M){\\n        int res=1;\\n      \\n        while(p){\\n            if(p&1){\\n                res= res * a % MOD;\\n            }\\n            a=a*a % MOD;\\n            p>>=1;\\n        }\\n        return res;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        long long int ans=0;\\n        long long int count4=n/2;\\n        long long int count5=n-count4;\\n            ans= (( (pw(5LL,count5) %M) * (pw(4LL,count4)%M)) % M);\\n        \\n        \\n        return (int)ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314785,
                "title": "1922-modpow-to-avoid-tle",
                "content": "---\\n\\nHave an optimal `modPow` libary to avoid TLE\\n\\n---\\n\\n**Algo**\\n- Find number of odds (`odds`), there can be only 4 primes (`2, 3, 5, or 7`)\\n- Find number of evens (`evens`), there can be only 5 evens (`0, 2, 4, 6, or 8`)\\n- Use an optimal `modPow` library, to find `(4^odds%(10^9)  *  5^evens%(10^9))  % (10^9)`\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nclass Math1 {\\n\\n    // https://en.wikipedia.org/wiki/Modular_exponentiation\\n    static modular_pow(base, exponent, modulus) {\\n        if (modulus === 1n)\\n            return 0n\\n        let result = 1n\\n        base = base % modulus\\n        while (exponent > 0n) {\\n            if (exponent % 2n == 1n)\\n                result = (result * base) % modulus\\n            exponent = exponent >> 1n\\n            base = (base * base) % modulus\\n        }\\n        return result\\n    }\\n\\n}\\n\\nvar countGoodNumbers = function(n) {\\n    // NOTE: 0n, 1n, 2n, 3n, 4n, 5n are numbers in BigInt\\n\\n    n = BigInt(n); // convert to BigInt, to avoid no rounding issues\\n\\n    const odds = n / 2n,\\n        evens = n - odds,\\n        MOD = BigInt(Math.pow(10, 9) + 7)\\n\\n    // from wikipedia\\n    return (Math1.modular_pow(4n, odds, MOD) * Math1.modular_pow(5n, evens, MOD)) % MOD;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b673f01b-8dec-4ac4-b02f-f950214de01a_1625386708.0581512.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Math1 {\\n\\n    // https://en.wikipedia.org/wiki/Modular_exponentiation\\n    static modular_pow(base, exponent, modulus) {\\n        if (modulus === 1n)\\n            return 0n\\n        let result = 1n\\n        base = base % modulus\\n        while (exponent > 0n) {\\n            if (exponent % 2n == 1n)\\n                result = (result * base) % modulus\\n            exponent = exponent >> 1n\\n            base = (base * base) % modulus\\n        }\\n        return result\\n    }\\n\\n}\\n\\nvar countGoodNumbers = function(n) {\\n    // NOTE: 0n, 1n, 2n, 3n, 4n, 5n are numbers in BigInt\\n\\n    n = BigInt(n); // convert to BigInt, to avoid no rounding issues\\n\\n    const odds = n / 2n,\\n        evens = n - odds,\\n        MOD = BigInt(Math.pow(10, 9) + 7)\\n\\n    // from wikipedia\\n    return (Math1.modular_pow(4n, odds, MOD) * Math1.modular_pow(5n, evens, MOD)) % MOD;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314700,
                "title": "go-fast-power-0ms",
                "content": "```\\nfunc countGoodNumbers(n int64) int {\\n    if n == 1 {\\n        return 5\\n    }\\n    \\n    var mod int64 = 1000000007\\n    return int((pow(5, (n+1)/2, mod)*pow(4, n/2, mod))% mod)\\n}\\n\\nfunc pow(a, b, mod int64) int64 {\\n    if b == 0 {\\n        return 1\\n    }\\n    \\n    x := pow(a, b/2, mod)\\n    if(b % 2 == 0) {\\n        return (x * x) % mod\\n    }\\n\\n    return (((a * x) % mod) * x) % mod\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countGoodNumbers(n int64) int {\\n    if n == 1 {\\n        return 5\\n    }\\n    \\n    var mod int64 = 1000000007\\n    return int((pow(5, (n+1)/2, mod)*pow(4, n/2, mod))% mod)\\n}\\n\\nfunc pow(a, b, mod int64) int64 {\\n    if b == 0 {\\n        return 1\\n    }\\n    \\n    x := pow(a, b/2, mod)\\n    if(b % 2 == 0) {\\n        return (x * x) % mod\\n    }\\n\\n    return (((a * x) % mod) * x) % mod\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1314585,
                "title": "javascript-recursion-to-divide-in-half-to-calc-math-pow",
                "content": "Error one during contest, can NOT directly use Math.pow(), since, it\\'s out of the **number** range: `2^53 - 1`\\n```js\\n// WRONG\\nvar ans = BigInt(Math.pow(5, even)) * BigInt(Math.pow(4, odd));\\n```\\n\\n**Fixed:** to use recursion build up the math.pow and use `BigInt`\\n```js\\nvar countGoodNumbers = function(n) {\\n    var mod = 1000000007n;\\n    var even = Math.ceil(n/2);\\n    var odd = n - even; \\n    function myPow(x,y)\\n    {\\n        if(y===0)\\n        {\\n            return 1n;\\n        }\\n        var res = 1n;\\n        res *= myPow(x, Math.floor(y/2)); // cut in half in each recursion\\n        res *= res;\\n        if(y%2===1)\\n        {\\n            res *= BigInt(x);\\n        }\\n        res %= mod;\\n        return res;\\n    }\\n    var ans = myPow(5, even) * myPow(4, odd);\\n    ans %= mod; \\n    return Number(ans);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n// WRONG\\nvar ans = BigInt(Math.pow(5, even)) * BigInt(Math.pow(4, odd));\\n```\n```js\\nvar countGoodNumbers = function(n) {\\n    var mod = 1000000007n;\\n    var even = Math.ceil(n/2);\\n    var odd = n - even; \\n    function myPow(x,y)\\n    {\\n        if(y===0)\\n        {\\n            return 1n;\\n        }\\n        var res = 1n;\\n        res *= myPow(x, Math.floor(y/2)); // cut in half in each recursion\\n        res *= res;\\n        if(y%2===1)\\n        {\\n            res *= BigInt(x);\\n        }\\n        res %= mod;\\n        return res;\\n    }\\n    var ans = myPow(5, even) * myPow(4, odd);\\n    ans %= mod; \\n    return Number(ans);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314545,
                "title": "c-0ms-100-time-complexity-5-even-indices-4-odd-indices-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long MOD=1000000007;\\n    int MAX=100000;\\n    long long powerLL(long long  x, long long n)\\n{\\n    long long result = 1;\\n    while (n) {\\n        if (n & 1)\\n            result = result * x % MOD;\\n        n = n / 2;\\n        x = x * x % MOD;\\n    }\\n    return result;\\n}\\n \\n// Returns modulo exponentiation for two numbers\\n// represented as strings. It is used by\\n// powerStrings()\\nlong long powerstring(string sa, string sb)\\n{\\n    // We convert strings to number\\n \\n    long long  a = 0, b = 0;\\n \\n    // calculating  a % MOD\\n    for (int i = 0; i < sa.length(); i++)\\n        a = (a * 10 + (sa[i] - \\'0\\')) % MOD;\\n \\n    // calculating  b % (MOD - 1)\\n    for (int i = 0; i < sb.length(); i++)\\n        b = (b * 10 + (sb[i] - \\'0\\')) % (MOD - 1);\\n \\n    // Now a and b are long long int. We\\n    // calculate a^b using modulo exponentiation\\n    return powerLL(a, b);\\n}    \\n    \\n    \\n    \\n    \\n    int countGoodNumbers(long long n) {\\n        if(n==1) return 5;\\n      //  cout<<mod<<endl;\\n        string s1=to_string(5);\\n            string s2=to_string(4);\\n            string s3=to_string(n/2);\\n            string s4=to_string(n/2+1);\\n        if(n%2==0){\\n            \\n            int prod= (powerstring(s1,s3) * powerstring(s2,s3))%MOD;\\n            return prod;\\n        }else{\\n            int prod= (powerstring(s1,s4) * powerstring(s2,s3))%MOD;\\n            return prod;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long MOD=1000000007;\\n    int MAX=100000;\\n    long long powerLL(long long  x, long long n)\\n{\\n    long long result = 1;\\n    while (n) {\\n        if (n & 1)\\n            result = result * x % MOD;\\n        n = n / 2;\\n        x = x * x % MOD;\\n    }\\n    return result;\\n}\\n \\n// Returns modulo exponentiation for two numbers\\n// represented as strings. It is used by\\n// powerStrings()\\nlong long powerstring(string sa, string sb)\\n{\\n    // We convert strings to number\\n \\n    long long  a = 0, b = 0;\\n \\n    // calculating  a % MOD\\n    for (int i = 0; i < sa.length(); i++)\\n        a = (a * 10 + (sa[i] - \\'0\\')) % MOD;\\n \\n    // calculating  b % (MOD - 1)\\n    for (int i = 0; i < sb.length(); i++)\\n        b = (b * 10 + (sb[i] - \\'0\\')) % (MOD - 1);\\n \\n    // Now a and b are long long int. We\\n    // calculate a^b using modulo exponentiation\\n    return powerLL(a, b);\\n}    \\n    \\n    \\n    \\n    \\n    int countGoodNumbers(long long n) {\\n        if(n==1) return 5;\\n      //  cout<<mod<<endl;\\n        string s1=to_string(5);\\n            string s2=to_string(4);\\n            string s3=to_string(n/2);\\n            string s4=to_string(n/2+1);\\n        if(n%2==0){\\n            \\n            int prod= (powerstring(s1,s3) * powerstring(s2,s3))%MOD;\\n            return prod;\\n        }else{\\n            int prod= (powerstring(s1,s4) * powerstring(s2,s3))%MOD;\\n            return prod;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1314437,
                "title": "cpp-solution-simple-logic-fast-exponentiation",
                "content": "```\\nclass Solution {\\npublic:    \\n    long long fastPow(long long x, long long y)\\n    {\\n        long long res = 1;\\n        x = x % MOD;\\n        if (x == 0) return 0;\\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x) % MOD;\\n\\n            y = y>>1;\\n            x = (x*x) % MOD;\\n        }\\n        return res;\\n    }\\n    \\n    const int MOD=1e9+7;\\n    int countGoodNumbers(long long n) {\\n        int eCount=5, pCount=4;\\n        long long result=0, k=0;\\n        if(n&1){\\n            k=n/2;\\n            result=((fastPow(5, k+1)%MOD)*(fastPow(4, k)%MOD))%MOD;\\n        }else{\\n            k=n/2;\\n            result=((fastPow(5, k)%MOD)*(fastPow(4, k)%MOD))%MOD;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    long long fastPow(long long x, long long y)\\n    {\\n        long long res = 1;\\n        x = x % MOD;\\n        if (x == 0) return 0;\\n\\n        while (y > 0)\\n        {\\n            if (y & 1)\\n                res = (res*x) % MOD;\\n\\n            y = y>>1;\\n            x = (x*x) % MOD;\\n        }\\n        return res;\\n    }\\n    \\n    const int MOD=1e9+7;\\n    int countGoodNumbers(long long n) {\\n        int eCount=5, pCount=4;\\n        long long result=0, k=0;\\n        if(n&1){\\n            k=n/2;\\n            result=((fastPow(5, k+1)%MOD)*(fastPow(4, k)%MOD))%MOD;\\n        }else{\\n            k=n/2;\\n            result=((fastPow(5, k)%MOD)*(fastPow(4, k)%MOD))%MOD;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314428,
                "title": "clean-c-code-binary-exponentiation-easy-pow-function",
                "content": "```\\nint mod=1e9+7;\\n    long long pow(int x , long long y){\\n        if(y==0) return 1;\\n        long long ans=pow(x,y/2)%mod;\\n        if(y%2==1) return ans*ans*x;\\n        return ((ans%mod)*(ans%mod))%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=(n+1)/2;\\n        long long odd=n-even;\\n        long long x=(pow(5,even)%mod);\\n        long long y=(pow(4,odd)%mod);\\n        long long ans= (x*y)%mod;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint mod=1e9+7;\\n    long long pow(int x , long long y){\\n        if(y==0) return 1;\\n        long long ans=pow(x,y/2)%mod;\\n        if(y%2==1) return ans*ans*x;\\n        return ((ans%mod)*(ans%mod))%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=(n+1)/2;\\n        long long odd=n-even;\\n        long long x=(pow(5,even)%mod);\\n        long long y=(pow(4,odd)%mod);\\n        long long ans= (x*y)%mod;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314407,
                "title": "c-easy-fast-power-with-modulo-a-b-mod-c",
                "content": "```\\nclass Solution {\\npublic:\\n    const long long MOD = 1000000007;\\n\\n    long long mul(long long a, long long x, long long p)\\n    {\\n        if (x == 0) return 1;\\n        long long res = mul(a,x/2,p);\\n        res = res * res % p;\\n        if (x%2)\\n            res = res * a  % p;\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long pe = n/2 + n%2, po = (n/2);\\n        return mul(5,pe,MOD) * mul(4,po,MOD) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long MOD = 1000000007;\\n\\n    long long mul(long long a, long long x, long long p)\\n    {\\n        if (x == 0) return 1;\\n        long long res = mul(a,x/2,p);\\n        res = res * res % p;\\n        if (x%2)\\n            res = res * a  % p;\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long pe = n/2 + n%2, po = (n/2);\\n        return mul(5,pe,MOD) * mul(4,po,MOD) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314339,
                "title": "c-explained-modulo-power-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // 0 2 4 6 8 even\\n\\t// 2 3 5 7   prime\\n    // n=5 =>   5*4*5*4*5\\n    \\n    \\n    long long int MOD = 1e9+7;\\n    long long int powerLL(long long int x, long long n){\\n        long long int result = 1;\\n        while (n) {\\n            if (n & 1)\\n                result = (result * x) % MOD;\\n                n = n / 2;\\n                x = (x * x) % MOD;\\n            }\\n            return result;\\n    }\\n    int countGoodNumbers(long long n) {\\n        // count total digit even and total digit odd places\\n\\t\\t// we can put any number out of 5 at every even place\\n\\t\\t// we can put any number out of 4 at every odd place\\n        long long int even = 5, prime = 4;\\n        if(n == 1)return 5;\\n        if(n == 2)return 20;\\n        long long int ans = 20;\\n        long long int evenPlace = n/2 + n%2, oddPlace = n/2;\\n        long long int res1 = powerLL(5, evenPlace);    // we have 5 choice at every even place\\n        long long int res2 = powerLL(4, oddPlace);      // we have 4 choice at every odd place\\n        return (res1*res2)%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // 0 2 4 6 8 even\\n\\t// 2 3 5 7   prime\\n    // n=5 =>   5*4*5*4*5\\n    \\n    \\n    long long int MOD = 1e9+7;\\n    long long int powerLL(long long int x, long long n){\\n        long long int result = 1;\\n        while (n) {\\n            if (n & 1)\\n                result = (result * x) % MOD;\\n                n = n / 2;\\n                x = (x * x) % MOD;\\n            }\\n            return result;\\n    }\\n    int countGoodNumbers(long long n) {\\n        // count total digit even and total digit odd places\\n\\t\\t// we can put any number out of 5 at every even place\\n\\t\\t// we can put any number out of 4 at every odd place\\n        long long int even = 5, prime = 4;\\n        if(n == 1)return 5;\\n        if(n == 2)return 20;\\n        long long int ans = 20;\\n        long long int evenPlace = n/2 + n%2, oddPlace = n/2;\\n        long long int res1 = powerLL(5, evenPlace);    // we have 5 choice at every even place\\n        long long int res2 = powerLL(4, oddPlace);      // we have 4 choice at every odd place\\n        return (res1*res2)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314332,
                "title": "java-recursion-memoization",
                "content": "First some basics:\\n1. Every even position has 5 potential values: 0, 2, 4, 5, 6, 8\\n2. Every odd position has 4 potential values: 12, 3, 5, 7\\n\\nThe idea is to divide the problem by half in each recursive call. It\\'s important to keep the start digit correct for the recursion to work. For e.g.\\n\\n* n = 6, start changes for the second half\\n\\n```\\n5, 4, 5, 4, 5, 4\\n```\\n\\nThis gets split into \\n\\n```\\n5, 4, 5\\n```\\nand \\n```\\n4, 5, 4\\n```\\n\\n* n=7 start doesn\\'t change for the second half\\n\\n```\\n5, 4, 5, 4, 5, 4, 5\\n```\\n\\n```\\n5, 4, 5, 4\\n```\\nand \\n```\\n5, 4, 5\\n```\\n\\n* Memoization is pretty straight forward.\\n\\nHope this helps :D\\n\\n```\\nclass Solution {\\n    \\n    private static int M = 1_000_000_007;\\n    private static HashMap<String, Long> cache;\\n\\n    public int countGoodNumbers(long n) {\\n        cache = new HashMap<>();\\n        return (int) helper(n, 5);\\n    }\\n    \\n    private long helper(long n, int start) {\\n        if (n == 1) {\\n            return start;\\n        }\\n        \\n        if (n == 2) {\\n            return 20;\\n        }\\n        \\n        String key = getKey(n, start);\\n        \\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        long res = 1;\\n        if (n % 2 == 1) {\\n            res = (helper(n/2 + 1, start) % M * helper(n/2, start) % M) % M;        \\n        } else {\\n            if (start == 4) {\\n                res = (helper(n/2, 4) % M * helper(n/2, 5) % M) % M;        \\n            } else {\\n                res = (helper(n/2, 5) % M * helper(n/2, 4) % M) % M;    \\n            }\\n        }\\n        \\n        cache.put(key, res);\\n        return res;\\n    }\\n    \\n    private String getKey(long n, int start) {\\n        return n + \":\" + start;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n5, 4, 5, 4, 5, 4\\n```\n```\\n5, 4, 5\\n```\n```\\n4, 5, 4\\n```\n```\\n5, 4, 5, 4, 5, 4, 5\\n```\n```\\n5, 4, 5, 4\\n```\n```\\n5, 4, 5\\n```\n```\\nclass Solution {\\n    \\n    private static int M = 1_000_000_007;\\n    private static HashMap<String, Long> cache;\\n\\n    public int countGoodNumbers(long n) {\\n        cache = new HashMap<>();\\n        return (int) helper(n, 5);\\n    }\\n    \\n    private long helper(long n, int start) {\\n        if (n == 1) {\\n            return start;\\n        }\\n        \\n        if (n == 2) {\\n            return 20;\\n        }\\n        \\n        String key = getKey(n, start);\\n        \\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        long res = 1;\\n        if (n % 2 == 1) {\\n            res = (helper(n/2 + 1, start) % M * helper(n/2, start) % M) % M;        \\n        } else {\\n            if (start == 4) {\\n                res = (helper(n/2, 4) % M * helper(n/2, 5) % M) % M;        \\n            } else {\\n                res = (helper(n/2, 5) % M * helper(n/2, 4) % M) % M;    \\n            }\\n        }\\n        \\n        cache.put(key, res);\\n        return res;\\n    }\\n    \\n    private String getKey(long n, int start) {\\n        return n + \":\" + start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314321,
                "title": "c-easy-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long get_pow(long base, long pow) {\\n        if (pow == 0) {\\n            return 1L;\\n        }\\n        \\n        if (pow % 2 == 0) {\\n            long half = get_pow(base, pow / 2) % 1000000007;\\n            \\n            return (half * half) % 1000000007;\\n        } else {\\n            return (get_pow(base, pow - 1) * base) % 1000000007;\\n        }\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        long even_count = n / 2 + n % 2;\\n        long odd_count = n / 2;\\n        \\n        return (get_pow(5, even_count) * get_pow(4, odd_count)) % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long get_pow(long base, long pow) {\\n        if (pow == 0) {\\n            return 1L;\\n        }\\n        \\n        if (pow % 2 == 0) {\\n            long half = get_pow(base, pow / 2) % 1000000007;\\n            \\n            return (half * half) % 1000000007;\\n        } else {\\n            return (get_pow(base, pow - 1) * base) % 1000000007;\\n        }\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        long even_count = n / 2 + n % 2;\\n        long odd_count = n / 2;\\n        \\n        return (get_pow(5, even_count) * get_pow(4, odd_count)) % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106688,
                "title": "basic-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define MOD 1000000007\\n#define ll long long \\nclass Solution {\\npublic:\\n\\n\\nll power(ll x,ll y){\\n    if(x==0)return 1;\\n   ll ans=power(x/2,y);\\n    ans*=ans;\\n    ans%=MOD;\\n    if(x%2)ans*=y;\\n    ans%=MOD;\\n    return ans;\\n}\\n    int countGoodNumbers(ll n) {\\n        ll odd=n/2;\\n     ll even=n/2+n%2;\\n        return (power(odd,4)*power(even,5))%MOD;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MOD 1000000007\\n#define ll long long \\nclass Solution {\\npublic:\\n\\n\\nll power(ll x,ll y){\\n    if(x==0)return 1;\\n   ll ans=power(x/2,y);\\n    ans*=ans;\\n    ans%=MOD;\\n    if(x%2)ans*=y;\\n    ans%=MOD;\\n    return ans;\\n}\\n    int countGoodNumbers(ll n) {\\n        ll odd=n/2;\\n     ll even=n/2+n%2;\\n        return (power(odd,4)*power(even,5))%MOD;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101480,
                "title": "recursion-with-binary-exponentiation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe main logic is if number is 1 return 5\\nelse for any other number it is 5^(n+1//2)x4^(n//2)\\nif n is 2 the output is 5x4=20\\nif n is 3 the output is 25x4=100\\nbcous the values 4 and 5 are constant and repeated.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing recursion we find the 5 power n+1//2 and 4 power n//2\\nand multiply both\\nnow in recursion -->\\nuse a divide-and-conquer approach to calculate the power:Calculate know as the power of N to the R // 2, modulo 1000000007.\\nIf R is odd, multiply ans by N and take modulo 1000000007.\\nFinally, return (ans * ((know * know) % 1000000007)) % 1000000007.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def power(self, N, R):\\n        if R == 0:\\n            return 1\\n        \\n        if R == 1:\\n            return N \\n        \\n        ans = 1\\n        know = self.power(N, R // 2) \\n        \\n        if R % 2:\\n            ans = (ans * N) \\n        \\n        return (ans * ((know * know) ))  % 1000000007\\n\\n    def countGoodNumbers(self, n):\\n        # Calculate power of 5 and 4 and return their product modulo 1000000007\\n        return (self.power(5, (n + 1) // 2) * self.power(4, n // 2)) % 1000000007\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def power(self, N, R):\\n        if R == 0:\\n            return 1\\n        \\n        if R == 1:\\n            return N \\n        \\n        ans = 1\\n        know = self.power(N, R // 2) \\n        \\n        if R % 2:\\n            ans = (ans * N) \\n        \\n        return (ans * ((know * know) ))  % 1000000007\\n\\n    def countGoodNumbers(self, n):\\n        # Calculate power of 5 and 4 and return their product modulo 1000000007\\n        return (self.power(5, (n + 1) // 2) * self.power(4, n // 2)) % 1000000007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100136,
                "title": "c-beat-100-iterative-recursive",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom 0 to 9 there are 10 positions\\nout of which `n/2` are odds ie `10/2 = 5` and `(n+1)/2` are even i.e `11/2 = 5`\\n\\n`odd indices : 1, 3, 5, 7, 9`\\n`even indices : 0, 2, 4, 6, 8`\\n\\nSuppose we take `2,3,4` then `even index : 0,2` and `odd index : 1`\\n\\nSo we have `5 options` i.e `0,2,4,6,8 : even numbers` for even indices\\nfor odd indices we can have `4 options` i.e `2,3,5,7 : prime numbers`\\n\\nTherefore for string of even length we have $$(20 ^n/2)$$ \\nFor odd length we have  $$(20 ^n/2)*5$$\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code (Iterative) : \\u2714\\uFE0F Accepted\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    long long binExp(long long base, long long power) {\\n        long long ans = 1;\\n        while(power>0){\\n            if(power&1) ans = (ans*base)%MOD;\\n            base = (base*base)%MOD;\\n            power >>=  1;\\n        }\\n        return ans;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long res = binExp(20, n/2);\\n        if(n&1) return (res*5)%MOD;\\n        else return res;\\n    }\\n};\\n```\\n\\n# Code (Recursive) : \\u2714\\uFE0F Accepted\\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    long long binExp(long long base, long long power) {\\n        if (power == 0) return 1;\\n        long long result = binExp(base, power / 2);\\n        result = (result * result) % MOD;\\n        if (power&1) result = (result * base) % MOD;\\n        return result;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long res = binExp(20, n/2);\\n        if(n&1) return (res*5)%MOD;\\n        else return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    long long binExp(long long base, long long power) {\\n        long long ans = 1;\\n        while(power>0){\\n            if(power&1) ans = (ans*base)%MOD;\\n            base = (base*base)%MOD;\\n            power >>=  1;\\n        }\\n        return ans;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long res = binExp(20, n/2);\\n        if(n&1) return (res*5)%MOD;\\n        else return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    const int MOD = 1e9+7;\\n    long long binExp(long long base, long long power) {\\n        if (power == 0) return 1;\\n        long long result = binExp(base, power / 2);\\n        result = (result * result) % MOD;\\n        if (power&1) result = (result * base) % MOD;\\n        return result;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long res = binExp(20, n/2);\\n        if(n&1) return (res*5)%MOD;\\n        else return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086318,
                "title": "not-using-pow-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlong long power(long long x, long long n,long long mod) {\\n    long long ans = 1; \\n    long long mn = n;\\n\\n    if (mn < 0)\\n        mn = -1 * mn;\\n\\n    while (mn > 0) {\\n        if (mn % 2 != 0) {\\n            ans = (ans * x)%mod;\\n           mn = mn - 1;\\n        } else if (mn % 2 == 0) {\\n            x = (x * x)%mod;\\n            mn = mn / 2;\\n        }\\n    }\\n\\n    if (n < 0) {\\n        ans = 1 / ans;\\n    }\\n\\n    return ans;\\n}\\nint countGoodNumbers(long long n) {\\n    long long mod = 1000000007;\\n    long long e = n / 2 + n % 2;\\n    long long o = n / 2;\\n\\n    long long an= (power(5,e,mod)*power(4,o,mod))%mod;\\n    return an;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long power(long long x, long long n,long long mod) {\\n    long long ans = 1; \\n    long long mn = n;\\n\\n    if (mn < 0)\\n        mn = -1 * mn;\\n\\n    while (mn > 0) {\\n        if (mn % 2 != 0) {\\n            ans = (ans * x)%mod;\\n           mn = mn - 1;\\n        } else if (mn % 2 == 0) {\\n            x = (x * x)%mod;\\n            mn = mn / 2;\\n        }\\n    }\\n\\n    if (n < 0) {\\n        ans = 1 / ans;\\n    }\\n\\n    return ans;\\n}\\nint countGoodNumbers(long long n) {\\n    long long mod = 1000000007;\\n    long long e = n / 2 + n % 2;\\n    long long o = n / 2;\\n\\n    long long an= (power(5,e,mod)*power(4,o,mod))%mod;\\n    return an;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068828,
                "title": "what-is-1-000-000-007-answered-fastest-solution-best-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n// /*\\n//     Approach : \\n\\n//     if n is even then  -> even places = n/2 \\n//                         -> odd places = n/2 \\n//     if n is even then  -> even places = n/2+1 \\n//                         -> odd places = n/2 \\n\\n//     Choices : // since a num digit can be only form 0-9 so , \\n//         even \"0\", \"2\", \"4\", \"6\", \"8\"\\n//         prime \"2\",\"3\",\"5\",\"7\" \\n    \\n\\n\\n// */\\n\\nclass Solution {\\n    \\n    // Define MOD as a class variable for easier reference and readability\\n    public long MOD = 1_000_000_007;//what is mod defined below \\n    \\n    public int countGoodNumbers(long n) {\\n        \\n        // Calculate the number of even and odd positions in the digit string\\n        long odd = n/2;\\n        long even = (n+1)/2;\\n        \\n        // Calculate the total number of good digit strings\\n        // multiplying 5 by even because there could only be 5 even numbers between 0-9\\n        // multiplying 4 by odd because there could only be 4 prime numbers between 0-9\\n        return (int)(pow(5,even) * pow(4,odd) % MOD);\\n    }\\n    \\n    public long pow(long x, long n){\\n        \\n        // Base case for the recursion\\n        if(n==0) \\n            return 1;\\n        \\n        // Recursively calculate x^(n/2)\\n        long temp = pow(x,n/2);\\n        \\n        // If n is even, return (x^(n/2))^2\\n        if(n%2==0){\\n            return (temp * temp)% MOD;\\n        }\\n        // If n is odd, return (x^(n/2))^2 * x\\n        else{\\n            return (x * temp * temp)% MOD;\\n        }\\n    }\\n}\\n```\\n# What is MOD  ? \\n- it is a  prime number which is use to deal with the interger overflow condition \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// /*\\n//     Approach : \\n\\n//     if n is even then  -> even places = n/2 \\n//                         -> odd places = n/2 \\n//     if n is even then  -> even places = n/2+1 \\n//                         -> odd places = n/2 \\n\\n//     Choices : // since a num digit can be only form 0-9 so , \\n//         even \"0\", \"2\", \"4\", \"6\", \"8\"\\n//         prime \"2\",\"3\",\"5\",\"7\" \\n    \\n\\n\\n// */\\n\\nclass Solution {\\n    \\n    // Define MOD as a class variable for easier reference and readability\\n    public long MOD = 1_000_000_007;//what is mod defined below \\n    \\n    public int countGoodNumbers(long n) {\\n        \\n        // Calculate the number of even and odd positions in the digit string\\n        long odd = n/2;\\n        long even = (n+1)/2;\\n        \\n        // Calculate the total number of good digit strings\\n        // multiplying 5 by even because there could only be 5 even numbers between 0-9\\n        // multiplying 4 by odd because there could only be 4 prime numbers between 0-9\\n        return (int)(pow(5,even) * pow(4,odd) % MOD);\\n    }\\n    \\n    public long pow(long x, long n){\\n        \\n        // Base case for the recursion\\n        if(n==0) \\n            return 1;\\n        \\n        // Recursively calculate x^(n/2)\\n        long temp = pow(x,n/2);\\n        \\n        // If n is even, return (x^(n/2))^2\\n        if(n%2==0){\\n            return (temp * temp)% MOD;\\n        }\\n        // If n is odd, return (x^(n/2))^2 * x\\n        else{\\n            return (x * temp * temp)% MOD;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054690,
                "title": "recursive-java-code",
                "content": "recur\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log n) due to recursive calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        long even = (n+1)/2;\\n        long odd = n/2;\\n        long first = pow(5,even)%MOD;\\n        long second = pow(4,odd)%MOD;\\n        return (int)((first*second)%MOD);\\n    }                     \\n    private long pow(long x,long n)\\n    {\\n        if(n==0)return 1;\\n        long temp = pow(x,n/2);\\n        if(n%2==0)\\n        {\\n            return (temp*temp)%MOD;\\n        }        \\n        return (x*temp*temp)%MOD;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private long MOD = 1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        long even = (n+1)/2;\\n        long odd = n/2;\\n        long first = pow(5,even)%MOD;\\n        long second = pow(4,odd)%MOD;\\n        return (int)((first*second)%MOD);\\n    }                     \\n    private long pow(long x,long n)\\n    {\\n        if(n==0)return 1;\\n        long temp = pow(x,n/2);\\n        if(n%2==0)\\n        {\\n            return (temp*temp)%MOD;\\n        }        \\n        return (x*temp*temp)%MOD;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047511,
                "title": "easy-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    const long long MOD = 1e9 + 7;\\n    long long power(long long x, long long n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        long long ans = power(x, n/2);\\n        ans *= ans;\\n        ans %= MOD;\\n        if(n%2==1){\\n            ans *= x;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n    \\n        long long even = (n/2) + (n%2);\\n        long long odd = n/2;\\n\\n        return (power(5,even) * power(4,odd))%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    const long long MOD = 1e9 + 7;\\n    long long power(long long x, long long n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        long long ans = power(x, n/2);\\n        ans *= ans;\\n        ans %= MOD;\\n        if(n%2==1){\\n            ans *= x;\\n            ans %= MOD;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n    \\n        long long even = (n/2) + (n%2);\\n        long long odd = n/2;\\n\\n        return (power(5,even) * power(4,odd))%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044781,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodNumbers(long n) {\\n        long ans=0;\\n        int k=(int)Math.pow(10,9)+7;\\n        long i=n/2;\\n        long j=n/2+n%2;\\n        System.out.print(i+\"\"+j);\\n        return (int)(pow(5,j,k)*pow(4,i,k)%k);\\n    }\\n    public long pow(int x,long y,int k){\\n        if(y==0){\\n            return 1;\\n        }\\n        long ans=pow(x,y/2,k);\\n        ans*=ans;\\n        ans%=k;\\n        if(y%2==1){\\n        ans*=x;\\n        ans%=k;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodNumbers(long n) {\\n        long ans=0;\\n        int k=(int)Math.pow(10,9)+7;\\n        long i=n/2;\\n        long j=n/2+n%2;\\n        System.out.print(i+\"\"+j);\\n        return (int)(pow(5,j,k)*pow(4,i,k)%k);\\n    }\\n    public long pow(int x,long y,int k){\\n        if(y==0){\\n            return 1;\\n        }\\n        long ans=pow(x,y/2,k);\\n        ans*=ans;\\n        ans%=k;\\n        if(y%2==1){\\n        ans*=x;\\n        ans%=k;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029520,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int countGoodNumbers(long long n) {\\n    return modPow(4 * 5, n / 2) * (n & 1 ? 5 : 1) % kMod;\\n  }\\n\\n private:\\n  static constexpr int kMod = 1\\'000\\'000\\'007;\\n\\n  long modPow(long x, long n) {\\n    if (n == 0)\\n      return 1;\\n    if (n & 1)\\n      return x * modPow(x, n - 1) % kMod;\\n    return modPow(x * x % kMod, n / 2);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int countGoodNumbers(long long n) {\\n    return modPow(4 * 5, n / 2) * (n & 1 ? 5 : 1) % kMod;\\n  }\\n\\n private:\\n  static constexpr int kMod = 1\\'000\\'000\\'007;\\n\\n  long modPow(long x, long n) {\\n    if (n == 0)\\n      return 1;\\n    if (n & 1)\\n      return x * modPow(x, n - 1) % kMod;\\n    return modPow(x * x % kMod, n / 2);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024011,
                "title": "clean-recursive-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int countGoodNumbers(long n) {\\n        long ans = 1;\\n        if (n % 2 == 0) {\\n            return (int) ((pow(5, n / 2, ans) * pow(4, n / 2, ans)) % 1000000007);\\n        }\\n        else {\\n            return (int) ((pow(5, (n / 2) + 1, ans) * pow(4, n / 2, ans)) % 1000000007);\\n        }\\n    }\\n\\n    private long pow(long a, long n, long ans) {\\n        if (n == 0) {\\n            return ans;\\n        }\\n        if (n % 2 == 0) {\\n            return pow((a * a) % 1000000007, n / 2, ans);\\n        } \\n        else {\\n            return pow(a, n - 1, (ans * a) % 1000000007);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int countGoodNumbers(long n) {\\n        long ans = 1;\\n        if (n % 2 == 0) {\\n            return (int) ((pow(5, n / 2, ans) * pow(4, n / 2, ans)) % 1000000007);\\n        }\\n        else {\\n            return (int) ((pow(5, (n / 2) + 1, ans) * pow(4, n / 2, ans)) % 1000000007);\\n        }\\n    }\\n\\n    private long pow(long a, long n, long ans) {\\n        if (n == 0) {\\n            return ans;\\n        }\\n        if (n % 2 == 0) {\\n            return pow((a * a) % 1000000007, n / 2, ans);\\n        } \\n        else {\\n            return pow(a, n - 1, (ans * a) % 1000000007);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020346,
                "title": "very-very-easy-solution-o-logn-beginners-freiendly-java-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount Good Numbers :\\n\\nThis method takes an integer n as input, representing the length of the digit string.\\nIt calculates first as the number of even positions (0-indexed) by checking whether n is even or odd. If n is even, it uses n/2, and if it\\'s odd, it uses (n/2) + 1. This is because even positions can have even digits, and we need to consider this.\\nIt calculates second as the number of odd positions by using n/2, as odd positions can have prime digits.\\nIt calculates res1 as 5^first modulo mod using the pow function, where 5 represents the count of even digits (0, 2, 4, 6, 8).\\nIt calculates res2 as 4^second modulo mod using the pow function, where 4 represents the count of prime digits (2, 3, 5, 7).\\nIt initializes ans to 1.\\nIt multiplies ans by res1 modulo mod. If second is not 0, it also multiplies ans by res2 modulo mod. These multiplications are done modulo mod to avoid integer overflow.\\nFinally, it returns (int)ans % mod to ensure the result is within the bounds of a 32-bit integer and is modulo mod.\\npow method:\\n\\nThis is a helper method that calculates x^n modulo mod using recursive exponentiation.\\nIt has base cases to handle when n is 0 or when n is even (to optimize the computation by halving n).\\nWhen n is odd, it uses recursion to calculate x^n as x * x^(n-1) modulo mod.\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //modulo\\n    int mod=(int)1e9+7;\\n    public int countGoodNumbers(long n) {\\n\\n        //calculate first number power\\n        long first=n%2==0?n/2:(n/2)+1;\\n        //second\\n        long second=n/2;\\n        //calculate power\\n        long  res1=pow(5,first)%mod; \\n        long res2=pow(4,second)%mod; \\n        long ans=1;\\n        ans=(res1*ans)%mod; \\n        ans=(second!=0)?(ans*res2)%mod:ans;\\n        return (int)ans%mod  ;\\n    }\\n\\n    public long pow(long x,long n){\\n\\n        //for base condition if n becomes 0 return 1\\n        if(n==0)return 1;\\n        //if n is even then retun x*x and n/2 as it reduces time complexity to O(log n)\\n        if(n%2==0)return pow(x*x%mod,n/2)%mod; \\n        //if n is odd then retun x*myPow(x,n-1) \\n        return(x%mod*pow(x,n-1))%mod;\\n\\n    }\\n     \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    //modulo\\n    int mod=(int)1e9+7;\\n    public int countGoodNumbers(long n) {\\n\\n        //calculate first number power\\n        long first=n%2==0?n/2:(n/2)+1;\\n        //second\\n        long second=n/2;\\n        //calculate power\\n        long  res1=pow(5,first)%mod; \\n        long res2=pow(4,second)%mod; \\n        long ans=1;\\n        ans=(res1*ans)%mod; \\n        ans=(second!=0)?(ans*res2)%mod:ans;\\n        return (int)ans%mod  ;\\n    }\\n\\n    public long pow(long x,long n){\\n\\n        //for base condition if n becomes 0 return 1\\n        if(n==0)return 1;\\n        //if n is even then retun x*x and n/2 as it reduces time complexity to O(log n)\\n        if(n%2==0)return pow(x*x%mod,n/2)%mod; \\n        //if n is odd then retun x*myPow(x,n-1) \\n        return(x%mod*pow(x,n-1))%mod;\\n\\n    }\\n     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014868,
                "title": "o-log-n-time-complexity-beats-100-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    private:\\n     long long mod = 1e9+7;\\npublic:\\n    long long calculatePow(long long x , long long n){\\n        long long res = 1;\\n        while(n){\\n            if(n%2){\\n                res = (res*x);\\n                res = res%mod;\\n                n = n-1;\\n            }\\n            else{\\n                x = (x*x)%mod;\\n                n = n/2;\\n            }\\n        }\\n        return res%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long  odd = n/2;\\n        long long even= n/2 + n%2;\\n        return (calculatePow(5,even)*calculatePow(4,odd))%mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "```\\n\\nclass Solution {\\n    private:\\n     long long mod = 1e9+7;\\npublic:\\n    long long calculatePow(long long x , long long n){\\n        long long res = 1;\\n        while(n){\\n            if(n%2){\\n                res = (res*x);\\n                res = res%mod;\\n                n = n-1;\\n            }\\n            else{\\n                x = (x*x)%mod;\\n                n = n/2;\\n            }\\n        }\\n        return res%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long  odd = n/2;\\n        long long even= n/2 + n%2;\\n        return (calculatePow(5,even)*calculatePow(4,odd))%mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013779,
                "title": "easy-solution-in-c",
                "content": "\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    //Here i am only calculating the power\\n    long long power(long long x,long long y)\\n    {\\n        if(y==0)    return 1;\\n        long long ans = power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2)ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) \\n    {\\n        long long odd=n/2;\\n        long long even=n/2 + n%2;\\n        return (power(5,even)*power(4,odd))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    //Here i am only calculating the power\\n    long long power(long long x,long long y)\\n    {\\n        if(y==0)    return 1;\\n        long long ans = power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2)ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) \\n    {\\n        long long odd=n/2;\\n        long long even=n/2 + n%2;\\n        return (power(5,even)*power(4,odd))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013409,
                "title": "easy-recursive-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public static long mod = (int) (1000000007);\\n\\n    public int countGoodNumbers(long n) {\\n        // long mod=1_000_000_007;\\n//         int count=0;\\n//        for(double i=Math.pow(10,n)-1;i>=0;i--){\\n//            String s=Double.toString(i);\\n//            int len=s.length();\\n//            for(int j=0;j<len ;j++){\\n//               if(j%2==0 && (s.charAt(j)==\\'0\\' || s.charAt(j)==\\'2\\'|| s.charAt(j)==\\'4\\'||s.charAt(j)==\\'6\\'||s.charAt(j)==\\'8\\')){\\n// count ++;\\n//               }\\n//               else if(j%2!=0 && (s.charAt(j)==\\'1\\'|| s.charAt(j)==\\'3\\' || s.charAt(j)==\\'5\\'|| s.charAt(j)==\\'7\\')){\\n//                   count++;\\n//               }\\n//            }\\n//        } return count; \\n\\n     long even=(n+1)/2,odd=n/2;\\n     return (int)  (((powr(5,even))*powr(4,odd))%mod);\\n    \\n    }\\n    public  long powr(long num,long power){\\n        long ans=1;\\n        if(power==0){\\n            return 1;\\n        }\\n        ans= powr(num,power/2);\\n     \\n       if(power%2==0){\\n             return (ans*ans)%mod;\\n          \\n       }else{\\n return (num*ans*ans)%mod;\\n       }\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public static long mod = (int) (1000000007);\\n\\n    public int countGoodNumbers(long n) {\\n        // long mod=1_000_000_007;\\n//         int count=0;\\n//        for(double i=Math.pow(10,n)-1;i>=0;i--){\\n//            String s=Double.toString(i);\\n//            int len=s.length();\\n//            for(int j=0;j<len ;j++){\\n//               if(j%2==0 && (s.charAt(j)==\\'0\\' || s.charAt(j)==\\'2\\'|| s.charAt(j)==\\'4\\'||s.charAt(j)==\\'6\\'||s.charAt(j)==\\'8\\')){\\n// count ++;\\n//               }\\n//               else if(j%2!=0 && (s.charAt(j)==\\'1\\'|| s.charAt(j)==\\'3\\' || s.charAt(j)==\\'5\\'|| s.charAt(j)==\\'7\\')){\\n//                   count++;\\n//               }\\n//            }\\n//        } return count; \\n\\n     long even=(n+1)/2,odd=n/2;\\n     return (int)  (((powr(5,even))*powr(4,odd))%mod);\\n    \\n    }\\n    public  long powr(long num,long power){\\n        long ans=1;\\n        if(power==0){\\n            return 1;\\n        }\\n        ans= powr(num,power/2);\\n     \\n       if(power%2==0){\\n             return (ans*ans)%mod;\\n          \\n       }else{\\n return (num*ans*ans)%mod;\\n       }\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008463,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     long md =1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        long  v = (n+1)/2;\\n        long d = n/2;\\n\\n        return (int)(slv(5,v)* slv(4, d)% md);\\n        \\n    }\\n\\n   long  slv(long x ,long y){\\n        if(y ==0){\\n            return 1;\\n        }\\n\\n        long tm = slv(x , y/2);\\n\\n         if(y % 2 ==0 ){\\n            return (tm*tm)% md;\\n         }else\\n           return (x*tm*tm)%md;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     long md =1_000_000_007;\\n    public int countGoodNumbers(long n) {\\n        long  v = (n+1)/2;\\n        long d = n/2;\\n\\n        return (int)(slv(5,v)* slv(4, d)% md);\\n        \\n    }\\n\\n   long  slv(long x ,long y){\\n        if(y ==0){\\n            return 1;\\n        }\\n\\n        long tm = slv(x , y/2);\\n\\n         if(y % 2 ==0 ){\\n            return (tm*tm)% md;\\n         }else\\n           return (x*tm*tm)%md;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003162,
                "title": "neatly-coded-solution-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 5 possible even numbers from 0 - 9 and 4 possible prime numbers from 0 - 9\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the power function to return (5**even) * (4**odd) modulo (10**9)+7\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodNumbers(self, num: int) -> int:\\n\\n        mod = ((10 ** 9) + 7)\\n\\n        def myPow(x, n):\\n            if n == 0:\\n                return 1\\n            \\n            ans = myPow(x, n//2)\\n            ans *= ans\\n\\n            if n % 2 == 1:\\n                ans *= x\\n\\n            return ans % mod\\n        \\n\\n        odd = num // 2\\n        even = num - odd\\n        return (myPow(5, even) * myPow(4, odd)) % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, num: int) -> int:\\n\\n        mod = ((10 ** 9) + 7)\\n\\n        def myPow(x, n):\\n            if n == 0:\\n                return 1\\n            \\n            ans = myPow(x, n//2)\\n            ans *= ans\\n\\n            if n % 2 == 1:\\n                ans *= x\\n\\n            return ans % mod\\n        \\n\\n        odd = num // 2\\n        even = num - odd\\n        return (myPow(5, even) * myPow(4, odd)) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996263,
                "title": "c-solution-easy-way",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1000000007;\\n\\n    long long myPow(long long x, long long n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        long long ans = myPow(x, n/2);\\n        ans *= ans;\\n        ans %= mod;\\n        if(n & 1){\\n            ans *= x;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long int odd = n / 2;\\n        long long int even = n - odd;\\n\\n        return (myPow(5, even) * myPow(4, odd)) % mod;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1000000007;\\n\\n    long long myPow(long long x, long long n){\\n        if(n == 0){\\n            return 1;\\n        }\\n        long long ans = myPow(x, n/2);\\n        ans *= ans;\\n        ans %= mod;\\n        if(n & 1){\\n            ans *= x;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long int odd = n / 2;\\n        long long int even = n - odd;\\n\\n        return (myPow(5, even) * myPow(4, odd)) % mod;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994154,
                "title": "best-recursive-solution-java-beats-100-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long MOD = 1000000007;\\n\\n    public long power(long x, long y){\\n        if(y == 0){\\n            return 1;\\n        }\\n        long ans = power(x, y/2);\\n        ans *= ans;\\n        if(y%2 == 1){\\n            ans *= x;\\n        }\\n        return ans % MOD;\\n    }\\n    public int countGoodNumbers(long n) {\\n\\n        long odd = n/2;\\n        long even  = n - odd;\\n        return(int)(power(5,even)*power(4,odd) % MOD);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long MOD = 1000000007;\\n\\n    public long power(long x, long y){\\n        if(y == 0){\\n            return 1;\\n        }\\n        long ans = power(x, y/2);\\n        ans *= ans;\\n        if(y%2 == 1){\\n            ans *= x;\\n        }\\n        return ans % MOD;\\n    }\\n    public int countGoodNumbers(long n) {\\n\\n        long odd = n/2;\\n        long even  = n - odd;\\n        return(int)(power(5,even)*power(4,odd) % MOD);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993129,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: O(logN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic : \\n    long long solve(long long x, long long n){\\n        int mod = 1000000007;\\n        if(n == 0)\\n            return 1;\\n        \\n        long long ans = solve(x, n/2);\\n        ans *= ans;\\n        ans %= mod;\\n\\n        if(n % 2 == 1){\\n            ans *= x;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        int mod = 1000000007;\\n        long long odd = n/2;\\n        long long even = n/2 + n%2;\\n        return (solve(5, even) * solve(4, odd)) % mod;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/0bb48aee-c53f-463a-99c4-32d40955bb7a_1692653715.6692786.png)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic : \\n    long long solve(long long x, long long n){\\n        int mod = 1000000007;\\n        if(n == 0)\\n            return 1;\\n        \\n        long long ans = solve(x, n/2);\\n        ans *= ans;\\n        ans %= mod;\\n\\n        if(n % 2 == 1){\\n            ans *= x;\\n            ans %= mod;\\n        }\\n        return ans;\\n    }\\n    \\n    int countGoodNumbers(long long n) {\\n        int mod = 1000000007;\\n        long long odd = n/2;\\n        long long even = n/2 + n%2;\\n        return (solve(5, even) * solve(4, odd)) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989681,
                "title": "count-good-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought was the brute force , which can be done by traversing through the number with TC:O(n);\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> We can use the approach of x^n problem; \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n#define mod 1000000007;\\nclass Solution {\\npublic:\\n\\n    long long power(long long x,long long y){\\n        if(y==0) return 1;\\n        long long ans=power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2) ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even=n/2+n%2;\\n        return (power(5,even)*power(4,odd))%mod;// 5 even numbers are there between 0->9 and 4 prime number \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long power(long long x,long long y){\\n        if(y==0) return 1;\\n        long long ans=power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2) ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3986128,
                "title": "genuine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long  solve(long long a,long long int n,int mod)\\n    {\\n        if(n==0)\\n        return 1;\\n        if(n&1)\\n        {\\n            long long z=solve(a,n/2,mod)%mod;\\n            return (z%mod*z%mod*a%mod)%mod;\\n        }\\n        else\\n        {\\n            long long z=solve(a,n/2,mod)%mod;\\n            return (z%mod*z%mod)%mod;\\n        }\\n    }\\n    int countGoodNumbers(long long n) {\\n        //if power is odd, multiply with that number and reduce by 1\\n        //if pow id even, mul that number twice and n/2\\n        int mod=1000000007;\\n        long long int fo,fi;\\n        if(n&1)\\n        {\\n            fo=n/2;\\n            fi=n/2+1;\\n        }\\n        else\\n        {\\n            fo=n/2;\\n            fi=n/2;\\n        }\\n        return (solve(5,fi,mod)%mod * solve(4,fo,mod)%mod)%mod;\\n        //shyd kuchh overflow ki wjah se wronf ans dera h, recursively try krta hu qki tag me h\\n        /*long long int a=4;\\n        long long int b=5;\\n        long long int res1=1;\\n        while(fo)\\n        {\\n            if(fo&1)\\n            {\\n                res1=(res1%mod*a%mod)%mod;\\n                fo--;\\n            }\\n            else\\n            {\\n                a=(a%mod*a%mod)%mod;\\n                fo=fo/2;\\n            }\\n        }\\n        long long int res2=1;\\n        while(fi)\\n        {\\n            if(fi&1)\\n            {\\n                res2=(res2%mod*b%mod)%mod;\\n                fi--;\\n            }\\n            else\\n            {\\n                b=(b%mod*b%mod)%mod;\\n                fi=fi/2;\\n            }\\n        }\\n        return (res1%mod*res2%mod)%mod;*/\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long  solve(long long a,long long int n,int mod)\\n    {\\n        if(n==0)\\n        return 1;\\n        if(n&1)\\n        {\\n            long long z=solve(a,n/2,mod)%mod;\\n            return (z%mod*z%mod*a%mod)%mod;\\n        }\\n        else\\n        {\\n            long long z=solve(a,n/2,mod)%mod;\\n            return (z%mod*z%mod)%mod;\\n        }\\n    }\\n    int countGoodNumbers(long long n) {\\n        //if power is odd, multiply with that number and reduce by 1\\n        //if pow id even, mul that number twice and n/2\\n        int mod=1000000007;\\n        long long int fo,fi;\\n        if(n&1)\\n        {\\n            fo=n/2;\\n            fi=n/2+1;\\n        }\\n        else\\n        {\\n            fo=n/2;\\n            fi=n/2;\\n        }\\n        return (solve(5,fi,mod)%mod * solve(4,fo,mod)%mod)%mod;\\n        //shyd kuchh overflow ki wjah se wronf ans dera h, recursively try krta hu qki tag me h\\n        /*long long int a=4;\\n        long long int b=5;\\n        long long int res1=1;\\n        while(fo)\\n        {\\n            if(fo&1)\\n            {\\n                res1=(res1%mod*a%mod)%mod;\\n                fo--;\\n            }\\n            else\\n            {\\n                a=(a%mod*a%mod)%mod;\\n                fo=fo/2;\\n            }\\n        }\\n        long long int res2=1;\\n        while(fi)\\n        {\\n            if(fi&1)\\n            {\\n                res2=(res2%mod*b%mod)%mod;\\n                fi--;\\n            }\\n            else\\n            {\\n                b=(b%mod*b%mod)%mod;\\n                fi=fi/2;\\n            }\\n        }\\n        return (res1%mod*res2%mod)%mod;*/\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970272,
                "title": "easy-solution-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to find the power\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNumber of values available for even position are 5. \\nNumber of values available for odd position are 4.\\nNumber of even position are (n+1)/2;\\nNumber of odd position are (n)/2; \\nAns =(pow(5, (n+1)/2))*(pow(4, (n)/2))\\nThis is the basic solution and we need to optimize which is given in code\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long power(long long n, long long number){ //Here n is the power\\n        if(n==0) return 1;\\n        if(n==1) return number;\\n        if(n%2==0){\\n            long long val=(power(n/2, number))%(1000000000+7);\\n            return (val*val)%(1000000000+7);\\n        }\\n        long long val=(power(n/2, number))%(1000000000+7);\\n        return ((val*val)%(1000000000+7)*number)%(1000000000+7);\\n\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long even_pow=(n+1)/2;   //Number of even position\\n        long long prime_pow=n/2;      //Number of odd position\\n        long long even=1, prime=1;    //even is use to store all the posibility at even position i.e. even = pow(5, even_pow)  and prime is to use for odd position.\\n        //cout<<even_pow<<\" \"<<prime_pow<<\"\\\\n\";\\n        even = power(even_pow, 5);\\n        //cout<<even<<\" \";\\n        prime = power(prime_pow, 4);\\n        //cout<<prime;\\n        return (even* prime)%(1000000000+7);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long power(long long n, long long number){ //Here n is the power\\n        if(n==0) return 1;\\n        if(n==1) return number;\\n        if(n%2==0){\\n            long long val=(power(n/2, number))%(1000000000+7);\\n            return (val*val)%(1000000000+7);\\n        }\\n        long long val=(power(n/2, number))%(1000000000+7);\\n        return ((val*val)%(1000000000+7)*number)%(1000000000+7);\\n\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long even_pow=(n+1)/2;   //Number of even position\\n        long long prime_pow=n/2;      //Number of odd position\\n        long long even=1, prime=1;    //even is use to store all the posibility at even position i.e. even = pow(5, even_pow)  and prime is to use for odd position.\\n        //cout<<even_pow<<\" \"<<prime_pow<<\"\\\\n\";\\n        even = power(even_pow, 5);\\n        //cout<<even<<\" \";\\n        prime = power(prime_pow, 4);\\n        //cout<<prime;\\n        return (even* prime)%(1000000000+7);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3963075,
                "title": "beats-90",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def countGoodNumbers(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        modulo = 10**9 + 7\\n        power_5 = n // 2\\n        power_4 = n // 2\\n\\n        if (n % 2) != 0:\\n            power_5 = power_5 + 1\\n\\n        return (pow(5, power_5, modulo) * pow(4, power_4, modulo)) % modulo\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countGoodNumbers(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        modulo = 10**9 + 7\\n        power_5 = n // 2\\n        power_4 = n // 2\\n\\n        if (n % 2) != 0:\\n            power_5 = power_5 + 1\\n\\n        return (pow(5, power_5, modulo) * pow(4, power_4, modulo)) % modulo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962733,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n\\n    long long powX(long long x, long long n) {\\n        if (n == 0) return 1;\\n        long long temp = powX(x, n/2);\\n        if (n % 2 == 0) return (temp * temp) % MOD;\\n        else return (x * temp * temp) % MOD;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long odd = n / 2;\\n        long long even = (n / 2) + (n % 2);\\n        return (int)((powX(5, even) * powX(4, odd)) % MOD);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n\\n    long long powX(long long x, long long n) {\\n        if (n == 0) return 1;\\n        long long temp = powX(x, n/2);\\n        if (n % 2 == 0) return (temp * temp) % MOD;\\n        else return (x * temp * temp) % MOD;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        long long odd = n / 2;\\n        long long even = (n / 2) + (n % 2);\\n        return (int)((powX(5, even) * powX(4, odd)) % MOD);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960875,
                "title": "just-permutation-clean-c-code-beats-100-in-time",
                "content": "# Intuition\\nPermutation\\n\\n# Approach\\nAt every even position ,we have 5 options :0,2,4,6,8;similarly we have 4 options at odd position:2,3,5,7 .Now, find permutation for all positions in the numbers ,and multiply them together.\\n\\n# Complexity\\n- Time complexity:O(LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(LogN) ,for recursive calls.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int a=1e9+7;\\n    long long power(int x,long long n){\\n        if(n==0)return 1ll;\\n        long long halfPower=power(x,n/2);\\n        long long ans=(halfPower*halfPower)%a;\\n        if(n%2!=0)ans=(ans*x)%a;\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long odd=(n/2);\\n        long long even=n-odd;\\n        long long pe=power(5,even);\\n        long long oe=power(4,odd);\\n        return (pe*oe)%a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int a=1e9+7;\\n    long long power(int x,long long n){\\n        if(n==0)return 1ll;\\n        long long halfPower=power(x,n/2);\\n        long long ans=(halfPower*halfPower)%a;\\n        if(n%2!=0)ans=(ans*x)%a;\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long odd=(n/2);\\n        long long even=n-odd;\\n        long long pe=power(5,even);\\n        long long oe=power(4,odd);\\n        return (pe*oe)%a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944123,
                "title": "beats-100-log-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(long long X,long long Y)\\n    {\\n        \\n         if(Y==0)\\n       return 1;\\n\\n\\n        if(Y%2==0)\\n         return calculate((X*X)%1000000007,Y/2);\\n        else\\n        return X=(X*calculate(X,Y-1))%1000000007;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        \\n        long long odd=n/2;\\n        long long even=(n/2)+(n%2);\\n\\n        return (calculate(4,odd)*calculate(5,even))%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(long long X,long long Y)\\n    {\\n        \\n         if(Y==0)\\n       return 1;\\n\\n\\n        if(Y%2==0)\\n         return calculate((X*X)%1000000007,Y/2);\\n        else\\n        return X=(X*calculate(X,Y-1))%1000000007;\\n    }\\n\\n    int countGoodNumbers(long long n) {\\n        \\n        long long odd=n/2;\\n        long long even=(n/2)+(n%2);\\n\\n        return (calculate(4,odd)*calculate(5,even))%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920718,
                "title": "java-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    long  mod=1000000007;\\n\\n    public long power(long num,long pow){\\n        //base case;\\n        if(pow==0)return 1;\\n\\n        long ans=power(num,pow/2);\\n        ans=(ans*ans)%mod;\\n\\n        if(pow%2==1){\\n            return (ans*num)%mod;\\n        }\\n        return ans;\\n    }\\n    public int countGoodNumbers(long n) {\\n        long totalevenindx=(n/2)+(n%2);\\n        long totaloddindx=(n/2);\\n        return (int) ((power(5,totalevenindx)*power(4,totaloddindx))%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    long  mod=1000000007;\\n\\n    public long power(long num,long pow){\\n        //base case;\\n        if(pow==0)return 1;\\n\\n        long ans=power(num,pow/2);\\n        ans=(ans*ans)%mod;\\n\\n        if(pow%2==1){\\n            return (ans*num)%mod;\\n        }\\n        return ans;\\n    }\\n    public int countGoodNumbers(long n) {\\n        long totalevenindx=(n/2)+(n%2);\\n        long totaloddindx=(n/2);\\n        return (int) ((power(5,totalevenindx)*power(4,totaloddindx))%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919117,
                "title": "simple-cpp-solution-that-beats-81",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int mod = 1e9+7;\\n    long long power(long long x,long long y)\\n    {\\n        if(y == 0)\\n        return 1;\\n        long long ans = power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2)ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long ans = 1;\\n        /*for(int i = 0;i<n;i++)\\n        {\\n            if(i%2 == 0)\\n            {\\n                ans=((ans%mod)*5)%mod;\\n            }\\n            else\\n            {\\n                ans=((ans%mod)*4)%mod;\\n            }\\n        }*/\\n        long long even = (n/2)+(n%2);\\n        long long odd = (n/2);\\n        return (power(5,even)*power(4,odd))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int mod = 1e9+7;\\n    long long power(long long x,long long y)\\n    {\\n        if(y == 0)\\n        return 1;\\n        long long ans = power(x,y/2);\\n        ans*=ans;\\n        ans%=mod;\\n        if(y%2)ans*=x;\\n        ans%=mod;\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long ans = 1;\\n        /*for(int i = 0;i<n;i++)\\n        {\\n            if(i%2 == 0)\\n            {\\n                ans=((ans%mod)*5)%mod;\\n            }\\n            else\\n            {\\n                ans=((ans%mod)*4)%mod;\\n            }\\n        }*/\\n        long long even = (n/2)+(n%2);\\n        long long odd = (n/2);\\n        return (power(5,even)*power(4,odd))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911427,
                "title": "c-binary-exponentiation",
                "content": "**Hints**\\n1. Think of what values we can place at even index\\n2. Think of what values we can place at odd index\\n3. We have to find ways of all possible values\\n\\n**Solution**\\n1. We can place 0, 2, 4, 6, 8 total 5 values\\n2. At odd index 2, 3, 5, 7 total 4 values\\n3. So for n=2 we have 5*4\\n4. For n=3 answer is 5 * 4 * 5.......\\n\\nFor optimal solution we have to use binary exponentiation technique to find in **O(log n)**\\n```\\ntypedef long long ll;\\nint mod=(int)1e9+7;\\nclass Solution {\\npublic:\\n    ll binPow(ll x,ll y){\\n        ll res=1;\\n        x=x%mod;\\n        while(y>0){\\n            if(y&1){\\n                res=res*x%mod;\\n            }\\n            x=(x*x)%mod;\\n            y>>=1;\\n        }\\n        return res%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        ll a=n/2,b=n/2;\\n        if(n&1) a+=1;\\n        ll ans=((binPow(5LL,a))%mod*(binPow(4LL,b)%mod))%mod;\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like :)",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nint mod=(int)1e9+7;\\nclass Solution {\\npublic:\\n    ll binPow(ll x,ll y){\\n        ll res=1;\\n        x=x%mod;\\n        while(y>0){\\n            if(y&1){\\n                res=res*x%mod;\\n            }\\n            x=(x*x)%mod;\\n            y>>=1;\\n        }\\n        return res%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n        ll a=n/2,b=n/2;\\n        if(n&1) a+=1;\\n        ll ans=((binPow(5LL,a))%mod*(binPow(4LL,b)%mod))%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902510,
                "title": "faster-than-100-c-modular-exponentiation",
                "content": "# Intuition\\nA \"good\" number is defined as a number that has exactly half of its digits being odd and the other half being even. We are given a value n, and we need to count the number of \"good\" numbers that can be formed using exactly n digits.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### ***Counting Even and Odd Digits:***\\nTo form a \"good\" number, we need to have an equal number of even and odd digits. If n is even, we can allocate half of them for even digits and half for odd digits. If n is odd, we can allocate one more even digit than odd digits. This is because we need to ensure that the number of even and odd digits remains equal even after including an extra even digit.\\n\\n***Modular Exponentiation:***\\nSince we are dealing with potentially large numbers, we need to perform exponentiation modulo a given value (mod), which in this case is 1000000007. This helps to keep the intermediate values manageable and prevents overflow during computations.\\n\\n#### ***Calculating Even and Odd Power Results:***\\nThe idea is to calculate (5^evenCount) % mod and (4^oddCount) % mod efficiently using modular exponentiation. The variable evenCount represents the count of even digits, and oddCount represents the count of odd digits.\\n\\n5 is used for even digits since they can end in 0, 2, 4, 6, or 8.\\n4 is used for odd digits since they can end in 1, 3, 5, 7, or 9.\\nThe modular exponentiation function is used to calculate these values efficiently and prevent overflow.\\n\\n#### *Final Count Calculation:*\\nThe total count of \"good\" numbers can be calculated by multiplying the results of (5^evenCount) and (4^oddCount) and then taking the modulo mod. This is because the number of ways to choose even and odd digits independently represents the total number of \"good\" numbers possible.\\n\\n***Returning the Result:***\\nThe final computed count is returned as the answer.\\n\\nOverall, the approach utilizes modular exponentiation to calculate the possible combinations of even and odd digits efficiently, and then multiplies these results to find the total count of \"good\" numbers modulo a given value. This approach ensures that the computations are manageable even for large values of n.\\n# Complexity\\n- **Time complexity:** O(log(n))\\n\\nCalculating Even and Odd Counts: These calculations involve basic arithmetic operations and comparisons. They can be done in constant time, O(1).\\n\\nModular Exponentiation: The time complexity of the modular exponentiation function is O(log(power)). In this case, the maximum value of power is n, so the time complexity for each modular exponentiation (5^evenCount and 4^oddCount) is O(log(n)).\\n\\nFinal Count Calculation: This involves multiplication and modulo operations, which are constant time operations. Thus, the final count calculation also takes O(1) time.\\n\\nOverall, the dominant time complexity comes from the modular exponentiation, which is O(log(n)).\\n\\n\\n- **Space complexity:** O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is mainly determined by the variables used in the solution. Let\\'s analyze the memory consumption:\\n\\nThe solution uses a constant number of variables to store intermediate results, even counts, odd counts, and the final count. These variables do not scale with the input value n, so they take constant space, O(1).\\n\\nThe recursive call stack for the modular exponentiation function can grow up to O(log(power)) deep, which in this case is O(log(n)). However, since the stack space is deallocated after each function call, the overall space complexity due to the call stack is also O(log(n)).\\n\\nThere are no data structures being used that would increase the space complexity.\\n\\nThus, the space complexity of the solution is O(log(n)).\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // Function to calculate (base^power) % mod efficiently\\n    long long modularExponentiation(long long base, long long power, int mod) {\\n        long long result = 1;\\n        while (power != 0) {\\n            if (power & 1) {\\n                result = (result * base) % mod;\\n                power--;\\n            } else {\\n                base = ((base % mod) * (base % mod)) % mod;\\n                power /= 2;\\n            }\\n        }\\n        return result;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long totalCount = 1;\\n        int mod = 1000000007;\\n\\n        long long evenCount, oddCount;\\n        if (n & 1) {\\n            evenCount = n / 2 + 1;\\n            oddCount = n / 2;\\n        } else {\\n            evenCount = n / 2;\\n            oddCount = n / 2;\\n        }\\n\\n        // Calculate (5^evenCount) % mod\\n        long long evenPowerResult = modularExponentiation(5, evenCount, mod);\\n\\n        // Calculate (4^oddCount) % mod\\n        long long oddPowerResult = modularExponentiation(4, oddCount, mod);\\n\\n        // Calculate the final result as (evenPowerResult * oddPowerResult) % mod\\n        totalCount = (evenPowerResult * oddPowerResult) % mod;\\n\\n        return totalCount;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Function to calculate (base^power) % mod efficiently\\n    long long modularExponentiation(long long base, long long power, int mod) {\\n        long long result = 1;\\n        while (power != 0) {\\n            if (power & 1) {\\n                result = (result * base) % mod;\\n                power--;\\n            } else {\\n                base = ((base % mod) * (base % mod)) % mod;\\n                power /= 2;\\n            }\\n        }\\n        return result;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long totalCount = 1;\\n        int mod = 1000000007;\\n\\n        long long evenCount, oddCount;\\n        if (n & 1) {\\n            evenCount = n / 2 + 1;\\n            oddCount = n / 2;\\n        } else {\\n            evenCount = n / 2;\\n            oddCount = n / 2;\\n        }\\n\\n        // Calculate (5^evenCount) % mod\\n        long long evenPowerResult = modularExponentiation(5, evenCount, mod);\\n\\n        // Calculate (4^oddCount) % mod\\n        long long oddPowerResult = modularExponentiation(4, oddCount, mod);\\n\\n        // Calculate the final result as (evenPowerResult * oddPowerResult) % mod\\n        totalCount = (evenPowerResult * oddPowerResult) % mod;\\n\\n        return totalCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895296,
                "title": "beats-100-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n\\n    public int countGoodNumbers(long n) {\\n        return (int) (fastModularExponentiation(5, (n + 1) / 2) * fastModularExponentiation(4, n / 2) % MOD);\\n    }\\n\\n    private long fastModularExponentiation(long base, long exponent) {\\n        long result = 1;\\n        while (exponent > 0) {\\n            if (exponent % 2 == 1) {\\n                result = (result * base) % MOD;\\n            }\\n            base = (base * base) % MOD;\\n            exponent /= 2;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n\\n    public int countGoodNumbers(long n) {\\n        return (int) (fastModularExponentiation(5, (n + 1) / 2) * fastModularExponentiation(4, n / 2) % MOD);\\n    }\\n\\n    private long fastModularExponentiation(long base, long exponent) {\\n        long result = 1;\\n        while (exponent > 0) {\\n            if (exponent % 2 == 1) {\\n                result = (result * base) % MOD;\\n            }\\n            base = (base * base) % MOD;\\n            exponent /= 2;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893737,
                "title": "simple-c-code-beats-100",
                "content": "\\n\\n# Code\\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n\\n\\nlong long int power(long long x,long long y){\\n    if(x==0)return 1;\\n    long long int ans=power(x/2,y);\\n    ans*=ans;\\n    ans%=MOD;\\n    if(x%2)ans*=y;\\n    ans%=MOD;\\n    return ans;\\n\\n\\n}\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even=n/2+n%2;\\n        return (power(odd,4)*power(even,5))%MOD;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n\\n\\nlong long int power(long long x,long long y){\\n    if(x==0)return 1;\\n    long long int ans=power(x/2,y);\\n    ans*=ans;\\n    ans%=MOD;\\n    if(x%2)ans*=y;\\n    ans%=MOD;\\n    return ans;\\n\\n\\n}\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even=n/2+n%2;\\n        return (power(odd,4)*power(even,5))%MOD;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893371,
                "title": "java-solution-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    long mod=1000000007;\\n    long pow(long x, long n)\\n    {\\n        if(n==1)return x;\\n        if(n==0)return 1;\\n        long smallPow=pow(x,n/2);\\n        if(n%2==1)\\n        {\\n            return (smallPow%mod*smallPow%mod*x%mod)%mod;\\n        }\\n        return (smallPow%mod*smallPow%mod)%mod;\\n    }\\n    public int countGoodNumbers(long n) {\\n        long oddInd = n/2;\\n        long eveInd = n/2 + n%2;\\n        return (int)((pow(5,eveInd)%mod*pow(4,oddInd)%mod)%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod=1000000007;\\n    long pow(long x, long n)\\n    {\\n        if(n==1)return x;\\n        if(n==0)return 1;\\n        long smallPow=pow(x,n/2);\\n        if(n%2==1)\\n        {\\n            return (smallPow%mod*smallPow%mod*x%mod)%mod;\\n        }\\n        return (smallPow%mod*smallPow%mod)%mod;\\n    }\\n    public int countGoodNumbers(long n) {\\n        long oddInd = n/2;\\n        long eveInd = n/2 + n%2;\\n        return (int)((pow(5,eveInd)%mod*pow(4,oddInd)%mod)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892357,
                "title": "java-code-beats-100-in-time-and-90-in-space-recursion",
                "content": "# Intuition\\nUse recursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(Log N);\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int d = (int)(Math.pow(10,9) + 7);\\n    public long pow(int x, long n){\\n        if(n == 0){\\n            return 1; \\n        }\\n        long temp = pow(x,n/2) % d;\\n        temp = (temp * temp) % d;\\n        if(n % 2 == 0){\\n            return (int)temp;\\n        }\\n        temp = (temp * x) % d;\\n        return (int) temp;\\n\\n    }\\n    public int countGoodNumbers(long n) {\\n        \\n        long a = pow(5,n/2);\\n        long b = pow(4,n/2);\\n        long ans;\\n        a = a%d;\\n        b = b%d;\\n        ans = (a*b) % d;\\n        if(n % 2 == 0){\\n            return (int)ans;\\n        }\\n        ans = (ans * 5) % d;\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int d = (int)(Math.pow(10,9) + 7);\\n    public long pow(int x, long n){\\n        if(n == 0){\\n            return 1; \\n        }\\n        long temp = pow(x,n/2) % d;\\n        temp = (temp * temp) % d;\\n        if(n % 2 == 0){\\n            return (int)temp;\\n        }\\n        temp = (temp * x) % d;\\n        return (int) temp;\\n\\n    }\\n    public int countGoodNumbers(long n) {\\n        \\n        long a = pow(5,n/2);\\n        long b = pow(4,n/2);\\n        long ans;\\n        a = a%d;\\n        b = b%d;\\n        ans = (a*b) % d;\\n        if(n % 2 == 0){\\n            return (int)ans;\\n        }\\n        ans = (ans * 5) % d;\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891232,
                "title": "c-100-approach-using-recursion",
                "content": "\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\n#define mod 1e9+7\\nclass Solution {\\npublic:\\n    long long power(long long x, long long y)\\n    {\\n        if(y==0)return 1;\\n        long long result= power(x,y/2);\\n        result *= result;\\n        result = result % 1000000007 ;\\n        if(y%2) result *= x;\\n        result %=1000000007;\\n        return result;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even=n/2+n%2;\\n        \\n        return (power(4,odd)*power(5,even))%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n#define mod 1e9+7\\nclass Solution {\\npublic:\\n    long long power(long long x, long long y)\\n    {\\n        if(y==0)return 1;\\n        long long result= power(x,y/2);\\n        result *= result;\\n        result = result % 1000000007 ;\\n        if(y%2) result *= x;\\n        result %=1000000007;\\n        return result;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even=n/2+n%2;\\n        \\n        return (power(4,odd)*power(5,even))%1000000007;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3889100,
                "title": "easy-c-solution-using-recursion-for-beginners-with-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# define mod 1000000007;\\nclass Solution {\\n\\n    private:\\n    long long Power(long long  x, long long n) { \\n        // solved using recursion \\n        \\n        if(n==0){\\n            return 1;\\n        }\\n\\n        long long ans=Power(x,n/2);\\n        if(n%2==0){\\n            ans*=ans;\\n            ans%=mod;\\n            return ans;\\n        }\\n        else{\\n            ans= x*ans*ans;\\n            ans%=mod;\\n            return ans;\\n        } \\n\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even = (n+1)/2;\\n         return (Power(5,even)* Power (4, odd) )%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n# define mod 1000000007;\\nclass Solution {\\n\\n    private:\\n    long long Power(long long  x, long long n) { \\n        // solved using recursion \\n        \\n        if(n==0){\\n            return 1;\\n        }\\n\\n        long long ans=Power(x,n/2);\\n        if(n%2==0){\\n            ans*=ans;\\n            ans%=mod;\\n            return ans;\\n        }\\n        else{\\n            ans= x*ans*ans;\\n            ans%=mod;\\n            return ans;\\n        } \\n\\n    }\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long odd=n/2;\\n        long long even = (n+1)/2;\\n         return (Power(5,even)* Power (4, odd) )%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874450,
                "title": "beats-100-binary-exponentiation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nread my code basic p and c\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\neven can filled with 5 options and odd can be filled with 4 options\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbinary exponentiation... think think O(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nno space bro\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nconst int mod = 1e9+7;\\n    long long binpow(long long a, long long b) {\\n    long long res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a;\\n        a = (a * a)%mod;\\n        b >>= 1;\\n        res%=mod;\\n    }\\n    return res;\\n}\\n    int countGoodNumbers(long long n) {\\n        long long ans =1;\\n        ans*=(binpow(5,(ceil(n/2.0))));\\n        ans%=mod;\\n        ans*=(binpow(4,(ceil(n/2))));\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Combinatorics",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst int mod = 1e9+7;\\n    long long binpow(long long a, long long b) {\\n    long long res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a;\\n        a = (a * a)%mod;\\n        b >>= 1;\\n        res%=mod;\\n    }\\n    return res;\\n}\\n    int countGoodNumbers(long long n) {\\n        long long ans =1;\\n        ans*=(binpow(5,(ceil(n/2.0))));\\n        ans%=mod;\\n        ans*=(binpow(4,(ceil(n/2))));\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863109,
                "title": "beats-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is simple Modular Exponentiation (look it up if u don\\'t know what this is!).<br>\\nSo, if you have **n** digits, **n/2** will be odd indices and **n-(n/2)** are gonna be even places.<br>\\nNo.of even digits avaliable = 5 (0,2,4,6,8)<br>\\nNo.of odd digits available = 4 (2,3,5,7)<br>\\n\\n**define m = 1e9+7** <br>\\n\\nSo, by simple combinatorics, no.of ways to fill up even places = 5<sup>even places</sup>%m<br>\\n\\nNo.of ways to fill odd places = 4<sup>odd places</sup>%m\\n\\nTotal no.of ways = (5<sup>even places</sup>%m * 4<sup>odd places</sup>%m)%m\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLook at how modular exponetiation is done in the code <code>ll modexp(ll x, ll n)</code> describes the process.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long modexp(ll x,ll n){\\n        ll m=1e9+7;\\n        if(n==0)return 1;\\n        x=x%m;\\n        ll res=1;\\n        while(n>0){\\n            if(n%2==1){\\n                res=(res*x)%m;\\n            }\\n            x=(x*x)%m;\\n            n/=2;\\n        }\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        if(n==1)return 5;\\n        int even=5;\\n        int prime=4;\\n\\n        ll oddplaces=n/2;\\n        ll eveplaces=n-oddplaces;\\n\\n        int m=1e9+7;\\n\\n        ll res=(modexp(even,eveplaces)*modexp(prime,oddplaces))%m;\\n        return (int)res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long modexp(ll x,ll n){\\n        ll m=1e9+7;\\n        if(n==0)return 1;\\n        x=x%m;\\n        ll res=1;\\n        while(n>0){\\n            if(n%2==1){\\n                res=(res*x)%m;\\n            }\\n            x=(x*x)%m;\\n            n/=2;\\n        }\\n        return res;\\n    }\\n    int countGoodNumbers(long long n) {\\n        if(n==1)return 5;\\n        int even=5;\\n        int prime=4;\\n\\n        ll oddplaces=n/2;\\n        ll eveplaces=n-oddplaces;\\n\\n        int m=1e9+7;\\n\\n        ll res=(modexp(even,eveplaces)*modexp(prime,oddplaces))%m;\\n        return (int)res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858551,
                "title": "explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static long mod = (int) (1e9 + 7);//Define mod as a class variable for easier reference and readability\\n\\n    public int countGoodNumbers(long n) {\\n      //Calculate the number of even and odd positions in the digit string\\n        long even = (n + 1) / 2;\\n        long odd = n / 2;\\n        //Calculate the total number of good digit strings\\n        return (int) ((myPow(5, even)) * (myPow(4, odd)) % mod);\\n    }\\n\\n    public static long myPow(long x, long y) {\\n        long temp = 1;\\n        if (y == 0) return 1;\\n        temp = myPow(x, y / 2);\\n        if (y % 2 == 0) {\\n            return (temp * temp) % mod;\\n        } else {\\n            return (x * temp * temp) % mod;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static long mod = (int) (1e9 + 7);//Define mod as a class variable for easier reference and readability\\n\\n    public int countGoodNumbers(long n) {\\n      //Calculate the number of even and odd positions in the digit string\\n        long even = (n + 1) / 2;\\n        long odd = n / 2;\\n        //Calculate the total number of good digit strings\\n        return (int) ((myPow(5, even)) * (myPow(4, odd)) % mod);\\n    }\\n\\n    public static long myPow(long x, long y) {\\n        long temp = 1;\\n        if (y == 0) return 1;\\n        temp = myPow(x, y / 2);\\n        if (y % 2 == 0) {\\n            return (temp * temp) % mod;\\n        } else {\\n            return (x * temp * temp) % mod;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856714,
                "title": "runtime-0ms-beats-100-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEasy enough to understand from this solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long int binaryexponenciation(long long int n,long long int k){\\n\\tlong long int expon = 1;\\n\\t\\twhile (k > 0)\\n\\t\\t{\\n\\t\\t\\tif (k & 1)\\n\\t\\t\\t\\texpon = (expon * n) % 1000000007;\\n\\n\\t\\t\\tk >>= 1;\\n\\t\\t\\tn = (n * n) % 1000000007;\\n\\t\\t}\\n\\t\\treturn expon;\\n}\\n    int countGoodNumbers(long long n) {\\n        long long int ans;\\n\\tif(n%2==0){\\n\\t\\tans=binaryexponenciation(5,n/2)*binaryexponenciation(4,n/2);\\n\\t}\\n\\telse{\\n\\t\\tans=binaryexponenciation(5,n/2+1)*binaryexponenciation(4,n/2);\\n\\t}\\n\\t\\t\\n\\treturn ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long int binaryexponenciation(long long int n,long long int k){\\n\\tlong long int expon = 1;\\n\\t\\twhile (k > 0)\\n\\t\\t{\\n\\t\\t\\tif (k & 1)\\n\\t\\t\\t\\texpon = (expon * n) % 1000000007;\\n\\n\\t\\t\\tk >>= 1;\\n\\t\\t\\tn = (n * n) % 1000000007;\\n\\t\\t}\\n\\t\\treturn expon;\\n}\\n    int countGoodNumbers(long long n) {\\n        long long int ans;\\n\\tif(n%2==0){\\n\\t\\tans=binaryexponenciation(5,n/2)*binaryexponenciation(4,n/2);\\n\\t}\\n\\telse{\\n\\t\\tans=binaryexponenciation(5,n/2+1)*binaryexponenciation(4,n/2);\\n\\t}\\n\\t\\t\\n\\treturn ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849816,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\nCalculating number of times even number comes at even position and odd number/digit comes at odd position.There are 5 even digits and 4 prime digits are present b/w 0 to 9.\\n# Approach\\nRecursive approach for calculating power in O(log n) time complexity will be most efficient.Here i made a recursive power function in which i simply calculate 5^even digits multiplied with 4^prime digits and in each multiplication i took modulo with 1e^9+7; and finally return the ans;\\n# Complexity\\n- Time complexity:\\nO(Log n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\n    private:\\n    long long power(long long x,long long y)\\n    {\\n        if(y == 0)\\n            return 1;\\n\\n        long long ans = power(x,y/2);\\n        ans *= ans;\\n        ans %= mod;\\n        if(y%2)\\n            ans *= x;\\n        ans %= mod;\\n        return ans;\\n    }\\n    public:\\n    int countGoodNumbers(long long n) \\n    {\\n        long long prime = n/2;\\n        long long even = n/2+n%2;\\n        return (power(5,even)*power(4,prime))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\n    private:\\n    long long power(long long x,long long y)\\n    {\\n        if(y == 0)\\n            return 1;\\n\\n        long long ans = power(x,y/2);\\n        ans *= ans;\\n        ans %= mod;\\n        if(y%2)\\n            ans *= x;\\n        ans %= mod;\\n        return ans;\\n    }\\n    public:\\n    int countGoodNumbers(long long n) \\n    {\\n        long long prime = n/2;\\n        long long even = n/2+n%2;\\n        return (power(5,even)*power(4,prime))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842309,
                "title": "binary-exponentiation-beats-100",
                "content": "# Approach\\nBinary Exponentiation\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod =1000000007;\\n    public int countGoodNumbers(long n) {\\n        long even=0;\\n        long odd=0;\\n        if ((n&1)==0)\\n        {\\n            //even\\n            even=odd=n/2;\\n        }\\n        else \\n        {\\n            odd=n/2;\\n            even=odd+1;\\n        }\\n\\n        long evenval= binaryExponentiation(5,even);\\n        long oddval = binaryExponentiation(4,odd);\\n\\n        long res = (oddval*evenval)%mod;\\n        return (int)res;\\n    }\\n    //gives me a^n;\\n    long binaryExponentiation(long a , long b)\\n    {\\n        if (b==0)\\n        return 1;\\n\\n        a=a%mod;\\n\\n        long ans = (binaryExponentiation(a,b/2))%mod;\\n        long pow = (ans*ans)%mod;\\n        if ((b&1)==0)\\n        return pow;\\n        else \\n        return (pow*a)%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod =1000000007;\\n    public int countGoodNumbers(long n) {\\n        long even=0;\\n        long odd=0;\\n        if ((n&1)==0)\\n        {\\n            //even\\n            even=odd=n/2;\\n        }\\n        else \\n        {\\n            odd=n/2;\\n            even=odd+1;\\n        }\\n\\n        long evenval= binaryExponentiation(5,even);\\n        long oddval = binaryExponentiation(4,odd);\\n\\n        long res = (oddval*evenval)%mod;\\n        return (int)res;\\n    }\\n    //gives me a^n;\\n    long binaryExponentiation(long a , long b)\\n    {\\n        if (b==0)\\n        return 1;\\n\\n        a=a%mod;\\n\\n        long ans = (binaryExponentiation(a,b/2))%mod;\\n        long pow = (ans*ans)%mod;\\n        if ((b&1)==0)\\n        return pow;\\n        else \\n        return (pow*a)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837724,
                "title": "recursion-and-maths",
                "content": "class Solution {\\npublic:\\n    \\n    const int mod=1e9+7;\\n   long long int pow(long long int x,long long int y)\\n    {\\n        if(y==0)\\n            return 1;\\n        if(y==1)\\n            return x;\\n      long long  int d1=pow(x,y/2);\\n        if(y%2!=0)\\n        {\\n            return((d1)%mod*d1%mod)*x;\\n        }\\n        else\\n            return (d1)%mod*(d1)%mod;\\n    }\\n    int countGoodNumbers(long long n) {\\n       long long  int m=n/2;\\n      long long  int d=n-m;\\n      long long  int ans1=pow(5,d)%mod;\\n    long long    int ans=pow(4,m)%mod;\\n        return (ans*ans1)%mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    const int mod=1e9+7;\\n   long long int pow(long long int x,long long int y)\\n    {\\n        if(y==0)\\n            return 1;\\n        if(y==1)\\n            return x;\\n      long long  int d1=pow(x,y/2);\\n        if(y%2!=0)\\n        {\\n            return((d1)%mod*d1%mod)*x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3834750,
                "title": "very-easy-recursive-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery even place element can have 5 values (0,2,4,6,8) and every odd value can have 4 possible values (2,3,5,7) so  what if we calculate all even places upto n and raised it to the respective power\\nSEE COMMENTS FOR BETTER UNDERSTANDING \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# define mod 1000000007;\\nclass Solution {\\npublic:\\n    long long power (long long x, long long y){\\n        if(y==0)return 1; // base condition \\n        long long ans= power(x,y/2); // recursive call \\n        ans*=ans;  // multiply ans with ans to obtain orignal ans  a^(b/2) * a^(b/2) ==  a^b\\n        ans%=mod; // mod to keep in range \\n        if(y%2) ans*=x;  // if power is odd we need to multiply by number once for ex power ==7 so  7/2=3  but (a^3 * a^3)  is not eq to a^7 \\n        ans%=mod;// again mod to keep in range \\n        return ans; // upvote kar do samaj aya to \\n    }\\n    int countGoodNumbers(long long n) {\\n        long long odd= n/2; //odd number in 0 indexed array for ex 5/2 = 2 so 2nd indexd i.e  3rd element is odd place \\n        long long even = n/2+n%2; // similarly  even index is calculated by adding mod (smarter way to add +1  to odd value )\\n        return (power(5,even)* power (4, odd) )%mod; \\n        // among 5 options (0,2,4,6,8) for even index  we can select one similarly for odd index there are 4 choises (2,3,5,7) \\n        //calculate the number of odd and even places and multiply by the choices(5,4) and mod to keep answer in limits ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n# define mod 1000000007;\\nclass Solution {\\npublic:\\n    long long power (long long x, long long y){\\n        if(y==0)return 1; // base condition \\n        long long ans= power(x,y/2); // recursive call \\n        ans*=ans;  // multiply ans with ans to obtain orignal ans  a^(b/2) * a^(b/2) ==  a^b\\n        ans%=mod; // mod to keep in range \\n        if(y%2) ans*=x;  // if power is odd we need to multiply by number once for ex power ==7 so  7/2=3  but (a^3 * a^3)  is not eq to a^7 \\n        ans%=mod;// again mod to keep in range \\n        return ans; // upvote kar do samaj aya to \\n    }\\n    int countGoodNumbers(long long n) {\\n        long long odd= n/2; //odd number in 0 indexed array for ex 5/2 = 2 so 2nd indexd i.e  3rd element is odd place \\n        long long even = n/2+n%2; // similarly  even index is calculated by adding mod (smarter way to add +1  to odd value )\\n        return (power(5,even)* power (4, odd) )%mod; \\n        // among 5 options (0,2,4,6,8) for even index  we can select one similarly for odd index there are 4 choises (2,3,5,7) \\n        //calculate the number of odd and even places and multiply by the choices(5,4) and mod to keep answer in limits ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822734,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\n  \\npublic:\\nlong long pw(long long x, long long y){\\n    if(y==0){\\n        return 1;\\n    }    \\n    long long reslt=pw(x,y/2);\\n    reslt=reslt*reslt;\\n    reslt=reslt%mod;\\n    if(y%2)reslt=reslt*x;\\n    reslt=reslt%mod;\\n    return reslt;\\n}\\n    int countGoodNumbers(long long n) {\\n       long long odd=n/2;\\n       long long even=n/2+n%2;\\n       return (pw(5,even)*pw(4,odd))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\n  \\npublic:\\nlong long pw(long long x, long long y){\\n    if(y==0){\\n        return 1;\\n    }    \\n    long long reslt=pw(x,y/2);\\n    reslt=reslt*reslt;\\n    reslt=reslt%mod;\\n    if(y%2)reslt=reslt*x;\\n    reslt=reslt%mod;\\n    return reslt;\\n}\\n    int countGoodNumbers(long long n) {\\n       long long odd=n/2;\\n       long long even=n/2+n%2;\\n       return (pw(5,even)*pw(4,odd))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820886,
                "title": "python3-recursion-and-logic-solution",
                "content": "U should know about the pow(x,n) problem before this.\\n0 2 4 6 8 are the even numbers.\\n2 3 5 7 are the odd numbers.\\nIn even digit we have 5 combo and in odd digit we have 4 combo.\\n1 = 5   = 5^1*4^0 = 5*1\\n2 = 20  = 5^1*4^1 = 5*4\\n3 = 100 = 5^2*4^1 = 25*4\\n4 = 400 = 5^2*4^2 = 25*16\\n5 = 2000= 5^3*5^2 = 125*16\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        def power(x,n):\\n            if n==0:\\n                return 1\\n            res=power(x,n//2)\\n            res=res*res\\n            res=res%1000000007\\n            return res*x if n%2 else res\\n\\n        four=n//2\\n        fo=power(4,four)%1000000007 if n>1 else 1\\n        five=(n//2)+1 if n%2==1 else n//2\\n        fi=power(5,five)%1000000007\\n        return (fo*fi)%1000000007\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        def power(x,n):\\n            if n==0:\\n                return 1\\n            res=power(x,n//2)\\n            res=res*res\\n            res=res%1000000007\\n            return res*x if n%2 else res\\n\\n        four=n//2\\n        fo=power(4,four)%1000000007 if n>1 else 1\\n        five=(n//2)+1 if n%2==1 else n//2\\n        fi=power(5,five)%1000000007\\n        return (fo*fi)%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817613,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\nint mod = 1e9 + 7;\\n    ll helper(ll b, ll p)\\n    {\\n        ll ans=1;\\n        while(p){\\n            if(p%2){\\n                p--;\\n                ans=(ans*b)%mod;\\n            }\\n            else{\\n                p/=2;\\n                b=(b*b)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        ll odd = n/2;\\n        ll even = n - odd;\\n        return (helper(5,even) * helper(4,odd))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\nint mod = 1e9 + 7;\\n    ll helper(ll b, ll p)\\n    {\\n        ll ans=1;\\n        while(p){\\n            if(p%2){\\n                p--;\\n                ans=(ans*b)%mod;\\n            }\\n            else{\\n                p/=2;\\n                b=(b*b)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        ll odd = n/2;\\n        ll even = n - odd;\\n        return (helper(5,even) * helper(4,odd))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800357,
                "title": "beats-100-solns-using-binary-exponentiation-c-soln",
                "content": "# Intuition\\nTo count the total number of good digit strings of length n, we need to consider the possible combinations of even and odd digits. A digit is considered \"good\" if it is either 0, 2, 4, 6, or 8 (an even digit) in the even positions and either 1,3,5,7 or 9 (an odd digit) in the odd positions.\\n# Approach\\nwe use the binary exponentiation algorithm to efficiently compute powers modulo a given value. We calculate the number of even and odd positions. Then, we find the powers of 5 and 4 using the powMod function. The total count of good digit strings is obtained by multiplying these powers and taking the result modulo MOD. This approach optimizes the computation and provides the total number of good digit strings of length n.\\n# Complexity\\n- Time complexity:\\n O(logN)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    const int MOD = 1e9 + 7;\\n\\n    long long powMod(long long base, long long exp) {\\n        long long result = 1;\\n        while (exp > 0) {\\n            if (exp % 2 == 1) {\\n                result = (result * base) % MOD;\\n            }\\n            base = (base * base) % MOD;\\n            exp /= 2;\\n        }\\n        return result;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long evenDigits = powMod(5, (n + 1) / 2);\\n        long long oddDigits = powMod(4, n / 2);\\n        return (int)((evenDigits * oddDigits) % MOD);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int MOD = 1e9 + 7;\\n\\n    long long powMod(long long base, long long exp) {\\n        long long result = 1;\\n        while (exp > 0) {\\n            if (exp % 2 == 1) {\\n                result = (result * base) % MOD;\\n            }\\n            base = (base * base) % MOD;\\n            exp /= 2;\\n        }\\n        return result;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        long long evenDigits = powMod(5, (n + 1) / 2);\\n        long long oddDigits = powMod(4, n / 2);\\n        return (int)((evenDigits * oddDigits) % MOD);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796328,
                "title": "c-simple-solution-using-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPermutation and Combination\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing simple mathematics of class 12 , we can directly get the formula for the total number of \\'good numbers\\' for both even and odd cases, but the main thing to ensure is that during the calculation of **ans** we need to calculate power(base,exponent) and this may lead to int-overflow, so power function can be written manually which handles this using modulo. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(log(base4) n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long power(long long base, long long exponent, long long modu) {\\n        long long result = 1;\\n        base %= modu;\\n        while (exponent > 0) {\\n            if (exponent & 1) {\\n                result = (result * base) % modu;\\n            }\\n            base = (base * base) % modu;\\n            exponent >>= 1;\\n        }\\n        return result;\\n    }\\n\\n    long long countGoodNumbers(long long n) {\\n        long long modu = 1e9 + 7;\\n        long long ans;\\n\\n        if (n % 2 == 0) {\\n            long long base = 5;\\n            long long exponent = n / 2;\\n            ans = (power(base, exponent, modu) * power(4, exponent, modu)) % modu;\\n        } else {\\n            long long base = 5;\\n            long long exponent = n / 2 + 1;\\n            ans = (power(base, exponent, modu) * power(4, exponent - 1, modu)) % modu;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long power(long long base, long long exponent, long long modu) {\\n        long long result = 1;\\n        base %= modu;\\n        while (exponent > 0) {\\n            if (exponent & 1) {\\n                result = (result * base) % modu;\\n            }\\n            base = (base * base) % modu;\\n            exponent >>= 1;\\n        }\\n        return result;\\n    }\\n\\n    long long countGoodNumbers(long long n) {\\n        long long modu = 1e9 + 7;\\n        long long ans;\\n\\n        if (n % 2 == 0) {\\n            long long base = 5;\\n            long long exponent = n / 2;\\n            ans = (power(base, exponent, modu) * power(4, exponent, modu)) % modu;\\n        } else {\\n            long long base = 5;\\n            long long exponent = n / 2 + 1;\\n            ans = (power(base, exponent, modu) * power(4, exponent - 1, modu)) % modu;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787460,
                "title": "c-fast-exponentiation-and-modular-arithmetic",
                "content": "# Approach\\nLet\\'s say we need to find the number of good digit strings of length 2.\\nn = 2; \\nWe have two indices: 0 and 1. 0 is even and 1 is odd. For even indices we have 5 choices (0, 2, 4, 6, and 8) and for odd indices we have 4 choices (2, 3, 5, 7, four single digit prime numbers). So the total number of good digit strings of length 2 is 5 * 4 = 20. Now let\\'s say n = 4. Now we have indices 0, 1, 2, 3. For each of the incides 0 and 2, we have 5 choices, a total of 5 * 5 = 25 and for each of the incides 1 and 3, we have 4 choices, a total of 4 * 4 = 16. The total number of good digit strings of length 4 is 25 * 16 = 400. \\n\\nIn a string of length n, let\\'s assume that the number of even incides is m and the number of odd incides is k. Then the total number of good digit strings of length n is 5^m * 4^k. Since here we have very large number n, we will surely get an overflow if we do an exponentiation. Therefore the problems asks us to find the answer modulo 10^9 + 7 in order to get a number within the range of int. \\nConsequently we have to make use of modular arithmetic.  We can write a for loop to find the exponent of a number by taking the modulo of the product at each step. But I didn\\'t use a for loop because I thought that would be slow and therefore I used the fast exponentiation algorithm.\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1) irrespective of stack space used by the recursion\\n\\n# Code\\n```\\n\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int evenBase = 5;\\n        int oddBase = 4;\\n\\n        long long evenExp, oddExp;\\n\\n        if(n % 2 == 0)\\n        {\\n            evenExp = n / 2;\\n            oddExp = evenExp;\\n        } else \\n        {\\n            oddExp = n / 2;\\n            evenExp = oddExp + 1;\\n        }\\n\\n        long long even = exponential(evenBase, evenExp);\\n        long long odd = exponential(oddBase, oddExp);\\n\\n        long long ans = ( (even % MOD) * (odd % MOD) ) % MOD;\\n\\n        return ans;\\n    }\\nprivate:\\n    long long exponential(long long b, long long e)\\n    {\\n        if (b == 1 || e == 0)\\n            return 1;\\n        if (b == 0)\\n            return 0;\\n        if (e == 1)\\n            return b;\\n\\n        long long x = exponential(b, e / 2);\\n        long long ans = ((x % MOD) * (x % MOD)) % MOD;\\n        if (e % 2)\\n        {\\n            return ((b % MOD) * (ans % MOD)) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int evenBase = 5;\\n        int oddBase = 4;\\n\\n        long long evenExp, oddExp;\\n\\n        if(n % 2 == 0)\\n        {\\n            evenExp = n / 2;\\n            oddExp = evenExp;\\n        } else \\n        {\\n            oddExp = n / 2;\\n            evenExp = oddExp + 1;\\n        }\\n\\n        long long even = exponential(evenBase, evenExp);\\n        long long odd = exponential(oddBase, oddExp);\\n\\n        long long ans = ( (even % MOD) * (odd % MOD) ) % MOD;\\n\\n        return ans;\\n    }\\nprivate:\\n    long long exponential(long long b, long long e)\\n    {\\n        if (b == 1 || e == 0)\\n            return 1;\\n        if (b == 0)\\n            return 0;\\n        if (e == 1)\\n            return b;\\n\\n        long long x = exponential(b, e / 2);\\n        long long ans = ((x % MOD) * (x % MOD)) % MOD;\\n        if (e % 2)\\n        {\\n            return ((b % MOD) * (ans % MOD)) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785208,
                "title": "easy-to-understand-code-c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long m = 1e9+7;\\n    long long power(long long a, long long d){\\n        if(d == 0) return 1;\\n        long long ans = power(a, d/2);\\n        ans *= ans;\\n        ans = ans%m;\\n        if(d%2 == 1){\\n            ans*=a;\\n            ans = ans%m;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even = n%2+n/2;   // 0,2,4,6,8 ->even number.. \\n        long long odd = n/2;    // 2,3,5,7   ->prime number...\\n        long long rans = (power(5,even)*power(4,odd))%m;\\n        rans = rans%m;\\n        return rans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long m = 1e9+7;\\n    long long power(long long a, long long d){\\n        if(d == 0) return 1;\\n        long long ans = power(a, d/2);\\n        ans *= ans;\\n        ans = ans%m;\\n        if(d%2 == 1){\\n            ans*=a;\\n            ans = ans%m;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even = n%2+n/2;   // 0,2,4,6,8 ->even number.. \\n        long long odd = n/2;    // 2,3,5,7   ->prime number...\\n        long long rans = (power(5,even)*power(4,odd))%m;\\n        rans = rans%m;\\n        return rans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783982,
                "title": "java-simple-approch",
                "content": "/* so basic approch is to first get the even number and odd number postion in size n\\nthis can be achieve by formula :\\nto get odd number = n/2;\\nto get even number = n/2+n%2 or n-odd;\\nnow when we get even and odd positions at even postion we have to keep an even number from range 0-9. all the even number in range 0-9 is 0,2,4,6,8, total of 5 number\\nand at odd postion keep prime number which is 2,3,5,7 total of 4;\\nto get permuation 5^even * 4^odd;\\nbut we cannot use power function directly because we are dealing with  large cases\\nmake a function power \\nif power is even just do (x^y/2) *(x^y/2)\\nif odd (x^y/2)*(x^y/2)*x;\\nuse recursion to get power and base case is if power y=0 retutn 1;\\n*/\\nclass Solution {\\n    long  mod =1000000007;\\n    public int  countGoodNumbers(long n) {\\n        long odd = n/2;\\n        long even = (n/2)+(n%2);\\n        int ans = (int)((power(5,even)*power(4,odd))%mod);\\n        return ans;\\n        \\n    }\\n    long power(long x,long y)\\n    {\\n        if(y==0)\\n        {\\n            return 1;\\n            \\n        }\\n        long ans = power(x,y/2);\\n        ans*=ans;\\n        if(y%2!=0)//if odd multiply by x \\n        {\\n            ans=ans*x;\\n        }\\n        return ans%mod;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    long  mod =1000000007;\\n    public int  countGoodNumbers(long n) {\\n        long odd = n/2;\\n        long even = (n/2)+(n%2);\\n        int ans = (int)((power(5,even)*power(4,odd))%mod);\\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575584,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1807131,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1882025,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1801751,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 2009683,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 2059903,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1993779,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1977129,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1974000,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1788968,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1575584,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1807131,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1882025,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1801751,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 2009683,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 2059903,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1993779,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1977129,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1974000,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            },
            {
                "id": 1788968,
                "content": [
                    {
                        "username": "Antarab",
                        "content": "Input: n = 4\\nOutput: 400\\n\\n![image](https://assets.leetcode.com/users/images/0dc06e48-d0f5-4351-b053-c420471405f8_1627489451.5483553.png)\\n\\nso answer should be 4x4x5x4\\nas in the 1st cell, we can\\'t put 0\\nBut seems like author has not taken that into account and hence the answer for him is-\\n5x4x5x4= 400, which is wrong"
                    },
                    {
                        "username": "Doodlinka",
                        "content": "they explicitly said leading zeros are ok"
                    },
                    {
                        "username": "kmp1084",
                        "content": "They are asking for \"good digit strings of length n\" and not good numbers of length n, hence the first digit can be a 0 even when n > 1."
                    },
                    {
                        "username": "anau99",
                        "content": "//Base\\nN=1 odd index odd-index positions in the string will be one of the numbers (0, 2, 4, 6, 8) -> ans = 5\\nN=2 x0x1 -> ans = 5x4 (x1 will be one of (3,5,7,2))\\nN= 3 x0x1x2 -> ans = 5x4x5\\nN=4 x0x1x2x3 -> ans = 5x4x5x4\\n...\\nif N is odd: ans = 5^(n/2+1) * 4^(n/2),\\nif N is even: ans = 5^(n/2)*4^(n/2)."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "maybe try this problem before https://leetcode.com/problems/powx-n/ \\ncurrent problem uses a concept from that problem"
                    },
                    {
                        "username": "haseebh",
                        "content": "I presume that the question is stating that the primes it is talking about is only 2, 3, 5 and 7. It seems as an example at first glance but then you realise we have infinite number of primes and inorder for this problem to be solvable, we must use only limited number of them. Poorly written problem description."
                    },
                    {
                        "username": "adi_kan",
                        "content": "The value 806166225460393 is too large for long"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "Return it mod 1e9+7."
                    },
                    {
                        "username": "bharsa09",
                        "content": "binary exponentiation !!!"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Setter tried to make my life easier by allowing leading zeros but ended up confusing me more :|"
                    },
                    {
                        "username": "xvarunx331",
                        "content": " `function goodNumber(n, pow) {\\n    if (pow === 0) return 1;\\n    let ans = goodNumber(n, Math.floor(pow / 2));\\n    ans *= ans;\\n    ans %= 1e9 + 7;;\\n    if (pow % 2 !== 0)\\n        ans *= n;\\n    ans %= 1000000007;\\n    return ans;\\n}\\n\\nfunction countGoodNumbers(n: number): number {\\n    let odd = n / 2;\\n    let even = Math.floor(odd) + n % 2;\\n    let mod = 1e9 + 7;;\\n    let res = goodNumber(5, even);\\n    let res1 = goodNumber(4, Math.floor(odd));\\n    return ((res * res1) % mod)\\n};\\n\\nWhy is the failing when it works in my local"
                    },
                    {
                        "username": "Mansi_Soni",
                        "content": "failing on bigger testcases even after using long long and mod\\n#define mod 10000000007\\n#define ll long long \\nclass Solution {\\n    ll pow(ll x, ll y){\\n        if(y==0) return 1;\\n        else if(y%2==0) return (pow((x*x)%mod, y/2)) %mod;\\n\\n        else return ( x*pow( (x*x)%mod, (y-1)/2 ) ) %mod;\\n    }\\n\\npublic:\\n    int countGoodNumbers(long long n) {\\n        int even= n/2 +n%2;\\n        int odd=n/2;\\n        return (pow(5, even)*pow(4, odd))%mod;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ahmed-ata",
                        "content": "try long long for odd and even as well and also apply mod on x while squaring. "
                    }
                ]
            }
        ]
    }
]