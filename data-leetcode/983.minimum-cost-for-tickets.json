[
    {
        "title": "Minimum Cost For Tickets",
        "question_content": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\n\n\ta 1-day pass is sold for costs[0] dollars,\n\ta 7-day pass is sold for costs[1] dollars, and\n\ta 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\n\tFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n&nbsp;\nExample 1:\n\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n\nExample 2:\n\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n\n&nbsp;\nConstraints:\n\n\t1 <= days.length <= 365\n\t1 <= days[i] <= 365\n\tdays is in strictly increasing order.\n\tcosts.length == 3\n\t1 <= costs[i] <= 1000",
        "solutions": [
            {
                "id": 226659,
                "title": "two-dp-solutions-with-pictures",
                "content": "The higher is the bar, the more you\\'re expected to use dynamic programming (DP) during an interview. This technique requires a lot of practice to grasp; if you\\'ve mastered the recursion, DP is the next level.\\n\\nThis problem appeared on LeetCode [weekly contest #121](https://leetcode.com/contest/weekly-contest-121), and it\\'s a good problem to practice the DP thinking.\\n<!--\\n# Problem Description\\nIn a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365.\\n\\nTrain tickets are sold in 3 different ways:\\n- 1-day pass is sold for costs[0] dollars;\\n- 7-day pass is sold for costs[1] dollars;\\n- 30-day pass is sold for costs[2] dollars.\\n\\nThe passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.\\n\\nReturn the minimum number of dollars you need to travel every day in the given list of days.\\n# Coding Practice\\nTry solving this problem before moving on to the solutions. It is available on LeetCode Online Judge ([983. Minimum Cost For Tickets](https://leetcode.com/problems/minimum-cost-for-tickets/)). Also, as you read through a solution, try implementing it yourself.\\n\\nLeetCode is my favorite destinations for algorithmic problems. It has 978 problems and counting, with test cases to validate the correctness, as well as computational and memory complexity. There is also a large community discussing different approaches, tips and tricks.\\n-->\\n# Intuition\\nFor each travel day, we can buy a one-day ticket, or use 7-day or 30-day pass as if we would have purchased it 7 or 30 days ago. We need to track rolling costs for at least 30 days back, and use them to pick the cheapest option for the next travel day.\\n\\nHere, we can use two approaches: track cost for all calendar days, or process only travel days. The first approach is simpler to implement, but it\\'s slower. Since the problem is limited to one calendar year, it does not make much of a difference; for a generalized problem I would recommend the second approach.\\n# 1. Track calendar days\\nWe track the minimum cost for all calendar days in ```dp```. For non-travel days, the cost stays the same as for the previous day. For travel days, it\\'s a minimum of yesterday\\'s cost plus single-day ticket, or cost for 8 days ago plus 7-day pass, or cost 31 days ago plus 30-day pass.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1548621855.png)\\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n  unordered_set<int> travel(begin(days), end(days));\\n  int dp[366] = {};\\n  for (int i = 1; i < 366; ++i) {\\n    if (travel.find(i) == travel.end()) dp[i] = dp[i - 1];\\n    else dp[i] = min({ dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2]});\\n  }\\n  return dp[365];\\n}\\n```\\n# Optimizations\\nIn the previous solution, we store cost for all calendar days. However, since we only look 30 days back, we can just store the cost for last 30 days in a rolling array.\\n\\nIn addition, we can only look at calendar days within our first and last travel dates, as [@zengxinhai](https://leetcode.com/zengxinhai) suggested.\\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n  unordered_set<int> travel(begin(days), end(days));\\n  int dp[30] = {};\\n  for (int i = days.front(); i <= days.back(); ++i) {\\n    if (travel.find(i) == travel.end()) dp[i % 30] = dp[(i - 1) % 30];\\n    else dp[i % 30] = min({ dp[(i - 1) % 30] + costs[0],\\n        dp[max(0, i - 7) % 30] + costs[1], dp[max(0, i - 30) % 30] + costs[2] });\\n  }\\n  return dp[days.back() % 30];\\n}\\n```\\n# Complexity analysis\\n- Time Complexity: O(N), where N is the number of calendar days.\\n- Space Complexity: O(N) or O(31) for the optimized solution. Stricter, it\\'s a maximum duration among all pass types.\\n# 2. Track travel days\\nWe track the minimum ```cost``` for each travel day. We process only travel days and store {day, cost} for 7-and 30-day passes in the ```last7``` and ```last30``` queues. After a pass \\'expires\\', we remove it from the queue. This way, our queues only contains travel days for the last 7 and 30 days, and the cheapest pass prices are in the front of the queues.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1548617861.png)\\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs, int cost = 0) {\\n  queue<pair<int, int>> last7, last30;\\n  for (auto d : days) {\\n    while (!last7.empty() && last7.front().first + 7 <= d) last7.pop();\\n    while (!last30.empty() && last30.front().first + 30 <= d) last30.pop();\\n    last7.push({ d, cost + costs[1] });\\n    last30.push({ d, cost + costs[2] });\\n    cost = min({ cost + costs[0], last7.front().second, last30.front().second });\\n  }\\n  return cost;\\n}\\n```\\n# Complexity analysis\\n- Time Complexity: O(n), where n is the number of travel days.\\n- Space Complexity: O(38). Stricter, it\\'s a sum of duration for all pass types (1 + 7 + 30 in our case).",
                "solutionTags": [],
                "code": "```dp```\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n  unordered_set<int> travel(begin(days), end(days));\\n  int dp[366] = {};\\n  for (int i = 1; i < 366; ++i) {\\n    if (travel.find(i) == travel.end()) dp[i] = dp[i - 1];\\n    else dp[i] = min({ dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2]});\\n  }\\n  return dp[365];\\n}\\n```\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n  unordered_set<int> travel(begin(days), end(days));\\n  int dp[30] = {};\\n  for (int i = days.front(); i <= days.back(); ++i) {\\n    if (travel.find(i) == travel.end()) dp[i % 30] = dp[(i - 1) % 30];\\n    else dp[i % 30] = min({ dp[(i - 1) % 30] + costs[0],\\n        dp[max(0, i - 7) % 30] + costs[1], dp[max(0, i - 30) % 30] + costs[2] });\\n  }\\n  return dp[days.back() % 30];\\n}\\n```\n```cost```\n```last7```\n```last30```\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs, int cost = 0) {\\n  queue<pair<int, int>> last7, last30;\\n  for (auto d : days) {\\n    while (!last7.empty() && last7.front().first + 7 <= d) last7.pop();\\n    while (!last30.empty() && last30.front().first + 30 <= d) last30.pop();\\n    last7.push({ d, cost + costs[1] });\\n    last30.push({ d, cost + costs[2] });\\n    cost = min({ cost + costs[0], last7.front().second, last30.front().second });\\n  }\\n  return cost;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 630868,
                "title": "explanation-from-someone-who-took-2-hours-to-solve",
                "content": "**before starting with DP one must master the art of recursion**\\nit took me 2 hours to solve this and 1 hours wo write this post , hopefully you will understand the question. and how we get the solution\\n\\n**step1 : understand the problem**\\nhere we are given days and cost of passes for 1 day pass, week pass, month pass, \"pass means , once you buy it is valid for that some period of time which means free travel during that period\"\\n\\n**step 2: logic building and deriving recurence relation**\\n\\n**1st sub step : asking questions**\\nwhen we buy pass what should we think ? \\nwe should think like, what pass should i buy today ? \\nshould i buy pass of one day , week or month pass ? \\n\\n**2nd sub step : Ariving at recurence relation**\\nif i buy one month pass , then i would be able to travel for next 30 days for free, then my cost will be 30 day pass cost + cost for remaining days after 30 day\\nif i buy one week pass , then i would be able to travel for next 7 days for free, then my cost will be 7 day pass cost + cost for remaining days after 30 day\\nif i buy 1 day pass ....... (\"you get it\");\\n\\nso we can skip to next day OR , next week OR next month ,\\nso cost for i would total pay today is going to be ? ... ? \\n```\\n# a = cost[one day pass] + cost of next day\\n# b = cost[ week pass ] + cost of next day after week\\n# c = cost[ month pass ] + cost of next day after month\\n```\\n\\nie we can skip 1, 7, or 30 days ;\\ncost = min( a , b , c )\\n\\nhere is 1st solution using recursion ( TLE )\\n**step 3: code recursive solution**\\n```\\n int sub(vector<int> &day, vector<int> &cost, int si)\\t\\t// si denotes starting index\\n    {\\n        int n = day.size();\\n        if(si>=n)   return 0;\\n        \\n        int cost_day = cost[0] + sub(day , cost , si+1);\\n        \\n        int i;\\n        for(i = si ; i<n and day[i]<day[si]+7 ; i++);   //skip till ith day is curr_day+7 as we are buying week pass\\n        int cost_week = cost[1] + sub(day, cost, i);\\n        \\n        for(i = si ; i<n and day[i]<day[si]+30 ; i++);   //skip till ith day is curr_day+30 as we are buying month pass\\n        int cost_month = cost[2] + sub(day, cost, i);      \\n        \\n        return min({cost_day, cost_week , cost_month  });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {        \\n        return sub(days,costs,0);\\n    }\\n```\\nNow you know the sub problems so we can convert OUR recursion solution to top-down-memoization , ie we store our answers at each step before returning, then if we already knows the answer , we can return right back withour re calculating;\\n\\n**step4 : memoization-top-down**\\n```\\nvector<int> dp;\\n    int sub(vector<int> &day, vector<int> &cost, int si)    // subproblem\\n    {\\n        int n = day.size();\\n        if(si>=n)   return 0;\\n        \\n        if(dp[si])  return dp[si];      // ie we aready knows the answer so no need to re calculate , return answer.\\n        \\n        int cost_day = cost[0] + sub(day , cost , si+1);\\n        \\n        int i;\\n        for(i = si ; i<n and day[i]<day[si]+7 ; i++);\\n        int cost_week = cost[1] + sub(day, cost, i);\\n        \\n        for(i = si ; i<n and day[i]<day[si]+30 ; i++);\\n        int cost_month = cost[2] + sub(day, cost, i);     \\n        \\n        dp[si] = min({cost_day, cost_week , cost_month  });   // we store answer for future references \\n        \\n        return dp[si];\\n    } \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {        \\n        dp.resize(367);\\n        return sub(days,costs,0);    \\n    }\\n```\\n\\nso you see , once we get to the recursive solution we converted it into DP top-dow using 3-4 lines.\\n\\n**step 5 : now you know the base casses , you know the sub problems so try coming up with bottom up solution yourself** \\n\\n```\\nint mincostTickets(vector<int>& DAYS, vector<int>& cost) {\\n        \\n        unordered_set<int> days(DAYS.begin(),DAYS.end());\\n        vector<int> dp(367);\\n        \\n        for(int i=1 ; i<366 ; i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(days.find(i) != days.end())\\n            {\\n\\t\\t\\t// cost of ith day , decision of ith day will be\\n                dp[i] = min({ dp[i - 1] + cost[0],   // 1st case\\n                             dp[max(0, i - 7)] + cost[1],  // 2nd case\\n                             dp[max(0, i - 30)] + cost[2]});  // 3rd case\\n            }\\n        }\\n        return dp[365];\\n    }\\n```\\n\\n**thanks for reading**\\n**previous tutorial on DP** \\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/discuss/642422/Lets-solve-it-together-%3A-step-by-step\\n\\nhttps://leetcode.com/problems/dungeon-game/discuss/745340/post-Dedicated-to-beginners-of-DP",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# a = cost[one day pass] + cost of next day\\n# b = cost[ week pass ] + cost of next day after week\\n# c = cost[ month pass ] + cost of next day after month\\n```\n```\\n int sub(vector<int> &day, vector<int> &cost, int si)\\t\\t// si denotes starting index\\n    {\\n        int n = day.size();\\n        if(si>=n)   return 0;\\n        \\n        int cost_day = cost[0] + sub(day , cost , si+1);\\n        \\n        int i;\\n        for(i = si ; i<n and day[i]<day[si]+7 ; i++);   //skip till ith day is curr_day+7 as we are buying week pass\\n        int cost_week = cost[1] + sub(day, cost, i);\\n        \\n        for(i = si ; i<n and day[i]<day[si]+30 ; i++);   //skip till ith day is curr_day+30 as we are buying month pass\\n        int cost_month = cost[2] + sub(day, cost, i);      \\n        \\n        return min({cost_day, cost_week , cost_month  });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {        \\n        return sub(days,costs,0);\\n    }\\n```\n```\\nvector<int> dp;\\n    int sub(vector<int> &day, vector<int> &cost, int si)    // subproblem\\n    {\\n        int n = day.size();\\n        if(si>=n)   return 0;\\n        \\n        if(dp[si])  return dp[si];      // ie we aready knows the answer so no need to re calculate , return answer.\\n        \\n        int cost_day = cost[0] + sub(day , cost , si+1);\\n        \\n        int i;\\n        for(i = si ; i<n and day[i]<day[si]+7 ; i++);\\n        int cost_week = cost[1] + sub(day, cost, i);\\n        \\n        for(i = si ; i<n and day[i]<day[si]+30 ; i++);\\n        int cost_month = cost[2] + sub(day, cost, i);     \\n        \\n        dp[si] = min({cost_day, cost_week , cost_month  });   // we store answer for future references \\n        \\n        return dp[si];\\n    } \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {        \\n        dp.resize(367);\\n        return sub(days,costs,0);    \\n    }\\n```\n```\\nint mincostTickets(vector<int>& DAYS, vector<int>& cost) {\\n        \\n        unordered_set<int> days(DAYS.begin(),DAYS.end());\\n        vector<int> dp(367);\\n        \\n        for(int i=1 ; i<366 ; i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(days.find(i) != days.end())\\n            {\\n\\t\\t\\t// cost of ith day , decision of ith day will be\\n                dp[i] = min({ dp[i - 1] + cost[0],   // 1st case\\n                             dp[max(0, i - 7)] + cost[1],  // 2nd case\\n                             dp[max(0, i - 30)] + cost[2]});  // 3rd case\\n            }\\n        }\\n        return dp[365];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227130,
                "title": "java-dp-solution-with-detailed-comment-and-explanation",
                "content": "dp[i] means up to i-th day the minimum cost of the tickets. The size of the dp array depends on the last travel day, so we don\\'t need an array length to be 365.\\n\\nWe do need a boolean array to mark the travel days, the reason is if it is not a travel day we don\\'t need a ticket. However, if it is a travel day, we consider three scenarios (with three types of tickects):\\n\\nIf a 1-day ticket on day i, dp[i] = dp[i - 1] + cost[0]\\nIf a 7-day ticket ending on day i, dp[i] = min(dp[i - 7], dp[i - 6] ... dp[i - 1]) + cost[1]\\nIf a 30-day ticket ending on day i, dp[i] = min(dp[i - 30], dp[i - 29] ... dp[i - 1]) + cost[2]\\n\\nBut since the value of dp array is increasing, therefore:\\nFor a 7-day ticket ending on day i, dp[i] = dp[i - 7] + cost[1] \\nFor a 30-day ticket ending on day i, dp[i] = dp[i - 30] + cost[2] \\n\\n\\n\\t public int mincostTickets(int[] days, int[] costs) {\\n\\t    // length up to the last travel + 1 day is good enough (no need for 365)\\n        int lastDay = days[days.length - 1]; \\n        // dp[i] means up to i-th day the minimum cost of the tickets\\n        int[] dp = new int[lastDay + 1]; \\n        boolean[] isTravelDays = new boolean[lastDay + 1];\\n        // mark the travel days\\n        for(int day : days) isTravelDays[day] = true;\\n        \\n        for(int i = 1; i <= lastDay; i++) {\\n            if(!isTravelDays[i]) { // no need to buy ticket if it is not a travel day\\n                dp[i] = dp[i - 1];\\n                continue;\\n            }\\n            // select which type of ticket to buy\\n            dp[i] = costs[0] + dp[i - 1]; // 1-day\\n            dp[i] = Math.min(costs[1] + dp[Math.max(i - 7, 0)], dp[i]); // 7-day\\n            dp[i] = Math.min(costs[2] + dp[Math.max(i - 30, 0)], dp[i]); // 30-day\\n        }\\n        return dp[lastDay];\\n    }",
                "solutionTags": [],
                "code": "dp[i] means up to i-th day the minimum cost of the tickets. The size of the dp array depends on the last travel day, so we don\\'t need an array length to be 365.\\n\\nWe do need a boolean array to mark the travel days, the reason is if it is not a travel day we don\\'t need a ticket. However, if it is a travel day, we consider three scenarios (with three types of tickects):\\n\\nIf a 1-day ticket on day i, dp[i] = dp[i - 1] + cost[0]\\nIf a 7-day ticket ending on day i, dp[i] = min(dp[i - 7], dp[i - 6] ... dp[i - 1]) + cost[1]\\nIf a 30-day ticket ending on day i, dp[i] = min(dp[i - 30], dp[i - 29] ... dp[i - 1]) + cost[2]\\n\\nBut since the value of dp array is increasing, therefore:\\nFor a 7-day ticket ending on day i, dp[i] = dp[i - 7] + cost[1] \\nFor a 30-day ticket ending on day i, dp[i] = dp[i - 30] + cost[2] \\n\\n\\n\\t public int mincostTickets(int[] days, int[] costs) {\\n\\t    // length up to the last travel + 1 day is good enough (no need for 365)\\n        int lastDay = days[days.length - 1]; \\n        // dp[i] means up to i-th day the minimum cost of the tickets\\n        int[] dp = new int[lastDay + 1]; \\n        boolean[] isTravelDays = new boolean[lastDay + 1];\\n        // mark the travel days\\n        for(int day : days) isTravelDays[day] = true;\\n        \\n        for(int i = 1; i <= lastDay; i++) {\\n            if(!isTravelDays[i]) { // no need to buy ticket if it is not a travel day\\n                dp[i] = dp[i - 1];\\n                continue;\\n            }\\n            // select which type of ticket to buy\\n            dp[i] = costs[0] + dp[i - 1]; // 1-day\\n            dp[i] = Math.min(costs[1] + dp[Math.max(i - 7, 0)], dp[i]); // 7-day\\n            dp[i] = Math.min(costs[2] + dp[Math.max(i - 30, 0)], dp[i]); // 30-day\\n        }\\n        return dp[lastDay];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 226670,
                "title": "java-dp-solution-with-explanation-o-n",
                "content": "Let minCost(i) denote the minimum cost that will be payed for all trips on days 1 to day 365.\\nThe desired answer is then minCost(365).\\n\\nCalculation minCost(i):\\n\\nIf no trip on day i, then minCost(i) = minCost(i-1).\\n minCost(i)=0 for all i \\u2264 0.\\nOtherwise:\\nIf a 1-day pass on day i. In this case,  minCost(i) =  minCost(i) + costs[0].\\nIf a 7-day pass ending on day i. then : In this case, minCost(i) = min(minCost(i \\u2212 7), minCost(i \\u2212 6), \\u2026, minCost(i \\u2212 1)) + costs[1].\\nBut since since minCost is increasing (adding a day never reduces the minCost) hence:\\n minCost(i) = minCost(i \\u2212 7) + costs[2]\\n\\nSame case for 30-day pass also.\\n\\n```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        boolean[] dayIncluded = new boolean[366];\\n        for (int day : days) {\\n            dayIncluded[day] = true;\\n        }\\n        int[] minCost = new int[366];\\n        minCost[0] = 0;\\n        for (int day = 1; day <= 365; ++day) {\\n            if (!dayIncluded[day]) {\\n                minCost[day] = minCost[day-1];\\n                continue;\\n            }\\n            int min;\\n            min = minCost[day-1] + costs[0];\\n            min =Math.min(min, minCost[Math.max(0, day-7)] + costs[1]);\\n            min = Math.min(min, minCost[Math.max(0, day-30)] + costs[2]);\\n            minCost[day] = min;\\n        }\\n\\n        return minCost[365];\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        boolean[] dayIncluded = new boolean[366];\\n        for (int day : days) {\\n            dayIncluded[day] = true;\\n        }\\n        int[] minCost = new int[366];\\n        minCost[0] = 0;\\n        for (int day = 1; day <= 365; ++day) {\\n            if (!dayIncluded[day]) {\\n                minCost[day] = minCost[day-1];\\n                continue;\\n            }\\n            int min;\\n            min = minCost[day-1] + costs[0];\\n            min =Math.min(min, minCost[Math.max(0, day-7)] + costs[1]);\\n            min = Math.min(min, minCost[Math.max(0, day-30)] + costs[2]);\\n            minCost[day] = min;\\n        }\\n\\n        return minCost[365];\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 228421,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp=[0 for i in range(days[-1]+1)]\\n        for i in range(days[-1]+1):\\n             if i not in days:\\n                dp[i]=dp[i-1]\\n             else:\\n                dp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n        return dp[-1]\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp=[0 for i in range(days[-1]+1)]\\n        for i in range(days[-1]+1):\\n             if i not in days:\\n                dp[i]=dp[i-1]\\n             else:\\n                dp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n        return dp[-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810806,
                "title": "python-dp-solution-explanation",
                "content": "**Explanation:**\\n\\ndp[i] means overall costs untill i-th day (included)\\nwe have to check two conditions:\\n\\n**1. i in days list:**\\nwe have three option:\\na) 1-pass:` dp[i] = dp[i-1] + costs[0]`\\nb) 7-pass: `dp[i] = dp[i-7] + costs[1]`\\nc) 30-pass:` dp[i] = dp[i-30] + costs[2]`\\n*in order to avoid negative index:*\\na) 1-pass:` dp[i] =dp[max(0,i-1)] + costs[0]`\\nb) 7-pass: `dp[i] = dp[max(0,i-7)] + costs[1]`\\nc) 30-pass:` dp[i] = dp[max(0,i-30)] + costs[2]`\\n**2. i not in days:**\\ndp[i] = dp[i-1] \\nwhich simply means we don\\'t have to spend money, and total costs remains same\\n\\n```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tdp=[0 for i in range(days[-1]+1)]\\n\\tdy = set(days)\\n\\tfor i in range(days[-1]+1):\\n\\t\\tif i not in dy: dp[i]=dp[i-1]\\n\\t\\telse: dp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n\\treturn dp[-1]\\n```\\n***\\n**Time complexity:** `O(n)`\\n**Space complexity:**` O(n)`\\nn = last day in days list + 1, time & space complexity max: `O(366)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tdp=[0 for i in range(days[-1]+1)]\\n\\tdy = set(days)\\n\\tfor i in range(days[-1]+1):\\n\\t\\tif i not in dy: dp[i]=dp[i-1]\\n\\t\\telse: dp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 227321,
                "title": "top-down-dp-logical-thinking",
                "content": "> Intuitively, we calculate total costs for each possible way of buying tickets and found the one with the minimum cost.\\n> That causes TLE.\\n> Why does it cause TLE? Because there are duplicate calculations.\\n> \\n\\n> Let\\'s decompose the problem: **minimum cost from day[i]** for i is the next day to buy tickets\\n> on day[i],  we can buy 1-day pass, 7-day pass or 30-day pass.\\n> - If we buy 1-day pass, cost from day[i] = costs[0] + **minimum cost from day[j]** for j is the next day to buy tickets\\n> - If we buy 7-day pass, cost from day[i] = costs[1] + **minimum cost from day[j]** for j is the next day to buy tickets\\n> - If we buy 30-day pass, cost from day[i] = costs[2] + **minimum cost from day[j]** for j is the next day to buy tickets\\n> \\n>**minimum cost from day[i]** is the minimum among 3 costs above\\n>Optimal substructure is found. We could apply dynamic programing.\\n\\n****\\n```\\n    private int[] memo;\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        memo = new int[days.length];\\n        return mincostTickets(0, days, costs);\\n    }\\n    \\n    private int mincostTickets(int dayIndex, int[] days, int[] costs) {\\n        if (dayIndex == days.length) {\\n            return 0;\\n        }\\n        \\n        if (memo[dayIndex] != 0) {\\n            return memo[dayIndex];\\n        }\\n        \\n        // Choose a pass, update dayIndex, and accumulate totalCost\\n        int totalCostDay = costs[0] + mincostTickets(getNextDayToBuy(dayIndex, days, 1), days, costs);   \\n        int totalCostWeek = costs[1] + mincostTickets(getNextDayToBuy(dayIndex, days, 7), days, costs);\\n        int totalCostMonth = costs[2] + mincostTickets(getNextDayToBuy(dayIndex, days, 30), days, costs);\\n        \\n        // Return the one with min totalCost\\n        memo[dayIndex] = Math.min(totalCostMonth, Math.min(totalCostDay, totalCostWeek));\\n        return memo[dayIndex];\\n    }\\n    \\n    private int getNextDayToBuy(int dayIndex, int[] days, int duration) {\\n        int endDay = days[dayIndex] + duration - 1;\\n        int newDayIndex = dayIndex;\\n\\t\\t\\n        while (newDayIndex < days.length && days[newDayIndex] <= endDay) {\\n            newDayIndex++;\\n        }\\n        \\n        return newDayIndex;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    private int[] memo;\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        memo = new int[days.length];\\n        return mincostTickets(0, days, costs);\\n    }\\n    \\n    private int mincostTickets(int dayIndex, int[] days, int[] costs) {\\n        if (dayIndex == days.length) {\\n            return 0;\\n        }\\n        \\n        if (memo[dayIndex] != 0) {\\n            return memo[dayIndex];\\n        }\\n        \\n        // Choose a pass, update dayIndex, and accumulate totalCost\\n        int totalCostDay = costs[0] + mincostTickets(getNextDayToBuy(dayIndex, days, 1), days, costs);   \\n        int totalCostWeek = costs[1] + mincostTickets(getNextDayToBuy(dayIndex, days, 7), days, costs);\\n        int totalCostMonth = costs[2] + mincostTickets(getNextDayToBuy(dayIndex, days, 30), days, costs);\\n        \\n        // Return the one with min totalCost\\n        memo[dayIndex] = Math.min(totalCostMonth, Math.min(totalCostDay, totalCostWeek));\\n        return memo[dayIndex];\\n    }\\n    \\n    private int getNextDayToBuy(int dayIndex, int[] days, int duration) {\\n        int endDay = days[dayIndex] + duration - 1;\\n        int newDayIndex = dayIndex;\\n\\t\\t\\n        while (newDayIndex < days.length && days[newDayIndex] <= endDay) {\\n            newDayIndex++;\\n        }\\n        \\n        return newDayIndex;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762493,
                "title": "c-dp-solution-w-detailed-explanation",
                "content": "Working Example: days = [1,4,6,7,8,20], costs = [2,7,15]\\nEssentially the question breaks down to \"what is your total expenses on `day 20`\". Since we have three possible tickets with varying durations, the total cost of  `day 20` is either the cost of your total expenses on `day 19` + `2`,  `day 13` + `7`, or `day 0` + `15`, (`day 0` being the day before any possible trip, we can\\'t have negative days). As you can see the total cost of any day relies on the total cost of previous days. Furthermore, you should see that our original problem breaks itself down into the same issue just with earlier days. If you have an idea on how to approach the problem, I suggest you stop reading and try the problem out for yourself.\\n\\n1) This is a classic [Minimum (Maximum) Path to Reach a Target](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Minimum-(Maximum)-Path-to-Reach-a-Target) problem. First we have to initialize a vector/array `dp` representing all 365 days plus 1 (`day 0`). Since we are trying to minimize cost, I initalize the total cost of each day to `INT_MAX`. However, if `dp[0]` or `day 0` represents the day before any trip we shouldn\\'t have to minimize the cost of this day thus its value is set to zero.\\n\\n```\\nunordered_map<int,int> tickets;\\n        tickets[1] = costs[0];\\n        tickets[7] = costs[1];\\n        tickets[30] = costs[2];\\n\\t\\t\\nvector<int> dp(366, INT_MAX);\\ndp[0] = 0\\n```\\n*You could do some clever indexing with `dp[0]` and `dp[n]` representing your first and last trip respectively, but I found that to be overall too confusing. (It is also here I initialized the cost and duration of each ticket*\\n\\n2) We take a bottom-up approach to this problem as before answering `dp[20]` we answer `dp[19]`, `dp[13]`, etc. Also note that we start on `day 1` as we are not trying to minimize the cost of `day 0`\\n```\\nfor(int i=1; i<366; ++i){\\n//...\\n}\\n```\\n\\n3) Taking our idea from our intro and `2)` we have our solution. We should note that if `day i` is not included in our argument `days` that day\\'s total expensenses is equal `day i-1` since we didn\\'t have to consider buying a ticket.\\n```\\nif(find(days.begin(), days.end(), i) == days.end()){\\n\\tdp[i] = dp[i-1];\\n\\tcontinue;\\n}\\nfor(auto ticket : tickets){\\n\\tdp[i] = min(dp[i], dp[max(0, i-ticket.first)] + ticket.second);\\n}\\n```\\n\\n4) **To illustrate the process**\\n* dp[1] = 2 or `min(dp[0] + 2 dp[0] + 7, dp[0] + 15)`\\n* dp[2] = 2 (we don\\'t have to consider buying a ticket here so we just take the total cost of the previous day)\\n* dp[3] = 2 \\n* dp[4] = 4 or `min(dp[3] + 2, dp[0] + 7, dp[0] + 15)`\\n* dp[5] = 4\\n* dp[6] = 6\\n* dp[7] = 7 or `min(dp[6] + 2, dp[0] + 7, + dp[0]  + 15)`\\n* dp[8] = 9 or `min(dp[7] + 2, dp[1] + 7, + dp[0] + 15)` \\n* etc.\\n*Technically we could just break out of the loop on the last day, but I chose not too. After the last day, the total expenses will remain the same because of our if statement.*\\n\\n5) **Full Solution** (please don\\'t copy pasta the solution without reading the post!)\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        unordered_map<int,int> tickets;\\n        tickets[1] = costs[0];\\n        tickets[7] = costs[1];\\n        tickets[30] = costs[2];\\n        \\n        vector<int> dp(366, INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<366; ++i){\\n            if(find(days.begin(), days.end(), i) == days.end()){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            for(auto ticket : tickets){\\n                dp[i] = min(dp[i], dp[max(0, i-ticket.first)] + ticket.second);\\n            }\\n        }\\n        \\n        return dp[365];\\n    }\\n};\\n```\\n6) Useful [post](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns) for those starting out with DP\\n7) Don\\'t forget to upvote if this post helped you :)\\n...if it didn\\'t please don\\'t downvote... I\\'m sorry I can change!\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nunordered_map<int,int> tickets;\\n        tickets[1] = costs[0];\\n        tickets[7] = costs[1];\\n        tickets[30] = costs[2];\\n\\t\\t\\nvector<int> dp(366, INT_MAX);\\ndp[0] = 0\\n```\n```\\nfor(int i=1; i<366; ++i){\\n//...\\n}\\n```\n```\\nif(find(days.begin(), days.end(), i) == days.end()){\\n\\tdp[i] = dp[i-1];\\n\\tcontinue;\\n}\\nfor(auto ticket : tickets){\\n\\tdp[i] = min(dp[i], dp[max(0, i-ticket.first)] + ticket.second);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        unordered_map<int,int> tickets;\\n        tickets[1] = costs[0];\\n        tickets[7] = costs[1];\\n        tickets[30] = costs[2];\\n        \\n        vector<int> dp(366, INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<366; ++i){\\n            if(find(days.begin(), days.end(), i) == days.end()){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            for(auto ticket : tickets){\\n                dp[i] = min(dp[i], dp[max(0, i-ticket.first)] + ticket.second);\\n            }\\n        }\\n        \\n        return dp[365];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810749,
                "title": "python-js-go-c-by-dp-w-visualization",
                "content": "**Hint**:\\n\\nOptimal substructure for DP\\n\\n----\\n\\nBase case:\\n```\\n# no cost before first day (i.e., no travel)\\ndp[ 0 ] = 0\\n```\\n\\n---\\n\\nGeneral case:\\n\\nFor non-traveling day:\\n\\n```\\n# today is not traveling day, no extra cost\\n\\ndp[ d ] = dp[ d - 1 ] \\n```\\n\\n---\\n\\nFor traveling day:\\n\\n```\\n\\n# compute minimum cost from subproblem\\n\\ndp[ d ] = min( dp[     d - 1      ] + cost[0],\\n               dp[ max(d - 7, 0)  ] + cost[1],\\n\\t\\t\\t   dp[ max(d - 30, 0) ] + cost[2] )\\n\\n# cost[0]: the cost of 1-day-pass ticket\\n# cost[1]: the cost of 7-day-pass ticket\\n# cost[2]: the cost of 30-day-pass ticket\\n```\\n\\nNote:\\nHere we use **max**( d-7, **0**) and **max**( d-30, **0**) to **avoid invalid day index** which is out-of-boundary.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/6d6e30e1-bffe-4911-868c-e3b347944696_1598355889.9800591.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/4c9f0064-9f1d-411e-9759-009f42b80128_1598355901.5866375.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/9dcadfdb-1428-4b94-a2e2-e2e97e464a4e_1598355916.5972583.png)\\n\\n---\\n\\n**Implementation** by Bottom-up DP with iteration (i.e., tabulation method)\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        # index of ticket\\n        _1day_pass, _7day_pass, _30day_pass = 0, 1, 2\\n        \\n        # set of travel days\\n        travel_days = set(days)\\n        \\n        # last travel day\\n        last_traverl_day = days[-1]\\n        \\n        # DP Table, record for minimum cost of ticket to travel\\n        dp_cost = [  0 for _ in range(last_traverl_day+1)]\\n    \\n        \\n        # Solve min cost by Dynamic Programming\\n        for day_i in range(1, last_traverl_day+1):\\n            \\n            \\n            if day_i not in travel_days:\\n                \\n                # today is not traveling day\\n                # no extra cost\\n                dp_cost[day_i] = dp_cost[day_i - 1]\\n            \\n            \\n            else:\\n                \\n                # today is traveling day\\n                # compute optimal cost by DP\\n                \\n                dp_cost[day_i] = min(   dp_cost[ day_i - 1 ]  + costs[ _1day_pass ],\\n                                        dp_cost[ max(day_i - 7, 0) ]  + costs[ _7day_pass ],\\n                                        dp_cost[ max(day_i - 30, 0) ] + costs[ _30day_pass ]     )\\n        \\n        \\n        # Cost on last travel day of this year is the answer\\n        return dp_cost[last_traverl_day]\\n        \\n```\\n\\n---\\n\\n**Implementaion** by Top-down DP with recursion + memoization\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        # to speed up element checking for days\\n        travel_days = set(days)\\n        \\n        # ---------------------------------------------------\\n        \\n        # use python built-in cache as memoization for DP\\n        @cache\\n        def dp(day_d):\\n            \\n            ## Base case\\n            if day_d == 0:\\n                \\n                # no cost on before traveling\\n                return 0\\n            \\n            ## General cases\\n            if day_d not in travel_days:\\n                \\n                # no extra cost on non-traverl day\\n                return dp(day_d-1)\\n            \\n            else:\\n                \\n                # compute minimal cost on travel day\\n                \\n                with_1_day_pass = dp( day_d-1 ) + costs[0]\\n                with_7_day_pass = dp( max( day_d - 7, 0) ) + costs[1]\\n                with_30_day_pass = dp( max( day_d - 30, 0) ) + costs[2]\\n                \\n                return min( with_1_day_pass, with_7_day_pass, with_30_day_pass)\\n            \\n        # ---------------------------------------------------\\n        last_travel_day = days[-1]\\n        \\n        return dp(last_travel_day)\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar mincostTickets = function(days, costs) {\\n    \\n    // index of ticket\\n    const [ _1day, _7day, _30day] = [0, 1, 2];\\n    \\n    // set of travel days\\n    let travelDays = new Set(days);\\n    \\n    let lastTravelDay = days[days.length-1];\\n    \\n    // DP table, record for minimum cost of ticket to travel\\n    dpCost = new Array( lastTravelDay+1 ).fill(0);\\n    \\n    // solve min cost by DP\\n    for( let day_i=1; day_i <= lastTravelDay ; day_i++ ){\\n        \\n        if( travelDays.has(day_i) == false ){\\n            \\n            // today is not traveling day\\n            // no extra cost\\n            dpCost[ day_i ] = dpCost[ day_i - 1 ];\\n            \\n        }else{\\n            \\n            // today is traveling day\\n            // compute optimal min cost\\n            dpCost[ day_i ] = Math.min( dpCost[ day_i - 1 ] + costs[ _1day ],\\n                                        dpCost[ Math.max(day_i - 7, 0) ] + costs[ _7day ], \\n                                        dpCost[ Math.max(day_i - 30, 0) ] + costs[_30day]  );\\n        }\\n    }\\n\\n    return dpCost[lastTravelDay];\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\n// Golang doesn\\'t have natural built in min/max function for integers\\n// Programmer have to implement it manually\\nfunc MinOf(vars ...int) int {\\n    min := vars[0]\\n\\n    for _, i := range vars {\\n        if min > i {\\n            min = i\\n        }\\n    }\\n\\n    return min\\n}\\n\\n\\nfunc Max( x, y int) int {\\n    \\n    if x > y{\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n\\ntype void struct{}\\nvar member void\\n\\nfunc mincostTickets(days []int, costs []int) int {\\n    \\n    // help reader to understand code, to avoid magic number\\n    const _1day, _7day, _30day = 0, 1, 2\\n    \\n    // set of travel days\\n    travelDays := make( map[int]void )\\n    \\n    for _, curTravelDay := range days{\\n        travelDays[ curTravelDay ] = member\\n    }\\n    \\n    // last travel day from input array\\n    lastTraverlDay := days[ len(days) - 1 ]\\n    \\n    // dp table\\n    dpCost := make([]int, lastTraverlDay+1)\\n    \\n    for day_i := 1 ; day_i <= lastTraverlDay ; day_i++ {\\n        \\n        if _, isTravelDay := travelDays[day_i] ; isTravelDay == false{\\n            \\n            // today is not traveling day\\n            // no extra cost\\n            dpCost[ day_i ] = dpCost[ day_i -1 ]\\n        \\n        }else{\\n            \\n                // today is traveling day\\n                // compute optimal cost by DP\\n                \\n                dpCost[day_i] = MinOf( dpCost[ day_i - 1 ]  + costs[ _1day ],\\n                                        dpCost[ Max(day_i - 7, 0) ]  + costs[ _7day ],\\n                                        dpCost[ Max(day_i - 30, 0) ] + costs[ _30day ]     )\\n        }\\n    }\\n    \\n    return dpCost[ lastTraverlDay ]\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        // index of ticket\\n        enum Ticket { _1day, _7day, _30day };\\n        \\n        \\n        // set of travel days\\n        set<int> travelDays = set<int>(days.begin(), days.end());\\n        \\n        int lastTravelDay = days.back();\\n        \\n        // dp table, record for minimum cost ofticket to travel\\n        vector<int> dpCost = vector<int>( lastTravelDay+1 );\\n        \\n        // Solve min cost by DP\\n        for( int day_i = 1; day_i <= lastTravelDay ; day_i++ ){\\n            \\n            if( travelDays.count(day_i) == 0 ){\\n                \\n                // today is not traveling day\\n                // no extra cost\\n                dpCost[ day_i ] = dpCost[ day_i - 1 ];\\n                \\n            }else{\\n                \\n                // today is traveling day\\n                // compute optimal cost by DP\\n                dpCost[ day_i ] = min( {dpCost[ day_i - 1 ]            + costs[ _1day ], \\n                                        dpCost[ max(day_i - 7, 0) ]    + costs[ _7day ], \\n                                        dpCost[ max(day_i - 30, 0) ]   + costs[ _30day]} );\\n            }\\n        }\\n\\n        return dpCost[lastTravelDay];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\n# no cost before first day (i.e., no travel)\\ndp[ 0 ] = 0\\n```\n```\\n# today is not traveling day, no extra cost\\n\\ndp[ d ] = dp[ d - 1 ] \\n```\n```\\n\\n# compute minimum cost from subproblem\\n\\ndp[ d ] = min( dp[     d - 1      ] + cost[0],\\n               dp[ max(d - 7, 0)  ] + cost[1],\\n\\t\\t\\t   dp[ max(d - 30, 0) ] + cost[2] )\\n\\n# cost[0]: the cost of 1-day-pass ticket\\n# cost[1]: the cost of 7-day-pass ticket\\n# cost[2]: the cost of 30-day-pass ticket\\n```\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        # index of ticket\\n        _1day_pass, _7day_pass, _30day_pass = 0, 1, 2\\n        \\n        # set of travel days\\n        travel_days = set(days)\\n        \\n        # last travel day\\n        last_traverl_day = days[-1]\\n        \\n        # DP Table, record for minimum cost of ticket to travel\\n        dp_cost = [  0 for _ in range(last_traverl_day+1)]\\n    \\n        \\n        # Solve min cost by Dynamic Programming\\n        for day_i in range(1, last_traverl_day+1):\\n            \\n            \\n            if day_i not in travel_days:\\n                \\n                # today is not traveling day\\n                # no extra cost\\n                dp_cost[day_i] = dp_cost[day_i - 1]\\n            \\n            \\n            else:\\n                \\n                # today is traveling day\\n                # compute optimal cost by DP\\n                \\n                dp_cost[day_i] = min(   dp_cost[ day_i - 1 ]  + costs[ _1day_pass ],\\n                                        dp_cost[ max(day_i - 7, 0) ]  + costs[ _7day_pass ],\\n                                        dp_cost[ max(day_i - 30, 0) ] + costs[ _30day_pass ]     )\\n        \\n        \\n        # Cost on last travel day of this year is the answer\\n        return dp_cost[last_traverl_day]\\n        \\n```\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        # to speed up element checking for days\\n        travel_days = set(days)\\n        \\n        # ---------------------------------------------------\\n        \\n        # use python built-in cache as memoization for DP\\n        @cache\\n        def dp(day_d):\\n            \\n            ## Base case\\n            if day_d == 0:\\n                \\n                # no cost on before traveling\\n                return 0\\n            \\n            ## General cases\\n            if day_d not in travel_days:\\n                \\n                # no extra cost on non-traverl day\\n                return dp(day_d-1)\\n            \\n            else:\\n                \\n                # compute minimal cost on travel day\\n                \\n                with_1_day_pass = dp( day_d-1 ) + costs[0]\\n                with_7_day_pass = dp( max( day_d - 7, 0) ) + costs[1]\\n                with_30_day_pass = dp( max( day_d - 30, 0) ) + costs[2]\\n                \\n                return min( with_1_day_pass, with_7_day_pass, with_30_day_pass)\\n            \\n        # ---------------------------------------------------\\n        last_travel_day = days[-1]\\n        \\n        return dp(last_travel_day)\\n```\n```\\nvar mincostTickets = function(days, costs) {\\n    \\n    // index of ticket\\n    const [ _1day, _7day, _30day] = [0, 1, 2];\\n    \\n    // set of travel days\\n    let travelDays = new Set(days);\\n    \\n    let lastTravelDay = days[days.length-1];\\n    \\n    // DP table, record for minimum cost of ticket to travel\\n    dpCost = new Array( lastTravelDay+1 ).fill(0);\\n    \\n    // solve min cost by DP\\n    for( let day_i=1; day_i <= lastTravelDay ; day_i++ ){\\n        \\n        if( travelDays.has(day_i) == false ){\\n            \\n            // today is not traveling day\\n            // no extra cost\\n            dpCost[ day_i ] = dpCost[ day_i - 1 ];\\n            \\n        }else{\\n            \\n            // today is traveling day\\n            // compute optimal min cost\\n            dpCost[ day_i ] = Math.min( dpCost[ day_i - 1 ] + costs[ _1day ],\\n                                        dpCost[ Math.max(day_i - 7, 0) ] + costs[ _7day ], \\n                                        dpCost[ Math.max(day_i - 30, 0) ] + costs[_30day]  );\\n        }\\n    }\\n\\n    return dpCost[lastTravelDay];\\n    \\n};\\n```\n```\\n// Golang doesn\\'t have natural built in min/max function for integers\\n// Programmer have to implement it manually\\nfunc MinOf(vars ...int) int {\\n    min := vars[0]\\n\\n    for _, i := range vars {\\n        if min > i {\\n            min = i\\n        }\\n    }\\n\\n    return min\\n}\\n\\n\\nfunc Max( x, y int) int {\\n    \\n    if x > y{\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n\\ntype void struct{}\\nvar member void\\n\\nfunc mincostTickets(days []int, costs []int) int {\\n    \\n    // help reader to understand code, to avoid magic number\\n    const _1day, _7day, _30day = 0, 1, 2\\n    \\n    // set of travel days\\n    travelDays := make( map[int]void )\\n    \\n    for _, curTravelDay := range days{\\n        travelDays[ curTravelDay ] = member\\n    }\\n    \\n    // last travel day from input array\\n    lastTraverlDay := days[ len(days) - 1 ]\\n    \\n    // dp table\\n    dpCost := make([]int, lastTraverlDay+1)\\n    \\n    for day_i := 1 ; day_i <= lastTraverlDay ; day_i++ {\\n        \\n        if _, isTravelDay := travelDays[day_i] ; isTravelDay == false{\\n            \\n            // today is not traveling day\\n            // no extra cost\\n            dpCost[ day_i ] = dpCost[ day_i -1 ]\\n        \\n        }else{\\n            \\n                // today is traveling day\\n                // compute optimal cost by DP\\n                \\n                dpCost[day_i] = MinOf( dpCost[ day_i - 1 ]  + costs[ _1day ],\\n                                        dpCost[ Max(day_i - 7, 0) ]  + costs[ _7day ],\\n                                        dpCost[ Max(day_i - 30, 0) ] + costs[ _30day ]     )\\n        }\\n    }\\n    \\n    return dpCost[ lastTraverlDay ]\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        // index of ticket\\n        enum Ticket { _1day, _7day, _30day };\\n        \\n        \\n        // set of travel days\\n        set<int> travelDays = set<int>(days.begin(), days.end());\\n        \\n        int lastTravelDay = days.back();\\n        \\n        // dp table, record for minimum cost ofticket to travel\\n        vector<int> dpCost = vector<int>( lastTravelDay+1 );\\n        \\n        // Solve min cost by DP\\n        for( int day_i = 1; day_i <= lastTravelDay ; day_i++ ){\\n            \\n            if( travelDays.count(day_i) == 0 ){\\n                \\n                // today is not traveling day\\n                // no extra cost\\n                dpCost[ day_i ] = dpCost[ day_i - 1 ];\\n                \\n            }else{\\n                \\n                // today is traveling day\\n                // compute optimal cost by DP\\n                dpCost[ day_i ] = min( {dpCost[ day_i - 1 ]            + costs[ _1day ], \\n                                        dpCost[ max(day_i - 7, 0) ]    + costs[ _7day ], \\n                                        dpCost[ max(day_i - 30, 0) ]   + costs[ _30day]} );\\n            }\\n        }\\n\\n        return dpCost[lastTravelDay];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349729,
                "title": "java-python-and-c-easy-solutions-with-exaplanation-look-at-once",
                "content": "# Intuition\\nThe given code implements a dynamic programming approach to solve the minimum cost ticket problem. It initializes an array `dp` of size `n+1`, where `n` is the length of the `days` array. The `dp` array stores the minimum cost required to travel up to the i-th day in the `days` array. It is initialized to `Integer.MAX_VALUE`, except for `dp[0]` which is initialized to `0`\\n\\n# Approach\\nFor each day `i`, three possibilities are considered:\\n- If a 1-day pass is bought on that day, then the cost will be `dp[i-1] + costs[0]`.\\n- If a 7-day pass is bought on that day, then we look for the first day before the i-th day, such that the difference between the two days is less than 7. Let that day be j. Then, the cost will be `dp[j+1] + costs[1]`. We add `1` to `j` because we need to consider the cost of the 7-day pass for the current day, which is `costs[1]`.\\n- If a 30-day pass is bought on that day, then we look for the first day before the i-th day, such that the difference between the two days is less than 30. Let that day be j. Then, the\\ncost will be `dp[j+1] + costs[2]`\\n\\nWe take the minimum of these three possibilities and store it in `dp[i]`. Finally, we return\\n`dp[n]`, which stores the minimum cost required to travel up to the last day in the `days` array.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the length of the `days` array.\\n\\n- Space complexity: $$O(n)$$ because we are using an additional array of size `n+1`.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + costs[0]; // 1-day pass for current day\\n            \\n            int j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 7) j--;\\n            dp[i] = Math.min(dp[i], dp[j + 1] + costs[1]); // 7-day pass for current day\\n            \\n            j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 30) j--;\\n            dp[i] = Math.min(dp[i], dp[j + 1] + costs[2]); // 30-day pass for current day\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + costs[0]; // 1-day pass for current day\\n            \\n            int j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 7) {\\n                j--;\\n            }\\n            dp[i] = min(dp[i], dp[j + 1] + costs[1]); // 7-day pass for current day\\n            \\n            j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 30) {\\n                j--;\\n            }\\n            dp[i] = min(dp[i], dp[j + 1] + costs[2]); // 30-day pass for current day\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n``` Python []\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(days)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n        \\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + costs[0] # 1-day pass for current day\\n            \\n            j = i - 1\\n            while j >= 0 and days[i - 1] - days[j] < 7:\\n                j -= 1\\n            dp[i] = min(dp[i], dp[j + 1] + costs[1]) # 7-day pass for current day\\n            \\n            j = i - 1\\n            while j >= 0 and days[i - 1] - days[j] < 30:\\n                j -= 1\\n            dp[i] = min(dp[i], dp[j + 1] + costs[2]) # 30-day pass for current day\\n        \\n        return dp[n]\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + costs[0]; // 1-day pass for current day\\n            \\n            int j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 7) j--;\\n            dp[i] = Math.min(dp[i], dp[j + 1] + costs[1]); // 7-day pass for current day\\n            \\n            j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 30) j--;\\n            dp[i] = Math.min(dp[i], dp[j + 1] + costs[2]); // 30-day pass for current day\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + costs[0]; // 1-day pass for current day\\n            \\n            int j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 7) {\\n                j--;\\n            }\\n            dp[i] = min(dp[i], dp[j + 1] + costs[1]); // 7-day pass for current day\\n            \\n            j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 30) {\\n                j--;\\n            }\\n            dp[i] = min(dp[i], dp[j + 1] + costs[2]); // 30-day pass for current day\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n``` Python []\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(days)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n        \\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + costs[0] # 1-day pass for current day\\n            \\n            j = i - 1\\n            while j >= 0 and days[i - 1] - days[j] < 7:\\n                j -= 1\\n            dp[i] = min(dp[i], dp[j + 1] + costs[1]) # 7-day pass for current day\\n            \\n            j = i - 1\\n            while j >= 0 and days[i - 1] - days[j] < 30:\\n                j -= 1\\n            dp[i] = min(dp[i], dp[j + 1] + costs[2]) # 30-day pass for current day\\n        \\n        return dp[n]\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349786,
                "title": "image-explanation-recursion-dp-dp-optimized-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`)\\n`Minimum Cost For Tickets` by `Aryan Mittal`\\n![Google4.png](https://assets.leetcode.com/users/images/c638499b-2494-47fd-a4d3-fab6bc792f62_1679974209.109997.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/1eb522f1-e7c4-46ae-9e03-25187040052e_1679969963.3160527.png)\\n![image.png](https://assets.leetcode.com/users/images/2a9cee71-f6ed-4c1a-84f7-3e6d0abfb56a_1679969974.2573662.png)\\n![image.png](https://assets.leetcode.com/users/images/72d3bff9-8be5-42cd-b948-aacbb8c424da_1679969983.6983235.png)\\n![image.png](https://assets.leetcode.com/users/images/22f9f518-17e5-48f5-8f4b-c30ca70c0936_1679969996.8871362.png)\\n![image.png](https://assets.leetcode.com/users/images/4290a7b7-e3ba-4239-bf52-ff025b46d455_1679970007.2821136.png)\\n![image.png](https://assets.leetcode.com/users/images/6f08a03a-dbb2-4986-b7b9-ccdebe70f290_1679970013.9704604.png)\\nDP - Optimized Code\\n![image.png](https://assets.leetcode.com/users/images/1c48d256-b368-4c0c-8e76-182c08c0a975_1679970021.1624587.png)\\n\\n\\n# DP - Optimized Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs, int cost = 0) {\\n    queue<pair<int, int>> last7, last30;\\n\\n    for (auto d : days) {\\n        while (!last7.empty() && last7.front().first + 7 <= d) last7.pop();\\n        while (!last30.empty() && last30.front().first + 30 <= d) last30.pop();\\n        \\n        last7.push({ d, cost + costs[1] });\\n        last30.push({ d, cost + costs[2] });\\n        \\n        cost = min({ cost + costs[0], last7.front().second, last30.front().second });\\n    }\\n    return cost;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        Queue<int[]> last7 = new LinkedList<>();\\n        Queue<int[]> last30 = new LinkedList<>();\\n        int cost = 0;\\n\\n        for (int d : days) {\\n            while (!last7.isEmpty() && last7.peek()[0] + 7 <= d) {\\n                last7.poll();\\n            }\\n            while (!last30.isEmpty() && last30.peek()[0] + 30 <= d) {\\n                last30.poll();\\n            }\\n            last7.offer(new int[]{d, cost + costs[1]});\\n            last30.offer(new int[]{d, cost + costs[2]});\\n            cost = Math.min(cost + costs[0], Math.min(last7.peek()[1], last30.peek()[1]));\\n        }\\n\\n        return cost;\\n    }\\n}\\n```\\n```Python []\\nfrom queue import Queue\\n\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last7 = Queue()\\n        last30 = Queue()\\n        cost = 0\\n\\n        for d in days:\\n            while not last7.empty() and last7.queue[0][0] + 7 <= d:\\n                last7.get()\\n            while not last30.empty() and last30.queue[0][0] + 30 <= d:\\n                last30.get()\\n            last7.put((d, cost + costs[1]))\\n            last30.put((d, cost + costs[2]))\\n            cost = min(cost + costs[0], last7.queue[0][1], last30.queue[0][1])\\n\\n        return cost\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs, int cost = 0) {\\n    queue<pair<int, int>> last7, last30;\\n\\n    for (auto d : days) {\\n        while (!last7.empty() && last7.front().first + 7 <= d) last7.pop();\\n        while (!last30.empty() && last30.front().first + 30 <= d) last30.pop();\\n        \\n        last7.push({ d, cost + costs[1] });\\n        last30.push({ d, cost + costs[2] });\\n        \\n        cost = min({ cost + costs[0], last7.front().second, last30.front().second });\\n    }\\n    return cost;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        Queue<int[]> last7 = new LinkedList<>();\\n        Queue<int[]> last30 = new LinkedList<>();\\n        int cost = 0;\\n\\n        for (int d : days) {\\n            while (!last7.isEmpty() && last7.peek()[0] + 7 <= d) {\\n                last7.poll();\\n            }\\n            while (!last30.isEmpty() && last30.peek()[0] + 30 <= d) {\\n                last30.poll();\\n            }\\n            last7.offer(new int[]{d, cost + costs[1]});\\n            last30.offer(new int[]{d, cost + costs[2]});\\n            cost = Math.min(cost + costs[0], Math.min(last7.peek()[1], last30.peek()[1]));\\n        }\\n\\n        return cost;\\n    }\\n}\\n```\n```Python []\\nfrom queue import Queue\\n\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last7 = Queue()\\n        last30 = Queue()\\n        cost = 0\\n\\n        for d in days:\\n            while not last7.empty() and last7.queue[0][0] + 7 <= d:\\n                last7.get()\\n            while not last30.empty() and last30.queue[0][0] + 30 <= d:\\n                last30.get()\\n            last7.put((d, cost + costs[1]))\\n            last30.put((d, cost + costs[2]))\\n            cost = min(cost + costs[0], last7.queue[0][1], last30.queue[0][1])\\n\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504403,
                "title": "dp-it-s-not-easy-as-you-thought",
                "content": "At the first glance, we think this problem can be solved by DP. It\\'s true, but the formular to come up with `bottom-up dp` is not intuitive. Once again, we have to come up with `dfs` first, then `dfs with memo`, and finally `bottom-up DP`.\\n\\n1) **dfs**\\n\\n\\tOk, at the `days[i]`, how many possibilities that we can do? \\n\\t+ pay nothing. We have bought a week-pass, or a month-pass in the past, and up-to-now, the pass is still valid.\\n\\t+ buy a day-pass to cover only this day\\n\\t+ buy a week-pass to cover next 6 consecutive days.\\n\\t+ buy a month-pass to cover next 29 consecutive days.\\n\\n```\\n\\tprivate int dfs(int[] days, int[] costs, int i, int finalValidDay) {\\n        if (i == days.length) return 0;\\n\\t\\t\\n\\t\\t// pay nothing, still a valid pass\\n        if (days[i] <= finalValidDay) return dfs(days, costs, i+1, finalValidDay);\\n\\t\\t\\n\\t\\t// buy a day-pass, or week-pass, or month-pass\\n        int buyDayPass = costs[0] + dfs(days, costs, i+1, days[i]);\\n        int buyWeekPass = costs[1] + dfs(days, costs, i+1, days[i]+6);\\n        int buyMonthPass = costs[2] + dfs(days, costs, i+1, days[i]+29);\\n\\t\\t\\n\\t\\t// choose the minimum cost\\n        return Math.min(buyDayPass, Math.min(buyWeekPass, buyMonthPass));\\n    }\\n```\\nThe interviewer is not satisfied, and will say this code is `TLE`, and you have to improve it. Now, since you see the `dfs function` depends on `i` and `finalValidDay`, so you are about to create a `int[][] memo` to represent these states? However, it doesn\\'t help. \\n\\n2) **simplify dfs**\\nWe should get rid of `finalValidDay` first. Note that we always encounter the first day we have to pay, the next days might be not necessary to calculate. For example `days=[1,2,4,6,7,8]`, if we buy a week-pass on the 1st day, then the next days `2,4,6,7` can be skipped. \\n\\n```\\n\\tprivate int dfs_simplify(int[] days, int[] costs, int i) {\\n        if (i == days.length) return 0;\\n\\n        // buy a day-pass, or week-pass, or month-pass\\n        int res = Integer.MAX_VALUE;\\n        for (int j = 0; j < costs.length; j++) {\\n            int nextIndex = nextDayIndex(days, i, j);\\n            res = Math.min(res, costs[j] + dfs_simplify(days, costs, nextIndex) );\\n        }\\n\\n        // choose the minimum cost\\n        return res;\\n    }\\n\\n    private int nextDayIndex(int[] days, int i, int j) {\\n        int next = nextDay(days, i, j);\\n        while (i < days.length && days[i] < next) i++;\\n        return i;\\n    }\\n\\n    private int nextDay(int[] days, int i, int j) {\\n        if (j == 0) return days[i]+1;\\n        if (j == 1) return days[i]+7;\\n        return days[i]+30;\\n    }\\n```\\n\\n3) **dfs with memo**\\n\\n```\\n\\tprivate int dfs_simplify_memo(int[] days, int[] costs, int i, int[] memo) {\\n        if (i == days.length) return 0;\\n        if (memo[i] != 0) return memo[i];\\n\\n        // buy a day-pass, or week-pass, or month-pass\\n        memo[i] = Integer.MAX_VALUE;\\n        for (int j = 0; j < costs.length; j++) {\\n            int nextIndex = nextDayIndex(days, i, j);\\n            memo[i] = Math.min(memo[i], costs[j] + dfs_simplify_memo(days, costs, nextIndex, memo) );\\n        }\\n\\n        // choose the minimum cost\\n        return memo[i];\\n    }\\n```\\n\\n4) **bottom-up dp**\\n\\n\\t`dp[n]` is the minimum cost to cover all days from day `1` until day `n`. \\n\\t- If day `n` is not one of our `days`, then we don\\'t have to worry. The cost is the same as the cost to cover all days to day `n-1` => `dp[n] = dp[n-1]`\\n\\t- If day `n` is one of our `days`, then we will check if buying a pass before can help us minimize the cost.\\n\\tFor example, buying a week-pass a week ago can cost: `dp[n-7] + costs[1]`\\n\\tbuying a month-pass a month ago can cost: `dp[n-30] + cost[2]`\\n\\t\\n\\tThere is a confusion here what if `n-7` or `n-30` is not one of our `days` ?? It doesn\\'t matter at all. What we care is we prefer not buy at day `n`, but rather buy at the moment before day `n`.\\n\\t\\n\\tdays: `1,2,3,x,x(n-7),x,x,x,x,9,x,11,12(n),13`\\n\\tIn this example, `n-7` is not our days, we would rather buy a week-pass from day `9`, than buy a week-pass on day `12`. Note that `dp[3] = dp[n-7] = dp[9]`\\n\\t\\n\\t```\\n\\tprivate int dp_bottom_up(int[] days, int[] costs) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int day : days) set.add(day);\\n\\n        int lastDay = days[days.length-1], dp[] = new int[lastDay+1];\\n        for (int i = 1; i <= lastDay; i++) {\\n            if (!set.contains(i)) {\\n                dp[i] = dp[i-1];\\n            }\\n            else {\\n                dp[i] = dp[i-1]+costs[0];\\n\\n                int j = (i >= 7) ? i-7 : 0;\\n                dp[i] = Math.min(dp[i], dp[j] + costs[1]);\\n\\n                j = (i >= 30) ? i-30 : 0;\\n                dp[i] = Math.min(dp[i], dp[j] + costs[2]);\\n            }\\n        }\\n\\n        return dp[lastDay];\\n    }\\n\\t```\\n\\t\\n\\t\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\tprivate int dfs(int[] days, int[] costs, int i, int finalValidDay) {\\n        if (i == days.length) return 0;\\n\\t\\t\\n\\t\\t// pay nothing, still a valid pass\\n        if (days[i] <= finalValidDay) return dfs(days, costs, i+1, finalValidDay);\\n\\t\\t\\n\\t\\t// buy a day-pass, or week-pass, or month-pass\\n        int buyDayPass = costs[0] + dfs(days, costs, i+1, days[i]);\\n        int buyWeekPass = costs[1] + dfs(days, costs, i+1, days[i]+6);\\n        int buyMonthPass = costs[2] + dfs(days, costs, i+1, days[i]+29);\\n\\t\\t\\n\\t\\t// choose the minimum cost\\n        return Math.min(buyDayPass, Math.min(buyWeekPass, buyMonthPass));\\n    }\\n```\n```\\n\\tprivate int dfs_simplify(int[] days, int[] costs, int i) {\\n        if (i == days.length) return 0;\\n\\n        // buy a day-pass, or week-pass, or month-pass\\n        int res = Integer.MAX_VALUE;\\n        for (int j = 0; j < costs.length; j++) {\\n            int nextIndex = nextDayIndex(days, i, j);\\n            res = Math.min(res, costs[j] + dfs_simplify(days, costs, nextIndex) );\\n        }\\n\\n        // choose the minimum cost\\n        return res;\\n    }\\n\\n    private int nextDayIndex(int[] days, int i, int j) {\\n        int next = nextDay(days, i, j);\\n        while (i < days.length && days[i] < next) i++;\\n        return i;\\n    }\\n\\n    private int nextDay(int[] days, int i, int j) {\\n        if (j == 0) return days[i]+1;\\n        if (j == 1) return days[i]+7;\\n        return days[i]+30;\\n    }\\n```\n```\\n\\tprivate int dfs_simplify_memo(int[] days, int[] costs, int i, int[] memo) {\\n        if (i == days.length) return 0;\\n        if (memo[i] != 0) return memo[i];\\n\\n        // buy a day-pass, or week-pass, or month-pass\\n        memo[i] = Integer.MAX_VALUE;\\n        for (int j = 0; j < costs.length; j++) {\\n            int nextIndex = nextDayIndex(days, i, j);\\n            memo[i] = Math.min(memo[i], costs[j] + dfs_simplify_memo(days, costs, nextIndex, memo) );\\n        }\\n\\n        // choose the minimum cost\\n        return memo[i];\\n    }\\n```\n```\\n\\tprivate int dp_bottom_up(int[] days, int[] costs) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int day : days) set.add(day);\\n\\n        int lastDay = days[days.length-1], dp[] = new int[lastDay+1];\\n        for (int i = 1; i <= lastDay; i++) {\\n            if (!set.contains(i)) {\\n                dp[i] = dp[i-1];\\n            }\\n            else {\\n                dp[i] = dp[i-1]+costs[0];\\n\\n                int j = (i >= 7) ? i-7 : 0;\\n                dp[i] = Math.min(dp[i], dp[j] + costs[1]);\\n\\n                j = (i >= 30) ? i-30 : 0;\\n                dp[i] = Math.min(dp[i], dp[j] + costs[2]);\\n            }\\n        }\\n\\n        return dp[lastDay];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 886443,
                "title": "evolution-recursion-memo-on-recursion-dp-6-line-dp-detailed-explanation",
                "content": "Recursion is the core of Dynamic Programming so coming up with recursive equation for any problem can be challenging. So here\\'s a flow of a how a Recursion ends up being a 6 line solution.\\n\\n**Recursion :**\\nTo come up with the recursive equation we need to think on how many ways are there to buy a ticket.\\n\\n*Scenario :*\\n*When our guy walks into the station to get ticket, he has to make choice between picking tickets.\\nHe has a note in his hand to see what all days he is travelling.\\nSo, **like a genius,** he looks at his notebook and thinks if he bought which ticket today, he might endup paying less in the year.\\nHe thinks of buying a ticket today by looking at tomorrow\\'s tickets at his disposal. **Oh wait!** now he thinks of the day after tomorrow and continues till last day of year!*\\n\\n*Turns out, if he bought ticket everyother day in consecutive days of travell, the ticket price is cheap for a week pass than buying it for everyday of the week*\\n\\n**He thinks about future and decides what to do today!**\\n`min cost of ticket` = `what ticket he might buy today` + `minimum price for the rest of the days`\\n\\nwhich translates to,\\n```\\nminCost = min({ \\n\\t\\t\\t\\toneDayPass + exceptToday,\\n\\t\\t\\t\\toneWeekPass + expectThisWeek,\\n\\t\\t\\t\\toneMonthPass, expectThisMonth \\n\\t\\t\\t})\\n```\\n\\nWhich in code translates to,\\n```\\n// Calculate for today ie i\\n// Recursive eqaution\\nminCost = min({\\n\\t\\t\\t\\tcost[0] + calculate(i + 1),\\n\\t\\t\\t\\tcost[1] + calculate(i + 7),\\n\\t\\t\\t\\tcost[2] + calculate(i + 30)\\n})\\n```\\n\\nRecursion code,\\n```\\nclass Solution {\\npublic:\\n    int calculate(vector<int> &days, vector<int> &costs, int i, vector <bool> map) {\\n        if( i > 365)    // Reached the end of year!!\\n            return 0;\\n        if(!map[i])\\n            return calculate(days, costs, i+1, map);    // If he ain\\'t travelling, goes to next day without buying any ticket\\n        return min({\\n            costs[0] + calculate(days, costs, i+1, map),\\n            costs[1] + calculate(days, costs, i+7, map),\\n            costs[2] + calculate(days, costs, i+30, map)\\n        });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector <bool> map(366, false);    // To keep track the days he ain\\'t travelling\\n        for(auto x: days)\\n            map[x] = true;   // Only the travelling days are marked\\n        int x = calculate(days, costs, 0, map);\\n        return x;\\n    }\\n};\\n```\\n\\n*Now he figures out that, he is unneccesarily calculating for everyday repeatedly!\\nHe thinks even smart know! Every time he calucates for a day, **he jots it down on the notebook**!*\\n\\n**Recursion with memoization :**\\nAll we need to do is introduce memo variable to avoid repeated calculations\\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &days, vector<int> &costs, int i, vector <bool> map, vector <int>& memo) {\\n        if( i > 365)\\n            return 0;\\n        if(memo[i] != -1)\\n            return memo[i]; // Already calculated\\n        if(!map[i])\\n            return memo[i] = rec(days, costs, i+1, map, memo);\\n        return memo[i] = min({\\n            costs[0] + rec(days, costs, i+1, map, memo),\\n            costs[1] + rec(days, costs, i+7, map, memo),\\n            costs[2] + rec(days, costs, i+30, map, memo)\\n        });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector <bool> map(366, false);\\n        vector <int> memo(366, -1);\\n        for(auto x: days)\\n            map[x] = true;\\n        int x = rec(days, costs, 0, map, memo);\\n        return x;\\n    }\\n};\\n```\\n\\n*He figures out, because he already has the reapeated calculations jotted, he can just begin from the end and whatever price he ends up paying for today, will be the min cost for year!*\\n\\n**Iterative DP : top down**\\nCan be written as bottom up, but that would equation will change. To maintain regularity and the proof of recursion equation leading to DP I\\'m using top-down.\\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = 367;\\n        vector <bool> map(n , false);\\n        vector <int> dp(n , 0);\\n        for(auto x: days)\\n            map[x] = true;\\n        for(int i = n - 1; i >= 0; i--){\\n            dp[i] = dp[min(n - 1, i + 1)];\\n            if(map[i]){ \\n                dp[i] = min({\\n                    costs[0] + dp[min(n - 1, i + 1)],\\n                    costs[1] + dp[min(n - 1, i + 7)],\\n                    costs[2] + dp[min(n - 1, i + 30)]\\n                });\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\n\\n**6 lines DP Solution :**\\n*Let\\'s make it look like a PRO!!!*\\nBy the way, this is actually slower than the previous because set searching is expensive(computationally) over index array search\\n```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = 367;\\n        unordered_set <int> map(days.begin(), days.end());\\n        vector <int> dp(n , 0);\\n        for(int i = n - 1; i >= 0; i--)\\n            dp[i] = map.find(i) == map.end() ? dp[min(n - 1, i + 1)] : min({ costs[0] + dp[min(n - 1, i + 1)], costs[1] + dp[min(n - 1, i + 7)], costs[2] + dp[min(n - 1, i + 30)] });\\n        return dp[0];\\n    }\\n```\\n\\n**Liked it? Simple enought to understand? Hit the damn upvote button.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nminCost = min({ \\n\\t\\t\\t\\toneDayPass + exceptToday,\\n\\t\\t\\t\\toneWeekPass + expectThisWeek,\\n\\t\\t\\t\\toneMonthPass, expectThisMonth \\n\\t\\t\\t})\\n```\n```\\n// Calculate for today ie i\\n// Recursive eqaution\\nminCost = min({\\n\\t\\t\\t\\tcost[0] + calculate(i + 1),\\n\\t\\t\\t\\tcost[1] + calculate(i + 7),\\n\\t\\t\\t\\tcost[2] + calculate(i + 30)\\n})\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(vector<int> &days, vector<int> &costs, int i, vector <bool> map) {\\n        if( i > 365)    // Reached the end of year!!\\n            return 0;\\n        if(!map[i])\\n            return calculate(days, costs, i+1, map);    // If he ain\\'t travelling, goes to next day without buying any ticket\\n        return min({\\n            costs[0] + calculate(days, costs, i+1, map),\\n            costs[1] + calculate(days, costs, i+7, map),\\n            costs[2] + calculate(days, costs, i+30, map)\\n        });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector <bool> map(366, false);    // To keep track the days he ain\\'t travelling\\n        for(auto x: days)\\n            map[x] = true;   // Only the travelling days are marked\\n        int x = calculate(days, costs, 0, map);\\n        return x;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &days, vector<int> &costs, int i, vector <bool> map, vector <int>& memo) {\\n        if( i > 365)\\n            return 0;\\n        if(memo[i] != -1)\\n            return memo[i]; // Already calculated\\n        if(!map[i])\\n            return memo[i] = rec(days, costs, i+1, map, memo);\\n        return memo[i] = min({\\n            costs[0] + rec(days, costs, i+1, map, memo),\\n            costs[1] + rec(days, costs, i+7, map, memo),\\n            costs[2] + rec(days, costs, i+30, map, memo)\\n        });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector <bool> map(366, false);\\n        vector <int> memo(366, -1);\\n        for(auto x: days)\\n            map[x] = true;\\n        int x = rec(days, costs, 0, map, memo);\\n        return x;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = 367;\\n        vector <bool> map(n , false);\\n        vector <int> dp(n , 0);\\n        for(auto x: days)\\n            map[x] = true;\\n        for(int i = n - 1; i >= 0; i--){\\n            dp[i] = dp[min(n - 1, i + 1)];\\n            if(map[i]){ \\n                dp[i] = min({\\n                    costs[0] + dp[min(n - 1, i + 1)],\\n                    costs[1] + dp[min(n - 1, i + 7)],\\n                    costs[2] + dp[min(n - 1, i + 30)]\\n                });\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = 367;\\n        unordered_set <int> map(days.begin(), days.end());\\n        vector <int> dp(n , 0);\\n        for(int i = n - 1; i >= 0; i--)\\n            dp[i] = map.find(i) == map.end() ? dp[min(n - 1, i + 1)] : min({ costs[0] + dp[min(n - 1, i + 1)], costs[1] + dp[min(n - 1, i + 7)], costs[2] + dp[min(n - 1, i + 30)] });\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349776,
                "title": "python3-39-ms-beats-91-51-dp",
                "content": "The mincostTickets function takes in two arguments: days, a list of integers representing the days on which you want to travel, and costs, a list of integers representing the costs for a 1-day, 7-day, and 30-day travel pass, respectively.\\n\\nThe function initializes the cost to zero and two deques last7 and last30, which will store tuples of the form (day, cost) representing the last 7-day and 30-day passes, respectively.\\n\\nThe function then iterates over each day in the days list. For each day, it first removes any tuples from last7 and last30 that are no longer valid (i.e., the day is more than 7 or 30 days after the day in the tuple).\\n\\nNext, it adds a new tuple to each deque with the current day and the cost of a 7-day or 30-day pass plus the cost so far. This is because if you buy a 7-day or 30-day pass on the current day, you will also have to pay for the cost of the pass for the preceding days.\\n\\nFinally, the function sets the cost to the minimum of the following three values: the cost so far plus the cost of a 1-day pass, the cost of the earliest tuple in last7, and the cost of the earliest tuple in last30. This is because you can either buy a 1-day pass on the current day or use one of the 7-day or 30-day passes in the deques.\\n\\nThe function returns the final cost at the end.\\n![image.png](https://assets.leetcode.com/users/images/ed5421cc-45ff-4a2d-afa7-b666655c06cb_1679969660.415069.png)\\n\\n# Please Upvote \\uD83D\\uDE07\\n\\n## Python3\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        cost = 0\\n        last7 = deque()\\n        last30 = deque()\\n        for day in days:\\n            while last7 and last7[0][0] + 7 <= day:\\n                last7.popleft()\\n            while last30 and last30[0][0] + 30 <= day:\\n                last30.popleft()\\n            last7.append((day, cost + costs[1]))\\n            last30.append((day, cost + costs[2]))\\n            cost = min(cost + costs[0],\\n                      last7[0][1],\\n                      last30[0][1])\\n        return cost\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        cost = 0\\n        last7 = deque()\\n        last30 = deque()\\n        for day in days:\\n            while last7 and last7[0][0] + 7 <= day:\\n                last7.popleft()\\n            while last30 and last30[0][0] + 30 <= day:\\n                last30.popleft()\\n            last7.append((day, cost + costs[1]))\\n            last30.append((day, cost + costs[2]))\\n            cost = min(cost + costs[0],\\n                      last7[0][1],\\n                      last30[0][1])\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323912,
                "title": "c-dp-on-days",
                "content": "In this solution ```dp[i]``` means cost, for travelling i days. In order to minimize cost we can see whether it is better to buy 30 days ticket (which will be ```dp[i] = dp[i-30] + cost[2]```), 7 days (which will be ```dp[i] = dp[i-7] + cost[1]```) or 1 day (which is set initially in a first loop)\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int dp[366];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(auto day: days)\\n            dp[day] = costs[0];\\n        for(int i = 1; i <= days[n-1]; i++){\\n            if(!dp[i])\\n                dp[i] = dp[i-1];\\n            else{\\n                dp[i] = dp[i-1] + costs[0];\\n                int j = max(0, i-7);\\n                dp[i] = min(dp[i], dp[j] + costs[1]);\\n                j = max(0, i-30);\\n                dp[i] = min(dp[i], dp[j] + costs[2]);\\n            }\\n        }\\n        \\n        return dp[days[n-1]];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i]```\n```dp[i] = dp[i-30] + cost[2]```\n```dp[i] = dp[i-7] + cost[1]```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int dp[366];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(auto day: days)\\n            dp[day] = costs[0];\\n        for(int i = 1; i <= days[n-1]; i++){\\n            if(!dp[i])\\n                dp[i] = dp[i-1];\\n            else{\\n                dp[i] = dp[i-1] + costs[0];\\n                int j = max(0, i-7);\\n                dp[i] = min(dp[i], dp[j] + costs[1]);\\n                j = max(0, i-30);\\n                dp[i] = min(dp[i], dp[j] + costs[2]);\\n            }\\n        }\\n        \\n        return dp[days[n-1]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810791,
                "title": "python-universal-true-o-days-solution-explained",
                "content": "There are a lot of different dp solution, which have `O(days)` complexity, which is in fact `O(30*days)`, so it depeneds a lot on our numbers `[1,7,30]`. My solution is universal: you can choose any passes you want, and time complexity will not depend on them. Let me introduce my notations:\\n\\n1. `k` is number of passes and `P` is durations of these passes, in our case it is `[1,7,30]`; cost is minimal cost so far, in the beginning it is equal to `0`.\\n2. `Q` is list of `k` queues. Why we need queues? When we want to find the best cost we can have at some day `d`, we need to look back `30` days before, so why not keep all these period in queue? What we keep in this queue? We keep pairs `[day, cost]`. Also we have queue for `7` day pass and for `1` day pass.\\n\\nLet us go through example for better understanding:\\n`days = [1,4,6,7,8,20], costs = [2,7,15]`.\\n\\n\\n1. `day = 1`, `Q[0] = [[1,2]], Q[1] = [[1,7]], Q[2] = [[1, 15]]`: for the first day we put it in all three queues.\\n2. `day = 4`, `Q[0] = [[4,4]], Q[1] = [[1,7], [4,9]], Q[2] = [[1,15], [4,17]]`: we update `Q[0]`, also `Q[1]` and `Q[2]` now have two elements.\\n3. `day = 6`, `Q[0] = [[6,6]], Q[1] = [[1,7], [4, 9], [6,11]], Q[2] = [[1,15], [4,17], [6,19]]`: update `Q[0]`, add element to `Q[1]` and `Q[2]`. \\n4. `day = 7`, `Q[0] = [[7,8]], Q[1] = [[1,7], [4,9], [6,11], [7,13]], Q[2] = [[1,15], [4,17], [6,19], [7,21]]`, similar logic.\\n5. `day = 8`, `Q[0] = [[8,9]], Q[1] = [[4,9], [6,11], [7,13], [8,14]], Q[2] = [[1,15], [4,17], [6,19], [7,21], [8,22]]`: update `Q[0]`, also add element to the end of `Q[1]` and remove element from the beginning of `Q[1]`, because it is outdated.\\n6. `day = 20`, `Q[0] = [[20,11]], Q[1] = [[20,16]], Q[2] = [[1,15], [4,17], [6,19], [7,21], [8,22], [20,24]]`.\\n\\nSo, we iterate through our days and update our queues on each step. Then we choose minimum possible result.\\n\\n**Complexity**: time complexity is `O(days)`, length of `days` list, because we process each element at most `3` times: we can put and remove it to each queue only once. For general case complexity is `O(days * k)`.  Space complexity is `O(30+7+1)` in our case and `O(sum(P))` in general case.\\n\\n\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days, costs):\\n        k, P, cost = 3, [1,7,30], 0\\n        Q = [deque() for _ in range(k)]\\n\\n        for d in days:\\n            for i in range(k):\\n                while Q[i] and Q[i][0][0] + P[i] <= d: Q[i].popleft()\\n                Q[i].append([d, cost + costs[i]])\\n         \\n            cost = min([Q[i][0][1] for i in range(k)])\\n\\n        return cost\\n```\\n\\n**Remark** I think this problem is similar to problem **264. Ugly Number II**, there we also need to keep several candidates for new number and update them.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days, costs):\\n        k, P, cost = 3, [1,7,30], 0\\n        Q = [deque() for _ in range(k)]\\n\\n        for d in days:\\n            for i in range(k):\\n                while Q[i] and Q[i][0][0] + P[i] <= d: Q[i].popleft()\\n                Q[i].append([d, cost + costs[i]])\\n         \\n            cost = min([Q[i][0][1] for i in range(k)])\\n\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533146,
                "title": "java-recursion-with-memoization-time-o-n-space-o-n",
                "content": "For each day that you need to buy a ticket you will try the three options\\n1. \\tBuying a one-day ticket and then continuing with the rest of the days\\n2. \\tBuying a seven-day ticket and skipping all the days included in this ticket\\n3. \\tBuying a thirty-day ticket and skipping all the days included in this ticket\\n\\n\\n```java\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length];\\n        return minCostTickets(days, costs, 0, dp);\\n    }\\n    \\n    public static int minCostTickets(int[] days, int[] costs, int day, int[] dp){\\n        if(day >= days.length) return 0;\\n        //return previously calculated day\\n        if(dp[day] != 0) return dp[day];\\n         int i;\\n        \\n        //Attempt to buy a one-day ticket\\n        int buyOneDay =  minCostTickets(days, costs, day + 1, dp) + costs[0];\\n\\n        //Attempt to buy a seven-day ticket and skip all days that will be included in this ticket\\n        for(i = day; i < days.length; i++)\\n            if(days[i] >= days[day] + 7) break;\\n        int buySevenDays = minCostTickets(days, costs, i, dp) + costs[1];\\n        \\n        //Attempt to buy a thirty-day ticket and skip all days that will be included in this ticket\\n        for(i = day; i < days.length; i++)\\n            if(days[i] >= days[day] + 30) break;\\n        int buyThirtyDays = minCostTickets(days, costs, i, dp) + costs[2];\\n        \\n        //return minimum of three options\\n        int result = Math.min(Math.min(buyOneDay, buySevenDays), buyThirtyDays);\\n        dp[day] = result;\\n        return result;\\n        \\n    }\\n```\\n\\nThe time complexity in this case will be O(n) as each day is computed at most once and saved in dp array to be used for later calls\\nThe space complexity will be O(n) for the dp array.\\nThe recursion stack will also never surpass O(n) calls (in the case of trying to buy all one-day tickets)\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```java\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length];\\n        return minCostTickets(days, costs, 0, dp);\\n    }\\n    \\n    public static int minCostTickets(int[] days, int[] costs, int day, int[] dp){\\n        if(day >= days.length) return 0;\\n        //return previously calculated day\\n        if(dp[day] != 0) return dp[day];\\n         int i;\\n        \\n        //Attempt to buy a one-day ticket\\n        int buyOneDay =  minCostTickets(days, costs, day + 1, dp) + costs[0];\\n\\n        //Attempt to buy a seven-day ticket and skip all days that will be included in this ticket\\n        for(i = day; i < days.length; i++)\\n            if(days[i] >= days[day] + 7) break;\\n        int buySevenDays = minCostTickets(days, costs, i, dp) + costs[1];\\n        \\n        //Attempt to buy a thirty-day ticket and skip all days that will be included in this ticket\\n        for(i = day; i < days.length; i++)\\n            if(days[i] >= days[day] + 30) break;\\n        int buyThirtyDays = minCostTickets(days, costs, i, dp) + costs[2];\\n        \\n        //return minimum of three options\\n        int result = Math.min(Math.min(buyOneDay, buySevenDays), buyThirtyDays);\\n        dp[day] = result;\\n        return result;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518772,
                "title": "javascript-solution-with-comments",
                "content": "Only doing days.length + 1 apporach. Beats 85% in speed 100% memory.\\n\\n```\\nvar mincostTickets = function(days, cost) {\\n// Initilize dp array to be the size of the last day plus 1\\n  let dp = new Array(days[days.length - 1] + 1);\\n  // Base case\\n  dp[0] = 0;\\n  // Loop through all the days\\n  for (let i = 1; i < dp.length; i++) {\\n  // If \\'i\\' isn\\'t in the days array we let it equal to the previous day because we don\\'t need to buy a ticket for that day\\n    if (!days.includes(i)) {\\n      dp[i] = dp[i - 1];\\n\\t  // if dp[i] is in the days array we find the min value between our 3 cost possibilities\\n    } else {\\n      dp[i] = Math.min(\\n        dp[Math.max(0, i - 1)] + cost[0],\\n        dp[Math.max(0, i - 7)] + cost[1],\\n        dp[Math.max(0, i - 30)] + cost[2]\\n      );\\n    }\\n  }\\n  // last element of dp will be our answer\\n  return dp[dp.length - 1];\\n};\\n\\n```\\nInput: days = [1,4,6,7,8,20]\\n\\t\\tcost = [2,7,15]\\nExample for a DP array : [ 0, 2, 2, 2, 4, 4, 6, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11 ]\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar mincostTickets = function(days, cost) {\\n// Initilize dp array to be the size of the last day plus 1\\n  let dp = new Array(days[days.length - 1] + 1);\\n  // Base case\\n  dp[0] = 0;\\n  // Loop through all the days\\n  for (let i = 1; i < dp.length; i++) {\\n  // If \\'i\\' isn\\'t in the days array we let it equal to the previous day because we don\\'t need to buy a ticket for that day\\n    if (!days.includes(i)) {\\n      dp[i] = dp[i - 1];\\n\\t  // if dp[i] is in the days array we find the min value between our 3 cost possibilities\\n    } else {\\n      dp[i] = Math.min(\\n        dp[Math.max(0, i - 1)] + cost[0],\\n        dp[Math.max(0, i - 7)] + cost[1],\\n        dp[Math.max(0, i - 30)] + cost[2]\\n      );\\n    }\\n  }\\n  // last element of dp will be our answer\\n  return dp[dp.length - 1];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462201,
                "title": "diego-s-understandable-explanations-c",
                "content": "Hi, I\\'m trying to make easily understandable explanations for everyone. Hopefully I did a good job here.\\n*Please upvote if this post helped you, so that others can find it.*\\n\\n**The insight**\\nThe problem insight comes from recognizing that it is a good idea to remember the total cost of covering your journey up to a particular day. Let\\'s look at an example with some ticket costs.\\n\\n```\\n# cover travel up to        cost\\n# ------------------        ----\\n# day 7                     $10\\n# day 13                    $15\\n```\\n\\nLet\\'s say you can only buy two tickets: 1-day for $2, and 7-day for $5.\\n\\nIf you had to cover travel up to **day 14**, you must choose one of the two tickets to cover this new day. Given the above ticket prices, this means that you would compare two numbers: the price of a 1-day ticket plus the cost of covering travel for all days up to 1 day before **day 14**, or the price of a 7-day ticket plus the cost of covering travel for all days up to 7 days before **day 14**. *Here, we see that the 7-day ticket is the better choice since we would pay $15 ($10 prior + $5 ticket) instead of $17 ($15 prior + $2 ticket).*\\n\\nWe reference the cost of covering all travel days before the length of the ticket we\\'re thinking about purchasing because, if we were to buy the ticket, the ticket would cover that length of time.\\n\\n**Wrapping up**\\nNow that you know what numbers to compare when making the decision to purchase a ticket, you simply perform this comparison for each day that you need to travel!\\n\\nThis implies that for days where you don\\'t travel, you simply forward-propagate the total travel cost of the previous day. This way you will have a total travel cost when you reference that date.\\n\\nAs a final note, you might reference days that are outside of the one-year window. This is totally fine, since you need to compare all ticket prices available to you. To handle this, you simply allow the total cost to be zero for days before the one-year window.\\n\\n**A solution**\\nThis solution can be optimized in some ways for improved performance, but I leave that exercise to the reader.\\n\\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> dp(366, INT_MAX);\\n    dp[0] = 0; // You haven\\'t traveled yet, so you haven\\'t spent anything!\\n    size_t j = 0;\\n    for (size_t i = 1; i < dp.size(); i++) {\\n\\t\\t// Is this one of my travel days?\\n        if (j >= days.size() || i != days[j]) { dp[i] = dp[i - 1]; continue; }\\n\\t\\t// Yes! Perform comparisons.\\n        dp[i] = min(dp[i], (i >= 1 ? dp[i - 1] : 0) + costs[0]);\\n        dp[i] = min(dp[i], (i >= 7 ? dp[i - 7] : 0) + costs[1]);\\n        dp[i] = min(dp[i], (i >= 30 ? dp[i - 30] : 0) + costs[2]);\\n        j++; // Don\\'t forget to move on to the next travel day!\\n    }\\n\\n    return dp.back(); // This is the total cost of travel for the year, day 365!\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n# cover travel up to        cost\\n# ------------------        ----\\n# day 7                     $10\\n# day 13                    $15\\n```\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> dp(366, INT_MAX);\\n    dp[0] = 0; // You haven\\'t traveled yet, so you haven\\'t spent anything!\\n    size_t j = 0;\\n    for (size_t i = 1; i < dp.size(); i++) {\\n\\t\\t// Is this one of my travel days?\\n        if (j >= days.size() || i != days[j]) { dp[i] = dp[i - 1]; continue; }\\n\\t\\t// Yes! Perform comparisons.\\n        dp[i] = min(dp[i], (i >= 1 ? dp[i - 1] : 0) + costs[0]);\\n        dp[i] = min(dp[i], (i >= 7 ? dp[i - 7] : 0) + costs[1]);\\n        dp[i] = min(dp[i], (i >= 30 ? dp[i - 30] : 0) + costs[2]);\\n        j++; // Don\\'t forget to move on to the next travel day!\\n    }\\n\\n    return dp.back(); // This is the total cost of travel for the year, day 365!\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227106,
                "title": "c-concise-4-line-0ms",
                "content": "```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        map<int, int> dp = {{-30,0}};\\n        auto cost = [&](int day){return prev(dp.upper_bound(day))->second;};\\n        for(int d:days) dp[d] = min({costs[0] + cost(d-1), costs[1] + cost(d-7), costs[2] + cost(d-30)});\\n\\t\\t// if you want O(N) solution, simply add one line in loop:  if(dp.size() > 31) dp.erase(dp.begin());   \\n        return dp[days.back()];\\n    }",
                "solutionTags": [],
                "code": "```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        map<int, int> dp = {{-30,0}};\\n        auto cost = [&](int day){return prev(dp.upper_bound(day))->second;};\\n        for(int d:days) dp[d] = min({costs[0] + cost(d-1), costs[1] + cost(d-7), costs[2] + cost(d-30)});\\n\\t\\t// if you want O(N) solution, simply add one line in loop:  if(dp.size() > 31) dp.erase(dp.begin());   \\n        return dp[days.back()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3349857,
                "title": "c-easy-solution-dp-approach-100-faster",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFDP Approach || 100% faster**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    int  helper(int idx,vector<int>&days,vector<int>&costs,vector<int>&dp){\\n        if(idx>=days.size()){\\n            return 0;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int pass1=upper_bound(days.begin(),days.end(),days[idx]+1-1)-days.begin();\\n        int c1=helper(pass1,days,costs,dp)+costs[0];\\n        int pass7=upper_bound(days.begin(),days.end(),days[idx]+7-1)-days.begin();\\n        int c7=helper(pass7,days,costs,dp)+costs[1];\\n        int pass3=upper_bound(days.begin(),days.end(),days[idx]+30-1)-days.begin();\\n        int c3=helper(pass3,days,costs,dp)+costs[2];\\n        \\n        return dp[idx]=min(min(c1,c7),c3);\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int>dp(days.size()+1,-1);\\n        return helper(0,days,costs,dp);\\n      \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/9143cf97-b9ee-446f-a38f-cea43c0216b0_1679971399.3428004.png)\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  helper(int idx,vector<int>&days,vector<int>&costs,vector<int>&dp){\\n        if(idx>=days.size()){\\n            return 0;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int pass1=upper_bound(days.begin(),days.end(),days[idx]+1-1)-days.begin();\\n        int c1=helper(pass1,days,costs,dp)+costs[0];\\n        int pass7=upper_bound(days.begin(),days.end(),days[idx]+7-1)-days.begin();\\n        int c7=helper(pass7,days,costs,dp)+costs[1];\\n        int pass3=upper_bound(days.begin(),days.end(),days[idx]+30-1)-days.begin();\\n        int c3=helper(pass3,days,costs,dp)+costs[2];\\n        \\n        return dp[idx]=min(min(c1,c7),c3);\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int>dp(days.size()+1,-1);\\n        return helper(0,days,costs,dp);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810728,
                "title": "c-3-approaches",
                "content": "We can solve this problem using dynamic programming. If we define:\\n\\n* `dp[i] = minimum cost for tickets on day i`\\n\\nThen, at each step, we have 3 options:\\n\\n* `dp[i] = dp[i -  1] + costs[0]\\t// for 1-day pass`\\n* `dp[i] = dp[i -  7] + costs[1]\\t// for 7-day pass`\\n* `dp[i] = dp[i - 30] + costs[2]\\t// for 30-day pass`\\n\\nApproaches 2 & 3 use this definition.\\n\\nWe can also define our `dp` table a bit differently:\\n\\n* `dp[i] = minimum cost for tickets on day days[i]`\\n\\nNote the subtle difference, it\\'s not on day `i` but rather on day `days[i]`. Now we have a problem, how do we find a value `x` in `days` where:\\n\\n* `x >= days[i] - 1`\\n* `x >= days[i] - 7`\\n* `x >= days[i] - 30`\\n\\nFor this we can use binary search shown in Approach 1.\\n\\n### **Approach 1: DP + Binary Search**\\n\\nWe find the previous day greater than or equal to `x` using binary search. Usually, we would use `std::lower_bound` for this but in this case our `dp` table is one-indexed instead of zero-indexed. So we use `std::upper_bound` instead.\\n\\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.size();\\n\\tvector<int> dp(n + 1);\\n\\tfor (int j, i = 1; i <= n; i++) {\\n\\t\\tdp[i] = dp[i - 1] + costs[0];\\n\\t\\tj = distance(days.begin(), upper_bound(days.begin(), days.begin() + i, days[i - 1] - 7));\\n\\t\\tdp[i] = min(dp[j] + costs[1], dp[i]);\\n\\t\\tj = distance(days.begin(), upper_bound(days.begin(), days.begin() + i, days[i - 1] - 30));\\n\\t\\tdp[i] = min(dp[j] + costs[2], dp[i]);\\n\\t}\\n\\treturn dp[n];\\n}\\n```\\n\\n### **Complexity**\\n* Time: `O(n \\u2022 log n)`\\n* Space: `O(n)`\\n\\nwhere `n` is the number of days.\\n\\n### **Approach 2: DP + HashSet**\\n\\nWe can only buy a ticket on a day we fly, _not_ on other days. So we need a quick way to check if given a day `x`, whether it exists in `days`. For this we can use a HashSet or `std::unordered_set`.\\n\\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.back();\\n\\tvector<int> dp(n + 1);\\n\\tunordered_set<int> seen(days.begin(), days.end());\\n\\t\\n\\t// dynamic programming\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (!seen.count(i))\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\telse\\n\\t\\t\\tdp[i] = min({dp[i - 1         ] + costs[0],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i -  7)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i - 30)] + costs[2]});\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\\n\\n### **Complexity**\\n* Time: `O(n)`\\n* Space: `O(n)`\\n\\nwhere `n` is the last day.\\n\\n### **Approach 3: DP**\\n\\nInstead of using a HashSet to check if a given day `x` exists in `days`, we can initialize it to some cost which we know we can never have, this cost can be anything `<= 0`, I chose cost zero to keep things simple.\\n\\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.back();\\n\\tvector<int> dp(n + 1);\\n\\t\\n\\t// initialization\\n\\tfor (int& day: days)\\n\\t\\tdp[day] = numeric_limits<int>::max();\\n\\t\\n\\t// dynamic programming\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (dp[i] == 0)\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\telse\\n\\t\\t\\tdp[i] = min({dp[i - 1         ] + costs[0],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i -  7)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i - 30)] + costs[2]});\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\\n\\n### **Complexity**\\n* Time: `O(n)`\\n* Space: `O(n)`\\n\\nwhere `n` is the last day.\\n\\n**Question:** What approach did you like the most?\\n\\nI\\'d say I like Approach 3 as it is very clean and fast too. However, if the number of days are much smaller, then Approach 1 would win.\\n\\nFind solutions to [this](https://github.com/Mohammed-Shoaib/Coding-Problems/blob/master/LeetCode/Solutions/LC0983.cpp?ts=4) and many other problems on my GitHub!\\n* [Coding-Problems](https://github.com/Mohammed-Shoaib/Coding-Problems/tree/master/LeetCode)\\n\\nI hope this helps :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.size();\\n\\tvector<int> dp(n + 1);\\n\\tfor (int j, i = 1; i <= n; i++) {\\n\\t\\tdp[i] = dp[i - 1] + costs[0];\\n\\t\\tj = distance(days.begin(), upper_bound(days.begin(), days.begin() + i, days[i - 1] - 7));\\n\\t\\tdp[i] = min(dp[j] + costs[1], dp[i]);\\n\\t\\tj = distance(days.begin(), upper_bound(days.begin(), days.begin() + i, days[i - 1] - 30));\\n\\t\\tdp[i] = min(dp[j] + costs[2], dp[i]);\\n\\t}\\n\\treturn dp[n];\\n}\\n```\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.back();\\n\\tvector<int> dp(n + 1);\\n\\tunordered_set<int> seen(days.begin(), days.end());\\n\\t\\n\\t// dynamic programming\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (!seen.count(i))\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\telse\\n\\t\\t\\tdp[i] = min({dp[i - 1         ] + costs[0],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i -  7)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i - 30)] + costs[2]});\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.back();\\n\\tvector<int> dp(n + 1);\\n\\t\\n\\t// initialization\\n\\tfor (int& day: days)\\n\\t\\tdp[day] = numeric_limits<int>::max();\\n\\t\\n\\t// dynamic programming\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (dp[i] == 0)\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\telse\\n\\t\\t\\tdp[i] = min({dp[i - 1         ] + costs[0],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i -  7)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i - 30)] + costs[2]});\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 583652,
                "title": "java-bottom-up-dp-solution",
                "content": "```\\nclass Solution \\n{\\n    public int mincostTickets(int[] days, int[] costs) \\n    {\\n        int[] dp = new int[366];\\n        dp[0] = 0; //no days to travel, no need to spend anything..!!!\\n            \\n        int j=0; //to iterate days array\\n        for(int i=1;i<=365;i++)\\n        {\\n            if(j==days.length)\\n                break; //when we are done with our travel days we break.\\n            \\n            if(days[j] != i) // if the day is not a travel day, just put the previous day cost.\\n                dp[i] = dp[i-1];\\n            \\n            else\\n            {\\n                int one = costs[0] + dp[i-1];\\n                int seven = costs[1] + dp[Math.max(0, i-7)];\\n                int thirty = costs[2] + dp[Math.max(0, i-30)];\\n                \\n                dp[i] = Math.min(one, Math.min(seven, thirty));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp));\\n        return dp[days[days.length-1]];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int mincostTickets(int[] days, int[] costs) \\n    {\\n        int[] dp = new int[366];\\n        dp[0] = 0; //no days to travel, no need to spend anything..!!!\\n            \\n        int j=0; //to iterate days array\\n        for(int i=1;i<=365;i++)\\n        {\\n            if(j==days.length)\\n                break; //when we are done with our travel days we break.\\n            \\n            if(days[j] != i) // if the day is not a travel day, just put the previous day cost.\\n                dp[i] = dp[i-1];\\n            \\n            else\\n            {\\n                int one = costs[0] + dp[i-1];\\n                int seven = costs[1] + dp[Math.max(0, i-7)];\\n                int thirty = costs[2] + dp[Math.max(0, i-30)];\\n                \\n                dp[i] = Math.min(one, Math.min(seven, thirty));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp));\\n        return dp[days[days.length-1]];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349667,
                "title": "recursion-memoization-tabulation-easiest-to-understand",
                "content": "### RECURSION\\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1; //Max I can travel upto this \\'day Number\\'\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, int daysIdx)\\n    {\\n        if (daysIdx == days.size()) return 0;\\n        \\n        int minTravelCost = INT_MAX;\\n        //==============================================================================\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);\\n            \\n            int travelCost = ticketCost + solve(days, costs, ticketDurations, nextDaysIdx);\\n            minTravelCost = min(minTravelCost, travelCost);\\n        }\\n        //===================================================================================\\n        return minTravelCost;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        vector<int>ticketDurations = {1, 7, 30};\\n        int ans = solve(days, costs, ticketDurations, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n//==========================================\\n### TOP - DOWN - MEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1;\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, vector<int>&dp, int daysIdx)\\n    {\\n        if (daysIdx == days.size()) return 0;\\n        \\n        if (dp[daysIdx] !=  -1) return dp[daysIdx];\\n        int minTravelCost = INT_MAX;\\n        //============================================================================\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);\\n            \\n            int travelCost = ticketCost + solve(days, costs, ticketDurations, dp, nextDaysIdx);\\n            minTravelCost = min(minTravelCost, travelCost);\\n        }\\n        //==============================================================================\\n        return dp[daysIdx] = minTravelCost;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        vector<int>ticketDurations = {1, 7, 30};\\n        vector<int>dp(days.size(), -1);\\n        int ans = solve(days, costs, ticketDurations, dp, 0);\\n        return ans;\\n    }\\n};\\n```\\n//====================================================================================\\n### BOTTOM UP - TABULATION\\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1;\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        int n = days.size();\\n        vector<int>ticketDurations = {1, 7, 30};\\n        vector<int>dp(n);\\n        //If I start at last day I can pick the min cost ticket instead of taking ticket for \\'1\\' day duration\\n        dp[n - 1] = *min_element(costs.begin(), costs.end()); \\n        for (int currDaysIdx = n - 2; currDaysIdx >= 0; currDaysIdx--)\\n        {\\n            int minTravelCost = INT_MAX;\\n            //=================================================================\\n            for (int i = 0; i < 3; i++)\\n            {\\n                int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n                int nextDaysIdx = getNextDaysIdx(days, currDaysIdx, ticketDuration);\\n                \\n                int nextTravelCost = (nextDaysIdx >= n)? 0 : dp[nextDaysIdx];\\n                int travelCost = ticketCost + nextTravelCost;\\n                minTravelCost = min(minTravelCost, travelCost);\\n            }\\n            //======================================================================\\n            dp[currDaysIdx] = minTravelCost;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1; //Max I can travel upto this \\'day Number\\'\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, int daysIdx)\\n    {\\n        if (daysIdx == days.size()) return 0;\\n        \\n        int minTravelCost = INT_MAX;\\n        //==============================================================================\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);\\n            \\n            int travelCost = ticketCost + solve(days, costs, ticketDurations, nextDaysIdx);\\n            minTravelCost = min(minTravelCost, travelCost);\\n        }\\n        //===================================================================================\\n        return minTravelCost;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        vector<int>ticketDurations = {1, 7, 30};\\n        int ans = solve(days, costs, ticketDurations, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1;\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, vector<int>&dp, int daysIdx)\\n    {\\n        if (daysIdx == days.size()) return 0;\\n        \\n        if (dp[daysIdx] !=  -1) return dp[daysIdx];\\n        int minTravelCost = INT_MAX;\\n        //============================================================================\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);\\n            \\n            int travelCost = ticketCost + solve(days, costs, ticketDurations, dp, nextDaysIdx);\\n            minTravelCost = min(minTravelCost, travelCost);\\n        }\\n        //==============================================================================\\n        return dp[daysIdx] = minTravelCost;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        vector<int>ticketDurations = {1, 7, 30};\\n        vector<int>dp(days.size(), -1);\\n        int ans = solve(days, costs, ticketDurations, dp, 0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1;\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        int n = days.size();\\n        vector<int>ticketDurations = {1, 7, 30};\\n        vector<int>dp(n);\\n        //If I start at last day I can pick the min cost ticket instead of taking ticket for \\'1\\' day duration\\n        dp[n - 1] = *min_element(costs.begin(), costs.end()); \\n        for (int currDaysIdx = n - 2; currDaysIdx >= 0; currDaysIdx--)\\n        {\\n            int minTravelCost = INT_MAX;\\n            //=================================================================\\n            for (int i = 0; i < 3; i++)\\n            {\\n                int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n                int nextDaysIdx = getNextDaysIdx(days, currDaysIdx, ticketDuration);\\n                \\n                int nextTravelCost = (nextDaysIdx >= n)? 0 : dp[nextDaysIdx];\\n                int travelCost = ticketCost + nextTravelCost;\\n                minTravelCost = min(minTravelCost, travelCost);\\n            }\\n            //======================================================================\\n            dp[currDaysIdx] = minTravelCost;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842592,
                "title": "c-easy-to-understand-brute-to-efficient-clean-concise-faster",
                "content": "**Idea**\\n1.  We have three choices: Either we can choose first Pass, second Pass or Last Pass\\n2.  If any day is within validity of earlier choosen pass then we can travel without any cost.\\n3.  Base Condition: If we complete our travel, we don\\'t need to pay any cost \\n\\n**Brute Force [Recursion]**\\n```\\nclass Solution {\\n    int solve(vector<int>& days, vector<int>& costs, int i, int validity) {\\n        if(i >= days.size())\\n            return 0;\\n        \\n        if(days[i] <= validity)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return solve(days, costs, i+1, validity);\\n        else {\\n            int ch1 = costs[0] + solve(days, costs, i+1, days[i]);\\n            int ch2 = costs[1] + solve(days, costs, i+1, days[i]+6);\\n            int ch3 = costs[2] + solve(days, costs, i+1, days[i]+29);\\n            return min(ch1, min(ch2, ch3));\\n        }\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return solve(days, costs, 0, 0);\\n    }\\n};\\n```\\n\\n**Efficient Solution [Recursion + Memoization]**\\n```\\nclass Solution {\\n    int solve(vector<int>& days, vector<int>& costs, int i, int validity, vector<vector<int>> &dp) {\\n        if(i >= days.size())\\n            return 0;\\n        if(dp[i][validity] != -1)\\n            return dp[i][validity];\\n        if(days[i] <= validity)\\n            return dp[i][validity] = solve(days, costs, i+1, validity, dp);\\n        else {\\n            int ch1 = costs[0] + solve(days, costs, i+1, days[i], dp);\\n            int ch2 = costs[1] + solve(days, costs, i+1, days[i]+6, dp);\\n            int ch3 = costs[2] + solve(days, costs, i+1, days[i]+29, dp);\\n            return dp[i][validity] = min(ch1, min(ch2, ch3));\\n        }\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int max_validity = days[n-1] + 30;\\n        vector<vector<int>> dp(n, vector<int>(max_validity, -1));\\n        return solve(days, costs, 0, 0, dp);\\n    }\\n};\\n```\\n\\n**If liked my approach and solution, do upvote!**\\n**If you have any doubt comment**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int>& days, vector<int>& costs, int i, int validity) {\\n        if(i >= days.size())\\n            return 0;\\n        \\n        if(days[i] <= validity)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return solve(days, costs, i+1, validity);\\n        else {\\n            int ch1 = costs[0] + solve(days, costs, i+1, days[i]);\\n            int ch2 = costs[1] + solve(days, costs, i+1, days[i]+6);\\n            int ch3 = costs[2] + solve(days, costs, i+1, days[i]+29);\\n            return min(ch1, min(ch2, ch3));\\n        }\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return solve(days, costs, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int solve(vector<int>& days, vector<int>& costs, int i, int validity, vector<vector<int>> &dp) {\\n        if(i >= days.size())\\n            return 0;\\n        if(dp[i][validity] != -1)\\n            return dp[i][validity];\\n        if(days[i] <= validity)\\n            return dp[i][validity] = solve(days, costs, i+1, validity, dp);\\n        else {\\n            int ch1 = costs[0] + solve(days, costs, i+1, days[i], dp);\\n            int ch2 = costs[1] + solve(days, costs, i+1, days[i]+6, dp);\\n            int ch3 = costs[2] + solve(days, costs, i+1, days[i]+29, dp);\\n            return dp[i][validity] = min(ch1, min(ch2, ch3));\\n        }\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int max_validity = days[n-1] + 30;\\n        vector<vector<int>> dp(n, vector<int>(max_validity, -1));\\n        return solve(days, costs, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349849,
                "title": "easy-solution-with-explanation-in-java-dp",
                "content": "# Intuition\\nSince we will have to use previous calculation to reach the end result we will be using Dyanmic programing to solve this. The thogugh for DP is to always think about what would happen for ith day.\\n\\ndp[i] will represent the min cost till that day.\\n\\nSo on ith day one of the following would occur\\n- We buy a one day ticket i.e one day before cost + 1 day ticket cost which looks like dp[i-1] + costs[0].\\n- We buy a seven day valid ticket which is dp[i-7] + costs[1]. ****But catch here is that we may still be at day 5(index 5) so 5-7 = -2 so that is a case we need to handle so dp[Math.max(0,i-7)] + costs[1]****\\n- We 30 days pass dp[Math.max(0,i-30)] + costs[2]\\n\\n*The underflow condition where we do Math.max(0, i-x) is imp and comes to mind only with practice*\\n\\n\\n---\\n\\n\\n# Approach\\n1) Define dp array to n+1 length where n is the max day we need to travel i.e days[length-1] element.\\n2) Since we don\\'t visit all the days we will maintain a boolean travel day array or Set anything would work\\n3) We traverse through all days and calculate\\n4) If the day is not in travel list cost remains same as what it costed us for last day i.e dp[i] = dp[i-1] where ith day is not travelled one\\n5) For travelled day i have explained above.\\n6) Return the value at last index of dp\\n\\nTo understand different type of DP see this [Leetcode award wining article](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns) that helped me during my prepartion time\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) Since we are travesing the days array once.\\n\\n- Space complexity:\\nO(n) for the DP array\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int maxDay = days[days.length-1];\\n        boolean [] travelDay = new boolean[maxDay+1];\\n        for(int day: days){\\n            travelDay[day] =true;\\n        }\\n        int [] dp = new int[maxDay+1];\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=maxDay;i++){\\n            if(!travelDay[i]){\\n                //dont have to buy a ticket if it is not a travel day\\n                dp[i]=dp[i-1]; \\n                continue;\\n            }\\n            dp[i] = costs[0]+dp[i-1];\\n            dp[i] = Math.min(dp[Math.max(0,i-7)]+costs[1],dp[i]);\\n            dp[i] = Math.min(dp[Math.max(0,i-30)]+costs[2],dp[i]);\\n        }\\n        return dp[maxDay];\\n    }\\n}\\n```\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/f3061d04-264d-411d-927e-55aa85c647aa_1679972485.450106.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int maxDay = days[days.length-1];\\n        boolean [] travelDay = new boolean[maxDay+1];\\n        for(int day: days){\\n            travelDay[day] =true;\\n        }\\n        int [] dp = new int[maxDay+1];\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=maxDay;i++){\\n            if(!travelDay[i]){\\n                //dont have to buy a ticket if it is not a travel day\\n                dp[i]=dp[i-1]; \\n                continue;\\n            }\\n            dp[i] = costs[0]+dp[i-1];\\n            dp[i] = Math.min(dp[Math.max(0,i-7)]+costs[1],dp[i]);\\n            dp[i] = Math.min(dp[Math.max(0,i-30)]+costs[2],dp[i]);\\n        }\\n        return dp[maxDay];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227236,
                "title": "python-solution",
                "content": "We construct a `dp` array with `dp[i]` recording the minimum cost up to `days[i]` (inclusive). We initialize `dp[0] = costs[0]`, and iterate `i` in `range(1, len(days))`, for each `i`, we initialize a pointer `j`, and let it traverse backwards starting with `i` to find the first `idx` such that `days[idx]` is at least 1 day, 7 days, and 30 days ago respectively from `days[i]`. We find the minimum of the three values and let `dp[i]` be that value. Since for each `i`, `j` can go back by at most 30 indices, the total runtime is `O(30*n) = O(n)`, and the space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        n = len(days)\\n        dp = [0]*n\\n        dp[0] = costs[0]\\n        for i in range(1, n):\\n            \\n            # buy one-day ticket\\n            dp[i] = dp[i-1]+costs[0]\\n            \\n            # what about buy seven-day ticket seven days ago\\n            j = i\\n            seven_ago = days[i]-7\\n            while j >= 0 and days[j] > seven_ago:\\n                j -= 1\\n            if j >= 0:\\n                dp[i] = min(dp[i], dp[j]+costs[1])\\n            else:\\n                dp[i] = min(dp[i], costs[1])\\n            \\n            # what about buy thirty-day ticket thirty days ago\\n            thirty_ago = days[i]-30\\n            while j >= 0 and days[j] > thirty_ago:\\n                j -= 1\\n            if j >= 0:\\n                dp[i] = min(dp[i], dp[j]+costs[2])\\n            else:\\n                dp[i] = min(dp[i], costs[2])\\n                \\n        return dp[-1]\\n```\\n\\nAnother solution: We can initialize a `dp` array and fill in every entry between `days[0]` and `days[-1]` with the minimum costs up to the respective day. This will eliminate the need to use another pointer to traverse back to find the minimum costs 1 day, 7 days, and 30 days ago. \\n\\nTime complexity: `O(m)`, space complexity: `O(m)`, where `m` is the range of days in `days`. We see that when `days` covers a wide range of days (`m` large `n` small), e.g., `days = [1, 365]`, the first algorithm performs better, and when `len(days)` is large but covers a relative small range of days (`n` large `m` small), e.g., `days = [4,6,8,9,10,12,15,20]`, the second algorithhm performs better.\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        dp = [0]*366\\n        j = 0\\n        for i in range(days[0], 366):\\n            if i == days[j]:\\n                dp[i] = dp[i-1]+costs[0]\\n                if i >= 7:\\n                    dp[i] = min(dp[i-7]+costs[1], dp[i])\\n                else:\\n                    dp[i] = min(dp[i], costs[1])\\n                if i >= 30:\\n                    dp[i] = min(dp[i-30]+costs[2], dp[i])\\n                else:\\n                    dp[i] = min(dp[i], costs[2])\\n                j += 1\\n                if j == len(days):\\n                    return dp[i]\\n            else:\\n                if i > 0:\\n                    dp[i] = dp[i-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        n = len(days)\\n        dp = [0]*n\\n        dp[0] = costs[0]\\n        for i in range(1, n):\\n            \\n            # buy one-day ticket\\n            dp[i] = dp[i-1]+costs[0]\\n            \\n            # what about buy seven-day ticket seven days ago\\n            j = i\\n            seven_ago = days[i]-7\\n            while j >= 0 and days[j] > seven_ago:\\n                j -= 1\\n            if j >= 0:\\n                dp[i] = min(dp[i], dp[j]+costs[1])\\n            else:\\n                dp[i] = min(dp[i], costs[1])\\n            \\n            # what about buy thirty-day ticket thirty days ago\\n            thirty_ago = days[i]-30\\n            while j >= 0 and days[j] > thirty_ago:\\n                j -= 1\\n            if j >= 0:\\n                dp[i] = min(dp[i], dp[j]+costs[2])\\n            else:\\n                dp[i] = min(dp[i], costs[2])\\n                \\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        dp = [0]*366\\n        j = 0\\n        for i in range(days[0], 366):\\n            if i == days[j]:\\n                dp[i] = dp[i-1]+costs[0]\\n                if i >= 7:\\n                    dp[i] = min(dp[i-7]+costs[1], dp[i])\\n                else:\\n                    dp[i] = min(dp[i], costs[1])\\n                if i >= 30:\\n                    dp[i] = min(dp[i-30]+costs[2], dp[i])\\n                else:\\n                    dp[i] = min(dp[i], costs[2])\\n                j += 1\\n                if j == len(days):\\n                    return dp[i]\\n            else:\\n                if i > 0:\\n                    dp[i] = dp[i-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350479,
                "title": "day-87-dp-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe approach used in the code is dynamic programming, where the algorithm maintains a dynamic programming array dp that stores the minimum cost of travel for each day of the year. The algorithm initializes dp[0] to zero since the cost of traveling on day 0 is zero. For each day from day 1 to day 365, the algorithm checks whether that day is in the days list or not. If the day is in the days list, the algorithm calculates the minimum cost of travel for that day based on the minimum cost of travel for the previous day plus the cost of buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass. The algorithm uses the minimum of these costs to update the dynamic programming array dp. If the day is not in the days list, the algorithm simply copies the value of dp[i-1] to dp[i].\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Create a function called mincostTickets that takes in two input parameters: days and costs.\\n2. Get the length of the days list and store it in a variable called n.\\n3. Create a dynamic programming array called dp of size 366 and fill it with INT_MAX.\\n4. Set dp[0] = 0 since the cost of travel on day 0 is zero.\\n5. Set a pointer j = 0.\\n6. Loop through all days from day 1 to day 365.\\n7. If the current day i equals the j-th day in the days list, then calculate the minimum cost of travel for that day using the following conditions:\\n    - a. dp[i] = min(dp[i], dp[i-1] + costs[0]) - If the cost of buying a 1-day pass and traveling on this day is cheaper than the previously calculated cost, then update dp[i].\\n    - b. if (i >= 7), dp[i] = min(dp[i], dp[i-7] + costs[1]) - If the cost of buying a 7-day pass and traveling on this day is cheaper than the previously calculated cost, then update dp[i].\\n    - c. if (i >= 30), dp[i] = min(dp[i], dp[i-30] + costs[2]) - If the cost of buying a 30-day pass and traveling on this day is cheaper than the previously calculated cost, then update dp[i].\\n    - d. Increment the pointer j.\\n1. Else, if the current day i is not in the days list, then dp[i] = dp[i-1].\\n2. Return dp[365], which gives the minimum cost of travel for the entire year.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(366, INT_MAX);\\n        dp[0] = 0;\\n        int j = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (j < n && i == days[j]) {\\n                dp[i] = min(dp[i], dp[i-1] + costs[0]);\\n                if (i >= 7) \\n                    dp[i] = min(dp[i], dp[i-7] + costs[1]);\\n                else \\n                    dp[i] = min(dp[i], costs[1]);\\n                if (i >= 30) \\n                    dp[i] = min(dp[i], dp[i-30] + costs[2]);\\n                else \\n                    dp[i] = min(dp[i], costs[2]);\\n                j++;\\n            } \\n            else {\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        return dp[365];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[366];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        int j = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (j < n && i == days[j]) {\\n                dp[i] = Math.min(dp[i], dp[i-1] + costs[0]);\\n                if (i >= 7) \\n                    dp[i] = Math.min(dp[i], dp[i-7] + costs[1]);\\n                else \\n                    dp[i] = Math.min(dp[i], costs[1]);\\n                if (i >= 30) \\n                    dp[i] = Math.min(dp[i], dp[i-30] + costs[2]);\\n                else \\n                    dp[i] = Math.min(dp[i], costs[2]);\\n                j++;\\n            } \\n            else {\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        return dp[365];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = len(days)\\n        dp = [float(\\'inf\\')] * 366\\n        dp[0] = 0\\n        j = 0\\n        for i in range(1, 366):\\n            if j < n and i == days[j]:\\n                dp[i] = min(dp[i], dp[i-1] + costs[0])\\n                if i >= 7:\\n                    dp[i] = min(dp[i], dp[i-7] + costs[1])\\n                else:\\n                    dp[i] = min(dp[i], costs[1])\\n                if i >= 30:\\n                    dp[i] = min(dp[i], dp[i-30] + costs[2])\\n                else:\\n                    dp[i] = min(dp[i], costs[2])\\n                j += 1\\n            else:\\n                dp[i] = dp[i-1]\\n        return dp[365]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(365*n) = O(n)**, where n is the length of the days list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(366) = O(1)**, since we only use a fixed size array of 366 elements.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(366, INT_MAX);\\n        dp[0] = 0;\\n        int j = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (j < n && i == days[j]) {\\n                dp[i] = min(dp[i], dp[i-1] + costs[0]);\\n                if (i >= 7) \\n                    dp[i] = min(dp[i], dp[i-7] + costs[1]);\\n                else \\n                    dp[i] = min(dp[i], costs[1]);\\n                if (i >= 30) \\n                    dp[i] = min(dp[i], dp[i-30] + costs[2]);\\n                else \\n                    dp[i] = min(dp[i], costs[2]);\\n                j++;\\n            } \\n            else {\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        return dp[365];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[366];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        int j = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (j < n && i == days[j]) {\\n                dp[i] = Math.min(dp[i], dp[i-1] + costs[0]);\\n                if (i >= 7) \\n                    dp[i] = Math.min(dp[i], dp[i-7] + costs[1]);\\n                else \\n                    dp[i] = Math.min(dp[i], costs[1]);\\n                if (i >= 30) \\n                    dp[i] = Math.min(dp[i], dp[i-30] + costs[2]);\\n                else \\n                    dp[i] = Math.min(dp[i], costs[2]);\\n                j++;\\n            } \\n            else {\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        return dp[365];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = len(days)\\n        dp = [float(\\'inf\\')] * 366\\n        dp[0] = 0\\n        j = 0\\n        for i in range(1, 366):\\n            if j < n and i == days[j]:\\n                dp[i] = min(dp[i], dp[i-1] + costs[0])\\n                if i >= 7:\\n                    dp[i] = min(dp[i], dp[i-7] + costs[1])\\n                else:\\n                    dp[i] = min(dp[i], costs[1])\\n                if i >= 30:\\n                    dp[i] = min(dp[i], dp[i-30] + costs[2])\\n                else:\\n                    dp[i] = min(dp[i], costs[2])\\n                j += 1\\n            else:\\n                dp[i] = dp[i-1]\\n        return dp[365]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500472,
                "title": "2-c-solutions-with-recursion-and-memorization",
                "content": "***We will simplify this question:***\\nFor each day we have 3 choices i.e. 1 day ticket, 7 day ticket and 30 day ticket. So we use recursion choosing 3 types of ticket each day and find out the minimum of those 3 types. \\n\\nLets take an example:\\ndays = {1, 3, 4, 9}    \\ncosts = {2, 4, 12}\\n\\n```\\ntaking 1 day ticket for day 1 and cost till now is 2\\ncost till day 1 is 2\\ntaking 1 day ticket for day 3 and cost till now is 4\\ncost till day 3 is 4\\ntaking 1 day ticket for day 4 and cost till now is 6\\ncost till day 4 is 6\\ntaking 1 day ticket for day 9 and cost till now is 8\\ncost till day 9 is 8\\ntaking 7 day ticket for day 9 and cost till now is 10\\ncost till day 9 is 10\\ntaking 30 day ticket for day 9 and cost till now is 18\\ncost till day 9 is 18\\ntaking 7 day ticket for day 4 and cost till now is 8\\ncost till day 4 is 8\\ngoing further because of validity 10 is greater than present day 9\\ncost till day 9 is 8\\ntaking 30 day ticket for day 4 and cost till now is 16\\ncost till day 4 is 16\\ngoing further because of validity 33 is greater than present day 9\\ncost till day 9 is 16\\ntaking 7 day ticket for day 3 and cost till now is 6\\ncost till day 3 is 6\\ngoing further because of validity 9 is greater than present day 4\\ncost till day 4 is 6\\ngoing further because of validity 9 is greater than present day 9\\ncost till day 9 is 6\\ntaking 30 day ticket for day 3 and cost till now is 14\\ncost till day 3 is 14\\ngoing further because of validity 32 is greater than present day 4\\ncost till day 4 is 14\\ngoing further because of validity 32 is greater than present day 9\\ncost till day 9 is 14\\ntaking 7 day ticket for day 1 and cost till now is 4\\ncost till day 1 is 4\\ngoing further because of validity 7 is greater than present day 3\\ncost till day 3 is 4\\ngoing further because of validity 7 is greater than present day 4\\ncost till day 4 is 4\\ntaking 1 day ticket for day 9 and cost till now is 6\\ncost till day 9 is 6\\ntaking 7 day ticket for day 9 and cost till now is 8\\ncost till day 9 is 8\\ntaking 30 day ticket for day 9 and cost till now is 16\\ncost till day 9 is 16\\ntaking 30 day ticket for day 1 and cost till now is 12\\ncost till day 1 is 12\\ngoing further because of validity 30 is greater than present day 3\\ncost till day 3 is 12\\ngoing further because of validity 30 is greater than present day 4\\ncost till day 4 is 12\\ngoing further because of validity 30 is greater than present day 9\\ncost till day 9 is 12\\n```\\n\\n*Hence most optimal is:*\\ntaking 1 day ticket for day 1 and cost till now is 2\\ntaking 7 day ticket for day 3 and cost till now is 6\\nday 4 and 9 are covered with the above ticket\\nTotal cost is 6\\n\\n***Recursion code:***\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return helper(0,0, days, costs);\\n    }\\n    \\n    int helper(int index,int validity, vector<int>& days, vector<int>& costs) {\\n        // if we reach nth index\\n        if(index>=days.size()) \\n            return 0;\\n        \\n        // if we buy a ticket with validity greater than current day\\n        if(validity >= days[index])\\n            return helper(index+1, validity, days, costs);\\n        \\n        int mini = INT_MAX;\\n        // Taking 1 day ticket and adding cost to present cost\\n        mini = min(mini, costs[0]+helper(index+1, days[index], days, costs));\\n        // Taking 7 day ticket and adding cost to present cost\\n        mini = min(mini, costs[1]+helper(index+1, days[index]+6, days, costs));\\n        // Taking 30 day ticket and adding cost to present cost\\n        mini = min(mini, costs[2]+helper(index+1, days[index]+29, days, costs));\\n        \\n        // storing the minimum in dp\\n        return mini;\\n    }\\n};\\n```\\n\\n***Optimised approach:*** 4ms Memorization (retrieving minimum amount for the days which we have already calculated min)\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // declaring dp with size of no of days\\n        dp.resize(days.size(),-1);\\n        return helper(0,0, days, costs);\\n    }\\n    \\n    int helper(int index,int validity, vector<int>& days, vector<int>& costs)\\n    {\\n        // if we reach nth index\\n        if(index>=days.size()) \\n            return 0;\\n        \\n        // if we buy a ticket with validity greater than current day\\n        if(validity >= days[index])\\n            return helper(index+1, validity, days, costs);\\n        \\n        // if we have already came across day[index], we can return dp[index] which has the minimum cost\\n        if(dp[index] != -1)\\n            return dp[index];\\n\\n        int mini = INT_MAX;\\n        // Taking 1 day ticket and adding cost to present cost\\n        mini = min(mini, costs[0]+helper(index+1, days[index], days, costs));\\n        // Taking 7 day ticket and adding cost to present cost\\n        mini = min(mini, costs[1]+helper(index+1, days[index]+6, days, costs));\\n        // Taking 30 day ticket and adding cost to present cost\\n        mini = min(mini, costs[2]+helper(index+1, days[index]+29, days, costs));\\n        \\n        // storing the minimum in dp\\n        return dp[index]=mini;\\n    }\\n};\\n```\\n\\nPlease Upvote If you liked it \\u263A\\uFE0F!! It keeps me motivated to post solutions like these.\\nIf there are any suggestions / questions / mistakes in my post, comment below.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntaking 1 day ticket for day 1 and cost till now is 2\\ncost till day 1 is 2\\ntaking 1 day ticket for day 3 and cost till now is 4\\ncost till day 3 is 4\\ntaking 1 day ticket for day 4 and cost till now is 6\\ncost till day 4 is 6\\ntaking 1 day ticket for day 9 and cost till now is 8\\ncost till day 9 is 8\\ntaking 7 day ticket for day 9 and cost till now is 10\\ncost till day 9 is 10\\ntaking 30 day ticket for day 9 and cost till now is 18\\ncost till day 9 is 18\\ntaking 7 day ticket for day 4 and cost till now is 8\\ncost till day 4 is 8\\ngoing further because of validity 10 is greater than present day 9\\ncost till day 9 is 8\\ntaking 30 day ticket for day 4 and cost till now is 16\\ncost till day 4 is 16\\ngoing further because of validity 33 is greater than present day 9\\ncost till day 9 is 16\\ntaking 7 day ticket for day 3 and cost till now is 6\\ncost till day 3 is 6\\ngoing further because of validity 9 is greater than present day 4\\ncost till day 4 is 6\\ngoing further because of validity 9 is greater than present day 9\\ncost till day 9 is 6\\ntaking 30 day ticket for day 3 and cost till now is 14\\ncost till day 3 is 14\\ngoing further because of validity 32 is greater than present day 4\\ncost till day 4 is 14\\ngoing further because of validity 32 is greater than present day 9\\ncost till day 9 is 14\\ntaking 7 day ticket for day 1 and cost till now is 4\\ncost till day 1 is 4\\ngoing further because of validity 7 is greater than present day 3\\ncost till day 3 is 4\\ngoing further because of validity 7 is greater than present day 4\\ncost till day 4 is 4\\ntaking 1 day ticket for day 9 and cost till now is 6\\ncost till day 9 is 6\\ntaking 7 day ticket for day 9 and cost till now is 8\\ncost till day 9 is 8\\ntaking 30 day ticket for day 9 and cost till now is 16\\ncost till day 9 is 16\\ntaking 30 day ticket for day 1 and cost till now is 12\\ncost till day 1 is 12\\ngoing further because of validity 30 is greater than present day 3\\ncost till day 3 is 12\\ngoing further because of validity 30 is greater than present day 4\\ncost till day 4 is 12\\ngoing further because of validity 30 is greater than present day 9\\ncost till day 9 is 12\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return helper(0,0, days, costs);\\n    }\\n    \\n    int helper(int index,int validity, vector<int>& days, vector<int>& costs) {\\n        // if we reach nth index\\n        if(index>=days.size()) \\n            return 0;\\n        \\n        // if we buy a ticket with validity greater than current day\\n        if(validity >= days[index])\\n            return helper(index+1, validity, days, costs);\\n        \\n        int mini = INT_MAX;\\n        // Taking 1 day ticket and adding cost to present cost\\n        mini = min(mini, costs[0]+helper(index+1, days[index], days, costs));\\n        // Taking 7 day ticket and adding cost to present cost\\n        mini = min(mini, costs[1]+helper(index+1, days[index]+6, days, costs));\\n        // Taking 30 day ticket and adding cost to present cost\\n        mini = min(mini, costs[2]+helper(index+1, days[index]+29, days, costs));\\n        \\n        // storing the minimum in dp\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // declaring dp with size of no of days\\n        dp.resize(days.size(),-1);\\n        return helper(0,0, days, costs);\\n    }\\n    \\n    int helper(int index,int validity, vector<int>& days, vector<int>& costs)\\n    {\\n        // if we reach nth index\\n        if(index>=days.size()) \\n            return 0;\\n        \\n        // if we buy a ticket with validity greater than current day\\n        if(validity >= days[index])\\n            return helper(index+1, validity, days, costs);\\n        \\n        // if we have already came across day[index], we can return dp[index] which has the minimum cost\\n        if(dp[index] != -1)\\n            return dp[index];\\n\\n        int mini = INT_MAX;\\n        // Taking 1 day ticket and adding cost to present cost\\n        mini = min(mini, costs[0]+helper(index+1, days[index], days, costs));\\n        // Taking 7 day ticket and adding cost to present cost\\n        mini = min(mini, costs[1]+helper(index+1, days[index]+6, days, costs));\\n        // Taking 30 day ticket and adding cost to present cost\\n        mini = min(mini, costs[2]+helper(index+1, days[index]+29, days, costs));\\n        \\n        // storing the minimum in dp\\n        return dp[index]=mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811626,
                "title": "c-simple-clear-dp-solution-explained-100-time-85-space",
                "content": "Okay, this program screamed \"dynamic programming\" since the first paragraph, so who am I to deny its requests? And who are you to question the fact that I hear voices while coding?!\\n\\nAnyway, we need to proceed so that:\\n* we build a dp array of `last + 1` elements, where `last` is the last day in `days` and `+ 1` is due to the fact that we will allow the first element to be `0` (and save ourselves the pain to think of every day `- 1` when otherwise moving through its indexes);\\n* we will proceed until the last element so that `dp[i]` will be the cumulative value of what we have paid up to the `i`th day (included);\\n* when we find a scheduled day (and, for convenience, we will use `j` to know which is going to be the next day from `days`), we will try to get the minimum between:\\n   - cost of a daily ticket (`costs[0]`), plus cumulative cost until the previous day;\\n   - cost of a weekly ticket (`costs[1]`), plus cumulative cost until the 7 days before (or from day `0`, whichever is lower);\\n   - cost of a monthly ticket (`costs[2]`), plus cumulative cost until the 30 days before (or from day `0`, whichever is lower);\\n* when we find an unscsheduled day (one not in the calendar), then we just carry on the value from the previous one, since our expenses won\\'t change.\\n\\nNotice that for weekly and monthly ticket having to get either the previous 7/30 days or from `0` is what will allow you to have a passing solutions even when the costs of the tickets are not in increasing order (you would fail otherwise, if you were to skip those ranges for the first days).\\n\\nOnce we are done, we just return the value of the last cell of `dp` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // initialising values\\n        int last = days.back(), dp[last + 1];\\n        dp[0] = 0;\\n        for (int i = 1, j = 0; i <= last; i++) {\\n            if (i == days[j]) {\\n                // moving j to the next number\\n                j++;\\n                // dp[i] must be the min of\\n                dp[i] = min({\\n                    // a daily ticket plus previous costs\\n                    costs[0] + dp[i - 1],\\n                    // a weekly ticket plus previous costs\\n                    costs[1] + dp[i - min(i, 7)],\\n                    // a monthly ticket plus previous costs\\n                    costs[2] + dp[i - min(i, 30)],\\n                });\\n            }\\n            else {\\n                // alternatively we keep progressing with the last recorded value\\n                dp[i] = dp[i - 1];\\n            }\\n        }\\n        return dp[last];\\n    }\\n};\\n```\\n\\nI am not sure how one might use less memory, if not having only an array (or maybe a deque) of 30 elements, but that seems rather expensive - suggestions are welcome as always :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // initialising values\\n        int last = days.back(), dp[last + 1];\\n        dp[0] = 0;\\n        for (int i = 1, j = 0; i <= last; i++) {\\n            if (i == days[j]) {\\n                // moving j to the next number\\n                j++;\\n                // dp[i] must be the min of\\n                dp[i] = min({\\n                    // a daily ticket plus previous costs\\n                    costs[0] + dp[i - 1],\\n                    // a weekly ticket plus previous costs\\n                    costs[1] + dp[i - min(i, 7)],\\n                    // a monthly ticket plus previous costs\\n                    costs[2] + dp[i - min(i, 30)],\\n                });\\n            }\\n            else {\\n                // alternatively we keep progressing with the last recorded value\\n                dp[i] = dp[i - 1];\\n            }\\n        }\\n        return dp[last];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226754,
                "title": "python-easy-to-understand-solution-with-comments",
                "content": "```\\ndef mincostTickets(self, days, costs):\\n    dp=[0]*366\\n    for d in range(366):\\n        if d not in days:\\n            dp[d]=dp[d-1]\\n            continue\\n\\t\\t//1-day pass on day d\\n        mincost=dp[d-1]+costs[0]\\n\\t\\t//7-day pass ending on or after day d\\n        mincost=min(mincost,dp[max(0,d-7)]+costs[1])\\n\\t\\t//30-day pass ending on or after day d\\n        mincost=min(mincost,dp[max(0,d-30)]+costs[2])\\n        dp[d]=mincost\\n    return dp[-1]",
                "solutionTags": [],
                "code": "```\\ndef mincostTickets(self, days, costs):\\n    dp=[0]*366\\n    for d in range(366):\\n        if d not in days:\\n            dp[d]=dp[d-1]\\n            continue\\n\\t\\t//1-day pass on day d\\n        mincost=dp[d-1]+costs[0]\\n\\t\\t//7-day pass ending on or after day d\\n        mincost=min(mincost,dp[max(0,d-7)]+costs[1])\\n\\t\\t//30-day pass ending on or after day d\\n        mincost=min(mincost,dp[max(0,d-30)]+costs[2])\\n        dp[d]=mincost\\n    return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3350801,
                "title": "easy-detailed-explanation-step-by-step",
                "content": "# Intuition\\n\\nOn each day, we need to look into future days and analyze if purchasing a 7 day or a 30 day pass will be benefitial.\\n- Weird scenario is when 30 day pass will be cheapest, the we can purchase that even for one day. But we ignore such cases in explaination since our answer also covers these cases\\n- So in other scenarios, getting a 7 day is benefitial if we need to travel multiple time in next seven days and cost of one 7 day pass would be less than purchasing one day pass multiple times for those days.\\n- If 7 day pass is cheaper and better then we can purchase that, but it might be possible that we are travelling a lot in not just 7 days but in next 30 days and getting a 30 day pass might be even cheaper\\n- So for each day, we look forward and find how many times we travel in next 7 days/ 30 days and calculate cost related to each option and choose the minimum.\\n- This is recursive problem since cost is Minimum of three available options\\n  - Get a one day pass and add rest of cost from next day onwards\\n  - Get a 7 day pass and add this cost and cost for remaining days after this 7 day pass expires \\n  - Get a 30 day pass and add this cost and cost for remaining days after this 30 day pass expires \\n\\n# Approach\\nIf we follow recursive approach we will get TLE, since multilple earlier days will require answer for later day and will make multiple calls but we can store the result i.e use DP to optimize.\\n\\n So we maintain a DP array and start from last day and calculate cost for last day, then second last day and then so on.\\n\\nOn any particular day, we check how many days we travel in next 7/ 30 days and then add the cost of pass + the cost from the day in future when pass would have expired\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ Since we calculate values for DP array n times: for each time we can look forward upto a max 30 elements. So Actual complexity is 30*O(n) but for large n, 30 is a constant hence final complexity is O(n) only. \\n\\n- Space complexity:\\n$$O(n)$$ Since we maintain a DP array of size n.\\n\\n# Please upvote if you liked the post, Spread some love!!\\n![image.png](https://assets.leetcode.com/users/images/01777ae4-777e-4984-9b93-e93c87985d2d_1679992953.4628372.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int dp[n];\\n\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            // Option 1 - get a one day pass\\n            int opOne = costs[0] + (i < n-1 ? dp[i+1] : 0);\\n            int j;\\n            \\n            // Option 2 - get 7 day pass\\n            for(j = i+1; j < n && days[j] < days[i] + 7; j++);  // single line for loop to get past elements that are in next 7 days and have cost already covered by this pass\\n            int opTwo = costs[1] + (j < n ? dp[j] : 0);\\n\\n            //Option 3 - get 30 day pass\\n            //    Notice that same var j is used since elements that had days upto next 7 days have been iterated, now we need to go till 30\\n            for(; j < n && days[j] < days[i] + 30; j++);\\n            int opThree = costs[2] + (j < n ? dp[j] : 0);\\n\\n            dp[i] = min(opOne, min(opTwo, opThree));\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int dp[n];\\n\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            // Option 1 - get a one day pass\\n            int opOne = costs[0] + (i < n-1 ? dp[i+1] : 0);\\n            int j;\\n            \\n            // Option 2 - get 7 day pass\\n            for(j = i+1; j < n && days[j] < days[i] + 7; j++);  // single line for loop to get past elements that are in next 7 days and have cost already covered by this pass\\n            int opTwo = costs[1] + (j < n ? dp[j] : 0);\\n\\n            //Option 3 - get 30 day pass\\n            //    Notice that same var j is used since elements that had days upto next 7 days have been iterated, now we need to go till 30\\n            for(; j < n && days[j] < days[i] + 30; j++);\\n            int opThree = costs[2] + (j < n ? dp[j] : 0);\\n\\n            dp[i] = min(opOne, min(opTwo, opThree));\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349875,
                "title": "c-simple-dp-solution-100-91-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake the minimum cost of tickets for each day, bottom up approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate backwards from the last day.\\n- Set days of no travel as -1, we can calculate the price of these days as the same as the next day.\\n- For days of travel, we take the minimum price of a 1 day ticket, 7 day ticket, and 30 day ticket.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = *max_element(days.begin(), days.end());\\n        vector<int> dp(lastDay + 2, -1);\\n        // needed a + 1 so that the ticket can also cover the last day\\n        dp[lastDay + 1] = 0; // no trips after the last day so price is 0\\n\\n        for (auto day : days) dp[day] = 0;\\n\\n        for (int i = lastDay; i >= 0; i--) {\\n            // no trips that day, take the price of next day\\n            if (dp[i] == -1) dp[i] = dp[i + 1];\\n            else {\\n                dp[i] = dp[min(i + 1, lastDay + 1)] + costs[0]; // 1 day pass\\n                dp[i] = min(dp[i], dp[min(i + 7, lastDay + 1)] + costs[1]); // 7 day pass\\n                dp[i] = min(dp[i], dp[min(i + 30, lastDay + 1)] + costs[2]); // 30 day pass\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n![Screenshot 2023-03-27 231946.png](https://assets.leetcode.com/users/images/1408ec23-7284-4d56-90c9-ed048a9f2714_1679973630.1438503.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = *max_element(days.begin(), days.end());\\n        vector<int> dp(lastDay + 2, -1);\\n        // needed a + 1 so that the ticket can also cover the last day\\n        dp[lastDay + 1] = 0; // no trips after the last day so price is 0\\n\\n        for (auto day : days) dp[day] = 0;\\n\\n        for (int i = lastDay; i >= 0; i--) {\\n            // no trips that day, take the price of next day\\n            if (dp[i] == -1) dp[i] = dp[i + 1];\\n            else {\\n                dp[i] = dp[min(i + 1, lastDay + 1)] + costs[0]; // 1 day pass\\n                dp[i] = min(dp[i], dp[min(i + 7, lastDay + 1)] + costs[1]); // 7 day pass\\n                dp[i] = min(dp[i], dp[min(i + 30, lastDay + 1)] + costs[2]); // 30 day pass\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645560,
                "title": "c-using-dp-very-easy-to-understand-must-see-clear-idea-and-comments",
                "content": "***Pls upvote if you find this helpful  :)***\\n\\nBaic idea here is to break the problem into subproblems.Here we get three options on the days we are travelling ,we can get a one day pass,seven or a thirty days one.We take the minimum of all these possibilities and update each day beginning from day1 to day 365 and finally return day 365. We keep boolean array ifTravelled for the days when we Travel.\\nFor a 1-day pass for ith day, i.e dp[i] = dp[i - 1] + cost[0]\\nFor a 7-day pass ending on day i i.e dp[i] = min(dp[i - 7], dp[i - 6] ... dp[i - 1]) + cost[1]\\nFor a 30-day pass ending on day i, dp[i] = min(dp[i - 30], dp[i - 29] ... dp[i - 1]) + cost[2]\\n\\nBut here we can notice dp is increasing therefore the minimum will be dp[i-7] and dp[i-30] respectively.\\nTherefore, \\n             one day pass=dp[i-1]+costs[0]          \\n             seven day pass=dp[(i-7)]+costs[1]      \\n             thirty day pass=dp[(i-30)]+costs[2] \\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<bool> ifTravelled(366,false);// boolean vector to keep track of days we travelled\\n        for(int i:days)ifTravelled[i]=true;\\n        vector<int> dp(366,INT_MAX);       //this vector keeps track of costs till the respective days\\n        dp[0]=0;                           //initialisation\\n        for(int i=1;i<366;i++){\\n            if(!ifTravelled[i])            //for the days we didn\\'t travel update it with value of previous day\\n            {\\n                dp[i]=dp[i-1];\\n                continue;\\n             }\\n            int one=dp[i-1]+costs[0];               //one day pass cost \\n            int seven=dp[max(i-7,0)]+costs[1];      //seven day pass cost,handled when i-7<0\\n            int thirty=dp[max(i-30,0)]+costs[2];    //thirty day pass cost,we have handled the condition when i-30<0\\n            \\n                 dp[i]=std::min({one,seven,thirty}); //update the value with the minimum of all three passes\\n      }   \\n         return dp[365] ;                            //finally return last day value\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<bool> ifTravelled(366,false);// boolean vector to keep track of days we travelled\\n        for(int i:days)ifTravelled[i]=true;\\n        vector<int> dp(366,INT_MAX);       //this vector keeps track of costs till the respective days\\n        dp[0]=0;                           //initialisation\\n        for(int i=1;i<366;i++){\\n            if(!ifTravelled[i])            //for the days we didn\\'t travel update it with value of previous day\\n            {\\n                dp[i]=dp[i-1];\\n                continue;\\n             }\\n            int one=dp[i-1]+costs[0];               //one day pass cost \\n            int seven=dp[max(i-7,0)]+costs[1];      //seven day pass cost,handled when i-7<0\\n            int thirty=dp[max(i-30,0)]+costs[2];    //thirty day pass cost,we have handled the condition when i-30<0\\n            \\n                 dp[i]=std::min({one,seven,thirty}); //update the value with the minimum of all three passes\\n      }   \\n         return dp[365] ;                            //finally return last day value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472937,
                "title": "a-comparison-between-the-forward-and-backward-approach",
                "content": "```C++\\n// 1. forward\\n// dp[i] represents the cost you need if day i \\n// is the i-th day in your traverl plan. In other words,\\n// the cost if you traverl from day 1 to day i.\\n//\\n// If you do not travel on day i, dp[i] = dp[i-1];\\n// If you DO traverl on day i, dp[i] = min(dp[i-1] + costs[0], dp[i-7] + costs[1] + dp[i-30] + costs[2]).\\nint forward(vector<int>& days, vector<int>& costs) {\\n\\tunordered_set<int> dayset(days.begin(), days.end());\\n\\n\\tvector<int> dp(366, 0);\\n\\tfor(int i = 1; i < 366; ++i) {\\n\\t\\tif (dayset.find(i) == dayset.end()) {\\n\\t\\t\\tdp[i] = dp[i-1];\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = min({dp[i-1] + costs[0], \\n\\t\\t\\t\\t\\t\\t dp[max(i-7, 0)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(i-30, 0)] + costs[2]});\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[365];\\n}\\n\\n// 2. backward\\n// dp[i] represents the cost you need if day i is \\n// the first day in your travel plan. In other words,\\n// the cost if you travel from day i to day 365.\\n//\\n// If you do not travel on day i, dp[i] = dp[i+1];\\n// If you DO traverl on day i, dp[i] = min(dp[i+1] + costs[0], dp[i+7] + costs[1] + dp[i+30] + costs[2]).\\nint backward(vector<int>&days, vector<int>& costs) {\\n\\tunordered_set<int> dayset(days.begin(), days.end());\\n\\n\\tvector<int> dp(367, 0);\\n\\tfor(int i = 365; i >= 1; --i) {\\n\\t\\tif (dayset.find(i) == dayset.end()) {\\n\\t\\t\\tdp[i] = dp[i+1];\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = min({dp[i+1] + costs[0], \\n\\t\\t\\t\\t\\t\\t dp[min(i+7, 366)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[min(i+30, 366)] + costs[2]});\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[1];\\n}\\n```\\nThe important thing is to find the relationship and understand the meaning of `dp[i]`.",
                "solutionTags": [],
                "code": "```C++\\n// 1. forward\\n// dp[i] represents the cost you need if day i \\n// is the i-th day in your traverl plan. In other words,\\n// the cost if you traverl from day 1 to day i.\\n//\\n// If you do not travel on day i, dp[i] = dp[i-1];\\n// If you DO traverl on day i, dp[i] = min(dp[i-1] + costs[0], dp[i-7] + costs[1] + dp[i-30] + costs[2]).\\nint forward(vector<int>& days, vector<int>& costs) {\\n\\tunordered_set<int> dayset(days.begin(), days.end());\\n\\n\\tvector<int> dp(366, 0);\\n\\tfor(int i = 1; i < 366; ++i) {\\n\\t\\tif (dayset.find(i) == dayset.end()) {\\n\\t\\t\\tdp[i] = dp[i-1];\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = min({dp[i-1] + costs[0], \\n\\t\\t\\t\\t\\t\\t dp[max(i-7, 0)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(i-30, 0)] + costs[2]});\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[365];\\n}\\n\\n// 2. backward\\n// dp[i] represents the cost you need if day i is \\n// the first day in your travel plan. In other words,\\n// the cost if you travel from day i to day 365.\\n//\\n// If you do not travel on day i, dp[i] = dp[i+1];\\n// If you DO traverl on day i, dp[i] = min(dp[i+1] + costs[0], dp[i+7] + costs[1] + dp[i+30] + costs[2]).\\nint backward(vector<int>&days, vector<int>& costs) {\\n\\tunordered_set<int> dayset(days.begin(), days.end());\\n\\n\\tvector<int> dp(367, 0);\\n\\tfor(int i = 365; i >= 1; --i) {\\n\\t\\tif (dayset.find(i) == dayset.end()) {\\n\\t\\t\\tdp[i] = dp[i+1];\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = min({dp[i+1] + costs[0], \\n\\t\\t\\t\\t\\t\\t dp[min(i+7, 366)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[min(i+30, 366)] + costs[2]});\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226672,
                "title": "java-1-d-dp-time-space-o-1",
                "content": "For each day, it could be covered by the tickets bought on today or before. \\nFor each day, we check if it\\'s in the days array. If not, then the cost should remain the same; otherwise, check today\\'s cost could be coved by which day that will minimize total cost up to today.\\n\\n```\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] minCosts = new int[366];\\n        boolean[] isDays = new boolean[366];\\n        for(int day: days) isDays[day] = true;\\n        \\n        for(int i = 1; i <= 365; i++) {\\n            if(!isDays[i]) {\\n                minCosts[i] = minCosts[i - 1];\\n                continue;\\n            }\\n            int minCost;\\n            // case 1\\n            minCost = minCosts[i - 1] + costs[0];\\n            // case 2\\n            minCost = Math.min(minCost, minCosts[Math.max(0, i - 7)] + costs[1]);\\n            // case 3\\n            minCost = Math.min(minCost, minCosts[Math.max(0, i - 30)] + costs[2]);\\n            \\n            minCosts[i] = minCost;\\n        }\\n        \\n        return minCosts[365];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] minCosts = new int[366];\\n        boolean[] isDays = new boolean[366];\\n        for(int day: days) isDays[day] = true;\\n        \\n        for(int i = 1; i <= 365; i++) {\\n            if(!isDays[i]) {\\n                minCosts[i] = minCosts[i - 1];\\n                continue;\\n            }\\n            int minCost;\\n            // case 1\\n            minCost = minCosts[i - 1] + costs[0];\\n            // case 2\\n            minCost = Math.min(minCost, minCosts[Math.max(0, i - 7)] + costs[1]);\\n            // case 3\\n            minCost = Math.min(minCost, minCosts[Math.max(0, i - 30)] + costs[2]);\\n            \\n            minCosts[i] = minCost;\\n        }\\n        \\n        return minCosts[365];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 811521,
                "title": "python-3-lines-intuitive-dp-binary-search-beats-99",
                "content": "```\\nclass Solution:\\n    \\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        @lru_cache(maxsize = None)\\n        def helper(i):\\n            if i >= lend: return 0\\n            return min(costs[0] + helper(bisect.bisect_left(days, days[i] + 1)), \\n                      costs[1] + helper(bisect.bisect_left(days, days[i] + 7)),\\n                      costs[2] + helper(bisect.bisect_left(days, days[i] + 30)))\\n        \\n        lend = len(days)\\n        return helper(0)\\n```\\n\\n\\tWhen to think of DP?\\n    - Any question where the answer to smallest valid inputs are necessary, we should think of DP\\n\\n    Any recurssive solution will have 3 segments\\n    - base condition \\n    - a choice\\n    - a way to break down the question into smaller questions\\n\\n    Base condition here is?\\n    - if there are no travel days --> cost is 0\\n    - Awesome, that was simple\\n\\n    Choice here is?\\n    - I can take tickets for \\n        - 1 day\\n        - 7 days\\n        - 30 days\\n    - Awesome, we need the minimum\\n\\n    Breaking the question into smaller questions?\\n    - When we buy 1 day ticket, we travel for a day, so we can remove that day from the list...\\n    - Same goes when we buy 7 day ticket (we travel for 7 days, so remove 7 days from the list), 30 day ticket (we travel for 30 days, so remove 30 days from the list)... \\n    - Awesome, even that was simple\\n\\n    Now, the DP part... \\n    - Usually, blindly putting a cache would help...\\n\\n    But let me give it a shot to explain why it works:\\n    - Usually there will be cases where things overlap, like buying a 7 day ticket and then 2 day ticket, might overlap with buy 2 day ticket and then 7 day..\\n    - It is not sure, because it depends on the input days. \\n\\n    Why binarysearch?\\n    - As the days are in ascending (strictly increasing) order. We can leverage this info to find the 7th day index or 30th day index from today using binary search.\\n    - Instead of using linear search.\\n\\n    Why does helper function have an index for the days list?\\n    - Because, days list in itself cannot be hashed into cache. So, we have to use something that is hashable (or immutable). \\n    - Also, indexes are way lighter than the whole list. So, the index will be pointing to the current day in each recurssive call.\\n\\n    Please like if I was able to help you. Thank you for reading.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        @lru_cache(maxsize = None)\\n        def helper(i):\\n            if i >= lend: return 0\\n            return min(costs[0] + helper(bisect.bisect_left(days, days[i] + 1)), \\n                      costs[1] + helper(bisect.bisect_left(days, days[i] + 7)),\\n                      costs[2] + helper(bisect.bisect_left(days, days[i] + 30)))\\n        \\n        lend = len(days)\\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647874,
                "title": "c-recursion-memoization-tabulation-binarysearch",
                "content": "# Method - 1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/390d04d4-2e6e-4ec4-8970-6ddb65a03861_1664654022.6634092.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& d,vector<int>& c,int n){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tint ind1=lower_bound(d.begin(),d.end(),d[i]+1)-d.begin();\\n\\t\\t\\tint op1=c[0]+f(ind1,d,c,n);\\n\\t\\t\\tint ind2=lower_bound(d.begin(),d.end(),d[i]+7)-d.begin();\\n\\t\\t\\tint op2=c[1]+f(ind2,d,c,n);\\n\\t\\t\\tint ind3=lower_bound(d.begin(),d.end(),d[i]+30)-d.begin();\\n\\t\\t\\tint op3=c[2]+f(ind3,d,c,n);\\n\\t\\t\\treturn min(op1,min(op2,op3));\\n\\t\\t}\\n\\n\\t\\tint mincostTickets(vector<int>& d, vector<int>& c) {\\n\\t\\t\\tint n=d.size();\\n\\t\\t\\treturn f(0,d,c,n);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/0c9059a5-1285-47dc-9b2a-58343821717b_1664654170.3973186.png)\\'\\n\\n**T->O(n) && S->O(n) + O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& d,vector<int>& c,int n,vector<int>& dp){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tif(dp[i]!=-1) return dp[i];\\n\\t\\t\\tint ind1=lower_bound(d.begin(),d.end(),d[i]+1)-d.begin();\\n\\t\\t\\tint op1=c[0]+f(ind1,d,c,n,dp);\\n\\t\\t\\tint ind2=lower_bound(d.begin(),d.end(),d[i]+7)-d.begin();\\n\\t\\t\\tint op2=c[1]+f(ind2,d,c,n,dp);\\n\\t\\t\\tint ind3=lower_bound(d.begin(),d.end(),d[i]+30)-d.begin();\\n\\t\\t\\tint op3=c[2]+f(ind3,d,c,n,dp);\\n\\t\\t\\treturn dp[i]=min(op1,min(op2,op3));\\n\\t\\t}\\n\\n\\t\\tint mincostTickets(vector<int>& d, vector<int>& c) {\\n\\t\\t\\tint n=d.size();\\n\\t\\t\\tvector<int> dp(n,-1);\\n\\t\\t\\treturn f(0,d,c,n,dp);\\n\\t\\t}\\n\\t};\\n\\n# Method -2 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/bbe375e3-7833-4ef3-a93e-6409889b04c0_1664654431.5132751.png)\\n\\n**T->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:    \\n\\t\\tint mincostTickets(vector<int>& d, vector<int>& c) {\\n\\t\\t\\tint n=d.size();\\n\\t\\t\\tvector<int> dp(n+1,0);\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tint ind1=lower_bound(d.begin(),d.end(),d[i]+1)-d.begin();\\n\\t\\t\\t\\tint op1=c[0]+dp[ind1];\\n\\t\\t\\t\\tint ind2=lower_bound(d.begin(),d.end(),d[i]+7)-d.begin();\\n\\t\\t\\t\\tint op2=c[1]+dp[ind2];\\n\\t\\t\\t\\tint ind3=lower_bound(d.begin(),d.end(),d[i]+30)-d.begin();\\n\\t\\t\\t\\tint op3=c[2]+dp[ind3];\\n\\t\\t\\t\\tdp[i]=min(op1,min(op2,op3));\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0];\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& d,vector<int>& c,int n){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tint ind1=lower_bound(d.begin(),d.end(),d[i]+1)-d.begin();\\n\\t\\t\\tint op1=c[0]+f(ind1,d,c,n);\\n\\t\\t\\tint ind2=lower_bound(d.begin(),d.end(),d[i]+7)-d.begin();\\n\\t\\t\\tint op2=c[1]+f(ind2,d,c,n);\\n\\t\\t\\tint ind3=lower_bound(d.begin(),d.end(),d[i]+30)-d.begin();\\n\\t\\t\\tint op3=c[2]+f(ind3,d,c,n);\\n\\t\\t\\treturn min(op1,min(op2,op3));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1412598,
                "title": "c-memoized-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int helper(vector<int> &arr,vector<int>& cost,int l)\\n    {\\n        if(l>365){\\n            return 0;\\n        }\\n        \\n        if(dp[l] != -1){                      // if calculated earlier , then return \\n            return dp[l];\\n        }\\n        if(arr[l] == 0){                    // if we dont have to travel on lth day , then skip and increase l\\n            return dp[l] = helper(arr,cost,l+1);          // calculate and store\\n        }\\n        else{\\n            \\n            int op1 = cost[0] + helper(arr,cost,l+1);//buy one day ticket\\n            int op2 = cost[1] + helper(arr,cost,l+7);//buy seven day ticket\\n            int op3 = cost[2] + helper(arr,cost,l+30);//buy thirty day day ticket\\n\\n\\n            return dp[l] = min(op1,min(op2,op3));   // return minimum out of three options\\n        }\\n        \\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        \\n        int n = days.size();\\n        vector<int> arr(366,0);\\n        \\n        for(int i=0;i<n;i++){\\n            arr[days[i]]++;\\n        }\\n        \\n        for(int i=0;i<366;i++) dp[i] = -1;\\n        \\n        return helper(arr,costs,1);\\n    }\\n};\\n```\\n\\n**If this post helped you in any way ,please consider upvoting .Thanks**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int helper(vector<int> &arr,vector<int>& cost,int l)\\n    {\\n        if(l>365){\\n            return 0;\\n        }\\n        \\n        if(dp[l] != -1){                      // if calculated earlier , then return \\n            return dp[l];\\n        }\\n        if(arr[l] == 0){                    // if we dont have to travel on lth day , then skip and increase l\\n            return dp[l] = helper(arr,cost,l+1);          // calculate and store\\n        }\\n        else{\\n            \\n            int op1 = cost[0] + helper(arr,cost,l+1);//buy one day ticket\\n            int op2 = cost[1] + helper(arr,cost,l+7);//buy seven day ticket\\n            int op3 = cost[2] + helper(arr,cost,l+30);//buy thirty day day ticket\\n\\n\\n            return dp[l] = min(op1,min(op2,op3));   // return minimum out of three options\\n        }\\n        \\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        \\n        int n = days.size();\\n        vector<int> arr(366,0);\\n        \\n        for(int i=0;i<n;i++){\\n            arr[days[i]]++;\\n        }\\n        \\n        for(int i=0;i<366;i++) dp[i] = -1;\\n        \\n        return helper(arr,costs,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741697,
                "title": "with-explanation-python-dp-short-and-fast-solution",
                "content": "Dynamic Programming \\n\\ndp[d] is the minimum price up to dth day\\n\\nOn each day in days, to make sure we have a pass, we either \\n1. buy a 1-day pass on that day\\n2. buy a 7-day pass 6 days ago\\n2. buy a 30-day pass 29 days ago\\n\\nIf we buy a 7-day pass, the price will be the cost at \"dp[day - 7] + costs[1]\", which is the minimum price 7 days ago + we buy a 7-day pass 6 days ago\\n\\nWe can buy a 7-day pass or a 30-day pass on day 1. That\\'s why we have \"dp[max(d - 7, 0)]\" and \"dp[max(d - 30, 0)]\" to handle first 30 days.\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last_day = days[-1]\\n        dp = [0] * (last_day + 1) \\n        days = set(days) # convert day to set for fast look up later\\n        for d in range(1, last_day + 1):\\n            # to make sure we have pass, we either buy a 1-d pass today, a 7-d pass 6 days ago, or a 30-d pass 29 days ago\\n            if d in days:\\n                dp[d] = min(costs[2] + dp[max(d - 30, 0)], costs[1] + dp[max(d - 7, 0)], costs[0] + dp[d - 1])\\n            else: # we don\\'t buy pass on day not in days\\n                dp[d] = dp[d - 1]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last_day = days[-1]\\n        dp = [0] * (last_day + 1) \\n        days = set(days) # convert day to set for fast look up later\\n        for d in range(1, last_day + 1):\\n            # to make sure we have pass, we either buy a 1-d pass today, a 7-d pass 6 days ago, or a 30-d pass 29 days ago\\n            if d in days:\\n                dp[d] = min(costs[2] + dp[max(d - 30, 0)], costs[1] + dp[max(d - 7, 0)], costs[0] + dp[d - 1])\\n            else: # we don\\'t buy pass on day not in days\\n                dp[d] = dp[d - 1]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349791,
                "title": "day-362-flow-chart-java-c-python-explained-intuition-algo-dry-run-proof",
                "content": "# upvote pls \\n![image.png](https://assets.leetcode.com/users/images/8a1a80a1-d47e-4224-8f8e-252cb5007971_1679970799.0759618.png)\\n\\n\\n##### \\u2022\\tThere are several ways to solve the \"Minimum Cost For Tickets\" problem. Here are some of the common approaches:\\n##### \\u2022\\tBrute Force: Try all possible combinations of passes for each day in the travel period. This approach has an exponential time complexity of O(3^n), where n is the number of days in the travel period, and is not practical for large values of n.\\n##### \\u2022\\tDynamic Programming: Use a DP array to store the minimum cost for each day in the travel period. The DP array is initialized with the cost of the previous day, and the cost for each travel day is computed by trying all three types of passes and choosing the minimum cost. This approach has a time complexity of O(maxDay), where maxDay is the maximum day in the travel period.\\n##### \\u2022\\tSliding Window: Use a sliding window to keep track of the previous 7 and 30 days and compute the cost for each travel day. This approach has a time complexity of O(n), where n is the number of days in the travel period.\\n##### \\u2022\\tStack: Use a stack to keep track of the travel days and their corresponding costs. This approach has a time complexity of O(n), where n is the number of days in the travel period.\\n##### \\u2022\\tQueue: Use a queue to keep track of the travel days and their corresponding costs. This approach has a time complexity of O(n), where n is the number of days in the travel period.\\n##### \\u2022\\tAll of these approaches have different time and space complexities and may be more or less suitable depending on the specific requirements of the problem.\\n\\n\\n# Intuition for space optimized dp\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere\\'s the intuition behind the given mincostTickets function:\\n![image.png](https://assets.leetcode.com/users/images/2b59ddd9-bc59-4075-8244-8db009361a40_1679975601.5487628.png)\\n\\n##### \\u2022\\tThe intuition behind this problem is to find the minimum cost of buying tickets for a travel period, given the costs of one-day, seven-day and thirty-day passes, and the days on which the person will be traveling.\\n##### \\u2022\\tThe code first computes the maximum day in the travel period and initializes an array called \"isTravelDay\" to mark the days on which the person will be traveling.\\n##### \\u2022\\tThen, the code initializes the costs of different types of passes and computes the minimum cost for each day from 1 to maxDay. If it\\'s not a travel day, the cost is the same as the previous day. If it\\'s a travel day, the code tries all three types of passes and chooses the minimum cost.\\n##### \\u2022\\tFinally, the code returns the minimum cost for the entire travel period. The intuition is to use dynamic programming to efficiently compute the minimum cost for each day, using the results from previous days. This reduces the time complexity of the algorithm from exponential to linear.\\n\\n\\n# ALGO \\n##### \\u2022\\tThe algorithm used in this code is Dynamic Programming. Here\\'s how it works:\\n##### \\u2022\\tInitialize the DP array and mark the travel days: The first step is to initialize the DP array with 0s and mark the days on which the person will be traveling.\\n##### \\u2022\\tCompute the minimum cost for each day from 1 to maxDay: For each day from 1 to maxDay, the algorithm checks if it\\'s a travel day or not. If it\\'s not a travel day, the cost is the same as the previous day. If it\\'s a travel day, the algorithm tries all three types of passes (one-day, seven-day, and thirty-day) and chooses the minimum cost. This is done using the formula dp[i] = Math.min(dp[i-1] + oneDayPassCost, dp[Math.max(0, i-7)] + sevenDayPassCost, dp[Math.max(0, i-30)] + thirtyDayPassCost).\\n##### \\u2022\\tReturn the minimum cost for the entire travel period: Once the minimum cost for each day has been computed, the algorithm returns the minimum cost for the entire travel period, which is stored in dp[maxDay].\\n##### \\u2022\\tThe time complexity of this algorithm is O(maxDay), where maxDay is the maximum day in the travel period. This is because the algorithm only needs to compute the minimum cost for each day once and then uses the results from previous days to compute the minimum cost for the current day. The space complexity is also O(maxDay), as the algorithm uses an array of size maxDay to store the DP values.\\n\\n\\n\\n```JAVA []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.length - 1];\\n    \\n    // Initialize the DP array and mark the travel days\\n    int[] dp = new int[maxDay + 1];\\n    boolean[] isTravelDay = new boolean[maxDay + 1];\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n    \\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n    \\n    // Compute the minimum cost for each day from 1 to maxDay\\n    for (int i = 1; i <= maxDay; i++) {\\n        if (!isTravelDay[i]) {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        } else {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[i - 1] + oneDayPassCost;\\n            int cost2 = dp[Math.max(0, i - 7)] + sevenDayPassCost;\\n            int cost3 = dp[Math.max(0, i - 30)] + thirtyDayPassCost;\\n            dp[i] = Math.min(cost1, Math.min(cost2, cost3));\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period\\n    return dp[maxDay];\\n}\\n```\\n```C++ []\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.size() - 1];\\n    \\n    // Initialize the DP array and mark the travel days\\n    vector<int> dp(maxDay + 1);\\n    vector<bool> isTravelDay(maxDay + 1);\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n    \\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n    \\n    // Compute the minimum cost for each day from 1 to maxDay\\n    for (int i = 1; i <= maxDay; i++) {\\n        if (!isTravelDay[i]) {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        } else {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[i - 1] + oneDayPassCost;\\n            int cost2 = dp[max(0, i - 7)] + sevenDayPassCost;\\n            int cost3 = dp[max(0, i - 30)] + thirtyDayPassCost;\\n            dp[i] = min(cost1, min(cost2, cost3));\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period\\n    return dp[maxDay];\\n}\\n```\\n```PYTHON []\\ndef mincostTickets(days: List[int], costs: List[int]) -> int:\\n    # Get the maximum day in the travel period\\n    maxDay = days[-1]\\n    \\n    # Initialize the DP array and mark the travel days\\n    dp = [0] * (maxDay + 1)\\n    isTravelDay = [False] * (maxDay + 1)\\n    for day in days:\\n        isTravelDay[day] = True\\n    \\n    # Initialize the costs of different types of passes\\n    oneDayPassCost = costs[0]\\n    sevenDayPassCost = costs[1]\\n    thirtyDayPassCost = costs[2]\\n    \\n    # Compute the minimum cost for each day from 1 to maxDay\\n    for i in range(1, maxDay + 1):\\n        if not isTravelDay[i]:\\n            # If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1]\\n        else:\\n            # If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            cost1 = dp[i - 1] + oneDayPassCost\\n            cost2 = dp[max(0, i - 7)] + sevenDayPassCost\\n            cost3 = dp[max(0, i - 30)] + thirtyDayPassCost\\n            dp[i] = min(cost1, cost2, cost3)\\n    \\n    # Return the minimum cost for the entire travel period\\n    return dp[maxDay]\\n```\\n\\n# Complexity\\nHere\\'s an explanation of the time complexity (TC) and space complexity (SC) of the mincostTickets function:\\n##### \\u2022\\tTime complexity: O(maxDay), where maxDay is the maximum day in the travel period. We iterate over each day from 1 to maxDay and compute the minimum cost for each day.\\n##### \\u2022\\tSpace complexity: O(maxDay), where maxDay is the maximum day in the travel period. We initialize an array of size maxDay + 1 to store the DP values and another array of size maxDay + 1 to mark the travel days. Therefore, the overall space complexity is O(maxDay + maxDay) = O(maxDay).\\n\\n# 2ND WAY DP top down :\\n\\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.length - 1];\\n\\n    // Initialize the DP array and mark the travel days\\n    int[] dp = new int[maxDay + 1];\\n    boolean[] isTravelDay = new boolean[maxDay + 1];\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n\\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n\\n    // Compute the minimum cost for each day from 1 to maxDay\\n    return minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay);\\n}\\n\\nprivate int minCost(int[] days, int[] costs, int[] dp, boolean[] isTravelDay, int oneDayPassCost, int sevenDayPassCost, int thirtyDayPassCost, int day, int maxDay) {\\n    if (day > maxDay) {\\n        return 0;\\n    }\\n    if (dp[day] != 0) {\\n        return dp[day];\\n    }\\n    if (!isTravelDay[day]) {\\n        dp[day] = minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n    } else {\\n        int cost1 = oneDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n        int cost2 = sevenDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 7), maxDay);\\n        int cost3 = thirtyDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 30), maxDay);\\n        dp[day] = Math.min(cost1, Math.min(cost2, cost3));\\n    }\\n    return dp[day];\\n}\\n\\nprivate int findNextTravelDay(int[] days, int day, int duration) {\\n    int i = 0;\\n    while (i < days.length && days[i] < day + duration) {\\n        i++;\\n    }\\n    return i < days.length ? days[i] : days[days.length - 1] + 1;\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int maxDay = days[days.size() - 1];\\n        vector<int> dp(maxDay + 1);\\n        vector<bool> isTravelDay(maxDay + 1);\\n        for (int day : days) {\\n            isTravelDay[day] = true;\\n        }\\n        int oneDayPassCost = costs[0];\\n        int sevenDayPassCost = costs[1];\\n        int thirtyDayPassCost = costs[2];\\n        return minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay);\\n    }\\n\\n    int minCost(vector<int>& days, vector<int>& costs, vector<int>& dp, vector<bool>& isTravelDay, int oneDayPassCost, int sevenDayPassCost, int thirtyDayPassCost, int day, int maxDay) {\\n        if (day > maxDay) {\\n            return 0;\\n        }\\n        if (dp[day] != 0) {\\n            return dp[day];\\n        }\\n        if (!isTravelDay[day]) {\\n            dp[day] = minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n        } else {\\n            int cost1 = oneDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n            int cost2 = sevenDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 7), maxDay);\\n            int cost3 = thirtyDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 30), maxDay);\\n            dp[day] = min(cost1, min(cost2, cost3));\\n        }\\n        return dp[day];\\n    }\\n\\n    int findNextTravelDay(vector<int>& days, int day, int duration) {\\n        int i = 0;\\n        while (i < days.size() && days[i] < day + duration) {\\n            i++;\\n        }\\n        return i < days.size() ? days[i] : days[days.size() - 1] + 1;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        maxDay = days[-1]\\n        dp = [0] * (maxDay + 1)\\n        isTravelDay = [False] * (maxDay + 1)\\n        for day in days:\\n            isTravelDay[day] = True\\n        oneDayPassCost = costs[0]\\n        sevenDayPassCost = costs[1]\\n        thirtyDayPassCost = costs[2]\\n        return self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay)\\n\\n    def minCost(self, days: List[int], costs: List[int], dp: List[int], isTravelDay: List[bool], oneDayPassCost: int, sevenDayPassCost: int, thirtyDayPassCost: int, day: int, maxDay: int) -> int:\\n        if day > maxDay:\\n            return 0\\n        if dp[day] != 0:\\n            return dp[day]\\n        if not isTravelDay[day]:\\n            dp[day] = self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay)\\n        else:\\n            cost1 = oneDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay)\\n            cost2 = sevenDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, self.findNextTravelDay(days, day, 7), maxDay)\\n            cost3 = thirtyDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, self.findNextTravelDay(days, day, 30), maxDay)\\n            dp[day] = min(cost1, min(cost2, cost3))\\n```\\n# 3rd way \\n\\n```PYTHON []\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n    # Initialize the DP array with all 0s\\n    dp = [0] * (days[-1] + 1)\\n    \\n    # Convert the list of travel days into a set for faster lookups\\n    travel_days = set(days)\\n    \\n    # Compute the minimum cost for each day from 1 to the maximum day\\n    for i in range(1, len(dp)):\\n        if i in travel_days:\\n            # If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            cost1 = dp[max(i - 1, 0)] + costs[0]\\n            cost2 = dp[max(i - 7, 0)] + costs[1]\\n            cost3 = dp[max(i - 30, 0)] + costs[2]\\n            dp[i] = min(cost1, cost2, cost3)\\n        else:\\n            # If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1]\\n    \\n    # Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp[-1]\\n```\\n```JAVA []\\npublic int mincostTickets(int[] days, int[] costs) { // Initialize the DP array with all 0s \\nint[] dp = new int[days[days.length - 1] + 1];\\n\\n    // Convert the list of travel days into a set for faster lookups\\n    Set<Integer> travelDays = new HashSet<>();\\n    for (int day : days) {\\n        travelDays.add(day);\\n    }\\n    \\n    // Compute the minimum cost for each day from 1 to the maximum day\\n    for (int i = 1; i < dp.length; i++) {\\n        if (travelDays.contains(i)) {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[Math.max(i - 1, 0)] + costs[0];\\n            int cost2 = dp[Math.max(i - 7, 0)] + costs[1];\\n            int cost3 = dp[Math.max(i - 30, 0)] + costs[2];\\n            dp[i] = Math.min(cost1, Math.min(cost2, cost3));\\n        } else {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp[dp.length - 1];\\n}\\n```\\n```C++ []\\nint mincostTickets(vector<int>& days, vector<int>& costs) { // Initialize the DP array with all 0s \\n    vector dp(days.back() + 1, 0);\\n\\n    // Convert the list of travel days into a set for faster lookups\\n    unordered_set<int> travel_days(days.begin(), days.end());\\n    \\n    // Compute the minimum cost for each day from 1 to the maximum day\\n    for (int i = 1; i < dp.size(); i++) {\\n        if (travel_days.count(i)) {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[max(i - 1, 0)] + costs[0];\\n            int cost2 = dp[max(i - 7, 0)] + costs[1];\\n            int cost3 = dp[max(i - 30, 0)] + costs[2];\\n            dp[i] = min(cost1, min(cost2, cost3));\\n        } else {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp.back();\\n}\\n```\\n# DP bottom up\\n\\n# INTUTION \\n\\n##### \\u2022\\tThe problem is to find the minimum cost to buy passes to travel on a given set of days. We can solve this problem using dynamic programming.\\n##### \\u2022\\tWe can define a recursive function minCost(days, costs, pass, index, dp) that returns the minimum cost to travel for the remaining days starting from the given index. We can use memoization to avoid recomputing the same subproblems.\\n##### \\u2022\\tAt each step, we can try all three types of passes (1-day, 7-day, and 30-day passes) and choose the one that gives the minimum cost. To find the cost of a pass, we need to add the cost of the pass to the cost of traveling for the remaining days after the pass expires.\\n##### \\u2022\\tTo find the index of the next day after a pass expires, we can use a loop to find the first day that is after the current day plus the duration of the pass.\\n##### \\u2022\\tThe base case of the recursion is when we have covered all the days. In this case, the cost is 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nHere\\'s an explanation of the algorithm used in the mincostTickets function:\\n##### \\u2022\\tDefine the passes: The given problem requires us to find the minimum cost to travel on a set of days. We are given three types of passes: a 1-day pass, a 7-day pass, and a 30-day pass. We can define these passes as an array pass of length 3, where pass[i] represents the duration of the i-th pass.\\n##### \\u2022\\tDefine the recursive function: We can define a recursive function minCost that takes as input the array of days, the array of costs, the array of pass durations, the current index, and a memoization array dp. The function returns the minimum cost to travel for the remaining days starting from the given index.\\n##### \\u2022\\tHandle the base case: If we have covered all the days, we return 0, since there is no cost to travel on no days.\\n##### \\u2022\\tCheck memoization: If we have already computed the result for the current index, we return the stored value from the memoization array.\\n##### \\u2022\\tTry all three types of passes: We loop through all three types of passes and compute the cost of each pass. For each pass, we add the cost of the pass to the cost of traveling for the remaining days after the pass expires.\\n##### \\u2022\\tFind the index of the next day after the pass expires: We use a loop to find the first day that is after the current day plus the duration of the pass.\\n##### \\u2022\\tCompute the cost for the remaining days: We call the minCost function recursively for the remaining days after the pass expires and add the cost of the pass to the result.\\n##### \\u2022\\tUpdate the minimum cost: We update the minimum cost by taking the minimum of the current minimum cost and the cost computed in step 7.\\n##### \\u2022\\tStore the result in the memoization array: We store the minimum cost computed for the current index in the memoization array.\\n##### \\u2022\\tReturn the minimum cost: We return the minimum cost computed in step 8.\\n##### \\u2022\\tCall the recursive function: In the mincostTickets function, we call the minCost function with the initial index set to 0 and return the result.\\n\\n# ALGO\\n\\n##### \\u2022\\tHere\\'s an explanation of the algorithm used in the mincostTickets function:\\n##### \\u2022\\tDefine the passes: The given problem requires us to find the minimum cost to travel on a set of days. We are given three types of passes: a 1-day pass, a 7-day pass, and a 30-day pass. We can define these passes as an array pass of length 3, where pass[i] represents the duration of the i-th pass.\\n##### \\u2022\\tDefine the recursive function: We can define a recursive function minCost that takes as input the array of days, the array of costs, the array of pass durations, the current index, and a memoization array dp. The function returns the minimum cost to travel for the remaining days starting from the given index.\\n##### \\u2022\\tHandle the base case: If we have covered all the days, we return 0, since there is no cost to travel on no days.\\n##### \\u2022\\tCheck memoization: If we have already computed the result for the current index, we return the stored value from the memoization array.\\n##### \\u2022\\tTry all three types of passes: We loop through all three types of passes and compute the cost of each pass. For each pass, we add the cost of the pass to the cost of traveling for the remaining days after the pass expires.\\n##### \\u2022\\tFind the index of the next day after the pass expires: We use a loop to find the first day that is after the current day plus the duration of the pass.\\n##### \\u2022\\tCompute the cost for the remaining days: We call the minCost function recursively for the remaining days after the pass expires and add the cost of the pass to the result.\\n##### \\u2022\\tUpdate the minimum cost: We update the minimum cost by taking the minimum of the current minimum cost and the cost computed in step 7.\\n##### \\u2022\\tStore the result in the memoization array: We store the minimum cost computed for the current index in the memoization array.\\n##### \\u2022\\tReturn the minimum cost: We return the minimum cost computed in step 8.\\n##### \\u2022\\tCall the recursive function: In the mincostTickets function, we call the minCost function with the initial index set to 0 and return the result.\\n\\n\\n# Code\\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    int n = days.length;\\n    int[] pass = {1, 7, 30};\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, -1);\\n    return minCost(days, costs, pass, 0, dp);\\n}\\n\\npublic int minCost(int[] days, int[] costs, int[] pass, int index, int[] dp) {\\n    // Base case: all days have been covered\\n    if (index == days.length) {\\n        return 0;\\n    }\\n    \\n    // Check if the result is already computed\\n    if (dp[index] != -1) {\\n        return dp[index];\\n    }\\n    \\n    int minCost = Integer.MAX_VALUE;\\n    \\n    // Try all three types of passes\\n    for (int i = 0; i < costs.length; i++) {\\n        int cost = costs[i];\\n        int duration = pass[i];\\n        \\n        // Find the next day after the pass expires\\n        int j = index;\\n        while (j < days.length && days[j] < days[index] + duration) {\\n            j++;\\n        }\\n        \\n        // Compute the cost for the remaining days\\n        int remainingCost = cost + minCost(days, costs, pass, j, dp);\\n        \\n        // Update the minimum cost\\n        minCost = Math.min(minCost, remainingCost);\\n    }\\n    \\n    // Store the result in the memoization array and return it\\n    dp[index] = minCost;\\n    return minCost;\\n}\\n```\\n```c++ []\\nint minCost(vector<int>& days, vector<int>& costs, vector<int>& pass, int index, vector<int>& dp) {\\n    // Base case: all days have been covered\\n    if (index == days.size()) {\\n        return 0;\\n    }\\n    \\n    // Check if the result is already computed\\n    if (dp[index] != -1) {\\n        return dp[index];\\n    }\\n    \\n    int minCost = INT_MAX;\\n    \\n    // Try all three types of passes\\n    for (int i = 0; i < costs.size(); i++) {\\n        int cost = costs[i];\\n        int duration = pass[i];\\n        \\n        // Find the next day after the pass expires\\n        int j = index;\\n        while (j < days.size() && days[j] < days[index] + duration) {\\n            j++;\\n        }\\n        \\n        // Compute the cost for the remaining days\\n        int remainingCost = cost + minCost(days, costs, pass, j, dp);\\n        \\n        // Update the minimum cost\\n        minCost = min(minCost, remainingCost);\\n    }\\n    \\n    // Store the result in the memoization array and return it\\n    dp[index] = minCost;\\n    return minCost;\\n}\\n\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> pass = {1, 7, 30};\\n    vector<int> dp(days.size(), -1);\\n    return minCost(days, costs, pass, 0, dp);\\n}\\n```\\n```python []\\ndef minCost(days, costs, pass_, index, dp):\\n    # Base case: all days have been covered\\n    if index == len(days):\\n        return 0\\n    \\n    # Check if the result is already computed\\n    if dp[index] != -1:\\n        return dp[index]\\n    \\n    minCost = float(\\'inf\\')\\n    \\n    # Try all three types of passes\\n    for i in range(len(costs)):\\n        cost = costs[i]\\n        duration = pass_[i]\\n        \\n        # Find the next day after the pass expires\\n        j = index\\n        while j < len(days) and days[j] < days[index] + duration:\\n            j += 1\\n        \\n        # Compute the cost for the remaining days\\n        remainingCost = cost + minCost(days, costs, pass_, j, dp)\\n        \\n        # Update the minimum cost\\n        minCost = min(minCost, remainingCost)\\n    \\n    # Store the result in the memoization array and return it\\n    dp[index] = minCost\\n    return minCost\\n\\ndef mincostTickets(days, costs):\\n    pass_ = [1, 7, 30]\\n    dp = [-1] * len(days)\\n    return minCost(days, costs, pass_, 0, dp)\\n```\\n# SOLUTION LINK \\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3349791/day-362-flow-chart-java-c-python-explained-intuition-algo-dry-run-proof/\\n\\n\\n# DRY RUN 1\\nHere\\'s a dry run process for this case:\\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\\nOutput: 11\\n##### \\u2022\\tInitialize an array \"dp\" of size n+1 with all elements set to 0. Here, n is the maximum value of days, which is 20 in this case. So, dp will be an array of size 21 with all elements set to 0.\\n##### \\u2022\\tMark the days for which travel is done in the input array \"days\". In this case, the travel is done on days 1, 4, 6, 7, 8, and 20. So, mark the corresponding elements in the \"dp\" array as 1.\\n##### \\u2022\\tNow, for each day from 1 to n, calculate the cost of travel if that day is chosen. To do this, we check if the current day is marked in the \"dp\" array. If it is, we can choose to travel on this day by paying the cost of a one-day pass, which is costs[0] = 2 in this case. If not, we can either choose a 7-day pass or a 30-day pass, depending on which one would be cheaper. To calculate the cost of a 7-day pass, we need to check if we can travel on any of the previous 6 days. If we can, we add the cost of a 7-day pass, which is costs[1] = 7 in this case, to the cost on that day. If not, we can\\'t use a 7-day pass, so we just add the cost of a one-day pass. Similarly, to calculate the cost of a 30-day pass, we need to check if we can travel on any of the previous 29 days. If we can, we add the cost of a 30-day pass, which is costs[2] = 15 in this case, to the cost on that day. If not, we can\\'t use a 30-day pass, so we just add the cost of a one-day pass.\\n##### \\u2022\\tAfter calculating the cost of travel for each day, the final answer is the value of dp[n], which represents the minimum cost of travel for n days.\\n##### \\u2022\\tSo, in this case, the \"dp\" array would look like this after step 2:\\n##### \\u2022\\tdp = [1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]\\n##### \\u2022\\tAnd after step 3, the \"dp\" array would look like this:\\n##### \\u2022\\tdp = [0, 2, 2, 2, 4, 4, 6, 7, 9, 9, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11]\\n##### \\u2022\\tSo the final answer is dp[n] = dp[20] = 11.\\n\\n# DRY RUN 2\\n\\nHere\\'s a dry run process for this case: \\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\\n\\nOutput: 17\\n##### \\u2022\\tInitialize an array \"dp\" of size n+1 with all elements set to 0. Here, n is the maximum value of days, which is 31 in this case. So, dp will be an array of size 32 with all elements set to 0.\\n##### \\u2022\\tMark the days for which travel is done in the input array \"days\". In this case, the travel is done on days 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, and 31. So, mark the corresponding elements in the \"dp\" array as 1.\\n##### \\u2022\\tNow, for each day from 1 to n, calculate the cost of travel if that day is chosen. To do this, we check if the current day is marked in the \"dp\" array. If it is, we can choose to travel on this day by paying the cost of a one-day pass, which is costs[0] = 2 in this case. If not, we can either choose a 7-day pass or a 30-day pass, depending on which one would be cheaper. To calculate the cost of a 7-day pass, we need to check if we can travel on any of the previous 6 days. If we can, we add the cost of a 7-day pass, which is costs[1] = 7 in this case, to the cost on that day. If not, we can\\'t use a 7-day pass, so we just add the cost of a one-day pass. Similarly, to calculate the cost of a 30-day pass, we need to check if we can travel on any of the previous 29 days. If we can, we add the cost of a 30-day pass, which is costs[2] = 15 in this case, to the cost on that day. If not, we can\\'t use a 30-day pass, so we just add the cost of a one-day pass.\\n##### \\u2022\\tAfter calculating the cost of travel for each day, the final answer is the value of dp[n], which represents the minimum cost of travel for n days.\\n##### \\u2022\\tSo, in this case, the \"dp\" array would look like this after step 2:\\n##### \\u2022\\tdp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]\\n##### \\u2022\\tAnd after step 3, the \"dp\" array would look like this:\\n##### \\u2022\\tdp = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 18, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 17]\\n##### \\u2022\\tSo the final answer is dp[n] = dp[31] = 17.\\n\\nhere\\'s a brute force solution to the \"Minimum Cost For Tickets\" problem:\\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    return minCost(days, costs, 0);\\n}\\n\\nprivate int minCost(int[] days, int[] costs, int i) {\\n    if (i == days.length) {\\n        return 0;\\n    }\\n    int cost1 = costs[0] + minCost(days, costs, i + 1);\\n    int j = i;\\n    while (j < days.length && days[j] < days[i] + 7) {\\n        j++;\\n    }\\n    int cost2 = costs[1] + minCost(days, costs, j);\\n    j = i;\\n    while (j < days.length && days[j] < days[i] + 30) {\\n        j++;\\n    }\\n    int cost3 = costs[2] + minCost(days, costs, j);\\n    return Math.min(cost1, Math.min(cost2, cost3));\\n}\\n```\\n\\n# 5th way \\n\\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> daypasses({1, 7, 30});\\n        vector<int> dp(days.size());\\n\\n        for (int i = 0; i < days.size(); i++) {\\n            int date = days[i];\\n            int mincost = INT_MAX;\\n\\n            for (int j = 0; j < costs.size(); j++) {\\n                int daypass = daypasses[j];\\n                int cost = costs[j];\\n\\n                int preidx = getEqualOrSmaller(days, i - 1, date - daypass);\\n                int precost = 0;\\n\\n                if (preidx >= 0) {\\n                    precost = dp[preidx];\\n                }\\n\\n                mincost = min(mincost, precost + cost);\\n            }\\n\\n            dp[i] = mincost;\\n        }\\n\\n        return dp.back();\\n    }\\n\\n    int getEqualOrSmaller(vector<int>& days, int r, int target) {\\n        int l = 0;\\n        int idx = -1;\\n\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n\\n            if (days[m] == target) {\\n                return m;\\n            }\\n\\n            if (days[m] < target) {\\n                idx = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n\\n        return idx;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length];\\n        int[] durations = new int[]{1, 7, 30};\\n\\n        for (int i = 0; i < days.length; i++) {\\n            int minCost = Integer.MAX_VALUE;\\n            int curDay = days[i];\\n\\n            for (int j = 0; j < costs.length; j++) {\\n                int duration = durations[j];\\n                int cost = costs[j];\\n\\n                int prevIdx = getPrevDayIdx(days, i - 1, curDay - duration);\\n                int prevCost = prevIdx >= 0 ? dp[prevIdx] : 0;\\n\\n                minCost = Math.min(minCost, prevCost + cost);\\n            }\\n\\n            dp[i] = minCost;\\n        }\\n\\n        return dp[dp.length - 1];\\n    }\\n\\n    private int getPrevDayIdx(int[] days, int r, int target) {\\n        int l = 0;\\n        int idx = -1;\\n\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n\\n            if (days[m] == target) {\\n                return m;\\n            }\\n\\n            if (days[m] < target) {\\n                idx = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n\\n        return idx;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * len(days)\\n        durations = [1, 7, 30]\\n\\n        for i in range(len(days)):\\n            minCost = float(\\'inf\\')\\n            curDay = days[i]\\n\\n            for j in range(len(costs)):\\n                duration = durations[j]\\n                cost = costs[j]\\n\\n                prevIdx = self.getPrevDayIdx(days, i - 1, curDay - duration)\\n                prevCost = dp[prevIdx] if prevIdx >= 0 else 0\\n\\n                minCost = min(minCost, prevCost + cost)\\n\\n            dp[i] = minCost\\n\\n        return dp[-1]\\n\\n    def getPrevDayIdx(self, days: List[int], r: int, target: int) -> int:\\n        l = 0\\n        idx = -1\\n\\n        while l <= r:\\n            m = l + (r - l) // 2\\n\\n            if days[m] == target:\\n                return m\\n\\n            if days[m] < target:\\n                idx = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n\\n        return idx\\n```\\n##### \\u2022\\tThe mincostTickets function initializes the DP array and iterates through each travel day. For each travel day, it tries all three types of passes and computes the minimum cost for the current travel day using the minimum cost for the previous travel day covered by the pass. It then stores the minimum cost for the current travel day in the DP array.\\n\\n##### \\u2022\\tThe getEqualOrSmaller function takes the days array, the right index r, and the target date as input. It returns the index of the travel day that is equal to or smaller than the target date.\\n\\n##### \\u2022\\tThis solution has a time complexity of O(n log n), where n is the number of days in the travel period, due to the binary search in the getEqualOrSmaller function, and a space complexity of O(n) due to the DP array.\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/eedef461-f538-49dd-9482-120de09d46a0_1679981620.0901728.webp)\\n\\n\\n# DAY 362 proof \\n![image.png](https://assets.leetcode.com/users/images/feb1231c-bc05-4c02-b655-de8bf43fcc70_1680004379.571364.png)\\n\\n\\n![meme2.png](https://assets.leetcode.com/users/images/b8fdddf4-5dc7-4b8a-a812-e35d0990d580_1679970322.2557046.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```JAVA []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.length - 1];\\n    \\n    // Initialize the DP array and mark the travel days\\n    int[] dp = new int[maxDay + 1];\\n    boolean[] isTravelDay = new boolean[maxDay + 1];\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n    \\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n    \\n    // Compute the minimum cost for each day from 1 to maxDay\\n    for (int i = 1; i <= maxDay; i++) {\\n        if (!isTravelDay[i]) {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        } else {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[i - 1] + oneDayPassCost;\\n            int cost2 = dp[Math.max(0, i - 7)] + sevenDayPassCost;\\n            int cost3 = dp[Math.max(0, i - 30)] + thirtyDayPassCost;\\n            dp[i] = Math.min(cost1, Math.min(cost2, cost3));\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period\\n    return dp[maxDay];\\n}\\n```\n```C++ []\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.size() - 1];\\n    \\n    // Initialize the DP array and mark the travel days\\n    vector<int> dp(maxDay + 1);\\n    vector<bool> isTravelDay(maxDay + 1);\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n    \\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n    \\n    // Compute the minimum cost for each day from 1 to maxDay\\n    for (int i = 1; i <= maxDay; i++) {\\n        if (!isTravelDay[i]) {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        } else {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[i - 1] + oneDayPassCost;\\n            int cost2 = dp[max(0, i - 7)] + sevenDayPassCost;\\n            int cost3 = dp[max(0, i - 30)] + thirtyDayPassCost;\\n            dp[i] = min(cost1, min(cost2, cost3));\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period\\n    return dp[maxDay];\\n}\\n```\n```PYTHON []\\ndef mincostTickets(days: List[int], costs: List[int]) -> int:\\n    # Get the maximum day in the travel period\\n    maxDay = days[-1]\\n    \\n    # Initialize the DP array and mark the travel days\\n    dp = [0] * (maxDay + 1)\\n    isTravelDay = [False] * (maxDay + 1)\\n    for day in days:\\n        isTravelDay[day] = True\\n    \\n    # Initialize the costs of different types of passes\\n    oneDayPassCost = costs[0]\\n    sevenDayPassCost = costs[1]\\n    thirtyDayPassCost = costs[2]\\n    \\n    # Compute the minimum cost for each day from 1 to maxDay\\n    for i in range(1, maxDay + 1):\\n        if not isTravelDay[i]:\\n            # If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1]\\n        else:\\n            # If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            cost1 = dp[i - 1] + oneDayPassCost\\n            cost2 = dp[max(0, i - 7)] + sevenDayPassCost\\n            cost3 = dp[max(0, i - 30)] + thirtyDayPassCost\\n            dp[i] = min(cost1, cost2, cost3)\\n    \\n    # Return the minimum cost for the entire travel period\\n    return dp[maxDay]\\n```\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.length - 1];\\n\\n    // Initialize the DP array and mark the travel days\\n    int[] dp = new int[maxDay + 1];\\n    boolean[] isTravelDay = new boolean[maxDay + 1];\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n\\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n\\n    // Compute the minimum cost for each day from 1 to maxDay\\n    return minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay);\\n}\\n\\nprivate int minCost(int[] days, int[] costs, int[] dp, boolean[] isTravelDay, int oneDayPassCost, int sevenDayPassCost, int thirtyDayPassCost, int day, int maxDay) {\\n    if (day > maxDay) {\\n        return 0;\\n    }\\n    if (dp[day] != 0) {\\n        return dp[day];\\n    }\\n    if (!isTravelDay[day]) {\\n        dp[day] = minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n    } else {\\n        int cost1 = oneDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n        int cost2 = sevenDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 7), maxDay);\\n        int cost3 = thirtyDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 30), maxDay);\\n        dp[day] = Math.min(cost1, Math.min(cost2, cost3));\\n    }\\n    return dp[day];\\n}\\n\\nprivate int findNextTravelDay(int[] days, int day, int duration) {\\n    int i = 0;\\n    while (i < days.length && days[i] < day + duration) {\\n        i++;\\n    }\\n    return i < days.length ? days[i] : days[days.length - 1] + 1;\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int maxDay = days[days.size() - 1];\\n        vector<int> dp(maxDay + 1);\\n        vector<bool> isTravelDay(maxDay + 1);\\n        for (int day : days) {\\n            isTravelDay[day] = true;\\n        }\\n        int oneDayPassCost = costs[0];\\n        int sevenDayPassCost = costs[1];\\n        int thirtyDayPassCost = costs[2];\\n        return minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay);\\n    }\\n\\n    int minCost(vector<int>& days, vector<int>& costs, vector<int>& dp, vector<bool>& isTravelDay, int oneDayPassCost, int sevenDayPassCost, int thirtyDayPassCost, int day, int maxDay) {\\n        if (day > maxDay) {\\n            return 0;\\n        }\\n        if (dp[day] != 0) {\\n            return dp[day];\\n        }\\n        if (!isTravelDay[day]) {\\n            dp[day] = minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n        } else {\\n            int cost1 = oneDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n            int cost2 = sevenDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 7), maxDay);\\n            int cost3 = thirtyDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 30), maxDay);\\n            dp[day] = min(cost1, min(cost2, cost3));\\n        }\\n        return dp[day];\\n    }\\n\\n    int findNextTravelDay(vector<int>& days, int day, int duration) {\\n        int i = 0;\\n        while (i < days.size() && days[i] < day + duration) {\\n            i++;\\n        }\\n        return i < days.size() ? days[i] : days[days.size() - 1] + 1;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        maxDay = days[-1]\\n        dp = [0] * (maxDay + 1)\\n        isTravelDay = [False] * (maxDay + 1)\\n        for day in days:\\n            isTravelDay[day] = True\\n        oneDayPassCost = costs[0]\\n        sevenDayPassCost = costs[1]\\n        thirtyDayPassCost = costs[2]\\n        return self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay)\\n\\n    def minCost(self, days: List[int], costs: List[int], dp: List[int], isTravelDay: List[bool], oneDayPassCost: int, sevenDayPassCost: int, thirtyDayPassCost: int, day: int, maxDay: int) -> int:\\n        if day > maxDay:\\n            return 0\\n        if dp[day] != 0:\\n            return dp[day]\\n        if not isTravelDay[day]:\\n            dp[day] = self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay)\\n        else:\\n            cost1 = oneDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay)\\n            cost2 = sevenDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, self.findNextTravelDay(days, day, 7), maxDay)\\n            cost3 = thirtyDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, self.findNextTravelDay(days, day, 30), maxDay)\\n            dp[day] = min(cost1, min(cost2, cost3))\\n```\n```PYTHON []\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n    # Initialize the DP array with all 0s\\n    dp = [0] * (days[-1] + 1)\\n    \\n    # Convert the list of travel days into a set for faster lookups\\n    travel_days = set(days)\\n    \\n    # Compute the minimum cost for each day from 1 to the maximum day\\n    for i in range(1, len(dp)):\\n        if i in travel_days:\\n            # If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            cost1 = dp[max(i - 1, 0)] + costs[0]\\n            cost2 = dp[max(i - 7, 0)] + costs[1]\\n            cost3 = dp[max(i - 30, 0)] + costs[2]\\n            dp[i] = min(cost1, cost2, cost3)\\n        else:\\n            # If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1]\\n    \\n    # Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp[-1]\\n```\n```JAVA []\\npublic int mincostTickets(int[] days, int[] costs) { // Initialize the DP array with all 0s \\nint[] dp = new int[days[days.length - 1] + 1];\\n\\n    // Convert the list of travel days into a set for faster lookups\\n    Set<Integer> travelDays = new HashSet<>();\\n    for (int day : days) {\\n        travelDays.add(day);\\n    }\\n    \\n    // Compute the minimum cost for each day from 1 to the maximum day\\n    for (int i = 1; i < dp.length; i++) {\\n        if (travelDays.contains(i)) {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[Math.max(i - 1, 0)] + costs[0];\\n            int cost2 = dp[Math.max(i - 7, 0)] + costs[1];\\n            int cost3 = dp[Math.max(i - 30, 0)] + costs[2];\\n            dp[i] = Math.min(cost1, Math.min(cost2, cost3));\\n        } else {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp[dp.length - 1];\\n}\\n```\n```C++ []\\nint mincostTickets(vector<int>& days, vector<int>& costs) { // Initialize the DP array with all 0s \\n    vector dp(days.back() + 1, 0);\\n\\n    // Convert the list of travel days into a set for faster lookups\\n    unordered_set<int> travel_days(days.begin(), days.end());\\n    \\n    // Compute the minimum cost for each day from 1 to the maximum day\\n    for (int i = 1; i < dp.size(); i++) {\\n        if (travel_days.count(i)) {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[max(i - 1, 0)] + costs[0];\\n            int cost2 = dp[max(i - 7, 0)] + costs[1];\\n            int cost3 = dp[max(i - 30, 0)] + costs[2];\\n            dp[i] = min(cost1, min(cost2, cost3));\\n        } else {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp.back();\\n}\\n```\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    int n = days.length;\\n    int[] pass = {1, 7, 30};\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, -1);\\n    return minCost(days, costs, pass, 0, dp);\\n}\\n\\npublic int minCost(int[] days, int[] costs, int[] pass, int index, int[] dp) {\\n    // Base case: all days have been covered\\n    if (index == days.length) {\\n        return 0;\\n    }\\n    \\n    // Check if the result is already computed\\n    if (dp[index] != -1) {\\n        return dp[index];\\n    }\\n    \\n    int minCost = Integer.MAX_VALUE;\\n    \\n    // Try all three types of passes\\n    for (int i = 0; i < costs.length; i++) {\\n        int cost = costs[i];\\n        int duration = pass[i];\\n        \\n        // Find the next day after the pass expires\\n        int j = index;\\n        while (j < days.length && days[j] < days[index] + duration) {\\n            j++;\\n        }\\n        \\n        // Compute the cost for the remaining days\\n        int remainingCost = cost + minCost(days, costs, pass, j, dp);\\n        \\n        // Update the minimum cost\\n        minCost = Math.min(minCost, remainingCost);\\n    }\\n    \\n    // Store the result in the memoization array and return it\\n    dp[index] = minCost;\\n    return minCost;\\n}\\n```\n```c++ []\\nint minCost(vector<int>& days, vector<int>& costs, vector<int>& pass, int index, vector<int>& dp) {\\n    // Base case: all days have been covered\\n    if (index == days.size()) {\\n        return 0;\\n    }\\n    \\n    // Check if the result is already computed\\n    if (dp[index] != -1) {\\n        return dp[index];\\n    }\\n    \\n    int minCost = INT_MAX;\\n    \\n    // Try all three types of passes\\n    for (int i = 0; i < costs.size(); i++) {\\n        int cost = costs[i];\\n        int duration = pass[i];\\n        \\n        // Find the next day after the pass expires\\n        int j = index;\\n        while (j < days.size() && days[j] < days[index] + duration) {\\n            j++;\\n        }\\n        \\n        // Compute the cost for the remaining days\\n        int remainingCost = cost + minCost(days, costs, pass, j, dp);\\n        \\n        // Update the minimum cost\\n        minCost = min(minCost, remainingCost);\\n    }\\n    \\n    // Store the result in the memoization array and return it\\n    dp[index] = minCost;\\n    return minCost;\\n}\\n\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> pass = {1, 7, 30};\\n    vector<int> dp(days.size(), -1);\\n    return minCost(days, costs, pass, 0, dp);\\n}\\n```\n```python []\\ndef minCost(days, costs, pass_, index, dp):\\n    # Base case: all days have been covered\\n    if index == len(days):\\n        return 0\\n    \\n    # Check if the result is already computed\\n    if dp[index] != -1:\\n        return dp[index]\\n    \\n    minCost = float(\\'inf\\')\\n    \\n    # Try all three types of passes\\n    for i in range(len(costs)):\\n        cost = costs[i]\\n        duration = pass_[i]\\n        \\n        # Find the next day after the pass expires\\n        j = index\\n        while j < len(days) and days[j] < days[index] + duration:\\n            j += 1\\n        \\n        # Compute the cost for the remaining days\\n        remainingCost = cost + minCost(days, costs, pass_, j, dp)\\n        \\n        # Update the minimum cost\\n        minCost = min(minCost, remainingCost)\\n    \\n    # Store the result in the memoization array and return it\\n    dp[index] = minCost\\n    return minCost\\n\\ndef mincostTickets(days, costs):\\n    pass_ = [1, 7, 30]\\n    dp = [-1] * len(days)\\n    return minCost(days, costs, pass_, 0, dp)\\n```\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    return minCost(days, costs, 0);\\n}\\n\\nprivate int minCost(int[] days, int[] costs, int i) {\\n    if (i == days.length) {\\n        return 0;\\n    }\\n    int cost1 = costs[0] + minCost(days, costs, i + 1);\\n    int j = i;\\n    while (j < days.length && days[j] < days[i] + 7) {\\n        j++;\\n    }\\n    int cost2 = costs[1] + minCost(days, costs, j);\\n    j = i;\\n    while (j < days.length && days[j] < days[i] + 30) {\\n        j++;\\n    }\\n    int cost3 = costs[2] + minCost(days, costs, j);\\n    return Math.min(cost1, Math.min(cost2, cost3));\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> daypasses({1, 7, 30});\\n        vector<int> dp(days.size());\\n\\n        for (int i = 0; i < days.size(); i++) {\\n            int date = days[i];\\n            int mincost = INT_MAX;\\n\\n            for (int j = 0; j < costs.size(); j++) {\\n                int daypass = daypasses[j];\\n                int cost = costs[j];\\n\\n                int preidx = getEqualOrSmaller(days, i - 1, date - daypass);\\n                int precost = 0;\\n\\n                if (preidx >= 0) {\\n                    precost = dp[preidx];\\n                }\\n\\n                mincost = min(mincost, precost + cost);\\n            }\\n\\n            dp[i] = mincost;\\n        }\\n\\n        return dp.back();\\n    }\\n\\n    int getEqualOrSmaller(vector<int>& days, int r, int target) {\\n        int l = 0;\\n        int idx = -1;\\n\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n\\n            if (days[m] == target) {\\n                return m;\\n            }\\n\\n            if (days[m] < target) {\\n                idx = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n\\n        return idx;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length];\\n        int[] durations = new int[]{1, 7, 30};\\n\\n        for (int i = 0; i < days.length; i++) {\\n            int minCost = Integer.MAX_VALUE;\\n            int curDay = days[i];\\n\\n            for (int j = 0; j < costs.length; j++) {\\n                int duration = durations[j];\\n                int cost = costs[j];\\n\\n                int prevIdx = getPrevDayIdx(days, i - 1, curDay - duration);\\n                int prevCost = prevIdx >= 0 ? dp[prevIdx] : 0;\\n\\n                minCost = Math.min(minCost, prevCost + cost);\\n            }\\n\\n            dp[i] = minCost;\\n        }\\n\\n        return dp[dp.length - 1];\\n    }\\n\\n    private int getPrevDayIdx(int[] days, int r, int target) {\\n        int l = 0;\\n        int idx = -1;\\n\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n\\n            if (days[m] == target) {\\n                return m;\\n            }\\n\\n            if (days[m] < target) {\\n                idx = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n\\n        return idx;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * len(days)\\n        durations = [1, 7, 30]\\n\\n        for i in range(len(days)):\\n            minCost = float(\\'inf\\')\\n            curDay = days[i]\\n\\n            for j in range(len(costs)):\\n                duration = durations[j]\\n                cost = costs[j]\\n\\n                prevIdx = self.getPrevDayIdx(days, i - 1, curDay - duration)\\n                prevCost = dp[prevIdx] if prevIdx >= 0 else 0\\n\\n                minCost = min(minCost, prevCost + cost)\\n\\n            dp[i] = minCost\\n\\n        return dp[-1]\\n\\n    def getPrevDayIdx(self, days: List[int], r: int, target: int) -> int:\\n        l = 0\\n        idx = -1\\n\\n        while l <= r:\\n            m = l + (r - l) // 2\\n\\n            if days[m] == target:\\n                return m\\n\\n            if days[m] < target:\\n                idx = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n\\n        return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345641,
                "title": "dp-solution-as-striver-taught-beginner-friendly",
                "content": "# Beginner friendly solution\\n**ya you can optimise it more but it is just for understanding the core concept of picking and not_picking **\\n```\\nclass Solution {\\npublic:\\n   int helper(int ind  , vector<int>&costs , unordered_set<int>&days,vector<int>&dp )\\n {\\n    if(ind> 365)\\n    {\\n        return 0;\\n    }\\n    if(dp[ind]!=-1)\\n    {\\n        return dp[ind];\\n    }\\n       //Well if the day is not present we will not be tarvelling\\n\\t   //so this is not_pick condition\\n    if(days.find(ind) == days.end()) \\n    {\\n       return helper(ind+1  ,costs ,days,dp );\\n    }\\n  //if the day is present then we will pick and add the cost\\n    int day1 = costs[0] + helper(ind+1  , costs , days ,dp);\\n    int day7 = costs[1] + helper(ind+7  , costs , days ,dp);\\n    int day30 = costs[2] + helper(ind+30  , costs , days,dp );\\n\\n    return dp[ind] = min(day1 ,min (day7 , day30));\\n }\\n int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        unordered_set<int>temp;\\n        vector<int>dp(366,-1);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n           temp.insert(days[i]);\\n        }\\n\\n       return helper(days[0]  ,costs,temp,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int helper(int ind  , vector<int>&costs , unordered_set<int>&days,vector<int>&dp )\\n {\\n    if(ind> 365)\\n    {\\n        return 0;\\n    }\\n    if(dp[ind]!=-1)\\n    {\\n        return dp[ind];\\n    }\\n       //Well if the day is not present we will not be tarvelling\\n\\t   //so this is not_pick condition\\n    if(days.find(ind) == days.end()) \\n    {\\n       return helper(ind+1  ,costs ,days,dp );\\n    }\\n  //if the day is present then we will pick and add the cost\\n    int day1 = costs[0] + helper(ind+1  , costs , days ,dp);\\n    int day7 = costs[1] + helper(ind+7  , costs , days ,dp);\\n    int day30 = costs[2] + helper(ind+30  , costs , days,dp );\\n\\n    return dp[ind] = min(day1 ,min (day7 , day30));\\n }\\n int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        unordered_set<int>temp;\\n        vector<int>dp(366,-1);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n           temp.insert(days[i]);\\n        }\\n\\n       return helper(days[0]  ,costs,temp,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815165,
                "title": "video-explanation-minimum-cost-for-tickets-leetcode-recursive-to-memoization-c",
                "content": "*Please let me know if I need to improve anything.*\\n\\n[FaxMachine Codes](https://www.youtube.com/watch?v=374z8uiGAsM&t=139s)\\n\\n**Recursive Approach (gives TLE)**\\n\\n```\\npublic class Solution {\\n    int[] daysTravel;\\n    \\n    public Solution() {\\n        daysTravel = new int[]{1, 7, 30};\\n    }\\n    \\n    public int MincostTickets(int[] days, int[] costs) {\\n        return MincostTicketsUtil(days, costs, 0, 0);\\n    }\\n    \\n    private int MincostTicketsUtil(int[] days, int[] costs, int index, int day) {\\n        if(index >= days.Length)\\n            return 0;\\n        \\n        if(days[index] < day) {\\n            return MincostTicketsUtil(days, costs, index + 1, day);\\n        }\\n        \\n        int cost = int.MaxValue;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            cost = Math.Min(cost, costs[i] + MincostTicketsUtil(days, costs, index + 1,\\n                                                                days[index] + daysTravel[i]));\\n        }\\n        \\n        return cost;\\n    }\\n}\\n```\\n\\n**Memoization**\\n\\n```\\npublic class Solution {\\n    int[] daysTravel;\\n    int[] dp;\\n    \\n    public int MincostTickets(int[] days, int[] costs) {\\n        daysTravel = new int[]{1, 7, 30};\\n        dp = new int[days.Length];\\n        Array.Fill(dp, -1);\\n        return MincostTicketsUtil(days, costs, 0, 0);\\n    }\\n    \\n    private int MincostTicketsUtil(int[] days, int[] costs, int index, int day) {\\n        if(index >= days.Length)\\n            return 0;\\n        \\n        if(index > 0 && days[index] < day) {\\n            return MincostTicketsUtil(days, costs, index + 1, day);\\n        }\\n        \\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        int cost = int.MaxValue;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            cost = Math.Min(cost, costs[i] + MincostTicketsUtil(days, costs, index + 1,\\n                                                                days[index] + daysTravel[i]));\\n        }\\n        \\n        dp[index] = cost;\\n        \\n        return dp[index];\\n    }\\n}\\n```\\n\\n*Please Like, Subscribe and Upvote this solution if you liked it.*",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    int[] daysTravel;\\n    \\n    public Solution() {\\n        daysTravel = new int[]{1, 7, 30};\\n    }\\n    \\n    public int MincostTickets(int[] days, int[] costs) {\\n        return MincostTicketsUtil(days, costs, 0, 0);\\n    }\\n    \\n    private int MincostTicketsUtil(int[] days, int[] costs, int index, int day) {\\n        if(index >= days.Length)\\n            return 0;\\n        \\n        if(days[index] < day) {\\n            return MincostTicketsUtil(days, costs, index + 1, day);\\n        }\\n        \\n        int cost = int.MaxValue;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            cost = Math.Min(cost, costs[i] + MincostTicketsUtil(days, costs, index + 1,\\n                                                                days[index] + daysTravel[i]));\\n        }\\n        \\n        return cost;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    int[] daysTravel;\\n    int[] dp;\\n    \\n    public int MincostTickets(int[] days, int[] costs) {\\n        daysTravel = new int[]{1, 7, 30};\\n        dp = new int[days.Length];\\n        Array.Fill(dp, -1);\\n        return MincostTicketsUtil(days, costs, 0, 0);\\n    }\\n    \\n    private int MincostTicketsUtil(int[] days, int[] costs, int index, int day) {\\n        if(index >= days.Length)\\n            return 0;\\n        \\n        if(index > 0 && days[index] < day) {\\n            return MincostTicketsUtil(days, costs, index + 1, day);\\n        }\\n        \\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        int cost = int.MaxValue;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            cost = Math.Min(cost, costs[i] + MincostTicketsUtil(days, costs, index + 1,\\n                                                                days[index] + daysTravel[i]));\\n        }\\n        \\n        dp[index] = cost;\\n        \\n        return dp[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354591,
                "title": "c-solution",
                "content": "```\\npublic static int MincostTickets(int[] days, int[] costs)\\n        {\\n            var set = new HashSet<int>(days);\\n            int[] dp = new int[366];\\n            for (int i = 1; i < dp.Length; i++)\\n                if (!set.Contains(i))\\n                    dp[i] = dp[i - 1];\\n                else dp[i] = Math.Min(dp[i - 1] + costs[0], Math.Min(dp[Math.Max(0, i - 7)] + costs[1], dp[Math.Max(0, i - 30)] + costs[2]));\\n\\n            return dp[365];\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int MincostTickets(int[] days, int[] costs)\\n        {\\n            var set = new HashSet<int>(days);\\n            int[] dp = new int[366];\\n            for (int i = 1; i < dp.Length; i++)\\n                if (!set.Contains(i))\\n                    dp[i] = dp[i - 1];\\n                else dp[i] = Math.Min(dp[i - 1] + costs[0], Math.Min(dp[Math.Max(0, i - 7)] + costs[1], dp[Math.Max(0, i - 30)] + costs[2]));\\n\\n            return dp[365];\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226704,
                "title": "java-o-nlogn-dp-solution-and-recursion-memorization-solution",
                "content": "```\\n//DP\\n//DP[i] is the minimum cost to complete the trip for the first i entris in days array...\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) return 0;\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            int res = dp[i] + costs[0]; //previous cost + today\\'s cost...\\n            \\n            //find the left most index that is larger than days[i] - 7..\\n            //calculate the cost by using prev cost + one-week cost...\\n            int index7 = binarySearch(days, i, days[i] - 7);\\n            res = Math.min(res, dp[index7] + costs[1]);\\n            \\n            //find the left most index that is larger than days[i] - 30..\\n            //calculate the cost by using prev cost + one-month cost...\\n            int index30 = binarySearch(days, i, days[i] - 30);\\n            res = Math.min(res, dp[index30] + costs[2]);\\n            dp[i + 1] = res;\\n        }\\n        return dp[n];\\n    }\\n    \\n    private int binarySearch(int[] days, int i, int target) {\\n        int lo = 0, hi = i;\\n        while (lo  < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (days[mid] > target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n\\n\\n\\n//recursion + memorization...\\nclass Solution {\\n    Integer[] memo;\\n    //memo[i] is the minimum cost from days[i] to days[days.length - 1];\\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) return 0;\\n        int n = days.length;\\n        memo = new Integer[n];      \\n        return minCost(days, costs, 0);\\n    }\\n    \\n    private int minCost(int[] days, int[] costs, int lo) {\\n        int n = days.length;\\n        if (lo >= n) return 0;\\n        if (memo[lo] != null) return memo[lo];\\n        int res = costs[0] + minCost(days, costs, lo + 1);\\n        \\n        //use binary search to find the right most index that has days[i] < days[lo] + 7...\\n        int index7 = binarySearch(days, lo, days[lo] + 7);\\n        res = Math.min(res, costs[1] + minCost(days, costs, index7 + 1));\\n        \\n        //use binary search to find the right most index that has days[i] <= days[lo] + 30...\\n        int index30 = binarySearch(days, lo, days[lo] + 30);\\n        res = Math.min(res, costs[2] + minCost(days, costs, index30 + 1));\\n        \\n        memo[lo] = res;\\n        return res;\\n    }\\n    \\n    private int binarySearch(int[] days, int lo, int target) {\\n        int hi = days.length - 1;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo + 1) / 2;\\n            if (days[mid] < target) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) return 0;\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            int res = dp[i] + costs[0]; //previous cost + today\\'s cost...\\n            \\n            //find the left most index that is larger than days[i] - 7..\\n            //calculate the cost by using prev cost + one-week cost...\\n            int index7 = binarySearch(days, i, days[i] - 7);\\n            res = Math.min(res, dp[index7] + costs[1]);\\n            \\n            //find the left most index that is larger than days[i] - 30..\\n            //calculate the cost by using prev cost + one-month cost...\\n            int index30 = binarySearch(days, i, days[i] - 30);\\n            res = Math.min(res, dp[index30] + costs[2]);\\n            dp[i + 1] = res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 811064,
                "title": "simple-dp-solution-in-python3",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mincostTickets(self, days: List[int], cost: List[int]) -> int:\\n        last = days[-1]\\n        dp = [0 for i in range(last + 1)]\\n        traveldays = Counter(days)\\n        \\n        for i in range(last + 1):\\n            if i not in traveldays:\\n                dp[i] = dp[i-1]\\n            else:\\n                one = dp[max(0, i - 1)] + cost[0]\\n                seven = dp[max(0, i - 7)] + cost[1]\\n                thirty = dp[max(0, i - 30)] + cost[2]\\n                dp[i] = min(one, seven, thirty)\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mincostTickets(self, days: List[int], cost: List[int]) -> int:\\n        last = days[-1]\\n        dp = [0 for i in range(last + 1)]\\n        traveldays = Counter(days)\\n        \\n        for i in range(last + 1):\\n            if i not in traveldays:\\n                dp[i] = dp[i-1]\\n            else:\\n                one = dp[max(0, i - 1)] + cost[0]\\n                seven = dp[max(0, i - 7)] + cost[1]\\n                thirty = dp[max(0, i - 30)] + cost[2]\\n                dp[i] = min(one, seven, thirty)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418307,
                "title": "c-recursive-solution",
                "content": "*we only buy ticket on travelling day*\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool s[366];\\n    int memo[366];\\n    \\n\\n    int dp(vector<int> &days, vector<int> &costs,int i=0)\\n    {\\n        if(i>365)  return 0;\\n        \\n        if (memo[i]!=-1)  return memo[i];\\n        int ans1,ans2,ans3;\\n        \\n        //if  not a travelling day we skip until the next travelling day\\n        if(s[i]==0)\\n        {\\n            return (memo[i]=dp(days,costs,i+1));\\n        }\\n        else\\n        {\\n            // on travelling day we can take 3  types of passes\\n           \\n            ans1=costs[0]+dp(days,costs,i+1);\\n            ans2=costs[1]+dp(days,costs,i+7);\\n            ans3=costs[2]+dp(days,costs,i+30);\\n        }\\n        \\n        return (memo[i]=min(ans1,min(ans2,ans3)));\\n        \\n\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        memset(s,0,sizeof(s));\\n        memset(memo,-1,sizeof(memo));\\n        for(auto x:days) s[x]=true;\\n        return dp(days,costs,0);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool s[366];\\n    int memo[366];\\n    \\n\\n    int dp(vector<int> &days, vector<int> &costs,int i=0)\\n    {\\n        if(i>365)  return 0;\\n        \\n        if (memo[i]!=-1)  return memo[i];\\n        int ans1,ans2,ans3;\\n        \\n        //if  not a travelling day we skip until the next travelling day\\n        if(s[i]==0)\\n        {\\n            return (memo[i]=dp(days,costs,i+1));\\n        }\\n        else\\n        {\\n            // on travelling day we can take 3  types of passes\\n           \\n            ans1=costs[0]+dp(days,costs,i+1);\\n            ans2=costs[1]+dp(days,costs,i+7);\\n            ans3=costs[2]+dp(days,costs,i+30);\\n        }\\n        \\n        return (memo[i]=min(ans1,min(ans2,ans3)));\\n        \\n\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        memset(s,0,sizeof(s));\\n        memset(memo,-1,sizeof(memo));\\n        for(auto x:days) s[x]=true;\\n        return dp(days,costs,0);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226657,
                "title": "short-python-recursive-dp",
                "content": "The idea is to test all possible ways of taking the tickets to cover the current day, and recurse on the remaining.\\nWe use a cache, to make it DP, to store intermediate results.\\n\\nOne of the important things to understand is what cache[i] means.\\n\\nCache[i]: Means, the total min. Cost to cover days starting from i. and assuming i is not covered.\\n\\nSo, if i is already covered, then i simply move on to recursing next.\\n\\n\\n```\\ndef mincost(i, covered_until):\\n\\tif i >= len(days): return 0\\n\\tif days[i] <= covered_until: return mincost(i+1, covered_until)\\n\\tif i in cache: return cache[i]\\n\\tres = min(costs[0] + mincost(i + 1, days[i]), costs[1] + mincost(i + 1, days[i]+6), costs[2] + mincost(i + 1, days[i]+29))\\n\\tcache[i] = res\\n\\treturn cache[i]\\ncache = {}\\nreturn mincost(0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef mincost(i, covered_until):\\n\\tif i >= len(days): return 0\\n\\tif days[i] <= covered_until: return mincost(i+1, covered_until)\\n\\tif i in cache: return cache[i]\\n\\tres = min(costs[0] + mincost(i + 1, days[i]), costs[1] + mincost(i + 1, days[i]+6), costs[2] + mincost(i + 1, days[i]+29))\\n\\tcache[i] = res\\n\\treturn cache[i]\\ncache = {}\\nreturn mincost(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3411957,
                "title": "c-bottom-up-approach-beats-100-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOkay, we are first of all we are creating the dp array to store our previous calculation, and initializating ```dp[n]``` with 0 we will talk about that latter.\\n\\nAlso we have to supporting methods ```skipWeek``` and ```skipMonth``` this methods trying to find day after our 7-day pass and 30-day pass. \\nIn ```skipWeek``` we returning first day that are larger than ```days[index] + 6``` (this day and six next days) or ```days.size()```, that mean in ```days``` there are no \"travel\" days after end of 7-day pass from ```days[index]```  to ```days[index] + 6```.\\n```skipMonth``` works same as ```skipWeek``` but now we are trying to find next \"travel\" day after end of 30-day pass.\\n\\n\\nAfter initializating all, we run loop from ```n-1``` to ```0``` at each iteration we are trying to get how much money we spent earlier. \\n```costIfTakeDay``` - amount of money spent earlier plus ```cost[0]``` . That means how much we spent earlier and if for this day we will take 1-day ticket.\\n```costIfTakeWeek``` - amount of money spent earlier plus ```cost[1]```. That means how much we spent earlier and if for this day we will take 7-day ticket. If there are no days before function ```skipWeek``` will return ```days.size()```, but we already initialized ```dp[days.size()] = 0;``` and the cost of travel from ```days[index]``` will cost like a 7-day pass\\n```costIfTakeMonth``` - - amount of money spent earlier plus ```cost[2]```. Means same as ```costIfTakeWeek``` but calls  ```skipMonth``` function.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int> &days, vector<int> &costs) {\\n        int n = days.size();\\n        auto dp = std::vector<::uint16_t>(n+1, 1001);\\n        dp[n] = 0;\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            int costIfTakeDay = dp[i + 1] + costs[0];\\n            int costIfTakeWeek = dp[skipWeek(i, days)] + costs[1];\\n            int costIfTakeMonth = dp[skipMonth(i, days)] + costs[2];\\n\\n            dp[i] = std::min({costIfTakeDay, costIfTakeMonth, costIfTakeWeek});\\n        }\\n        return dp[0];\\n    }\\n\\n    int skipWeek(int index, std::vector<int> &days) {\\n        int lastDayOfWeekTicket = days[index] + 6;\\n        for (auto i = index; i < days.size(); ++i) {\\n            if (days[i] > lastDayOfWeekTicket)\\n                return i;\\n        }\\n        return days.size();\\n    }\\n\\n    int skipMonth(int index, std::vector<int> &days) {\\n        int lastDayOfMonthTicket = days[index] + 29;\\n        for (auto i = index; i < days.size(); ++i) {\\n            if (days[i] > lastDayOfMonthTicket)\\n                return i;\\n        }\\n        return days.size();\\n    }\\n};\\n```\\n\\n![_za_kompom_yapfiles.ru-min (online-video-cutter.com).gif](https://assets.leetcode.com/users/images/24de1e30-69bf-4d5e-9d36-cc6d305eadb8_1681373977.8447819.gif)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```dp[n]```\n```skipWeek```\n```skipMonth```\n```skipWeek```\n```days[index] + 6```\n```days.size()```\n```days```\n```days[index]```\n```days[index] + 6```\n```skipMonth```\n```skipWeek```\n```n-1```\n```0```\n```costIfTakeDay```\n```cost[0]```\n```costIfTakeWeek```\n```cost[1]```\n```skipWeek```\n```days.size()```\n```dp[days.size()] = 0;```\n```days[index]```\n```costIfTakeMonth```\n```cost[2]```\n```costIfTakeWeek```\n```skipMonth```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int> &days, vector<int> &costs) {\\n        int n = days.size();\\n        auto dp = std::vector<::uint16_t>(n+1, 1001);\\n        dp[n] = 0;\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            int costIfTakeDay = dp[i + 1] + costs[0];\\n            int costIfTakeWeek = dp[skipWeek(i, days)] + costs[1];\\n            int costIfTakeMonth = dp[skipMonth(i, days)] + costs[2];\\n\\n            dp[i] = std::min({costIfTakeDay, costIfTakeMonth, costIfTakeWeek});\\n        }\\n        return dp[0];\\n    }\\n\\n    int skipWeek(int index, std::vector<int> &days) {\\n        int lastDayOfWeekTicket = days[index] + 6;\\n        for (auto i = index; i < days.size(); ++i) {\\n            if (days[i] > lastDayOfWeekTicket)\\n                return i;\\n        }\\n        return days.size();\\n    }\\n\\n    int skipMonth(int index, std::vector<int> &days) {\\n        int lastDayOfMonthTicket = days[index] + 29;\\n        for (auto i = index; i < days.size(); ++i) {\\n            if (days[i] > lastDayOfMonthTicket)\\n                return i;\\n        }\\n        return days.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948406,
                "title": "dp-binary-search",
                "content": "**DP +Binary Search** . Time Complexity is O(Nlogn) and Space is O(N) . This code for Just a Knowledge .\\nPlease Hit the Like if u like My post.\\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n     int n=days.size();\\n     int dp[n];\\n     memset(dp, 0, sizeof(dp));\\n       \\n    for(int i=0; i<n;i++){\\n        \\n        if(i==0){\\n            //Base Case  Only One Day is there means size of days array is 1.\\n            dp[i]= *min_element(costs.begin(), costs.end());\\n            continue;\\n        }\\n        // val varible is used  to find minimum cost to reach days[i].\\n        // Choice one :- (1 day ticket).\\n        int val= dp[i-1]+costs[0];\\n        int index= lower_bound(days.begin() ,days.begin()+i, days[i]-6)-days.begin();\\n        // choice two :- 7 day ticket. As we know days array is sorted in Nature . \\n        // So Binary Search we can apply to find started day to Buy a ticket of 7 day pass.\\n        if(index!=0){\\n           val=min(dp[index-1]+ costs[1], val); \\n        }else{\\n            val=min(val, costs[1]);\\n        }\\n        index=lower_bound(days.begin() ,days.begin()+i, days[i]-29)-days.begin();\\n        // Similarly with 30 day pass as we do as 7 day pass.\\n        if(index!=0){\\n            val= min(dp[index-1]+costs[2], val);\\n        }else{\\n            val=min(val, costs[2]);\\n        }\\n        // Store val in dp for the Memoization.\\n        dp[i]=val;\\n        // cout<<dp[i]<<endl;\\n        \\n    }\\n        \\n    return dp[n-1];\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n     int n=days.size();\\n     int dp[n];\\n     memset(dp, 0, sizeof(dp));\\n       \\n    for(int i=0; i<n;i++){\\n        \\n        if(i==0){\\n            //Base Case  Only One Day is there means size of days array is 1.\\n            dp[i]= *min_element(costs.begin(), costs.end());\\n            continue;\\n        }\\n        // val varible is used  to find minimum cost to reach days[i].\\n        // Choice one :- (1 day ticket).\\n        int val= dp[i-1]+costs[0];\\n        int index= lower_bound(days.begin() ,days.begin()+i, days[i]-6)-days.begin();\\n        // choice two :- 7 day ticket. As we know days array is sorted in Nature . \\n        // So Binary Search we can apply to find started day to Buy a ticket of 7 day pass.\\n        if(index!=0){\\n           val=min(dp[index-1]+ costs[1], val); \\n        }else{\\n            val=min(val, costs[1]);\\n        }\\n        index=lower_bound(days.begin() ,days.begin()+i, days[i]-29)-days.begin();\\n        // Similarly with 30 day pass as we do as 7 day pass.\\n        if(index!=0){\\n            val= min(dp[index-1]+costs[2], val);\\n        }else{\\n            val=min(val, costs[2]);\\n        }\\n        // Store val in dp for the Memoization.\\n        dp[i]=val;\\n        // cout<<dp[i]<<endl;\\n        \\n    }\\n        \\n    return dp[n-1];\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1778507,
                "title": "java-dp-solution-similar-to-coin-change",
                "content": "This question can be solved both recursively & tabulated way similarly to the Classic Coin change problem. Just like how we would be looping through all coin possiblities for a given amount, we would consider cost for all 3 passes at once (1,7,30) days.\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[366]; // we would consider all 365 days for our simplicity\\n        int k = 0;\\n        for(int i = 1; k < days.length; i++)\\n        {\\n            if(i != days[k])\\n                dp[i] = dp[i-1]; // just if we dont have to travel on the Current ith day in our 365 day Calendar, we consider the result from the previous day we have travelled\\n            else\\n            {\\n                int daypass = i-1 > 0 ?  dp[i-1] + costs[0] : costs[0]; // if we can go back 1 day & check the cost till a day before + 1 day pass for current day\\n                int weekpass = i-7 > 0 ? dp[i-7] + costs[1] : costs[1]; // if we can go back 7 days & check the cost till a week before + 7 day pass for current day\\n                int monthpass = i-30 > 0 ? dp[i-30] + costs[2] : costs[2]; // if we can go back 30 days & check the cost till a month before + 30 day pass for current day\\n                \\n                dp[i] = Math.min(monthpass, Math.min(weekpass,daypass)); // min of all above scenarios\\n                k++;\\n            }\\n        }\\n        k = days[days.length-1];\\n        return dp[k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[366]; // we would consider all 365 days for our simplicity\\n        int k = 0;\\n        for(int i = 1; k < days.length; i++)\\n        {\\n            if(i != days[k])\\n                dp[i] = dp[i-1]; // just if we dont have to travel on the Current ith day in our 365 day Calendar, we consider the result from the previous day we have travelled\\n            else\\n            {\\n                int daypass = i-1 > 0 ?  dp[i-1] + costs[0] : costs[0]; // if we can go back 1 day & check the cost till a day before + 1 day pass for current day\\n                int weekpass = i-7 > 0 ? dp[i-7] + costs[1] : costs[1]; // if we can go back 7 days & check the cost till a week before + 7 day pass for current day\\n                int monthpass = i-30 > 0 ? dp[i-30] + costs[2] : costs[2]; // if we can go back 30 days & check the cost till a month before + 30 day pass for current day\\n                \\n                dp[i] = Math.min(monthpass, Math.min(weekpass,daypass)); // min of all above scenarios\\n                k++;\\n            }\\n        }\\n        k = days[days.length-1];\\n        return dp[k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658009,
                "title": "simple-cpp-solution-using-dp-with-detailed-explanation-o-n-tc",
                "content": "```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\t//since days are sorted, take the last day that you should travel.\\n        int lastDay = days.back();\\n        vector<int> dp(lastDay + 1, -1);\\n\\n        //Mark those days needed to travel on as 0, just to remind us to do DP at this index.\\n        for(auto i : days)\\n            dp[i] = 0;\\n        //Make 0th day as 0, since it costs 0 to travel on 0th day\\n        dp[0] = 0;\\n        //Iterate from 1st day to last day\\n        for(int i = 1; i <= lastDay; i++)\\n        {\\n\\t\\t//If current index is -1, then we are not travelling on this day. Cost will be same as previous index\\n            if(dp[i] == -1)\\n                dp[i] = dp[i-1];\\n            else\\n            {\\n//Cost for one day travel is cost to travel till this date (dp[i-1]) + cost of one day travel\\n                dp[i] = dp[i-1] + costs[0];\\n//cost to travel if you had taken 7 day pass earlier and see if that can be cheaper than current cost.\\n                dp[i] = min(dp[i], dp[max(0, i-7)] + costs[1]);\\n//cost to travel if you had taken 7 day pass earlier and see if that can be cheaper than current cost.\\n                dp[i] = min(dp[i], dp[max(0, i-30)] + costs[2]);\\n            }\\n        }\\n        return dp[lastDay];\\n```",
                "solutionTags": [],
                "code": "```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\t//since days are sorted, take the last day that you should travel.\\n        int lastDay = days.back();\\n        vector<int> dp(lastDay + 1, -1);\\n\\n        //Mark those days needed to travel on as 0, just to remind us to do DP at this index.\\n        for(auto i : days)\\n            dp[i] = 0;\\n        //Make 0th day as 0, since it costs 0 to travel on 0th day\\n        dp[0] = 0;\\n        //Iterate from 1st day to last day\\n        for(int i = 1; i <= lastDay; i++)\\n        {\\n\\t\\t//If current index is -1, then we are not travelling on this day. Cost will be same as previous index\\n            if(dp[i] == -1)\\n                dp[i] = dp[i-1];\\n            else\\n            {\\n//Cost for one day travel is cost to travel till this date (dp[i-1]) + cost of one day travel\\n                dp[i] = dp[i-1] + costs[0];\\n//cost to travel if you had taken 7 day pass earlier and see if that can be cheaper than current cost.\\n                dp[i] = min(dp[i], dp[max(0, i-7)] + costs[1]);\\n//cost to travel if you had taken 7 day pass earlier and see if that can be cheaper than current cost.\\n                dp[i] = min(dp[i], dp[max(0, i-30)] + costs[2]);\\n            }\\n        }\\n        return dp[lastDay];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238974,
                "title": "javascript-as-simple-as-it-gets",
                "content": "Keep a running total of your cost every day. \\nOn days where you need a ticket increment your cost by the daily cost.\\nEveryday do the following:\\n\\tLook back a week (or the first day) to see if it would have been cheaper to buy a weekly ticket. \\n\\tLook back a month (or the first day) to see if it would have been cheaper to buy a monthly ticket. \\n\\n```\\nvar mincostTickets = function(days, costs) {\\n    \\n    let total = Array(365);\\n    let dayPtr = 0;\\n    \\n    total[0] = 0;\\n    for(let i = 1; i < 365; i++){\\n        let curCost = total[i - 1];\\n        \\n        if(days[dayPtr] == i){\\n            curCost += costs[0];\\n            dayPtr++;\\n        }\\n        curCost = Math.min(curCost,total[Math.max(0,i - 7)] + costs[1]);\\n        curCost = Math.min(curCost,total[Math.max(0, i - 30)] + costs[2]); \\n\\n        \\n        total[i] = curCost;\\n    }\\n    \\n    return total[365 - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mincostTickets = function(days, costs) {\\n    \\n    let total = Array(365);\\n    let dayPtr = 0;\\n    \\n    total[0] = 0;\\n    for(let i = 1; i < 365; i++){\\n        let curCost = total[i - 1];\\n        \\n        if(days[dayPtr] == i){\\n            curCost += costs[0];\\n            dayPtr++;\\n        }\\n        curCost = Math.min(curCost,total[Math.max(0,i - 7)] + costs[1]);\\n        curCost = Math.min(curCost,total[Math.max(0, i - 30)] + costs[2]); \\n\\n        \\n        total[i] = curCost;\\n    }\\n    \\n    return total[365 - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493310,
                "title": "recursion-memoization-very-easy-approach-with-easy-comments",
                "content": "class Solution {\\npublic:\\n \\n\\n    int solve(int n , vector<int>& days, vector<int>& costs , int ind , vector<int>& dp ){\\n        \\n        //BASE CASE agar index N ya usse bda hojae to hum sare days travel kr chuke h return krjao \\n        if(ind >= n){\\n            return 0 ;\\n        }\\n        \\n\\t\\t//step3 dp \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        \\n         // Mere pass 3 option honge har bar ya to ma ek day ka pass lu ya\\n        //3 din ka pass lu ya fir 7 din ka pass lu  \\n      \\n        //1 din ka pass \\n        \\n        int option1 = costs[0] + solve(n , days , costs , ind+1 , dp);\\n        \\n      // ek option ha ma 7 din ka pass lelu lekin agar mne 7 din ka pass lelia to mera\\n     //  index muje jb tk agge le jane hoga jb tk 7 din nhi ho jate \\n    // yani agar mne pass lia h day 1 pe to abb 1 se 7 tk jitne bhi din h unke lia call nhi krunga ma \\n        \\n        int i ;\\n        //iss for loop ko hmne bas i increase krne ke lia chlaya h \\n        \\n        for(i = ind ; i<n && days[i] <days[ind] + 7 ; i++);\\n        int option2 = costs[1] + solve(n , days , costs , i , dp);\\n        \\n        // abb ind na pass krke i pass krenge kyuki i hmara 7 days ke \\n      // lia traverse kr chuka h or same for 30 days \\n        \\n        int j ;\\n        for(j = ind ; j<n && days[j] <days[ind] + 30 ; j++);\\n        int option3 = costs[2] + solve(n , days , costs , j , dp); \\n        \\n\\t\\t//step 2 dp \\n        return dp[ind] =  min(option1 , min(option2 , option3));\\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n\\t\\t//step 1 dp \\n        vector<int> dp(n+1, -1);\\n        int ans = solve(n , days , costs , 0 , dp);\\n        return ans; \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n \\n\\n    int solve(int n , vector<int>& days, vector<int>& costs , int ind , vector<int>& dp ){\\n        \\n        //BASE CASE agar index N ya usse bda hojae to hum sare days travel kr chuke h return krjao \\n        if(ind >= n){\\n            return 0 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3366816,
                "title": "minimum-cost-for-tickets-mem-dp-concept",
                "content": "class Solution {\\npublic:\\n    int solvemem(int n1,vector<int>& days, vector<int>& costs,int index,vector<int> &dp){\\n        if(index>=n1){\\n            return 0;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int option1=costs[0]+solvemem(n1,days,costs,index+1,dp);\\n        int i;\\n        for( i=index;i<n1 && days[i]<days[index]+7;i++);\\n        int option2=costs[1]+solvemem(n1,days,costs,i,dp);\\n        \\n        \\n        for( i=index;i<n1 && days[i]<days[index]+30;i++);\\n        int option3=costs[2]+solvemem(n1,days,costs,i,dp);\\n        \\n        \\n        dp[index]=min(option1,min(option2,option3));\\n        return dp[index];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // vector<int> dp(n+1,-1);\\n        int n=days.size();\\n         vector<int> dp(n+1,-1);\\n        return solvemem(n,days,costs,0,dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solvemem(int n1,vector<int>& days, vector<int>& costs,int index,vector<int> &dp){\\n        if(index>=n1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3350997,
                "title": "simple-solution-with-detailed-comments",
                "content": "# JavaScript Solution\\n```\\nvar mincostTickets = function (days, costs) {\\n  // Create an array to store the minimum cost for each day of the year\\n  const minCosts = new Array(days[days.length - 1] + 1).fill(0);\\n  \\n  // Create a set of the days you will be traveling on for faster lookup\\n  const travelDays = new Set(days);\\n  \\n  // Loop through each day of the year, starting from day 1\\n  for (let day = 1; day < minCosts.length; day++) {\\n    // If you\\'re not traveling on this day, the minimum cost is the same as the previous day\\n    if (!travelDays.has(day)) {\\n      minCosts[day] = minCosts[day - 1];\\n    } else {\\n      // If you\\'re traveling on this day, calculate the minimum cost by comparing the costs\\n      // of buying a 1-day pass, a 7-day pass, or a 30-day pass on this day, and adding the\\n      // cost of the minimum cost of traveling up to 1, 7, or 30 days ago respectively\\n      minCosts[day] = Math.min(\\n        minCosts[day - 1] + costs[0],\\n        minCosts[Math.max(0, day - 7)] + costs[1],\\n        minCosts[Math.max(0, day - 30)] + costs[2]\\n      );\\n    }\\n  }\\n  \\n  // Return the minimum cost for traveling on all the given days\\n  return minCosts[minCosts.length - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar mincostTickets = function (days, costs) {\\n  // Create an array to store the minimum cost for each day of the year\\n  const minCosts = new Array(days[days.length - 1] + 1).fill(0);\\n  \\n  // Create a set of the days you will be traveling on for faster lookup\\n  const travelDays = new Set(days);\\n  \\n  // Loop through each day of the year, starting from day 1\\n  for (let day = 1; day < minCosts.length; day++) {\\n    // If you\\'re not traveling on this day, the minimum cost is the same as the previous day\\n    if (!travelDays.has(day)) {\\n      minCosts[day] = minCosts[day - 1];\\n    } else {\\n      // If you\\'re traveling on this day, calculate the minimum cost by comparing the costs\\n      // of buying a 1-day pass, a 7-day pass, or a 30-day pass on this day, and adding the\\n      // cost of the minimum cost of traveling up to 1, 7, or 30 days ago respectively\\n      minCosts[day] = Math.min(\\n        minCosts[day - 1] + costs[0],\\n        minCosts[Math.max(0, day - 7)] + costs[1],\\n        minCosts[Math.max(0, day - 30)] + costs[2]\\n      );\\n    }\\n  }\\n  \\n  // Return the minimum cost for traveling on all the given days\\n  return minCosts[minCosts.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3350806,
                "title": "recursion-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst we will try with recursion then we will optimse time complexcity due to overlapping subproblems by 1 d dp\\nf(cd) is each state of recursive function \\nis defined as min travelling cost from day cd to the last valid travelling day\\nintuition is that we will buy tickets only when we encounter a valid travelling day \\non the rest of the day we assume to solve the question that we dont require a pass to travel on that day\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nif the last travelling day=d\\nthen time complexcity =O(d)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[366];\\n\\n    int help(int cd,vector<int>&days,set<int>&st,vector<int>&costs,int & total,int till){\\n\\n\\n        //understand each state of this recursive function\\n        //f(cd) will tell the minimum cost to travel from day cd to the last valid travelling day\\n        if(cd>days[days.size()-1]){\\n            total=min(total,till);\\n            return  0;\\n        }\\n      \\n        if(dp[cd]!=-1){\\n            return dp[cd];\\n        }\\n        int ans=INT_MAX;\\n\\n        if(st.find(cd)==st.end()){\\n                ans=help(cd+1,days,st,costs,total,till);\\n\\n        }else{\\n            int c1=costs[0]+help(cd+1,days,st,costs,total,till+costs[0]);\\n            int c2=costs[1]+help(cd+7,days,st,costs,total,till+costs[1]);\\n            int c3=costs[2]+help(cd+30,days,st,costs,total,till+costs[2]);\\n            ans =min({c1,c2,c3,ans});\\n        }\\n        return dp[cd]=ans;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n        //first we will be writing the recursive approach for this question \\n\\n\\n        set<int>st;\\n        for(auto e:days){\\n            st.insert(e);\\n        }\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n        //st will contain the valid days on which we need to travel\\n        int total=INT_MAX;\\n        return help(1,days,st,costs,total,0);\\n        return total;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[366];\\n\\n    int help(int cd,vector<int>&days,set<int>&st,vector<int>&costs,int & total,int till){\\n\\n\\n        //understand each state of this recursive function\\n        //f(cd) will tell the minimum cost to travel from day cd to the last valid travelling day\\n        if(cd>days[days.size()-1]){\\n            total=min(total,till);\\n            return  0;\\n        }\\n      \\n        if(dp[cd]!=-1){\\n            return dp[cd];\\n        }\\n        int ans=INT_MAX;\\n\\n        if(st.find(cd)==st.end()){\\n                ans=help(cd+1,days,st,costs,total,till);\\n\\n        }else{\\n            int c1=costs[0]+help(cd+1,days,st,costs,total,till+costs[0]);\\n            int c2=costs[1]+help(cd+7,days,st,costs,total,till+costs[1]);\\n            int c3=costs[2]+help(cd+30,days,st,costs,total,till+costs[2]);\\n            ans =min({c1,c2,c3,ans});\\n        }\\n        return dp[cd]=ans;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n        //first we will be writing the recursive approach for this question \\n\\n\\n        set<int>st;\\n        for(auto e:days){\\n            st.insert(e);\\n        }\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n        //st will contain the valid days on which we need to travel\\n        int total=INT_MAX;\\n        return help(1,days,st,costs,total,0);\\n        return total;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349673,
                "title": "java-easy-solution-detailed-explanation-dp-100-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length+1];\\n        int monthStart = 1;\\n        int weekStart = 1;\\n        \\n        for(int i=0;i<days.length;i++){\\n            \\n            //calculate the total cost till the current day if day pass is bought\\n            int dayPass = costs[0] + dp[i];\\n            \\n            //Find the best possible window for week pass from current day(i)\\n            while(days[i]-days[weekStart-1]+1>7)\\n                weekStart++;\\n            \\n            //calculate the total cost till current day if week pass is bought for the last week pass window possible\\n            int weekPass = costs[1] + dp[weekStart-1];\\n            \\n            //Find the best possible window for month pass from current day(i)\\n            while(days[i]-days[monthStart-1]+1>30)\\n                monthStart++;\\n            \\n            //calculate the total cost till current day if month pass is bought for the last month pass window possible\\n            int monthPass = costs[2] + dp[monthStart-1];\\n            \\n            //Now calculate the lowest ticket cost till current day. This is done by choosing the lowest cost among day pass, week pass(for last 7 days) or month pass (for last 30 days)\\n            dp[i+1] = Math.min(dayPass,Math.min(weekPass,monthPass));\\n        }\\n        return dp[days.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length+1];\\n        int monthStart = 1;\\n        int weekStart = 1;\\n        \\n        for(int i=0;i<days.length;i++){\\n            \\n            //calculate the total cost till the current day if day pass is bought\\n            int dayPass = costs[0] + dp[i];\\n            \\n            //Find the best possible window for week pass from current day(i)\\n            while(days[i]-days[weekStart-1]+1>7)\\n                weekStart++;\\n            \\n            //calculate the total cost till current day if week pass is bought for the last week pass window possible\\n            int weekPass = costs[1] + dp[weekStart-1];\\n            \\n            //Find the best possible window for month pass from current day(i)\\n            while(days[i]-days[monthStart-1]+1>30)\\n                monthStart++;\\n            \\n            //calculate the total cost till current day if month pass is bought for the last month pass window possible\\n            int monthPass = costs[2] + dp[monthStart-1];\\n            \\n            //Now calculate the lowest ticket cost till current day. This is done by choosing the lowest cost among day pass, week pass(for last 7 days) or month pass (for last 30 days)\\n            dp[i+1] = Math.min(dayPass,Math.min(weekPass,monthPass));\\n        }\\n        return dp[days.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991115,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int max_day, cost[5], dys[500], dp[500];\\n\\n    int solve(int id) {\\n        if(id > 365) return 0;\\n        if(dp[id] != -1) return dp[id];\\n\\n        int ans;\\n        if(dys[id]) {\\n            ans = min({cost[0] + solve(id+1), cost[1] + solve(id+7), cost[2] + solve(id+30)});\\n        }\\n        else {\\n            ans = solve(id+1);\\n        }\\n        return dp[id] = ans;\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        for(int i=0; i<3; i++) cost[i] = costs[i];\\n        for(int i=0; i<500; i++) dp[i] = -1;\\n        for(int i=0; i<days.size(); i++) dys[days[i]] = 1;\\n        int ans = solve(0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_day, cost[5], dys[500], dp[500];\\n\\n    int solve(int id) {\\n        if(id > 365) return 0;\\n        if(dp[id] != -1) return dp[id];\\n\\n        int ans;\\n        if(dys[id]) {\\n            ans = min({cost[0] + solve(id+1), cost[1] + solve(id+7), cost[2] + solve(id+30)});\\n        }\\n        else {\\n            ans = solve(id+1);\\n        }\\n        return dp[id] = ans;\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        for(int i=0; i<3; i++) cost[i] = costs[i];\\n        for(int i=0; i<500; i++) dp[i] = -1;\\n        for(int i=0; i<days.size(); i++) dys[days[i]] = 1;\\n        int ans = solve(0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631059,
                "title": "c-iterative-dp-faster-than-100",
                "content": "Please upvote if you found this solution helpful.\\n\\n```\\n    int mincostTickets(vector<int> &days, vector<int> &costs) {\\n        vector<int> DP(days.back() + 1); // DP[i] is cost after ith day of travel\\n        DP[0] = 0; // initial cost before traveling is zero\\n        int i = 0; // iterator for days vector\\n        \\n        // **** Not neccessary\\n        int monthly = costs[2];\\n        int weekly = min(costs[1], monthly);\\n        int single = min(costs[0], weekly);\\n        // **** Not neccessary\\n        \\n        for (int day = 1; day < DP.size(); ++day) {\\n            if (day < days[i]) {\\n                /* Not traveling this day */\\n                DP[day] = DP[day - 1];\\n            } else if (day == days[i]) {\\n                // Recurrence relation\\n                DP[day] = DP[day - 1] + single;\\n                DP[day] = min(DP[day], DP[max(0, day - 7)] + weekly);\\n                DP[day] = min(DP[day], DP[max(0, day - 30)] + monthly);\\n                \\n                ++i; // Advance to next travel day\\n            } \\n        }\\n        \\n        return DP.back();\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "Please upvote if you found this solution helpful.\\n\\n```\\n    int mincostTickets(vector<int> &days, vector<int> &costs) {\\n        vector<int> DP(days.back() + 1); // DP[i] is cost after ith day of travel\\n        DP[0] = 0; // initial cost before traveling is zero\\n        int i = 0; // iterator for days vector\\n        \\n        // **** Not neccessary\\n        int monthly = costs[2];\\n        int weekly = min(costs[1], monthly);\\n        int single = min(costs[0], weekly);\\n        // **** Not neccessary\\n        \\n        for (int day = 1; day < DP.size(); ++day) {\\n            if (day < days[i]) {\\n                /* Not traveling this day */\\n                DP[day] = DP[day - 1];\\n            } else if (day == days[i]) {\\n                // Recurrence relation\\n                DP[day] = DP[day - 1] + single;\\n                DP[day] = min(DP[day], DP[max(0, day - 7)] + weekly);\\n                DP[day] = min(DP[day], DP[max(0, day - 30)] + monthly);\\n                \\n                ++i; // Advance to next travel day\\n            } \\n        }\\n        \\n        return DP.back();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1563435,
                "title": "simple-python-solution-with-explanation",
                "content": "explanation : https://github.com/midnightbot/leetcode_solutions/blob/main/983.%20Minimum%20Cost%20For%20Tickets(DP).pdf\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = max(days) + 1\\n        dp = [-1 for x in range(n)]\\n        #dp = [-1]*(max(days)+1)\\n        dp[0] = 0\\n        \\n        for x in range(1,len(dp)):\\n            if x in days:\\n                if x>=30:\\n                    #print(x,min(dp[x-1]+costs[0],dp[x-7]+costs[1],dp[x-30]+costs[2]))\\n                    dp[x] = min(dp[x-1]+costs[0],dp[x-7]+costs[1],dp[x-30]+costs[2])\\n                    \\n                elif x>=7 and x<30:\\n                    dp[x] = min(dp[x-1]+costs[0],dp[x-7]+costs[1],costs[2])\\n                    \\n                else:\\n                    dp[x] = min(dp[x-1]+costs[0],costs[1],costs[2])\\n                    \\n            else:\\n                dp[x] = dp[x-1]\\n                \\n        return dp[max(days)]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = max(days) + 1\\n        dp = [-1 for x in range(n)]\\n        #dp = [-1]*(max(days)+1)\\n        dp[0] = 0\\n        \\n        for x in range(1,len(dp)):\\n            if x in days:\\n                if x>=30:\\n                    #print(x,min(dp[x-1]+costs[0],dp[x-7]+costs[1],dp[x-30]+costs[2]))\\n                    dp[x] = min(dp[x-1]+costs[0],dp[x-7]+costs[1],dp[x-30]+costs[2])\\n                    \\n                elif x>=7 and x<30:\\n                    dp[x] = min(dp[x-1]+costs[0],dp[x-7]+costs[1],costs[2])\\n                    \\n                else:\\n                    dp[x] = min(dp[x-1]+costs[0],costs[1],costs[2])\\n                    \\n            else:\\n                dp[x] = dp[x-1]\\n                \\n        return dp[max(days)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339864,
                "title": "c-simple-and-easy-solution-faster-than-100-without-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n  \\n        int dp[366] = {};\\n        \\n        for(int a : days)\\n            dp[a]++;\\n        \\n        for(int i = days[0]; i <= days.back(); i++){\\n            if(dp[i]){\\n                dp[i] = min({dp[i-1] + costs[0], dp[max(0, i-7)] + costs[1], dp[max(0, i-30)] + costs[2]});\\n            }\\n            else dp[i] = dp[i-1];\\n        }\\n        return dp[days.back()];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n  \\n        int dp[366] = {}",
                "codeTag": "Java"
            },
            {
                "id": 1320678,
                "title": "c-memoization-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[366];\\n    int solve(vector<int>&days,vector<int>&cost,int i){\\n        if(i>=days.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int op1=cost[0]+solve(days,cost,i+1);\\n        \\n        int k=i;\\n        for(;k<days.size();k++){\\n            if(days[k]>=days[i]+7){\\n                break;\\n            }\\n        }\\n        int op2=cost[1]+solve(days,cost,k);\\n        \\n         for(;k<days.size();k++){\\n            if(days[k]>=days[i]+30){\\n                break;\\n            }\\n        }\\n        int op3=cost[2]+solve(days,cost,k);\\n        \\n        dp[i]=min(op1,min(op2,op3));\\n        \\n        return min(op1,min(op2,op3));\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(days,costs,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[366];\\n    int solve(vector<int>&days,vector<int>&cost,int i){\\n        if(i>=days.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int op1=cost[0]+solve(days,cost,i+1);\\n        \\n        int k=i;\\n        for(;k<days.size();k++){\\n            if(days[k]>=days[i]+7){\\n                break;\\n            }\\n        }\\n        int op2=cost[1]+solve(days,cost,k);\\n        \\n         for(;k<days.size();k++){\\n            if(days[k]>=days[i]+30){\\n                break;\\n            }\\n        }\\n        int op3=cost[2]+solve(days,cost,k);\\n        \\n        dp[i]=min(op1,min(op2,op3));\\n        \\n        return min(op1,min(op2,op3));\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(days,costs,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811661,
                "title": "c-dynamic-programming-simple-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> d(days.back()+1); // initialize a help array for dynamic programming\\n        for (int i=0; i<days.size(); i++) // days of traveling are initialized with max value\\n            d[days[i]] = INT_MAX;\\n        for (int i = 1; i<d.size();i++) // dynamic programming: fill the array depending on previous sub-problems\\n        {\\n            if (d[i] == 0)\\n                d[i] = d[i-1];\\n            else\\n                if (i < 7)\\n                    d[i] = min({d[i-1]+costs[0], d[0]+costs[1]});\\n                else if (i<30)\\n                    d[i] = min({d[i-1]+costs[0], d[i-7]+costs[1], d[0]+costs[2]});\\n                else\\n                    d[i] = min({d[i-1]+costs[0], d[i-7]+costs[1], d[i-30]+costs[2]});\\n        }\\n        return d.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> d(days.back()+1); // initialize a help array for dynamic programming\\n        for (int i=0; i<days.size(); i++) // days of traveling are initialized with max value\\n            d[days[i]] = INT_MAX;\\n        for (int i = 1; i<d.size();i++) // dynamic programming: fill the array depending on previous sub-problems\\n        {\\n            if (d[i] == 0)\\n                d[i] = d[i-1];\\n            else\\n                if (i < 7)\\n                    d[i] = min({d[i-1]+costs[0], d[0]+costs[1]});\\n                else if (i<30)\\n                    d[i] = min({d[i-1]+costs[0], d[i-7]+costs[1], d[0]+costs[2]});\\n                else\\n                    d[i] = min({d[i-1]+costs[0], d[i-7]+costs[1], d[i-30]+costs[2]});\\n        }\\n        return d.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811378,
                "title": "java-100-0ms-dp-o-n-simple-explanation-no-recursion",
                "content": "**If useful, please up-vote.**\\n\\nUse a dynamic programming array ```dp[]``` indexed by the day number.  The ```dp[]``` array contains the minimum cost up to a specific day.  To decide between 1-day, 7-day, and 30-day tickets being cheapest, we will need look backward 1, 7, and 30 days in ```dp[]```, then add the ticket cost, and see which type of ticket would give the lowest cost to get to the current day.  We loop through days from the first travel day to the last travel day, updating the minimum cost to get to that day.  The ```dp[]``` array includes **all** days from day 0, until the last travel day, including all non-travel days in between travel days.\\n\\nBecause the 30-day ticket would use the longest look back in ```dp[]```, we add an **offset of 30 days** to all indexes into ```dp[]```.  With the 30 day offset, all day numbers used from ```days[]``` have 30 added to that day number.  This 30 day offset keeps the look backs from repeatedly requiring extra coding to make sure we don\\'t look back to a negative index in the ```dp[]``` array.  For example, **without** the extra 30 offset, at day 4, if looking back 30 days, we would need extra code to keep from indexing day 4-30 = day -26.  **With** an offset of 30 days into ```dp[]```, we can always safely index back to the current day minus 7 or the current day minus 30.\\n\\nSteps in the code below are:\\n1) Loop through all days from the first travel day to the last travel day.  The first travel day is ```days[0] + 30```, adding 30 for a 30 day offset of indexing the ```dp[]``` array.  The last travel day is ```days[days.length - 1] + 30```.\\n2) Get the day number of the next travel day, offset by 30 extra days.\\n3) If there are non-travel days since the last travel day, then copy the previous minimum cost from the previous day in ```dp[]``` to all non-travel days since the last travel day.\\n4) Find the minimum of the three costs of travelling with either a 1-day, 7-day, or 30-day ticket, for the last 1, 7, or 30 days.  \\n4a) To find the cost of travelling for the previous 1 day on a 1-day ticket, look back 1-day to get the minimum cost we had determined 1-day ago in ```dp[day-1]```, and add the ```costs[0]``` of a 1-day ticket since then.\\n4b) To find the cost travelling for the previous 7 days on a 7-day ticket, look back 7-days in ```dp[]``` to get the minimum cost we calculated in ```dp[day-7]```, and add the ```costs[1]``` of a 7-day ticket to travel since 7 days ago.  \\n4c) To find the cost of travelling for the previous 30 days on a 30-day ticket, look back 30-days in ```dp[]``` to get the minimum cost 30 days earlier in ```dp[day-30]```, and add the ```costs[2]``` of a 30-day ticket since then. \\n5) Loop back to step 2) until having processed the last travel day.\\n6) Return the minimum cost for the last travel day in ```dp[]```.\\n\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int firstDay = days[0] + 30;                            // First day to travel, offset by max look back.\\n        int lastDay = days[days.length - 1] + 30;               // Last day to travel, offset by max look back.\\n        int travelDayIndex = 0;                                 // Index of current travel day, in days[].\\n        int[] dp = new int[lastDay + 1 + 30];\\n        \\n        // Loop through the days to be travelling, including all the days between travel days.\\n        for (int day = firstDay; day <= lastDay; day++) {\\n            int nextTravelDay = days[travelDayIndex++] + 30;    // Next travel day, offset by max look back.\\n            while (day < nextTravelDay)                         // Loop through non-travel days until next travel day.\\n                dp[day] = dp[day++ - 1];                        // Between travel days, continue prev best price.\\n            dp[day] = Math.min(dp[day-1] + costs[0],            // Find min of 1-day ticket for last 1 day,\\n                               Math.min(dp[day-7] + costs[1],   //    or 7-day ticket for last 7 days, \\n                                       dp[day-30] + costs[2])); //    or 30-day ticket for last 30 days.\\n        }\\n        \\n        return dp[lastDay];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```dp[]```\n```dp[]```\n```dp[]```\n```dp[]```\n```dp[]```\n```dp[]```\n```days[]```\n```dp[]```\n```dp[]```\n```days[0] + 30```\n```dp[]```\n```days[days.length - 1] + 30```\n```dp[]```\n```dp[day-1]```\n```costs[0]```\n```dp[]```\n```dp[day-7]```\n```costs[1]```\n```dp[]```\n```dp[day-30]```\n```costs[2]```\n```dp[]```\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int firstDay = days[0] + 30;                            // First day to travel, offset by max look back.\\n        int lastDay = days[days.length - 1] + 30;               // Last day to travel, offset by max look back.\\n        int travelDayIndex = 0;                                 // Index of current travel day, in days[].\\n        int[] dp = new int[lastDay + 1 + 30];\\n        \\n        // Loop through the days to be travelling, including all the days between travel days.\\n        for (int day = firstDay; day <= lastDay; day++) {\\n            int nextTravelDay = days[travelDayIndex++] + 30;    // Next travel day, offset by max look back.\\n            while (day < nextTravelDay)                         // Loop through non-travel days until next travel day.\\n                dp[day] = dp[day++ - 1];                        // Between travel days, continue prev best price.\\n            dp[day] = Math.min(dp[day-1] + costs[0],            // Find min of 1-day ticket for last 1 day,\\n                               Math.min(dp[day-7] + costs[1],   //    or 7-day ticket for last 7 days, \\n                                       dp[day-30] + costs[2])); //    or 30-day ticket for last 30 days.\\n        }\\n        \\n        return dp[lastDay];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701437,
                "title": "simple-to-understand-python-dp-bottom-up-approach",
                "content": "\\n```\\nday      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\\ncosts    0, 2, 2, 2, 4, 4, 6, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11\\n```\\n\\n`costs` represent the cache in the code whereas `day` is the corresponding day. Notice how we do not update the cost on the days we do not travel e.g on day `2-3` and days `9 - 19 `\\n\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = days[-1] + 1\\n        cache = [0] * n\\n\\n        # convert days to set for faster lookup\\n        travel_days = {day for day in days}\\n\\n        for i in range(1, n):\\n            if i in travel_days:\\n                # use max() to pick cache[0] incase `i-day` is out of bounds\\n                cache[i] = min(\\n                    [\\n                        cache[max(i - 1, 0)] + costs[0],  # one day pass\\n                        cache[max(i - 7, 0)] + costs[1],  # seven day pass\\n                        cache[max(i - 30, 0)] + costs[2],  # thirty day pass\\n                    ]\\n                )\\n            else:\\n                # not a travel day\\n                cache[i] = cache[i - 1]\\n\\n        return cache[-1]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nday      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\\ncosts    0, 2, 2, 2, 4, 4, 6, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342599,
                "title": "python",
                "content": "```\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * (days[-1] + 1)\\n        day = set(days)\\n        for i in range(1, days[-1] + 1):\\n            if i not in day:\\n                dp[i] = dp[i-1]\\n            else:\\n                dp[i] = min(dp[i-1]+costs[0], dp[max(0, i-7)]+costs[1], dp[max(0, i-30)] + costs[2])\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * (days[-1] + 1)\\n        day = set(days)\\n        for i in range(1, days[-1] + 1):\\n            if i not in day:\\n                dp[i] = dp[i-1]\\n            else:\\n                dp[i] = min(dp[i-1]+costs[0], dp[max(0, i-7)]+costs[1], dp[max(0, i-30)] + costs[2])\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3683203,
                "title": "memoized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,int e,vector<int> &days,vector<int> &costs,vector<vector<int>> &dp){\\n        if(i>=n || e>365){\\n            return 0;\\n        }\\n        if(dp[i][e] != -1)return dp[i][e];\\n        int a = INT_MAX,b=INT_MAX,c=INT_MAX;\\n        if(days[i]>e){\\n            a = costs[0]+solve(i+1,n,days[i],days,costs,dp);\\n        }\\n        if(days[i]>e){\\n            b = costs[1]+solve(i+1,n,days[i]+6,days,costs,dp);\\n        }else{\\n            b = solve(i+1,n,e,days,costs,dp);\\n        }\\n        if(days[i]>e){\\n            c = costs[2]+solve(i+1,n,days[i]+29,days,costs,dp);\\n        }else{\\n            c = solve(i+1,n,e,days,costs,dp);\\n        }\\n        return dp[i][e] = min({a,b,c});\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<vector<int>> dp(n,vector<int>(366,-1));\\n        return solve(0,n,0,days,costs,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,int e,vector<int> &days,vector<int> &costs,vector<vector<int>> &dp){\\n        if(i>=n || e>365){\\n            return 0;\\n        }\\n        if(dp[i][e] != -1)return dp[i][e];\\n        int a = INT_MAX,b=INT_MAX,c=INT_MAX;\\n        if(days[i]>e){\\n            a = costs[0]+solve(i+1,n,days[i],days,costs,dp);\\n        }\\n        if(days[i]>e){\\n            b = costs[1]+solve(i+1,n,days[i]+6,days,costs,dp);\\n        }else{\\n            b = solve(i+1,n,e,days,costs,dp);\\n        }\\n        if(days[i]>e){\\n            c = costs[2]+solve(i+1,n,days[i]+29,days,costs,dp);\\n        }else{\\n            c = solve(i+1,n,e,days,costs,dp);\\n        }\\n        return dp[i][e] = min({a,b,c});\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<vector<int>> dp(n,vector<int>(366,-1));\\n        return solve(0,n,0,days,costs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352638,
                "title": "1-loop-solution-o-n",
                "content": "### Explained below inside the code for better Understanding.\\n\\n# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# \\uD83D\\uDE09Please upvote it motivates me\\uD83D\\uDE09\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        unordered_set<int> st(begin(days), end(days));\\n\\n        int last_day = days.back();\\n\\n        vector<int> t(last_day+1, 0);\\n        //t[i] will give us min cost to travel till day i.\\n\\n        t[0] = 0;\\n\\n        //Start from 1st day & travel till last day\\n        for(int i=1; i<=last_day; i++)\\n        {\\n            /* If i\\'th day is not found then\\n            set previous value in current index & continue. */\\n            if(st.find(i) == st.end())\\n            {\\n                t[i] = t[i-1];\\n                continue;\\n            }\\n\\n            //Calculate cost of day 1 pass\\n            int day_1_pass = costs[0] + t[max(i-1, 0)];\\n\\n            //Calculate cost of day 7 pass\\n            int day_7_pass = costs[1] + t[max(i-7, 0)];\\n\\n            //Calculate cost of day 30 pass\\n            int day_30_pass = costs[2] + t[max(i-30, 0)];\\n\\n\\n            //Find minimum of all & store in i\\'th index.\\n            t[i] = min({day_1_pass, day_7_pass, day_30_pass});\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return t[last_day];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        unordered_set<int> st(begin(days), end(days));\\n\\n        int last_day = days.back();\\n\\n        vector<int> t(last_day+1, 0);\\n        //t[i] will give us min cost to travel till day i.\\n\\n        t[0] = 0;\\n\\n        //Start from 1st day & travel till last day\\n        for(int i=1; i<=last_day; i++)\\n        {\\n            /* If i\\'th day is not found then\\n            set previous value in current index & continue. */\\n            if(st.find(i) == st.end())\\n            {\\n                t[i] = t[i-1];\\n                continue;\\n            }\\n\\n            //Calculate cost of day 1 pass\\n            int day_1_pass = costs[0] + t[max(i-1, 0)];\\n\\n            //Calculate cost of day 7 pass\\n            int day_7_pass = costs[1] + t[max(i-7, 0)];\\n\\n            //Calculate cost of day 30 pass\\n            int day_30_pass = costs[2] + t[max(i-30, 0)];\\n\\n\\n            //Find minimum of all & store in i\\'th index.\\n            t[i] = min({day_1_pass, day_7_pass, day_30_pass});\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return t[last_day];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351359,
                "title": "recursive-dp-solution-with-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int>dp;\\n    int solve(int i,vector<int>& days, vector<int>& costs){\\n        if(i>=days.size()){\\n            return 0;\\n        }\\n        else if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=2e9;\\n\\n        //test for 3 vals\\n        int cur=days[i];\\n        res=min(res,costs[2]+solve(upper_bound(days.begin(),days.end(),cur+30-1)-days.begin(),days,costs));\\n        res=min(res,costs[1]+solve(upper_bound(days.begin(),days.end(),cur+7-1)-days.begin(),days,costs));\\n        res=min(res,costs[0]+solve(i+1,days,costs));\\n\\n        return dp[i]=res;\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp.clear();\\n        dp.resize(days.size()+1,-1);\\n        return solve(0,days,costs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int>dp;\\n    int solve(int i,vector<int>& days, vector<int>& costs){\\n        if(i>=days.size()){\\n            return 0;\\n        }\\n        else if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=2e9;\\n\\n        //test for 3 vals\\n        int cur=days[i];\\n        res=min(res,costs[2]+solve(upper_bound(days.begin(),days.end(),cur+30-1)-days.begin(),days,costs));\\n        res=min(res,costs[1]+solve(upper_bound(days.begin(),days.end(),cur+7-1)-days.begin(),days,costs));\\n        res=min(res,costs[0]+solve(i+1,days,costs));\\n\\n        return dp[i]=res;\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp.clear();\\n        dp.resize(days.size()+1,-1);\\n        return solve(0,days,costs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350934,
                "title": "java-easy-understanding-dp-recursion-beats-100-simple",
                "content": "RECURSION VERSION\\nIT WILL GIVE A TLE.\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        return check(days,costs,0);\\n    }\\n    public static int check(int d[],int c[],int day){\\n        if(day>=d.length) return 0;\\n        int d1=check(d,c,day+1)+c[0];\\n        int i;\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+7) break;\\n        }\\n        int d7=check(d,c,i)+c[1];\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+30) break;\\n        }\\n        int d30=check(d,c,i)+c[2];\\n        return Math.min(d1,Math.min(d7,d30));\\n    }\\n}\\n\\n```\\nMEMOIZED VERSION\\nFULLY WORKING BEATS 100%\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dp[]=new int[days.length+1];\\n        return check(days,costs,0,dp);\\n    }\\n    public static int check(int d[],int c[],int day,int dp[]){\\n        if(day>=d.length) return 0;\\n        if(dp[day]!=0) return dp[day];\\n        int d1=check(d,c,day+1,dp)+c[0];\\n        int i;\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+7) break;\\n        }\\n        int d7=check(d,c,i,dp)+c[1];\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+30) break;\\n        }\\n        int d30=check(d,c,i,dp)+c[2];\\n        return dp[day]=Math.min(d1,Math.min(d7,d30));\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        return check(days,costs,0);\\n    }\\n    public static int check(int d[],int c[],int day){\\n        if(day>=d.length) return 0;\\n        int d1=check(d,c,day+1)+c[0];\\n        int i;\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+7) break;\\n        }\\n        int d7=check(d,c,i)+c[1];\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+30) break;\\n        }\\n        int d30=check(d,c,i)+c[2];\\n        return Math.min(d1,Math.min(d7,d30));\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dp[]=new int[days.length+1];\\n        return check(days,costs,0,dp);\\n    }\\n    public static int check(int d[],int c[],int day,int dp[]){\\n        if(day>=d.length) return 0;\\n        if(dp[day]!=0) return dp[day];\\n        int d1=check(d,c,day+1,dp)+c[0];\\n        int i;\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+7) break;\\n        }\\n        int d7=check(d,c,i,dp)+c[1];\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+30) break;\\n        }\\n        int d30=check(d,c,i,dp)+c[2];\\n        return dp[day]=Math.min(d1,Math.min(d7,d30));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350689,
                "title": "c-recursion-memoization-tabulation",
                "content": "# Recursion (Gives TLE)\\n```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int> &costs,vector<int> days,int n){\\n\\n        if(ind>=n){\\n            return 0;\\n        }\\n        cout<<ind<<\" \";\\n        int Day1=costs[0]+f(ind+1,costs,days,n);\\n        int i;\\n        for(i=ind;i<n;i++){\\n            if(days[i]>=days[ind]+7){\\n                break;\\n            }\\n        }\\n        int Day7=costs[1]+f(i,costs,days,n);\\n        int j;\\n        for(j=ind;j<n;j++){\\n            if(days[j]>=days[ind]+30){\\n                break;\\n            }\\n        }\\n        int Day30=costs[2]+f(j,costs,days,n);\\n\\n        \\n        return min(Day1,min(Day7,Day30));\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        return f(0,costs,days,n);\\n        \\n    }\\n};\\n```\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int> &costs,vector<int> &days,int n,vector<int> &dp){\\n\\n        if(ind>=n){\\n            return 0;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        int Day1=costs[0]+f(ind+1,costs,days,n,dp);\\n        int i;\\n        for(i=ind;i<n;i++){\\n            if(days[i]>=days[ind]+7){\\n                break;\\n            }\\n        }\\n        int Day7=costs[1]+f(i,costs,days,n,dp);\\n        int j;\\n        for(j=ind;j<n;j++){\\n            if(days[j]>=days[ind]+30){\\n                break;\\n            }\\n        }\\n        int Day30=costs[2]+f(j,costs,days,n,dp);\\n\\n        \\n        return dp[ind]=min(Day1,min(Day7,Day30));\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        vector<int> dp(n+1,-1);\\n        return f(0,costs,days,n,dp);\\n        \\n    }\\n};\\n```\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        vector<int> dp(n+1,0);\\n\\n        for(int ind=n-1;ind>=0;ind--){\\n            \\n            int Day1=costs[0]+dp[ind+1];\\n            int i;\\n            for(i=ind;i<n;i++){\\n                if(days[i]>=days[ind]+7){\\n                    break;\\n                }\\n            }\\n            int Day7=costs[1]+dp[i];\\n            int j;\\n            for(j=ind;j<n;j++){\\n                if(days[j]>=days[ind]+30){\\n                    break;\\n                }\\n            }\\n            int Day30=costs[2]+dp[j];\\n\\n            dp[ind]=min(Day1,min(Day7,Day30));\\n\\n        }\\n\\n        return dp[0];\\n        \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int> &costs,vector<int> days,int n){\\n\\n        if(ind>=n){\\n            return 0;\\n        }\\n        cout<<ind<<\" \";\\n        int Day1=costs[0]+f(ind+1,costs,days,n);\\n        int i;\\n        for(i=ind;i<n;i++){\\n            if(days[i]>=days[ind]+7){\\n                break;\\n            }\\n        }\\n        int Day7=costs[1]+f(i,costs,days,n);\\n        int j;\\n        for(j=ind;j<n;j++){\\n            if(days[j]>=days[ind]+30){\\n                break;\\n            }\\n        }\\n        int Day30=costs[2]+f(j,costs,days,n);\\n\\n        \\n        return min(Day1,min(Day7,Day30));\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        return f(0,costs,days,n);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int> &costs,vector<int> &days,int n,vector<int> &dp){\\n\\n        if(ind>=n){\\n            return 0;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        int Day1=costs[0]+f(ind+1,costs,days,n,dp);\\n        int i;\\n        for(i=ind;i<n;i++){\\n            if(days[i]>=days[ind]+7){\\n                break;\\n            }\\n        }\\n        int Day7=costs[1]+f(i,costs,days,n,dp);\\n        int j;\\n        for(j=ind;j<n;j++){\\n            if(days[j]>=days[ind]+30){\\n                break;\\n            }\\n        }\\n        int Day30=costs[2]+f(j,costs,days,n,dp);\\n\\n        \\n        return dp[ind]=min(Day1,min(Day7,Day30));\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        vector<int> dp(n+1,-1);\\n        return f(0,costs,days,n,dp);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        vector<int> dp(n+1,0);\\n\\n        for(int ind=n-1;ind>=0;ind--){\\n            \\n            int Day1=costs[0]+dp[ind+1];\\n            int i;\\n            for(i=ind;i<n;i++){\\n                if(days[i]>=days[ind]+7){\\n                    break;\\n                }\\n            }\\n            int Day7=costs[1]+dp[i];\\n            int j;\\n            for(j=ind;j<n;j++){\\n                if(days[j]>=days[ind]+30){\\n                    break;\\n                }\\n            }\\n            int Day30=costs[2]+dp[j];\\n\\n            dp[ind]=min(Day1,min(Day7,Day30));\\n\\n        }\\n\\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3349931,
                "title": "beats-99-easy-to-understand-bottom-up-top-down-approach",
                "content": "# Intuition\\nEach value in `memo` stores the minimum cost it takes to travel for that many days, given the travel days required.\\n\\n# Approach\\nHence, the sub problems can be expressed as follows in two cases\\n### If we don\\'t travel:\\n`memo[i] = memo[i-1]`\\nThis is because we don\\'t travel so we can just use the value of the previous memo\\n### If we travel:\\nWe consider\\n`memo[i] = min(memo[i-1] + costs[0], memo[max(0, i-7)] + costs[1], memo[max(0,i-30)] + costs[2])`\\n\\nThis is because we need to find out whether we should buy a ticket 1,7 or 30 days earlier.\\nComparing these options, we can then find what is the minimum cost so that on day `i` we can travel\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(max\\\\_days + n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(max\\\\_days)$\\n# Code\\n### Bottom-Up approach\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        max_day = days[-1]\\n        memo = [0] * (max_day + 1)\\n        travel = [False] * (max_day + 1)\\n        memo[0] = 0\\n        for d in days:\\n            travel[d] = True\\n\\n        for i in range(1, len(memo)):\\n            memo[i] = memo[i-1]\\n            if travel[i]:\\n                memo[i] = min(memo[i-1] + costs[0], memo[max(0, i-7)] + costs[1], memo[max(0,i-30)] + costs[2])\\n    \\n        return memo[-1]\\n```\\n\\n### Top-down approach\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        self.costs = costs\\n        self.memo = {}\\n        self.memo[0] = 0\\n        self.travel = set(days)\\n\\n        return self.min_ticket(days[-1])\\n\\n    def min_ticket(self, day):\\n        if day <= 0:\\n            day = 0\\n\\n        if day in self.memo:\\n            return self.memo[day]\\n\\n        if day in self.travel:\\n            self.memo[day] = min(self.min_ticket(day - 1) + self.costs[0], self.min_ticket(day - 7) + self.costs[1], self.min_ticket(day - 30) + self.costs[2])\\n        else:\\n            self.memo[day] = self.min_ticket(day - 1)\\n                \\n        return self.memo[day]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        max_day = days[-1]\\n        memo = [0] * (max_day + 1)\\n        travel = [False] * (max_day + 1)\\n        memo[0] = 0\\n        for d in days:\\n            travel[d] = True\\n\\n        for i in range(1, len(memo)):\\n            memo[i] = memo[i-1]\\n            if travel[i]:\\n                memo[i] = min(memo[i-1] + costs[0], memo[max(0, i-7)] + costs[1], memo[max(0,i-30)] + costs[2])\\n    \\n        return memo[-1]\\n```\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        self.costs = costs\\n        self.memo = {}\\n        self.memo[0] = 0\\n        self.travel = set(days)\\n\\n        return self.min_ticket(days[-1])\\n\\n    def min_ticket(self, day):\\n        if day <= 0:\\n            day = 0\\n\\n        if day in self.memo:\\n            return self.memo[day]\\n\\n        if day in self.travel:\\n            self.memo[day] = min(self.min_ticket(day - 1) + self.costs[0], self.min_ticket(day - 7) + self.costs[1], self.min_ticket(day - 30) + self.costs[2])\\n        else:\\n            self.memo[day] = self.min_ticket(day - 1)\\n                \\n        return self.memo[day]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349725,
                "title": "100-recursion-memoisation-top-down-dp",
                "content": "# Intuition\\nAt any index $$idx$$, we have 3 choices:\\n- Buy a ticket for 1 day\\n- Buy a ticket for 7 days\\n- Buy a ticket for 30 days\\nWe have to find the **optimal set of choices** we should make to spend the least amount of money and complete all our travel plans. \\n\\n```\\nSuppose f(0) means the minimum cost incurred if you buy a pass\\nat the 0-th index in the array:[1,10,15]\\n\\nAt index 0:\\nTotal cost if you get a 1 day pass= costs[0] + f(1) //because you need to buy another ticket at index=1\\nTotal cost if you get a 7 day pass= costs[1] + f(1) //because the ticket you buy on day 1 will expire after day 6\\nf(0)= Math.min(1 day pass, 7 day pass)\\n\\nAs the 7 day pass expires on day 6, you still have to calculate f(10)\\n```\\nDoesn\\'t this repetitive nature of function calls hint at a DP solution? \\n\\n# Approach\\nDefine a function:\\n```\\nfunction memo(index){}\\n```\\nwhere $$memo(index)$$ means the minimum amount of money spent to complete your travel plans, if you start at the day at $$index$$ position in the array.\\n\\nAs we\\'re using only one parameter, we need a **1d dp array** to memoise results calculated by $$memo()$$\\n\\nTo deal with the availability of passes, assume you only had the option of a 1 day pass. How would memo function be called recursively?\\n```\\nmemo(index){\\n  int buy1DayPass = costs[0] + memo(index+1);\\n  return buy1DayPass;\\n}\\n```\\nWhat changed do you need to make to account for the 7/30 day passes?\\n**Just call memo(day after your current ticket expires)**\\n```\\nIf the array is: [1,5,10,20,22,50,60] and you had to calculate memo(2),\\nit would be:\\n\\nmemo(2){ // buy on day 10\\n  int buy30DayPass= costs[2]+ memo(5)//buy on day 50\\n}\\n```\\nAs $$memo(5)$$ returns the minimum cost incurred if you **start from the 50th day**, you will have the cost incurred if you buy a 30 day pass on the 10th day *if the only available option was a 30 day pass.*\\n\\nJust have to compute the minimum of all three choices.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nWe are calling each function only once before we store its result. \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        Integer[] dp = new Integer[days.length];\\n        return f(dp, days, costs, 0);\\n    }\\n\\n    public int f(Integer[] dp, int[] nums, int[] costs, int idx) {\\n        if (idx == nums.length) {\\n            return 0;\\n        }\\n        if (dp[idx] != null) {\\n            return dp[idx];\\n        }\\n        \\n        // Buy a 1-day pass:\\n        int one = costs[0] + f(dp, nums, costs, idx + 1);\\n        \\n        // Buy a 7-day pass:\\n        int week = Integer.MAX_VALUE;\\n        int k = idx;\\n        while (k < nums.length) {\\n            if (nums[idx] + 6 >= nums[k]) {\\n                k++;\\n            } else {\\n                break;\\n            }\\n        }\\n        week = costs[1] + f(dp, nums, costs, k);\\n        \\n        // Buy a 30-day pass:\\n        int month = Integer.MAX_VALUE;\\n        k = idx;\\n        while (k < nums.length) {\\n            if (nums[idx] + 29 >= nums[k]) {\\n                k++;\\n            } else {\\n                break;\\n            }\\n        }\\n        month = costs[2] + f(dp, nums, costs, k);\\n        \\n        int ret = Math.min(one, Math.min(week, month));\\n        return dp[idx] = ret; \\n    }\\n}\\n\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> dp(days.size());\\n    return f(dp, days, costs, 0);\\n}\\n\\nint f(vector<int>& dp, vector<int>& nums, vector<int>& costs, int idx) {\\n    if (idx == nums.size()) {\\n        return 0;\\n    }\\n    if (dp[idx] != 0) {\\n        return dp[idx];\\n    }\\n    //buy 1 day pass:\\n    int one = costs[0] + f(dp, nums, costs, idx + 1);\\n    //buy a weak\\n    int week = INT_MAX;\\n    int k = idx;\\n    while (k < nums.size()) {\\n        if (nums[idx] + 6 >= nums[k]) {\\n            k++;\\n        } else {\\n            break;\\n        }\\n    }\\n    week = costs[1] + f(dp, nums, costs, k);\\n    //buy a month\\n    int month = INT_MAX;\\n    k = idx;\\n    while (k < nums.size()) {\\n        if (nums[idx] + 29 >= nums[k]) {\\n            k++;\\n        } else {\\n            break;\\n        }\\n    }\\n    month = costs[2] + f(dp, nums, costs, k);\\n    int ret = min(one, min(week, month));\\n    return dp[idx] = ret;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nSuppose f(0) means the minimum cost incurred if you buy a pass\\nat the 0-th index in the array:[1,10,15]\\n\\nAt index 0:\\nTotal cost if you get a 1 day pass= costs[0] + f(1) //because you need to buy another ticket at index=1\\nTotal cost if you get a 7 day pass= costs[1] + f(1) //because the ticket you buy on day 1 will expire after day 6\\nf(0)= Math.min(1 day pass, 7 day pass)\\n\\nAs the 7 day pass expires on day 6, you still have to calculate f(10)\\n```\n```\\nfunction memo(index){}\\n```\n```\\nmemo(index){\\n  int buy1DayPass = costs[0] + memo(index+1);\\n  return buy1DayPass;\\n}\\n```\n```\\nIf the array is: [1,5,10,20,22,50,60] and you had to calculate memo(2),\\nit would be:\\n\\nmemo(2){ // buy on day 10\\n  int buy30DayPass= costs[2]+ memo(5)//buy on day 50\\n}\\n```\n```java []\\nclass Solution {\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        Integer[] dp = new Integer[days.length];\\n        return f(dp, days, costs, 0);\\n    }\\n\\n    public int f(Integer[] dp, int[] nums, int[] costs, int idx) {\\n        if (idx == nums.length) {\\n            return 0;\\n        }\\n        if (dp[idx] != null) {\\n            return dp[idx];\\n        }\\n        \\n        // Buy a 1-day pass:\\n        int one = costs[0] + f(dp, nums, costs, idx + 1);\\n        \\n        // Buy a 7-day pass:\\n        int week = Integer.MAX_VALUE;\\n        int k = idx;\\n        while (k < nums.length) {\\n            if (nums[idx] + 6 >= nums[k]) {\\n                k++;\\n            } else {\\n                break;\\n            }\\n        }\\n        week = costs[1] + f(dp, nums, costs, k);\\n        \\n        // Buy a 30-day pass:\\n        int month = Integer.MAX_VALUE;\\n        k = idx;\\n        while (k < nums.length) {\\n            if (nums[idx] + 29 >= nums[k]) {\\n                k++;\\n            } else {\\n                break;\\n            }\\n        }\\n        month = costs[2] + f(dp, nums, costs, k);\\n        \\n        int ret = Math.min(one, Math.min(week, month));\\n        return dp[idx] = ret; \\n    }\\n}\\n\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> dp(days.size());\\n    return f(dp, days, costs, 0);\\n}\\n\\nint f(vector<int>& dp, vector<int>& nums, vector<int>& costs, int idx) {\\n    if (idx == nums.size()) {\\n        return 0;\\n    }\\n    if (dp[idx] != 0) {\\n        return dp[idx];\\n    }\\n    //buy 1 day pass:\\n    int one = costs[0] + f(dp, nums, costs, idx + 1);\\n    //buy a weak\\n    int week = INT_MAX;\\n    int k = idx;\\n    while (k < nums.size()) {\\n        if (nums[idx] + 6 >= nums[k]) {\\n            k++;\\n        } else {\\n            break;\\n        }\\n    }\\n    week = costs[1] + f(dp, nums, costs, k);\\n    //buy a month\\n    int month = INT_MAX;\\n    k = idx;\\n    while (k < nums.size()) {\\n        if (nums[idx] + 29 >= nums[k]) {\\n            k++;\\n        } else {\\n            break;\\n        }\\n    }\\n    month = costs[2] + f(dp, nums, costs, k);\\n    int ret = min(one, min(week, month));\\n    return dp[idx] = ret;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349612,
                "title": "daily-leetcoding-challenge-march-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-cost-for-tickets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Day Variant)\n\n  \n**Approach 2:** Dynamic Programming (Window Variant)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-cost-for-tickets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Dynamic Programming (Day Variant)\n**Approach 2:** Dynamic Programming (Window Variant)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 928203,
                "title": "c-beats-100-0-dp-solution",
                "content": "Create a vector to calculate ticket price until the last day. If calculated day is not the planned day in given days vector, just copy previous day ticket price.\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = days[days.size()-1];\\n        vector<int> dp(lastDay+1, 0);\\n        int dayIndex = 0;\\n        for(int i=1; i<lastDay+1; i++){\\n            if(i != days[dayIndex]){\\n                dp[i] = dp[i-1];\\n            }\\n            else{\\n                dp[i] = min({dp[i-1] + costs[0], dp[max(0,i-7)] + costs[1], dp[max(0,i-30)] + costs[2]});\\n                dayIndex++;\\n            }\\n        }\\n        return dp[lastDay];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = days[days.size()-1];\\n        vector<int> dp(lastDay+1, 0);\\n        int dayIndex = 0;\\n        for(int i=1; i<lastDay+1; i++){\\n            if(i != days[dayIndex]){\\n                dp[i] = dp[i-1];\\n            }\\n            else{\\n                dp[i] = min({dp[i-1] + costs[0], dp[max(0,i-7)] + costs[1], dp[max(0,i-30)] + costs[2]});\\n                dayIndex++;\\n            }\\n        }\\n        return dp[lastDay];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895812,
                "title": "easy-dp-solution-100-faster-c-code-easy",
                "content": "### ***//The idea is to check for everyday and take minimum value each day***\\n **// If this is helpful then please upvote //**\\n\\n\\n\\n\\n        int mincostTickets(vector<int>& days, vector<int>& costs) {\\n         int n = (int)days.size();\\n         int nn = days[n-1];\\n        vector<int>dp(nn+1,0);\\n        int j = 0;\\n        int z = 0;\\n        for(int i = 1; i <= nn; i++){\\n            if(days[j] == i){\\n                j++;\\n                int a = INT_MAX, b = INT_MAX, c = INT_MAX;\\n                a = dp[i-1] + costs[0];\\n                b = dp[max(z,i-7)] + costs[1];\\n                c = dp[max(z,i-30)] + costs[2];\\n                dp[i] = min({a,b,c});\\n            }\\n            else dp[i] = dp[i-1];\\n        }\\n       \\n        return dp[nn];\\n    }",
                "solutionTags": [],
                "code": "### ***//The idea is to check for everyday and take minimum value each day***\\n **// If this is helpful then please upvote //**\\n\\n\\n\\n\\n        int mincostTickets(vector<int>& days, vector<int>& costs) {\\n         int n = (int)days.size();\\n         int nn = days[n-1];\\n        vector<int>dp(nn+1,0);\\n        int j = 0;\\n        int z = 0;\\n        for(int i = 1; i <= nn; i++){\\n            if(days[j] == i){\\n                j++;\\n                int a = INT_MAX, b = INT_MAX, c = INT_MAX;\\n                a = dp[i-1] + costs[0];\\n                b = dp[max(z,i-7)] + costs[1];\\n                c = dp[max(z,i-30)] + costs[2];\\n                dp[i] = min({a,b,c});\\n            }\\n            else dp[i] = dp[i-1];\\n        }\\n       \\n        return dp[nn];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 893668,
                "title": "c-0-ms-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size(), x = 0, y = 0;\\n        vector<int> dp(n+1, 0);\\n        dp[1] = min(costs[0], min(costs[1], costs[2]));\\n        for(int i = 1; i < days.size(); i++) {\\n            while(days[i] >=  days[x] + 7) x++;\\n            while(days[i] >=  days[y] + 30) y++;\\n            dp[i+1] = min(dp[i]+costs[0], min(dp[x]+costs[1], dp[y]+costs[2]));\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size(), x = 0, y = 0;\\n        vector<int> dp(n+1, 0);\\n        dp[1] = min(costs[0], min(costs[1], costs[2]));\\n        for(int i = 1; i < days.size(); i++) {\\n            while(days[i] >=  days[x] + 7) x++;\\n            while(days[i] >=  days[y] + 30) y++;\\n            dp[i+1] = min(dp[i]+costs[0], min(dp[x]+costs[1], dp[y]+costs[2]));\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868987,
                "title": "javascript",
                "content": "```javascript\\nfunction dp (days, costs) {\\n    const dp = Array(days[days.length - 1] + 1).fill(0);\\n\\tconst [cost1Day, cost7Day, cost30Day] = costs;\\n\\n\\tfor (let d of days) {\\n\\t\\tdp[d] = 1;\\n\\t}\\n\\n\\tfor (let i = 1; i <= days[days.length - 1]; i++) {\\n\\t\\tif (dp[i]) {\\n\\t\\t\\tdp[i] = Math.min(cost1Day + dp[i - 1], cost7Day + dp[Math.max(0, i - 7)], cost30Day + dp[Math.max(0, i - 30)]);\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp.pop();\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\nfunction dp (days, costs) {\\n    const dp = Array(days[days.length - 1] + 1).fill(0);\\n\\tconst [cost1Day, cost7Day, cost30Day] = costs;\\n\\n\\tfor (let d of days) {\\n\\t\\tdp[d] = 1;\\n\\t}\\n\\n\\tfor (let i = 1; i <= days[days.length - 1]; i++) {\\n\\t\\tif (dp[i]) {\\n\\t\\t\\tdp[i] = Math.min(cost1Day + dp[i - 1], cost7Day + dp[Math.max(0, i - 7)], cost30Day + dp[Math.max(0, i - 30)]);\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp.pop();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 821365,
                "title": "dp-top-down-recursion-explained-beats-94",
                "content": "\\n> Approach\\n1. On a particular day suppose `days[i]` we have `3` choices \\n\\t a. Buy a day pass. valid for `days[i]` only\\n\\t b. Buy a weekly pass, valid for `[days[i], days[i] + 7)` \\n\\t c. Buy a monthly pass, valid for `[days[i], days[i] + 30)`\\n\\t \\n2. We try out all the possiblities recursively, to find the min cost \\n3. Rest explaination is in comments\\n\\n> Algorithm \\n\\n```\\n\\tint n;\\n    vector<int> dp;\\n    \\n    int go(int i, vector<int> &days, vector<int> &costs) {\\n        if(i == n) {\\n\\t\\t\\t// all trips are done\\n            return 0;\\n        }\\n        // memoized result\\n        int &ans = dp[i];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n\\t\\t// arbirarily high value\\n        ans = INT_MAX;\\n        \\n        // buy daily pass, go to next day\\n        ans = min(ans, costs[0] + go(i+1, days, costs));\\n        \\n        // weekly pass, [days[i], days[i] + 7] ,\\n\\t\\t// and skip days that we already paid for\\n        int j = i;\\n        while(j < n && days[j] < days[i] + 7) {\\n            j += 1;\\n        }\\n        // go to jth day, our weekly pass date has expired \\n        ans = min(ans, costs[1] + go(j, days, costs));\\n        \\n        // buy monthly pass, [days[i], days[i] + 30]\\n\\t\\t// and skip days that we already paid for\\n        j = i;\\n        while(j < n && days[j] < days[i] + 30) {\\n            j += 1;\\n        }\\n        // go to jth day, our monthly pass expired \\n        ans = min(ans, costs[2] + go(j, days, costs));\\n        \\n        return ans;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        n = days.size();\\n        dp.assign(n, -1);\\n        return go(0, days, costs);\\n    }\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint n;\\n    vector<int> dp;\\n    \\n    int go(int i, vector<int> &days, vector<int> &costs) {\\n        if(i == n) {\\n\\t\\t\\t// all trips are done\\n            return 0;\\n        }\\n        // memoized result\\n        int &ans = dp[i];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n\\t\\t// arbirarily high value\\n        ans = INT_MAX;\\n        \\n        // buy daily pass, go to next day\\n        ans = min(ans, costs[0] + go(i+1, days, costs));\\n        \\n        // weekly pass, [days[i], days[i] + 7] ,\\n\\t\\t// and skip days that we already paid for\\n        int j = i;\\n        while(j < n && days[j] < days[i] + 7) {\\n            j += 1;\\n        }\\n        // go to jth day, our weekly pass date has expired \\n        ans = min(ans, costs[1] + go(j, days, costs));\\n        \\n        // buy monthly pass, [days[i], days[i] + 30]\\n\\t\\t// and skip days that we already paid for\\n        j = i;\\n        while(j < n && days[j] < days[i] + 30) {\\n            j += 1;\\n        }\\n        // go to jth day, our monthly pass expired \\n        ans = min(ans, costs[2] + go(j, days, costs));\\n        \\n        return ans;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        n = days.size();\\n        dp.assign(n, -1);\\n        return go(0, days, costs);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 810812,
                "title": "easy-to-understand-dp-python-with-explanation",
                "content": "**Explanation:**\\n\\ndp[i] means overall costs untill i-th day (included)\\nwe have to check two conditions:\\n\\n**1. i in days list:**\\nwe have three option:\\na) 1-pass:` dp[i] = dp[i-1] + costs[0]`\\nb) 7-pass: `dp[i] = dp[i-7] + costs[1]`\\nc) 30-pass:` dp[i] = dp[i-30] + costs[2]`\\n*in order to avoid negative index:*\\na) 1-pass:` dp[i] =dp[max(0,i-1)] + costs[0]`\\nb) 7-pass: `dp[i] = dp[max(0,i-7)] + costs[1]`\\nc) 30-pass:` dp[i] = dp[max(0,i-30)] + costs[2]`\\n**2. i not in days:**\\ndp[i] = dp[i-1] \\nwhich simply means we don\\'t have to spend money, and total costs remains same\\n\\n```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tdp=[0 for i in range(days[-1]+1)]\\n\\tdy = set(days)\\n\\tfor i in range(days[-1]+1):\\n\\t\\tif i not in dy: \\n\\t\\t\\tdp[i]=dp[i-1]\\n\\t\\telse: \\n\\t\\t\\tdp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n\\treturn dp[-1]\\n```\\n***\\n**Time complexity:** `O(n)`\\n**Space complexity:**` O(n)`\\nn = last day in days list + 1, time & space complexity max: `O(366)`",
                "solutionTags": [],
                "code": "```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tdp=[0 for i in range(days[-1]+1)]\\n\\tdy = set(days)\\n\\tfor i in range(days[-1]+1):\\n\\t\\tif i not in dy: \\n\\t\\t\\tdp[i]=dp[i-1]\\n\\t\\telse: \\n\\t\\t\\tdp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 786430,
                "title": "c-dp-recursion",
                "content": "```\\nint solve(vector<int>& days, int index, vector<int>& costs, vector<int>& dp){\\n        if(index == days.size()) return 0;\\n        if(dp[index] != -1) return dp[index];    //return the value if it was already calculated\\n        \\n        int sum = 0;\\n        int base = days[index];\\n        sum = costs[0] + solve(days, index+1, costs, dp);    //first find the sum for 1 day tickets\\n        auto i = upper_bound(days.begin(), days.end(), base + 7-1);\\n        sum = min(sum, costs[1] + solve(days, i - days.begin(), costs, dp));  //sum for 7 day tickets. since the array is sorted, i used binary search to find the required index\\n        auto j = upper_bound(days.begin(), days.end(), base + 30-1);  //find sum for 30 day ticket\\n        sum = min(sum, costs[2] + solve(days, j - days.begin(), costs, dp));\\n        return dp[index] = sum;   //store the value in dp and return it.\\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int d = days.size();\\n        vector<int> dp(d, -1);   //dp[i] stores the minimum cost to cover all days from i(inclusive) to n-1.\\n        int cost = solve(days, 0, costs, dp);\\n        return cost;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint solve(vector<int>& days, int index, vector<int>& costs, vector<int>& dp){\\n        if(index == days.size()) return 0;\\n        if(dp[index] != -1) return dp[index];    //return the value if it was already calculated\\n        \\n        int sum = 0;\\n        int base = days[index];\\n        sum = costs[0] + solve(days, index+1, costs, dp);    //first find the sum for 1 day tickets\\n        auto i = upper_bound(days.begin(), days.end(), base + 7-1);\\n        sum = min(sum, costs[1] + solve(days, i - days.begin(), costs, dp));  //sum for 7 day tickets. since the array is sorted, i used binary search to find the required index\\n        auto j = upper_bound(days.begin(), days.end(), base + 30-1);  //find sum for 30 day ticket\\n        sum = min(sum, costs[2] + solve(days, j - days.begin(), costs, dp));\\n        return dp[index] = sum;   //store the value in dp and return it.\\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int d = days.size();\\n        vector<int> dp(d, -1);   //dp[i] stores the minimum cost to cover all days from i(inclusive) to n-1.\\n        int cost = solve(days, 0, costs, dp);\\n        return cost;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746889,
                "title": "java-clean-code-with-memoization",
                "content": "Bottom up is so hard to come up with. Hence, be advised to start with recursion and get TLE and change it to memoization. Pretty simple, no?\\n\\nTime : O(n)\\nSpace : O(n)\\n\\nPlease let me know if you have any doubts. And do not forget to **upvote**.\\n\\n```java\\npublic int mincostTickets(int[] days, int[] costs) {\\n        \\n\\tint n = days.length;\\n\\n\\tInteger[] memo = new Integer[n];\\n\\n\\treturn minCostTicketsHelper(days, 0, costs, memo);\\n}\\n\\nprivate int minCostTicketsHelper(int[] days, int index, int[] costs, Integer[] memo) {\\n\\n\\tif (index >= days.length) return 0;\\n\\n\\tif (memo[index] != null) return memo[index];\\n\\n\\tint x = costs[0] + minCostTicketsHelper(days, index + 1, costs, memo);\\n\\n\\tint next = index;\\n\\tfor (; next < days.length && days[next] < days[index] + 7; next++);\\n\\n\\tint y = costs[1] + minCostTicketsHelper(days, next, costs, memo);\\n\\n\\tnext = index;\\n\\tfor (; next < days.length && days[next] < days[index] + 30; next++);\\n\\n\\tint z = costs[2] + minCostTicketsHelper(days, next, costs, memo);\\n\\n\\tmemo[index] = Math.min(x, Math.min(y, z));\\n\\treturn memo[index];\\n}",
                "solutionTags": [],
                "code": "Bottom up is so hard to come up with. Hence, be advised to start with recursion and get TLE and change it to memoization. Pretty simple, no?\\n\\nTime : O(n)\\nSpace : O(n)\\n\\nPlease let me know if you have any doubts. And do not forget to **upvote**.\\n\\n```java\\npublic int mincostTickets(int[] days, int[] costs) {\\n        \\n\\tint n = days.length;\\n\\n\\tInteger[] memo = new Integer[n];\\n\\n\\treturn minCostTicketsHelper(days, 0, costs, memo);\\n}\\n\\nprivate int minCostTicketsHelper(int[] days, int index, int[] costs, Integer[] memo) {\\n\\n\\tif (index >= days.length) return 0;\\n\\n\\tif (memo[index] != null) return memo[index];\\n\\n\\tint x = costs[0] + minCostTicketsHelper(days, index + 1, costs, memo);\\n\\n\\tint next = index;\\n\\tfor (; next < days.length && days[next] < days[index] + 7; next++);\\n\\n\\tint y = costs[1] + minCostTicketsHelper(days, next, costs, memo);\\n\\n\\tnext = index;\\n\\tfor (; next < days.length && days[next] < days[index] + 30; next++);\\n\\n\\tint z = costs[2] + minCostTicketsHelper(days, next, costs, memo);\\n\\n\\tmemo[index] = Math.min(x, Math.min(y, z));\\n\\treturn memo[index];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 666901,
                "title": "javascript-solution",
                "content": "```\\nvar mincostTickets = function(days, costs) {\\n    const lastDay = days[days.length - 1];\\n    const memo = new Map();\\n    const set = new Set(days);\\n    \\n    return dp(lastDay);\\n    \\n    function dp(day) {\\n        if (day <= 0) return 0;\\n        if (memo.has(day)) return memo.get(day);\\n        \\n        let res;\\n        \\n        if (!set.has(day)) {\\n            res = dp(day - 1);    \\n        } else {\\n            res = Math.min(\\n\\t\\t\\t\\tdp(day - 1) + costs[0], \\n\\t\\t\\t\\tdp(day - 7) + costs[1], \\n\\t\\t\\t\\tdp(day - 30) + costs[2]\\n\\t\\t\\t);\\n        }\\n        \\n        memo.set(day, res);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n```\\nvar mincostTickets = function(days, costs) {\\n    const lastDay = days[days.length - 1];\\n    const set = new Set(days);\\n    \\n    const dp = new Array(lastDay + 1).fill(0);\\n    \\n    for (let i = 1; i <= lastDay; i++) {\\n        if (!set.has(i)) dp[i] = dp[i - 1];\\n        else dp[i] = Math.min(\\n            dp[i - 1] + costs[0],\\n            dp[Math.max(0, i - 7)] + costs[1], \\n            dp[Math.max(0, i - 30)] + costs[2]\\n        );\\n    }\\n    \\n    return dp[lastDay];\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mincostTickets = function(days, costs) {\\n    const lastDay = days[days.length - 1];\\n    const memo = new Map();\\n    const set = new Set(days);\\n    \\n    return dp(lastDay);\\n    \\n    function dp(day) {\\n        if (day <= 0) return 0;\\n        if (memo.has(day)) return memo.get(day);\\n        \\n        let res;\\n        \\n        if (!set.has(day)) {\\n            res = dp(day - 1);    \\n        } else {\\n            res = Math.min(\\n\\t\\t\\t\\tdp(day - 1) + costs[0], \\n\\t\\t\\t\\tdp(day - 7) + costs[1], \\n\\t\\t\\t\\tdp(day - 30) + costs[2]\\n\\t\\t\\t);\\n        }\\n        \\n        memo.set(day, res);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307529,
                "title": "c-solution-using-upper-bound-beats-100",
                "content": "for each given day:\\n\\tfind the min cost using either 1-day,7-day,30-day pass\\nreturn min cost of last day of trip\\n\\nTo calculate cost using k-day pass\\n1.find highest trip day  which is <= (curr day-k)\\n2. add k-day pass value to the cost of trip day found in 1.\\n\\n```\\nint getVal(vector<int>& days, vector<int>& dp, int i,int cost,int day)\\n    {\\n        int val = cost;            \\n        int ind = (upper_bound(days.begin(),days.begin()+i,days[i]-day)-days.begin())-1;\\n        if(ind>=0)\\n            val+=dp[ind];\\n        return val;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        vector<int> dp(days.size());\\n        int val1,val2,val3;\\n        for(int i=0;i<days.size();i++)\\n        {\\n          val1 = getVal(days,dp,i,costs[0],1);            \\n          val2 = getVal(days,dp,i,costs[1],7);            \\n          val3 = getVal(days,dp,i,costs[2],30);            \\n          dp[i] = min(val1,min(val2,val3));   \\n        }\\n        return dp[days.size()-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getVal(vector<int>& days, vector<int>& dp, int i,int cost,int day)\\n    {\\n        int val = cost;            \\n        int ind = (upper_bound(days.begin(),days.begin()+i,days[i]-day)-days.begin())-1;\\n        if(ind>=0)\\n            val+=dp[ind];\\n        return val;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        vector<int> dp(days.size());\\n        int val1,val2,val3;\\n        for(int i=0;i<days.size();i++)\\n        {\\n          val1 = getVal(days,dp,i,costs[0],1);            \\n          val2 = getVal(days,dp,i,costs[1],7);            \\n          val3 = getVal(days,dp,i,costs[2],30);            \\n          dp[i] = min(val1,min(val2,val3));   \\n        }\\n        return dp[days.size()-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3352632,
                "title": "java-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, you can use dynamic programming to keep track of the minimum cost of traveling up to a certain day. You can start by creating an array to represent the days on which you will travel, marking those days as true. Then, for each day of the year, you need to decide whether to buy a 1-day pass, a 7-day pass, or a 30-day pass. You can do this by considering the cost of buying each type of pass, and choosing the option that gives you the lowest overall cost.\\n\\nTo make this decision, you need to look back at the previous days to see if you can save money by buying a pass that allows you to travel for multiple days. Specifically, for each day, you need to look back 7 and 30 days to see if you could have bought a pass on one of those days and still be covered for the current day. This is where dynamic programming comes in: you can use the dp array to keep track of the minimum cost up to the previous 7 or 30 days, and use that information to make your decision for the current day.\\n\\nAt the end, you return the minimum cost of traveling every day in the year, which is stored in the last element of the dp array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstep-by-step approach to solving the problem:\\n\\n1.Create a boolean array to represent the days on which you will travel. Mark those days as true.\\n2.Create a dynamic programming array dp of size 366 (to include a \"0\" day at the beginning).\\n3.Initialize dp[0] to 0.\\n4.For each day i from 1 to 365:\\n    i)If you are not traveling on day i, set dp[i] = dp[i-1].\\n    ii)If you are traveling on day i, consider three options:\\n        ->Buy a 1-day pass on day i: dp[i] = dp[i-1] + costs[0].\\n        ->Buy a 7-day pass on day i: dp[i] = dp[i-7] + costs[1].\\n        ->Buy a 30-day pass on day i: dp[i] = dp[i-30] + costs[2].\\n    iii)Choose the lowest cost among the three options: dp[i] = min(dp[i], min(dp[i-7], dp[i-30]) + corresponding cost).\\n5.Return dp[365] as the minimum cost of traveling every day in the year.\\n\\nThe idea is to use dynamic programming to keep track of the minimum cost of traveling up to a certain day. If you are not traveling on a particular day, you don\\'t need to buy a ticket, and you can just copy over the cost from the previous day. If you are traveling on a particular day, you need to consider the cost of buying a 1-day, 7-day, or 30-day pass, and choose the option that gives you the lowest overall cost.\\n\\nTo make this decision, you need to look back at the previous days to see if you can save money by buying a pass that allows you to travel for multiple days. You can use the dp array to keep track of the minimum cost up to the previous 7 or 30 days, and use that information to make your decision for the current day.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the above code is O(n), where n is the length of the days array. This is because we are iterating through each day in the year exactly once, and performing constant-time operations for each day.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the above code is O(1), since we are only using a fixed-size boolean array to represent the days on which we will travel, and a fixed-size array costs to represent the cost of different types of passes. We are also using a constant amount of space to keep track of the current minimum cost, so the space complexity is constant with respect to the length of the days array.\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[366]; // dynamic programming array\\n        boolean[] travelDays = new boolean[366]; // days on which we will travel\\n        \\n        for (int day : days) {\\n            travelDays[day] = true;\\n        }\\n        \\n        for (int i = 1; i <= 365; i++) {\\n            if (!travelDays[i]) {\\n                // if we\\'re not traveling on this day, we don\\'t need to buy a ticket\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            \\n            // if we\\'re traveling on this day, we need to decide which ticket to buy\\n            dp[i] = Math.min(dp[i-1] + costs[0], dp[Math.max(0, i-7)] + costs[1]);\\n            dp[i] = Math.min(dp[i], dp[Math.max(0, i-30)] + costs[2]);\\n        }\\n        \\n        return dp[365]; // return the cost of traveling every day in the year\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[366]; // dynamic programming array\\n        boolean[] travelDays = new boolean[366]; // days on which we will travel\\n        \\n        for (int day : days) {\\n            travelDays[day] = true;\\n        }\\n        \\n        for (int i = 1; i <= 365; i++) {\\n            if (!travelDays[i]) {\\n                // if we\\'re not traveling on this day, we don\\'t need to buy a ticket\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            \\n            // if we\\'re traveling on this day, we need to decide which ticket to buy\\n            dp[i] = Math.min(dp[i-1] + costs[0], dp[Math.max(0, i-7)] + costs[1]);\\n            dp[i] = Math.min(dp[i], dp[Math.max(0, i-30)] + costs[2]);\\n        }\\n        \\n        return dp[365]; // return the cost of traveling every day in the year\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351583,
                "title": "dp-beat-100-c",
                "content": "# Intuition\\n- First of all we are at index 0 .\\n- Now we have 3 types of passes 1day ,7day,30day , and we have to choose that pass so that i can plan the whole trip at minimum possible price.\\n- So we make call at all the three options and return the value which is minimum from all those options.\\n- And when we are out of the array then no other days remaining so just return 0 cost .\\n# Approach\\n-Used memoization and return the minimum possible cost at each stage.\\nIn second approach , i have made a solveTab function in which tabulation is done .\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) \\n\\n- Space complexity:\\nO(n) -> for the DP array to store the value at each stage and to prevent unneccessary subProblem calls which are already taken place.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*Approach One*/\\n    int solve(int idx,vector<int>& days, vector<int>& costs,vector<int>& dp){\\n        if(idx >= days.size())\\n            return 0;\\n\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n\\n        int ans = INT_MAX;\\n        //1 day pass\\n        ans = min(ans,costs[0] + solve(idx+1,days,costs,dp));\\n\\n        int i;\\n\\n        //7-day pass\\n        for(i=idx;i<days.size() && days[i]<days[idx]+7;i++);\\n        ans = min(ans,costs[1]+solve(i,days,costs,dp));\\n\\n        //30-days pass\\n        for(i=idx;i<days.size() && days[i]<days[idx]+30;i++);\\n        ans = min(ans,costs[2]+solve(i,days,costs,dp));\\n\\n        return dp[idx] = ans;\\n    }\\n/*Approach 2*/\\n    int solveTab(vector<int>& days, vector<int>& costs){\\n        int n = days.size();\\n        vector<int> dp(days.size()+1,0);\\n\\n        for(int idx=n-1;idx>=0;idx--){\\n\\n            int ans = INT_MAX;\\n\\n            //1 day pass\\n            ans = min(ans,costs[0] + dp[idx+1]);\\n\\n            int i;\\n\\n            //7-day pass\\n            for(i=idx;i<days.size() && days[i]<days[idx]+7;i++);\\n            ans = min(ans,costs[1]+dp[i]);\\n\\n            //30-days pass\\n            for(i=idx;i<days.size() && days[i]<days[idx]+30;i++);\\n            ans = min(ans,costs[2]+dp[i]);\\n\\n            dp[idx] = ans;\\n        }\\n        return dp[0];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n/*Approach 1*/\\n        // vector<int> dp(days.size(),-1);\\n        // return solve(0,days,costs,dp);\\n\\n/*Approach 2*/\\n        return solveTab(days,costs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*Approach One*/\\n    int solve(int idx,vector<int>& days, vector<int>& costs,vector<int>& dp){\\n        if(idx >= days.size())\\n            return 0;\\n\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n\\n        int ans = INT_MAX;\\n        //1 day pass\\n        ans = min(ans,costs[0] + solve(idx+1,days,costs,dp));\\n\\n        int i;\\n\\n        //7-day pass\\n        for(i=idx;i<days.size() && days[i]<days[idx]+7;i++);\\n        ans = min(ans,costs[1]+solve(i,days,costs,dp));\\n\\n        //30-days pass\\n        for(i=idx;i<days.size() && days[i]<days[idx]+30;i++);\\n        ans = min(ans,costs[2]+solve(i,days,costs,dp));\\n\\n        return dp[idx] = ans;\\n    }\\n/*Approach 2*/\\n    int solveTab(vector<int>& days, vector<int>& costs){\\n        int n = days.size();\\n        vector<int> dp(days.size()+1,0);\\n\\n        for(int idx=n-1;idx>=0;idx--){\\n\\n            int ans = INT_MAX;\\n\\n            //1 day pass\\n            ans = min(ans,costs[0] + dp[idx+1]);\\n\\n            int i;\\n\\n            //7-day pass\\n            for(i=idx;i<days.size() && days[i]<days[idx]+7;i++);\\n            ans = min(ans,costs[1]+dp[i]);\\n\\n            //30-days pass\\n            for(i=idx;i<days.size() && days[i]<days[idx]+30;i++);\\n            ans = min(ans,costs[2]+dp[i]);\\n\\n            dp[idx] = ans;\\n        }\\n        return dp[0];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n/*Approach 1*/\\n        // vector<int> dp(days.size(),-1);\\n        // return solve(0,days,costs,dp);\\n\\n/*Approach 2*/\\n        return solveTab(days,costs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351379,
                "title": "c-easiest-way-solved-solution-well-explained-approach-inution-tc-sc-gauravthinks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we will attempt with recursion then we will optimse time complexcity because of covering subproblems by 1 d dp\\nInstinct is that we will purchase tickets/vouchers just when we experience a substantial travelling day\\nThen at the end we\\'ll return the minimum of all the possibilities\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow you know the sub problems so we can convert OUR recursion solution to top-down-memoization , ie we store our answers at each step before returning, then if we already knows the answer , we can return right back without re calculating\\n\\n- For each day index of days array, three possibilities are considered:\\nFor each day that you need to buy a ticket you will try the three options\\n\\ni) Buying a one-day ticket and then continuing with the rest of the days\\nii) Buying a seven-day ticket and skipping all the days included in this ticket\\niii) Buying a thirty-day ticket and skipping all the days included in this ticket\\n as in top down DP approach, we store the results into the array(here in 1D array as needed) so that we can directly return the answer already stored if we traver again onto that index.\\nso before returning the answer at any index, we store it into the MEMO( DP ) array, for future use.\\nthis helps us reduce the time complexity(of recursive solution) from  3^n to much good(acchi acchi time complexity) time complexity;\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we travel only once throught the days array, \\nTC comes out to be : O(N) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe use extra space (in memoised solution) of size N,\\ntherefore O(N) space complexity\\n\\n# Code\\n```\\nclass Solution {\\n    //          RECURSIVE SOLUTION(MIGHT GIVE TLE)\\n    int helper(vector<int>& days, vector<int>& costs, int n, int ind){\\n                                    // base condition\\n        // if the index while traversing  goes out of bound, then the fucntion can not bring anything from there, so return 0 \\n    if(ind>=n) return 0; \\n\\n                              //  else we have three routes to go with, take one day,   take                                      one week or take one month package\\n  \\n    // to take one day voucher, we just add the cost[0] and move to the next index\\n    int one= costs[0]+ helper(days, costs, n, ind+1);\\n\\n    // to take 7 or 30 day vouchers, we need to check the forward index if they are avaiable, if available, take 7 day or 30 day vouchers\\n    int pointer;\\n    for( pointer=ind; pointer<n and days[pointer] < days[ind]+7; pointer++ );\\n     int seven=  costs[1]+ helper(days, costs, n, pointer);\\n     for( pointer=ind; pointer<n and days[pointer] < days[ind]+30; pointer++ );\\n    int thirty= costs[2]+ helper(days, costs, n, pointer);\\n\\n\\n//  at the end, return minimum of all the three possibilities \\n    return min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n= days.size();\\n        \\n        // helper(days, costs, n, starting index)\\n        return helper(days, costs,n, 0);\\n        \\n    }\\n};\\n```\\n```\\nclass Solution {\\n                          //          MEMOISED SOLUTION TO THE RECURSIVE ONE\\n    int helper(vector<int>& days, vector<int>& costs, int n, int ind, vector<int> &memo){\\n                                    // base condition\\n        // if the index while traversing  goes out of bound, then the fucntion can not bring anything from there, so return 0 \\n    if(ind>=n) return 0; \\n\\n                              //  else we have three routes to go with, take one day,   take                                      one week or take one month package\\n   if(memo[ind]!=-1) return memo[ind];\\n\\n    // to take one day voucher, we just add the cost[0] and move to the next index\\n    int one= costs[0]+ helper(days, costs, n, ind+1, memo);\\n\\n    // to take 7 or 30 day vouchers, we need to check the forward index if they are avaiable, if available, take 7 day or 30 day vouchers\\n    int pointer;\\n    for( pointer=ind; pointer<n and days[pointer] < days[ind]+7; pointer++ );\\n     int seven=  costs[1]+ helper(days, costs, n, pointer, memo);\\n     for( pointer=ind; pointer<n and days[pointer] < days[ind]+30; pointer++ );\\n    int thirty= costs[2]+ helper(days, costs, n, pointer, memo);\\n\\n\\n//  at the end, return minimum of all the three possibilities \\n    return memo[ind]= min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n= days.size();\\n        \\n        vector<int> memo(n, -1);\\n        // helper(days, costs, n, starting index)\\n        return helper(days, costs,n, 0, memo);\\n        \\n    }\\n};\\n```\\nIf you liked the solution and explanation, then do Upvote the solution and subscribe to our YouTube Channel down below.\\n\\n# @GauravThinks <----- youtube channel",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    //          RECURSIVE SOLUTION(MIGHT GIVE TLE)\\n    int helper(vector<int>& days, vector<int>& costs, int n, int ind){\\n                                    // base condition\\n        // if the index while traversing  goes out of bound, then the fucntion can not bring anything from there, so return 0 \\n    if(ind>=n) return 0; \\n\\n                              //  else we have three routes to go with, take one day,   take                                      one week or take one month package\\n  \\n    // to take one day voucher, we just add the cost[0] and move to the next index\\n    int one= costs[0]+ helper(days, costs, n, ind+1);\\n\\n    // to take 7 or 30 day vouchers, we need to check the forward index if they are avaiable, if available, take 7 day or 30 day vouchers\\n    int pointer;\\n    for( pointer=ind; pointer<n and days[pointer] < days[ind]+7; pointer++ );\\n     int seven=  costs[1]+ helper(days, costs, n, pointer);\\n     for( pointer=ind; pointer<n and days[pointer] < days[ind]+30; pointer++ );\\n    int thirty= costs[2]+ helper(days, costs, n, pointer);\\n\\n\\n//  at the end, return minimum of all the three possibilities \\n    return min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n= days.size();\\n        \\n        // helper(days, costs, n, starting index)\\n        return helper(days, costs,n, 0);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n                          //          MEMOISED SOLUTION TO THE RECURSIVE ONE\\n    int helper(vector<int>& days, vector<int>& costs, int n, int ind, vector<int> &memo){\\n                                    // base condition\\n        // if the index while traversing  goes out of bound, then the fucntion can not bring anything from there, so return 0 \\n    if(ind>=n) return 0; \\n\\n                              //  else we have three routes to go with, take one day,   take                                      one week or take one month package\\n   if(memo[ind]!=-1) return memo[ind];\\n\\n    // to take one day voucher, we just add the cost[0] and move to the next index\\n    int one= costs[0]+ helper(days, costs, n, ind+1, memo);\\n\\n    // to take 7 or 30 day vouchers, we need to check the forward index if they are avaiable, if available, take 7 day or 30 day vouchers\\n    int pointer;\\n    for( pointer=ind; pointer<n and days[pointer] < days[ind]+7; pointer++ );\\n     int seven=  costs[1]+ helper(days, costs, n, pointer, memo);\\n     for( pointer=ind; pointer<n and days[pointer] < days[ind]+30; pointer++ );\\n    int thirty= costs[2]+ helper(days, costs, n, pointer, memo);\\n\\n\\n//  at the end, return minimum of all the three possibilities \\n    return memo[ind]= min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n= days.size();\\n        \\n        vector<int> memo(n, -1);\\n        // helper(days, costs, n, starting index)\\n        return helper(days, costs,n, 0, memo);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351362,
                "title": "java-100-o-days-length",
                "content": "No need to iterate on all 365 days, we just need to iterate on each travelling day and find the earliest day for which a pass bought on that day would still be valid today\\n\\n```\\nclass Solution {\\n    \\n    // dp[i] = min cost to travel up to day i (inclusive)\\n    // = min  | dp[i-1] + day pass\\n    //        | dp[7_days_ago] + 7 days pass\\n    //        | dp[30_days_ago] + 30 days pass\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dayPass = costs[0];\\n        int weekPass = costs[1];\\n        int monthPass = costs[2];\\n        \\n        int n = days.length;\\n        \\n        int[] dp = new int[n+1];\\n        int w = 0; // index of earliest day within 7 days of today \\n        int m = 0; // index of earliest day within 30 days of today\\n        for(int i = 1; i<= n; i++){\\n            int today = days[i-1];\\n            while(days[w] <= today-7) w++;\\n            while(days[m] <= today-30) m++;\\n            \\n            int withDayPass = dp[i-1] + dayPass;\\n            int withWeekPass = dp[w] + weekPass;\\n            int withMonthPass = dp[m] + monthPass;\\n            dp[i] = Math.min(withDayPass, Math.min(withWeekPass, withMonthPass));\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // dp[i] = min cost to travel up to day i (inclusive)\\n    // = min  | dp[i-1] + day pass\\n    //        | dp[7_days_ago] + 7 days pass\\n    //        | dp[30_days_ago] + 30 days pass\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dayPass = costs[0];\\n        int weekPass = costs[1];\\n        int monthPass = costs[2];\\n        \\n        int n = days.length;\\n        \\n        int[] dp = new int[n+1];\\n        int w = 0; // index of earliest day within 7 days of today \\n        int m = 0; // index of earliest day within 30 days of today\\n        for(int i = 1; i<= n; i++){\\n            int today = days[i-1];\\n            while(days[w] <= today-7) w++;\\n            while(days[m] <= today-30) m++;\\n            \\n            int withDayPass = dp[i-1] + dayPass;\\n            int withWeekPass = dp[w] + weekPass;\\n            int withMonthPass = dp[m] + monthPass;\\n            dp[i] = Math.min(withDayPass, Math.min(withWeekPass, withMonthPass));\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351257,
                "title": "easy-to-understand-short-upper-bound-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> apply dp on 365 days..similar to striver soln\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\\n        if(ind<0){return 0;}\\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp);\\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\\n        indweek--;\\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\\n        indmonth--;\\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int>dp(366,-1);\\n        return helper(costs,days,n-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\\n        if(ind<0){return 0;}\\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp);\\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\\n        indweek--;\\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\\n        indmonth--;\\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int>dp(366,-1);\\n        return helper(costs,days,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350586,
                "title": "memoization",
                "content": "\\n# Approach\\nSimple memoization using three operations as increase by 1,7 or 30\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(vector<int>& days, vector<int>& costs, int idx, vector<int> &dp) {\\n        if(idx >= n) return 0;\\n        \\n        if(dp[idx] != -1) return dp[idx];\\n\\n        int i;\\n        int op1 = costs[0] + solve(days, costs, idx+1, dp);\\n        \\n        i=idx;\\n        while(i<n && days[i]<days[idx]+7){\\n            i++;\\n        }\\n        \\n        int op2 = costs[1] + solve(days, costs, i, dp);\\n        \\n    \\n        i=idx;\\n        while(i<n && days[i]<days[idx]+30){\\n            i++;\\n        }\\n            \\n        int op3 = costs[2] + solve(days, costs, i, dp);\\n        \\n        return dp[idx] = min({op1, op2,op3});\\n            \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        n = days.size();\\n        \\n        vector<int> dp(n+1, -1);\\n        \\n        return solve(days, costs, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(vector<int>& days, vector<int>& costs, int idx, vector<int> &dp) {\\n        if(idx >= n) return 0;\\n        \\n        if(dp[idx] != -1) return dp[idx];\\n\\n        int i;\\n        int op1 = costs[0] + solve(days, costs, idx+1, dp);\\n        \\n        i=idx;\\n        while(i<n && days[i]<days[idx]+7){\\n            i++;\\n        }\\n        \\n        int op2 = costs[1] + solve(days, costs, i, dp);\\n        \\n    \\n        i=idx;\\n        while(i<n && days[i]<days[idx]+30){\\n            i++;\\n        }\\n            \\n        int op3 = costs[2] + solve(days, costs, i, dp);\\n        \\n        return dp[idx] = min({op1, op2,op3});\\n            \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        n = days.size();\\n        \\n        vector<int> dp(n+1, -1);\\n        \\n        return solve(days, costs, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350359,
                "title": "easy-code-with-intuition-and-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using Dynamic Programming where we need to find the minimum cost required to travel all the days mentioned in the given list. We can use a recursive approach to solve the problem where we consider all the possibilities of buying 1-day, 7-day, and 30-day passes, and choose the minimum cost among them.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will create a recursive function where we pass the vector of days, costs, and the index of the current day. We will use memoization to store the already calculated results so that we do not have to recompute them. Inside the function, we will check if the result is already computed, if yes, we return the computed value. Otherwise, we will check if we have reached the end of the days, if yes, we return 0. Otherwise, we consider all the possibilities of buying passes for 1-day, 7-day, and 30-day and choose the minimum cost among them. We will calculate the index of the day when the pass expires using lower_bound function, and pass the updated index to the recursive function.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(n) where n is the number of days in the given list. This is because we are solving each subproblem only once and storing the results in the memoization table.\\n- Space complexity:\\nThe space complexity of the solution is O(n) where n is the number of days in the given list. This is because we are storing the results in the memoization table.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // vector to store the available passes\\n    vector<int> passes = {1, 7, 30};\\n    vector<int> memo; // memoization table to store the already computed results\\n    \\n    int minCost(vector<int>& days, vector<int>& costs, int index) {\\n        // If result already computed, return it\\n        if (memo[index] != -1) {\\n            return memo[index];\\n        }\\n        // If we have reached the end of the days, return 0\\n        if (index >= days.size()) {\\n            return memo[index] = 0;\\n        }\\n        int ans = INT_MAX;\\n        // Consider all possibilities of buying passes for 1-day, 7-day, and 30-day\\n        for (int i = 0; i < costs.size(); i++) {\\n            int passIndex = lower_bound(days.begin(), days.end(), passes[i] + days[index]) - days.begin();\\n            ans = min(ans, minCost(days, costs, passIndex) + costs[i]);\\n        }\\n        return memo[index] = ans;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memo.resize(days.size()+1, -1);\\n        return minCost(days, costs, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // vector to store the available passes\\n    vector<int> passes = {1, 7, 30};\\n    vector<int> memo; // memoization table to store the already computed results\\n    \\n    int minCost(vector<int>& days, vector<int>& costs, int index) {\\n        // If result already computed, return it\\n        if (memo[index] != -1) {\\n            return memo[index];\\n        }\\n        // If we have reached the end of the days, return 0\\n        if (index >= days.size()) {\\n            return memo[index] = 0;\\n        }\\n        int ans = INT_MAX;\\n        // Consider all possibilities of buying passes for 1-day, 7-day, and 30-day\\n        for (int i = 0; i < costs.size(); i++) {\\n            int passIndex = lower_bound(days.begin(), days.end(), passes[i] + days[index]) - days.begin();\\n            ans = min(ans, minCost(days, costs, passIndex) + costs[i]);\\n        }\\n        return memo[index] = ans;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memo.resize(days.size()+1, -1);\\n        return minCost(days, costs, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349689,
                "title": "go-dp",
                "content": "```\\nfunc mincostTickets(days []int, costs []int) int {\\n\\tvar dp [396]int\\n\\tfor _, d := range days {\\n\\t\\tdp[d] = 1\\n\\t}\\n\\tfor d := 365; d > 0; d-- {\\n\\t\\tif dp[d] == 0 {\\n\\t\\t\\tdp[d] = dp[d+1]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdp[d] = min(\\n\\t\\t\\tdp[d+1]+costs[0],\\n\\t\\t\\tdp[d+7]+costs[1],\\n\\t\\t\\tdp[d+30]+costs[2])\\n\\t}\\n\\treturn dp[1]\\n}\\n\\nfunc min(nums ...int) int {\\n\\tfor _, n := range nums {\\n\\t\\tif n < nums[0] {\\n\\t\\t\\tnums[0] = n\\n\\t\\t}\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mincostTickets(days []int, costs []int) int {\\n\\tvar dp [396]int\\n\\tfor _, d := range days {\\n\\t\\tdp[d] = 1\\n\\t}\\n\\tfor d := 365; d > 0; d-- {\\n\\t\\tif dp[d] == 0 {\\n\\t\\t\\tdp[d] = dp[d+1]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdp[d] = min(\\n\\t\\t\\tdp[d+1]+costs[0],\\n\\t\\t\\tdp[d+7]+costs[1],\\n\\t\\t\\tdp[d+30]+costs[2])\\n\\t}\\n\\treturn dp[1]\\n}\\n\\nfunc min(nums ...int) int {\\n\\tfor _, n := range nums {\\n\\t\\tif n < nums[0] {\\n\\t\\t\\tnums[0] = n\\n\\t\\t}\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084991,
                "title": "beats-100-in-both-time-and-space-easy-to-understand-o-n-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[366];\\n    int solve(vector<int>& days, vector<int>& costs, int i, int x){\\n        if(x<=0) return 0;\\n\\n        if(dp[x] != -1)\\n           return dp[x];\\n\\n        int cnt1=INT_MAX-1; int cnt2=INT_MAX-1; int cnt3=INT_MAX-1;\\n\\n        while(i>=0 && x<days[i]){\\n            i--;\\n        } if(i<0) return 0;\\n       \\n        cnt1=costs[0]+solve(days, costs, i, days[i]-1);\\n        cnt2=costs[1]+solve(days, costs, i, days[i]-7);\\n        cnt3=costs[2]+solve(days, costs, i, days[i]-30);\\n\\n       return dp[x]=min(cnt1, min(cnt2, cnt3));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(days, costs, days.size()-1, days[days.size()-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[366];\\n    int solve(vector<int>& days, vector<int>& costs, int i, int x){\\n        if(x<=0) return 0;\\n\\n        if(dp[x] != -1)\\n           return dp[x];\\n\\n        int cnt1=INT_MAX-1; int cnt2=INT_MAX-1; int cnt3=INT_MAX-1;\\n\\n        while(i>=0 && x<days[i]){\\n            i--;\\n        } if(i<0) return 0;\\n       \\n        cnt1=costs[0]+solve(days, costs, i, days[i]-1);\\n        cnt2=costs[1]+solve(days, costs, i, days[i]-7);\\n        cnt3=costs[2]+solve(days, costs, i, days[i]-30);\\n\\n       return dp[x]=min(cnt1, min(cnt2, cnt3));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(days, costs, days.size()-1, days[days.size()-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494543,
                "title": "c-top-down-dp-memoized-explained",
                "content": "**---- DO UPVOTE IF YOU LIKE MY EXPLAINATION :D ----\\n**\\nclass Solution {\\npublic:\\n    \\n        int util(vector<int>& days, vector<int>& costs, vector<int>& dp,int ind)\\n        {\\n            //base case, if we reach end of days, we dont have to travel anymore\\n            if(ind>=days.size()) return 0;\\n\\n            \\n            // return memoized solution if it exists\\n            if(dp[ind]!=-1) return dp[ind];\\n\\n            //choice 1 we take 1-day pass for a given day at index ind\\n            //then we add 1-day cost and calculate cost for remaining days\\n            int choice1  = costs[0] + util(days,costs,dp,ind+1);\\n            \\n            //now for choice 2 we take a 7-day pass for a given day at index ind\\n            //now we can skip upto 7 days from days[ind]\\n            //so if any of values in days array i.e. any of upcoming travel days fall in the next 7 days we can skip them\\n            //formally \\n            //  while (days[i]<days[ind]+7) \\n            // { \\n                    // skip \\n                    // i++ \\n            // } \\n            \\n            int i= ind;\\n\\n            while(i < days.size() && days[i]<days[ind]+7) i++;\\n            \\n            //now we add cost of choice2 and calculate cost for remaining days\\n            int choice2 = costs[1]+util(days,costs,dp,i);\\n\\n            //now for choice 3 we take a 30-day pass for a given day at index ind\\n            //now we can skip upto 30 days from days[ind]\\n            //so if any of values in days array i.e. any of upcoming travel days fall in the next 30 days we can skip them\\n            //formally \\n            //  while (days[i]<days[ind]+30) \\n            // { \\n                    // skip \\n                    // i++ \\n            // }             \\n            while(i < days.size() && days[i]<days[ind]+30) i++;\\n            \\n            //now we add cost of choice3 and calculate cost for remaining days\\n            int choice3 = costs[2]+util(days,costs,dp,i);\\n\\n            \\n            //now that we have calculated for all 3 choices, we simply return the minimum cost of these 3 choices\\n            return dp[ind]=min({choice1,choice2,choice3});\\n        }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n        vector<int> dp(days.size(),-1);\\n        int ans = util(days, costs,dp,0);\\n        return ans;\\n    }\\n        \\n        \\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n        int util(vector<int>& days, vector<int>& costs, vector<int>& dp,int ind)\\n        {\\n            //base case, if we reach end of days, we dont have to travel anymore\\n            if(ind>=days.size()) return 0;\\n\\n            \\n            // return memoized solution if it exists\\n            if(dp[ind]!=-1) return dp[ind];\\n\\n            //choice 1 we take 1-day pass for a given day at index ind\\n            //then we add 1-day cost and calculate cost for remaining days\\n            int choice1  = costs[0] + util(days,costs,dp,ind+1);\\n            \\n            //now for choice 2 we take a 7-day pass for a given day at index ind\\n            //now we can skip upto 7 days from days[ind]\\n            //so if any of values in days array i.e. any of upcoming travel days fall in the next 7 days we can skip them\\n            //formally \\n            //  while (days[i]<days[ind]+7) \\n            // { \\n                    // skip \\n                    // i++ \\n            // }",
                "codeTag": "Java"
            },
            {
                "id": 2415004,
                "title": "dp-recursive-solution-with-lower-bound-c-solution-beasts-90-submissions",
                "content": "```\\nint dp[366];\\n    int helper(vector<int>&days, vector<int>&costs, int idx){\\n        if(idx>=days.size())\\n            return 0;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        \\n        int ans1 = 0, ans2 = 0, ans3 = 0;\\n        // 1-day pass\\n        int i = lower_bound(days.begin(), days.end(), days[idx]+1)-days.begin();\\n        ans1 += costs[0] + helper(days,costs,i);\\n        // // 7-days pass\\n        i = lower_bound(days.begin(), days.end(), days[idx]+7)-days.begin();\\n        ans2 += costs[1] + helper(days,costs,i);\\n        // // 30-days pass\\n        i = lower_bound(days.begin(), days.end(), days[idx]+30)-days.begin();\\n        ans3 += costs[2] + helper(days,costs,i);\\n        \\n        return dp[idx] = min({ans1,ans2,ans3});\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(days,costs,0);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[366];\\n    int helper(vector<int>&days, vector<int>&costs, int idx){\\n        if(idx>=days.size())\\n            return 0;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        \\n        int ans1 = 0, ans2 = 0, ans3 = 0;\\n        // 1-day pass\\n        int i = lower_bound(days.begin(), days.end(), days[idx]+1)-days.begin();\\n        ans1 += costs[0] + helper(days,costs,i);\\n        // // 7-days pass\\n        i = lower_bound(days.begin(), days.end(), days[idx]+7)-days.begin();\\n        ans2 += costs[1] + helper(days,costs,i);\\n        // // 30-days pass\\n        i = lower_bound(days.begin(), days.end(), days[idx]+30)-days.begin();\\n        ans3 += costs[2] + helper(days,costs,i);\\n        \\n        return dp[idx] = min({ans1,ans2,ans3});\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(days,costs,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123226,
                "title": "python3-concise-bottom-up-dp",
                "content": "```\\n\"\"\"https://leetcode.com/problems/minimum-cost-for-tickets/\"\"\"\\n\\n\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        max_day = days[-1] + 1\\n        dp = [0] * max_day\\n        # dp[day] contains the minimum cost to cover the days up to the given day\\n        for day in range(1, max_day):\\n            if day in days:\\n                dp[day] = min(dp[day - 1] + costs[0], dp[max(day - 7, 0)] + costs[1], dp[max(day - 30, 0)] + costs[2])\\n            else:\\n                dp[day] = dp[day - 1]\\n\\n        return dp[-1]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\"\"\"https://leetcode.com/problems/minimum-cost-for-tickets/\"\"\"\\n\\n\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        max_day = days[-1] + 1\\n        dp = [0] * max_day\\n        # dp[day] contains the minimum cost to cover the days up to the given day\\n        for day in range(1, max_day):\\n            if day in days:\\n                dp[day] = min(dp[day - 1] + costs[0], dp[max(day - 7, 0)] + costs[1], dp[max(day - 30, 0)] + costs[2])\\n            else:\\n                dp[day] = dp[day - 1]\\n\\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 2021685,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int day: days) set.add(day);\\n        int n = days[days.length - 1];\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(!set.contains(i)){\\n                dp[i] = dp[i - 1];\\n                continue;\\n            }\\n            int a = dp[Math.max(0, i - 1)] + costs[0];\\n            int b = dp[Math.max(0, i - 7)] + costs[1];\\n            int c = dp[Math.max(0, i - 30)] + costs[2];\\n            dp[i] = Math.min(a, Math.min(b, c));\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int day: days) set.add(day);\\n        int n = days[days.length - 1];\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(!set.contains(i)){\\n                dp[i] = dp[i - 1];\\n                continue;\\n            }\\n            int a = dp[Math.max(0, i - 1)] + costs[0];\\n            int b = dp[Math.max(0, i - 7)] + costs[1];\\n            int c = dp[Math.max(0, i - 30)] + costs[2];\\n            dp[i] = Math.min(a, Math.min(b, c));\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867012,
                "title": "top-down-memoization",
                "content": "For every day we have 3 choices to buy pass .\\nWe can buy 1 day pass, 7 day pass or 30 day pass .\\nThis helps in breaking down the problem .\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dn = days.length;\\n        //System.out.println(\"dn = \" + dn);\\n        Integer[] memo = new Integer[dn];\\n        int minCost = minCost(0, days, costs, memo);\\n        return minCost;\\n    }\\n    \\n    \\n    private int minCost(int start, int[] days, int[] costs, Integer[] memo){\\n        int dn = days.length;\\n        \\n        // it cost 0 to travel for 0 days\\n        if(start >= dn){\\n            return 0;\\n        }\\n        \\n        // already know minCost of travel from days[start, end]\\n        if(memo[start] != null){\\n            return memo[start];\\n        }\\n        \\n        int minCost = Integer.MAX_VALUE;\\n        \\n        int cost = 0;\\n        // case 1 : buy 1-day pass\\n        int Day1Cost = costs[0] + minCost(start + 1, days, costs, memo);\\n        minCost = Math.min(Day1Cost, minCost);\\n        \\n        // case 2 : buy 7-day pass\\n        \\n        // find first index of x = days[start] + 7 day\\n\\t\\t// then we need to find minCost of travel from xth day till end\\n        int Day7Idx = findIndex(start + 1, days[start] + 7, days);\\n        int Day7Cost = costs[1] + minCost(Day7Idx, days, costs, memo);\\n        minCost = Math.min(Day7Cost, minCost);\\n        \\n        // case 3 : buy 30-day pass\\n\\t\\t// again I bought 30-day pass means I can travel \\n\\t\\t// from S till T days , where S = days[start] and T = days[start] + 30 - 1\\n\\t\\t// on this pass and need to find minCost for remaining days .\\n        int Day30Idx = findIndex(start + 1, days[start] + 30, days);\\n        //System.out.println(\"Day30Idx \" + Day30Idx);\\n        // return 0;\\n        int Day30Cost = costs[2] + minCost(Day30Idx, days, costs, memo);\\n        minCost = Math.min(Day30Cost, minCost);\\n        \\n\\t\\t// memo[start] = minCost for travel from days[start, tillEnd]\\n\\t\\t// minCost = mnimum of three cases \\n        memo[start] = minCost;\\n        return minCost;\\n    }\\n    \\n\\t/*\\n\\tReturns the index of lower bound of \\'target\\' .\\n\\tPortion of array which is considered here is\\n\\tdays[startIdx...tillEnd] .\\n\\t*/\\n    private int findIndex(int startIdx, int target, int[] days){\\n        int dn = days.length;\\n        int lo = startIdx, hi = dn, m;\\n        while(lo < hi){\\n            m = lo + (hi - lo) / 2;\\n            // System.out.println(days[m] + \" \" + target);\\n            if(days[m] < target){\\n                lo = m + 1;\\n            }\\n            else{\\n                hi = m;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dn = days.length;\\n        //System.out.println(\"dn = \" + dn);\\n        Integer[] memo = new Integer[dn];\\n        int minCost = minCost(0, days, costs, memo);\\n        return minCost;\\n    }\\n    \\n    \\n    private int minCost(int start, int[] days, int[] costs, Integer[] memo){\\n        int dn = days.length;\\n        \\n        // it cost 0 to travel for 0 days\\n        if(start >= dn){\\n            return 0;\\n        }\\n        \\n        // already know minCost of travel from days[start, end]\\n        if(memo[start] != null){\\n            return memo[start];\\n        }\\n        \\n        int minCost = Integer.MAX_VALUE;\\n        \\n        int cost = 0;\\n        // case 1 : buy 1-day pass\\n        int Day1Cost = costs[0] + minCost(start + 1, days, costs, memo);\\n        minCost = Math.min(Day1Cost, minCost);\\n        \\n        // case 2 : buy 7-day pass\\n        \\n        // find first index of x = days[start] + 7 day\\n\\t\\t// then we need to find minCost of travel from xth day till end\\n        int Day7Idx = findIndex(start + 1, days[start] + 7, days);\\n        int Day7Cost = costs[1] + minCost(Day7Idx, days, costs, memo);\\n        minCost = Math.min(Day7Cost, minCost);\\n        \\n        // case 3 : buy 30-day pass\\n\\t\\t// again I bought 30-day pass means I can travel \\n\\t\\t// from S till T days , where S = days[start] and T = days[start] + 30 - 1\\n\\t\\t// on this pass and need to find minCost for remaining days .\\n        int Day30Idx = findIndex(start + 1, days[start] + 30, days);\\n        //System.out.println(\"Day30Idx \" + Day30Idx);\\n        // return 0;\\n        int Day30Cost = costs[2] + minCost(Day30Idx, days, costs, memo);\\n        minCost = Math.min(Day30Cost, minCost);\\n        \\n\\t\\t// memo[start] = minCost for travel from days[start, tillEnd]\\n\\t\\t// minCost = mnimum of three cases \\n        memo[start] = minCost;\\n        return minCost;\\n    }\\n    \\n\\t/*\\n\\tReturns the index of lower bound of \\'target\\' .\\n\\tPortion of array which is considered here is\\n\\tdays[startIdx...tillEnd] .\\n\\t*/\\n    private int findIndex(int startIdx, int target, int[] days){\\n        int dn = days.length;\\n        int lo = startIdx, hi = dn, m;\\n        while(lo < hi){\\n            m = lo + (hi - lo) / 2;\\n            // System.out.println(days[m] + \" \" + target);\\n            if(days[m] < target){\\n                lo = m + 1;\\n            }\\n            else{\\n                hi = m;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577749,
                "title": "java-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        // using dfs as it is a decision tree\\n        // at each stage I can choose either 1/7/30 day pass\\n        // caching already visited indices\\n        return dfs(days, costs, 0, new int[days.length]);\\n    }\\n    \\n    private int dfs(int[] days, int[] costs, int index, int[] dp) {\\n        \\n        if(index >= days.length) {\\n            return 0;\\n        }\\n        \\n        // cached\\n        if(dp[index] > 0) {\\n            return dp[index];\\n        }\\n        \\n        \\n        // 1 Day Pass\\n        int cost1DayPass = costs[0] + dfs(days, costs, index+1, dp);\\n        \\n        // 7 Days Pass\\n        \\n        // Find next travel day when pass expires\\n        int i = index;\\n        \\n        while(i < days.length && days[i] < days[index] + 7) {\\n            i++;\\n        }\\n        \\n        int cost7DayPass = costs[1] + dfs(days, costs, i, dp);\\n        \\n        // 30 Days Pass\\n        \\n        // Find next travel day when pass expires\\n        i = index;\\n        \\n        while(i < days.length && days[i] < days[index] + 30) {\\n            i++;\\n        }\\n        \\n        int cost30DayPass = costs[2] + dfs(days, costs, i, dp);\\n        \\n        \\n        int result = Math.min(cost1DayPass, Math.min(cost7DayPass, cost30DayPass));\\n        \\n        dp[index] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        // using dfs as it is a decision tree\\n        // at each stage I can choose either 1/7/30 day pass\\n        // caching already visited indices\\n        return dfs(days, costs, 0, new int[days.length]);\\n    }\\n    \\n    private int dfs(int[] days, int[] costs, int index, int[] dp) {\\n        \\n        if(index >= days.length) {\\n            return 0;\\n        }\\n        \\n        // cached\\n        if(dp[index] > 0) {\\n            return dp[index];\\n        }\\n        \\n        \\n        // 1 Day Pass\\n        int cost1DayPass = costs[0] + dfs(days, costs, index+1, dp);\\n        \\n        // 7 Days Pass\\n        \\n        // Find next travel day when pass expires\\n        int i = index;\\n        \\n        while(i < days.length && days[i] < days[index] + 7) {\\n            i++;\\n        }\\n        \\n        int cost7DayPass = costs[1] + dfs(days, costs, i, dp);\\n        \\n        // 30 Days Pass\\n        \\n        // Find next travel day when pass expires\\n        i = index;\\n        \\n        while(i < days.length && days[i] < days[index] + 30) {\\n            i++;\\n        }\\n        \\n        int cost30DayPass = costs[2] + dfs(days, costs, i, dp);\\n        \\n        \\n        int result = Math.min(cost1DayPass, Math.min(cost7DayPass, cost30DayPass));\\n        \\n        dp[index] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569613,
                "title": "easy-c-recursive-and-memorization",
                "content": "Recursive solution\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs, int ind=0, int d=0) {\\n        int cost=INT_MAX;\\n        static int arr[3]={1,7,30};\\n        if(ind>=days.size())\\n            return 0;\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(d<days[ind])\\n                cost = min(costs[i]+mincostTickets(days, costs, ind+1, d+arr[i]), cost);\\n            else\\n                cost = min(cost, mincostTickets(days, costs, ind+1, d));\\n        }\\n        return cost;\\n    }\\n};\\n```\\nDynamic Programming\\n```\\nclass Solution {\\npublic:\\n    int dp[367];\\n     int count(vector<int> &days, vector<int> &costs, int d = 0, int ind = -1)\\n     {\\n         if (d > days[days.size() - 1])\\n             return 0;\\n         if (dp[d] != -1)\\n             return dp[d];\\n     \\n         for (int i = ind + 1; i < days.size(); i++)\\n         {\\n             if (days[i] > d)\\n             {\\n                 dp[d] = min(min(count(days, costs, days[i], i) + costs[0], count(days, costs, days[i] + 6, i) + costs[1]), count(days, costs, days[i] + 29, i) + costs[2]);\\n                 return dp[d];\\n             }\\n         }\\n         return 0;\\n     }\\n     int mincostTickets(vector<int> &days, vector<int> &costs)\\n     {\\n         memset(dp, -1, sizeof(dp));\\n         return count(days, costs);\\n     }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs, int ind=0, int d=0) {\\n        int cost=INT_MAX;\\n        static int arr[3]={1,7,30};\\n        if(ind>=days.size())\\n            return 0;\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(d<days[ind])\\n                cost = min(costs[i]+mincostTickets(days, costs, ind+1, d+arr[i]), cost);\\n            else\\n                cost = min(cost, mincostTickets(days, costs, ind+1, d));\\n        }\\n        return cost;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[367];\\n     int count(vector<int> &days, vector<int> &costs, int d = 0, int ind = -1)\\n     {\\n         if (d > days[days.size() - 1])\\n             return 0;\\n         if (dp[d] != -1)\\n             return dp[d];\\n     \\n         for (int i = ind + 1; i < days.size(); i++)\\n         {\\n             if (days[i] > d)\\n             {\\n                 dp[d] = min(min(count(days, costs, days[i], i) + costs[0], count(days, costs, days[i] + 6, i) + costs[1]), count(days, costs, days[i] + 29, i) + costs[2]);\\n                 return dp[d];\\n             }\\n         }\\n         return 0;\\n     }\\n     int mincostTickets(vector<int> &days, vector<int> &costs)\\n     {\\n         memset(dp, -1, sizeof(dp));\\n         return count(days, costs);\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428983,
                "title": "c-dp-6-lines",
                "content": "```\\n\\n```public:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        set<int>s(days.begin(),days.end());\\n        vector<int>dp(366,0);\\n        for(int i=1;i<366;i++)\\n        {\\n            if(s.find(i)==s.end())\\n            {\\n                dp[i]=dp[i-1];\\n            }\\n            else\\n            {\\n                dp[i]=min({costs[0]+dp[i-1],costs[1]+dp[max(0,i-7)],costs[2]+dp[max(0,i-30)]});\\n            }\\n        }\\n        return dp[365];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366312,
                "title": "c-commented-dp-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int m = days.size(), n = costs.size(), mx = *max_element(days.begin(),days.end());        \\n        vector<int> dp(mx+1,INT_MAX); // dp[i] is the minimum cost required upto ith day\\n        dp[0] = 0;\\n        unordered_set<int> st(days.begin(),days.end()); // To efficently check whether the day is a travel day or not\\n        for(int i = 1 ; i <= mx ; ++i) // Iterating over the maximum day in days array\\n        {\\n            if(st.count(i) == 0) // If there is no travel on that day then the cost is equal to the cost upto the previous day\\n                dp[i] = dp[i-1];\\n            else\\n            {\\n                dp[i] = min(dp[i],dp[i-1] + costs[0]); // Taking the minimum of the cost upto ith day and the minimum upto (i-1)th day and cost of 1 day ticket\\n                if(i - 7 >= 0)\\n                    dp[i] = min(dp[i],dp[i-7] + costs[1]); // Taking the minimum of the cost upto ith day and the minimum upto (i-7)th day and cost of 7 days ticket\\n                else \\n                    dp[i] = min(dp[i],costs[1]); // Considering the case where cost of 7 days ticket is lower \\n                if(i - 30 >= 0)\\n                    dp[i] = min(dp[i],dp[i-30] + costs[2]); // Taking the minimum of the cost upto ith day and the minimum upto (i-30)th day and cost of 30 days ticket\\n                else \\n                    dp[i] = min(dp[i],costs[2]); // Considering the case where cost of 30 days ticket is lower\\n            }\\n        }\\n        return dp[mx]; // dp[last day] stores the minimum cost upto the last day in days array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int m = days.size(), n = costs.size(), mx = *max_element(days.begin(),days.end());        \\n        vector<int> dp(mx+1,INT_MAX); // dp[i] is the minimum cost required upto ith day\\n        dp[0] = 0;\\n        unordered_set<int> st(days.begin(),days.end()); // To efficently check whether the day is a travel day or not\\n        for(int i = 1 ; i <= mx ; ++i) // Iterating over the maximum day in days array\\n        {\\n            if(st.count(i) == 0) // If there is no travel on that day then the cost is equal to the cost upto the previous day\\n                dp[i] = dp[i-1];\\n            else\\n            {\\n                dp[i] = min(dp[i],dp[i-1] + costs[0]); // Taking the minimum of the cost upto ith day and the minimum upto (i-1)th day and cost of 1 day ticket\\n                if(i - 7 >= 0)\\n                    dp[i] = min(dp[i],dp[i-7] + costs[1]); // Taking the minimum of the cost upto ith day and the minimum upto (i-7)th day and cost of 7 days ticket\\n                else \\n                    dp[i] = min(dp[i],costs[1]); // Considering the case where cost of 7 days ticket is lower \\n                if(i - 30 >= 0)\\n                    dp[i] = min(dp[i],dp[i-30] + costs[2]); // Taking the minimum of the cost upto ith day and the minimum upto (i-30)th day and cost of 30 days ticket\\n                else \\n                    dp[i] = min(dp[i],costs[2]); // Considering the case where cost of 30 days ticket is lower\\n            }\\n        }\\n        return dp[mx]; // dp[last day] stores the minimum cost upto the last day in days array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352703,
                "title": "a-very-easy-approach-dynamic-programming-fully-explained",
                "content": "# ****To Solve this problem we will take a dynamic array of size 366 and start travese it from one as dp[0] = 0 No cost for 0th day, Now for each day we will check the cost for 3 tickets and take minimum of it ----> Math.min(dp[i] =  dp[i-1] + costs[0] , dp[i] = dp[i-7] + costs[1], dp[i]  = dp[i-30] + costs[2]) this we will do when the ith day is in our days array otherwise we will simply store dp[i]= dp[i-1] and for optimisation we will break when our j pointer reaches days.length**\\n\\n\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dp[] = new int[366];\\n        dp[0]=0;\\n        int j=0;\\n        for(int i=1;i<366;i++){\\n            if(j==days.length){\\n                break;\\n            }\\n            \\n            if(days[j] != i){\\n                dp[i] = dp[i-1];\\n            }\\n            else{\\n                int one = dp[i-1] + costs[0];\\n                int seven = dp[Math.max(0,i-7)] + costs[1];\\n                int thirty = dp[Math.max(0,i-30)] + costs[2];\\n                dp[i] = Math.min(one, Math.min(seven, thirty));\\n                j++;\\n            }\\n        }\\n        return dp[days[days.length-1]];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dp[] = new int[366];\\n        dp[0]=0;\\n        int j=0;\\n        for(int i=1;i<366;i++){\\n            if(j==days.length){\\n                break;\\n            }\\n            \\n            if(days[j] != i){\\n                dp[i] = dp[i-1];\\n            }\\n            else{\\n                int one = dp[i-1] + costs[0];\\n                int seven = dp[Math.max(0,i-7)] + costs[1];\\n                int thirty = dp[Math.max(0,i-30)] + costs[2];\\n                dp[i] = Math.min(one, Math.min(seven, thirty));\\n                j++;\\n            }\\n        }\\n        return dp[days[days.length-1]];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219272,
                "title": "python-o-n-runtime-o-n-with-explanation",
                "content": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t#create the total costs for the days \\n        costForDays = [0 for _ in range(days[-1] + 1) ]\\n\\t\\t#since days are sorted in ascending order, we only need the index of the days we haven\\'t visited yet\\n        curIdx = 0\\n\\t\\t\\n        for d in range(1, len(costForDays)):\\n\\t\\t\\t#if we do not need to travel that day\\n\\t\\t\\t#we don\\'t need to add extra costs\\n            if d < days[curIdx]:\\n                costForDays[d] = costForDays[d - 1]\\n                continue\\n            \\n\\t\\t\\t#else this means we need to travel this day\\n\\t\\t\\t#find the cost if we were to buy a 1-day pass, 7-day pass and 30-day pass\\n            costs_extra_1 = costForDays[d - 1] + costs[0]\\n            costs_extra_7 = costForDays[max(0, d - 7)] + costs[1] \\n            costs_extra_30 = costForDays[max(0, d - 30)] + costs[2]\\n            \\n\\t\\t\\t#get the minimum value\\n            costForDays[d] = min(costs_extra_1, costs_extra_7, costs_extra_30)\\n\\t\\t\\t\\n\\t\\t\\t#update the index to the next day we need to travel\\n            curIdx += 1\\n\\t\\t\\t\\n        return costForDays[-1]\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t#create the total costs for the days \\n        costForDays = [0 for _ in range(days[-1] + 1) ]\\n\\t\\t#since days are sorted in ascending order, we only need the index of the days we haven\\'t visited yet\\n        curIdx = 0\\n\\t\\t\\n        for d in range(1, len(costForDays)):\\n\\t\\t\\t#if we do not need to travel that day\\n\\t\\t\\t#we don\\'t need to add extra costs\\n            if d < days[curIdx]:\\n                costForDays[d] = costForDays[d - 1]\\n                continue\\n            \\n\\t\\t\\t#else this means we need to travel this day\\n\\t\\t\\t#find the cost if we were to buy a 1-day pass, 7-day pass and 30-day pass\\n            costs_extra_1 = costForDays[d - 1] + costs[0]\\n            costs_extra_7 = costForDays[max(0, d - 7)] + costs[1] \\n            costs_extra_30 = costForDays[max(0, d - 30)] + costs[2]\\n            \\n\\t\\t\\t#get the minimum value\\n            costForDays[d] = min(costs_extra_1, costs_extra_7, costs_extra_30)\\n\\t\\t\\t\\n\\t\\t\\t#update the index to the next day we need to travel\\n            curIdx += 1\\n\\t\\t\\t\\n        return costForDays[-1]\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147589,
                "title": "c-recursive-solution-basic-thinking-2d-memoization",
                "content": "Our aim is here that we buy a ticket and keep a track of the day till which the last Bought is valid(This is stored in a valid variable). If the current day is less than that of valid then that means we do not need to buy a ticket at this day. \\n\\n```\\nclass Solution {\\npublic: int dp[366][366];\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return Solve(days, costs, 0, -1); \\n    }\\n    \\n    int Solve(vector <int>& days, vector <int>& cost, int curr, int valid) \\n    {\\n        if(curr == days.size())\\n            return 0; \\n        \\n        if(valid != -1 && days[curr] <= valid)\\n            return Solve(days, cost, curr + 1, valid);\\n        \\n        if(valid != -1 && dp[curr][valid] != -1)\\n            return dp[curr][valid];\\n        \\n        int res = INT_MAX; \\n        \\n        for(int k = 0; k <= 2; k++)\\n        {\\n            int temp; \\n            \\n            if(k == 0)\\n                temp = days[curr]; \\n            else if(k == 1)\\n                temp = days[curr] + 6; \\n            else if(k == 2)\\n                temp = days[curr] +  29; \\n\\t\\t\\t\\t\\n            //the number of days this ticket is valid for is stored in temp. \\n\\t\\t\\t\\n            res = min(res, cost[k] + Solve(days, cost, curr + 1, temp)); \\n        }\\n        \\n        return valid == -1 ? res : dp[curr][valid] = res;  // doing memo at valid = -1 would lead to a invalid index. \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: int dp[366][366];\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return Solve(days, costs, 0, -1); \\n    }\\n    \\n    int Solve(vector <int>& days, vector <int>& cost, int curr, int valid) \\n    {\\n        if(curr == days.size())\\n            return 0; \\n        \\n        if(valid != -1 && days[curr] <= valid)\\n            return Solve(days, cost, curr + 1, valid);\\n        \\n        if(valid != -1 && dp[curr][valid] != -1)\\n            return dp[curr][valid];\\n        \\n        int res = INT_MAX; \\n        \\n        for(int k = 0; k <= 2; k++)\\n        {\\n            int temp; \\n            \\n            if(k == 0)\\n                temp = days[curr]; \\n            else if(k == 1)\\n                temp = days[curr] + 6; \\n            else if(k == 2)\\n                temp = days[curr] +  29; \\n\\t\\t\\t\\t\\n            //the number of days this ticket is valid for is stored in temp. \\n\\t\\t\\t\\n            res = min(res, cost[k] + Solve(days, cost, curr + 1, temp)); \\n        }\\n        \\n        return valid == -1 ? res : dp[curr][valid] = res;  // doing memo at valid = -1 would lead to a invalid index. \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813844,
                "title": "concise-java-dp-o-n-beats-100",
                "content": "Idea is quite simple and it is based on the fact that at ``i-th`` day we can be in 3 possible conditions to minimize expenses:\\n* we buy 1-day pass, then min cost is ``1-day pass + min cost the day before`` i.e. ``costs[0] + minCost[i]``\\n* it is last day of 7-day pass, then min cost is ``7-day pass + min cost the day before we bought it`` i.e. ``costs[1] + minCost[i7]``\\n* it is last day of 30-day pass, then min cost is ``30-day pass + min cost the day before we bought it`` i.e. ``costs[2] + minCost[i30]``\\n\\n``i7`` and ``i30`` are indices of the day when week or month window starts and are being advanced as we go and ``minCost`` is where we keep min cost for every day. Min cost for ``i-th`` day is kept in ``minCost[i+1]`` so that min cost at day before ``i-th`` day is ``minCost[i]``. If there is no day before day/week/month window min cost will be 0 i.e. ``minCost[0]=0``.\\n\\nWhen we done the answer will be the last element in ``minCost``.\\n\\n```\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] minCost = new int[days.length + 1]; // DP to keep min cost at i + 1 day\\n        for (int i = 0, i7 = 0, i30 = 0; i < days.length; i++) {\\n            while (days[i] - days[i7] >= 7) i7++;    // advance week start\\n            while (days[i] - days[i30] >= 30) i30++; // advance month start\\n            int daily = costs[0] + minCost[i];\\n            int weekly = costs[1] + minCost[i7];\\n            int monthly = costs[2] + minCost[i30];\\n            minCost[i + 1] = Math.min(daily, Math.min(weekly, monthly));\\n        }\\n        return minCost[minCost.length - 1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] minCost = new int[days.length + 1]; // DP to keep min cost at i + 1 day\\n        for (int i = 0, i7 = 0, i30 = 0; i < days.length; i++) {\\n            while (days[i] - days[i7] >= 7) i7++;    // advance week start\\n            while (days[i] - days[i30] >= 30) i30++; // advance month start\\n            int daily = costs[0] + minCost[i];\\n            int weekly = costs[1] + minCost[i7];\\n            int monthly = costs[2] + minCost[i30];\\n            minCost[i + 1] = Math.min(daily, Math.min(weekly, monthly));\\n        }\\n        return minCost[minCost.length - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 811825,
                "title": "javascript-clean-recursive-dp",
                "content": "```javascript\\nvar mincostTickets = function(days, costs) {\\n    const [one, seven, thirty] = costs;\\n    const memo = new Map()\\n    \\n    function recurse(curr, idx) {\\n        if(memo.has(curr)) return memo.get(curr);\\n        if(idx >= days.length) return 0;\\n        if(curr >= days[idx]) return recurse(curr, idx+1);\\n        \\n        const buy1 = recurse(days[idx], idx) + one;\\n        const buy7 = recurse(days[idx]+6, idx) + seven;\\n        const buy30 = recurse(days[idx]+29, idx) + thirty;\\n        const min = Math.min(buy1, buy7, buy30);\\n        memo.set(curr, min);\\n        return min;\\n    }\\n    return recurse(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar mincostTickets = function(days, costs) {\\n    const [one, seven, thirty] = costs;\\n    const memo = new Map()\\n    \\n    function recurse(curr, idx) {\\n        if(memo.has(curr)) return memo.get(curr);\\n        if(idx >= days.length) return 0;\\n        if(curr >= days[idx]) return recurse(curr, idx+1);\\n        \\n        const buy1 = recurse(days[idx], idx) + one;\\n        const buy7 = recurse(days[idx]+6, idx) + seven;\\n        const buy30 = recurse(days[idx]+29, idx) + thirty;\\n        const min = Math.min(buy1, buy7, buy30);\\n        memo.set(curr, min);\\n        return min;\\n    }\\n    return recurse(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 790708,
                "title": "python-bottom-up-dp-with-video-explanation",
                "content": "# Time Complexity: O(max(days))\\n# Space Complexity: O(max(days))\\n\\nvideo explanation: https://www.youtube.com/watch?v=DDcTw8QaJ0s\\n\\n# CODE PYTHON\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        daySet = set(days)\\n        size = max(days)+1\\n        dp = [0] * size\\n        dp[0] = 0\\n        for i in range(1, size):\\n            if i in daySet:\\n                pass1 = dp[0] if i - 1 <= 0 else dp[i-1] \\n                pass7 = dp[0] if i - 7 <= 0 else dp[i-7]\\n                pass30 = dp[0] if i - 30 <= 0 else dp[i-30]\\n                \\n                dp[i] = min(pass1+costs[0], pass7+costs[1], pass30+costs[2])\\n            else:\\n                dp[i] = dp[i-1]\\n        return dp[size-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        daySet = set(days)\\n        size = max(days)+1\\n        dp = [0] * size\\n        dp[0] = 0\\n        for i in range(1, size):\\n            if i in daySet:\\n                pass1 = dp[0] if i - 1 <= 0 else dp[i-1] \\n                pass7 = dp[0] if i - 7 <= 0 else dp[i-7]\\n                pass30 = dp[0] if i - 30 <= 0 else dp[i-30]\\n                \\n                dp[i] = min(pass1+costs[0], pass7+costs[1], pass30+costs[2])\\n            else:\\n                dp[i] = dp[i-1]\\n        return dp[size-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746094,
                "title": "python-dp",
                "content": "Once we find the recurrence relation, it becomes a lot easier.\\n\\nCode:\\n```\\n        dp = [0]* (days[-1]+1)\\n        for i in range(1,len(dp)):\\n            if i not in days:   # keep the previous cost, do buy anything\\n                dp[i] = dp[i-1]\\n            else:\\n                dp[i] = min(dp[i-1]+costs[0], dp[max(0,i-7)]+costs[1], dp[max(0,i-30)]+costs[2])\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\n        dp = [0]* (days[-1]+1)\\n        for i in range(1,len(dp)):\\n            if i not in days:   # keep the previous cost, do buy anything\\n                dp[i] = dp[i-1]\\n            else:\\n                dp[i] = min(dp[i-1]+costs[0], dp[max(0,i-7)]+costs[1], dp[max(0,i-30)]+costs[2])\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673459,
                "title": "python-3-dp-easy-to-read-solution",
                "content": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n , max_days = len(days) , max(days)\\n        tickets_bought = [False for i in range(max_days + 1)]\\n        for day in days:\\n            tickets_bought[day] = True\\n        dp = [0 for i in range(max_days + 1)]\\n        for i in range(1 , max_days + 1):\\n            if not tickets_bought[i]:\\n                dp[i] = dp[i - 1]\\n            else:\\n                one_day_pass = dp[i - 1] + costs[0]\\n                seven_day_pass = dp[max(i - 7 , 0)] + costs[1]\\n                thirty_day_pass = dp[max(i - 30 , 0)] + costs[2]\\n                dp[i] = min(one_day_pass , seven_day_pass , thirty_day_pass)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n , max_days = len(days) , max(days)\\n        tickets_bought = [False for i in range(max_days + 1)]\\n        for day in days:\\n            tickets_bought[day] = True\\n        dp = [0 for i in range(max_days + 1)]\\n        for i in range(1 , max_days + 1):\\n            if not tickets_bought[i]:\\n                dp[i] = dp[i - 1]\\n            else:\\n                one_day_pass = dp[i - 1] + costs[0]\\n                seven_day_pass = dp[max(i - 7 , 0)] + costs[1]\\n                thirty_day_pass = dp[max(i - 30 , 0)] + costs[2]\\n                dp[i] = min(one_day_pass , seven_day_pass , thirty_day_pass)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613964,
                "title": "dp-unbounded-knapsackconcept",
                "content": "\\n    \\n    int ks(vector<int> days, int n, vector<int> cost, int day){\\n                \\n        int dp[n+1][day+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=day;j++){\\n                if(i==0) dp[i][j] = 0;\\n                else if(days[i-1]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    int res = cost[0] + dp[i-1][days[i-1]-1];\\n                    if(days[i-1]-7>=0){\\n                        res = min(res,cost[1] + dp[i-1][days[i-1]-7]);         \\n                    }else res = min(res,cost[1]);\\n                    if(days[i-1]-30>=0){\\n                        res = min(res,cost[2] + dp[i-1][days[i-1]-30]);\\n                    } else res = min(res,cost[2]);\\n                    dp[i][j] = res;\\n\\n                } \\n                    \\n            }\\n        }\\n        return dp[n][day];\\n\\t\\t\\n\\t\\t}\\n        \\n//         if(n==0) return 0;\\n//         if(days[n-1] > day ){\\n//             return ks(days,n-1,cost,day);\\n//         }\\n//         return min( cost[0] + ks(days,n-1,cost,days[n-1]-1), min( cost[1] + ks(days,n-1,cost,days[n-1]-7),\\n//                                   cost[2] + ks(days,n-1,cost,days[n-1]-30) ) );\\n        \\n    \\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        return ks(days,days.size(),costs, days[days.size()-1]);     \\n    }",
                "solutionTags": [],
                "code": "\\n    \\n    int ks(vector<int> days, int n, vector<int> cost, int day){\\n                \\n        int dp[n+1][day+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=day;j++){\\n                if(i==0) dp[i][j] = 0;\\n                else if(days[i-1]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    int res = cost[0] + dp[i-1][days[i-1]-1];\\n                    if(days[i-1]-7>=0){\\n                        res = min(res,cost[1] + dp[i-1][days[i-1]-7]);         \\n                    }else res = min(res,cost[1]);\\n                    if(days[i-1]-30>=0){\\n                        res = min(res,cost[2] + dp[i-1][days[i-1]-30]);\\n                    } else res = min(res,cost[2]);\\n                    dp[i][j] = res;\\n\\n                } \\n                    \\n            }\\n        }\\n        return dp[n][day];\\n\\t\\t\\n\\t\\t}\\n        \\n//         if(n==0) return 0;\\n//         if(days[n-1] > day ){\\n//             return ks(days,n-1,cost,day);\\n//         }\\n//         return min( cost[0] + ks(days,n-1,cost,days[n-1]-1), min( cost[1] + ks(days,n-1,cost,days[n-1]-7),\\n//                                   cost[2] + ks(days,n-1,cost,days[n-1]-30) ) );\\n        \\n    \\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        return ks(days,days.size(),costs, days[days.size()-1]);     \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 293195,
                "title": "python-4-liner-dp-easy-to-understand-explanation",
                "content": "This solution runs in O(total number of days). The most optimal solution runs in O(30 days) because that is the most days a single ticket can cover, but since we\\'re told this problem only extends for 365 days, I just coded this solution up. If you want to understand the O(30) days one, https://leetcode.com/problems/minimum-cost-for-tickets/discuss/226659/Two-DP-solutions-with-pictures explains it quite well here. If the interviewer asks this question with an unlimited or very high number of days, you should implement the O(30) solution. If I have time, I will try to write it in Python. \\n\\nBeginner explanation for easy to code solution: If you do DP problems, you\\'ll notice most start with a 1D or 2D array. In this case, we can do this with a 1D array. We create a dparry with `number of days +1` elements so that we can have index 0 be 0. This is so we don\\'t run into out of bounds errors. \\n\\nFor day i, we look backward to see what kind of ticket we should buy. We look backward for i-1, i-7, i-30 days and see how much we already paid for tickets on those days and add the cost of one ticket for 1, 7, or 30 days. We\\'re looking to spend the least amount of money, so we look to take the value that is the smallest out of the three. \\n\\nThis is: \\n```\\nmin(dp[max(0, i-1)] + costs[0],  #min cost if we buy 1 day ticket for our current day\\n\\tdp[max(0, i-7)] + costs[1],  #min cost if we buy 7 day ticket for our current day, so we look 7 days previous to see what we paid\\n\\tdp[max(0, i-30)] + costs[2]) #min cost if we buy 30 day ticket for our current day, so we look 30 days previous to see what we paid\\n```\\n\\nIf during our for loop we loop through a day that isn\\'t one of our travel days, we just use the value in the prior index.  `else dp[max(0, i-1)]`\\n\\nSo, at every day we are on, we know that the minimum amount of money we need to spend on the days before us are all correct, so we just build on those results, one day at a time. We return the least amount of money, which is dp[-1]. \\n\\nCoding style tips: I use to do code that would look like: \"if i-1 >= 0, if i-7>= 0, if i-30 >=0\" clauses to make sure I wouldn\\'t go out of bounds for arrays, but if you use max(0, i-#) it makes the code look much better. \\n\\nRuntime + Space: O(number of days + 1)\\nI did try out totaldays = days[-1] and days = set(days) so that when we check if i is in days we\\'re not looping through the entire array and can just check O(1) for set, but the runtime is the same because we\\'re only checking 365 days max. \\n\\n```\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0 for i in range(days[-1] + 1)]\\n        for i in range(days[-1] + 1):\\n            dp[i] = min(dp[max(0, i-1)] + costs[0], dp[max(0, i-7)] + costs[1], dp[max(0, i-30)] + costs[2]) if i in days else dp[max(0, i-1)]\\n        return dp[-1]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nmin(dp[max(0, i-1)] + costs[0],  #min cost if we buy 1 day ticket for our current day\\n\\tdp[max(0, i-7)] + costs[1],  #min cost if we buy 7 day ticket for our current day, so we look 7 days previous to see what we paid\\n\\tdp[max(0, i-30)] + costs[2]) #min cost if we buy 30 day ticket for our current day, so we look 30 days previous to see what we paid\\n```\n```\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0 for i in range(days[-1] + 1)]\\n        for i in range(days[-1] + 1):\\n            dp[i] = min(dp[max(0, i-1)] + costs[0], dp[max(0, i-7)] + costs[1], dp[max(0, i-30)] + costs[2]) if i in days else dp[max(0, i-1)]\\n        return dp[-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 273012,
                "title": "python-dp",
                "content": "For each day that we need to travel, we can use either 1/7/30-day pass depend on the cost.\\n\\nSuppose ```dp[i]``` is the lowest cost till ```day i``` and ```one```, ```seven```, ```thirty``` are costs for 1-day, 7-day, 30-day pass accordingly. \\nIf ```day i``` is when we have to travel, we need to use a ticket, then ```dp[i] = min(dp[i-1]+one, dp[i-7]+seven, dp[i-30]+thirty)```. \\nOtherwise, we don\\'t need a ticket so there\\'s no extra cost, ```dp[i] = dp[i-1]```.\\n\\nAnd when i<7 or i<30, 7 and 30-day pass are still possible to lower down our cost, so I use ```dp[max(i-7), 0]+seven``` and ```dp[max(i-30),0]+thirty``` instead. In that case, we just buy a 7/30-day pass on day 0.\\n```\\ndef mincostTickets(days, costs):\\n\\tn, plans, days = max(days)+1, [1,7,30], set(days)\\n\\tdp = [0] * n\\n\\tfor i in range(n):\\n\\t\\tdp[i] = min((dp[max(0,i-p)]+c for p,c in zip(plans, costs))) if i in days else dp[i-1]\\n\\treturn dp[n-1]\\n```\\n\\nAnd actually we don\\'t have to iterate those days we don\\'t travel, especially for those large and sparse cases. \\nI use ```dp[prev:curr] = [dp[prev]] * (curr-prev)``` to reduce number of iteration as ```dp[i]=dp[i-1]``` when we don\\'t travel. Therefore, we only need to iterate the days we do travel.\\n```\\ndef mincostTickets(days, costs):\\n\\tdp, prev, plans = [0] * (max(days) + 1), 0, [1,7,30]\\n\\tfor curr in days:\\n\\t\\tdp[prev:curr] = [dp[prev]] * (curr-prev)\\n\\t\\tdp[curr], prev = min(dp[max(curr-p, 0)]+c for p,c in zip(plans, costs)), curr\\n\\treturn dp[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[i]```\n```day i```\n```one```\n```seven```\n```thirty```\n```day i```\n```dp[i] = min(dp[i-1]+one, dp[i-7]+seven, dp[i-30]+thirty)```\n```dp[i] = dp[i-1]```\n```dp[max(i-7), 0]+seven```\n```dp[max(i-30),0]+thirty```\n```\\ndef mincostTickets(days, costs):\\n\\tn, plans, days = max(days)+1, [1,7,30], set(days)\\n\\tdp = [0] * n\\n\\tfor i in range(n):\\n\\t\\tdp[i] = min((dp[max(0,i-p)]+c for p,c in zip(plans, costs))) if i in days else dp[i-1]\\n\\treturn dp[n-1]\\n```\n```dp[prev:curr] = [dp[prev]] * (curr-prev)```\n```dp[i]=dp[i-1]```\n```\\ndef mincostTickets(days, costs):\\n\\tdp, prev, plans = [0] * (max(days) + 1), 0, [1,7,30]\\n\\tfor curr in days:\\n\\t\\tdp[prev:curr] = [dp[prev]] * (curr-prev)\\n\\t\\tdp[curr], prev = min(dp[max(curr-p, 0)]+c for p,c in zip(plans, costs)), curr\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 245595,
                "title": "java-easy-to-understand-dp-solution-3ms-beats-100",
                "content": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int days_cost[] = new int[366];\\n        for(int i = 0; i < days.length; i++)\\n            days_cost[days[i]] = 1;\\n        \\n        for(int i = 1; i < 366; i++) {\\n            if(days_cost[i] == 0)\\n                days_cost[i] = days_cost[i - 1];\\n            else\\n                days_cost[i] = Math.min(costs[0] + days_cost[i - 1], Math.min(costs[1] + days_cost[Math.max(0, i - 7)], \\n                                                                             costs[2] + days_cost[Math.max(0, i - 30)]));\\n        }\\n        \\n        return days_cost[days[n - 1]];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int days_cost[] = new int[366];\\n        for(int i = 0; i < days.length; i++)\\n            days_cost[days[i]] = 1;\\n        \\n        for(int i = 1; i < 366; i++) {\\n            if(days_cost[i] == 0)\\n                days_cost[i] = days_cost[i - 1];\\n            else\\n                days_cost[i] = Math.min(costs[0] + days_cost[i - 1], Math.min(costs[1] + days_cost[Math.max(0, i - 7)], \\n                                                                             costs[2] + days_cost[Math.max(0, i - 30)]));\\n        }\\n        \\n        return days_cost[days[n - 1]];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237632,
                "title": "4ms-solution-in-c",
                "content": "Thanks to https://leetcode.com/problems/minimum-cost-for-tickets/discuss/226670/Java-DP-Solution-with-explanation-O(n).\\n```\\nint min(int x, int y, int z)\\n{\\n    if (x < y)\\n        return x < z ? x : z;\\n    return y < z ? y : z;\\n}\\n\\nint max(int x, int y) { return x > y ? x : y; }\\n\\nint mincostTickets(int *days, int daysSize, int *costs, int costsSize)\\n{\\n    bool day_list[366] = { false };\\n    int dp[366];\\n\\n    for (int i = 0; i < daysSize; ++i)\\n        day_list[days[i]] = true;\\n\\n    dp[0] = 0;\\n    for (int i = 1; i < 366; ++i) {\\n        if (!day_list[i]) {\\n            dp[i] = dp[i - 1];\\n            continue;\\n        }\\n\\n        dp[i] = min(dp[i - 1] + costs[0],\\n                    dp[max(0, i - 7)] + costs[1],\\n                    dp[max(0, i - 30)] + costs[2]);\\n    }\\n\\n    return dp[365];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint min(int x, int y, int z)\\n{\\n    if (x < y)\\n        return x < z ? x : z;\\n    return y < z ? y : z;\\n}\\n\\nint max(int x, int y) { return x > y ? x : y; }\\n\\nint mincostTickets(int *days, int daysSize, int *costs, int costsSize)\\n{\\n    bool day_list[366] = { false };\\n    int dp[366];\\n\\n    for (int i = 0; i < daysSize; ++i)\\n        day_list[days[i]] = true;\\n\\n    dp[0] = 0;\\n    for (int i = 1; i < 366; ++i) {\\n        if (!day_list[i]) {\\n            dp[i] = dp[i - 1];\\n            continue;\\n        }\\n\\n        dp[i] = min(dp[i - 1] + costs[0],\\n                    dp[max(0, i - 7)] + costs[1],\\n                    dp[max(0, i - 30)] + costs[2]);\\n    }\\n\\n    return dp[365];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237530,
                "title": "python-straight-forward-dp-solution-100",
                "content": "```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        # min cost for travelling till day i\\n        dp = [float(\\'inf\\')] * (days[-1] + 1)\\n        dp[0] = 0\\n        travel_days = set(days)\\n        for i in range(1, days[-1] + 1):\\n            if i not in travel_days:\\n                dp[i] = dp[i - 1]\\n            else:\\n                # 1-day pass\\n                dp[i] = min(dp[i], dp[i - 1] + costs[0])\\n                \\n                # 7-day pass\\n                if i <= 7:\\n                    dp[i] = min(dp[i], costs[1])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - 7] + costs[1])\\n                    \\n                # 30-day pass\\n                if i <= 30:\\n                    dp[i] = min(dp[i], costs[2])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - 30] + costs[2])\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        # min cost for travelling till day i\\n        dp = [float(\\'inf\\')] * (days[-1] + 1)\\n        dp[0] = 0\\n        travel_days = set(days)\\n        for i in range(1, days[-1] + 1):\\n            if i not in travel_days:\\n                dp[i] = dp[i - 1]\\n            else:\\n                # 1-day pass\\n                dp[i] = min(dp[i], dp[i - 1] + costs[0])\\n                \\n                # 7-day pass\\n                if i <= 7:\\n                    dp[i] = min(dp[i], costs[1])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - 7] + costs[1])\\n                    \\n                # 30-day pass\\n                if i <= 30:\\n                    dp[i] = min(dp[i], costs[2])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - 30] + costs[2])\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227412,
                "title": "java-solution-dfs-with-memory-dp-solution",
                "content": "I was not able to come up with the DP solution at first. Therefore, I used a hashmap to record calculated data along the way. \\nThe solution still beat 50%, so I\\'d like to share it for reference.\\n```\\nclass Solution {\\n    Map<Integer, Integer> cache = new HashMap<>();\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        return dfs(days, 0, costs, -1);\\n    }\\n    \\n    private int dfs(int[] days, int index, int[] costs, int endDay) {\\n        if (index == days.length) {\\n            return 0;\\n        }\\n        if (endDay >= days[index]) {\\n            return dfs(days, index + 1, costs, endDay);\\n        } else if (cache.containsKey(days[index])) {\\n            return cache.get(days[index]);\\n        } else {\\n            int cost0 = costs[0] + dfs(days, index + 1, costs, days[index]);\\n            int cost1 = costs[1] + dfs(days, index + 1, costs, days[index] + 6);\\n            int cost2 = costs[2] + dfs(days, index + 1, costs, days[index] + 29);\\n            int minCost = Math.min(cost0, Math.min(cost1, cost2));\\n            cache.put(days[index], minCost);\\n            return minCost;\\n        }\\n    }\\n}\\n```\\n\\nDP solution attached. Considering the input length `n <= 365`, the space complexity can be treated as `O(1)`. Time complexity is tricky, it can be treated as O(1) becasue each day can be iterated at most `30 + 7` times, and there are at most 365 days. Or we can treat it as O(n).\\n```\\nclass Solution {\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) {\\n            return 0;\\n        }\\n        int n = days.length;\\n        int[][] dp = new int[n][3];\\n        for (int i = 0; i < 3; i++) {\\n            dp[0][i] = costs[i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            int today = days[i];\\n            int cost0 = dp[i - 1][0] + costs[0];\\n            for (int j = i - 1; j >= 0 && days[j] + 30 > today; j--) {\\n                cost0 = Math.min(cost0, dp[j][2]);\\n            }\\n            for (int j = i - 1; j >= 0 && days[j] + 7 > today; j--) {\\n                cost0 = Math.min(cost0, dp[j][1]);\\n            }\\n            dp[i][0] = cost0;\\n            dp[i][1] = dp[i - 1][0] + costs[1];\\n            dp[i][2] = dp[i - 1][0] + costs[2];\\n        }\\n        return dp[n - 1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> cache = new HashMap<>();\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        return dfs(days, 0, costs, -1);\\n    }\\n    \\n    private int dfs(int[] days, int index, int[] costs, int endDay) {\\n        if (index == days.length) {\\n            return 0;\\n        }\\n        if (endDay >= days[index]) {\\n            return dfs(days, index + 1, costs, endDay);\\n        } else if (cache.containsKey(days[index])) {\\n            return cache.get(days[index]);\\n        } else {\\n            int cost0 = costs[0] + dfs(days, index + 1, costs, days[index]);\\n            int cost1 = costs[1] + dfs(days, index + 1, costs, days[index] + 6);\\n            int cost2 = costs[2] + dfs(days, index + 1, costs, days[index] + 29);\\n            int minCost = Math.min(cost0, Math.min(cost1, cost2));\\n            cache.put(days[index], minCost);\\n            return minCost;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) {\\n            return 0;\\n        }\\n        int n = days.length;\\n        int[][] dp = new int[n][3];\\n        for (int i = 0; i < 3; i++) {\\n            dp[0][i] = costs[i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            int today = days[i];\\n            int cost0 = dp[i - 1][0] + costs[0];\\n            for (int j = i - 1; j >= 0 && days[j] + 30 > today; j--) {\\n                cost0 = Math.min(cost0, dp[j][2]);\\n            }\\n            for (int j = i - 1; j >= 0 && days[j] + 7 > today; j--) {\\n                cost0 = Math.min(cost0, dp[j][1]);\\n            }\\n            dp[i][0] = cost0;\\n            dp[i][1] = dp[i - 1][0] + costs[1];\\n            dp[i][2] = dp[i - 1][0] + costs[2];\\n        }\\n        return dp[n - 1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226994,
                "title": "the-easiest-way-c-with-simple-array",
                "content": "everyday from Jan 1 to itself either cost   1-day ticket + yesterday\\'s cost      or         7-day ticket + the cost 7 day\\'s ago             or                30-day ticket + the cost 30 day\\'s before\\nso the solution below :\\n\\nfrom day 1 to day 6  can only buy a one day ticket\\n```\\nfor(int i = 1;i < 7;++i){\\n\\tanswer[i] = answer[i - 1] + need[i] * costs[0];// another array bool need[366] stores whether you\\'ll travel or not\\n}\\n```\\nfrom day 7 to day 29 you may have two choices : one-day ticket    or   7-day ticket\\n```\\nfor(int i = 7;i < 30;++i){\\n\\tanswer[i] = min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]);\\n}\\n```\\nand all the other days you have three choices \\ncode below : \\n```\\nfor(int i = 30;i < 366;++i){\\n\\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n}\\n```\\n\\nthe full code is here : \\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int answer[366] = {};\\n        bool need[366] = {};\\n        for(auto &i : days)need[i] = true;\\n        for(int i = 1;i < 7;++i){\\n        \\tanswer[i] = answer[i - 1] + need[i] * costs[0];\\n        }\\n        for(int i = 7;i < 30;++i){\\n        \\tanswer[i] = min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]);\\n        }\\n        for(int i = 30;i < 366;++i){\\n        \\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n        }\\n        return answer[365];\\n    }\\n};\\n```\\n\\n\\nor just simply add 30 space days infront of Jan 1st and use the third `if else`\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int answer[396] = {};\\n        bool need[396] = {};\\n        for(auto &i : days)need[i + 30] = true;\\n        for(int i = 30;i < 396;++i){\\n        \\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n        }\\n        return answer[395];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i = 1;i < 7;++i){\\n\\tanswer[i] = answer[i - 1] + need[i] * costs[0];// another array bool need[366] stores whether you\\'ll travel or not\\n}\\n```\n```\\nfor(int i = 7;i < 30;++i){\\n\\tanswer[i] = min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]);\\n}\\n```\n```\\nfor(int i = 30;i < 366;++i){\\n\\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int answer[366] = {};\\n        bool need[366] = {};\\n        for(auto &i : days)need[i] = true;\\n        for(int i = 1;i < 7;++i){\\n        \\tanswer[i] = answer[i - 1] + need[i] * costs[0];\\n        }\\n        for(int i = 7;i < 30;++i){\\n        \\tanswer[i] = min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]);\\n        }\\n        for(int i = 30;i < 366;++i){\\n        \\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n        }\\n        return answer[365];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int answer[396] = {};\\n        bool need[396] = {};\\n        for(auto &i : days)need[i + 30] = true;\\n        for(int i = 30;i < 396;++i){\\n        \\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n        }\\n        return answer[395];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226710,
                "title": "java-solution-using-dp",
                "content": "\\tpublic int mincostTickets(int[] days, int[] costs) {\\n        int dp[] = new int[366];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        for (int i = 0; i < days.length; i++) {\\n            dp[days[i]] = 1;\\n        }\\n        dp[0] = 0;\\n        for (int i = 1; i < 366; i++) {\\n            if(dp[i] == Integer.MAX_VALUE) {\\n                dp[i] = dp[i-1];\\n                \\n            } else {\\n                dp[i] = dp[i-1] + costs[0];\\n            }\\n            if(i>=7) {\\n                dp[i] = Math.min(dp[i], dp[i-7] + costs[1]);\\n            }\\n            if(i>=30) {\\n                dp[i] = Math.min(dp[i], dp[i - 30] + costs[2]);\\n            }\\n        }\\n        return dp[365];\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int mincostTickets(int[] days, int[] costs) {\\n        int dp[] = new int[366];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        for (int i = 0; i < days.length; i++) {\\n            dp[days[i]] = 1;\\n        }\\n        dp[0] = 0;\\n        for (int i = 1; i < 366; i++) {\\n            if(dp[i] == Integer.MAX_VALUE) {\\n                dp[i] = dp[i-1];\\n                \\n            } else {\\n                dp[i] = dp[i-1] + costs[0];\\n            }\\n            if(i>=7) {\\n                dp[i] = Math.min(dp[i], dp[i-7] + costs[1]);\\n            }\\n            if(i>=30) {\\n                dp[i] = Math.min(dp[i], dp[i - 30] + costs[2]);\\n            }\\n        }\\n        return dp[365];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3954095,
                "title": "recursive-solution-dp-explanation-cpp",
                "content": "Here we are exploring all possible combinations of passes and selecting the one that results in the minimum cost.\\n \\nIf the current day (days[index]) is before or on the last day for which a pass was purchased (lastValidDay), we don\\'t need to buy any pass for the current day. We move to the next day (index + 1) and make a recursive call with the same lastValidDay.\\n\\nIf the current day is after the lastValidDay, we have three options to consider for buying passes:\\n1. Buy a one-day pass for the current day and move to the next day (index + 1).\\n2. Buy a seven-day pass starting from the current day and move to the day seven days later (index + 1, and lastValidDay + 6).\\n3. Buy a thirty-day pass starting from the current day and move to the day thirty days later (index + 1, and lastValidDay + 29).\\n\\nRecursive Solution\\n```\\nclass Solution {\\n    int solve(vector<int> &days, vector<int> &costs, int index, int lastValidDay){\\n        if(index == days.size()){\\n            return 0;\\n        }\\n        \\n        if(days[index] <= lastValidDay){\\n            return solve(days, costs, index + 1, lastValidDay);\\n        }\\n        \\n        int oneDayPass = costs[0] + solve(days, costs, index + 1, days[index]);\\n        int weekPass = costs[1] + solve(days, costs, index + 1, days[index] + 6);\\n        int monthPass = costs[2] + solve(days, costs, index + 1, days[index] + 29);\\n        \\n        return min(oneDayPass, min(weekPass, monthPass));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return solve(days, costs, 0, -1e9);\\n    }\\n};\\n```\\nTC - O(3^n)\\n\\nBottom Up approach\\nshifting of indices in bottom up approach to handle the case of -1\\n-1 0 1 2 3 ... n-1\\n 0 1 2 3 4 ... n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (1001, 0));\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            for(int lastValidDay = days[n-1]; lastValidDay >= -1; lastValidDay--){\\n                if(days[i] <= lastValidDay){\\n                    dp[i][lastValidDay + 1] = dp[i + 1][lastValidDay + 1]; \\n                }else{\\n                    int oneDayPass = costs[0] + dp[i + 1][days[i] + 1];\\n                    int weekPass = costs[1] + dp[i + 1][days[i] + 6 + 1];\\n                    int monthPass = costs[2] + dp[i + 1][days[i] + 29 + 1];\\n                    \\n                    dp[i][lastValidDay + 1] = min(oneDayPass, min(weekPass, monthPass));\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int> &days, vector<int> &costs, int index, int lastValidDay){\\n        if(index == days.size()){\\n            return 0;\\n        }\\n        \\n        if(days[index] <= lastValidDay){\\n            return solve(days, costs, index + 1, lastValidDay);\\n        }\\n        \\n        int oneDayPass = costs[0] + solve(days, costs, index + 1, days[index]);\\n        int weekPass = costs[1] + solve(days, costs, index + 1, days[index] + 6);\\n        int monthPass = costs[2] + solve(days, costs, index + 1, days[index] + 29);\\n        \\n        return min(oneDayPass, min(weekPass, monthPass));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return solve(days, costs, 0, -1e9);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (1001, 0));\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            for(int lastValidDay = days[n-1]; lastValidDay >= -1; lastValidDay--){\\n                if(days[i] <= lastValidDay){\\n                    dp[i][lastValidDay + 1] = dp[i + 1][lastValidDay + 1]; \\n                }else{\\n                    int oneDayPass = costs[0] + dp[i + 1][days[i] + 1];\\n                    int weekPass = costs[1] + dp[i + 1][days[i] + 6 + 1];\\n                    int monthPass = costs[2] + dp[i + 1][days[i] + 29 + 1];\\n                    \\n                    dp[i][lastValidDay + 1] = min(oneDayPass, min(weekPass, monthPass));\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807067,
                "title": "c-apni-bhasha-mein-easy-explanation-dp-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Complexity\\n- Time complexity:$O(lastDay+1)$\\n\\n- Space complexity:$O(lastDay+1)$\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. We are given some integers in the list days.\\n    2. We can travel if we have a valid train ticket for that day.\\n    3. There are three ticket options.\\n    -  valid for 1 day at costs[0] dollars.\\n    -  valid for 7 day at costs[1] dollars.\\n    -  valid for 30 day at costs[2] dollars.\\n    4. We need to return the min cost that is required to travel on every day that\\n       is  given.\\n\\n    INTUITION & APPROACH\\n    1. 2 important things to notice in this problem\\n    - As we iterate we have to decide ki whether for that day we have a valid pass\\n    or we have to buy one.\\n    - Also we need to decide which ticket to buy which affects future decisions.\\n\\n    2. So this is a problem of DP and Recursion\\n    Why\\u2753\\n    - Each decision we make is affected by previous decision we made.\\n    - The problem is asking to find the minimum cost required.\\n\\n    3. Agar hamare paas ticket hain jis din ham travel kar rahe to koi dikkat nahin\\n    aage wale din check karenge is din koi extra cost nahin.\\n    4. Agar ticket nahin hain to hamare paas 3 choices hongi 1,7 and 30 day passed.\\n    5. Baari Baari se recursive call karenge aur teeno ka min nikalnege.\\n    \\uD83D\\uDCA5Recurrence relation mentioned in memoization code.\\n    6. The parameter which is changing is the currDay.\\n    7. BASE CASE :- currDay>days[days.length-1] return 0.\\n    8. We will create a hash set which will contain days on which we travel.\\n    9. In recursiveFunction we will check the currDay in this hash set and decide\\n    if we have the valid ticket or not.\\n    10. RECURSION -> MEMOIZATION -> TABULATION \\n    11. MEMOIZATION STEPS\\n    - Which parameter is changing\\n    - Declare dp array\\n    - Store the dp values\\n    - Check if the dp value is already stored.\\n    12. TABULATION\\n    - In this we will not keep a hash set but a variable i.\\n    - i will keep track of the days we have to visit.\\n    - While iterating the days from 1 to the largest day possible we will check it\\n    with index i if the day is smaller than days[i] if yes then this day is valid,\\n    cost is same as that of prev day and no extra cost is incurred otherwise \\n    we will check all three day passed and find min.\\n\\n//=========================================================================================================\\n\\n       \\t//MEMOIZATION SOLUTION\\n        unordered_set<int> isTicketValid;\\n    int Memoization(vector<int> &dp, vector<int> &days, vector< int > &costs, int currDay)\\n    {\\n        if (currDay > days[days.size() - 1])\\n        //BASE CASE\\n        //If the current day exceeds last Day\\n            return 0;\\n        if (dp[currDay] != -1)\\n        //If we have already calculated the val for currDay\\n            return dp[currDay];\\n        if (isTicketValid.find(currDay) == isTicketValid.end())\\n        //Checking if the currDay is a day on which we had to travel\\n            return Memoization(dp, days, costs, currDay + 1);\\n        int oneDay = costs[0] + Memoization(dp, days, costs, currDay + 1);\\n        //One day path\\n        int sevenDay = costs[1] + Memoization(dp, days, costs, currDay + 7);\\n        //seven day path\\n        int thirtyDay = costs[2] + Memoization(dp, days, costs, currDay + 30);\\n        //thirty day path\\n        return dp[currDay] = min(oneDay, min(sevenDay, thirtyDay));\\n        //min of all paths\\n    }\\n    int mincostTickets(vector<int> &days, vector<int> &costs)\\n    {\\n        int lastDay = days[days.size() - 1];\\n        vector<int> dp(lastDay + 1, -1);\\n        for (auto i: days)\\n        {\\n            isTicketValid.insert(i);\\n            //Creating valid days hash set\\n        }\\n        return Memoization(dp, days, costs, 1);\\n    }\\n//==============================================================================================================================\\n   \\t//TABULATION\\n    int mincostTickets(vector<int> &days, vector<int> &costs)\\n    {\\n        int lastDay = days[days.size() - 1];\\n        vector<int> dp(lastDay + 1, 0);\\n        int index = 0;\\n        //Index tracking valid days\\n        for (int day = 1; day <= lastDay; day++)\\n        {\\n            if (day < days[index])\\n            {\\n                dp[day] = dp[day - 1];\\n                //If the day is smaller than valid day so no extra cost\\n            }\\n            else\\n            {\\n                index++;\\n                //If day exceeds valid days\\n                //Checking cost of all paths\\n                int oneDay = costs[0] + dp[day - 1];\\n                int sevenDay = costs[1] + dp[max(0, day - 7)];\\n                int thirtyDay = costs[2] + dp[max(0, day - 30)];\\n                //Min of all paths\\n                dp[day] = min(oneDay, min(sevenDay, thirtyDay));\\n            }\\n        }\\n        return dp[lastDay];\\n    }\\n};\\n```\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. We are given some integers in the list days.\\n    2. We can travel if we have a valid train ticket for that day.\\n    3. There are three ticket options.\\n    -  valid for 1 day at costs[0] dollars.\\n    -  valid for 7 day at costs[1] dollars.\\n    -  valid for 30 day at costs[2] dollars.\\n    4. We need to return the min cost that is required to travel on every day that\\n       is  given.\\n\\n    INTUITION & APPROACH\\n    1. 2 important things to notice in this problem\\n    - As we iterate we have to decide ki whether for that day we have a valid pass\\n    or we have to buy one.\\n    - Also we need to decide which ticket to buy which affects future decisions.\\n\\n    2. So this is a problem of DP and Recursion\\n    Why\\u2753\\n    - Each decision we make is affected by previous decision we made.\\n    - The problem is asking to find the minimum cost required.\\n\\n    3. Agar hamare paas ticket hain jis din ham travel kar rahe to koi dikkat nahin\\n    aage wale din check karenge is din koi extra cost nahin.\\n    4. Agar ticket nahin hain to hamare paas 3 choices hongi 1,7 and 30 day passed.\\n    5. Baari Baari se recursive call karenge aur teeno ka min nikalnege.\\n    \\uD83D\\uDCA5Recurrence relation mentioned in memoization code.\\n    6. The parameter which is changing is the currDay.\\n    7. BASE CASE :- currDay>days[days.length-1] return 0.\\n    8. We will create a hash set which will contain days on which we travel.\\n    9. In recursiveFunction we will check the currDay in this hash set and decide\\n    if we have the valid ticket or not.\\n    10. RECURSION -> MEMOIZATION -> TABULATION \\n    11. MEMOIZATION STEPS\\n    - Which parameter is changing\\n    - Declare dp array\\n    - Store the dp values\\n    - Check if the dp value is already stored.\\n    12. TABULATION\\n    - In this we will not keep a hash set but a variable i.\\n    - i will keep track of the days we have to visit.\\n    - While iterating the days from 1 to the largest day possible we will check it\\n    with index i if the day is smaller than days[i] if yes then this day is valid,\\n    cost is same as that of prev day and no extra cost is incurred otherwise \\n    we will check all three day passed and find min.\\n\\n//=========================================================================================================\\n\\n       \\t//MEMOIZATION SOLUTION\\n        unordered_set<int> isTicketValid;\\n    int Memoization(vector<int> &dp, vector<int> &days, vector< int > &costs, int currDay)\\n    {\\n        if (currDay > days[days.size() - 1])\\n        //BASE CASE\\n        //If the current day exceeds last Day\\n            return 0;\\n        if (dp[currDay] != -1)\\n        //If we have already calculated the val for currDay\\n            return dp[currDay];\\n        if (isTicketValid.find(currDay) == isTicketValid.end())\\n        //Checking if the currDay is a day on which we had to travel\\n            return Memoization(dp, days, costs, currDay + 1);\\n        int oneDay = costs[0] + Memoization(dp, days, costs, currDay + 1);\\n        //One day path\\n        int sevenDay = costs[1] + Memoization(dp, days, costs, currDay + 7);\\n        //seven day path\\n        int thirtyDay = costs[2] + Memoization(dp, days, costs, currDay + 30);\\n        //thirty day path\\n        return dp[currDay] = min(oneDay, min(sevenDay, thirtyDay));\\n        //min of all paths\\n    }\\n    int mincostTickets(vector<int> &days, vector<int> &costs)\\n    {\\n        int lastDay = days[days.size() - 1];\\n        vector<int> dp(lastDay + 1, -1);\\n        for (auto i: days)\\n        {\\n            isTicketValid.insert(i);\\n            //Creating valid days hash set\\n        }\\n        return Memoization(dp, days, costs, 1);\\n    }\\n//==============================================================================================================================\\n   \\t//TABULATION\\n    int mincostTickets(vector<int> &days, vector<int> &costs)\\n    {\\n        int lastDay = days[days.size() - 1];\\n        vector<int> dp(lastDay + 1, 0);\\n        int index = 0;\\n        //Index tracking valid days\\n        for (int day = 1; day <= lastDay; day++)\\n        {\\n            if (day < days[index])\\n            {\\n                dp[day] = dp[day - 1];\\n                //If the day is smaller than valid day so no extra cost\\n            }\\n            else\\n            {\\n                index++;\\n                //If day exceeds valid days\\n                //Checking cost of all paths\\n                int oneDay = costs[0] + dp[day - 1];\\n                int sevenDay = costs[1] + dp[max(0, day - 7)];\\n                int thirtyDay = costs[2] + dp[max(0, day - 30)];\\n                //Min of all paths\\n                dp[day] = min(oneDay, min(sevenDay, thirtyDay));\\n            }\\n        }\\n        return dp[lastDay];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755833,
                "title": "o-1-dp-and-queue-solutions-fully-explained-from-scratch",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Explanation 1: DP**\\n1. Try to decode the problem and think for a recursive solution.\\n2. There are **three options** in this problem:\\n- Option 1: Take 1 day pass for each day\\n- Option 2: Take a 7 days pass for 7 consecutive days in a year.\\n- Option 3: Take a 30 days pass for 30 consecutive days in a year.\\n3.Let us see an example for better understanding:\\n**days[] = {2,5}, costs[] = {1,4,25}**\\n\\nHere is the recursion tree for this example:\\n![image.png](https://assets.leetcode.com/users/images/e113f90d-6946-45b5-86fe-c7996a238f43_1689179197.6838899.png)\\n\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe size of our dp vector is days.size() + 1, we know that in a year, there are 365 days (as per this question, leap year is not considered), therefore size of our dp vector can be atmost 365 + 1 = 366, this can obviously be accessed in a constant time.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solveMem(vector<int>& days, vector<int>& costs, vector<int>& dp, int index)\\n    {\\n        if(index >= days.size()) return 0;\\n\\n        if(dp[index] != -1) return dp[index];\\n\\n        //1 day pass\\n        int option1 = costs[0] + solveMem(days, costs, dp, index + 1);\\n\\n        int i;\\n\\n        //7 days pass\\n        for(i = index; i < days.size() && days[i] < days[index] + 7; i++);\\n        int option2 = costs[1] + solveMem(days, costs, dp, i);\\n\\n        //30 days pass\\n        for(i = index; i < days.size() && days[i] < days[index] + 30; i++);\\n        int option3 = costs[2] + solveMem(days, costs, dp, i);\\n\\n        dp[index] = min(option1, min(option2, option3));\\n\\n        return dp[index];\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> dp(days.size() + 1, -1);\\n\\n        int index = 0;\\n\\n        return solveMem(days, costs, dp, index);\\n    }\\n};\\n```\\n\\n# **Queue Solution**\\n\\n# Approach\\nSliding window.\\nMaximum size of month queue can be 30.\\nMaximum size of week queue can be 7.\\n\\n**Time and Space Complexity**: both are O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int ans = 0;\\n        queue<pair<int, int>> week, month;\\n\\n        //first part of the pair will indicate the day, and the second part will indicate the cost on this day\\n\\n        for(auto day : days)\\n        {\\n            //step 1 : remove expired elements from the queue\\n            while(!week.empty() && week.front().first + 7 <= day)\\n            {\\n                week.pop();\\n            }\\n            while(!month.empty() && month.front().first + 30 <= day)\\n            {\\n                month.pop();\\n            }\\n            \\n            //step 2: push current day\\'s cost\\n            week.push(make_pair(day, ans + costs[1]));\\n            month.push(make_pair(day, ans + costs[2]));\\n\\n            //step 3: update the ans\\n            ans = min(ans + costs[0], min(week.front().second, month.front().second));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solveMem(vector<int>& days, vector<int>& costs, vector<int>& dp, int index)\\n    {\\n        if(index >= days.size()) return 0;\\n\\n        if(dp[index] != -1) return dp[index];\\n\\n        //1 day pass\\n        int option1 = costs[0] + solveMem(days, costs, dp, index + 1);\\n\\n        int i;\\n\\n        //7 days pass\\n        for(i = index; i < days.size() && days[i] < days[index] + 7; i++);\\n        int option2 = costs[1] + solveMem(days, costs, dp, i);\\n\\n        //30 days pass\\n        for(i = index; i < days.size() && days[i] < days[index] + 30; i++);\\n        int option3 = costs[2] + solveMem(days, costs, dp, i);\\n\\n        dp[index] = min(option1, min(option2, option3));\\n\\n        return dp[index];\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> dp(days.size() + 1, -1);\\n\\n        int index = 0;\\n\\n        return solveMem(days, costs, dp, index);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int ans = 0;\\n        queue<pair<int, int>> week, month;\\n\\n        //first part of the pair will indicate the day, and the second part will indicate the cost on this day\\n\\n        for(auto day : days)\\n        {\\n            //step 1 : remove expired elements from the queue\\n            while(!week.empty() && week.front().first + 7 <= day)\\n            {\\n                week.pop();\\n            }\\n            while(!month.empty() && month.front().first + 30 <= day)\\n            {\\n                month.pop();\\n            }\\n            \\n            //step 2: push current day\\'s cost\\n            week.push(make_pair(day, ans + costs[1]));\\n            month.push(make_pair(day, ans + costs[2]));\\n\\n            //step 3: update the ans\\n            ans = min(ans + costs[0], min(week.front().second, month.front().second));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449475,
                "title": "memoization-c-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst wrote the basic recurssive code for the problem then just memoized it. When solving this type of problem , the best thing is try to first decide the states of the recurrsion and 90% of the job is done.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**pass** is the number of days the traveller has purchased the ticket i.e 1,7 or 30 days\\n        it seems like pass also constitutes a state of the dp. But we purchase ticket(1,7,or 30) \\n        every day if we don\\'t have ticket for that day.And then initialise the minimun cost for \\n        that day.\\n\\n      day is the iterator from 0 to days.size()-1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\nwhere n= days.size()\\nwe are calling the function for each day only once then its result is being stored.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) \\nExtra space for the memo table.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int travel(vector<int>& days, vector<int>& costs,int pass, int day,vector<int> &memo)\\n    {\\n        if(day>=days.size())  // when we have reached end of the array\\n            return 0;\\n        \\n        if(days[day]<=pass)   // if we have ticket for that day then we don\\'t purchase any and simply increment day\\n            return travel(days,costs,pass,day+1,memo);\\n\\n        if(memo[day]!=-1)     // memo table look up\\n            return memo[day];\\n\\n        //if we don\\'t have ticket for that day\\n\\n        int cst=0; // purchasing all types of ticket for a given day and choosing the minimum from them\\n        \\n        cst=costs[0]+travel(days,costs,days[day],day+1,memo);\\n        cst= min(cst, costs[1]+travel(days,costs,days[day]+6,day+1,memo));\\n        cst= min(cst,costs[2]+travel(days,costs,days[day]+29,day+1,memo));\\n\\n        memo[day]=cst;\\n\\n        return cst;\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        vector<int> memo(days.size(),-1);\\n\\n        return travel(days,costs,0,0,memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int travel(vector<int>& days, vector<int>& costs,int pass, int day,vector<int> &memo)\\n    {\\n        if(day>=days.size())  // when we have reached end of the array\\n            return 0;\\n        \\n        if(days[day]<=pass)   // if we have ticket for that day then we don\\'t purchase any and simply increment day\\n            return travel(days,costs,pass,day+1,memo);\\n\\n        if(memo[day]!=-1)     // memo table look up\\n            return memo[day];\\n\\n        //if we don\\'t have ticket for that day\\n\\n        int cst=0; // purchasing all types of ticket for a given day and choosing the minimum from them\\n        \\n        cst=costs[0]+travel(days,costs,days[day],day+1,memo);\\n        cst= min(cst, costs[1]+travel(days,costs,days[day]+6,day+1,memo));\\n        cst= min(cst,costs[2]+travel(days,costs,days[day]+29,day+1,memo));\\n\\n        memo[day]=cst;\\n\\n        return cst;\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        vector<int> memo(days.size(),-1);\\n\\n        return travel(days,costs,0,0,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353097,
                "title": "kotlin-o-n-solution-brute-force-to-memoized-dfs-and-tabulation",
                "content": "# Approach\\nApproach is to do a brute force, which is quite hard, but intuition is like this:\\n\\nAt given position i, we can do three things:\\n- buy a 1 day ticket\\n- buy a 7 day ticket\\n- buy a 30 day ticket\\n\\nThe trick is to jump to first next index where our ticket is expired. We can compute that by a loop, or a binary search (since our day array is sorted).\\n\\n# Complexity\\n- Time complexity:\\nApproximately $$O(n)$$ (+ a little overhead caused by next function calls)\\n\\n- Space complexity:\\n$$O(n)$$ at most allocated in call stack\\n\\n# Code - brute force dfs\\n```java []\\nclass Solution {\\n    private int[] days;\\n    private int[] costs;\\n    private final int DAY_1 = 0;\\n    private final int DAY_7 = 1;\\n    private final int DAY_30 = 2;\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        this.days = days;\\n        this.costs = costs;\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int i) {\\n        if (i == days.length) return 0;\\n        return Math.min(\\n            Math.min(\\n                costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n                costs[DAY_7] + dfs(next(i, 7)) // buy 7 day ticket\\n            ),\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        );\\n    }\\n\\n    private int next(int i, int ticket) {\\n        int low = i+1;\\n        int high = days.length;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\\n```kotlin []\\nclass Solution {\\n    private lateinit var days: IntArray\\n    private lateinit var costs: IntArray\\n    private val DAY_1 = 0\\n    private val DAY_7 = 1\\n    private val DAY_30 = 2\\n\\n    fun mincostTickets(days: IntArray, costs: IntArray): Int {\\n        this.days = days\\n        this.costs = costs\\n        return dfs(0)\\n    }\\n\\n    private fun dfs(i: Int): Int {\\n        if (i == days.size) return 0\\n        return minOf(\\n            costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n            costs[DAY_7] + dfs(next(i, 7)), // buy 7 day ticket\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        )\\n    }\\n\\n    private fun next(i: Int, ticket: Int): Int {\\n        var low = i+1\\n        var high = days.size\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n\\n        return low\\n    }\\n}\\n```\\n\\nThis gives us a brute force algorithm, where we get optimal solution at index i. This means solution to a subproblem we can memoize.\\n\\n# Code - memoized dfs\\n\\n```\\nclass Solution {\\n    private int[] days;\\n    private int[] costs;\\n    private int[] memo;\\n    private final int DAY_1 = 0;\\n    private final int DAY_7 = 1;\\n    private final int DAY_30 = 2;\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        this.days = days;\\n        this.costs = costs;\\n        memo = new int[days.length];\\n        Arrays.fill(memo, -1);\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int i) {\\n        if (i == days.length) return 0;\\n        if (memo[i] != -1) return memo[i];\\n        memo[i] = Math.min(\\n            Math.min(\\n                costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n                costs[DAY_7] + dfs(next(i, 7)) // buy 7 day ticket\\n            ),\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        );\\n        return memo[i];\\n    }\\n\\n    private int next(int i, int ticket) {\\n        int low = i+1;\\n        int high = days.length;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\\nFrom this approach we can come up with DP algo with single foreach where we iterate from end to beginning, just like in the dfs. Answer at i would be minimum of:\\n\\n1. day1Cost + memo[i+1]\\n2. day7Cost + memo at first expired index\\n3. day30Cost + memo at first expired index\\n \\nThe answer is then at first index of memo.\\n\\n# Code - DP tabulation\\n```\\nclass Solution {\\n    private val DAY_1 = 0\\n    private val DAY_7 = 1\\n    private val DAY_30 = 2\\n\\n    fun mincostTickets(days: IntArray, costs: IntArray): Int {\\n        val memo = IntArray(days.size+1) { -1 }\\n        memo[memo.lastIndex] = 0\\n        for (i in days.size-1 downTo 0) {\\n            memo[i] = minOf(\\n                costs[DAY_1] + memo[i+1],\\n                costs[DAY_7] + memo[next(days, i, 7)],\\n                costs[DAY_30] + memo[next(days, i, 30)]\\n            )\\n        }\\n\\n        return memo[0]\\n    }\\n\\n    private fun next(days: IntArray, i: Int, ticket: Int): Int {\\n        var low = i+1\\n        var high = days.size\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n        return low\\n    }\\n}\\n```\\n\\n---\\n\\n\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    private int[] days;\\n    private int[] costs;\\n    private final int DAY_1 = 0;\\n    private final int DAY_7 = 1;\\n    private final int DAY_30 = 2;\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        this.days = days;\\n        this.costs = costs;\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int i) {\\n        if (i == days.length) return 0;\\n        return Math.min(\\n            Math.min(\\n                costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n                costs[DAY_7] + dfs(next(i, 7)) // buy 7 day ticket\\n            ),\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        );\\n    }\\n\\n    private int next(int i, int ticket) {\\n        int low = i+1;\\n        int high = days.length;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\n```kotlin []\\nclass Solution {\\n    private lateinit var days: IntArray\\n    private lateinit var costs: IntArray\\n    private val DAY_1 = 0\\n    private val DAY_7 = 1\\n    private val DAY_30 = 2\\n\\n    fun mincostTickets(days: IntArray, costs: IntArray): Int {\\n        this.days = days\\n        this.costs = costs\\n        return dfs(0)\\n    }\\n\\n    private fun dfs(i: Int): Int {\\n        if (i == days.size) return 0\\n        return minOf(\\n            costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n            costs[DAY_7] + dfs(next(i, 7)), // buy 7 day ticket\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        )\\n    }\\n\\n    private fun next(i: Int, ticket: Int): Int {\\n        var low = i+1\\n        var high = days.size\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n\\n        return low\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[] days;\\n    private int[] costs;\\n    private int[] memo;\\n    private final int DAY_1 = 0;\\n    private final int DAY_7 = 1;\\n    private final int DAY_30 = 2;\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        this.days = days;\\n        this.costs = costs;\\n        memo = new int[days.length];\\n        Arrays.fill(memo, -1);\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int i) {\\n        if (i == days.length) return 0;\\n        if (memo[i] != -1) return memo[i];\\n        memo[i] = Math.min(\\n            Math.min(\\n                costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n                costs[DAY_7] + dfs(next(i, 7)) // buy 7 day ticket\\n            ),\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        );\\n        return memo[i];\\n    }\\n\\n    private int next(int i, int ticket) {\\n        int low = i+1;\\n        int high = days.length;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private val DAY_1 = 0\\n    private val DAY_7 = 1\\n    private val DAY_30 = 2\\n\\n    fun mincostTickets(days: IntArray, costs: IntArray): Int {\\n        val memo = IntArray(days.size+1) { -1 }\\n        memo[memo.lastIndex] = 0\\n        for (i in days.size-1 downTo 0) {\\n            memo[i] = minOf(\\n                costs[DAY_1] + memo[i+1],\\n                costs[DAY_7] + memo[next(days, i, 7)],\\n                costs[DAY_30] + memo[next(days, i, 30)]\\n            )\\n        }\\n\\n        return memo[0]\\n    }\\n\\n    private fun next(days: IntArray, i: Int, ticket: Int): Int {\\n        var low = i+1\\n        var high = days.size\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n        return low\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352860,
                "title": "java-solution-beats-100-recursive-approach",
                "content": "# Intuition \\nRecursion, Dynamic Programming\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int dp[] = new int[days.length + 1];\\n        Arrays.fill(dp, -1);\\n        return f(days, costs, 0, dp);\\n    }\\n    int f (int days[], int cost[], int i, int dp[]) {\\n        if(i >= days.length)\\n            return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n        //day 1\\n        int option1 = cost[0] + f(days, cost, i + 1, dp);\\n    \\n        int j;\\n        //day 7\\n        for(j = i; j < days.length && days[j] < days[i] + 7; j++);\\n        int option2 = cost[1] + f(days, cost, j, dp);\\n\\n        //day 30\\n        //day 7\\n       \\n        for(j = i; j < days.length && days[j] < days[i] + 30; j++);\\n        int option3 = cost[2] + f(days, cost, j, dp);\\n\\n        return dp[i] = Math.min(option1, Math.min(option2, option3));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int dp[] = new int[days.length + 1];\\n        Arrays.fill(dp, -1);\\n        return f(days, costs, 0, dp);\\n    }\\n    int f (int days[], int cost[], int i, int dp[]) {\\n        if(i >= days.length)\\n            return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n        //day 1\\n        int option1 = cost[0] + f(days, cost, i + 1, dp);\\n    \\n        int j;\\n        //day 7\\n        for(j = i; j < days.length && days[j] < days[i] + 7; j++);\\n        int option2 = cost[1] + f(days, cost, j, dp);\\n\\n        //day 30\\n        //day 7\\n       \\n        for(j = i; j < days.length && days[j] < days[i] + 30; j++);\\n        int option3 = cost[2] + f(days, cost, j, dp);\\n\\n        return dp[i] = Math.min(option1, Math.min(option2, option3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352821,
                "title": "python-short-and-clean-dp",
                "content": "# Approach\\nTL;DR, Same as [Official solution](https://leetcode.com/problems/minimum-cost-for-tickets/editorial/).\\n\\n# Complexity\\n- Time complexity: $$O(n * k)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is length of days array`,\\n`k is length of costs array`.\\n\\n# Code\\nRecursive:\\n```python\\nclass Solution:\\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\\n        @cache\\n        def min_cost(i: int) -> int:\\n            return min(\\n                min_cost(bisect.bisect_left(days, days[i] + d, i)) + c\\n                for d, c in zip((1, 7, 30), costs)\\n            ) if i < len(days) else 0\\n        \\n        return min_cost(0)\\n\\n\\n```\\n\\nIterative:\\n```python\\nclass Solution:\\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\\n        dp = [0] * (len(days) + 1)\\n        for i, x in enumerate(days):\\n            dp[i + 1] = min(\\n                dp[bisect.bisect(days, x - d, 0, i)] + c\\n                for d, c in zip((1, 7, 30), costs)\\n            )\\n        return dp[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\\n        @cache\\n        def min_cost(i: int) -> int:\\n            return min(\\n                min_cost(bisect.bisect_left(days, days[i] + d, i)) + c\\n                for d, c in zip((1, 7, 30), costs)\\n            ) if i < len(days) else 0\\n        \\n        return min_cost(0)\\n\\n\\n```\n```python\\nclass Solution:\\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\\n        dp = [0] * (len(days) + 1)\\n        for i, x in enumerate(days):\\n            dp[i + 1] = min(\\n                dp[bisect.bisect(days, x - d, 0, i)] + c\\n                for d, c in zip((1, 7, 30), costs)\\n            )\\n        return dp[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352059,
                "title": "c-tabulation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. There are two cases whether a person buys a ticket on a particular day or not .\\n2. If he does not buy a ticket there must be a day prior to that day \\nsuch that the ticket bought on that day covers today . Choose minimum\\ncost from those .(Second Loop) .\\n3. If he buys a ticket we consider all three cases and add to minimum cost till now .\\n\\n# Complexity\\n- Time complexity:\\nO(n*n) \\n\\n- Space complexity:\\nO(4*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        //dp[i][j] where j can be 0 , 1 , 2 , 3\\n\\n        vector<vector<int>> dp(366,vector<int>(4,INT_MAX)) ;\\n\\n        int n = days.size() ;\\n\\n        dp[days[0]][0] = INT_MAX ;\\n        dp[days[0]][1] = costs[0] , dp[days[0]][2] = costs[1] , dp[days[0]][3] = costs[2] ;\\n\\n        for(int i = 1 ; i < n ; i++){\\n\\n            int mini = min(dp[days[i-1]][1],min(dp[days[i-1]][2],dp[days[i-1]][3])) ;\\n\\n            if(dp[days[i-1]][0] != INT_MAX)\\n            {\\n                dp[days[i]][1] = min(dp[days[i-1]][0],mini) + costs[0] ;\\n                dp[days[i]][2] = min(dp[days[i-1]][0],mini) + costs[1] ;\\n                dp[days[i]][3] = min(dp[days[i-1]][0],mini) + costs[2] ;\\n            }\\n            else{\\n                dp[days[i]][1] = mini + costs[0] ;\\n                dp[days[i]][2] = mini + costs[1] ;\\n                dp[days[i]][3] = mini + costs[2] ;\\n            }\\n\\n            for(int j = 0 ; j < i ; j++){\\n                if(days[j] + 7 > days[i]){\\n                    dp[days[i]][0] = min(dp[days[i]][0],dp[days[j]][2]) ;\\n                }\\n                if(days[j] + 30 > days[i]){\\n                    dp[days[i]][0] = min(dp[days[i]][0],dp[days[j]][3]) ;\\n                }\\n            }\\n        }\\n\\n        return \\n        min(dp[days[n-1]][0],min(dp[days[n-1]][1],min(dp[days[n-1]][2],dp[days[n-1]][3]))) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        //dp[i][j] where j can be 0 , 1 , 2 , 3\\n\\n        vector<vector<int>> dp(366,vector<int>(4,INT_MAX)) ;\\n\\n        int n = days.size() ;\\n\\n        dp[days[0]][0] = INT_MAX ;\\n        dp[days[0]][1] = costs[0] , dp[days[0]][2] = costs[1] , dp[days[0]][3] = costs[2] ;\\n\\n        for(int i = 1 ; i < n ; i++){\\n\\n            int mini = min(dp[days[i-1]][1],min(dp[days[i-1]][2],dp[days[i-1]][3])) ;\\n\\n            if(dp[days[i-1]][0] != INT_MAX)\\n            {\\n                dp[days[i]][1] = min(dp[days[i-1]][0],mini) + costs[0] ;\\n                dp[days[i]][2] = min(dp[days[i-1]][0],mini) + costs[1] ;\\n                dp[days[i]][3] = min(dp[days[i-1]][0],mini) + costs[2] ;\\n            }\\n            else{\\n                dp[days[i]][1] = mini + costs[0] ;\\n                dp[days[i]][2] = mini + costs[1] ;\\n                dp[days[i]][3] = mini + costs[2] ;\\n            }\\n\\n            for(int j = 0 ; j < i ; j++){\\n                if(days[j] + 7 > days[i]){\\n                    dp[days[i]][0] = min(dp[days[i]][0],dp[days[j]][2]) ;\\n                }\\n                if(days[j] + 30 > days[i]){\\n                    dp[days[i]][0] = min(dp[days[i]][0],dp[days[j]][3]) ;\\n                }\\n            }\\n        }\\n\\n        return \\n        min(dp[days[n-1]][0],min(dp[days[n-1]][1],min(dp[days[n-1]][2],dp[days[n-1]][3]))) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351970,
                "title": "all-three-approaches-discussed-in-an-understandable-manner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic Programming is to be implemented as the number of possibilities are infinte and we need to minimize the cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor recursive solution , you\\'ll get a TLE as cases are large.\\nCode gets successfully submitted for the top-down approach i.e. the memoized version of recursive solution and the bottom-up apprach.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nExponential in case of recursive.\\nConstant i.e. O(1) in the memoized solution.\\nO(n) in case of bottom-up approach where n is the number of elememts in days array.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) in case of top-down and bottom-up solutions.\\n\\n# Code\\n```\\n//RECURSIVE SOLUTION\\nclass Solution {\\npublic:\\n\\n    int solve(int n, vector<int>& days, vector<int>& costs, int index)\\n    {\\n        //BASE CASE\\n        if(index >= n)\\n        return 0;\\n\\n        //1 day pass\\n        int option1 = costs[0] + solve(n,days, costs, index+1);\\n\\n        //7 days pass\\n        int i;\\n        for(i = index; i<n && days[i] < days[index]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + solve(n, days, costs, i);\\n\\n        //30 days pass\\n        for(i = index; i<n && days[i] < days[index]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + solve(n, days, costs, i);\\n\\n\\n        return min(option1, min(option2, option3));\\n\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n     return solve(n, days, costs, 0);\\n    }\\n};\\n\\n\\n\\n//MEMOIZED CODE\\nclass Solution {\\npublic:\\n\\n    int solveMem(int n, vector<int>& days, vector<int>& costs, int index, vector<int> & dp)\\n    {\\n        //BASE CASE\\n        if(index >= n)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        //1 day pass\\n        int option1 = costs[0] + solveMem(n,days, costs, index+1, dp);\\n\\n        //7 days pass\\n        int i;\\n        for(i = index; i<n && days[i] < days[index]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + solveMem(n, days, costs, i, dp);\\n\\n        //30 days pass\\n        for(i = index; i<n && days[i] < days[index]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + solveMem(n, days, costs, i, dp);\\n\\n\\n        dp[index] = min(option1, min(option2, option3));\\n        return dp[index];\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n+1, -1);\\n     return solveMem(n, days, costs, 0, dp);\\n    }\\n};\\n\\n\\n\\n//BOTTOM-UP APPROACH\\nclass Solution {\\npublic:\\n\\n    int solveTab(int n, vector<int>& days, vector<int>& costs)\\n    {\\n       vector<int> dp(n+1, INT_MAX);\\n       dp[n] = 0;\\n\\n       for(int k = n-1; k>=0; k--)\\n       {\\n         //1 day pass\\n        int option1 = costs[0] + dp[k+1];\\n\\n        //7 days pass\\n        int i;\\n        for(i = k; i<n && days[i] < days[k]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + dp[i];\\n\\n        //30 days pass\\n        for(i = k; i<n && days[i] < days[k]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + dp[i];\\n\\n\\n        dp[k] = min(option1, min(option2, option3));\\n\\n       }\\n        return dp[0];\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n     return solveTab(n, days, costs);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//RECURSIVE SOLUTION\\nclass Solution {\\npublic:\\n\\n    int solve(int n, vector<int>& days, vector<int>& costs, int index)\\n    {\\n        //BASE CASE\\n        if(index >= n)\\n        return 0;\\n\\n        //1 day pass\\n        int option1 = costs[0] + solve(n,days, costs, index+1);\\n\\n        //7 days pass\\n        int i;\\n        for(i = index; i<n && days[i] < days[index]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + solve(n, days, costs, i);\\n\\n        //30 days pass\\n        for(i = index; i<n && days[i] < days[index]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + solve(n, days, costs, i);\\n\\n\\n        return min(option1, min(option2, option3));\\n\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n     return solve(n, days, costs, 0);\\n    }\\n};\\n\\n\\n\\n//MEMOIZED CODE\\nclass Solution {\\npublic:\\n\\n    int solveMem(int n, vector<int>& days, vector<int>& costs, int index, vector<int> & dp)\\n    {\\n        //BASE CASE\\n        if(index >= n)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        //1 day pass\\n        int option1 = costs[0] + solveMem(n,days, costs, index+1, dp);\\n\\n        //7 days pass\\n        int i;\\n        for(i = index; i<n && days[i] < days[index]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + solveMem(n, days, costs, i, dp);\\n\\n        //30 days pass\\n        for(i = index; i<n && days[i] < days[index]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + solveMem(n, days, costs, i, dp);\\n\\n\\n        dp[index] = min(option1, min(option2, option3));\\n        return dp[index];\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n+1, -1);\\n     return solveMem(n, days, costs, 0, dp);\\n    }\\n};\\n\\n\\n\\n//BOTTOM-UP APPROACH\\nclass Solution {\\npublic:\\n\\n    int solveTab(int n, vector<int>& days, vector<int>& costs)\\n    {\\n       vector<int> dp(n+1, INT_MAX);\\n       dp[n] = 0;\\n\\n       for(int k = n-1; k>=0; k--)\\n       {\\n         //1 day pass\\n        int option1 = costs[0] + dp[k+1];\\n\\n        //7 days pass\\n        int i;\\n        for(i = k; i<n && days[i] < days[k]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + dp[i];\\n\\n        //30 days pass\\n        for(i = k; i<n && days[i] < days[k]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + dp[i];\\n\\n\\n        dp[k] = min(option1, min(option2, option3));\\n\\n       }\\n        return dp[0];\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n     return solveTab(n, days, costs);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351619,
                "title": "solution-swift-dynamic-programming-beats-90",
                "content": "**TC:** O(n)\\n**SC:** O(n)\\n```\\nclass Solution {\\n    func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int {\\n        let days = Set(days)\\n        var dp = Array(repeating: 0, count: 366)\\n        \\n        for i in 1...365 {\\n            if days.contains(i) {\\n                dp[i] = min(\\n                    dp[i - 1] + costs[0],\\n                    dp[max(0, i - 7)] + costs[1],\\n                    dp[max(0, i - 30)] + costs[2]\\n                )\\n            } else {\\n                dp[i] = dp[i - 1]\\n            }\\n        }\\n\\n        return dp[365]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int {\\n        let days = Set(days)\\n        var dp = Array(repeating: 0, count: 366)\\n        \\n        for i in 1...365 {\\n            if days.contains(i) {\\n                dp[i] = min(\\n                    dp[i - 1] + costs[0],\\n                    dp[max(0, i - 7)] + costs[1],\\n                    dp[max(0, i - 30)] + costs[2]\\n                )\\n            } else {\\n                dp[i] = dp[i - 1]\\n            }\\n        }\\n\\n        return dp[365]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351548,
                "title": "bottom-up-dp-three-pointers-0-ms-100-c-fast-and-simple",
                "content": "**Explaination :**\\n\\nIn this solution ```dp[i]``` means cost, for travelling ```days[i]``` days. In order to minimize cost we check whether it is better to buy 30 days ticket (which will be ```dp[i+1] = dp[k]+costs[2]```), 7 days (which will be ```dp[i+1] = dp[j]+costs[1]```) or 1 day ticket (which will be ```dp[i+1]=min(dp[i]+costs[0]```) using Two Pointers ```k``` and ```j``` to track the day atleast 30 and 7 days before ```i``` respectively. \\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size(),j=0,k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(days[i]-days[j]>=7)j++;\\n            while(days[i]-days[k]>=30)k++;\\n            dp[i+1]=min(dp[i]+costs[0],min(dp[j]+costs[1],dp[k]+costs[2]));\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Complexity analysis**\\n\\n* Time Complexity: O(N), where N is the number of calendar days.\\n* Space Complexity: O(N).",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```dp[i]```\n```days[i]```\n```dp[i+1] = dp[k]+costs[2]```\n```dp[i+1] = dp[j]+costs[1]```\n```dp[i+1]=min(dp[i]+costs[0]```\n```k```\n```j```\n```i```\n```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size(),j=0,k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(days[i]-days[j]>=7)j++;\\n            while(days[i]-days[k]>=30)k++;\\n            dp[i+1]=min(dp[i]+costs[0],min(dp[j]+costs[1],dp[k]+costs[2]));\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351472,
                "title": "3-approaches-easy-java-solution-using-backtracking-and-dp",
                "content": "# Approach 1 backtracking\\n\\n# Note\\n- This will give Time Limit Executed error but must do for beginners because it help in building dp solution\\n\\n# Complexity\\n- Time complexity: $$O(3^n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        return mincostTickets(days, costs, 0, 0);\\n    }\\n    private int mincostTickets(int[] days, int[] costs, int s, int cost){\\n        if(s >= days.length) return cost;\\n        int minCost = Integer.MAX_VALUE;\\n        for(int x = 0; x<3; x++){\\n            if(x == 0){\\n                minCost = Math.min(minCost, mincostTickets(days, costs, s+1, cost+costs[0]));\\n            } else if(x == 1){\\n                int nextDay = days[s]+7-1;\\n                for(int i = s+1; i<=days.length; i++){\\n                    if(i == days.length){\\n                        minCost = Math.min(minCost, cost+costs[1]);\\n                    } else if(days[i] > nextDay){\\n                        minCost = Math.min(minCost, mincostTickets(days, costs, i, cost+costs[1]));\\n                        break;\\n                    }\\n                }\\n            } else {\\n                int nextDay = days[s]+30-1;\\n                for(int i = s+1; i<=days.length; i++){\\n                    if(i == days.length){\\n                        minCost = Math.min(minCost, cost+costs[2]);\\n                    } else if(days[i] > nextDay){\\n                        minCost = Math.min(minCost, mincostTickets(days, costs, i, cost+costs[2]));\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return minCost;\\n    }\\n}\\n\\n```\\n\\n# Approach 2 DP\\n- I call it as forward dp approach because :- \\n    - In this approach we take our current day as starting day and check for the maximum days from current day we can travel.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for(int day = 1; day <= n; day++){\\n            dp[day] = Math.min(dp[day], dp[day-1] + costs[0]);\\n            for(int i = day; i<=n; i++){\\n                if(i == n || days[i] > days[day-1]+7-1){\\n                    dp[i] = Math.min(dp[i], dp[day-1]+costs[1]);\\n                    break;\\n                }\\n            }\\n            for(int i = day; i<=n; i++){\\n                if(i == n || days[i] > days[day-1]+30-1){\\n                    dp[i] = Math.min(dp[i], dp[day-1]+costs[2]);\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n\\n```\\n\\n# Approach 3 DP easy\\n- I call it as backward dp approach because :- \\n    - In this approach we take our current day as ending day and check for the previous days from where we can reach to current day.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ where n is the maximum day in days array\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int maxDay = days[days.length-1];\\n        int[] dp = new int[maxDay+1];\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int day : days){\\n            hs.add(day);\\n        }\\n        for(int i = 1; i<=maxDay; i++){\\n            if(!hs.contains(i)){\\n                dp[i] = dp[i-1];\\n            } else {\\n                dp[i] = Math.min(dp[i-1]+costs[0], Math.min(dp[Math.max(0, i-7)] + costs[1], dp[Math.max(0, i-30)] + costs[2]));\\n            }\\n        }\\n        return dp[maxDay];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        return mincostTickets(days, costs, 0, 0);\\n    }\\n    private int mincostTickets(int[] days, int[] costs, int s, int cost){\\n        if(s >= days.length) return cost;\\n        int minCost = Integer.MAX_VALUE;\\n        for(int x = 0; x<3; x++){\\n            if(x == 0){\\n                minCost = Math.min(minCost, mincostTickets(days, costs, s+1, cost+costs[0]));\\n            } else if(x == 1){\\n                int nextDay = days[s]+7-1;\\n                for(int i = s+1; i<=days.length; i++){\\n                    if(i == days.length){\\n                        minCost = Math.min(minCost, cost+costs[1]);\\n                    } else if(days[i] > nextDay){\\n                        minCost = Math.min(minCost, mincostTickets(days, costs, i, cost+costs[1]));\\n                        break;\\n                    }\\n                }\\n            } else {\\n                int nextDay = days[s]+30-1;\\n                for(int i = s+1; i<=days.length; i++){\\n                    if(i == days.length){\\n                        minCost = Math.min(minCost, cost+costs[2]);\\n                    } else if(days[i] > nextDay){\\n                        minCost = Math.min(minCost, mincostTickets(days, costs, i, cost+costs[2]));\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return minCost;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for(int day = 1; day <= n; day++){\\n            dp[day] = Math.min(dp[day], dp[day-1] + costs[0]);\\n            for(int i = day; i<=n; i++){\\n                if(i == n || days[i] > days[day-1]+7-1){\\n                    dp[i] = Math.min(dp[i], dp[day-1]+costs[1]);\\n                    break;\\n                }\\n            }\\n            for(int i = day; i<=n; i++){\\n                if(i == n || days[i] > days[day-1]+30-1){\\n                    dp[i] = Math.min(dp[i], dp[day-1]+costs[2]);\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int maxDay = days[days.length-1];\\n        int[] dp = new int[maxDay+1];\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int day : days){\\n            hs.add(day);\\n        }\\n        for(int i = 1; i<=maxDay; i++){\\n            if(!hs.contains(i)){\\n                dp[i] = dp[i-1];\\n            } else {\\n                dp[i] = Math.min(dp[i-1]+costs[0], Math.min(dp[Math.max(0, i-7)] + costs[1], dp[Math.max(0, i-30)] + costs[2]));\\n            }\\n        }\\n        return dp[maxDay];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351197,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cost(vector<int>& days,  vector<int>& costs, int i, int n, vector<int>&dp){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int i7,i30;\\n        for(int j=i; j<n; j++){\\n            if(days[j]-days[i]+1 <= 7){\\n                i7 = j;\\n            }\\n            if(days[j]-days[i]+1 <= 30){\\n                i30 = j;\\n            }\\n            else break;\\n        }\\n        return dp[i] = min(costs[0] + cost(days,costs,i+1,n,dp),min(costs[1] + cost(days,costs,i7+1,n,dp), costs[2] + cost(days,costs,i30+1,n,dp) ) ); \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int>dp(n,-1);\\n        return cost(days,costs,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(vector<int>& days,  vector<int>& costs, int i, int n, vector<int>&dp){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int i7,i30;\\n        for(int j=i; j<n; j++){\\n            if(days[j]-days[i]+1 <= 7){\\n                i7 = j;\\n            }\\n            if(days[j]-days[i]+1 <= 30){\\n                i30 = j;\\n            }\\n            else break;\\n        }\\n        return dp[i] = min(costs[0] + cost(days,costs,i+1,n,dp),min(costs[1] + cost(days,costs,i7+1,n,dp), costs[2] + cost(days,costs,i30+1,n,dp) ) ); \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int>dp(n,-1);\\n        return cost(days,costs,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351028,
                "title": "dp-solution-implementation-with-cache-decorator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee the code snippet below.\\n---\\n---\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, $n$ is max day in `days`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        @cache\\n        def dp(day):\\n            if day <= 0: return 0\\n            if day not in days: return dp(day-1)\\n            return min(dp(day-1)+costs[0], dp(day-7)+costs[1], dp(day-30)+costs[2])\\n\\n        return dp(days[-1])\\n```\\n---\\n```\\nIf you like this solution, upvote, please !\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        @cache\\n        def dp(day):\\n            if day <= 0: return 0\\n            if day not in days: return dp(day-1)\\n            return min(dp(day-1)+costs[0], dp(day-7)+costs[1], dp(day-30)+costs[2])\\n\\n        return dp(days[-1])\\n```\n```\\nIf you like this solution, upvote, please !\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351002,
                "title": "java-easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int mincostTickets(int[] days, int[] costs) {\\n    int dp[] = new int[395];\\n    for(int d: days) dp[d+29] = 1;\\n\\n    for(int i = 30; i != dp.length; ++i)\\n      if(dp[i] == 0) dp[i] = dp[i-1];\\n      else dp[i] = Math.min(Math.min(dp[i-30] + costs[2], dp[i-7] + costs[1]), dp[i-1] + costs[0]);\\n\\n    return dp[394];      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int mincostTickets(int[] days, int[] costs) {\\n    int dp[] = new int[395];\\n    for(int d: days) dp[d+29] = 1;\\n\\n    for(int i = 30; i != dp.length; ++i)\\n      if(dp[i] == 0) dp[i] = dp[i-1];\\n      else dp[i] = Math.min(Math.min(dp[i-30] + costs[2], dp[i-7] + costs[1]), dp[i-1] + costs[0]);\\n\\n    return dp[394];      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350897,
                "title": "typescript-solution-basic-intutition",
                "content": "# Intuition\\nEvery day you can either travel or not travel. \\n- In case you are not travelling, then you can check the next day\\n- In case you are travelling, you can either purchase:\\n  - A 1 day ticket - purchase and check next day\\n  - A 7 days ticket - purchase and check 7 days from now\\n  - A 30 days ticket - purchase and check 30 days from now\\n\\n\\n# Code\\n```\\nfunction mincostTickets(days: number[], costs: number[]): number {\\n    const daySet = new Set(days);\\n\\n    const dp = (d: number): number => {\\n        if (d > 365) {\\n            return 0;\\n        }\\n\\n        if (typeof cache[d] !== \\'undefined\\') {\\n            return cache[d];\\n        }\\n\\n        return cache[d] = !daySet.has(d) ? \\n            dp(d + 1) : // d is not among travelling days, skipping\\n            Math.min(\\n                costs[0] + dp(d + 1),\\n                costs[1] + dp(d + 7),\\n                costs[2] + dp(d + 30),\\n            ); \\n    }\\n    \\n    const cache: number[] = new Array(days.length);\\n\\n    // Starts from day 1\\n    return dp(1);\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mincostTickets(days: number[], costs: number[]): number {\\n    const daySet = new Set(days);\\n\\n    const dp = (d: number): number => {\\n        if (d > 365) {\\n            return 0;\\n        }\\n\\n        if (typeof cache[d] !== \\'undefined\\') {\\n            return cache[d];\\n        }\\n\\n        return cache[d] = !daySet.has(d) ? \\n            dp(d + 1) : // d is not among travelling days, skipping\\n            Math.min(\\n                costs[0] + dp(d + 1),\\n                costs[1] + dp(d + 7),\\n                costs[2] + dp(d + 30),\\n            ); \\n    }\\n    \\n    const cache: number[] = new Array(days.length);\\n\\n    // Starts from day 1\\n    return dp(1);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3350836,
                "title": "dynamic-programming-100-faster-solution-and-greedy",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Why Greedy doesn\\'t work:***\\n- The simplest greedy approach would be similar to the fractional knapsack, taking the best cost per day plan.\\n- But, The solution doesn\\'t work because the plan must be taken in total we cannot take it per day, *Example: For 7 days plan we must take all 7 days cost even though we are using only 4 days in that plan. So, the total cost would not be reduced to per day*.\\nI don\\'t know if it was only me or if anyone would consider greedy as their first approach. This was for people who had trouble finding why greedy wouldn\\'t work.\\n\\n# Greedy Code\\n*Note: This is just an example for greedy.(However, I am not a good programmer. Any changes to the code are appreciated)*\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // we must pay the all days plan in total so, greedy fails here\\n        int start = 0;\\n        int ans = 0;\\n        while(start < days.size()){\\n        //     naive approach -> next 30 days if it has least cost per day for 30, 7 or 1 day cost take it --> greedy\\n        int cnt7=0,cnt30=0;\\n        for(int i=start; i<days.size(); i++){\\n            if(days[i]-days[start] < 7){\\n                     cnt7++;\\n                 }\\n                 if(days[i]-days[start] < 30){\\n                     cnt30++;\\n                 }else{\\n                     break;\\n                 }\\n             }\\n             // cost per day\\n             double c1 = (double)costs[0], c2 = (double)(costs[1]*7)/cnt7, c3 = (double)(costs[2]*30)/cnt30;\\n             // take day 1 and proceed\\n             if(c1 < c2 && c1 < c3){\\n                 ans += costs[0];\\n                 start++;\\n             }else if(c2 < c3){\\n                 ans += costs[1];\\n                 start += cnt7;\\n             }else{\\n                 ans += costs[2];\\n                 start += cnt30;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```\\n\\n# Approach\\n**Working Solution (Dynamic Programming):**\\n- Each day of the \\'dp\\' array represents the optimal money spent till that day.\\n- For the 1-day plan, it is easy to get the optimal cost for a particular day i.e. 1-day plan cost + dp[i-1](optimal cost till previous day).\\n- For the 7-day plan and 30-day plan, the minimum cost affects the next upcoming 30 or 7 days. So, Take the minimum cost and update the \\'dp\\' array to have minimum costs for upcoming days. This ensures that we are not taking multiple plans at the same time. \\n- For the first day, we don\\'t have any minimum value to take for the previous day. So, make sure to set the previous cost to 0 before proceeding. \\n\\n# Complexity\\n- Time complexity: **O(number of days * 30)**\\nFor each day we can atmost look for next 30 days.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(number of days)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution described is not the best solution. May have better solutions than this.\\n\\n# Dynamic Programming Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // dynamic programming knapsack and LIS kind-of problem\\n        vector<int> dp(days.size(), INT_MAX);\\n        for(int i=0; i<days.size(); i++){\\n            // cost for a day\\n            if(i == 0)\\n                dp[i] = costs[0];\\n            else\\n                dp[i] = min(dp[i-1]+costs[0], dp[i]);\\n\\n            // cost for 7-day or 30-day plan\\n            int prevCost = 0;\\n            if(i != 0)\\n                prevCost = dp[i-1];\\n            for(int j=i; j<days.size(); j++){\\n                if(days[j]-days[i] < 7){\\n                    dp[j] = min(prevCost+costs[1], dp[j]);\\n                }\\n                if(days[j]-days[i] < 30){\\n                    dp[j] = min(prevCost+costs[2], dp[j]);\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[days.size()-1];\\n    }\\n};\\n```\\n\\n**If anyone found this helpful, give an upvote.\\nThank you for reading this post**\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // we must pay the all days plan in total so, greedy fails here\\n        int start = 0;\\n        int ans = 0;\\n        while(start < days.size()){\\n        //     naive approach -> next 30 days if it has least cost per day for 30, 7 or 1 day cost take it --> greedy\\n        int cnt7=0,cnt30=0;\\n        for(int i=start; i<days.size(); i++){\\n            if(days[i]-days[start] < 7){\\n                     cnt7++;\\n                 }\\n                 if(days[i]-days[start] < 30){\\n                     cnt30++;\\n                 }else{\\n                     break;\\n                 }\\n             }\\n             // cost per day\\n             double c1 = (double)costs[0], c2 = (double)(costs[1]*7)/cnt7, c3 = (double)(costs[2]*30)/cnt30;\\n             // take day 1 and proceed\\n             if(c1 < c2 && c1 < c3){\\n                 ans += costs[0];\\n                 start++;\\n             }else if(c2 < c3){\\n                 ans += costs[1];\\n                 start += cnt7;\\n             }else{\\n                 ans += costs[2];\\n                 start += cnt30;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // dynamic programming knapsack and LIS kind-of problem\\n        vector<int> dp(days.size(), INT_MAX);\\n        for(int i=0; i<days.size(); i++){\\n            // cost for a day\\n            if(i == 0)\\n                dp[i] = costs[0];\\n            else\\n                dp[i] = min(dp[i-1]+costs[0], dp[i]);\\n\\n            // cost for 7-day or 30-day plan\\n            int prevCost = 0;\\n            if(i != 0)\\n                prevCost = dp[i-1];\\n            for(int j=i; j<days.size(); j++){\\n                if(days[j]-days[i] < 7){\\n                    dp[j] = min(prevCost+costs[1], dp[j]);\\n                }\\n                if(days[j]-days[i] < 30){\\n                    dp[j] = min(prevCost+costs[2], dp[j]);\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[days.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350804,
                "title": "java-solution-all-approaches-recursion-memoization-tabulation-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this by Dynamic Programming.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can apply Memoization and Tabulation for better complexity.\\n\\n# Complexity\\n- **Time complexity: O(n)** because we have days array with size n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(n)** cause we are using addtion dp array of size(n+1)\\n\\n**If we use space optimization then Space complexity would be O(1).**\\n\\n# Code Approaches\\n\\n`Recursion Solution will give you TLE so after that we should optimize our code to Memoization or Tabulation`.\\n\\n```Recursion []\\n    //Using Recursion\\n     int solve(int n, int[] days, int[] costs, int index)\\n     {\\n         if(index >= n)\\n         {\\n             return 0;\\n         }\\n\\n         //1 day pass\\n         int option1 = costs[0] + solve(n, days, costs, index+1);\\n\\n         //7 day pass\\n         int i;\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +7; i++);\\n\\n         int option2 = costs[1] + solve(n, days, costs, i);\\n\\n         //30 day pass\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +30; i++);\\n\\n         int option3 = costs[2] + solve(n, days, costs, i);\\n\\n        return Math.min(option1, Math.min(option2,option3));\\n     }\\n\\n```\\n```Memoization []\\n     //Using Memoization\\n     int solve(int n, int[] days, int[] costs, int index, int[] dp)\\n     {\\n         if(index >= n)\\n         {\\n             return 0;\\n         }\\n\\n         if(dp[index] != -1)\\n         {\\n             return dp[index];\\n         }\\n\\n         //1 day pass\\n         int option1 = costs[0] + solve(n, days, costs, index+1, dp);\\n\\n         //7 day pass\\n         int i;\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +7; i++);\\n\\n         int option2 = costs[1] + solve(n, days, costs, i, dp);\\n\\n         //30 day pass\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +30; i++);\\n\\n         int option3 = costs[2] + solve(n, days, costs, i, dp);\\n\\n         dp[index] = Math.min(option1, Math.min(option2,option3));\\n\\n         return dp[index];\\n     }\\n\\n```\\n```Tabulation []\\n    //Using Tabulation\\n    int solve(int n, int[] days, int[] costs, int index)\\n    {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            //1 day pass\\n            int option1 = costs[0] + dp[k+1];\\n\\n            //7 day pass\\n            int i;\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +7; i++);\\n\\n            int option2 = costs[1] + dp[i];\\n\\n            //30 day pass\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +30; i++);\\n\\n            int option3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(option1, Math.min(option2,option3));\\n        }\\n\\n        return dp[0];\\n\\n    }\\n```\\n```Space_Optimization []\\n\\n    int solve(int n, int[] days, int[] costs)\\n    {\\n        Queue<int[]> week = new LinkedList<>();\\n        Queue<int[]> month = new LinkedList<>();\\n   \\n        int ans= 0;\\n\\n        for (int t : days) {\\n            while (!week .isEmpty() && week.peek()[0] + 7 <= t) {\\n                week.poll();\\n            }\\n            while (!month.isEmpty() && month.peek()[0] + 30 <= t) {\\n                month.poll();\\n            }\\n            week.offer(new int[]{t, ans + costs[1]});\\n            month.offer(new int[]{t, ans + costs[2]});\\n            ans= Math.min(ans + costs[0], Math.min(week.peek()[1], month.peek()[1]));\\n        }\\n\\n        return ans;\\n    }\\n    \\n```\\n \\n# Code\\n\\n**I Solved by Tabulation you can use \"Space Optimization Solution\" as well.** \\n```\\nclass Solution {\\n\\n    //Using Tabulation\\n    int solve(int n, int[] days, int[] costs, int index)\\n    {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            //1 day pass\\n            int option1 = costs[0] + dp[k+1];\\n\\n            //7 day pass\\n            int i;\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +7; i++);\\n\\n            int option2 = costs[1] + dp[i];\\n\\n            //30 day pass\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +30; i++);\\n\\n            int option3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(option1, Math.min(option2,option3));\\n        }\\n\\n        return dp[0];\\n\\n    }\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int n = days.length;\\n        // int[] dp = new int[n+1];\\n        // Arrays.fill(dp, -1);\\n        return solve(n, days, costs, 0);\\n    }\\n}\\n```\\n# Please Upvote \\uD83D\\uDC4D\\n\\n```\\nIf you like my all approaches. \\nPlease give my solution upvote !!!.\\nIt really motivates me.\\nKeep me motivated.\\nThank you! \\uD83D\\uDE0A\\n```\\n\\n![3dv7yo.jpg](https://assets.leetcode.com/users/images/6e634d87-fe4b-485a-a8a9-bca79eba9fa7_1679993240.6115506.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```Recursion []\\n    //Using Recursion\\n     int solve(int n, int[] days, int[] costs, int index)\\n     {\\n         if(index >= n)\\n         {\\n             return 0;\\n         }\\n\\n         //1 day pass\\n         int option1 = costs[0] + solve(n, days, costs, index+1);\\n\\n         //7 day pass\\n         int i;\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +7; i++);\\n\\n         int option2 = costs[1] + solve(n, days, costs, i);\\n\\n         //30 day pass\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +30; i++);\\n\\n         int option3 = costs[2] + solve(n, days, costs, i);\\n\\n        return Math.min(option1, Math.min(option2,option3));\\n     }\\n\\n```\n```Memoization []\\n     //Using Memoization\\n     int solve(int n, int[] days, int[] costs, int index, int[] dp)\\n     {\\n         if(index >= n)\\n         {\\n             return 0;\\n         }\\n\\n         if(dp[index] != -1)\\n         {\\n             return dp[index];\\n         }\\n\\n         //1 day pass\\n         int option1 = costs[0] + solve(n, days, costs, index+1, dp);\\n\\n         //7 day pass\\n         int i;\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +7; i++);\\n\\n         int option2 = costs[1] + solve(n, days, costs, i, dp);\\n\\n         //30 day pass\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +30; i++);\\n\\n         int option3 = costs[2] + solve(n, days, costs, i, dp);\\n\\n         dp[index] = Math.min(option1, Math.min(option2,option3));\\n\\n         return dp[index];\\n     }\\n\\n```\n```Tabulation []\\n    //Using Tabulation\\n    int solve(int n, int[] days, int[] costs, int index)\\n    {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            //1 day pass\\n            int option1 = costs[0] + dp[k+1];\\n\\n            //7 day pass\\n            int i;\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +7; i++);\\n\\n            int option2 = costs[1] + dp[i];\\n\\n            //30 day pass\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +30; i++);\\n\\n            int option3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(option1, Math.min(option2,option3));\\n        }\\n\\n        return dp[0];\\n\\n    }\\n```\n```Space_Optimization []\\n\\n    int solve(int n, int[] days, int[] costs)\\n    {\\n        Queue<int[]> week = new LinkedList<>();\\n        Queue<int[]> month = new LinkedList<>();\\n   \\n        int ans= 0;\\n\\n        for (int t : days) {\\n            while (!week .isEmpty() && week.peek()[0] + 7 <= t) {\\n                week.poll();\\n            }\\n            while (!month.isEmpty() && month.peek()[0] + 30 <= t) {\\n                month.poll();\\n            }\\n            week.offer(new int[]{t, ans + costs[1]});\\n            month.offer(new int[]{t, ans + costs[2]});\\n            ans= Math.min(ans + costs[0], Math.min(week.peek()[1], month.peek()[1]));\\n        }\\n\\n        return ans;\\n    }\\n    \\n```\n```\\nclass Solution {\\n\\n    //Using Tabulation\\n    int solve(int n, int[] days, int[] costs, int index)\\n    {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            //1 day pass\\n            int option1 = costs[0] + dp[k+1];\\n\\n            //7 day pass\\n            int i;\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +7; i++);\\n\\n            int option2 = costs[1] + dp[i];\\n\\n            //30 day pass\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +30; i++);\\n\\n            int option3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(option1, Math.min(option2,option3));\\n        }\\n\\n        return dp[0];\\n\\n    }\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int n = days.length;\\n        // int[] dp = new int[n+1];\\n        // Arrays.fill(dp, -1);\\n        return solve(n, days, costs, 0);\\n    }\\n}\\n```\n```\\nIf you like my all approaches. \\nPlease give my solution upvote !!!.\\nIt really motivates me.\\nKeep me motivated.\\nThank you! \\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350121,
                "title": "time-o-n-space-o-365-with-comments-c-easy-to-understand-short-sweet",
                "content": "````\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> v(367,INT_MAX);//INITIALIZE ANS FOR EVERY DAY TO INFINITY\\n        v[366] = 0;\\n        int i = 0, j = 0,n = days.size();\\n        i = n-1;\\n        for(j = 365; j >=0; j--){\\n            if(i>=0&&days[i]==j){\\n                if(j+1<=366){//BUY 1-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+1th DAY \\n                    v[j] = min(v[j],v[j+1]+costs[0]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+1]if(j+1<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[0]);//other wise v[j] = min(v[j],costs[0])\\n                }\\n                if(j+7<=366){//BUY 7-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+7th DAY \\n                    v[j] = min(v[j],v[j+7]+costs[1]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+7]if(j+7<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[1]);;//other wise v[j] = min(v[j],costs[1])\\n                }\\n                if(j+30<=366){//BUY 30-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+30th DAY \\n                    v[j] = min(v[j],v[j+30]+costs[2]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+30]if(j+30<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[2]);;//other wise v[j] = min(v[j],costs[2])\\n                }\\n                i--;\\n            }else{\\n                v[j] = v[j+1];\\n            }\\n        }\\n        // for(int i = 0; i <= days[n-1]; i++){\\n        //     cout<<v[i]<<\" \";\\n        // }\\n        return v[days[0]];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> v(367,INT_MAX);//INITIALIZE ANS FOR EVERY DAY TO INFINITY\\n        v[366] = 0;\\n        int i = 0, j = 0,n = days.size();\\n        i = n-1;\\n        for(j = 365; j >=0; j--){\\n            if(i>=0&&days[i]==j){\\n                if(j+1<=366){//BUY 1-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+1th DAY \\n                    v[j] = min(v[j],v[j+1]+costs[0]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+1]if(j+1<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[0]);//other wise v[j] = min(v[j],costs[0])\\n                }\\n                if(j+7<=366){//BUY 7-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+7th DAY \\n                    v[j] = min(v[j],v[j+7]+costs[1]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+7]if(j+7<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[1]);;//other wise v[j] = min(v[j],costs[1])\\n                }\\n                if(j+30<=366){//BUY 30-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+30th DAY \\n                    v[j] = min(v[j],v[j+30]+costs[2]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+30]if(j+30<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[2]);;//other wise v[j] = min(v[j],costs[2])\\n                }\\n                i--;\\n            }else{\\n                v[j] = v[j+1];\\n            }\\n        }\\n        // for(int i = 0; i <= days[n-1]; i++){\\n        //     cout<<v[i]<<\" \";\\n        // }\\n        return v[days[0]];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3331696,
                "title": "java-dp-memoization-0ms-runtime-beats-100",
                "content": "``` java []\\n// Memoization \\n// Beats 100%\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        boolean[] isPresent = new boolean[days[days.length-1]+1];\\n        for(int x:days){\\n            isPresent[x]=true;\\n        }\\n        Integer[] dp = new Integer[isPresent.length];\\n        return solve(isPresent,days[0],costs,dp);\\n    }\\n\\n    private int solve(boolean[] isPresent,int day,int[] costs,Integer[] dp){\\n        if(day>=isPresent.length){\\n            return 0;\\n        }\\n        if(dp[day]!=null){\\n            return dp[day];\\n        }\\n        if(isPresent[day]){\\n           int a = costs[0] + solve(isPresent,day+1,costs,dp);\\n           int b = costs[1] + solve(isPresent,day+7,costs,dp);\\n           int c = costs[2] + solve(isPresent,day+30,costs,dp);\\n           return dp[day] = Math.min(a,Math.min(b,c));\\n        }\\n        else{\\n            return dp[day] = solve(isPresent,day+1,costs,dp);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` java []\\n// Memoization \\n// Beats 100%\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        boolean[] isPresent = new boolean[days[days.length-1]+1];\\n        for(int x:days){\\n            isPresent[x]=true;\\n        }\\n        Integer[] dp = new Integer[isPresent.length];\\n        return solve(isPresent,days[0],costs,dp);\\n    }\\n\\n    private int solve(boolean[] isPresent,int day,int[] costs,Integer[] dp){\\n        if(day>=isPresent.length){\\n            return 0;\\n        }\\n        if(dp[day]!=null){\\n            return dp[day];\\n        }\\n        if(isPresent[day]){\\n           int a = costs[0] + solve(isPresent,day+1,costs,dp);\\n           int b = costs[1] + solve(isPresent,day+7,costs,dp);\\n           int c = costs[2] + solve(isPresent,day+30,costs,dp);\\n           return dp[day] = Math.min(a,Math.min(b,c));\\n        }\\n        else{\\n            return dp[day] = solve(isPresent,day+1,costs,dp);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255576,
                "title": "dp-bs-memoization-tabulation-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &days, vector<int> &costs, vector<int> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int one = costs[0] + dfs(i + 1, n, days, costs, dp);\\n        \\n        int pos1 = lower_bound(days.begin(), days.end(), days[i] + 7) - days.begin();\\n        int seven = costs[1] + dfs(pos1, n, days, costs, dp);\\n\\n        int pos2 = lower_bound(days.begin(), days.end(), days[i] + 30) - days.begin();\\n        int thirty = costs[2] + dfs(pos2, n, days, costs, dp);\\n\\n        return dp[i] = min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n, -1);\\n        return dfs(0, n, days, costs, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n + 1);\\n\\n        for(int i=n-1; i>=0; i--) {\\n            int one = costs[0] + dp[i + 1];\\n        \\n            int pos1 = lower_bound(days.begin(), days.end(), days[i] + 7) - days.begin();\\n            int seven = costs[1] + dp[pos1];\\n\\n            int pos2 = lower_bound(days.begin(), days.end(), days[i] + 30) - days.begin();\\n            int thirty = costs[2] + dp[pos2];\\n\\n            dp[i] = min({one, seven, thirty});\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &days, vector<int> &costs, vector<int> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int one = costs[0] + dfs(i + 1, n, days, costs, dp);\\n        \\n        int pos1 = lower_bound(days.begin(), days.end(), days[i] + 7) - days.begin();\\n        int seven = costs[1] + dfs(pos1, n, days, costs, dp);\\n\\n        int pos2 = lower_bound(days.begin(), days.end(), days[i] + 30) - days.begin();\\n        int thirty = costs[2] + dfs(pos2, n, days, costs, dp);\\n\\n        return dp[i] = min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n, -1);\\n        return dfs(0, n, days, costs, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n + 1);\\n\\n        for(int i=n-1; i>=0; i--) {\\n            int one = costs[0] + dp[i + 1];\\n        \\n            int pos1 = lower_bound(days.begin(), days.end(), days[i] + 7) - days.begin();\\n            int seven = costs[1] + dp[pos1];\\n\\n            int pos2 = lower_bound(days.begin(), days.end(), days[i] + 30) - days.begin();\\n            int thirty = costs[2] + dp[pos2];\\n\\n            dp[i] = min({one, seven, thirty});\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236585,
                "title": "dynamic-programming-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int f(vector<int> &nums,int ind,vector<int> &cost,int n){\\n        \\n        if(ind>=n) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        \\n        int way1 = cost[0] + f(nums,ind+1,cost,n);\\n        int tempInd = ind;\\n        while(tempInd<n && nums[tempInd]-nums[ind]<7){\\n            tempInd++;\\n        }\\n        int way2 = cost[1] + f(nums,tempInd,cost,n);\\n        tempInd = ind;\\n        while(tempInd<n && nums[tempInd]-nums[ind]<30){\\n            tempInd++;\\n        }\\n        int way3 = cost[2] + f(nums,tempInd,cost,n);\\n        return dp[ind] = min(way1,min(way2,way3));\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(days,0,costs,days.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int f(vector<int> &nums,int ind,vector<int> &cost,int n){\\n        \\n        if(ind>=n) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        \\n        int way1 = cost[0] + f(nums,ind+1,cost,n);\\n        int tempInd = ind;\\n        while(tempInd<n && nums[tempInd]-nums[ind]<7){\\n            tempInd++;\\n        }\\n        int way2 = cost[1] + f(nums,tempInd,cost,n);\\n        tempInd = ind;\\n        while(tempInd<n && nums[tempInd]-nums[ind]<30){\\n            tempInd++;\\n        }\\n        int way3 = cost[2] + f(nums,tempInd,cost,n);\\n        return dp[ind] = min(way1,min(way2,way3));\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(days,0,costs,days.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210827,
                "title": "minimum-cost-for-tickets-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int ans = 0;\\n        queue<pair<int,int>> monthly;\\n        queue<pair<int,int>> weekly;\\n\\n        for(int day : days){\\n            //step 1 : remove expired days\\n            while(!monthly.empty() && monthly.front().first + 30 <= day){\\n                monthly.pop();\\n            }\\n\\n            while(!weekly.empty() && weekly.front().first + 7 <= day){\\n                weekly.pop();\\n            }\\n\\n            //step 2 : add cost for current day\\n            monthly.push(make_pair(day , ans + costs[2]));\\n            weekly.push(make_pair(day , ans + costs[1]));\\n\\n            ans = min(ans + costs[0] , min(monthly.front().second , weekly.front().second));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int ans = 0;\\n        queue<pair<int,int>> monthly;\\n        queue<pair<int,int>> weekly;\\n\\n        for(int day : days){\\n            //step 1 : remove expired days\\n            while(!monthly.empty() && monthly.front().first + 30 <= day){\\n                monthly.pop();\\n            }\\n\\n            while(!weekly.empty() && weekly.front().first + 7 <= day){\\n                weekly.pop();\\n            }\\n\\n            //step 2 : add cost for current day\\n            monthly.push(make_pair(day , ans + costs[2]));\\n            weekly.push(make_pair(day , ans + costs[1]));\\n\\n            ans = min(ans + costs[0] , min(monthly.front().second , weekly.front().second));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182214,
                "title": "dp-recursive-memoization-c-3ms-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int n, vector<int>& days, vector<int>& costs, vector<int> &dp)\\n    {\\n        if(idx>=n) return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n        int day_1=costs[0]+solve(idx+1,n,days,costs,dp);\\n        \\n        int new_idx=upper_bound(days.begin(),days.end(),days[idx]+6)-days.begin();\\n        int day_7=costs[1]+solve(new_idx,n,days,costs,dp);\\n        \\n        int new_idx1=upper_bound(days.begin(),days.end(),days[idx]+29)-days.begin();\\n        int mn=costs[2]+solve(new_idx1,n,days,costs,dp);\\n        \\n        return dp[idx]=min(day_1,min(day_7,mn));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,n,days,costs,dp);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/68e3bb93-975a-4e5d-88e1-4723bd06cfb9_1676315355.202165.png)\\n\\n# If it is helpful for you please upvote \\uD83D\\uDC46. Keep coding \\uD83D\\uDE0A\\uD83D\\uDC4D \\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int n, vector<int>& days, vector<int>& costs, vector<int> &dp)\\n    {\\n        if(idx>=n) return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n        int day_1=costs[0]+solve(idx+1,n,days,costs,dp);\\n        \\n        int new_idx=upper_bound(days.begin(),days.end(),days[idx]+6)-days.begin();\\n        int day_7=costs[1]+solve(new_idx,n,days,costs,dp);\\n        \\n        int new_idx1=upper_bound(days.begin(),days.end(),days[idx]+29)-days.begin();\\n        int mn=costs[2]+solve(new_idx1,n,days,costs,dp);\\n        \\n        return dp[idx]=min(day_1,min(day_7,mn));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,n,days,costs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089689,
                "title": "4ms-soln-very-intuitive-easy-recursion-memoization-upper-bound",
                "content": "**Every day you have 3 different options to choose the pass, suppose if you choose the 7 day pass you can, then you just have to find the upper bound of currDay value + 6 and similarly for other options.**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int>& days, vector<int>& cost, vector<int> &dp){\\n        if(i>=days.size())  return 0;\\n        if(dp[i]!=-1)   return dp[i];\\n        int a=0,b=0,c=0;\\n        int ind = upper_bound(days.begin(), days.end(), days[i]+0)-days.begin();\\n        a = cost[0] + solve(ind,days,cost,dp);\\n        ind = upper_bound(days.begin(), days.end(), days[i]+6)-days.begin();\\n        b = cost[1] + solve(ind,days,cost,dp);\\n        ind = upper_bound(days.begin(), days.end(), days[i]+29)-days.begin();\\n        c = cost[2] + solve(ind,days,cost,dp);\\n\\n        return dp[i] = min({a,b,c});\\n\\n\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> dp(366,-1);\\n        return solve(0,days, costs,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int>& days, vector<int>& cost, vector<int> &dp){\\n        if(i>=days.size())  return 0;\\n        if(dp[i]!=-1)   return dp[i];\\n        int a=0,b=0,c=0;\\n        int ind = upper_bound(days.begin(), days.end(), days[i]+0)-days.begin();\\n        a = cost[0] + solve(ind,days,cost,dp);\\n        ind = upper_bound(days.begin(), days.end(), days[i]+6)-days.begin();\\n        b = cost[1] + solve(ind,days,cost,dp);\\n        ind = upper_bound(days.begin(), days.end(), days[i]+29)-days.begin();\\n        c = cost[2] + solve(ind,days,cost,dp);\\n\\n        return dp[i] = min({a,b,c});\\n\\n\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> dp(366,-1);\\n        return solve(0,days, costs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968702,
                "title": "easy-to-understand-binary-search-with-dp-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    int getNextDay(vector<int>& days, int dayIdx, int numDays) {\\n        int lastDay = days[dayIdx] + numDays;\\n        auto it = lower_bound(begin(days)+dayIdx, end(days), lastDay);\\n        if(it == days.end()) return days.size();\\n        int newDayIdx = it - days.begin();\\n        return newDayIdx;\\n    }\\n    \\n    int getMinCost(vector<int>& days, vector<int>& costs, int dayIdx) {\\n        if (dayIdx == days.size())\\n            return 0;\\n        if (dp[dayIdx] != -1)\\n            return dp[dayIdx];\\n        // Assume on a given day we bought a particular ticket\\n        // then recurse on remaining days function getNextDay tells till what time\\n        // current ticket is valid\\n        int totalDayCost = costs[0] + getMinCost(days,costs,getNextDay(days,dayIdx,1));\\n        int totalWeekCost = costs[1] + getMinCost(days,costs,getNextDay(days,dayIdx,7));\\n        int totalMonthCost = costs[2] + getMinCost(days,costs,getNextDay(days,dayIdx,30));\\n        dp[dayIdx]  = min({totalDayCost,totalWeekCost,totalMonthCost});\\n        return dp[dayIdx];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp = vector<int>(days.size(),-1);\\n        return getMinCost(days,costs,0);\\n    }\\n};\\n\\nclass Solution1 {\\npublic:\\n    vector<int> dp;\\n    \\n    int getNextDay(vector<int>& days, int dayIdx, int numDays) {\\n        int lastDay = days[dayIdx] + numDays-1;\\n        int newDayIdx = dayIdx;\\n        while(newDayIdx < days.size() && days[newDayIdx] <= lastDay)\\n            newDayIdx++;\\n        return newDayIdx;\\n    }\\n    int getMinCost(vector<int>& days, vector<int>& costs, int dayIdx) {\\n        if (dayIdx == days.size())\\n            return 0;\\n        if (dp[dayIdx] != -1)\\n            return dp[dayIdx];\\n        // Assume on a given day we bought a particular ticket\\n        // then recurse on remaining days function getNextDay tells till what time\\n        // current ticket is valid\\n        int totalDayCost = costs[0] + getMinCost(days,costs,getNextDay(days,dayIdx,1));\\n        int totalWeekCost = costs[1] + getMinCost(days,costs,getNextDay(days,dayIdx,7));\\n        int totalMonthCost = costs[2] + getMinCost(days,costs,getNextDay(days,dayIdx,30));\\n        dp[dayIdx]  = min({totalDayCost,totalWeekCost,totalMonthCost});\\n        return dp[dayIdx];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp = vector<int>(days.size(),-1);\\n        return getMinCost(days,costs,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    int getNextDay(vector<int>& days, int dayIdx, int numDays) {\\n        int lastDay = days[dayIdx] + numDays;\\n        auto it = lower_bound(begin(days)+dayIdx, end(days), lastDay);\\n        if(it == days.end()) return days.size();\\n        int newDayIdx = it - days.begin();\\n        return newDayIdx;\\n    }\\n    \\n    int getMinCost(vector<int>& days, vector<int>& costs, int dayIdx) {\\n        if (dayIdx == days.size())\\n            return 0;\\n        if (dp[dayIdx] != -1)\\n            return dp[dayIdx];\\n        // Assume on a given day we bought a particular ticket\\n        // then recurse on remaining days function getNextDay tells till what time\\n        // current ticket is valid\\n        int totalDayCost = costs[0] + getMinCost(days,costs,getNextDay(days,dayIdx,1));\\n        int totalWeekCost = costs[1] + getMinCost(days,costs,getNextDay(days,dayIdx,7));\\n        int totalMonthCost = costs[2] + getMinCost(days,costs,getNextDay(days,dayIdx,30));\\n        dp[dayIdx]  = min({totalDayCost,totalWeekCost,totalMonthCost});\\n        return dp[dayIdx];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp = vector<int>(days.size(),-1);\\n        return getMinCost(days,costs,0);\\n    }\\n};\\n\\nclass Solution1 {\\npublic:\\n    vector<int> dp;\\n    \\n    int getNextDay(vector<int>& days, int dayIdx, int numDays) {\\n        int lastDay = days[dayIdx] + numDays-1;\\n        int newDayIdx = dayIdx;\\n        while(newDayIdx < days.size() && days[newDayIdx] <= lastDay)\\n            newDayIdx++;\\n        return newDayIdx;\\n    }\\n    int getMinCost(vector<int>& days, vector<int>& costs, int dayIdx) {\\n        if (dayIdx == days.size())\\n            return 0;\\n        if (dp[dayIdx] != -1)\\n            return dp[dayIdx];\\n        // Assume on a given day we bought a particular ticket\\n        // then recurse on remaining days function getNextDay tells till what time\\n        // current ticket is valid\\n        int totalDayCost = costs[0] + getMinCost(days,costs,getNextDay(days,dayIdx,1));\\n        int totalWeekCost = costs[1] + getMinCost(days,costs,getNextDay(days,dayIdx,7));\\n        int totalMonthCost = costs[2] + getMinCost(days,costs,getNextDay(days,dayIdx,30));\\n        dp[dayIdx]  = min({totalDayCost,totalWeekCost,totalMonthCost});\\n        return dp[dayIdx];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp = vector<int>(days.size(),-1);\\n        return getMinCost(days,costs,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741364,
                "title": "python-simple-code-dp-with-binary-search-memoization-98-faster",
                "content": "\\tclass Solution:\\n\\t\\tdef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef solve(ind):\\n\\t\\t\\t\\tif ind>=len(days):\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\toneDayCost = costs[0]+solve(ind+1)\\n\\t\\t\\t\\ttwoDayCost=costs[1]\\n\\t\\t\\t\\ti=ind\\n\\t\\t\\t\\twhile i<len(days) and days[i]<days[ind]+7:\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\ttwoDayCost +=solve(i)\\n\\t\\t\\t\\tthreeDayCost=costs[2]\\n\\t\\t\\t\\ti=ind\\n\\t\\t\\t\\twhile i<len(days) and days[i]<days[ind]+30:\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\tthreeDayCost +=solve(i)\\n\\t\\t\\t\\treturn min(oneDayCost,twoDayCost,threeDayCost)\\n\\t\\t\\treturn solve(0)\\n\\n\\n\\t#With Binary Search\\n\\t\\tclass Solution:\\n\\t\\t\\tdef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t\\t\\t@lru_cache(None)\\n\\t\\t\\t\\tdef solve(ind):\\n\\t\\t\\t\\t\\tif ind>=len(days):\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\toneDayCost = costs[0]+solve(ind+1)\\n\\t\\t\\t\\t\\ttwoDayCost=costs[1]\\n\\t\\t\\t\\t\\ti=bisect_left(days,days[ind]+7)\\n\\t\\t\\t\\t\\t# while i<len(days) and days[i]<days[ind]+7:\\n\\t\\t\\t\\t\\t#     i+=1\\n\\t\\t\\t\\t\\ttwoDayCost +=solve(i)\\n\\t\\t\\t\\t\\tthreeDayCost=costs[2]\\n\\t\\t\\t\\t\\ti=bisect_left(days,days[ind]+30)\\n\\t\\t\\t\\t\\t# while i<len(days) and days[i]<days[ind]+30:\\n\\t\\t\\t\\t\\t#     i+=1\\n\\t\\t\\t\\t\\tthreeDayCost +=solve(i)\\n\\t\\t\\t\\t\\treturn min(oneDayCost,twoDayCost,threeDayCost)\\n\\t\\t\\t\\treturn solve(0)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef solve(ind):\\n\\t\\t\\t\\tif ind>=len(days):\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\toneDayCost = costs[0]+solve(ind+1)\\n\\t\\t\\t\\ttwoDayCost=costs[1]\\n\\t\\t\\t\\ti=ind\\n\\t\\t\\t\\twhile i<len(days) and days[i]<days[ind]+7:\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\ttwoDayCost +=solve(i)\\n\\t\\t\\t\\tthreeDayCost=costs[2]\\n\\t\\t\\t\\ti=ind\\n\\t\\t\\t\\twhile i<len(days) and days[i]<days[ind]+30:\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\tthreeDayCost +=solve(i)\\n\\t\\t\\t\\treturn min(oneDayCost,twoDayCost,threeDayCost)\\n\\t\\t\\treturn solve(0)\\n\\n\\n\\t#With Binary Search\\n\\t\\tclass Solution:\\n\\t\\t\\tdef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t\\t\\t@lru_cache(None)\\n\\t\\t\\t\\tdef solve(ind):\\n\\t\\t\\t\\t\\tif ind>=len(days):\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\toneDayCost = costs[0]+solve(ind+1)\\n\\t\\t\\t\\t\\ttwoDayCost=costs[1]\\n\\t\\t\\t\\t\\ti=bisect_left(days,days[ind]+7)\\n\\t\\t\\t\\t\\t# while i<len(days) and days[i]<days[ind]+7:\\n\\t\\t\\t\\t\\t#     i+=1\\n\\t\\t\\t\\t\\ttwoDayCost +=solve(i)\\n\\t\\t\\t\\t\\tthreeDayCost=costs[2]\\n\\t\\t\\t\\t\\ti=bisect_left(days,days[ind]+30)\\n\\t\\t\\t\\t\\t# while i<len(days) and days[i]<days[ind]+30:\\n\\t\\t\\t\\t\\t#     i+=1\\n\\t\\t\\t\\t\\tthreeDayCost +=solve(i)\\n\\t\\t\\t\\t\\treturn min(oneDayCost,twoDayCost,threeDayCost)\\n\\t\\t\\t\\treturn solve(0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2491491,
                "title": "80-tc-easy-python-solution",
                "content": "```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tn = len(days)\\n\\tdp = dict()\\n\\tdef solve(i, m):\\n\\t\\tif(i == n): return 0\\n\\t\\tif(m >= days[i]):\\n\\t\\t\\treturn solve(i+1, m)\\n\\t\\tif(i in dp): return dp[i]\\n\\t\\tdp[i] = min([costs[0] + solve(i+1, days[i]), costs[1] + solve(i+1, days[i]+6), costs[2] + solve(i+1, days[i]+29)])\\n\\t\\treturn dp[i]\\n\\n\\treturn solve(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tn = len(days)\\n\\tdp = dict()\\n\\tdef solve(i, m):\\n\\t\\tif(i == n): return 0\\n\\t\\tif(m >= days[i]):\\n\\t\\t\\treturn solve(i+1, m)\\n\\t\\tif(i in dp): return dp[i]\\n\\t\\tdp[i] = min([costs[0] + solve(i+1, days[i]), costs[1] + solve(i+1, days[i]+6), costs[2] + solve(i+1, days[i]+29)])\\n\\t\\treturn dp[i]\\n\\n\\treturn solve(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2484497,
                "title": "easy-java-solution",
                "content": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        dp[n] = 0;\\n        for(int k=n-1; k>=0; k--){\\n            int op1 = costs[0] + dp[k+1];\\n            int i;\\n            for(i=k; i<n && days[i] < days[k] + 7; i++);\\n            int op2 = costs[1] + dp[i];\\n\\n            for(i=k; i<n && days[i] < days[k] + 30; i++);\\n            int op3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(op1, Math.min(op2, op3));\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        dp[n] = 0;\\n        for(int k=n-1; k>=0; k--){\\n            int op1 = costs[0] + dp[k+1];\\n            int i;\\n            for(i=k; i<n && days[i] < days[k] + 7; i++);\\n            int op2 = costs[1] + dp[i];\\n\\n            for(i=k; i<n && days[i] < days[k] + 30; i++);\\n            int op3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(op1, Math.min(op2, op3));\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2410873,
                "title": "c-3-methods-recursion-memoization-tabulation-method-solving-by-queue",
                "content": "```\\nclass Solution {\\n    \\n    \\n        \\n      int SolveMemo(int index , vector<int>& days, vector<int>& costs,  vector<int> &dp)\\n    {\\n        if(index  == days.size())\\n            return 0;\\n        \\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        //1 day Pass\\n        int op1 = costs[0] + SolveMemo(index+1 , days, costs, dp);\\n        \\n        //7 Day pass\\n        int i = index+1 ;\\n        while( i<days.size() && days[i]-days[index]<7 )\\n            i++;\\n        \\n        int op2 = costs[1] + SolveMemo(i , days, costs, dp);\\n        \\n        //7 Day pass\\n         while( i<days.size() && days[i]-days[index]<30 )\\n             i++;\\n        \\n        int op3 = costs[2] + SolveMemo(i , days, costs, dp);\\n        \\n        return dp[index] = min(op1 , min(op2, op3));\\n    }\\n    \\n    int SolveTabulation(vector<int>& days, vector<int>& costs)\\n    {\\n          vector<int> dp(days.size()+1 , 0);\\n        \\n        for(int k = days.size()-1 ; k>=0 ; k--)\\n        {\\n             //1 day Pass\\n        int op1 = costs[0] + dp[k+1];\\n        \\n        //7 Day pass\\n        int i = k+1 ;\\n        while( i<days.size() && days[i]-days[k]<7 )\\n            i++;\\n        \\n        int op2 = costs[1] + dp[i];\\n        \\n        //7 Day pass\\n         while( i<days.size() && days[i]-days[k]<30 )\\n             i++;\\n        \\n        int op3 = costs[2] + dp[i];\\n            \\n            dp[k] =  min(op1 , min(op2, op3));\\n        }\\n        \\n        return dp[0];\\n    }\\n    \\n    int SolveByQueue(vector<int>& days, vector<int>& costs)\\n    {\\n        int ans  = 0;\\n        \\n        queue<pair<int, int>> week;\\n        \\n        queue<pair<int, int>> month;\\n        \\n        for (auto day : days)\\n    {\\n        while (!week.empty() && week.front().first + 7 <= day)\\n            week.pop();\\n\\n        while (!month.empty() && month.front().first + 30 <= day)\\n            month.pop();\\n\\n        week.push(make_pair(day, ans + costs[1]));\\n        month.push(make_pair(day, ans + costs[2]));\\n\\n        \\n        ans = min(ans + costs[0], min(week.front().second, month.front().second));\\n    }\\n\\n        \\n        return ans;\\n        \\n    }\\n    \\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n      \\n        // Recursion + Memoization -> Uncomment This Part\\n        // vector<int> dp(days.size() , -1);\\n        // return SolveMemo(0 , days, costs, dp);\\n        \\n        \\n        //Tabulation Method -> Uncomment this part\\n        //return SolveTabulation(days, costs);\\n        \\n        //Queue Method -> Uncomment This part\\n        return SolveByQueue(days, costs);\\n    }\\n};\\n\\n// Pls Upvote If You Like It , Thanks !!\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n        \\n      int SolveMemo(int index , vector<int>& days, vector<int>& costs,  vector<int> &dp)\\n    {\\n        if(index  == days.size())\\n            return 0;\\n        \\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        //1 day Pass\\n        int op1 = costs[0] + SolveMemo(index+1 , days, costs, dp);\\n        \\n        //7 Day pass\\n        int i = index+1 ;\\n        while( i<days.size() && days[i]-days[index]<7 )\\n            i++;\\n        \\n        int op2 = costs[1] + SolveMemo(i , days, costs, dp);\\n        \\n        //7 Day pass\\n         while( i<days.size() && days[i]-days[index]<30 )\\n             i++;\\n        \\n        int op3 = costs[2] + SolveMemo(i , days, costs, dp);\\n        \\n        return dp[index] = min(op1 , min(op2, op3));\\n    }\\n    \\n    int SolveTabulation(vector<int>& days, vector<int>& costs)\\n    {\\n          vector<int> dp(days.size()+1 , 0);\\n        \\n        for(int k = days.size()-1 ; k>=0 ; k--)\\n        {\\n             //1 day Pass\\n        int op1 = costs[0] + dp[k+1];\\n        \\n        //7 Day pass\\n        int i = k+1 ;\\n        while( i<days.size() && days[i]-days[k]<7 )\\n            i++;\\n        \\n        int op2 = costs[1] + dp[i];\\n        \\n        //7 Day pass\\n         while( i<days.size() && days[i]-days[k]<30 )\\n             i++;\\n        \\n        int op3 = costs[2] + dp[i];\\n            \\n            dp[k] =  min(op1 , min(op2, op3));\\n        }\\n        \\n        return dp[0];\\n    }\\n    \\n    int SolveByQueue(vector<int>& days, vector<int>& costs)\\n    {\\n        int ans  = 0;\\n        \\n        queue<pair<int, int>> week;\\n        \\n        queue<pair<int, int>> month;\\n        \\n        for (auto day : days)\\n    {\\n        while (!week.empty() && week.front().first + 7 <= day)\\n            week.pop();\\n\\n        while (!month.empty() && month.front().first + 30 <= day)\\n            month.pop();\\n\\n        week.push(make_pair(day, ans + costs[1]));\\n        month.push(make_pair(day, ans + costs[2]));\\n\\n        \\n        ans = min(ans + costs[0], min(week.front().second, month.front().second));\\n    }\\n\\n        \\n        return ans;\\n        \\n    }\\n    \\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n      \\n        // Recursion + Memoization -> Uncomment This Part\\n        // vector<int> dp(days.size() , -1);\\n        // return SolveMemo(0 , days, costs, dp);\\n        \\n        \\n        //Tabulation Method -> Uncomment this part\\n        //return SolveTabulation(days, costs);\\n        \\n        //Queue Method -> Uncomment This part\\n        return SolveByQueue(days, costs);\\n    }\\n};\\n\\n// Pls Upvote If You Like It , Thanks !!\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1845832,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845956,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845802,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845977,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846107,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845764,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846389,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845961,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846119,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846118,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845832,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845956,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845802,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845977,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846107,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845764,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846389,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845961,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846119,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846118,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845904,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1804885,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846306,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846022,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1845887,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 2059945,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1984501,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1923507,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846891,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846509,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846507,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846375,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846216,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846198,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846189,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846185,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846055,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846043,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846021,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1845979,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            }
        ]
    }
]