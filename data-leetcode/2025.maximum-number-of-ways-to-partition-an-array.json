[
    {
        "title": "Maximum Number of Ways to Partition an Array",
        "question_content": "You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\n\n\t1 <= pivot < n\n\tnums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]\n\nYou are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\nReturn the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.\n&nbsp;\nExample 1:\n\nInput: nums = [2,-1,2], k = 3\nOutput: 1\nExplanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.\n\nExample 2:\n\nInput: nums = [0,0,0], k = 1\nOutput: 2\nExplanation: The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.\n\nExample 3:\n\nInput: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\nOutput: 4\nExplanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].\nThere are four ways to partition the array.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t2 <= n <= 105\n\t-105 <= k, nums[i] <= 105",
        "solutions": [
            {
                "id": 1498999,
                "title": "c-o-n",
                "content": "**Requirements**\\n* We need count of indexes i, such that nums[0] + ... + nums[i-1] == nums[i] ... nums[n-1], that is prefixSum[i-1] = SuffixSum[i].\\n* We are also allowed to change an element to \\'K\\'.\\n* We need to return max possible count of such indexes.\\n\\n**Thought Process**\\n* How can we find the count of pivots, if we are not allowed to change any value?\\n\\t* We can iterate over prefixSum array, and count all indexes where pref[i] == suff[i+1].\\n* Now suppose we are allowed to change an element, say nums[j] to value K. How will it change the array prefixSum and suffixSum?\\n\\t* Let d be the increase in jth element => d =  K - nums[j]\\n\\t* We can easily see, all values from pref[ j ] to pref[n-1] will also increase by d, and all values from suff[ j ] to suff[ 0 ], will also increase by d.\\n\\t* So, if we had the count of all indexes i, such that:\\n\\t\\t* if i < j, then pref[ i ] - suff[ i + 1] = d, **in original array i.e. without changing j\\'s value**\\n\\t\\t\\t* Because, suffix sum from 0 to j is increased by d.\\n\\t\\t\\t* Thus this difference will now become 0. \\n\\t\\t\\t* Hence, i will become a pivot point. \\n\\n\\n\\t\\t* if i >= j, then pref [ i ] - suff[ i+1 ] = -d, **in original array i.e. without changing j\\'s value**\\n\\t\\t\\t* Because, prefix sum from j to n-1 is increased by d. \\n\\t\\t\\t* Thus this difference will now become 0. \\n\\t\\t\\t* Hence, i will become a pivot point. \\n\\t\\t\\t\\n**Algorithm & Code**\\n* As seen in the thought process, difference between prefSum[ i ] - suffSum[ i+1 ] is the thing which actually matters.\\n* Thus, we maintain two hash maps, *left* & *right*, which store the count of differences.\\n\\t* *left* stores the count of difference for j < i && *right* stores for j >= i, where i is the index of element which we are changing to K.\\n* Intially, when no elements is changed, *left* is empty, *right* will contain all the differences.\\n* Now, whenever we change the element i, then we check count of difference d = k - nums[i] in *left* and -d in *right*.\\n* Then, we transfer the current element from, hashMap *right* to hashMap *left*.\\n\\n**TC & SC**\\n* TC: O(n)\\n* SC: O(n)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<long long> pref(n), suff(n);\\n\\n        //store prefix and suffix sum\\n        pref[0] = nums[0]; suff[n-1] = nums[n-1];\\n        for(int i=1; i<n; ++i) { \\n            pref[i]     = pref[i-1] + nums[i]; \\n            suff[n-1-i] = suff[n-i] + nums[n-1-i];\\n        } \\n        // for(int i=n-2; i>=0; --i) suff[i] = suff[i+1] + nums[i];\\n \\n        long long ans = 0;\\n        unordered_map<long long,long long> left, right;\\n        \\n        //intially store the differences in the hashmap right\\n        for(int i=0;i<n-1; ++i) right[pref[i] - suff[i+1]]++;\\n        \\n        \\n        if(right.count(0)) ans = right[0];\\n        for(int i=0; i<n; ++i){\\n\\n            //find the number of pivot indexes when nums[i] is changed to k\\n            long long curr = 0, diff = k-nums[i];\\n            if(left.count(diff)) curr+=left[diff];\\n            if(right.count(-diff)) curr+=right[-diff];\\n\\n            //update answer\\n            ans = max(ans, curr);\\n            \\n            //transfer the current element from right to left\\n            if(i<n-1){\\n                long long dd = pref[i]-suff[i+1]; \\n                left[dd]++; right[dd]--;\\n                if(right[dd] == 0) right.erase(dd);\\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<long long> pref(n), suff(n);\\n\\n        //store prefix and suffix sum\\n        pref[0] = nums[0]; suff[n-1] = nums[n-1];\\n        for(int i=1; i<n; ++i) { \\n            pref[i]     = pref[i-1] + nums[i]; \\n            suff[n-1-i] = suff[n-i] + nums[n-1-i];\\n        } \\n        // for(int i=n-2; i>=0; --i) suff[i] = suff[i+1] + nums[i];\\n \\n        long long ans = 0;\\n        unordered_map<long long,long long> left, right;\\n        \\n        //intially store the differences in the hashmap right\\n        for(int i=0;i<n-1; ++i) right[pref[i] - suff[i+1]]++;\\n        \\n        \\n        if(right.count(0)) ans = right[0];\\n        for(int i=0; i<n; ++i){\\n\\n            //find the number of pivot indexes when nums[i] is changed to k\\n            long long curr = 0, diff = k-nums[i];\\n            if(left.count(diff)) curr+=left[diff];\\n            if(right.count(-diff)) curr+=right[-diff];\\n\\n            //update answer\\n            ans = max(ans, curr);\\n            \\n            //transfer the current element from right to left\\n            if(i<n-1){\\n                long long dd = pref[i]-suff[i+1]; \\n                left[dd]++; right[dd]--;\\n                if(right[dd] == 0) right.erase(dd);\\n\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507271,
                "title": "python-cpp-explanation-with-pictures-o-n",
                "content": "First, if we do not change any number, how many ways we can split this array `A` into two parts with equal sum? We can get the prefix sum array of `A`, and count how many occurrence of `sum(A) / 2` in the prefix sum array. (If sum(A) % 2 = 1 meaning there is no way to split it)\\nTake a look at the array `A` in the picture below as an example.\\n\\n![image](https://assets.leetcode.com/users/images/69f38079-9bb6-4547-86a1-7e12a0379f55_1633554658.6705472.png)\\n\\n\\nOnce we get the prefix sum of `A`, and the sum of `A` which is `0`, let\\'s count how many `0`s in prefix sum. Notice that we **NEVER** count the last prefix sum since it stands for `A` itself.\\n\\n\\n![image](https://assets.leetcode.com/users/images/c2e0bac6-b8a5-4d85-a87d-702e12dfdd13_1633554669.2358608.png)\\n\\nWe find 4 `0` in the prefix sum array. That means without changing a number, there are 4 ways to split it. \\nWhat if we change one number, let\\'s say `A[i]`, can we still get the number of spliting ways by counting the occurrence of half the sum, or by some similar methods? **Yes**.\\n\\nTake the array `A` below as an example. Suppose we changed `A[4]` from `3` to `4`, how will the prefix sum array changes according to the change of one number?\\n\\n\\n![image](https://assets.leetcode.com/users/images/1819bdee-c6c0-48e8-8a92-96f21e2fb408_1633554674.8122022.png)\\n\\nWe can tell that **ONLY** the prefix sum of and after `A[4]` are changed. Since `A[4]` is added by one, all the changed prefix sum are added by one as well.\\n\\n\\nWe use two hashmaps(let\\'s call them **pred** and **sufd**) to store the occurrence of all prefix sum of the **Original A**, we don\\'t change any key of either hashmaps because it will bring O(N^2) time complexity and there is no need to change it.\\n\\n![image](https://assets.leetcode.com/users/images/a9fd6d76-8eb3-46ba-b0bd-7ec4c3e29f72_1633554679.6567972.png)\\n\\nNow, once we have changed `A[4]` from `3` to `4`, what is the next step to find all spliting ways? Similarly, we look for occurrences of half sum in hashmap. \\n\\n- When we look into **pred**, we search of the occurrence of `newSum / 2`.\\n- When we look into **sufd**, we don\\'t search for `newSum / 2`, but `(newSum - k + A[i]) / 2`.\\n\\n> Why?\\n>\\nRemember that we do not update the keys in neither of the hashmap, thus they only contain the information of the original A. When we want to get the result of `newSum / 2`, we have to modify it by `A[i] - k` which is the reverse value by which the original A has changed.\\n\\n![image](https://assets.leetcode.com/users/images/2e4803ff-9305-4d5a-a4b6-2099a76e5752_1633554685.1129231.png)\\n\\nTherefore, since `newSum = 13 + 4 - 1 = 14`, we are looking for `7` in the **pred**, and `6` in **sufd**. In this case, we have `2` ways to split `A`.\\n\\n![image](https://assets.leetcode.com/users/images/c6d02ec0-8c0c-44d3-bf6a-d860eba2df44_1633554689.9242008.png)\\n\\nDon\\'t forget to update the occurrence of this presum **pre[i]** in both hashmaps. That is, \"move\" one `pre[i]` from **sufd** to **pred** and move on for the next index.\\n\\n\\n**Python**\\n```\\ndef waysToPartition(self, A: List[int], k: int) -> int:\\n        n = len(A) \\n        pre, s = list(itertools.accumulate(A)), sum(A)\\n        \\n        # pred contains all the presum BEFORE i-th number.\\n        # sufd contains all the presum AFTER and WITH i-th number.\\n        pred = collections.defaultdict(int)\\n        sufd = collections.Counter(pre)\\n        \\n        # The last prefix sum is NEVER used. \\n        sufd[sum(A)] -= 1\\n        \\n        # The number of ways if we do not change any number.\\n\\t\\tans = 0\\n        if s % 2 == 0:\\n            ans = sufd[s // 2]\\n\\n        # The number of ways if we split i-th number to k.\\n        for i in range(n):\\n            cur = 0\\n            \\n            # We only count number of ways when A[i] != k (otherwise change makes no difference)\\n            # and when the SUM after the change is dividable by 2.\\n            if A[i] != k:\\n                news = s + k - A[i]\\n                if news % 2 == 0:\\n                    \\n                    # If i == 0, only count suffix part.\\n                    if i > 0:\\n                        cur += pred[news // 2]\\n                        \\n                    # If i == n - 1, only count prefix part.\\n                    if i < n - 1:\\n                        cur += sufd[news // 2 + A[i] - k]\\n            ans = max(ans, cur)\\n            \\n            # Don\\'t forget to change the values in the two counters.\\n            sufd[pre[i]] -= 1\\n            pred[pre[i]] += 1\\n            \\n        return ans\\n```\\n**cpp**\\n```\\nint waysToPartition(vector<int>& A, int k) {\\n        int n = A.size();\\n        long long s = 0, ans = 0;\\n        vector<int> pre;\\n        unordered_map<long long, long long> pred, sufd;\\n        \\n        for (int a : A) {\\n            s += a;\\n            pre.push_back(s);\\n            sufd[s] += 1;\\n        }\\n        sufd[s] -= 1;\\n        \\n        if (s % 2 == 0) {\\n            ans += sufd[s / 2];\\n        }\\n       \\n        for (int i = 0; i < n; ++i) {\\n            long long cur = 0;\\n            if (A[i] != k) {\\n                int news = s + k - A[i];\\n                if (news % 2 == 0) {\\n                    if (i > 0) \\n                        cur += pred[news / 2];\\n                    if (i < n - 1)\\n                        cur += sufd[news / 2 + A[i] - k];\\n                }\\n            }\\n            ans = max(ans, cur);\\n            sufd[pre[i]] -= 1;\\n            pred[pre[i]] += 1;\\n        }\\n        return ans;        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef waysToPartition(self, A: List[int], k: int) -> int:\\n        n = len(A) \\n        pre, s = list(itertools.accumulate(A)), sum(A)\\n        \\n        # pred contains all the presum BEFORE i-th number.\\n        # sufd contains all the presum AFTER and WITH i-th number.\\n        pred = collections.defaultdict(int)\\n        sufd = collections.Counter(pre)\\n        \\n        # The last prefix sum is NEVER used. \\n        sufd[sum(A)] -= 1\\n        \\n        # The number of ways if we do not change any number.\\n\\t\\tans = 0\\n        if s % 2 == 0:\\n            ans = sufd[s // 2]\\n\\n        # The number of ways if we split i-th number to k.\\n        for i in range(n):\\n            cur = 0\\n            \\n            # We only count number of ways when A[i] != k (otherwise change makes no difference)\\n            # and when the SUM after the change is dividable by 2.\\n            if A[i] != k:\\n                news = s + k - A[i]\\n                if news % 2 == 0:\\n                    \\n                    # If i == 0, only count suffix part.\\n                    if i > 0:\\n                        cur += pred[news // 2]\\n                        \\n                    # If i == n - 1, only count prefix part.\\n                    if i < n - 1:\\n                        cur += sufd[news // 2 + A[i] - k]\\n            ans = max(ans, cur)\\n            \\n            # Don\\'t forget to change the values in the two counters.\\n            sufd[pre[i]] -= 1\\n            pred[pre[i]] += 1\\n            \\n        return ans\\n```\n```\\nint waysToPartition(vector<int>& A, int k) {\\n        int n = A.size();\\n        long long s = 0, ans = 0;\\n        vector<int> pre;\\n        unordered_map<long long, long long> pred, sufd;\\n        \\n        for (int a : A) {\\n            s += a;\\n            pre.push_back(s);\\n            sufd[s] += 1;\\n        }\\n        sufd[s] -= 1;\\n        \\n        if (s % 2 == 0) {\\n            ans += sufd[s / 2];\\n        }\\n       \\n        for (int i = 0; i < n; ++i) {\\n            long long cur = 0;\\n            if (A[i] != k) {\\n                int news = s + k - A[i];\\n                if (news % 2 == 0) {\\n                    if (i > 0) \\n                        cur += pred[news / 2];\\n                    if (i < n - 1)\\n                        cur += sufd[news / 2 + A[i] - k];\\n                }\\n            }\\n            ans = max(ans, cur);\\n            sufd[pre[i]] -= 1;\\n            pred[pre[i]] += 1;\\n        }\\n        return ans;        \\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1499365,
                "title": "c-frequency-map-o-n",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Frequency Map\\n\\nGiven array `A`, we can compute an array `diff` where `diff[i] = (A[0] + .. + A[i-1]) - (A[i] + .. + A[N-1])` (`1 <= i < N`), i.e. sum of left part minus sum of right part.\\n\\nIf we don\\'t do any replacement, the answer is the number of `0`s in the `diff` array.\\n\\nIf we replace `A[i]` with `k`, then `diff[1]` to `diff[i]` decrease by `d`, and `diff[i+1]` to `diff[N-1]` increase by `d`, where `d = k - A[i]`. Again, the answer is the number of `0`s in this new `diff` array.\\n\\nInstead of changing the `diff` array (taking `O(N)` time), we can simply count the number of `d` in `diff[1..i]` and number of `-d` in `diff[(i+1)..(N-1)]` (taking `O(1)` time).\\n\\nSo, we can use two frequency maps `L` and `R` which are the frequency maps of `diff[1..i]` and `diff[(i+1)..(N-1)]` respectively.\\n\\nWe scan from left to right. For each `A[i]`, we try to update `ans` with `L[d] + R[-d]` where `d = k - A[i]`, and update the frequency maps.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& A, int k) {\\n        long sum = accumulate(begin(A), end(A), 0L), N = A.size();\\n        unordered_map<long, int> L, R;\\n        for (long i = 0, left = 0; i < N - 1; ++i) {\\n            left += A[i];\\n            long right = sum - left;\\n            R[left - right]++;\\n        }\\n        int ans = R[0]; // If we don\\'t do any replacement, answer is the number of `0`s in the frequency map\\n        for (long i = 0, left = 0; i < N; ++i) {\\n            left += A[i];\\n            long right = sum - left, d = k - A[i];\\n            ans = max(ans, L[d] + R[-d]); // If we replace `A[i]` with `k`, we will get `L[d] + R[-d]` pivots\\n            R[left - right]--; // transfer the frequency from `R` to `L`.\\n            L[left - right]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nExample: \\n\\n```plaintext\\nA =            [2, -1,  2]\\ndiff =         [_,  1, -1]\\n```\\n\\nIf we change the `diff` array.\\n\\n```plaintext\\n// replace A[0] with 3\\nA =            [3, -1,  2]\\ndiff change        +1  +1\\ndiff =         [_,  2,  0]\\n\\n// replace A[1] with 3\\nA =            [2,  3,  2]\\ndiff change        -4  +4\\ndiff =         [_, -3,  3]\\n\\n// replace A[2] with 3\\nA =            [2, -1,  3]\\ndiff change        -1  -1 \\ndiff =         [_,  0, -2]\\n```\\n\\nIf we use frequency maps:\\n```plaintext\\ndiff =         [_,  1, -1]\\n\\n// If we don\\'t do any replacement\\n               [_ | 1,  -1]\\nanswer = R[0] = 0\\n\\n// replace A[0] with 3, d = 1\\n               [_ | 1,  -1]\\nanswer = L[1] + R[-1] = 0 + 1 = 1\\n\\n// replace A[1] with 3, d = 4\\n               [_  1 | -1]\\nanswer = L[4] + R[-4] = 0 + 0 = 0\\n\\n// replace A[2] with 3, d = 1\\n               [_  1  -1 |]\\nanswer = L[1] + R[-1] = 1 + 0 = 1\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& A, int k) {\\n        long sum = accumulate(begin(A), end(A), 0L), N = A.size();\\n        unordered_map<long, int> L, R;\\n        for (long i = 0, left = 0; i < N - 1; ++i) {\\n            left += A[i];\\n            long right = sum - left;\\n            R[left - right]++;\\n        }\\n        int ans = R[0]; // If we don\\'t do any replacement, answer is the number of `0`s in the frequency map\\n        for (long i = 0, left = 0; i < N; ++i) {\\n            left += A[i];\\n            long right = sum - left, d = k - A[i];\\n            ans = max(ans, L[d] + R[-d]); // If we replace `A[i]` with `k`, we will get `L[d] + R[-d]` pivots\\n            R[left - right]--; // transfer the frequency from `R` to `L`.\\n            L[left - right]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```plaintext\\nA =            [2, -1,  2]\\ndiff =         [_,  1, -1]\\n```\n```plaintext\\n// replace A[0] with 3\\nA =            [3, -1,  2]\\ndiff change        +1  +1\\ndiff =         [_,  2,  0]\\n\\n// replace A[1] with 3\\nA =            [2,  3,  2]\\ndiff change        -4  +4\\ndiff =         [_, -3,  3]\\n\\n// replace A[2] with 3\\nA =            [2, -1,  3]\\ndiff change        -1  -1 \\ndiff =         [_,  0, -2]\\n```\n```plaintext\\ndiff =         [_,  1, -1]\\n\\n// If we don\\'t do any replacement\\n               [_ | 1,  -1]\\nanswer = R[0] = 0\\n\\n// replace A[0] with 3, d = 1\\n               [_ | 1,  -1]\\nanswer = L[1] + R[-1] = 0 + 1 = 1\\n\\n// replace A[1] with 3, d = 4\\n               [_  1 | -1]\\nanswer = L[4] + R[-4] = 0 + 0 = 0\\n\\n// replace A[2] with 3, d = 1\\n               [_  1  -1 |]\\nanswer = L[1] + R[-1] = 1 + 0 = 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500048,
                "title": "left-and-right-differences",
                "content": "For each pivot point, figure out the the **difference** between left and right sums, and count each difference in a hash map `right`.\\n\\nIf we do not change anything, our answer will be the count of zero differences.\\n\\nNow, what happens if we change `num[i]` to `k`? \\n- All differences to the left of `i` will increase by `nums[i] - k`.\\n- All differences starting from `i` will decrease by  `nums[i] - k`.\\n\\nNow, we go left-to-right, move differences from `right` to `left`, and track max partitions if we change the current number.\\n\\n**C++**\\n```cpp\\nint waysToPartition(vector<int>& nums, int k) {\\n    unordered_map<long long, int> left, right;\\n    long long sum = accumulate(begin(nums), end(nums), 0ll);\\n    for (long long i = 0, lsum = 0; i < nums.size() - 1; ++i) {\\n        lsum += nums[i];\\n        ++right[sum - 2 * lsum];\\n    }\\n    int res = right[0];\\n    for (long long i = 0, lsum = 0; i < nums.size(); ++i) {\\n        res = max(res, left[nums[i] - k] + right[-nums[i] + k]);\\n        lsum += nums[i];\\n        ++left[sum - 2 * lsum];\\n        --right[sum - 2 * lsum];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint waysToPartition(vector<int>& nums, int k) {\\n    unordered_map<long long, int> left, right;\\n    long long sum = accumulate(begin(nums), end(nums), 0ll);\\n    for (long long i = 0, lsum = 0; i < nums.size() - 1; ++i) {\\n        lsum += nums[i];\\n        ++right[sum - 2 * lsum];\\n    }\\n    int res = right[0];\\n    for (long long i = 0, lsum = 0; i < nums.size(); ++i) {\\n        res = max(res, left[nums[i] - k] + right[-nums[i] + k]);\\n        lsum += nums[i];\\n        ++left[sum - 2 * lsum];\\n        --right[sum - 2 * lsum];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499006,
                "title": "python-binary-search-solution-explained",
                "content": "Actually, not very difficult problem, but I made 6 attempts on contests, because I messed up with indexes. The idea is the following:\\n\\nIf we have numbers `[a0, a1, a2, a3, a4, a5, a5, a7, a8, a9]` and we want to change say `a3` to `k` so now we have `[a0, a1, a2, k, a4, a5, a6, a7, a8, a9]`. \\n\\nThen for every partition either **left** part is from original `nums` or **right** part. This is the clue idea which solve this problem.\\n\\nSo, all we need to do is to evaluate cumulative sums both from left and form right and then check how many numbers we can change to `k` such that sums are equal. We evaluate our `cand = (acc1[-1] - nums[i] + k)/2`, this is what we want to have in our left part, because if **left = right**, then **left = all/2** and **all** changed by `nums[i] - k`. Now we need to understand how many sums are good partitions: for this we keep dictionary `d1`, which for every cumulatime sum keep list of indexes. We are interested only in indexes which are `<= i - 1`, because we want to have left part unchanged. Very similar logic is for the cases where right part unchanged, but here we need to use index `n - i - 2`, because we start from the last element. Finally we update our `ans`.\\n\\n#### Complexity\\nTime complexity is `O(n log n)`, because for each of `n` candidates we do 2 binary searches, each of which is `O(log n)`. Space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def waysToPartition(self, nums, k):\\n        n = len(nums)\\n        acc1 = list(accumulate(nums))\\n        d1 = defaultdict(list)\\n        for idx, num in enumerate(acc1):\\n            d1[num].append(idx)\\n\\n        acc2 = list(accumulate(nums[::-1]))\\n        d2 = defaultdict(list)\\n        for idx, num in enumerate(acc2):\\n            d2[num].append(idx)\\n\\n        ans, ans2 = 0, 0\\n\\n        for i in range(n - 1):\\n            if acc1[-1] == 2*acc1[i]: ans2 += 1\\n\\n        for i in range(0, n):\\n            cand = (acc1[-1] - nums[i] + k)/2\\n            lft = bisect(d1[cand], i-1)\\n            rgh = bisect(d2[cand], n - i - 2)\\n            ans = max(ans, lft + rgh)\\n\\n        return max(ans, ans2)\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def waysToPartition(self, nums, k):\\n        n = len(nums)\\n        acc1 = list(accumulate(nums))\\n        d1 = defaultdict(list)\\n        for idx, num in enumerate(acc1):\\n            d1[num].append(idx)\\n\\n        acc2 = list(accumulate(nums[::-1]))\\n        d2 = defaultdict(list)\\n        for idx, num in enumerate(acc2):\\n            d2[num].append(idx)\\n\\n        ans, ans2 = 0, 0\\n\\n        for i in range(n - 1):\\n            if acc1[-1] == 2*acc1[i]: ans2 += 1\\n\\n        for i in range(0, n):\\n            cand = (acc1[-1] - nums[i] + k)/2\\n            lft = bisect(d1[cand], i-1)\\n            rgh = bisect(d2[cand], n - i - 2)\\n            ans = max(ans, lft + rgh)\\n\\n        return max(ans, ans2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499026,
                "title": "short-python-solution-compute-prefix-sums-o-n",
                "content": "**Explanation**\\n\\n* For each pivot `p`, `1 <= p <= n-1`, we can test whether it is a valid partition point by checking whether `sum(nums[:p]) == sum(nums[p:])`, which can be determined in constant time after computing prefix sums.\\n\\n* If a pivot `p` is not valid, we compute `gap[p] = sum(nums[p:]) - sum(nums[:p])`. This `gap[p]` is how much we need to add to an element strictly before index `p`, or subtract from an element at or after index `p`, in order to make `p` a valid pivot.\\n* Now, for each element `nums[i]`, find the number of valid pivots in the new array after changing `nums[i]` to `k`, or in other words, adding `k-nums[i]` at index `i`. \\n* This value, for a fixed `i`, is the count of indices `j` with `j > i` that satisfy `gap[j] == k - nums[i]`, \\nplus the number of indices `j` with `1 <= j <= i` such that `-gap[j] == k - nums[i]`. \\n* Use two dictionaries (for earlier gap counts and later gap counts) plus a prefix sum array, and update the dictionaries as we traverse.\\n\\n\\n**Complexity**\\n\\nTime complexity: `O(n)`, Space complexity `O(n)`\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix_sums = list(accumulate(nums))\\n        total_sum = prefix_sums[-1]\\n        best = 0\\n        if total_sum % 2 == 0:\\n            best = prefix_sums[:-1].count(total_sum // 2)  # If no change\\n\\n        after_counts = Counter(total_sum - 2 * prefix_sum\\n                               for prefix_sum in prefix_sums[:-1])\\n        before_counts = Counter()\\n\\n        best = max(best, after_counts[k - nums[0]])  # If we change first num\\n\\n        for prefix, x in zip(prefix_sums, nums[1:]):\\n            gap = total_sum - 2 * prefix\\n            after_counts[gap] -= 1\\n            before_counts[gap] += 1\\n\\n            best = max(best, after_counts[k - x] + before_counts[x - k])\\n\\n        return best\\n```\\n\\nEdit: Thanks to user @zeck008 for pointing out a swapped pair of inequality signs in the original explanation.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix_sums = list(accumulate(nums))\\n        total_sum = prefix_sums[-1]\\n        best = 0\\n        if total_sum % 2 == 0:\\n            best = prefix_sums[:-1].count(total_sum // 2)  # If no change\\n\\n        after_counts = Counter(total_sum - 2 * prefix_sum\\n                               for prefix_sum in prefix_sums[:-1])\\n        before_counts = Counter()\\n\\n        best = max(best, after_counts[k - nums[0]])  # If we change first num\\n\\n        for prefix, x in zip(prefix_sums, nums[1:]):\\n            gap = total_sum - 2 * prefix\\n            after_counts[gap] -= 1\\n            before_counts[gap] += 1\\n\\n            best = max(best, after_counts[k - x] + before_counts[x - k])\\n\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499316,
                "title": "java-o-n-prefix-sum",
                "content": "Our task is trying to find at least two partitions with equals sums. Obvious :), we have only one sum to find for our partitions : `totalSum / 2`. We need to find two partitions with `sum = totalSum / 2` and other partitions with `sum = 0` between them.\\n\\nExample : \\n```\\n[8, -5, 3, 2, -2, 2, 3], k = 3\\nprefix sum [8, 3, 6, 8, 6, 8, 11]\\ntotal sum = 11\\nsum [-5, 3, 2] = 0\\nsum [-2, 2] = 0\\n```\\n\\nif change `8 -> 3` : \\n\\n```\\nnums :     [3, -5, 3, 2, -2, 2, 3]\\nprefix sum [3, -2, 1, 3,  1, 3, 6]\\ntotal sum = 6\\nsum to find = 3\\nresult = 3 \\n\\n[3], [-5, 3, 2, 2, -2, 3]\\n[3, -5, 3, 2], [2, -2, 3]\\n[3, -5, 3, 2, 2, -2], [3]\\n```\\n\\n```\\nclass Solution {\\n    //time - O(n), space - O(n)\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        int[] pref = new int[n];\\n        pref[0] = nums[0];        \\n        Map<Integer, Integer> count = new HashMap<>(); //contribution of prefixes without changing\\n        count.put(pref[0], 1); \\n        \\n        for (int i = 1; i < n - 1; i++){\\n            pref[i] += pref[i - 1] + nums[i];\\n            count.put(pref[i], count.getOrDefault(pref[i], 0) + 1);\\n        }\\n        pref[n - 1] += pref[n - 2] + nums[n - 1]; //last step doesn\\'t add into \\'count\\' map, because we\\'re trying to find at least two parts.\\n\\n        int sum = pref[n - 1];\\n        int max = 0;\\n        if (sum % 2 == 0)\\n            max = count.getOrDefault(sum / 2, 0); //max without changing\\n\\n        Map<Integer, Integer> countPrev = new HashMap<>(); //contribution of prefixes before current step\\n        for (int i = 0; i < n; i++){\\n            int diff = k - nums[i];\\n            int changedSum = sum + diff;\\n            if (changedSum % 2 == 0) \\n                max = Math.max(max, count.getOrDefault(changedSum / 2 - diff, 0) + countPrev.getOrDefault(changedSum / 2, 0));            \\n            count.put(pref[i], count.getOrDefault(pref[i], 0) - 1);\\n            countPrev.put(pref[i], countPrev.getOrDefault(pref[i], 0) + 1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[8, -5, 3, 2, -2, 2, 3], k = 3\\nprefix sum [8, 3, 6, 8, 6, 8, 11]\\ntotal sum = 11\\nsum [-5, 3, 2] = 0\\nsum [-2, 2] = 0\\n```\n```\\nnums :     [3, -5, 3, 2, -2, 2, 3]\\nprefix sum [3, -2, 1, 3,  1, 3, 6]\\ntotal sum = 6\\nsum to find = 3\\nresult = 3 \\n\\n[3], [-5, 3, 2, 2, -2, 3]\\n[3, -5, 3, 2], [2, -2, 3]\\n[3, -5, 3, 2, 2, -2], [3]\\n```\n```\\nclass Solution {\\n    //time - O(n), space - O(n)\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        \\n        int[] pref = new int[n];\\n        pref[0] = nums[0];        \\n        Map<Integer, Integer> count = new HashMap<>(); //contribution of prefixes without changing\\n        count.put(pref[0], 1); \\n        \\n        for (int i = 1; i < n - 1; i++){\\n            pref[i] += pref[i - 1] + nums[i];\\n            count.put(pref[i], count.getOrDefault(pref[i], 0) + 1);\\n        }\\n        pref[n - 1] += pref[n - 2] + nums[n - 1]; //last step doesn\\'t add into \\'count\\' map, because we\\'re trying to find at least two parts.\\n\\n        int sum = pref[n - 1];\\n        int max = 0;\\n        if (sum % 2 == 0)\\n            max = count.getOrDefault(sum / 2, 0); //max without changing\\n\\n        Map<Integer, Integer> countPrev = new HashMap<>(); //contribution of prefixes before current step\\n        for (int i = 0; i < n; i++){\\n            int diff = k - nums[i];\\n            int changedSum = sum + diff;\\n            if (changedSum % 2 == 0) \\n                max = Math.max(max, count.getOrDefault(changedSum / 2 - diff, 0) + countPrev.getOrDefault(changedSum / 2, 0));            \\n            count.put(pref[i], count.getOrDefault(pref[i], 0) - 1);\\n            countPrev.put(pref[i], countPrev.getOrDefault(pref[i], 0) + 1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935142,
                "title": "c-code-for-beginners-visualized-through-example-and-explaination-easy-understandable",
                "content": "\\nTO UNDERSTAND PROPERLY, RUN BELOW CODE TO SEE\\n\\nLets try to see what happens when we change a certain index to k\\n\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid resetAndRecalculate(vector<int> &prefix, vector<int> &suffix, vector<int> &arr){\\n    cout<<endl;\\n    prefix=arr;\\n    suffix=arr;\\n    for(int i=1;i<arr.size();i++){\\n        prefix[i]=prefix[i]+prefix[i-1];\\n    }\\n    for(int i=arr.size()-2;i>=0;i--){\\n        suffix[i]=suffix[i]+suffix[i+1];\\n    }\\n    cout<<\"RECALCULATED PREFIX:- \";\\n    for(auto e: prefix){\\n        cout<<e<<\" \";\\n    }\\n    cout<<endl<<\"RECALCULATED SUFFIX:- \";\\n    for(auto e: suffix){\\n        cout<<e<<\" \";\\n    }\\n    cout<<endl;\\n}\\n \\nvoid Solve(vector<int> &arr, int k){\\n    int n=arr.size();\\n    vector<int> prefix=arr;\\n    vector<int> suffix=arr;\\n    for(int i=1;i<n;i++){\\n        prefix[i]=prefix[i]+prefix[i-1];\\n    }\\n    for(int i=n-2;i>=0;i--){\\n        suffix[i]=suffix[i]+suffix[i+1];\\n    }\\n    vector<int> origDifference(n);\\n    cout<<\"DIFFERENCE WITHOUT REPLACEMENT \"<<endl;\\n    for(int i=0;i<n-1;i++){\\n        origDifference[i]=prefix[i]-suffix[i+1];\\n        cout<<origDifference[i]<<\" \";\\n    }\\n    cout<<endl;\\n    for(int i=0;i<n-1;i++){\\n        cout<<endl;\\n        vector<int> temp=arr;\\n        temp[i]=k;\\n        cout<<\"i= \"<<i<<endl;\\n        cout<<\"Difference is d- \"<<k-arr[i]<<endl;\\n        cout<<\"ARRAY- \";\\n        for(auto e: temp){\\n            cout<<e<<\" \";\\n        }\\n        resetAndRecalculate(prefix,suffix,temp);\\n        vector<int> tempDiff(n);\\n        cout<<\"DIFFERENCE- \";\\n        for(int i=0;i<n-1;i++){\\n            tempDiff[i]=prefix[i]-suffix[i+1];\\n            cout<<tempDiff[i]<<\" \";\\n        }\\n        cout<<endl<<\"DIFFERENCE WRT TO origDifference \"<<endl;\\n        for(int i=0;i<n-1;i++){\\n            cout<<origDifference[i]-tempDiff[i]<<\" \";\\n        }\\n        cout<<endl;\\n    }\\n    \\n}\\n\\nint main() {\\n    vector<int> arr={22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14};\\n    int k=-33;\\n    cout<<\"ORIGINAL ARRAY: -\"<<endl;\\n    for(auto e: arr){\\n        cout<<e<<\" \";\\n    }\\n    cout<<endl<<endl;\\n    Solve(arr,k);\\n\\n    return 0;\\n}\\n```\\n# Just observe how left side of i is decreasing by d and right side increases by d\\n\\n```\\nORIGINAL ARRAY: -\\n22 4 -25 -20 -15 15 -16 7 19 -10 0 -13 -14 \\n\\nDIFFERENCE WITHOUT REPLACEMENT \\n90 98 48 8 -22 8 -24 -10 28 8 8 -18 \\n\\ni= 0\\nDifference is d- -55\\nARRAY- -33 4 -25 -20 -15 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- -33 -29 -54 -74 -89 -74 -90 -83 -64 -74 -74 -87 -101 \\nRECALCULATED SUFFIX:- -101 -68 -72 -47 -27 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 35 43 -7 -47 -77 -47 -79 -65 -27 -47 -47 -73 \\nDIFFERENCE WRT TO origDifference \\n55 55 55 55 55 55 55 55 55 55 55 55 // since we changed i=0, there is no change seen, since left does not exist\\n\\ni= 1\\nDifference is d- -37\\nARRAY- 22 -33 -25 -20 -15 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 -11 -36 -56 -71 -56 -72 -65 -46 -56 -56 -69 -83 \\nRECALCULATED SUFFIX:- -83 -105 -72 -47 -27 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 127 61 11 -29 -59 -29 -61 -47 -9 -29 -29 -55 \\nDIFFERENCE WRT TO origDifference \\n-37 37 37 37 37 37 37 37 37 37 37 37  // when changed arr[i]=k, seen all j<i are getting decreased by d\\n\\ni= 2\\nDifference is d- -8\\nARRAY- 22 4 -33 -20 -15 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 -7 -27 -42 -27 -43 -36 -17 -27 -27 -40 -54 \\nRECALCULATED SUFFIX:- -54 -76 -80 -47 -27 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 98 106 40 0 -30 0 -32 -18 20 0 0 -26   // These zeros are the points of partitions \\nDIFFERENCE WRT TO origDifference \\n-8 -8 8 8 8 8 8 8 8 8 8 8  // when changed arr[i]=k, seen all j<i are getting decreased by d\\n\\ni= 3\\nDifference is d- -13\\nARRAY- 22 4 -25 -33 -15 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -32 -47 -32 -48 -41 -22 -32 -32 -45 -59 \\nRECALCULATED SUFFIX:- -59 -81 -85 -60 -27 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 103 111 61 -5 -35 -5 -37 -23 15 -5 -5 -31 \\nDIFFERENCE WRT TO origDifference \\n-13 -13 -13 13 13 13 13 13 13 13 13 13 \\n\\ni= 4\\nDifference is d- -18\\nARRAY- 22 4 -25 -20 -33 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -52 -37 -53 -46 -27 -37 -37 -50 -64 \\nRECALCULATED SUFFIX:- -64 -86 -90 -65 -45 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 108 116 66 26 -40 -10 -42 -28 10 -10 -10 -36 \\nDIFFERENCE WRT TO origDifference \\n-18 -18 -18 -18 18 18 18 18 18 18 18 18 \\n\\ni= 5\\nDifference is d- -48\\nARRAY- 22 4 -25 -20 -15 -33 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -67 -83 -76 -57 -67 -67 -80 -94 \\nRECALCULATED SUFFIX:- -94 -116 -120 -95 -75 -60 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 138 146 96 56 26 -40 -72 -58 -20 -40 -40 -66 \\nDIFFERENCE WRT TO origDifference \\n-48 -48 -48 -48 -48 48 48 48 48 48 48 48 \\n\\ni= 6\\nDifference is d- -17\\nARRAY- 22 4 -25 -20 -15 15 -33 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -52 -45 -26 -36 -36 -49 -63 \\nRECALCULATED SUFFIX:- -63 -85 -89 -64 -44 -29 -44 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 107 115 65 25 -5 25 -41 -27 11 -9 -9 -35 \\nDIFFERENCE WRT TO origDifference \\n-17 -17 -17 -17 -17 -17 17 17 17 17 17 17 \\n\\ni= 7\\nDifference is d- -40\\nARRAY- 22 4 -25 -20 -15 15 -16 -33 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -68 -49 -59 -59 -72 -86 \\nRECALCULATED SUFFIX:- -86 -108 -112 -87 -67 -52 -67 -51 -18 -37 -27 -27 -14 \\nDIFFERENCE- 130 138 88 48 18 48 16 -50 -12 -32 -32 -58 \\nDIFFERENCE WRT TO origDifference \\n-40 -40 -40 -40 -40 -40 -40 40 40 40 40 40 \\n\\ni= 8\\nDifference is d- -52\\nARRAY- 22 4 -25 -20 -15 15 -16 7 -33 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -28 -61 -71 -71 -84 -98 \\nRECALCULATED SUFFIX:- -98 -120 -124 -99 -79 -64 -79 -63 -70 -37 -27 -27 -14 \\nDIFFERENCE- 142 150 100 60 30 60 28 42 -24 -44 -44 -70 \\nDIFFERENCE WRT TO origDifference \\n-52 -52 -52 -52 -52 -52 -52 -52 52 52 52 52 \\n\\ni= 9\\nDifference is d- -23\\nARRAY- 22 4 -25 -20 -15 15 -16 7 19 -33 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -28 -9 -42 -42 -55 -69 \\nRECALCULATED SUFFIX:- -69 -91 -95 -70 -50 -35 -50 -34 -41 -60 -27 -27 -14 \\nDIFFERENCE- 113 121 71 31 1 31 -1 13 51 -15 -15 -41 \\nDIFFERENCE WRT TO origDifference \\n-23 -23 -23 -23 -23 -23 -23 -23 -23 23 23 23 \\n\\ni= 10\\nDifference is d- -33\\nARRAY- 22 4 -25 -20 -15 15 -16 7 19 -10 -33 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -28 -9 -19 -52 -65 -79 \\nRECALCULATED SUFFIX:- -79 -101 -105 -80 -60 -45 -60 -44 -51 -70 -60 -27 -14 \\nDIFFERENCE- 123 131 81 41 11 41 9 23 61 41 -25 -51 \\nDIFFERENCE WRT TO origDifference \\n-33 -33 -33 -33 -33 -33 -33 -33 -33 -33 33 33 \\n\\ni= 11\\nDifference is d- -20\\nARRAY- 22 4 -25 -20 -15 15 -16 7 19 -10 0 -33 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -28 -9 -19 -19 -52 -66 \\nRECALCULATED SUFFIX:- -66 -88 -92 -67 -47 -32 -47 -31 -38 -57 -47 -47 -14 \\nDIFFERENCE- 110 118 68 28 -2 28 -4 10 48 28 28 -38 \\nDIFFERENCE WRT TO origDifference \\n-20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 20 \\n```\\n\\n**THE MAIN REASON BEHIND THIS BEHAVIOUR\\nLEFT SIDE OF POINT OF CHANGE DECREASES \\nAND \\nRIGHT SIDE INCLUDING CHANGE POINT INCREASES BY K**\\n\\n![image](https://assets.leetcode.com/users/images/b960f4bb-c3f4-4525-9b92-59f09f84128e_1655884550.8194563.jpeg)\\n\\n\\n\\n\\n# CODE\\n```\\nclass Solution {\\npublic:\\n    \\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int,int> left;  \\n        unordered_map<long long int,int> right;   \\n        \\n        long long int sum=accumulate(nums.begin(),nums.end(),0L);\\n        long long int leftSum=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n-1;i++){\\n            leftSum+=nums[i];\\n            long long int rightSum=sum-leftSum;\\n            long long int difference=leftSum-rightSum;\\n            right[difference]++; //storing difference count in right, since no difference exist in left\\n        }\\n        \\n        int res=right[0];        // Point Zero difference are the partition points                       \\n        leftSum=0;\\n        for(int i=0;i<n;i++){\\n            long long int D=k-nums[i];  \\n            res=max(res,right[-D]+left[D]);  // We can run a few test cases and see that if we replace arr[i] by k, the difference D, the left side including i,each element decreases by D while the right Side each element increases by D, so we find -D on right Side... WHY?? if right side is increasing by D, we need to find -D since this will result in -D+D=0, which are our partition points, since point 0 signifies a partition where leftSum==rightSum, similarly, left side decreases by D, so we find +D on left since this will result in zero as well.\\n\\n            leftSum+=nums[i];\\n            long long int rightSum=sum-leftSum;\\n            left[leftSum-rightSum]++;   //Now since we are moving our i forward, we are gonna change the next i point, so we are placing leftSum-RightSum on left side  \\n            right[leftSum-rightSum]--;  // From right we are gonna decrease it and transfer to left side\\n            if(right[leftSum-rightSum]==0){\\n                right.erase(leftSum-rightSum);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid resetAndRecalculate(vector<int> &prefix, vector<int> &suffix, vector<int> &arr){\\n    cout<<endl;\\n    prefix=arr;\\n    suffix=arr;\\n    for(int i=1;i<arr.size();i++){\\n        prefix[i]=prefix[i]+prefix[i-1];\\n    }\\n    for(int i=arr.size()-2;i>=0;i--){\\n        suffix[i]=suffix[i]+suffix[i+1];\\n    }\\n    cout<<\"RECALCULATED PREFIX:- \";\\n    for(auto e: prefix){\\n        cout<<e<<\" \";\\n    }\\n    cout<<endl<<\"RECALCULATED SUFFIX:- \";\\n    for(auto e: suffix){\\n        cout<<e<<\" \";\\n    }\\n    cout<<endl;\\n}\\n \\nvoid Solve(vector<int> &arr, int k){\\n    int n=arr.size();\\n    vector<int> prefix=arr;\\n    vector<int> suffix=arr;\\n    for(int i=1;i<n;i++){\\n        prefix[i]=prefix[i]+prefix[i-1];\\n    }\\n    for(int i=n-2;i>=0;i--){\\n        suffix[i]=suffix[i]+suffix[i+1];\\n    }\\n    vector<int> origDifference(n);\\n    cout<<\"DIFFERENCE WITHOUT REPLACEMENT \"<<endl;\\n    for(int i=0;i<n-1;i++){\\n        origDifference[i]=prefix[i]-suffix[i+1];\\n        cout<<origDifference[i]<<\" \";\\n    }\\n    cout<<endl;\\n    for(int i=0;i<n-1;i++){\\n        cout<<endl;\\n        vector<int> temp=arr;\\n        temp[i]=k;\\n        cout<<\"i= \"<<i<<endl;\\n        cout<<\"Difference is d- \"<<k-arr[i]<<endl;\\n        cout<<\"ARRAY- \";\\n        for(auto e: temp){\\n            cout<<e<<\" \";\\n        }\\n        resetAndRecalculate(prefix,suffix,temp);\\n        vector<int> tempDiff(n);\\n        cout<<\"DIFFERENCE- \";\\n        for(int i=0;i<n-1;i++){\\n            tempDiff[i]=prefix[i]-suffix[i+1];\\n            cout<<tempDiff[i]<<\" \";\\n        }\\n        cout<<endl<<\"DIFFERENCE WRT TO origDifference \"<<endl;\\n        for(int i=0;i<n-1;i++){\\n            cout<<origDifference[i]-tempDiff[i]<<\" \";\\n        }\\n        cout<<endl;\\n    }\\n    \\n}\\n\\nint main() {\\n    vector<int> arr={22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14};\\n    int k=-33;\\n    cout<<\"ORIGINAL ARRAY: -\"<<endl;\\n    for(auto e: arr){\\n        cout<<e<<\" \";\\n    }\\n    cout<<endl<<endl;\\n    Solve(arr,k);\\n\\n    return 0;\\n}\\n```\n```\\nORIGINAL ARRAY: -\\n22 4 -25 -20 -15 15 -16 7 19 -10 0 -13 -14 \\n\\nDIFFERENCE WITHOUT REPLACEMENT \\n90 98 48 8 -22 8 -24 -10 28 8 8 -18 \\n\\ni= 0\\nDifference is d- -55\\nARRAY- -33 4 -25 -20 -15 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- -33 -29 -54 -74 -89 -74 -90 -83 -64 -74 -74 -87 -101 \\nRECALCULATED SUFFIX:- -101 -68 -72 -47 -27 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 35 43 -7 -47 -77 -47 -79 -65 -27 -47 -47 -73 \\nDIFFERENCE WRT TO origDifference \\n55 55 55 55 55 55 55 55 55 55 55 55 // since we changed i=0, there is no change seen, since left does not exist\\n\\ni= 1\\nDifference is d- -37\\nARRAY- 22 -33 -25 -20 -15 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 -11 -36 -56 -71 -56 -72 -65 -46 -56 -56 -69 -83 \\nRECALCULATED SUFFIX:- -83 -105 -72 -47 -27 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 127 61 11 -29 -59 -29 -61 -47 -9 -29 -29 -55 \\nDIFFERENCE WRT TO origDifference \\n-37 37 37 37 37 37 37 37 37 37 37 37  // when changed arr[i]=k, seen all j<i are getting decreased by d\\n\\ni= 2\\nDifference is d- -8\\nARRAY- 22 4 -33 -20 -15 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 -7 -27 -42 -27 -43 -36 -17 -27 -27 -40 -54 \\nRECALCULATED SUFFIX:- -54 -76 -80 -47 -27 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 98 106 40 0 -30 0 -32 -18 20 0 0 -26   // These zeros are the points of partitions \\nDIFFERENCE WRT TO origDifference \\n-8 -8 8 8 8 8 8 8 8 8 8 8  // when changed arr[i]=k, seen all j<i are getting decreased by d\\n\\ni= 3\\nDifference is d- -13\\nARRAY- 22 4 -25 -33 -15 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -32 -47 -32 -48 -41 -22 -32 -32 -45 -59 \\nRECALCULATED SUFFIX:- -59 -81 -85 -60 -27 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 103 111 61 -5 -35 -5 -37 -23 15 -5 -5 -31 \\nDIFFERENCE WRT TO origDifference \\n-13 -13 -13 13 13 13 13 13 13 13 13 13 \\n\\ni= 4\\nDifference is d- -18\\nARRAY- 22 4 -25 -20 -33 15 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -52 -37 -53 -46 -27 -37 -37 -50 -64 \\nRECALCULATED SUFFIX:- -64 -86 -90 -65 -45 -12 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 108 116 66 26 -40 -10 -42 -28 10 -10 -10 -36 \\nDIFFERENCE WRT TO origDifference \\n-18 -18 -18 -18 18 18 18 18 18 18 18 18 \\n\\ni= 5\\nDifference is d- -48\\nARRAY- 22 4 -25 -20 -15 -33 -16 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -67 -83 -76 -57 -67 -67 -80 -94 \\nRECALCULATED SUFFIX:- -94 -116 -120 -95 -75 -60 -27 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 138 146 96 56 26 -40 -72 -58 -20 -40 -40 -66 \\nDIFFERENCE WRT TO origDifference \\n-48 -48 -48 -48 -48 48 48 48 48 48 48 48 \\n\\ni= 6\\nDifference is d- -17\\nARRAY- 22 4 -25 -20 -15 15 -33 7 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -52 -45 -26 -36 -36 -49 -63 \\nRECALCULATED SUFFIX:- -63 -85 -89 -64 -44 -29 -44 -11 -18 -37 -27 -27 -14 \\nDIFFERENCE- 107 115 65 25 -5 25 -41 -27 11 -9 -9 -35 \\nDIFFERENCE WRT TO origDifference \\n-17 -17 -17 -17 -17 -17 17 17 17 17 17 17 \\n\\ni= 7\\nDifference is d- -40\\nARRAY- 22 4 -25 -20 -15 15 -16 -33 19 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -68 -49 -59 -59 -72 -86 \\nRECALCULATED SUFFIX:- -86 -108 -112 -87 -67 -52 -67 -51 -18 -37 -27 -27 -14 \\nDIFFERENCE- 130 138 88 48 18 48 16 -50 -12 -32 -32 -58 \\nDIFFERENCE WRT TO origDifference \\n-40 -40 -40 -40 -40 -40 -40 40 40 40 40 40 \\n\\ni= 8\\nDifference is d- -52\\nARRAY- 22 4 -25 -20 -15 15 -16 7 -33 -10 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -28 -61 -71 -71 -84 -98 \\nRECALCULATED SUFFIX:- -98 -120 -124 -99 -79 -64 -79 -63 -70 -37 -27 -27 -14 \\nDIFFERENCE- 142 150 100 60 30 60 28 42 -24 -44 -44 -70 \\nDIFFERENCE WRT TO origDifference \\n-52 -52 -52 -52 -52 -52 -52 -52 52 52 52 52 \\n\\ni= 9\\nDifference is d- -23\\nARRAY- 22 4 -25 -20 -15 15 -16 7 19 -33 0 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -28 -9 -42 -42 -55 -69 \\nRECALCULATED SUFFIX:- -69 -91 -95 -70 -50 -35 -50 -34 -41 -60 -27 -27 -14 \\nDIFFERENCE- 113 121 71 31 1 31 -1 13 51 -15 -15 -41 \\nDIFFERENCE WRT TO origDifference \\n-23 -23 -23 -23 -23 -23 -23 -23 -23 23 23 23 \\n\\ni= 10\\nDifference is d- -33\\nARRAY- 22 4 -25 -20 -15 15 -16 7 19 -10 -33 -13 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -28 -9 -19 -52 -65 -79 \\nRECALCULATED SUFFIX:- -79 -101 -105 -80 -60 -45 -60 -44 -51 -70 -60 -27 -14 \\nDIFFERENCE- 123 131 81 41 11 41 9 23 61 41 -25 -51 \\nDIFFERENCE WRT TO origDifference \\n-33 -33 -33 -33 -33 -33 -33 -33 -33 -33 33 33 \\n\\ni= 11\\nDifference is d- -20\\nARRAY- 22 4 -25 -20 -15 15 -16 7 19 -10 0 -33 -14 \\nRECALCULATED PREFIX:- 22 26 1 -19 -34 -19 -35 -28 -9 -19 -19 -52 -66 \\nRECALCULATED SUFFIX:- -66 -88 -92 -67 -47 -32 -47 -31 -38 -57 -47 -47 -14 \\nDIFFERENCE- 110 118 68 28 -2 28 -4 10 48 28 28 -38 \\nDIFFERENCE WRT TO origDifference \\n-20 -20 -20 -20 -20 -20 -20 -20 -20 -20 -20 20 \\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int,int> left;  \\n        unordered_map<long long int,int> right;   \\n        \\n        long long int sum=accumulate(nums.begin(),nums.end(),0L);\\n        long long int leftSum=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n-1;i++){\\n            leftSum+=nums[i];\\n            long long int rightSum=sum-leftSum;\\n            long long int difference=leftSum-rightSum;\\n            right[difference]++; //storing difference count in right, since no difference exist in left\\n        }\\n        \\n        int res=right[0];        // Point Zero difference are the partition points                       \\n        leftSum=0;\\n        for(int i=0;i<n;i++){\\n            long long int D=k-nums[i];  \\n            res=max(res,right[-D]+left[D]);  // We can run a few test cases and see that if we replace arr[i] by k, the difference D, the left side including i,each element decreases by D while the right Side each element increases by D, so we find -D on right Side... WHY?? if right side is increasing by D, we need to find -D since this will result in -D+D=0, which are our partition points, since point 0 signifies a partition where leftSum==rightSum, similarly, left side decreases by D, so we find +D on left since this will result in zero as well.\\n\\n            leftSum+=nums[i];\\n            long long int rightSum=sum-leftSum;\\n            left[leftSum-rightSum]++;   //Now since we are moving our i forward, we are gonna change the next i point, so we are placing leftSum-RightSum on left side  \\n            right[leftSum-rightSum]--;  // From right we are gonna decrease it and transfer to left side\\n            if(right[leftSum-rightSum]==0){\\n                right.erase(leftSum-rightSum);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1523151,
                "title": "a-clear-explanation",
                "content": "I found most of the discussions gave a solid answer with a vague explanation. Thus, this post is aimed to provide some insights into the problem to help the reader develop a deeper understanding.\\n\\nFirst, the problem is trying to solve the question, \"return the maximum number of possible partition ways **after** updating at most one element to `k`\".\\n\\nIt is important to realize that the problem is **NOT** to return all unique partition ways for all possible update. In other words, the update is made first, then we count the possible partition ways, and finally get the maximum of them. \\n\\nIn short, there are at most `n + 1` update ways, literally, no update and update at position `j` where `j` is in `[0, ... , n - 1]`. For each update scenario, there are at most `n - 1` partition ways. This is easy to understand, we can parition at position `i` in `[1, ... , n - 1]`, where each patition splits the array into `[0, ..., i - 1]` and `[i, ... , n - 1]`.\\n\\nNext, let us define an array called `diff`, where `diff[i] = sum(nums[0] to nums[i - 1]) - sum(nums[i] to nums[n - 1])`. The diff array can be constructed from strategy like prefix sum (skip the details for now). If `diff[i] == 0`, then we know index `i` is a `pivot`. If we  no update is allowed, the answer would be the number of `diff[i] == 0` where `1 <= i < n`.\\n\\nLet us consider updating the array. There are at most `n` possible update ways. For each update, we can update `nums` and generate a new diff array. This leads to a solution of time complexity O(n^2).\\n\\nAlternatively, instead of generating a new diff array, we can reuse the existing one. The update operation affects the diff array in two ways. For an update at position `j`, define a variable `delta = k - nums[j]`. The update decreases `diff[i]` by delta where `1 <= i <= j` and increases `diff[i]` by delta where `j  < i < n`. We can simply check if `diff[i] == +/- delta`.\\n\\nNow we have our first brute force version. Time complexity O(n^2).\\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int result = 0;\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        \\n        int n = nums.length;\\n        long sum = 0;\\n        for (int num : nums) {\\n            sum += (long) num;\\n        }\\n        \\n        // 1st step, construct diff, count zeros.\\n        long[] diff = new long[n];\\n        diff[0] = -sum;        \\n        for (int i = 1; i < n; i++) {\\n            diff[i] = diff[i - 1] + 2 * nums[i - 1];\\n            if (diff[i] == 0) {\\n                result++;\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            int count = 0;\\n            long delta = (long) (k - nums[j]);\\n            // diff[i] = sum[0, ..., i - 1] - sum[i, ..., n - 1]\\n            for (int i = 1; i <= j; i++) {\\n                if (diff[i] == delta) {\\n                    count++;\\n                }\\n            }\\n            for (int i = j + 1; i < n; i++) {\\n                if (diff[i] == -delta) {\\n                    count++;\\n                }\\n            }\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nTo optimize it, we notice that the split cut inside the for loop changes with `j` too. It splits the diff array into two. Let us define it as `left` array and `right` array. We can use a HashMap to track the count of `diff[i]` accordingly. Each time we move to the next index, we will populate the `diff[i]` from right array to left array. It is a refactoring of what we have written.\\n\\nTime Complexity O(n):\\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int result = 0;\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        \\n        int n = nums.length;\\n        long sum = 0;\\n        for (int num : nums) {\\n            sum += (long) num;\\n        }\\n        \\n        // 1st step, construct diff, count zeros.\\n        long[] diff = new long[n];\\n        diff[0] = -sum;        \\n        for (int i = 1; i < n; i++) {\\n            diff[i] = diff[i - 1] + 2 * nums[i - 1];\\n            if (diff[i] == 0) {\\n                result++;\\n            }\\n        }\\n        \\n        Map<Long, Integer> left = new HashMap<>();\\n        Map<Long, Integer> right = new HashMap<>();\\n        \\n        for (int i = 1; i < n; i++) {\\n            right.put(diff[i], 1 + right.getOrDefault(diff[i], 0));\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            // Update the map. diff[0] is not a valid partition way.\\n            if (j > 0) {\\n                left.put(diff[j], left.getOrDefault(diff[j], 0) + 1);\\n                right.put(diff[j], right.getOrDefault(diff[j], 0) - 1);\\n            }            \\n            int count = 0;\\n            long delta = (long) (k - nums[j]);\\n            count += left.getOrDefault(delta, 0);\\n            count += right.getOrDefault(-delta, 0);\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nFurthermore, we can replace the `diff` array and calculate the value on the fly, which leads to the following code. And you can for sure find it very confusing.\\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        Map<Long, Integer> left = new HashMap<>();\\n        Map<Long, Integer> right = new HashMap<>();\\n        int n = nums.length;\\n        long sum = 0;\\n        \\n        for (int num : nums) {\\n            sum += (long) num;\\n        }\\n    \\n        long diff = -sum;\\n        for (int i = 1; i < n; i++) {\\n            diff += 2 * nums[i - 1];\\n            right.put(diff, 1 + right.getOrDefault(diff, 0));\\n        }\\n        int result = right.getOrDefault(0L, 0);\\n        \\n        diff = -sum;\\n        for (int i = 0; i < n; i++) {   \\n            long delta = (long) (k - nums[i]);\\n            int count = left.getOrDefault(delta, 0) + right.getOrDefault(-delta, 0);\\n            result = Math.max(result, count);\\n            \\n            diff += 2 * nums[i];\\n            left.put(diff, left.getOrDefault(diff, 0) + 1);\\n            right.put(diff, right.getOrDefault(diff, 0) - 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int result = 0;\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        \\n        int n = nums.length;\\n        long sum = 0;\\n        for (int num : nums) {\\n            sum += (long) num;\\n        }\\n        \\n        // 1st step, construct diff, count zeros.\\n        long[] diff = new long[n];\\n        diff[0] = -sum;        \\n        for (int i = 1; i < n; i++) {\\n            diff[i] = diff[i - 1] + 2 * nums[i - 1];\\n            if (diff[i] == 0) {\\n                result++;\\n            }\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            int count = 0;\\n            long delta = (long) (k - nums[j]);\\n            // diff[i] = sum[0, ..., i - 1] - sum[i, ..., n - 1]\\n            for (int i = 1; i <= j; i++) {\\n                if (diff[i] == delta) {\\n                    count++;\\n                }\\n            }\\n            for (int i = j + 1; i < n; i++) {\\n                if (diff[i] == -delta) {\\n                    count++;\\n                }\\n            }\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int result = 0;\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n        \\n        int n = nums.length;\\n        long sum = 0;\\n        for (int num : nums) {\\n            sum += (long) num;\\n        }\\n        \\n        // 1st step, construct diff, count zeros.\\n        long[] diff = new long[n];\\n        diff[0] = -sum;        \\n        for (int i = 1; i < n; i++) {\\n            diff[i] = diff[i - 1] + 2 * nums[i - 1];\\n            if (diff[i] == 0) {\\n                result++;\\n            }\\n        }\\n        \\n        Map<Long, Integer> left = new HashMap<>();\\n        Map<Long, Integer> right = new HashMap<>();\\n        \\n        for (int i = 1; i < n; i++) {\\n            right.put(diff[i], 1 + right.getOrDefault(diff[i], 0));\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            // Update the map. diff[0] is not a valid partition way.\\n            if (j > 0) {\\n                left.put(diff[j], left.getOrDefault(diff[j], 0) + 1);\\n                right.put(diff[j], right.getOrDefault(diff[j], 0) - 1);\\n            }            \\n            int count = 0;\\n            long delta = (long) (k - nums[j]);\\n            count += left.getOrDefault(delta, 0);\\n            count += right.getOrDefault(-delta, 0);\\n            result = Math.max(result, count);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        Map<Long, Integer> left = new HashMap<>();\\n        Map<Long, Integer> right = new HashMap<>();\\n        int n = nums.length;\\n        long sum = 0;\\n        \\n        for (int num : nums) {\\n            sum += (long) num;\\n        }\\n    \\n        long diff = -sum;\\n        for (int i = 1; i < n; i++) {\\n            diff += 2 * nums[i - 1];\\n            right.put(diff, 1 + right.getOrDefault(diff, 0));\\n        }\\n        int result = right.getOrDefault(0L, 0);\\n        \\n        diff = -sum;\\n        for (int i = 0; i < n; i++) {   \\n            long delta = (long) (k - nums[i]);\\n            int count = left.getOrDefault(delta, 0) + right.getOrDefault(-delta, 0);\\n            result = Math.max(result, count);\\n            \\n            diff += 2 * nums[i];\\n            left.put(diff, left.getOrDefault(diff, 0) + 1);\\n            right.put(diff, right.getOrDefault(diff, 0) - 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499064,
                "title": "c-using-prefix-and-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& A, int k) {\\n        \\n        int n= A.size();\\n        vector<long long int >pref(n);\\n        vector<long long int >suff(n);\\n        pref[0]=A[0];suff[n-1]=A[n-1];\\n        \\n        // creating prefix and suffix arrays\\n        for(int i=1;i<n;i++)pref[i] = pref[i-1] +A[i];\\n        for(int i=n-2;i>=0;i--)suff[i] = suff[i+1] + A[i];\\n        \\n        map<long long int ,int >mp;\\n        map<long long int ,int >mp1;\\n        \\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            long long int l = pref[i];\\n            long long int r = suff[i] - A[i];\\n            mp[r-l]++;\\n        }\\n        // mp[0] now represnts no of partitions such that diff beetween suffix and prefix is zero\\n        \\n        long long int ans =mp[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            // this is the case if we change the ith index to k this d will be added to all the preffix from the ith index to the end\\n            // this (-d) would change for all the suffix before index i\\n            long long int d = k-A[i];\\n            ans = max(ans , (1ll)*(mp[d]-mp1[d]) + mp1[-d] );\\n\\t\\t\\t\\n\\t\\t\\t//mp[d]-mp1[d]) this for the right prefix\\n\\t\\t\\t//mp1[-d]  this is for left suffix\\n             \\n            //updating mp1\\n            long long int l = pref[i];\\n            long long int r = suff[i] - A[i];\\n        \\n            mp1[r-l]++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& A, int k) {\\n        \\n        int n= A.size();\\n        vector<long long int >pref(n);\\n        vector<long long int >suff(n);\\n        pref[0]=A[0];suff[n-1]=A[n-1];\\n        \\n        // creating prefix and suffix arrays\\n        for(int i=1;i<n;i++)pref[i] = pref[i-1] +A[i];\\n        for(int i=n-2;i>=0;i--)suff[i] = suff[i+1] + A[i];\\n        \\n        map<long long int ,int >mp;\\n        map<long long int ,int >mp1;\\n        \\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            long long int l = pref[i];\\n            long long int r = suff[i] - A[i];\\n            mp[r-l]++;\\n        }\\n        // mp[0] now represnts no of partitions such that diff beetween suffix and prefix is zero\\n        \\n        long long int ans =mp[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            // this is the case if we change the ith index to k this d will be added to all the preffix from the ith index to the end\\n            // this (-d) would change for all the suffix before index i\\n            long long int d = k-A[i];\\n            ans = max(ans , (1ll)*(mp[d]-mp1[d]) + mp1[-d] );\\n\\t\\t\\t\\n\\t\\t\\t//mp[d]-mp1[d]) this for the right prefix\\n\\t\\t\\t//mp1[-d]  this is for left suffix\\n             \\n            //updating mp1\\n            long long int l = pref[i];\\n            long long int r = suff[i] - A[i];\\n        \\n            mp1[r-l]++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499196,
                "title": "two-hashmaps-java-explanation",
                "content": "This problem can be split into 2 cases: unchanged and change one element.\\n1. For the unchanged case, just use prefix sum to check the number of ways to partition.\\n2. For the other case, think about the two-sides prefix sum. Split the whole array into 3 parts: left part, the one element to change, the right part (as the figure below). \\n![image](https://assets.leetcode.com/users/images/d8957731-8823-401e-8454-f2a859c14661_1633191495.2487679.png)\\nThen use two hashmaps to keep record of the prefix sum from both sides for the left-part and right-part respectively. Then the number of ways is just the frequncy of key totalsum/2 for both hashmaps. Repeat the process by moving the changed element forward and keep the biggest frequency.\\n\\n```java\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long totalSum = 0;\\n        for (int i = 0; i < n; ++i) {\\n            arr[i] = (long)(nums[i]);\\n            totalSum += arr[i];\\n        }\\n        long[] sum = new long[n];\\n        sum[0] = arr[0];\\n       \\n        for (int i = 1; i < n; ++i) {\\n            sum[i] = sum[i-1] + (long)arr[i];\\n        }\\n        \\n        int res = 0;\\n        \\n        Map<Long, Integer> leftSum = new HashMap(), rightSum = new HashMap();\\n        \\n        for (int idx = 1; idx < n; ++idx) { \\n            if (sum[idx-1] == sum[n-1] - sum[idx-1]) {\\n                res ++;\\n            }\\n        }\\n        \\n        long temp = 0;\\n        for (int i = n - 1; i > 0; --i) {\\n            temp += arr[i];\\n            rightSum.put(temp, rightSum.getOrDefault(temp, 0) + 1);\\n        }\\n        \\n        temp = 0;\\n        long newSum = totalSum + (long)(k) - arr[0];\\n        if (newSum % 2 == 0 && rightSum.containsKey(newSum / 2)) {\\n            res = Math.max(res, rightSum.get(newSum / 2));\\n        }\\n        for (int idx = 1; idx < n; ++idx) {\\n            temp += arr[idx-1];\\n            leftSum.put(temp, leftSum.getOrDefault(temp, 0) + 1);\\n            if (rightSum.containsKey(totalSum - temp)) {\\n                int fr = rightSum.get(totalSum - temp);\\n                if (fr == 1)\\n                    rightSum.remove(totalSum - temp);\\n                else\\n                    rightSum.put(totalSum - temp, fr - 1);\\n            }\\n            \\n            newSum = totalSum + (long)(k) - arr[idx];\\n            if (newSum % 2 != 0)\\n                continue;\\n            \\n            int cl = leftSum.getOrDefault(newSum / 2, 0), cr = rightSum.getOrDefault(newSum / 2, 0);\\n            res = Math.max(res, cl + cr);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long totalSum = 0;\\n        for (int i = 0; i < n; ++i) {\\n            arr[i] = (long)(nums[i]);\\n            totalSum += arr[i];\\n        }\\n        long[] sum = new long[n];\\n        sum[0] = arr[0];\\n       \\n        for (int i = 1; i < n; ++i) {\\n            sum[i] = sum[i-1] + (long)arr[i];\\n        }\\n        \\n        int res = 0;\\n        \\n        Map<Long, Integer> leftSum = new HashMap(), rightSum = new HashMap();\\n        \\n        for (int idx = 1; idx < n; ++idx) { \\n            if (sum[idx-1] == sum[n-1] - sum[idx-1]) {\\n                res ++;\\n            }\\n        }\\n        \\n        long temp = 0;\\n        for (int i = n - 1; i > 0; --i) {\\n            temp += arr[i];\\n            rightSum.put(temp, rightSum.getOrDefault(temp, 0) + 1);\\n        }\\n        \\n        temp = 0;\\n        long newSum = totalSum + (long)(k) - arr[0];\\n        if (newSum % 2 == 0 && rightSum.containsKey(newSum / 2)) {\\n            res = Math.max(res, rightSum.get(newSum / 2));\\n        }\\n        for (int idx = 1; idx < n; ++idx) {\\n            temp += arr[idx-1];\\n            leftSum.put(temp, leftSum.getOrDefault(temp, 0) + 1);\\n            if (rightSum.containsKey(totalSum - temp)) {\\n                int fr = rightSum.get(totalSum - temp);\\n                if (fr == 1)\\n                    rightSum.remove(totalSum - temp);\\n                else\\n                    rightSum.put(totalSum - temp, fr - 1);\\n            }\\n            \\n            newSum = totalSum + (long)(k) - arr[idx];\\n            if (newSum % 2 != 0)\\n                continue;\\n            \\n            int cl = leftSum.getOrDefault(newSum / 2, 0), cr = rightSum.getOrDefault(newSum / 2, 0);\\n            res = Math.max(res, cl + cr);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622571,
                "title": "o-n-with-explanation",
                "content": "It took me a while to understand but the idea is \\n1) We calculate total sum\\n2) Now we iterate over the array and considering each index as a pivot point calculate the frequency of differences between leftSum - rightSum at the given point.\\n3) By Default, all the difference\\'s that are 0 are already considered for an answer, so the count of all differences that are 0 is one possible answer but may not be maximum number of ways to partition array.\\n4) Now we try to replace each index value with our K. So how is the replacement done, well we subtract that index value i.e num[i] and add k, In other words we are adding k - nums[i], call it delta to the candidate index.\\n5) Now is the tricky part, remember our difference is calculated leftSum - rightSum. Now lets say we added the delta to an index that falls into left side of a pivot.\\nThat means leftSum will go up by delta, which means to neutralize it rightSum should also have to go up by delta for diff to be 0.\\nBut how can we deduce the fact there exists a pivot point on the right of this given index where RightSum is more than leftSum by delta. We can fortunately find that from diff hashmap where count of all differences where it has -delta as key (as diff = leftSum - rightsum and if rightSum > leftSum by delta, it will give us -delta)\\nSo now that can give us all differences to neutralize any increase in leftSum, by doing something like this `diffFreq.getOrDefault(-delta, 0)`\\nSimilarly if the delta falls in the right side of the pivot, and since diff is calculated leftSum - rightSum, there must exist a pivot point on the leftDiff HashMap i.e `leftFreq` in code below where leftSum is greater than rightSum by delta to neutralize the increase in rightSum. We can find that by `leftFreq.getOrDefault(delta, 0)`\\n\\n\\n\\n\\n```\\n    public int waysToPartition(int[] nums, int k) {\\n        Map<Long, Integer> diffFreq = new HashMap<>();\\n        \\n        long totalSum = 0;        \\n        for(int i=0; i < nums.length; i++)\\n            totalSum += nums[i];\\n                    \\n        long leftSum = 0L;\\n        for(int i=0; i < nums.length-1; i++) {\\n            leftSum += nums[i];\\n            long diff = 2*leftSum - totalSum;\\n            diffFreq.put(diff, diffFreq.getOrDefault(diff, 0) + 1);\\n        }\\n        \\n        \\n        Map<Long, Integer> leftFreq = new HashMap<>();\\n\\n        int result = diffFreq.getOrDefault(0L, 0);\\n        leftSum = 0L;\\n        for(int i=0; i < nums.length; i++) {\\n            long delta = (long) (k - nums[i]);            \\n            result = Math.max(result, leftFreq.getOrDefault(delta, 0) + diffFreq.getOrDefault(-delta, 0));\\n\\n            leftSum += nums[i];\\n            long diff = 2 * leftSum - totalSum;\\n            leftFreq.put(diff, leftFreq.getOrDefault(diff, 0) + 1);\\n            diffFreq.put(diff, diffFreq.getOrDefault(diff, 0) - 1);\\n        }\\n        \\n        return result;\\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int waysToPartition(int[] nums, int k) {\\n        Map<Long, Integer> diffFreq = new HashMap<>();\\n        \\n        long totalSum = 0;        \\n        for(int i=0; i < nums.length; i++)\\n            totalSum += nums[i];\\n                    \\n        long leftSum = 0L;\\n        for(int i=0; i < nums.length-1; i++) {\\n            leftSum += nums[i];\\n            long diff = 2*leftSum - totalSum;\\n            diffFreq.put(diff, diffFreq.getOrDefault(diff, 0) + 1);\\n        }\\n        \\n        \\n        Map<Long, Integer> leftFreq = new HashMap<>();\\n\\n        int result = diffFreq.getOrDefault(0L, 0);\\n        leftSum = 0L;\\n        for(int i=0; i < nums.length; i++) {\\n            long delta = (long) (k - nums[i]);            \\n            result = Math.max(result, leftFreq.getOrDefault(delta, 0) + diffFreq.getOrDefault(-delta, 0));\\n\\n            leftSum += nums[i];\\n            long diff = 2 * leftSum - totalSum;\\n            leftFreq.put(diff, leftFreq.getOrDefault(diff, 0) + 1);\\n            diffFreq.put(diff, diffFreq.getOrDefault(diff, 0) - 1);\\n        }\\n        \\n        return result;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499539,
                "title": "java-o-n-by-prefixsum-and-hashmap",
                "content": "This question can be solved by figuring out relationship between prefixSum and sum;\\n\\nWhen the array is divided at index i into two parts: [0, i - 1] and [i, n - 1], if these two parts have same subarraySum, then their subarraySum = sum / 2;\\n\\n1. WITHOUT the change one element condition, how many ways can the original array be divided into two parts?\\n\\n\\t--> if (sum % 2 == 1) then the original array cannot be divided into two subarrays with equal subarraySum;\\n\\t--> if (sum % 2 == 0) then the original array POSSIBLY be divided into two subarrays with equal subarraySum; \\n\\t\\t\\t-> AND IMPORTANTLY, the subarraySum = sum / 2;\\n\\t\\nthen the question become: how many subarray [0, i] where i > 0 has subarraySum = sum / 2?\\n\\n\\t --> The subarraySum of the subarray [0, i] is the prefixSum[i];\\n\\t --> Then the question become: how many prefixSum = sum / 2;\\n \\n I used a Map<Integer, Integer> **prefixCnt** to count frequency of prefixSum; and one query of sum / 2 is the answer to the original array division.\\n \\n 2. WITH the change a one element to k, assume we change the index i to k, then the diff = k - nums[i];\\n \\n Since we used prefixSum to solve the 1st question, we can extend the same method to the 2nd question. \\n\\n\\tAfter observation, the change at nums[i] will change the prefixSum array in this way:\\n\\t --> prefixSum[0] to prefixSum[i - 1] has no change;\\n\\t --> prefixSum[i] to prefixSum[n - 1] has changed by diff = k - nums[i];\\n\\t --> in addition, the sum has changed by diff too;\\n\\t \\nTherefore, the question become to find two subarray with subarraySum = (sum + diff) / 2, given the sum + diff is even;\\n\\t \\n\\t The subarraySum for array starting from 0 is the prefixSum, so new prefixSum[j] * 2 = sum + diff;\\n\\t \\n\\t a. if (j < i), new prefixSum[j] = prefixSum[j] since the change of nums[i] only influence prefixSum at or after i;\\n\\t b. if (j >= i, new prefixSum[j] = prefixSum[j] + diff;\\n\\t \\n\\twe need to find (a) and (b) separately by updating the **prefixCnt** map from left to right;\\n\\n\\tFor (int i = 0; i < n; i++) \\n\\t(a). prefixSum[i] = (sum + diff) / 2, the count of (sum + diff) / 2 can be retrieved from **leftPrefixCnt** map\\n\\n\\t(b). prefixSum[i] + diff = (sum + diff) / 2 --> prefixSum[i] = (sum - diff) / 2; the count of (sum - diff) / 2 can be retrieved from the most up-to-date **prefixCnt**;\\n\\n\\t(a) + (b) is the number of divisions for the new nums by changing nums[i] to k;\\n\\n\\tAfter computing count, we need to update **leftPrefixCnt** and **prefixCnt** by adding curPrefixSum into **leftPrefixCnt** and removing curPrefixSum from  **prefixCnt** ;\\n\\nHere the 2nd question is solved;\\n\\nThe 1st and 2nd question altogether is the final answer;\\n\\nThe time complexity is O(n) and space complexity is O(n);\\n\\n\\n```\\npublic int waysToPartition(int[] nums, int k) {\\n        int sum = 0, n = nums.length;\\n        Map<Integer, Integer> prefixCnt = new HashMap<>(), leftPrefixCnt = new HashMap<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            sum += nums[i];\\n            prefixCnt.put(sum, prefixCnt.getOrDefault(sum, 0) + 1);\\n        }\\n        sum += nums[n - 1];\\n        int max = 0;\\n        if (sum % 2 == 0 && prefixCnt.containsKey(sum / 2)) {\\n            max = prefixCnt.get(sum / 2);\\n        }\\n        int prefix = 0;\\n        for (int i = 0; i < n; i++) {\\n            int diff = k - nums[i];\\n            if ((sum + diff) % 2 == 0) {\\n                Integer left = leftPrefixCnt.get((sum + diff) / 2), right = prefixCnt.get((sum - diff) / 2);\\n                int count = (left == null ? 0 : left) + (right == null ? 0 : right);\\n                max = Math.max(max, count);\\n            }\\n            prefix += nums[i];\\n            leftPrefixCnt.put(prefix, leftPrefixCnt.getOrDefault(prefix, 0) + 1);\\n            if (i < n - 1)\\n                prefixCnt.put(prefix, prefixCnt.get(prefix) - 1);\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int waysToPartition(int[] nums, int k) {\\n        int sum = 0, n = nums.length;\\n        Map<Integer, Integer> prefixCnt = new HashMap<>(), leftPrefixCnt = new HashMap<>();\\n        for (int i = 0; i < n - 1; i++) {\\n            sum += nums[i];\\n            prefixCnt.put(sum, prefixCnt.getOrDefault(sum, 0) + 1);\\n        }\\n        sum += nums[n - 1];\\n        int max = 0;\\n        if (sum % 2 == 0 && prefixCnt.containsKey(sum / 2)) {\\n            max = prefixCnt.get(sum / 2);\\n        }\\n        int prefix = 0;\\n        for (int i = 0; i < n; i++) {\\n            int diff = k - nums[i];\\n            if ((sum + diff) % 2 == 0) {\\n                Integer left = leftPrefixCnt.get((sum + diff) / 2), right = prefixCnt.get((sum - diff) / 2);\\n                int count = (left == null ? 0 : left) + (right == null ? 0 : right);\\n                max = Math.max(max, count);\\n            }\\n            prefix += nums[i];\\n            leftPrefixCnt.put(prefix, leftPrefixCnt.getOrDefault(prefix, 0) + 1);\\n            if (i < n - 1)\\n                prefixCnt.put(prefix, prefixCnt.get(prefix) - 1);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328358,
                "title": "c-100-fast-explanation-with-comments",
                "content": "# Intuition\\nTry to play between left and right subarray in form of variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int getSum(vector<int> &nums){\\n        long long int temp = 0;\\n        for(auto &i : nums) temp += i;\\n        return temp;\\n    }\\n\\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\\n        \\n        // If flag, then we need to change element from right subarray\\n        if(flag){\\n            if(mp[val].second >= pivot) return true;\\n            return false;\\n        }\\n\\n        // Else we need to change element from left subarray\\n        else{\\n            if(mp[val].first < pivot) return true;\\n            return false;\\n        }\\n    }\\n\\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int, pair<int, int>> mp;\\n        unordered_map<long long int, pair<int, int>> count;\\n\\n        // mp stores first and last occurence of an element\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]].first = i;\\n            }\\n            mp[nums[i]].second = i;\\n        }\\n\\n        long long int totSum = getSum(nums);\\n        long long int left = nums[0];\\n        int ans = 0;\\n\\n        for(int i=1; i<nums.size(); i++){\\n            long long int right = totSum - left;\\n\\n            if(left == right){\\n                ans++;\\n            }\\n            else{\\n                long long int diff = left - right;\\n\\n                // num is the value of element we need to change with k wo satisfy the condition\\n                long long int num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 1)){\\n\\n                        // count.second means we have got the element in right subarray with which we can replace our k\\n                        count[num].second++;\\n                    }\\n                }\\n\\n                diff = right - left;\\n                num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 0)){\\n\\n                        // count.first means we got element in left subarray to get replaced \\n\\n                        count[num].first++; \\n                    }\\n                }\\n            }\\n\\n            left += nums[i];\\n\\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(auto [i,j] : count){\\n            maxi = max(maxi, max(j.first, j.second));\\n        }\\n\\n        return max(maxi, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int getSum(vector<int> &nums){\\n        long long int temp = 0;\\n        for(auto &i : nums) temp += i;\\n        return temp;\\n    }\\n\\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\\n        \\n        // If flag, then we need to change element from right subarray\\n        if(flag){\\n            if(mp[val].second >= pivot) return true;\\n            return false;\\n        }\\n\\n        // Else we need to change element from left subarray\\n        else{\\n            if(mp[val].first < pivot) return true;\\n            return false;\\n        }\\n    }\\n\\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int, pair<int, int>> mp;\\n        unordered_map<long long int, pair<int, int>> count;\\n\\n        // mp stores first and last occurence of an element\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]].first = i;\\n            }\\n            mp[nums[i]].second = i;\\n        }\\n\\n        long long int totSum = getSum(nums);\\n        long long int left = nums[0];\\n        int ans = 0;\\n\\n        for(int i=1; i<nums.size(); i++){\\n            long long int right = totSum - left;\\n\\n            if(left == right){\\n                ans++;\\n            }\\n            else{\\n                long long int diff = left - right;\\n\\n                // num is the value of element we need to change with k wo satisfy the condition\\n                long long int num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 1)){\\n\\n                        // count.second means we have got the element in right subarray with which we can replace our k\\n                        count[num].second++;\\n                    }\\n                }\\n\\n                diff = right - left;\\n                num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 0)){\\n\\n                        // count.first means we got element in left subarray to get replaced \\n\\n                        count[num].first++; \\n                    }\\n                }\\n            }\\n\\n            left += nums[i];\\n\\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(auto [i,j] : count){\\n            maxi = max(maxi, max(j.first, j.second));\\n        }\\n\\n        return max(maxi, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499242,
                "title": "using-one-hash-map-binary-search",
                "content": "class Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<long long int>prefix(n);\\n        prefix[0]=nums[0];\\n        map<long long int,vector<long long int>>mp;\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+nums[i];\\n        for(int i=0;i<n;i++)mp[prefix[i]].push_back(i);\\n        long long int sum = prefix[n-1];\\n        long long int ans =0;\\n        if(sum%2==0)\\n        {\\n            long long int si = mp[sum/2].size();\\n            ans = max(ans,si);\\n            if(ans)\\n            {\\n                long long int si = mp[sum/2].size();\\n                if(mp[sum/2][si-1]==n-1)ans--;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            long long int upd = k-nums[i];\\n            long long int new_sum = sum + upd;\\n            if(new_sum%2)continue;\\n            long long int x = new_sum/2;\\n            long long int sol=0;\\n            if(mp[x].size()>0)\\n            {\\n                auto it = lower_bound(mp[x].begin(),mp[x].end(),i);\\n                if(it != mp[x].begin())\\n                {\\n                    it--;\\n                    sol += it - mp[x].begin()+1;\\n                }\\n            }\\n            if(mp[x-upd].size()>0)\\n            {\\n                auto it = lower_bound(mp[x-upd].begin(),mp[x-upd].end(),i);\\n                if(it != mp[x-upd].end())\\n                {\\n                    sol += mp[x-upd].end() - it;\\n                    int si = mp[x-upd].size();\\n                    if(mp[x-upd][si-1]==n-1)sol--;\\n                }\\n            }\\n            ans = max(ans,sol);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<long long int>prefix(n);\\n        prefix[0]=nums[0];\\n        map<long long int,vector<long long int>>mp;\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+nums[i];\\n        for(int i=0;i<n;i++)mp[prefix[i]].push_back(i);\\n        long long int sum = prefix[n-1];\\n        long long int ans =0;\\n        if(sum%2==0)\\n        {\\n            long long int si = mp[sum/2].size();\\n            ans = max(ans,si);\\n            if(ans)\\n            {\\n                long long int si = mp[sum/2].size();\\n                if(mp[sum/2][si-1]==n-1)ans--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2345184,
                "title": "78-tc-and-56-sc-easy-python-solution",
                "content": "1. Create a map of list , going thru the indices and make diff between right half and left half as key.\\n2. Store all the indices in the list having the diff as x, as you gonna need it it later.\\n3. Now try to change all the indices and check how many indices could now become your pivot.\\n4. So you are changing a num, nums[i] to k.\\n5. Let\\'s assume this i index is in the left of pivot. So by changing nums[i] to k, you are increasing the sum of left half by k-nums[i].\\n6. So all the pivots where the right half\\'s sum was (k-nums[i]) grater than left half\\'s sum, would now be balanced, as you have added that (k-nums[i]) to the left. So just find out how many indices are in the RIGHT of index i, having such diff. Now, those all will be counted as pivots.\\n7. Now go back to step 5. We had assumed the index i to be in the left of pivot. Nows the time to take it the other way.\\n8. Now the index i is inthe right of pivot. By changing nums[i] to k, we have increased right half by (k-nums[i]).\\n9. So search for all the indices having left half\\'s sum more than rights\\'s half by (k-nums[i]). \\n10. The ans for the index i would be the sum of the both assumptions we have taken.\\n11. Do the same for all the indices. Max of all will be your answer. :)\\n ```\\ndef waysToPartition(self, nums: List[int], k: int) -> int:\\n\\tl, r = 0, sum(nums)\\n\\td = defaultdict(list)\\n\\tprev = nums[0]\\n\\tn = len(nums)\\n\\tans = 0\\n\\tfor i in range(1, n):\\n\\t\\tl += prev\\n\\t\\tr -= prev\\n\\t\\tif(l == r): ans += 1\\n\\t\\td[r-l].append(i)\\n\\t\\tprev = nums[i]\\n\\tfor i in range(n):\\n\\t\\tdiff = k-nums[i]\\n\\t\\tleft = right = 0\\n\\t\\tif(diff in d):\\n\\t\\t\\tright = len(d[diff]) - bisect_left(d[diff], i+1)\\n\\t\\tif(d[-diff] and d[-diff][0] <= i):\\n\\t\\t\\tleft = bisect_right(d[-diff], i)\\n\\t\\tans = max(ans, left+right)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\ndef waysToPartition(self, nums: List[int], k: int) -> int:\\n\\tl, r = 0, sum(nums)\\n\\td = defaultdict(list)\\n\\tprev = nums[0]\\n\\tn = len(nums)\\n\\tans = 0\\n\\tfor i in range(1, n):\\n\\t\\tl += prev\\n\\t\\tr -= prev\\n\\t\\tif(l == r): ans += 1\\n\\t\\td[r-l].append(i)\\n\\t\\tprev = nums[i]\\n\\tfor i in range(n):\\n\\t\\tdiff = k-nums[i]\\n\\t\\tleft = right = 0\\n\\t\\tif(diff in d):\\n\\t\\t\\tright = len(d[diff]) - bisect_left(d[diff], i+1)\\n\\t\\tif(d[-diff] and d[-diff][0] <= i):\\n\\t\\t\\tleft = bisect_right(d[-diff], i)\\n\\t\\tans = max(ans, left+right)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2275666,
                "title": "python3-change-nums-i-to-k-don-t-split-nums-i-to-left-and-right-half",
                "content": "A few tricky parts:\\n1. This questions asks you to first decide a changing point of k, and once decided, count splitting ways that make left and right half equal using this changing point. Results from different changing point of k cannot add up together.\\n2. It is straightforward to enuemrate all points that splits nums to left and right half, but this will not work. Instead we should enumerate all changing points of \\'k\\', and try to calculate number of splitting ways in O(1) time without knowing exactly which point to split.\\n\\nSuppose we change nums[i] to \\'k\\', how to know the number of splitting ways in O(1) time?\\nNumber of splitting ways equals number of prefix sums that equal to \\u201Chalf the total sum\\u201D. This can be achieved by applying counter on prefix sum array.  But since nums[i] is changed, the prefix sums counter cannot be directly used.\\nInstead, we split the counter table into two parts: left of nums[i] and right of nums[i]. Changing nums[i] to k only affect prefix sums to the right side of \\'i\\'. For the left side, we directly look for the count of \"half the total sum\". For the right side of \\'i\\', we look for the count of \"half the total sum - (k-nums[i])\". Because all these prefix sums will increase by \"k-nums[i]\", looking for the count of \"half the total sum - (k-nums[i])\" is same as looking for the count of \"half the total sum\" after num[i] becomes \\'k\\'.\\n\\n**Python3:**\\n``` python\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix = list(accumulate(nums))\\n        \\n        # \\'left sums\\' to the left and right of nums[i]\\n        l_counter = Counter() \\n        r_counter = Counter(prefix[:-1]) # \\'left sums\\' cannot include last element\\n        \\n        res =  r_counter[prefix[-1]//2] if prefix[-1]%2==0 else 0 # change nothing\\n        for i in range(len(nums)): # change nums[i] to k\\n            total = prefix[-1]+(k-nums[i])\\n            if total%2==0:\\n                cur = l_counter[total//2]+r_counter[total//2-(k-nums[i])]\\n                res = max(res,cur)\\n            l_counter[prefix[i]]+=1\\n            r_counter[prefix[i]]-=1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` python\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix = list(accumulate(nums))\\n        \\n        # \\'left sums\\' to the left and right of nums[i]\\n        l_counter = Counter() \\n        r_counter = Counter(prefix[:-1]) # \\'left sums\\' cannot include last element\\n        \\n        res =  r_counter[prefix[-1]//2] if prefix[-1]%2==0 else 0 # change nothing\\n        for i in range(len(nums)): # change nums[i] to k\\n            total = prefix[-1]+(k-nums[i])\\n            if total%2==0:\\n                cur = l_counter[total//2]+r_counter[total//2-(k-nums[i])]\\n                res = max(res,cur)\\n            l_counter[prefix[i]]+=1\\n            r_counter[prefix[i]]-=1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1548250,
                "title": "c-map-binary-search-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& A, int k) {\\n        int n = A.size();\\n        unordered_map<long long int, vector<int>> m;\\n        long long int left = A[0];\\n        long long int sum = 0;\\n        for(int x : A)\\n            sum += x;\\n        for(int i=1; i<n; i++){\\n            m[left-(sum-left)].push_back(i-1);\\n            left += A[i];\\n        }\\n        int ans = 0;\\n        if(m.find(0) != m.end())\\n            ans = m[0].size();\\n\\t\\tfor(int i=0; i<n; i++){\\n            long long int diff = k-A[i];\\n            int count = 0;\\n            if(m.find(-diff) != m.end()){\\n                vector<int> &v = m[-diff];\\n                count += v.size() - (lower_bound(v.begin(), v.end(), i) - v.begin());\\n            }\\n            if(m.find(diff)!=m.end()){\\n                vector<int> &v = m[diff];\\n                count += lower_bound(v.begin(), v.end(), i) - v.begin();\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;             \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& A, int k) {\\n        int n = A.size();\\n        unordered_map<long long int, vector<int>> m;\\n        long long int left = A[0];\\n        long long int sum = 0;\\n        for(int x : A)\\n            sum += x;\\n        for(int i=1; i<n; i++){\\n            m[left-(sum-left)].push_back(i-1);\\n            left += A[i];\\n        }\\n        int ans = 0;\\n        if(m.find(0) != m.end())\\n            ans = m[0].size();\\n\\t\\tfor(int i=0; i<n; i++){\\n            long long int diff = k-A[i];\\n            int count = 0;\\n            if(m.find(-diff) != m.end()){\\n                vector<int> &v = m[-diff];\\n                count += v.size() - (lower_bound(v.begin(), v.end(), i) - v.begin());\\n            }\\n            if(m.find(diff)!=m.end()){\\n                vector<int> &v = m[diff];\\n                count += lower_bound(v.begin(), v.end(), i) - v.begin();\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;             \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499381,
                "title": "c-map-faster-than-90",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<long long, int> m2,m1;\\n        \\n        long long pref = 0;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        for(int i=0;i<n-1;i++){\\n            pref+=nums[i];\\n            long long left = pref;\\n            long long right = sum - pref;\\n            long long d = left - right;\\n            m1[d]++;\\n        }\\n        long long suf = 0;\\n        long long val = k - nums[n-1];\\n        long long ans = m1[val];\\n        ans=max(ans,(long long)m1[0]);\\n        for(int i=n-1;i>0;i--){\\n            suf+=nums[i];\\n            long long right = suf;\\n            long long left = sum - suf;\\n            long long d = left - right;\\n            long long val = k - nums[i-1];\\n            m1[d]--;\\n            m2[d]++;\\n            ans = max(ans,(long long)m1[val]+(long long)m2[-val]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        unordered_map<long long, int> m2,m1;\\n        \\n        long long pref = 0;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++)\\n            sum+=nums[i];\\n        for(int i=0;i<n-1;i++){\\n            pref+=nums[i];\\n            long long left = pref;\\n            long long right = sum - pref;\\n            long long d = left - right;\\n            m1[d]++;\\n        }\\n        long long suf = 0;\\n        long long val = k - nums[n-1];\\n        long long ans = m1[val];\\n        ans=max(ans,(long long)m1[0]);\\n        for(int i=n-1;i>0;i--){\\n            suf+=nums[i];\\n            long long right = suf;\\n            long long left = sum - suf;\\n            long long d = left - right;\\n            long long val = k - nums[i-1];\\n            m1[d]--;\\n            m2[d]++;\\n            ans = max(ans,(long long)m1[val]+(long long)m2[-val]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499200,
                "title": "python-o-n-precompute-sums-and-scan-with-dictionary",
                "content": "The idea is to keep an array leftMore recording the difference between left and right for each candidate pivot.\\nThen try to put k in each position i, notice that any difference to the left j<=i: leftMore[j] = k-nums[i] -> 0 and any difference to the right j>i leftMore[j] = nums[i]-k -> 0. Such operation can be done in O(n) by scanning from one end to the other and keeping a hashmap {diff:count}.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        left = 0\\n        right = sum(nums)\\n        leftMore = [-right] # an array of the difference between left and right sums\\n        for pivot in range(1,n):\\n            inc = nums[pivot-1]\\n            left += inc\\n            right -= inc\\n            diff = left-right\\n            leftMore.append(diff)\\n        ans = sum([1 if n==0 else 0 for n in leftMore[1:]])\\n        \\n        # try to put k in each position and count how many pivot sum can disappear to the left of pos\\n        f = [ans]*(n)\\n        curMore = defaultdict(int)\\n        for pos in range(n):\\n            diff = k-nums[pos]\\n            if pos != 0:\\n                curMore[leftMore[pos]] += 1\\n            f[pos] = curMore[diff]\\n        \\n        # try to put k in each position and count how many pivot sum can disappear to the right of pos\\n        curMore = defaultdict(int)\\n        for pos in range(n-1,-1,-1):\\n            diff = k-nums[pos]\\n            f[pos] += curMore[-diff]\\n            if pos != 0:\\n                curMore[leftMore[pos]] += 1\\n            \\n        return max(max(f), ans)\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "The idea is to keep an array leftMore recording the difference between left and right for each candidate pivot.\\nThen try to put k in each position i, notice that any difference to the left j<=i: leftMore[j] = k-nums[i] -> 0 and any difference to the right j>i leftMore[j] = nums[i]-k -> 0. Such operation can be done in O(n) by scanning from one end to the other and keeping a hashmap {diff:count}.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        left = 0\\n        right = sum(nums)\\n        leftMore = [-right] # an array of the difference between left and right sums\\n        for pivot in range(1,n):\\n            inc = nums[pivot-1]\\n            left += inc\\n            right -= inc\\n            diff = left-right\\n            leftMore.append(diff)\\n        ans = sum([1 if n==0 else 0 for n in leftMore[1:]])\\n        \\n        # try to put k in each position and count how many pivot sum can disappear to the left of pos\\n        f = [ans]*(n)\\n        curMore = defaultdict(int)\\n        for pos in range(n):\\n            diff = k-nums[pos]\\n            if pos != 0:\\n                curMore[leftMore[pos]] += 1\\n            f[pos] = curMore[diff]\\n        \\n        # try to put k in each position and count how many pivot sum can disappear to the right of pos\\n        curMore = defaultdict(int)\\n        for pos in range(n-1,-1,-1):\\n            diff = k-nums[pos]\\n            f[pos] += curMore[-diff]\\n            if pos != 0:\\n                curMore[leftMore[pos]] += 1\\n            \\n        return max(max(f), ans)\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 1499024,
                "title": "python3-binary-search",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/182350e41572fb26ffb8c44204b037cc9f0e5035) for solutions of biweekly 62. \\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix = [0]\\n        loc = defaultdict(list)\\n        for i, x in enumerate(nums): \\n            prefix.append(prefix[-1] + x)\\n            if i < len(nums)-1: loc[prefix[-1]].append(i)\\n        \\n        ans = 0 \\n        if prefix[-1] % 2 == 0: ans = len(loc[prefix[-1]//2]) # unchanged \\n        \\n        total = prefix[-1]\\n        for i, x in enumerate(nums): \\n            cnt = 0 \\n            diff = k - x\\n            target = total + diff \\n            if target % 2 == 0: \\n                target //= 2\\n                cnt += bisect_left(loc[target], i)\\n                cnt += len(loc[target-diff]) - bisect_left(loc[target-diff], i)\\n            ans = max(ans, cnt)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix = [0]\\n        loc = defaultdict(list)\\n        for i, x in enumerate(nums): \\n            prefix.append(prefix[-1] + x)\\n            if i < len(nums)-1: loc[prefix[-1]].append(i)\\n        \\n        ans = 0 \\n        if prefix[-1] % 2 == 0: ans = len(loc[prefix[-1]//2]) # unchanged \\n        \\n        total = prefix[-1]\\n        for i, x in enumerate(nums): \\n            cnt = 0 \\n            diff = k - x\\n            target = total + diff \\n            if target % 2 == 0: \\n                target //= 2\\n                cnt += bisect_left(loc[target], i)\\n                cnt += len(loc[target-diff]) - bisect_left(loc[target-diff], i)\\n            ans = max(ans, cnt)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801817,
                "title": "python3-counter-of-left-right-at-each-pivot",
                "content": "```python\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        \"\"\"This is a good problem. It\\'s not difficult, but is quite complex.\\n\\n        The idea is that once we change a position at i, for all the pivots at\\n        1...i, the sum of the left half stay the same whereas the sum of\\n        the right half changes by delta = k - nums[i]. Similarly, for all the\\n        pivots at i + 1...n - 1, the left half changes by delta, whereas the\\n        right half stay the same.\\n\\n        We can pre-compute all the differences at each pivot position and make\\n        that into a diffs = [d1, d2, .... , dn-1]\\n\\n        Then after a change at i, if we want the pivots at 1...i to form a good\\n        partition, we must have left - (right + delta) = 0 => delta = left - right\\n        In other words, the number of good partitions is the count of d1, d2, ...\\n        di that are equal to delta. Similarly, if we want the pivots at i + 1...\\n        n - 1 to form a good partition, we must have left + delta - right = 0\\n        => left - right = -delta. In other words, the number of good partitions\\n        is the count of di+1, ...., dn-1 that are equal to -delta.\\n\\n        Based on this, we progressively build a left sum and right sum to\\n        compute the diffs array. And then progressively build a left counter\\n        and right counter to compute the number of matches to delta and -delta.\\n\\n        The difficulty is in the implementation, especially with the indices.\\n\\n        O(N), 7339 ms, faster than 32.20%\\n        \"\"\"\\n        N = len(nums)\\n        diffs = []\\n        sl, sr = 0, sum(nums)\\n        for i in range(N - 1):\\n            sl += nums[i]\\n            sr -= nums[i]\\n            diffs.append(sl - sr)\\n        diffs.append(math.inf)  # to prevent error in the counter arithemtic\\n        \\n        cl, cr = Counter(), Counter(diffs)\\n        res = cl[0] + cr[0]\\n        for i in range(N):\\n            d = k - nums[i]\\n            res = max(res, cl[d] + cr[-d])\\n            cl[diffs[i]] += 1\\n            cr[diffs[i]] -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        \"\"\"This is a good problem. It\\'s not difficult, but is quite complex.\\n\\n        The idea is that once we change a position at i, for all the pivots at\\n        1...i, the sum of the left half stay the same whereas the sum of\\n        the right half changes by delta = k - nums[i]. Similarly, for all the\\n        pivots at i + 1...n - 1, the left half changes by delta, whereas the\\n        right half stay the same.\\n\\n        We can pre-compute all the differences at each pivot position and make\\n        that into a diffs = [d1, d2, .... , dn-1]\\n\\n        Then after a change at i, if we want the pivots at 1...i to form a good\\n        partition, we must have left - (right + delta) = 0 => delta = left - right\\n        In other words, the number of good partitions is the count of d1, d2, ...\\n        di that are equal to delta. Similarly, if we want the pivots at i + 1...\\n        n - 1 to form a good partition, we must have left + delta - right = 0\\n        => left - right = -delta. In other words, the number of good partitions\\n        is the count of di+1, ...., dn-1 that are equal to -delta.\\n\\n        Based on this, we progressively build a left sum and right sum to\\n        compute the diffs array. And then progressively build a left counter\\n        and right counter to compute the number of matches to delta and -delta.\\n\\n        The difficulty is in the implementation, especially with the indices.\\n\\n        O(N), 7339 ms, faster than 32.20%\\n        \"\"\"\\n        N = len(nums)\\n        diffs = []\\n        sl, sr = 0, sum(nums)\\n        for i in range(N - 1):\\n            sl += nums[i]\\n            sr -= nums[i]\\n            diffs.append(sl - sr)\\n        diffs.append(math.inf)  # to prevent error in the counter arithemtic\\n        \\n        cl, cr = Counter(), Counter(diffs)\\n        res = cl[0] + cr[0]\\n        for i in range(N):\\n            d = k - nums[i]\\n            res = max(res, cl[d] + cr[-d])\\n            cl[diffs[i]] += 1\\n            cr[diffs[i]] -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622693,
                "title": "c-easy-to-understand-short",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int,int> left;  \\n        unordered_map<long long int,int> right;   \\n        \\n        long long int sum=accumulate(nums.begin(),nums.end(),0L);\\n        long long int leftSum=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n-1;i++){\\n            leftSum+=nums[i];\\n            long long int rightSum=sum-leftSum;\\n            long long int difference=leftSum-rightSum;\\n            right[difference]++; //storing difference count in right, since no difference exist in left\\n        }\\n        \\n        int res=right[0];        // Point Zero difference are the partition points                       \\n        leftSum=0;\\n        for(int i=0;i<n;i++){\\n            long long int D=k-nums[i];  \\n            res=max(res,right[-D]+left[D]);  // We can run a few test cases and see that if we replace arr[i] by k, the difference D, the left side including i,each element decreases by D while the right Side each element increases by D, so we find -D on right Side... WHY?? if right side is increasing by D, we need to find -D since this will result in -D+D=0, which are our partition points, since point 0 signifies a partition where leftSum==rightSum, similarly, left side decreases by D, so we find +D on left since this will result in zero as well.\\n\\n            leftSum+=nums[i];\\n            long long int rightSum=sum-leftSum;\\n            left[leftSum-rightSum]++;   //Now since we are moving our i forward, we are gonna change the next i point, so we are placing leftSum-RightSum on left side  \\n            right[leftSum-rightSum]--;  // From right we are gonna decrease it and transfer to left side\\n            if(right[leftSum-rightSum]==0){\\n                right.erase(leftSum-rightSum);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int,int> left;  \\n        unordered_map<long long int,int> right;   \\n        \\n        long long int sum=accumulate(nums.begin(),nums.end(),0L);\\n        long long int leftSum=0;\\n        int n=nums.size();\\n        \\n        for(int i=0;i<n-1;i++){\\n            leftSum+=nums[i];\\n            long long int rightSum=sum-leftSum;\\n            long long int difference=leftSum-rightSum;\\n            right[difference]++; //storing difference count in right, since no difference exist in left\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2057576,
                "title": "java-3-approaches",
                "content": "\\n\\n**Approach 1 O(n)** \\nApproach 1 based on prefix sums and frequency map\\n\\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pref = new long[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            pref[i] = pref[i - 1] + nums[i - 1];\\n        }\\n        long[] diff = new long[n];\\n        for(int i = 0; i < n; i++) {\\n            long left = pref[i + 1];\\n            long right = pref[n] - pref[i + 1];\\n            diff[i] = left - right;\\n        }\\n        Map<Long, Integer> L = new HashMap<>();\\n        Map<Long, Integer> R = new HashMap<>();\\n        for(int i = 0; i < n - 1; i++) {\\n            R.merge(diff[i], +1, Integer::sum);\\n        }\\n        int answer = R.getOrDefault(0L, 0);\\n        for(int i = 0; i < n; i++) {            \\n            long d = (long) (k - nums[i]);\\n            int curr = L.getOrDefault(d, 0) + R.getOrDefault(-d, 0);\\n            answer = Math.max(answer, curr);                        \\n            L.merge(diff[i], +1, Integer::sum);\\n            R.merge(diff[i], -1, Integer::sum);\\n            if(R.get(diff[i]) == 0) {\\n                R.remove(diff[i]);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n**Approach 2 (n * log(n))**\\n\\nApproach 2 is similar to approach 1, but uses binary search to do same job.\\n\\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pref = new long[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            pref[i] = pref[i - 1] + nums[i - 1];\\n        }\\n        long[] diff = new long[n];\\n        for(int i = 0; i < n; i++) {\\n            long left = pref[i + 1];\\n            long right = pref[n] - pref[i + 1];\\n            diff[i] = left - right;\\n        }\\n        Map<Long, List<Integer>> M = new HashMap<>();\\n        for(int i = 0; i < n - 1; i++) {\\n            M.putIfAbsent(diff[i], new ArrayList<>());\\n            M.get(diff[i]).add(i);\\n        }\\n        int answer = M.getOrDefault(0L, Collections.emptyList()).size();\\n        for(int i = 0; i < n; i++) {            \\n            long d = (long) (k - nums[i]);\\n            int curr = 0;\\n            if(M.containsKey(-d)) {\\n                List<Integer> list = M.get(-d);\\n                int j = Collections.binarySearch(list, i);\\n                if(j < 0) {\\n                    j = -j - 1;\\n                }\\n                curr += list.size() - j;\\n            }\\n            if(M.containsKey(d)) {\\n                List<Integer> list = M.get(d);\\n                int j = Collections.binarySearch(list, i);\\n                if(j < 0) {\\n                    j = -j - 1;\\n                }\\n                curr += j;\\n            }\\n            answer = Math.max(answer, curr);\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n**Approach 3 (may TLE)**\\nJust another approach with binary search.\\nIn previous 2 approaches when we iterate, each i-th element considered as pivot.\\nHere, we count pivots to the left and right parts of the i-th element.\\n\\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pref = new long[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            pref[i] = pref[i - 1] + nums[i - 1];\\n        }\\n        Map<Long, List<Integer>> M = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            long d = k - nums[i];\\n            M.putIfAbsent(d, new ArrayList<>());            \\n            M.get(d).add(i);\\n        }        \\n        int notReplaced = 0;\\n        int replaced = 0;\\n        int[] count = new int[n];\\n        for(int i = 0; i < n - 1; i++) {            \\n            long diff = pref[i + 1] - (pref[n] - pref[i + 1]);\\n            if(diff == 0L) {\\n                notReplaced++;\\n            }\\n            int curr = 0;\\n            if(M.containsKey(diff)) {\\n                List<Integer> list = M.get(diff);\\n                int j = Collections.binarySearch(list, i + 1);\\n                if(j < 0) {\\n                    j = -j - 1;\\n                }\\n                for(int jj = j; jj < list.size(); jj++) {\\n                    count[list.get(jj)]++;\\n                    curr = Math.max(curr, count[list.get(jj)]);\\n                }\\n            }\\n            if(M.containsKey(-diff)) {\\n                List<Integer> list = M.get(-diff);\\n                int j = Collections.binarySearch(list, i + 1);\\n                if(j < 0) {\\n                    j = -j - 1;\\n                }\\n                for(int jj = 0; jj < Math.min(j, list.size()); jj++) {\\n                    count[list.get(jj)]++;\\n                    curr = Math.max(curr, count[list.get(jj)]);\\n                }\\n            }\\n            replaced = Math.max(replaced, curr);\\n        }        \\n        return Math.max(notReplaced, replaced);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pref = new long[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            pref[i] = pref[i - 1] + nums[i - 1];\\n        }\\n        long[] diff = new long[n];\\n        for(int i = 0; i < n; i++) {\\n            long left = pref[i + 1];\\n            long right = pref[n] - pref[i + 1];\\n            diff[i] = left - right;\\n        }\\n        Map<Long, Integer> L = new HashMap<>();\\n        Map<Long, Integer> R = new HashMap<>();\\n        for(int i = 0; i < n - 1; i++) {\\n            R.merge(diff[i], +1, Integer::sum);\\n        }\\n        int answer = R.getOrDefault(0L, 0);\\n        for(int i = 0; i < n; i++) {            \\n            long d = (long) (k - nums[i]);\\n            int curr = L.getOrDefault(d, 0) + R.getOrDefault(-d, 0);\\n            answer = Math.max(answer, curr);                        \\n            L.merge(diff[i], +1, Integer::sum);\\n            R.merge(diff[i], -1, Integer::sum);\\n            if(R.get(diff[i]) == 0) {\\n                R.remove(diff[i]);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pref = new long[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            pref[i] = pref[i - 1] + nums[i - 1];\\n        }\\n        long[] diff = new long[n];\\n        for(int i = 0; i < n; i++) {\\n            long left = pref[i + 1];\\n            long right = pref[n] - pref[i + 1];\\n            diff[i] = left - right;\\n        }\\n        Map<Long, List<Integer>> M = new HashMap<>();\\n        for(int i = 0; i < n - 1; i++) {\\n            M.putIfAbsent(diff[i], new ArrayList<>());\\n            M.get(diff[i]).add(i);\\n        }\\n        int answer = M.getOrDefault(0L, Collections.emptyList()).size();\\n        for(int i = 0; i < n; i++) {            \\n            long d = (long) (k - nums[i]);\\n            int curr = 0;\\n            if(M.containsKey(-d)) {\\n                List<Integer> list = M.get(-d);\\n                int j = Collections.binarySearch(list, i);\\n                if(j < 0) {\\n                    j = -j - 1;\\n                }\\n                curr += list.size() - j;\\n            }\\n            if(M.containsKey(d)) {\\n                List<Integer> list = M.get(d);\\n                int j = Collections.binarySearch(list, i);\\n                if(j < 0) {\\n                    j = -j - 1;\\n                }\\n                curr += j;\\n            }\\n            answer = Math.max(answer, curr);\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pref = new long[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            pref[i] = pref[i - 1] + nums[i - 1];\\n        }\\n        Map<Long, List<Integer>> M = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            long d = k - nums[i];\\n            M.putIfAbsent(d, new ArrayList<>());            \\n            M.get(d).add(i);\\n        }        \\n        int notReplaced = 0;\\n        int replaced = 0;\\n        int[] count = new int[n];\\n        for(int i = 0; i < n - 1; i++) {            \\n            long diff = pref[i + 1] - (pref[n] - pref[i + 1]);\\n            if(diff == 0L) {\\n                notReplaced++;\\n            }\\n            int curr = 0;\\n            if(M.containsKey(diff)) {\\n                List<Integer> list = M.get(diff);\\n                int j = Collections.binarySearch(list, i + 1);\\n                if(j < 0) {\\n                    j = -j - 1;\\n                }\\n                for(int jj = j; jj < list.size(); jj++) {\\n                    count[list.get(jj)]++;\\n                    curr = Math.max(curr, count[list.get(jj)]);\\n                }\\n            }\\n            if(M.containsKey(-diff)) {\\n                List<Integer> list = M.get(-diff);\\n                int j = Collections.binarySearch(list, i + 1);\\n                if(j < 0) {\\n                    j = -j - 1;\\n                }\\n                for(int jj = 0; jj < Math.min(j, list.size()); jj++) {\\n                    count[list.get(jj)]++;\\n                    curr = Math.max(curr, count[list.get(jj)]);\\n                }\\n            }\\n            replaced = Math.max(replaced, curr);\\n        }        \\n        return Math.max(notReplaced, replaced);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992552,
                "title": "o-n-c-solution-with-explanation",
                "content": "// Intuitively, we will compute prefix/suffix sum for each pivot [1, n).\\n    // For each pivot, we compute the difference below the two partitions divided by it.In the implementation, we will re-use the suffix-sum array to store these difference, say diffs[n].\\n    //\\n    // Iterate each number in nums[n], and change nums[i] to k, 0 <= i < n. It will cause the differece inc = k - nums[i]. let\\'s understand how it will affect the \\'diff\\' for each pivot in the diffs[n] array, see below.\\n    // These pivots will be divided into two groups, i.e., pivots on left of i and pivots on right of i (inclusive). For the pivots on left of i (pivot < i), the \\'inc\\' will be added to the  right partition divided by these pivots, then the \\'diff\\' will be changed to \\'diff - inc\\'. For pivots on the right of i (pivots >= i), the \\'inc\\' will be added to the left partition, the \\'diff\\' will be added by \\'inc\\', so the diff will be changed to \\'diff + inc\\'.\\n    // If the new difference \\'diff - inc\\' or \\'diff + inc\\' is zero (i.e, diff = inc or diff = -inc), then will have equal partitions. The problem is finally converted into counting number of \\'inc\\' for the pivots on left of i, and the number of \\'-inc\\' for pivots on right of i. We will use two unordered_map<long, int> to keep track of the diffs for pivots on left of i and on right of i respectively. \\n    //\\n    \\n```\\n    int waysToPartition(vector<int>& nums, int k) {\\n        int ret = 0, n = nums.size();\\n        vector<long> diffs(n, 0);\\n        unordered_map<long, int> ls, rs;\\n        \\n        // suffix sum\\n        for (int i = n - 1; i >= 0; i--)\\n            diffs[i] = (i == n - 1) ? nums[i] : nums[i] + diffs[i + 1];\\n    \\n        // prefix sum and diffs b/w two partitons divided by pivot i\\n        for (long i = 1, ps = nums[0]; i < n; i++) {\\n            diffs[i] = ps - diffs[i];\\n            ps = ps + nums[i];\\n            rs[diffs[i]]++; // keep track of numbers of these diffs\\n        }\\n        \\n        ret = rs[0]; // doesn\\'t change any number, we neee to search the number of \\'diff = 0\\'.\\n        \\n        // change nums[i] to k\\n        for (int i = 0; i < n; i++) {\\n            int inc = k - nums[i];\\n            ret = max(ret, (ls.count(inc) ? ls[inc] : 0) + (rs.count(-inc) ? rs[-inc] : 0));\\n            if (i == n - 1)\\n                break;\\n            ls[diffs[i + 1]]++;\\n            rs[diffs[i + 1]]--;\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "// Intuitively, we will compute prefix/suffix sum for each pivot [1, n).\\n    // For each pivot, we compute the difference below the two partitions divided by it.In the implementation, we will re-use the suffix-sum array to store these difference, say diffs[n].\\n    //\\n    // Iterate each number in nums[n], and change nums[i] to k, 0 <= i < n. It will cause the differece inc = k - nums[i]. let\\'s understand how it will affect the \\'diff\\' for each pivot in the diffs[n] array, see below.\\n    // These pivots will be divided into two groups, i.e., pivots on left of i and pivots on right of i (inclusive). For the pivots on left of i (pivot < i), the \\'inc\\' will be added to the  right partition divided by these pivots, then the \\'diff\\' will be changed to \\'diff - inc\\'. For pivots on the right of i (pivots >= i), the \\'inc\\' will be added to the left partition, the \\'diff\\' will be added by \\'inc\\', so the diff will be changed to \\'diff + inc\\'.\\n    // If the new difference \\'diff - inc\\' or \\'diff + inc\\' is zero (i.e, diff = inc or diff = -inc), then will have equal partitions. The problem is finally converted into counting number of \\'inc\\' for the pivots on left of i, and the number of \\'-inc\\' for pivots on right of i. We will use two unordered_map<long, int> to keep track of the diffs for pivots on left of i and on right of i respectively. \\n    //\\n    \\n```\\n    int waysToPartition(vector<int>& nums, int k) {\\n        int ret = 0, n = nums.size();\\n        vector<long> diffs(n, 0);\\n        unordered_map<long, int> ls, rs;\\n        \\n        // suffix sum\\n        for (int i = n - 1; i >= 0; i--)\\n            diffs[i] = (i == n - 1) ? nums[i] : nums[i] + diffs[i + 1];\\n    \\n        // prefix sum and diffs b/w two partitons divided by pivot i\\n        for (long i = 1, ps = nums[0]; i < n; i++) {\\n            diffs[i] = ps - diffs[i];\\n            ps = ps + nums[i];\\n            rs[diffs[i]]++; // keep track of numbers of these diffs\\n        }\\n        \\n        ret = rs[0]; // doesn\\'t change any number, we neee to search the number of \\'diff = 0\\'.\\n        \\n        // change nums[i] to k\\n        for (int i = 0; i < n; i++) {\\n            int inc = k - nums[i];\\n            ret = max(ret, (ls.count(inc) ? ls[inc] : 0) + (rs.count(-inc) ? rs[-inc] : 0));\\n            if (i == n - 1)\\n                break;\\n            ls[diffs[i + 1]]++;\\n            rs[diffs[i + 1]]--;\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1705923,
                "title": "c-prefix-sum-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n\\n        vector<long long> pref(nums.size());\\n        unordered_map<long long, int> seg_diff; //total seg diff count record\\n        vector<int> count_per_position(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();++i){\\n            pref[i] = (i>0?pref[i-1]:0) + nums[i];\\n        }\\n        \\n        //compute diff of sums of right versus left partitions\\n        for(int pivot=1;pivot<nums.size();++pivot){       \\n            long long sum_left = pref[pivot-1];\\n            long long sum_righ = pref[nums.size()-1] - sum_left;\\n            seg_diff[sum_righ - sum_left]++; // extra amount right sum has compared to left sum\\n        }                \\n\\n        \\n        //consider not changing number\\n        int ans = 0;\\n        {\\n            for(int pivot=1;pivot<nums.size();++pivot){\\n                long long sum_left = pref[pivot-1];\\n                long long sum_righ = pref[nums.size()-1] - sum_left;\\n                ans += (sum_left - sum_righ==0)? 1 : 0;\\n            }\\n        }\\n        //consider changing a number in the left partition\\n        {\\n            unordered_map<long long, int> seg_diff_seen;\\n            for(int i=0;i<nums.size()-1;++i){\\n                \\n                long long num_diff = k - nums[i]; //current delta\\n                \\n                //get number of segment_diffs with current position in left partition that has num_diff in value \\n                count_per_position[i] = seg_diff[num_diff] - seg_diff_seen[num_diff];\\n                \\n                //segment difference\\n                long long sum_left = pref[i];\\n                long long sum_righ = pref[nums.size()-1] - sum_left;\\n                long long d = sum_righ - sum_left;\\n                seg_diff_seen[d]++;\\n            }\\n        }\\n        //consider changing a number in the right partition\\n        {\\n            unordered_map<long long, int> seg_diff_seen;\\n            for(int i=nums.size()-1;i>=1;--i){\\n                \\n                long long num_diff = k - nums[i]; //current delta\\n                \\n                //get number of segment_diffs with current position in right partition that has -num_diff in value \\n                count_per_position[i] += seg_diff[-num_diff] - seg_diff_seen[-num_diff];\\n                \\n                //segment difference\\n                long long sum_left = pref[i-1];\\n                long long sum_righ = pref[nums.size()-1] - sum_left;\\n                long long d = sum_righ - sum_left;\\n                seg_diff_seen[d]++;\\n            }\\n        }\\n        \\n        for(auto i: count_per_position){\\n            ans = max(ans, i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n\\n        vector<long long> pref(nums.size());\\n        unordered_map<long long, int> seg_diff; //total seg diff count record\\n        vector<int> count_per_position(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();++i){\\n            pref[i] = (i>0?pref[i-1]:0) + nums[i];\\n        }\\n        \\n        //compute diff of sums of right versus left partitions\\n        for(int pivot=1;pivot<nums.size();++pivot){       \\n            long long sum_left = pref[pivot-1];\\n            long long sum_righ = pref[nums.size()-1] - sum_left;\\n            seg_diff[sum_righ - sum_left]++; // extra amount right sum has compared to left sum\\n        }                \\n\\n        \\n        //consider not changing number\\n        int ans = 0;\\n        {\\n            for(int pivot=1;pivot<nums.size();++pivot){\\n                long long sum_left = pref[pivot-1];\\n                long long sum_righ = pref[nums.size()-1] - sum_left;\\n                ans += (sum_left - sum_righ==0)? 1 : 0;\\n            }\\n        }\\n        //consider changing a number in the left partition\\n        {\\n            unordered_map<long long, int> seg_diff_seen;\\n            for(int i=0;i<nums.size()-1;++i){\\n                \\n                long long num_diff = k - nums[i]; //current delta\\n                \\n                //get number of segment_diffs with current position in left partition that has num_diff in value \\n                count_per_position[i] = seg_diff[num_diff] - seg_diff_seen[num_diff];\\n                \\n                //segment difference\\n                long long sum_left = pref[i];\\n                long long sum_righ = pref[nums.size()-1] - sum_left;\\n                long long d = sum_righ - sum_left;\\n                seg_diff_seen[d]++;\\n            }\\n        }\\n        //consider changing a number in the right partition\\n        {\\n            unordered_map<long long, int> seg_diff_seen;\\n            for(int i=nums.size()-1;i>=1;--i){\\n                \\n                long long num_diff = k - nums[i]; //current delta\\n                \\n                //get number of segment_diffs with current position in right partition that has -num_diff in value \\n                count_per_position[i] += seg_diff[-num_diff] - seg_diff_seen[-num_diff];\\n                \\n                //segment difference\\n                long long sum_left = pref[i-1];\\n                long long sum_righ = pref[nums.size()-1] - sum_left;\\n                long long d = sum_righ - sum_left;\\n                seg_diff_seen[d]++;\\n            }\\n        }\\n        \\n        for(auto i: count_per_position){\\n            ans = max(ans, i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520626,
                "title": "noob-s-explanation-java",
                "content": "So the basic approach is to check when no number is changed \\nthat is basic :- just calculate two arrays \"prefix[i]\" and \"suffix[i]\"\\nprefix[i] = sum of elements from 0th index to \"i\"th index\\nsuffix[i] = sum of elements from index (length-1) to index \"i\"\\nNow there will be two cases :- \\n\\tCase 1 : when no element is changed \\n\\t\\t\\t\\t\\t\\t\\t\\tsimple just find count of all the  indexes where preix[i] == suffix[i+1]\\n\\t\\t\\t\\t\\t\\t\\t\\tand find there count\\n\\t\\tCase 2 : here problem becomes interesting \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnow let\\'s suppose you wanted to change an element at index \"i\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tto the given value \"k\". How this change can help in getting more partition ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tso there will be some pivots at index \"j\" where j >= i such that \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprefix[j] - suffix[j] == -(k - nums[i])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\twhy (k - nums[i]) because if you replace element at index \"i\" with value k \\n\\t\\t\\t\\t\\t\\t\\t\\t\\tit will becomes (k - nums[i])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor all above pivots you can increase prefix[j] value by substituting element at ith index\\n                                    with k because as it will only increase value of the prefix[j] not of the suffix\\n                                    (So keep count of all the diff on the right hand side of ith index)\\n                                    \\n                                    now coming to the second part where j < i we can increase the value of sufix and not prefix \\n                                    by susbstituting value at index ith so we will find all the values where \\n                                    prefix[j] - suffix[j+1] == (k - nums[i])\\n                                    (so here we will need count of such value for the left side of index i)\\n                                    \\n                                    So finally we will start from index 0 (considering of replace value here) and at that \\n                                    position we need all the diff on right hand side as there is no left \\n                                    that gives the intution that we need all the diffs on right side intially \\n                                    then as we proceed one index furthur we need to remove diff of this from right hand side count \\n                                    and add this diff to left hand side count (because for right hand side we only need diff where j >= i)\\n                                    \\n                                    So we will need two hash map \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nCode\\n\\n```\\nclass Solution {\\n    \\n    public int waysToPartition(int[] nums, int k) {\\n        int length = nums.length;\\n        HashMap<Long, Long> rightDiff = new HashMap<Long, Long>();\\n        HashMap<Long, Long> leftDiff = new HashMap<Long, Long>();\\n        Long []prefix = new Long[length];\\n        Long []suffix = new Long[length];\\n        prefix[0] = (long)nums[0];\\n        suffix[length-1] = (long)nums[length-1];\\n        for(int curIndex = 1; curIndex < (length); curIndex++){\\n            prefix[curIndex] = (long)nums[curIndex] + prefix[curIndex-1];\\n            suffix[length-1-curIndex] = (long)nums[length - 1 - curIndex] + suffix[length - curIndex];\\n        }\\n        \\n        long max = 0l, diff = 0l, curCount  = 0l;\\n        \\n        for(int curIndex = 0; curIndex < (length-1); curIndex++){\\n            diff = prefix[curIndex] - suffix[curIndex + 1];\\n            rightDiff.put(diff, rightDiff.getOrDefault(diff, 0l) + 1l);\\n        }\\n        max = rightDiff.getOrDefault(0l, 0l);\\n        for(int curIndex = 0; curIndex < (length); curIndex++){\\n            curCount = 0;\\n            diff = k - nums[curIndex];\\n            curCount = rightDiff.getOrDefault(-1l * diff, 0l);\\n            curCount += leftDiff.getOrDefault(diff, 0l);\\n            max = Math.max(max, curCount);\\n            if(curIndex < (length-1)){\\n                diff = prefix[curIndex] - suffix[curIndex + 1];\\n                leftDiff.put(diff, leftDiff.getOrDefault(diff, 0l) + 1l);\\n                 if(rightDiff.getOrDefault(diff, 0l) > 0l){\\n                     rightDiff.put(diff, rightDiff.getOrDefault(diff, 0l) - 1l);\\n                 }\\n            }\\n        }\\n        return (int)max;\\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int waysToPartition(int[] nums, int k) {\\n        int length = nums.length;\\n        HashMap<Long, Long> rightDiff = new HashMap<Long, Long>();\\n        HashMap<Long, Long> leftDiff = new HashMap<Long, Long>();\\n        Long []prefix = new Long[length];\\n        Long []suffix = new Long[length];\\n        prefix[0] = (long)nums[0];\\n        suffix[length-1] = (long)nums[length-1];\\n        for(int curIndex = 1; curIndex < (length); curIndex++){\\n            prefix[curIndex] = (long)nums[curIndex] + prefix[curIndex-1];\\n            suffix[length-1-curIndex] = (long)nums[length - 1 - curIndex] + suffix[length - curIndex];\\n        }\\n        \\n        long max = 0l, diff = 0l, curCount  = 0l;\\n        \\n        for(int curIndex = 0; curIndex < (length-1); curIndex++){\\n            diff = prefix[curIndex] - suffix[curIndex + 1];\\n            rightDiff.put(diff, rightDiff.getOrDefault(diff, 0l) + 1l);\\n        }\\n        max = rightDiff.getOrDefault(0l, 0l);\\n        for(int curIndex = 0; curIndex < (length); curIndex++){\\n            curCount = 0;\\n            diff = k - nums[curIndex];\\n            curCount = rightDiff.getOrDefault(-1l * diff, 0l);\\n            curCount += leftDiff.getOrDefault(diff, 0l);\\n            max = Math.max(max, curCount);\\n            if(curIndex < (length-1)){\\n                diff = prefix[curIndex] - suffix[curIndex + 1];\\n                leftDiff.put(diff, leftDiff.getOrDefault(diff, 0l) + 1l);\\n                 if(rightDiff.getOrDefault(diff, 0l) > 0l){\\n                     rightDiff.put(diff, rightDiff.getOrDefault(diff, 0l) - 1l);\\n                 }\\n            }\\n        }\\n        return (int)max;\\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501226,
                "title": "python-3-two-counters",
                "content": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        tot = sum(nums)\\n        acc = list(accumulate(nums))[:-1]\\n        cnt = Counter(acc)\\n        ans = 0\\n        if tot % 2 == 0:\\n            ans += cnt[tot // 2]\\n\\n        n = len(nums)\\n        left_cnt = Counter()\\n        for i in range(n):\\n            new_tot = tot - nums[i] + k\\n            if new_tot % 2 == 0 and nums[i] != k:\\n                ans = max(ans, cnt[new_tot // 2 - k + nums[i]] + left_cnt[new_tot // 2])\\n            if i < n - 1:\\n                left_cnt[acc[i]] += 1\\n                cnt[acc[i]] -= 1\\n\\n        \\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        tot = sum(nums)\\n        acc = list(accumulate(nums))[:-1]\\n        cnt = Counter(acc)\\n        ans = 0\\n        if tot % 2 == 0:\\n            ans += cnt[tot // 2]\\n\\n        n = len(nums)\\n        left_cnt = Counter()\\n        for i in range(n):\\n            new_tot = tot - nums[i] + k\\n            if new_tot % 2 == 0 and nums[i] != k:\\n                ans = max(ans, cnt[new_tot // 2 - k + nums[i]] + left_cnt[new_tot // 2])\\n            if i < n - 1:\\n                left_cnt[acc[i]] += 1\\n                cnt[acc[i]] -= 1\\n\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1500382,
                "title": "c-o-n-prefix-sum",
                "content": "Let us consider n = length of the array\\n**Possibilities**\\n1. Leave the array unchanged.\\n2. Change any one element to k. (n ways to do that)\\n\\nSo overall, we can create n + 1 Arrays\\n\\n**Brute Force O(n^2)**\\nWe can Calculate the answer for all the n + 1 Possible Arrays by linearly traversing all the n+1 arrays.\\nAnd this will take O(n) Time for each array  resulting in quadratic time complexity overall.\\n\\n**Optimizing the Brute Force**\\n1. Calculate answer for possibility 1(Possiblity 1 is to keep the array unchanged) by traversing the array once.\\n2. Calculate the answer of all n + 1 possible arrays(Possibility 2 as discussed ablve) in one traversal. by using Prefix Sum(Optimization)\\n\\nLet us consider a particilar element nums[i]. and `k - nums[i] = x`\\n```\\nGiving RightUpdate means Incrementing Right counterpart\\'s (subarray) sum by x.\\nGiving LeftUpdate means Incrementing Left counterpart\\'s (subarray) sum by x.\\n```\\nNow, for each `i(1 <= i < n)` we want to calculate the number of ways in which we can create partitions if we change nums[i] to k.\\nAnd for that, we need 2 variables.\\n1. Number of subarrays ending before i and are heavier then their right counterpart. i.e. having R = L - x (Left part is heavy & require RigtUpdate), because for all such arrays, there would be an increase of x in their right counterpart(if we change nums[i] to k), eventually balancing the left and right part. (L = R).\\n2. Number of subarrays starting after i and are heavier then their left counterpart. i.e. having L = R - x (Right part is heavy & hence require LeftUpdate), because for all such arrays, there would be an increase of x in their left counterpart(if we change nums[i] to k), eventually balancing the left and right part. (L = R)\\n\\n**Implementation**\\nLet\\'s create 2 maps(Creating A 4 * 10^5 length array wolud also work, with an offset of 2 * 10^5 as `-10^5 <= k, nums[i] <= 10^5`)\\n`RightUpdate[y]` -> Stores the number of subarrays which end before i and are heavier than their right counterpart(subarray) by `y`.\\n`LeftUpdate[y]` -> Stores the number of subarrays which start from/after i and are heavier than their left counterpart(subarray) by `y`. Such subarrays require a LeftUpdate in order to increase the Left subarray\\'s sum by y and `eventually making left Subarray sum equal to the right subarray sum`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, long long int k) {\\n        map<long long int, long long int> leftUpdate, rightUpdate;\\n        long long int right = accumulate(nums.begin(), nums.end(), 0ll), left = 0, ans = 0;\\n        \\n        for (long long int i = 0; i < nums.size() - 1; ++i) {\\n            left += nums[i];\\n            right -= nums[i];\\n            ans += (left == right);\\n            long long int diff = right - left;\\n            ++leftUpdate[diff];\\n        }\\n\\n        right = accumulate(nums.begin(), nums.end(), 0ll), left = 0;\\n        \\n        for (long long int i = 0; i < nums.size(); ++i) {\\n            left += nums[i];\\n            right -= nums[i];\\n            long long int delta = k - nums[i];\\n            ans = max(ans, rightUpdate[delta] + leftUpdate[delta]);\\n            --leftUpdate[right - left];\\n            ++rightUpdate[left - right];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nGiving RightUpdate means Incrementing Right counterpart\\'s (subarray) sum by x.\\nGiving LeftUpdate means Incrementing Left counterpart\\'s (subarray) sum by x.\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, long long int k) {\\n        map<long long int, long long int> leftUpdate, rightUpdate;\\n        long long int right = accumulate(nums.begin(), nums.end(), 0ll), left = 0, ans = 0;\\n        \\n        for (long long int i = 0; i < nums.size() - 1; ++i) {\\n            left += nums[i];\\n            right -= nums[i];\\n            ans += (left == right);\\n            long long int diff = right - left;\\n            ++leftUpdate[diff];\\n        }\\n\\n        right = accumulate(nums.begin(), nums.end(), 0ll), left = 0;\\n        \\n        for (long long int i = 0; i < nums.size(); ++i) {\\n            left += nums[i];\\n            right -= nums[i];\\n            long long int delta = k - nums[i];\\n            ans = max(ans, rightUpdate[delta] + leftUpdate[delta]);\\n            --leftUpdate[right - left];\\n            ++rightUpdate[left - right];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499159,
                "title": "java-two-solution-treemap-two-hashmap",
                "content": "```\\nclass Solution {\\n    public static int waysToPartition(int[] nums, int k) {\\n        long[] left = new long[nums.length];\\n        long[] right = new long[nums.length];\\n        left[0] = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            left[i] = left[i - 1] + nums[i];\\n        }\\n        right[nums.length - 1] = nums[nums.length - 1];\\n        for(int i = nums.length - 2; i >= 0 ; i --){\\n            right[i] = right[i + 1] + nums[i];\\n        }\\n        long[] minus = new long[nums.length - 1];\\n        int cnt = 0;\\n        Map<Long, TreeMap<Integer, Integer>> map = new HashMap<>();\\n        for(int i = 0; i < nums.length - 1; i++){\\n            minus[i] = left[i] - right[i + 1];\\n            if(minus[i] == 0){\\n                cnt++;\\n            }\\n            if(minus[i] >= -200000 && minus[i] <= 200000){\\n                if(map.containsKey(minus[i])){\\n                    TreeMap<Integer, Integer> tm = map.get(minus[i]);\\n                    Integer pre = tm.lastEntry().getValue();\\n                    tm.put(i, pre + 1);\\n                }else{\\n                    TreeMap<Integer, Integer> tm = new TreeMap<>();\\n                    tm.put(i, 1);\\n                    map.put(minus[i], tm);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            long l = nums[i] - k;\\n            long r = k - nums[i];\\n            int cur = 0;\\n            if(map.containsKey(l)){\\n                TreeMap<Integer, Integer> tm = map.get(l);\\n                cur += tm.lastEntry().getValue() - (tm.lowerEntry(i) == null ? 0 : tm.lowerEntry(i).getValue());\\n            }\\n            if(map.containsKey(r)){\\n                TreeMap<Integer, Integer> tm = map.get(r);\\n                cur += (tm.lowerEntry(i) == null ? 0 : tm.lowerEntry(i).getValue());\\n            }\\n            cnt = Math.max(cnt, cur);\\n        }\\n        return cnt;\\n    }\\n}\\n```\\nTime complexity: In the worst case, time complexity will be O(nlogn)\\n\\n\\nOptimize: There\\'s no need to use treeMap, we can use two hashmap instead\\n```\\nclass Solution {\\n    public static int waysToPartition(int[] nums, int k) {\\n        long[] left = new long[nums.length];\\n        long[] right = new long[nums.length];\\n        left[0] = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            left[i] = left[i - 1] + nums[i];\\n        }\\n        right[nums.length - 1] = nums[nums.length - 1];\\n        for(int i = nums.length - 2; i >= 0 ; i --){\\n            right[i] = right[i + 1] + nums[i];\\n        }\\n        long[] minus = new long[nums.length - 1];\\n        int cnt = 0;\\n        Map<Long, Integer> l = new HashMap<>();\\n        Map<Long, Integer> r = new HashMap<>();\\n        for(int i = 0; i < nums.length - 1; i++){\\n            minus[i] = left[i] - right[i + 1];\\n            if(minus[i] == 0){\\n                cnt++;\\n            }\\n            if(minus[i] >= -200000 && minus[i] <= 200000){\\n                l.put(minus[i], l.getOrDefault(minus[i], 0) + 1);\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            long lm = nums[i] - k;\\n            long rm = k - nums[i];\\n            int cur = 0;\\n            if(l.get(lm) != null){\\n                cur += l.get(lm);\\n            }\\n            if(r.get(rm) != null){\\n                cur += r.get(rm);\\n            }\\n            if(i != nums.length - 1){\\n                l.put(minus[i], l.getOrDefault(minus[i], 0) - 1);\\n                l.put(minus[i], r.getOrDefault(minus[i], 0) + 1);\\n            }\\n            cnt = Math.max(cnt, cur);\\n        }\\n        return cnt;\\n    }\\n}\\n```\\nTime complexity: O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int waysToPartition(int[] nums, int k) {\\n        long[] left = new long[nums.length];\\n        long[] right = new long[nums.length];\\n        left[0] = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            left[i] = left[i - 1] + nums[i];\\n        }\\n        right[nums.length - 1] = nums[nums.length - 1];\\n        for(int i = nums.length - 2; i >= 0 ; i --){\\n            right[i] = right[i + 1] + nums[i];\\n        }\\n        long[] minus = new long[nums.length - 1];\\n        int cnt = 0;\\n        Map<Long, TreeMap<Integer, Integer>> map = new HashMap<>();\\n        for(int i = 0; i < nums.length - 1; i++){\\n            minus[i] = left[i] - right[i + 1];\\n            if(minus[i] == 0){\\n                cnt++;\\n            }\\n            if(minus[i] >= -200000 && minus[i] <= 200000){\\n                if(map.containsKey(minus[i])){\\n                    TreeMap<Integer, Integer> tm = map.get(minus[i]);\\n                    Integer pre = tm.lastEntry().getValue();\\n                    tm.put(i, pre + 1);\\n                }else{\\n                    TreeMap<Integer, Integer> tm = new TreeMap<>();\\n                    tm.put(i, 1);\\n                    map.put(minus[i], tm);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            long l = nums[i] - k;\\n            long r = k - nums[i];\\n            int cur = 0;\\n            if(map.containsKey(l)){\\n                TreeMap<Integer, Integer> tm = map.get(l);\\n                cur += tm.lastEntry().getValue() - (tm.lowerEntry(i) == null ? 0 : tm.lowerEntry(i).getValue());\\n            }\\n            if(map.containsKey(r)){\\n                TreeMap<Integer, Integer> tm = map.get(r);\\n                cur += (tm.lowerEntry(i) == null ? 0 : tm.lowerEntry(i).getValue());\\n            }\\n            cnt = Math.max(cnt, cur);\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public static int waysToPartition(int[] nums, int k) {\\n        long[] left = new long[nums.length];\\n        long[] right = new long[nums.length];\\n        left[0] = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            left[i] = left[i - 1] + nums[i];\\n        }\\n        right[nums.length - 1] = nums[nums.length - 1];\\n        for(int i = nums.length - 2; i >= 0 ; i --){\\n            right[i] = right[i + 1] + nums[i];\\n        }\\n        long[] minus = new long[nums.length - 1];\\n        int cnt = 0;\\n        Map<Long, Integer> l = new HashMap<>();\\n        Map<Long, Integer> r = new HashMap<>();\\n        for(int i = 0; i < nums.length - 1; i++){\\n            minus[i] = left[i] - right[i + 1];\\n            if(minus[i] == 0){\\n                cnt++;\\n            }\\n            if(minus[i] >= -200000 && minus[i] <= 200000){\\n                l.put(minus[i], l.getOrDefault(minus[i], 0) + 1);\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            long lm = nums[i] - k;\\n            long rm = k - nums[i];\\n            int cur = 0;\\n            if(l.get(lm) != null){\\n                cur += l.get(lm);\\n            }\\n            if(r.get(rm) != null){\\n                cur += r.get(rm);\\n            }\\n            if(i != nums.length - 1){\\n                l.put(minus[i], l.getOrDefault(minus[i], 0) - 1);\\n                l.put(minus[i], r.getOrDefault(minus[i], 0) + 1);\\n            }\\n            cnt = Math.max(cnt, cur);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499154,
                "title": "c-2025-maximum-number-of-ways-to-partition-an-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        vector<long> prefix(1); \\n        unordered_map<long, vector<int>> mp; \\n        for (int i = 0; i < nums.size(); ++i) {\\n            prefix.push_back(prefix[i] + nums[i]); \\n            if (i < nums.size()-1) mp[prefix[i+1]].push_back(i); \\n        }\\n        \\n        int ans = 0; \\n        long total = prefix.back(); \\n        if (total % 2 == 0) ans = mp[total/2].size(); \\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            int diff = k - nums[i], val = 0; \\n            long target = total + diff; \\n            if (target % 2 == 0) {\\n                target /= 2; \\n                val += lower_bound(mp[target].begin(), mp[target].end(), i) - mp[target].begin(); \\n                val += mp[target-diff].size() - (lower_bound(mp[target-diff].begin(), mp[target-diff].end(), i) - mp[target-diff].begin()); \\n            }\\n            ans = max(ans, val); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        vector<long> prefix(1); \\n        unordered_map<long, vector<int>> mp; \\n        for (int i = 0; i < nums.size(); ++i) {\\n            prefix.push_back(prefix[i] + nums[i]); \\n            if (i < nums.size()-1) mp[prefix[i+1]].push_back(i); \\n        }\\n        \\n        int ans = 0; \\n        long total = prefix.back(); \\n        if (total % 2 == 0) ans = mp[total/2].size(); \\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            int diff = k - nums[i], val = 0; \\n            long target = total + diff; \\n            if (target % 2 == 0) {\\n                target /= 2; \\n                val += lower_bound(mp[target].begin(), mp[target].end(), i) - mp[target].begin(); \\n                val += mp[target-diff].size() - (lower_bound(mp[target-diff].begin(), mp[target-diff].end(), i) - mp[target-diff].begin()); \\n            }\\n            ans = max(ans, val); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060306,
                "title": "clean-easy-prefix-hashmap-o-n",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& v, ll k) {\\n        ll n=v.size();\\n        ll sum=accumulate(v.begin(),v.end(),0ll);\\n        int res=0;\\n        ll pref=0;\\n        for(int x=0;x<n-1;x++){\\n            pref+=v[x];\\n            res+=(2*pref==sum);\\n        }\\n        auto calc=[n,sum,k](vector<int> &v){\\n            vector<int> res(n);\\n            unordered_map<ll,int> cnt;\\n            ll pref=v[0];\\n            cnt[2*pref-sum]++;\\n            for(int x=1;x<n;x++){\\n                res[x]=cnt[-(v[x]-k)];\\n                pref+=v[x];\\n                cnt[2*pref-sum]++;\\n            }\\n            return res;\\n        };\\n        vector<int> a1=calc(v);\\n        reverse(v.begin(),v.end());\\n        vector<int> a2=calc(v);\\n        reverse(a2.begin(),a2.end());\\n        for(int x=0;x<n;x++){\\n            res=max(a1[x]+a2[x],res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& v, ll k) {\\n        ll n=v.size();\\n        ll sum=accumulate(v.begin(),v.end(),0ll);\\n        int res=0;\\n        ll pref=0;\\n        for(int x=0;x<n-1;x++){\\n            pref+=v[x];\\n            res+=(2*pref==sum);\\n        }\\n        auto calc=[n,sum,k](vector<int> &v){\\n            vector<int> res(n);\\n            unordered_map<ll,int> cnt;\\n            ll pref=v[0];\\n            cnt[2*pref-sum]++;\\n            for(int x=1;x<n;x++){\\n                res[x]=cnt[-(v[x]-k)];\\n                pref+=v[x];\\n                cnt[2*pref-sum]++;\\n            }\\n            return res;\\n        };\\n        vector<int> a1=calc(v);\\n        reverse(v.begin(),v.end());\\n        vector<int> a2=calc(v);\\n        reverse(a2.begin(),a2.end());\\n        for(int x=0;x<n;x++){\\n            res=max(a1[x]+a2[x],res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935059,
                "title": "python-o-n-left-right-difference-counter-easy-solution",
                "content": "# Intuition\\nInstead of changing each item to k and find its partition, we can iteration over the arr and check possible operation for each partition point to make `leftsum` = `rightsum`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe partition the array into 2 parts: left_arr and right_arr. The left_arr starts with only nums[0], right_arr contains the remaining. We then iterate over nums add adding each item from right_arr to left_arr.\\n\\nFor each partition, we can calculate the `diff` between `leftsum` and `rightsum`. \\n\\nIf `diff == 0`, it means at current pivot, there are no need to change anything, we increment `unchanged` by 1. In the end, the `unchanged` reprents **number of ways to partition the array without any change**.\\n\\nIf `diff != 0`, it means some items need to be changed. We keep track the indices `ind` on the left that can fulfill the `diff`, i.e. `nums[ind] - k == diff`. On the right, the samething but pay attention to the sign, i.e.` nums[ind] - k == - diff`. We increment the counter of at these indices by 1. It means, at current partition, we can satisfy the condition by changing values at these indces to `k`.\\n\\nIn the end, we can get the maximum counter `t` for each index. This represents there are `t` different partitions when this index changes to `k`. To get final result, also compare with `unchanged`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def waysToPartition(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dright = defaultdict(set) \\n        dleft = defaultdict(set)\\n        rightsum = leftsum = 0 \\n        for i, v in enumerate(nums):\\n            rightsum += v\\n            dright[v - k].add(i) # keep track of the indices that have the value v - k\\n        \\n        unchanged = 0\\n        record = [0] * len(nums)\\n        for i in range(len(nums)-1):\\n            leftsum += nums[i] \\n            rightsum -= nums[i] # move the value from right to left\\n            dleft[nums[i] - k].add(i)\\n            dright[nums[i] - k].remove(i) # also update the two dictionaries\\n            \\n            if leftsum == rightsum:\\n                unchanged += 1 # no change to the array\\n            else:\\n                diff = leftsum - rightsum\\n                for ind in dleft[diff]:\\n                    record[ind] += 1 # all the indices at the left array can satisfy the condition by changing to k, increment its record by 1\\n                for ind in dright[-diff]:\\n                    record[ind] += 1 # all the indices at the right array can satisfy the condition by changing to k, increment its record by 1\\n                \\n        return max(max(record), unchanged)\\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def waysToPartition(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        dright = defaultdict(set) \\n        dleft = defaultdict(set)\\n        rightsum = leftsum = 0 \\n        for i, v in enumerate(nums):\\n            rightsum += v\\n            dright[v - k].add(i) # keep track of the indices that have the value v - k\\n        \\n        unchanged = 0\\n        record = [0] * len(nums)\\n        for i in range(len(nums)-1):\\n            leftsum += nums[i] \\n            rightsum -= nums[i] # move the value from right to left\\n            dleft[nums[i] - k].add(i)\\n            dright[nums[i] - k].remove(i) # also update the two dictionaries\\n            \\n            if leftsum == rightsum:\\n                unchanged += 1 # no change to the array\\n            else:\\n                diff = leftsum - rightsum\\n                for ind in dleft[diff]:\\n                    record[ind] += 1 # all the indices at the left array can satisfy the condition by changing to k, increment its record by 1\\n                for ind in dright[-diff]:\\n                    record[ind] += 1 # all the indices at the right array can satisfy the condition by changing to k, increment its record by 1\\n                \\n        return max(max(record), unchanged)\\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900889,
                "title": "rust-prefix-sum-binary-search-beats-100-space-time",
                "content": "# Intuition\\n\\nJust look at the hints...\\n\\nTry finding the count of index `i` where **prefix and postfix sums** at `i` differs by `vec[i] - k`.\\n\\n# Approach\\n\\nDur to complexity constraints, we need to be able to search across possible differences between prefix and postfix sums, *fast*. ~~HashM~~ Sorting the difference array and perform **binary search** on it is good enough.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```rust\\npub fn to_pref_sum(vec: &Vec<i64>) -> Vec<i64> {\\n    let mut ret = Vec::with_capacity(vec.len() + 1);\\n\\n    let mut pref_sum = i64::default();\\n    ret.push(pref_sum);\\n    for &e in vec {\\n        pref_sum += e;\\n        ret.push(pref_sum);\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn ways_to_partition(vec: Vec<i32>, k: i32) -> i32 {\\n        let vec = vec.into_iter()\\n            .map(|e| e as i64)\\n            .collect::<Vec<_>>();\\n        let k = k as i64;\\n\\n        let vec_sum = vec.iter().sum::<i64>();\\n        let pref_sum = to_pref_sum(&vec);\\n        let mut diff_vec = pref_sum.into_iter()\\n            .skip(1)\\n            .take(vec.len() - 1)\\n            .enumerate()\\n            .map(|(i, e0)| (vec_sum - e0 * 2, i))\\n            .collect::<Vec<_>>();\\n        diff_vec.sort_unstable();\\n\\n        let ptr_0 = diff_vec.partition_point(\\n            |&(diff, _)| diff < 0\\n        );\\n        let ptr_1 = diff_vec.partition_point(\\n            |&(diff, _)| diff <= 0\\n        );\\n\\n        let mut ret = (ptr_1 - ptr_0);\\n\\n        for (i, e) in vec.into_iter().enumerate() {\\n            let (diff_0, diff_1) = (k - e, e - k);\\n            \\n            let mut _ret = usize::MIN;\\n\\n            let ptr_0 = diff_vec.partition_point(\\n                |&(diff, i_next)| (diff < diff_0)\\n                    || ((diff == diff_0) && (i_next < i))\\n            );\\n            let ptr_1 = diff_vec.partition_point(\\n                |&(diff, i_next)| diff <= diff_0\\n            );\\n            _ret += (ptr_1 - ptr_0);\\n\\n            let ptr_0 = diff_vec.partition_point(\\n                |&(diff, i_next)| diff < diff_1\\n            );\\n            let ptr_1 = diff_vec.partition_point(\\n                |&(diff, i_next)| (diff < diff_1)\\n                    || ((diff == diff_1) && (i_next < i))\\n            );\\n            _ret += (ptr_1 - ptr_0);\\n\\n            ret = ret.max(_ret);\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```rust\\npub fn to_pref_sum(vec: &Vec<i64>) -> Vec<i64> {\\n    let mut ret = Vec::with_capacity(vec.len() + 1);\\n\\n    let mut pref_sum = i64::default();\\n    ret.push(pref_sum);\\n    for &e in vec {\\n        pref_sum += e;\\n        ret.push(pref_sum);\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn ways_to_partition(vec: Vec<i32>, k: i32) -> i32 {\\n        let vec = vec.into_iter()\\n            .map(|e| e as i64)\\n            .collect::<Vec<_>>();\\n        let k = k as i64;\\n\\n        let vec_sum = vec.iter().sum::<i64>();\\n        let pref_sum = to_pref_sum(&vec);\\n        let mut diff_vec = pref_sum.into_iter()\\n            .skip(1)\\n            .take(vec.len() - 1)\\n            .enumerate()\\n            .map(|(i, e0)| (vec_sum - e0 * 2, i))\\n            .collect::<Vec<_>>();\\n        diff_vec.sort_unstable();\\n\\n        let ptr_0 = diff_vec.partition_point(\\n            |&(diff, _)| diff < 0\\n        );\\n        let ptr_1 = diff_vec.partition_point(\\n            |&(diff, _)| diff <= 0\\n        );\\n\\n        let mut ret = (ptr_1 - ptr_0);\\n\\n        for (i, e) in vec.into_iter().enumerate() {\\n            let (diff_0, diff_1) = (k - e, e - k);\\n            \\n            let mut _ret = usize::MIN;\\n\\n            let ptr_0 = diff_vec.partition_point(\\n                |&(diff, i_next)| (diff < diff_0)\\n                    || ((diff == diff_0) && (i_next < i))\\n            );\\n            let ptr_1 = diff_vec.partition_point(\\n                |&(diff, i_next)| diff <= diff_0\\n            );\\n            _ret += (ptr_1 - ptr_0);\\n\\n            let ptr_0 = diff_vec.partition_point(\\n                |&(diff, i_next)| diff < diff_1\\n            );\\n            let ptr_1 = diff_vec.partition_point(\\n                |&(diff, i_next)| (diff < diff_1)\\n                    || ((diff == diff_1) && (i_next < i))\\n            );\\n            _ret += (ptr_1 - ptr_0);\\n\\n            ret = ret.max(_ret);\\n        }\\n\\n        ret as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848826,
                "title": "range-frequency-queries",
                "content": "```\\nfrom collections import defaultdict\\nimport bisect\\n\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        p = 0\\n        pos = defaultdict(list)\\n        pos[0].append(0)\\n        for i in range(n):\\n            p += nums[i]\\n            pos[p].append(i + 1)\\n        res = 0\\n        if p % 2 == 0:\\n            res = bisect.bisect_right(pos[p // 2], n - 1) - bisect.bisect_left(pos[p // 2], 1)\\n        for i in range(n):\\n            diff = k - nums[i]\\n            if (p + diff) & 1:\\n                continue\\n            ltarget = (p + diff) // 2\\n            rtarget = ltarget - diff\\n            left = bisect.bisect_right(pos[ltarget], i) - bisect.bisect_left(pos[ltarget], 1)\\n            right = bisect.bisect_right(pos[rtarget], n - 1) - bisect.bisect_left(pos[rtarget], i + 1)\\n            res = max(res, left + right)\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/c5514ed0-e171-475b-9c92-e80cadaec4f0_1690904587.872978.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport bisect\\n\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        p = 0\\n        pos = defaultdict(list)\\n        pos[0].append(0)\\n        for i in range(n):\\n            p += nums[i]\\n            pos[p].append(i + 1)\\n        res = 0\\n        if p % 2 == 0:\\n            res = bisect.bisect_right(pos[p // 2], n - 1) - bisect.bisect_left(pos[p // 2], 1)\\n        for i in range(n):\\n            diff = k - nums[i]\\n            if (p + diff) & 1:\\n                continue\\n            ltarget = (p + diff) // 2\\n            rtarget = ltarget - diff\\n            left = bisect.bisect_right(pos[ltarget], i) - bisect.bisect_left(pos[ltarget], 1)\\n            right = bisect.bisect_right(pos[rtarget], n - 1) - bisect.bisect_left(pos[rtarget], i + 1)\\n            res = max(res, left + right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759163,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int waysToPartition(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<long long, int> postsum_to_count;\\n    long long sum = 0LL;\\n    for (int i = n - 1; i > 0; --i) {\\n      sum += nums[i];\\n      ++postsum_to_count[sum];\\n    }\\n    sum += nums.front();\\n    \\n    int ret = 0;\\n    if (sum % 2 == 0) {\\n      auto itr = postsum_to_count.find(sum / 2);\\n      if (itr != postsum_to_count.end()) {\\n        ret = itr->second;\\n      }\\n    }\\n    \\n    ++postsum_to_count[sum];\\n    unordered_map<long long, int> presum_to_count;\\n    for (long long presum = 0, i = 0; i < n; ++i) {\\n      const long long postsum = sum - presum;\\n      presum += nums[i];\\n      auto itr_post = postsum_to_count.find(postsum);\\n      if (--itr_post->second == 0) {\\n        postsum_to_count.erase(itr_post);\\n      }\\n      const long long current_sum = sum - nums[i] + k;\\n      if (current_sum % 2 == 0) {\\n        auto itr_pre = presum_to_count.find(current_sum / 2);\\n        const int pre_count = itr_pre == presum_to_count.end() ? 0 : itr_pre->second;\\n        auto itr_post = postsum_to_count.find(current_sum / 2);\\n        const int post_count = itr_post == postsum_to_count.end() ? 0 : itr_post->second;\\n        ret = max(ret, pre_count + post_count);\\n      }\\n      ++presum_to_count[presum];\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int waysToPartition(const vector<int> &nums, const int k) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<long long, int> postsum_to_count;\\n    long long sum = 0LL;\\n    for (int i = n - 1; i > 0; --i) {\\n      sum += nums[i];\\n      ++postsum_to_count[sum];\\n    }\\n    sum += nums.front();\\n    \\n    int ret = 0;\\n    if (sum % 2 == 0) {\\n      auto itr = postsum_to_count.find(sum / 2);\\n      if (itr != postsum_to_count.end()) {\\n        ret = itr->second;\\n      }\\n    }\\n    \\n    ++postsum_to_count[sum];\\n    unordered_map<long long, int> presum_to_count;\\n    for (long long presum = 0, i = 0; i < n; ++i) {\\n      const long long postsum = sum - presum;\\n      presum += nums[i];\\n      auto itr_post = postsum_to_count.find(postsum);\\n      if (--itr_post->second == 0) {\\n        postsum_to_count.erase(itr_post);\\n      }\\n      const long long current_sum = sum - nums[i] + k;\\n      if (current_sum % 2 == 0) {\\n        auto itr_pre = presum_to_count.find(current_sum / 2);\\n        const int pre_count = itr_pre == presum_to_count.end() ? 0 : itr_pre->second;\\n        auto itr_post = postsum_to_count.find(current_sum / 2);\\n        const int post_count = itr_post == postsum_to_count.end() ? 0 : itr_post->second;\\n        ret = max(ret, pre_count + post_count);\\n      }\\n      ++presum_to_count[presum];\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564526,
                "title": "prefix-sum-c-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        vector<long long>prefix(nums.size()),suffix(nums.size());\\n        prefix[0]=nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        suffix[nums.size()-1]=nums.back();\\n        for(int i= nums.size()-2; i>=0; i--){\\n            suffix[i]=nums[i]+suffix[i+1];\\n        }\\n        map<long long,long long>m,left;\\n        long long ans=INT_MIN;\\n        for(int i=0; i<nums.size()-1; i++){\\n            m[prefix[i]-suffix[i+1]]++;\\n        }\\n        ans=max(ans,m[0]);\\n        for(int i=0; i<nums.size(); i++){\\n            ans=max(ans,left[k-nums[i]]+m[nums[i]-k]);\\n            if(i+1<nums.size()){\\n                left[prefix[i]-suffix[i+1]]++;\\n                m[prefix[i]-suffix[i+1]]--;\\n                if(m[prefix[i]-suffix[i+1]]==0) m.erase(prefix[i]-suffix[i+1]);\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        vector<long long>prefix(nums.size()),suffix(nums.size());\\n        prefix[0]=nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        suffix[nums.size()-1]=nums.back();\\n        for(int i= nums.size()-2; i>=0; i--){\\n            suffix[i]=nums[i]+suffix[i+1];\\n        }\\n        map<long long,long long>m,left;\\n        long long ans=INT_MIN;\\n        for(int i=0; i<nums.size()-1; i++){\\n            m[prefix[i]-suffix[i+1]]++;\\n        }\\n        ans=max(ans,m[0]);\\n        for(int i=0; i<nums.size(); i++){\\n            ans=max(ans,left[k-nums[i]]+m[nums[i]-k]);\\n            if(i+1<nums.size()){\\n                left[prefix[i]-suffix[i+1]]++;\\n                m[prefix[i]-suffix[i+1]]--;\\n                if(m[prefix[i]-suffix[i+1]]==0) m.erase(prefix[i]-suffix[i+1]);\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491746,
                "title": "counting-in-parts",
                "content": "The idea is to count prefix sum and postfix sum in parts w.r.t. changed element so that we count number of prefix sum = updated target before each changed element in one pass and number of postfix sum = updated target after each changed element in second go. We accumlate those 2 numbers for each candidate change separately to find max.\\n```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        vector<int> sol(nums.size(), 0);\\n        int ans = 0;\\n        long long sum = 0;\\n        for(int x: nums) sum += x;\\n        unordered_map<long long, int> fmap;\\n        fmap[nums[0]] = 1;\\n        long long c = nums[0];\\n        long long csum;\\n        for(int i = 1; i < nums.size(); i++){\\n            csum = sum + k - nums[i];\\n            if(csum%2 == 0){\\n                sol[i] = fmap[csum/2];\\n            }\\n            c += nums[i];\\n            if(i != nums.size() - 1){\\n                fmap[c]++;\\n            }\\n        }\\n        if(sum%2 == 0){\\n            ans = fmap[sum/2];\\n        }\\n        unordered_map<long long, int> bmap;\\n        bmap[nums[nums.size() - 1]] = 1;\\n        c = nums[nums.size() - 1];\\n        for(int i = nums.size() - 2; i >= 0; i--){\\n            csum = sum + k - nums[i];\\n            if(csum%2 == 0){\\n                sol[i] += bmap[csum/2];\\n            }\\n            c += nums[i];\\n            if(i != nums.size() - 1){\\n                bmap[c]++;\\n            }\\n        }\\n        for(int x: sol) {\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        vector<int> sol(nums.size(), 0);\\n        int ans = 0;\\n        long long sum = 0;\\n        for(int x: nums) sum += x;\\n        unordered_map<long long, int> fmap;\\n        fmap[nums[0]] = 1;\\n        long long c = nums[0];\\n        long long csum;\\n        for(int i = 1; i < nums.size(); i++){\\n            csum = sum + k - nums[i];\\n            if(csum%2 == 0){\\n                sol[i] = fmap[csum/2];\\n            }\\n            c += nums[i];\\n            if(i != nums.size() - 1){\\n                fmap[c]++;\\n            }\\n        }\\n        if(sum%2 == 0){\\n            ans = fmap[sum/2];\\n        }\\n        unordered_map<long long, int> bmap;\\n        bmap[nums[nums.size() - 1]] = 1;\\n        c = nums[nums.size() - 1];\\n        for(int i = nums.size() - 2; i >= 0; i--){\\n            csum = sum + k - nums[i];\\n            if(csum%2 == 0){\\n                sol[i] += bmap[csum/2];\\n            }\\n            c += nums[i];\\n            if(i != nums.size() - 1){\\n                bmap[c]++;\\n            }\\n        }\\n        for(int x: sol) {\\n            ans = max(ans, x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390088,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        vector<LL>preSum(n) ;\\n        vector<LL>sufSum(n) ;\\n        LL sum = accumulate(nums.begin(), nums.end(), 0LL) ;\\n        vector<int>rets(n) ;\\n        \\n        preSum[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n            preSum[i] = preSum[i-1] + nums[i] ;\\n        \\n        sufSum[n-1] = nums[n-1] ;\\n        for(int i = n-2 ; i >= 0; i--)\\n            sufSum[i] = sufSum[i+1] + nums[i] ;\\n        \\n        unordered_map<LL, int>Map ; //{preSum, count} \\n        for(int i = 0; i < n; i++){\\n            LL newSum = sum - nums[i] + k ;\\n            if(newSum % 2 == 0)\\n                rets[i] += Map[newSum/2] ;\\n            Map[preSum[i]]++ ;\\n        }\\n        Map.clear() ;\\n        for(int i = n-1; i >= 0; i--){\\n            LL newSum = sum - nums[i] + k ;\\n            if(newSum % 2 == 0)\\n                rets[i] += Map[newSum/2] ;\\n            Map[sufSum[i]]++ ;\\n        }\\n        \\n        int retNoChanged = 0 ;\\n        for(int i = 0; i < n-1; i++){\\n            if(preSum[i]*2 == sum )\\n                retNoChanged++ ;\\n        }\\n        int ans = *max_element(rets.begin(), rets.end()) ;\\n        ans = max(ans, retNoChanged) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        int n = nums.size() ;\\n        vector<LL>preSum(n) ;\\n        vector<LL>sufSum(n) ;\\n        LL sum = accumulate(nums.begin(), nums.end(), 0LL) ;\\n        vector<int>rets(n) ;\\n        \\n        preSum[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n            preSum[i] = preSum[i-1] + nums[i] ;\\n        \\n        sufSum[n-1] = nums[n-1] ;\\n        for(int i = n-2 ; i >= 0; i--)\\n            sufSum[i] = sufSum[i+1] + nums[i] ;\\n        \\n        unordered_map<LL, int>Map ; //{preSum, count} \\n        for(int i = 0; i < n; i++){\\n            LL newSum = sum - nums[i] + k ;\\n            if(newSum % 2 == 0)\\n                rets[i] += Map[newSum/2] ;\\n            Map[preSum[i]]++ ;\\n        }\\n        Map.clear() ;\\n        for(int i = n-1; i >= 0; i--){\\n            LL newSum = sum - nums[i] + k ;\\n            if(newSum % 2 == 0)\\n                rets[i] += Map[newSum/2] ;\\n            Map[sufSum[i]]++ ;\\n        }\\n        \\n        int retNoChanged = 0 ;\\n        for(int i = 0; i < n-1; i++){\\n            if(preSum[i]*2 == sum )\\n                retNoChanged++ ;\\n        }\\n        int ans = *max_element(rets.begin(), rets.end()) ;\\n        ans = max(ans, retNoChanged) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377158,
                "title": "c-counting-left-and-right-differences",
                "content": "# Complexity\\n\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int WaysToPartition(int[] nums, int k)\\n    {\\n        int n = nums.Length;\\n\\n        long[] prefix = new long[n + 1];\\n        for (int i = 0; i < n; i++)\\n        {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n\\n        var left = new Dictionary<long, int>();\\n        var right = new Dictionary<long, int>();\\n\\n        long diff;\\n        for (int i = 1; i < n; i++)\\n        {\\n            diff = prefix[i] - (prefix[n] - prefix[i]);\\n\\n            if (!right.ContainsKey(diff))\\n            {\\n                right.Add(diff, 0);\\n            }\\n            right[diff]++;\\n        }\\n\\n        int max = 0;\\n        if (right.ContainsKey(0))\\n        {\\n            max += right[0];\\n        }\\n\\n        int count;\\n        for (int i = 0; i < n; i++)\\n        {\\n            count = 0;\\n            if (left.ContainsKey(k - nums[i]))\\n            {\\n                count += left[k - nums[i]];\\n            }\\n            if (right.ContainsKey(nums[i] - k))\\n            {\\n                count += right[nums[i] - k];\\n            }\\n\\n            max = Math.Max(max, count);\\n\\n            if (i < n - 1)\\n            {\\n                diff = prefix[i + 1] - (prefix[n] - prefix[i + 1]);\\n\\n                right[diff]--;\\n                if (right[diff] == 0)\\n                {\\n                    right.Remove(diff);\\n                }\\n\\n                if (!left.ContainsKey(diff))\\n                {\\n                    left.Add(diff, 0);\\n                }\\n                left[diff]++;\\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int WaysToPartition(int[] nums, int k)\\n    {\\n        int n = nums.Length;\\n\\n        long[] prefix = new long[n + 1];\\n        for (int i = 0; i < n; i++)\\n        {\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n\\n        var left = new Dictionary<long, int>();\\n        var right = new Dictionary<long, int>();\\n\\n        long diff;\\n        for (int i = 1; i < n; i++)\\n        {\\n            diff = prefix[i] - (prefix[n] - prefix[i]);\\n\\n            if (!right.ContainsKey(diff))\\n            {\\n                right.Add(diff, 0);\\n            }\\n            right[diff]++;\\n        }\\n\\n        int max = 0;\\n        if (right.ContainsKey(0))\\n        {\\n            max += right[0];\\n        }\\n\\n        int count;\\n        for (int i = 0; i < n; i++)\\n        {\\n            count = 0;\\n            if (left.ContainsKey(k - nums[i]))\\n            {\\n                count += left[k - nums[i]];\\n            }\\n            if (right.ContainsKey(nums[i] - k))\\n            {\\n                count += right[nums[i] - k];\\n            }\\n\\n            max = Math.Max(max, count);\\n\\n            if (i < n - 1)\\n            {\\n                diff = prefix[i + 1] - (prefix[n] - prefix[i + 1]);\\n\\n                right[diff]--;\\n                if (right[diff] == 0)\\n                {\\n                    right.Remove(diff);\\n                }\\n\\n                if (!left.ContainsKey(diff))\\n                {\\n                    left.Add(diff, 0);\\n                }\\n                left[diff]++;\\n            }\\n        }\\n\\n        return max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371978,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int WaysToPartition(int[] nums, int k)\\n    {\\n        var prefixSum = new long[nums.Length];\\n        var suffixSum = new long[nums.Length];\\n        int n = nums.Length;\\n        for (int i = 0; i < n; i++)\\n        {\\n            prefixSum[i] = (i == 0 ? 0 : prefixSum[i - 1]) + nums[i];\\n            suffixSum[n - 1 - i] = nums[n - 1 - i] + (i == 0 ? 0 : suffixSum[n - i]);\\n        }\\n\\n        var diff = new Dictionary<long, List<Info>>();\\n        for (int i = 0; i < nums.Length - 1; i++)\\n        {\\n            var difference = prefixSum[i] - suffixSum[i + 1];\\n            var list = diff.GetValueOrDefault(Math.Abs(difference), new List<Info>());\\n            list.Add(new Info() { diff = difference, index = i, count = 0 });\\n            diff[Math.Abs(difference)] = list;\\n        }\\n\\n        int max = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            long change = k - nums[i];\\n            var list = diff.GetValueOrDefault(Math.Abs(change), new List<Info>());\\n            int sum = 0;\\n            foreach (var info in list)\\n            {\\n                if (info.index >= i && info.diff == -change ||\\n                    info.index < i && info.diff == change)\\n                {\\n                    sum++;\\n                }\\n            }\\n            max = Math.Max(max, sum);\\n        }\\n\\n        int sum0 = 0;\\n        if (diff.ContainsKey(0))\\n        {\\n            sum0 = diff[0].Count;\\n        }\\n\\n        return Math.Max(max, sum0);\\n    }\\n\\n    private class Info\\n    {\\n        public long diff;\\n        public int index;\\n        public int count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int WaysToPartition(int[] nums, int k)\\n    {\\n        var prefixSum = new long[nums.Length];\\n        var suffixSum = new long[nums.Length];\\n        int n = nums.Length;\\n        for (int i = 0; i < n; i++)\\n        {\\n            prefixSum[i] = (i == 0 ? 0 : prefixSum[i - 1]) + nums[i];\\n            suffixSum[n - 1 - i] = nums[n - 1 - i] + (i == 0 ? 0 : suffixSum[n - i]);\\n        }\\n\\n        var diff = new Dictionary<long, List<Info>>();\\n        for (int i = 0; i < nums.Length - 1; i++)\\n        {\\n            var difference = prefixSum[i] - suffixSum[i + 1];\\n            var list = diff.GetValueOrDefault(Math.Abs(difference), new List<Info>());\\n            list.Add(new Info() { diff = difference, index = i, count = 0 });\\n            diff[Math.Abs(difference)] = list;\\n        }\\n\\n        int max = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            long change = k - nums[i];\\n            var list = diff.GetValueOrDefault(Math.Abs(change), new List<Info>());\\n            int sum = 0;\\n            foreach (var info in list)\\n            {\\n                if (info.index >= i && info.diff == -change ||\\n                    info.index < i && info.diff == change)\\n                {\\n                    sum++;\\n                }\\n            }\\n            max = Math.Max(max, sum);\\n        }\\n\\n        int sum0 = 0;\\n        if (diff.ContainsKey(0))\\n        {\\n            sum0 = diff[0].Count;\\n        }\\n\\n        return Math.Max(max, sum0);\\n    }\\n\\n    private class Info\\n    {\\n        public long diff;\\n        public int index;\\n        public int count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257959,
                "title": "maximum-number-of-ways-to-partition-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGiven array A, we can compute an array diff where diff[i] = (A[0] + .. + A[i-1]) - (A[i] + .. + A[N-1]) (1 <= i < N), i.e. sum of left part minus sum of right part.\\n\\nIf we don\\'t do any replacement, the answer is the number of 0s in the diff array.\\n\\nIf we replace A[i] with k, then diff[1] to diff[i] decrease by d, and diff[i+1] to diff[N-1] increase by d, where d = k - A[i]. Again, the answer is the number of 0s in this new diff array.\\n\\nInstead of changing the diff array (taking O(N) time), we can simply count the number of d in diff[1..i] and number of -d in diff[(i+1)..(N-1)] (taking O(1) time).\\n\\nSo, we can use two frequency maps L and R which are the frequency maps of diff[1..i] and diff[(i+1)..(N-1)] respectively.\\n\\nWe scan from left to right. For each A[i], we try to update ans with L[d] + R[-d] where d = k - A[i], and update the frequency maps.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        long sum = accumulate(begin(nums), end(nums), 0L), N = nums.size();\\n        unordered_map<long, int> L, R;\\n        for (long i = 0, left = 0; i < N - 1; ++i) {\\n            left += nums[i];\\n            long right = sum - left;\\n            R[left - right]++;\\n        }\\n        int ans = R[0]; // If we don\\'t do any replacement, answer is the number of `0`s in the frequency map\\n        for (long i = 0, left = 0; i < N; ++i) {\\n            left += nums[i];\\n            long right = sum - left, d = k - nums[i];\\n            ans = max(ans, L[d] + R[-d]); // If we replace `A[i]` with `k`, we will get `L[d] + R[-d]` pivots\\n            R[left - right]--; // transfer the frequency from `R` to `L`.\\n            L[left - right]++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        long sum = accumulate(begin(nums), end(nums), 0L), N = nums.size();\\n        unordered_map<long, int> L, R;\\n        for (long i = 0, left = 0; i < N - 1; ++i) {\\n            left += nums[i];\\n            long right = sum - left;\\n            R[left - right]++;\\n        }\\n        int ans = R[0]; // If we don\\'t do any replacement, answer is the number of `0`s in the frequency map\\n        for (long i = 0, left = 0; i < N; ++i) {\\n            left += nums[i];\\n            long right = sum - left, d = k - nums[i];\\n            ans = max(ans, L[d] + R[-d]); // If we replace `A[i]` with `k`, we will get `L[d] + R[-d]` pivots\\n            R[left - right]--; // transfer the frequency from `R` to `L`.\\n            L[left - right]++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246251,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn ways_to_partition(nums: Vec<i32>, k: i32) -> i32 {\\n        let nums = nums.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let k = k as i64;\\n        let n = nums.len();\\n        let mut pref = vec![0; n];\\n        let mut suff = vec![0; n];\\n        pref[0] = nums[0];\\n        suff[n - 1] = nums[n - 1];\\n        for i in 1..n {\\n            pref[i] = pref[i - 1] + nums[i];\\n            suff[n - 1 - i] = suff[n - i] + nums[n - 1 - i];\\n        }\\n        let mut ans = 0;\\n        let mut left = std::collections::HashMap::new();\\n        let mut right = std::collections::HashMap::new();\\n        for i in 0..n - 1 {\\n            *right.entry(pref[i] - suff[i + 1]).or_insert(0) += 1;\\n        }\\n        if right.contains_key(&0) {\\n            ans = *right.get(&0).unwrap();\\n        }\\n        for i in 0..n {\\n            let mut curr = 0;\\n            let diff = k - nums[i];\\n            if left.contains_key(&diff) {\\n                curr += *left.get(&diff).unwrap();\\n            }\\n            if right.contains_key(&-diff) {\\n                curr += *right.get(&-diff).unwrap();\\n            }\\n            ans = ans.max(curr);\\n            if i < n - 1 {\\n                let dd = pref[i] - suff[i + 1];\\n                *left.entry(dd).or_insert(0) += 1;\\n                *right.entry(dd).or_insert(0) -= 1;\\n                if *right.get(&dd).unwrap() == 0 {\\n                    right.remove(&dd);\\n                }\\n            }\\n        }\\n        ans as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn ways_to_partition(nums: Vec<i32>, k: i32) -> i32 {\\n        let nums = nums.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let k = k as i64;\\n        let n = nums.len();\\n        let mut pref = vec![0; n];\\n        let mut suff = vec![0; n];\\n        pref[0] = nums[0];\\n        suff[n - 1] = nums[n - 1];\\n        for i in 1..n {\\n            pref[i] = pref[i - 1] + nums[i];\\n            suff[n - 1 - i] = suff[n - i] + nums[n - 1 - i];\\n        }\\n        let mut ans = 0;\\n        let mut left = std::collections::HashMap::new();\\n        let mut right = std::collections::HashMap::new();\\n        for i in 0..n - 1 {\\n            *right.entry(pref[i] - suff[i + 1]).or_insert(0) += 1;\\n        }\\n        if right.contains_key(&0) {\\n            ans = *right.get(&0).unwrap();\\n        }\\n        for i in 0..n {\\n            let mut curr = 0;\\n            let diff = k - nums[i];\\n            if left.contains_key(&diff) {\\n                curr += *left.get(&diff).unwrap();\\n            }\\n            if right.contains_key(&-diff) {\\n                curr += *right.get(&-diff).unwrap();\\n            }\\n            ans = ans.max(curr);\\n            if i < n - 1 {\\n                let dd = pref[i] - suff[i + 1];\\n                *left.entry(dd).or_insert(0) += 1;\\n                *right.entry(dd).or_insert(0) -= 1;\\n                if *right.get(&dd).unwrap() == 0 {\\n                    right.remove(&dd);\\n                }\\n            }\\n        }\\n        ans as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3110102,
                "title": "c-left-right-count-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int waysToPartition(vector<int>& A, int k) {\\n        ll res = 0, N = A.size(), sum = accumulate(begin(A), end(A), 0ll);\\n        unordered_map<ll, ll> left, right;\\n        for(ll i = 0, s0 = A[0], s1 = sum-A[0]; i < N-1; i++, s0 += A[i], s1 -= A[i]) right[s0-s1]++;\\n        res = right[0];\\n        for(ll i = 0, s0 = A[0], s1 = sum-A[0]; i < N; i++, s0 += i < N ? A[i] : 0, s1 -= i < N ? A[i] : 0) {\\n            res = max(res, right[A[i]-k]+left[k-A[i]]);\\n            left[s0-s1]++;\\n            if(i < N-1) right[s0-s1]--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int waysToPartition(vector<int>& A, int k) {\\n        ll res = 0, N = A.size(), sum = accumulate(begin(A), end(A), 0ll);\\n        unordered_map<ll, ll> left, right;\\n        for(ll i = 0, s0 = A[0], s1 = sum-A[0]; i < N-1; i++, s0 += A[i], s1 -= A[i]) right[s0-s1]++;\\n        res = right[0];\\n        for(ll i = 0, s0 = A[0], s1 = sum-A[0]; i < N; i++, s0 += i < N ? A[i] : 0, s1 -= i < N ? A[i] : 0) {\\n            res = max(res, right[A[i]-k]+left[k-A[i]]);\\n            left[s0-s1]++;\\n            if(i < N-1) right[s0-s1]--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104670,
                "title": "python-one-pass-6-liner-o-n-with-prefix-sum-with-explanation",
                "content": "We maintain a prefix sum `pref` to allow easy computation of subarray sums and dictionary `dic` such that `dic[r]` is a list containing all pivots such that the right sum minus the left sum is equal to `r`. We iterate in one pass, updating `dic` as we go. As we iterate over `i`, we also wish to keep track of maximum equal partitions if `nums[i]` is replaced with` k`. Such a partition exists at pivot `j \\u2264 i` if and only if the right sum minus the left sum (wrt partition at pivot `j`) equals `nums[i] - k`. The number of such `j` is exactly current size of `dic[nums[pivot] - k]`; we store in this `vals[i][1]`. Such a partition exists at pivot `j > i` if and only if the right sum minus the left sum (wrt partition at pivot `j`) equals `k - nums[i]`. The number of such `j` is exactly the difference between the final size of `dic[k - nums[i]]` (after we stop iterating) and the current size.  Maintain the current size in `vals[i][0]`; the difference between final size can just be computed at the end when we return. \\n\\nFinally, we should not forget the case where we leave the array unchanged. That simply corresponds to `dic[0]`. The space and time complexity are both `O(n)`. \\n\\n\\n```\\ndef waysToPartition(self, nums: List[int], k: int) -> int:\\n        pref, vals, dic = [0] + list(accumulate(nums)), [(0,0)] * len(nums), defaultdict(list)\\n        for pivot in range(1, len(nums)):\\n            left, right = pref[pivot] - pref[0], pref[-1] - pref[pivot]\\n            dic[right - left].append(pivot)\\n            vals[pivot] = (len(dic[k - nums[pivot]]), len(dic[nums[pivot] - k]))\\n        return max(len(dic[0]), max([vals[i][1] + len(dic[k - nums[i]]) - vals[i][0] for i in range(len(nums))]))\\n```\\n\\t\\t\\n\\n\\nI later realized this it is possible to optimize the space slightly (this doesn\\'t improve the space complexity, but will improve the constant factor). If you notice, we only ever use the list objects which are the values in `dic` to check their size. So we can replace them with counters. We obtain the following. \\n\\n```\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        pref, vals, dic = [0] + list(accumulate(nums)), [(0,0)] * len(nums), defaultdict(int)\\n        for pivot in range(1, len(nums)):\\n            left, right = pref[pivot] - pref[0], pref[-1] - pref[pivot]\\n            dic[right - left] += 1\\n            vals[pivot] = (dic[k - nums[pivot]], dic[nums[pivot] - k])\\n        return max(dic[0], max([vals[i][1] + dic[k - nums[i]] - vals[i][0] for i in range(len(nums))]))\\n\\n```\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\ndef waysToPartition(self, nums: List[int], k: int) -> int:\\n        pref, vals, dic = [0] + list(accumulate(nums)), [(0,0)] * len(nums), defaultdict(list)\\n        for pivot in range(1, len(nums)):\\n            left, right = pref[pivot] - pref[0], pref[-1] - pref[pivot]\\n            dic[right - left].append(pivot)\\n            vals[pivot] = (len(dic[k - nums[pivot]]), len(dic[nums[pivot] - k]))\\n        return max(len(dic[0]), max([vals[i][1] + len(dic[k - nums[i]]) - vals[i][0] for i in range(len(nums))]))\\n```\n```\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        pref, vals, dic = [0] + list(accumulate(nums)), [(0,0)] * len(nums), defaultdict(int)\\n        for pivot in range(1, len(nums)):\\n            left, right = pref[pivot] - pref[0], pref[-1] - pref[pivot]\\n            dic[right - left] += 1\\n            vals[pivot] = (dic[k - nums[pivot]], dic[nums[pivot] - k])\\n        return max(dic[0], max([vals[i][1] + dic[k - nums[i]] - vals[i][0] for i in range(len(nums))]))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3100558,
                "title": "prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n\\n        int n = nums.length;\\n        long[] prefix = new long[n + 1];\\n        long[] suffix = new long[n + 1];\\n\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        }\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + nums[i];\\n        }\\n\\n        int count = 0;\\n        int max = 0;\\n\\n        HashMap<Long, Integer> map = new HashMap<>();\\n        HashMap<Long, Integer> rev = new HashMap<>();\\n\\n\\n        for (int i = 1; i < n; i++) {\\n\\n            if (prefix[i] == suffix[i]) {\\n                count++;\\n            } else {\\n                long diff = prefix[i] - suffix[i];\\n                if (map.containsKey(diff)) {\\n                    map.put(diff, map.get(diff) + 1);\\n                } else {\\n                    map.put(diff, 1);\\n                }\\n            }\\n        }\\n        max = count;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            long diff = k - nums[i];\\n            int c = 0;\\n\\n            if (map.containsKey(diff)) {\\n                c += map.get(diff);\\n            }\\n\\n            if (rev.containsKey(-diff)) {\\n                c += rev.get(-diff);\\n            }\\n\\n            long dd = prefix[i] - suffix[i];\\n\\n            if (map.containsKey(dd)) {\\n                map.put(dd, map.get(dd) - 1);\\n                if (map.get(dd) == 0) {\\n                    map.remove(dd);\\n                }\\n            }\\n\\n\\n            if (rev.containsKey(dd)) {\\n                rev.put(dd, rev.get(dd) + 1);\\n            } else {\\n                rev.put(dd, 1);\\n            }\\n\\n            max = Math.max(max, c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n\\n        int n = nums.length;\\n        long[] prefix = new long[n + 1];\\n        long[] suffix = new long[n + 1];\\n\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] + nums[i - 1];\\n        }\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + nums[i];\\n        }\\n\\n        int count = 0;\\n        int max = 0;\\n\\n        HashMap<Long, Integer> map = new HashMap<>();\\n        HashMap<Long, Integer> rev = new HashMap<>();\\n\\n\\n        for (int i = 1; i < n; i++) {\\n\\n            if (prefix[i] == suffix[i]) {\\n                count++;\\n            } else {\\n                long diff = prefix[i] - suffix[i];\\n                if (map.containsKey(diff)) {\\n                    map.put(diff, map.get(diff) + 1);\\n                } else {\\n                    map.put(diff, 1);\\n                }\\n            }\\n        }\\n        max = count;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            long diff = k - nums[i];\\n            int c = 0;\\n\\n            if (map.containsKey(diff)) {\\n                c += map.get(diff);\\n            }\\n\\n            if (rev.containsKey(-diff)) {\\n                c += rev.get(-diff);\\n            }\\n\\n            long dd = prefix[i] - suffix[i];\\n\\n            if (map.containsKey(dd)) {\\n                map.put(dd, map.get(dd) - 1);\\n                if (map.get(dd) == 0) {\\n                    map.remove(dd);\\n                }\\n            }\\n\\n\\n            if (rev.containsKey(dd)) {\\n                rev.put(dd, rev.get(dd) + 1);\\n            } else {\\n                rev.put(dd, 1);\\n            }\\n\\n            max = Math.max(max, c);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063455,
                "title": "ez-solution-java-o-n-hashmap-no-prefix-sum-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPart - 1 \\nLets ignore K for a bit. \\nThen can we find number of possible partitions that divides the array into 2 parts that have equal sum ?\\n\\nThe answer would be : all the Left partition subarrays starting from index 0 ending at an index i which has the sum = total_elements/2 \\n-  Left partition size = 1 to n-1 and Right parition size 1 to n-1\\n\\nPart -2 \\nNow lets consider K in the array.\\nThere can be 2 cases :\\n1. Case : When K is in the Right partition!!\\n2. Case : When K is in the Left partition!!\\n\\nCase 1: \\nIf K is in the Right partition then answer is : all the Left partition subarrays starting from index 0 ending at an index i which has the sum X. Where 2*X lies in the \"possible summitions\" with pivot index> i.\\n\\n \\nCase 2: \\nIf K is in the Left partition then answer is :\\nI cant calculate it beacuse i would need to replace the nums[i] with k and change the ending index. Two nested loops on pivot and ending index, giving O(N^2) complexity!! \\n\\nSo a work Around!!! \\nIf K is in the Left partition that must that all the elements int the Right Partitions would remain unchanged.\\nHence the answer would be all the Right partition subarrays starting from index i ending at an index n-1 which has the sum X. Where 2*X lies in the \"possible summitions\" with pivot index < i.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a HashMap that stores <Possible Sum, Array List that stores (index of K responsible for the possible sum)>.\\nThis is done in O(N)\\n\\nAnd the rest as mentioned above!!\\n  \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        long total_sum  =0;\\n        for(int i=0;i<nums.length;i++){\\n            total_sum = total_sum + nums[i];\\n        }\\n\\n        HashMap<Long, ArrayList<Integer>>HM = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            long tem = total_sum +k- nums[i];\\n            ArrayList<Integer> AL = \\n            HM.getOrDefault(tem,new ArrayList<>());\\n            AL.add(i);\\n            HM.put(tem,AL);\\n        }\\n\\n        int[] ans = new int[nums.length];\\n        long sum_L =0;\\n        for(int i=0;i<=nums.length-2;i++){\\n            sum_L = sum_L+nums[i];\\n            if(HM.containsKey(sum_L*2)){\\n                ArrayList<Integer> AL = \\n                HM.get(sum_L*2);\\n                for(int idx : AL){\\n                    // if added K position is after I\\n                    if(i<idx){\\n                        ans[idx]++;\\n                    }\\n                }\\n            }\\n        }\\n        long sum_R =0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum_R = sum_R+nums[i];\\n            if(HM.containsKey(sum_R*2)){\\n                ArrayList<Integer> AL = \\n                HM.get(sum_R*2);\\n                for(int idx : AL){\\n                    // if added K position is before I\\n                    if(i>idx){\\n                        ans[idx]++;\\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(Arrays.toString(ans));\\n        // solve case 1\\n        int c1 =0;\\n        long c1_sum =0;\\n        for(int i=0;i<nums.length-1;i++){\\n            c1_sum = c1_sum + nums[i];\\n            if(c1_sum*2==total_sum){\\n               c1++; \\n            }\\n        }\\n\\n        int ff = c1;\\n        for(int ali: ans){\\n            ff = Math.max(ff,ali);\\n        }\\n        return ff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        long total_sum  =0;\\n        for(int i=0;i<nums.length;i++){\\n            total_sum = total_sum + nums[i];\\n        }\\n\\n        HashMap<Long, ArrayList<Integer>>HM = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            long tem = total_sum +k- nums[i];\\n            ArrayList<Integer> AL = \\n            HM.getOrDefault(tem,new ArrayList<>());\\n            AL.add(i);\\n            HM.put(tem,AL);\\n        }\\n\\n        int[] ans = new int[nums.length];\\n        long sum_L =0;\\n        for(int i=0;i<=nums.length-2;i++){\\n            sum_L = sum_L+nums[i];\\n            if(HM.containsKey(sum_L*2)){\\n                ArrayList<Integer> AL = \\n                HM.get(sum_L*2);\\n                for(int idx : AL){\\n                    // if added K position is after I\\n                    if(i<idx){\\n                        ans[idx]++;\\n                    }\\n                }\\n            }\\n        }\\n        long sum_R =0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum_R = sum_R+nums[i];\\n            if(HM.containsKey(sum_R*2)){\\n                ArrayList<Integer> AL = \\n                HM.get(sum_R*2);\\n                for(int idx : AL){\\n                    // if added K position is before I\\n                    if(i>idx){\\n                        ans[idx]++;\\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(Arrays.toString(ans));\\n        // solve case 1\\n        int c1 =0;\\n        long c1_sum =0;\\n        for(int i=0;i<nums.length-1;i++){\\n            c1_sum = c1_sum + nums[i];\\n            if(c1_sum*2==total_sum){\\n               c1++; \\n            }\\n        }\\n\\n        int ff = c1;\\n        for(int ali: ans){\\n            ff = Math.max(ff,ali);\\n        }\\n        return ff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753973,
                "title": "java-single-hashmap-counting-both-prefix-and-suffix-sums-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n\\n        long s = 0;\\n        for (int n : nums)\\n            s += n;\\n        Map<Long,Integer> map = new HashMap<Long,Integer>();\\n        long r = 0;\\n        for (int i = nums.length-1; i > 0; i--) {\\n            r += nums[i]; // sufix sum from i\\n            long t = s-r*2+k; // this suffix sum (r) would qualify as pivot if in the corresponding prefix an element of value t was changed to k\\n            map.put(t,map.getOrDefault(t,0)+1);            \\n        }\\n\\n        long l = 0;\\n        int resp = map.getOrDefault((long)nums[0],0);\\n        int none = 0; // count of pivots for unchanged array\\n        for (int i = 1; i < nums.length; i++) {\\n            l += nums[i-1];  // prefix sum up to i-1\\n            if (l*2 == s) none++;  // i is a pivot for unchanged array\\n            long t = s - l*2;\\n            map.put(t+k,map.getOrDefault(t+k,0)+1); // this prefix sum (l) would qualify as pivot if in the corresponding suffix an element of value t+k was changed to k\\n            map.put(-t+k,map.get(-t+k)-1); // remove the suffix contribution\\n            resp = Math.max(resp,map.getOrDefault((long)nums[i],0)); // check the \\n        }\\n        return Math.max(resp,none);        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n\\n        long s = 0;\\n        for (int n : nums)\\n            s += n;\\n        Map<Long,Integer> map = new HashMap<Long,Integer>();\\n        long r = 0;\\n        for (int i = nums.length-1; i > 0; i--) {\\n            r += nums[i]; // sufix sum from i\\n            long t = s-r*2+k; // this suffix sum (r) would qualify as pivot if in the corresponding prefix an element of value t was changed to k\\n            map.put(t,map.getOrDefault(t,0)+1);            \\n        }\\n\\n        long l = 0;\\n        int resp = map.getOrDefault((long)nums[0],0);\\n        int none = 0; // count of pivots for unchanged array\\n        for (int i = 1; i < nums.length; i++) {\\n            l += nums[i-1];  // prefix sum up to i-1\\n            if (l*2 == s) none++;  // i is a pivot for unchanged array\\n            long t = s - l*2;\\n            map.put(t+k,map.getOrDefault(t+k,0)+1); // this prefix sum (l) would qualify as pivot if in the corresponding suffix an element of value t+k was changed to k\\n            map.put(-t+k,map.get(-t+k)-1); // remove the suffix contribution\\n            resp = Math.max(resp,map.getOrDefault((long)nums[i],0)); // check the \\n        }\\n        return Math.max(resp,none);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705181,
                "title": "python-o-n-solution-faster-than-82",
                "content": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        sz, ans, left, right = len(nums), 0, defaultdict(int), defaultdict(int)\\n        prefix, suffix = [0] * sz, [0] * sz\\n        prefix[0], suffix[-1] = nums[0], nums[-1]\\n        # store prefix and suffix sum\\n        for idx in range(1, sz):\\n            prefix[idx] = prefix[idx - 1] + nums[idx]\\n            suffix[sz - 1 - idx] = suffix[sz - idx] + nums[sz - 1 - idx]\\n        # intially store the differences in the hashmap right\\n        for idx in range(sz - 1):\\n            right[prefix[idx] - suffix[idx + 1]] += 1\\n        if 0 in right:\\n            ans = right[0]\\n        for idx in range(sz):\\n            # find the number of pivot indexes when nums[i] is changed to k\\n            curr, diff = 0, k - nums[idx]\\n            if diff in left: \\n                curr += left[diff]\\n            if -diff in right: \\n                curr += right[-diff]\\n            # update answer\\n            ans = max(ans, curr)\\n            # transfer the current element from right to left\\n            if idx < sz - 1:\\n                currentElem = prefix[idx] - suffix[idx + 1]\\n                left[currentElem] += 1\\n                right[currentElem] -= 1\\n                if right[currentElem] == 0:\\n                    del right[currentElem]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        sz, ans, left, right = len(nums), 0, defaultdict(int), defaultdict(int)\\n        prefix, suffix = [0] * sz, [0] * sz\\n        prefix[0], suffix[-1] = nums[0], nums[-1]\\n        # store prefix and suffix sum\\n        for idx in range(1, sz):\\n            prefix[idx] = prefix[idx - 1] + nums[idx]\\n            suffix[sz - 1 - idx] = suffix[sz - idx] + nums[sz - 1 - idx]\\n        # intially store the differences in the hashmap right\\n        for idx in range(sz - 1):\\n            right[prefix[idx] - suffix[idx + 1]] += 1\\n        if 0 in right:\\n            ans = right[0]\\n        for idx in range(sz):\\n            # find the number of pivot indexes when nums[i] is changed to k\\n            curr, diff = 0, k - nums[idx]\\n            if diff in left: \\n                curr += left[diff]\\n            if -diff in right: \\n                curr += right[-diff]\\n            # update answer\\n            ans = max(ans, curr)\\n            # transfer the current element from right to left\\n            if idx < sz - 1:\\n                currentElem = prefix[idx] - suffix[idx + 1]\\n                left[currentElem] += 1\\n                right[currentElem] -= 1\\n                if right[currentElem] == 0:\\n                    del right[currentElem]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675687,
                "title": "python-solution-faster-93",
                "content": "\\tfrom bisect import bisect\\n\\n\\tclass Solution:\\n\\t\\tdef waysToPartition(self, nums, k):\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tacc1 = list(accumulate(nums))\\n\\t\\t\\td1 = defaultdict(list)\\n\\t\\t\\tfor idx, num in enumerate(acc1):\\n\\t\\t\\t\\td1[num].append(idx)\\n\\n\\t\\t\\tacc2 = list(accumulate(nums[::-1]))\\n\\t\\t\\td2 = defaultdict(list)\\n\\t\\t\\tfor idx, num in enumerate(acc2):\\n\\t\\t\\t\\td2[num].append(idx)\\n\\n\\t\\t\\tans, ans2 = 0, 0\\n\\n\\t\\t\\tfor i in range(n - 1):\\n\\t\\t\\t\\tif acc1[-1] == 2*acc1[i]: ans2 += 1\\n\\n\\t\\t\\tfor i in range(0, n):\\n\\t\\t\\t\\tcand = (acc1[-1] - nums[i] + k)/2\\n\\t\\t\\t\\tlft = bisect(d1[cand], i-1)\\n\\t\\t\\t\\trgh = bisect(d2[cand], n - i - 2)\\n\\t\\t\\t\\tans = max(ans, lft + rgh)\\n\\n\\t\\t\\treturn max(ans, ans2)",
                "solutionTags": [],
                "code": "\\tfrom bisect import bisect\\n\\n\\tclass Solution:\\n\\t\\tdef waysToPartition(self, nums, k):\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tacc1 = list(accumulate(nums))\\n\\t\\t\\td1 = defaultdict(list)\\n\\t\\t\\tfor idx, num in enumerate(acc1):\\n\\t\\t\\t\\td1[num].append(idx)\\n\\n\\t\\t\\tacc2 = list(accumulate(nums[::-1]))\\n\\t\\t\\td2 = defaultdict(list)\\n\\t\\t\\tfor idx, num in enumerate(acc2):\\n\\t\\t\\t\\td2[num].append(idx)\\n\\n\\t\\t\\tans, ans2 = 0, 0\\n\\n\\t\\t\\tfor i in range(n - 1):\\n\\t\\t\\t\\tif acc1[-1] == 2*acc1[i]: ans2 += 1\\n\\n\\t\\t\\tfor i in range(0, n):\\n\\t\\t\\t\\tcand = (acc1[-1] - nums[i] + k)/2\\n\\t\\t\\t\\tlft = bisect(d1[cand], i-1)\\n\\t\\t\\t\\trgh = bisect(d2[cand], n - i - 2)\\n\\t\\t\\t\\tans = max(ans, lft + rgh)\\n\\n\\t\\t\\treturn max(ans, ans2)",
                "codeTag": "Java"
            },
            {
                "id": 2621328,
                "title": "simple-std-map-solution-c",
                "content": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n        ll ans = 0, tot_sum = 0;\\n        /*\\n\\t\\tcase 2. explanation:\\n\\t\\t\\tlet\\'s assume you change nums[i] to nums[i] + d. (note that d = k - a[i].)\\n\\t\\t\\t\\t->a[0],a[1] , ... a[i] + d, a[i + 1] ... a[n - 1]\\n\\t\\t\\tthen accumulate:\\n\\t\\t\\t\\t->a[0], a[0] + a[1] ,, a[0] + a[i] + d, .... a[0] + ... a[n - 1] + d\\n            sum = a[0] + ... + a[n - 1] + d\\n            pref_sum = a[0] + ... a[j] + d * (j < i)\\n            pref_sum * 2 == sum \\n            count the number of j which satisfies two equations below : \\n\\t\\t\\t(1) 0 <= j < n - 1.\\n\\t\\t\\t\\tand\\n\\t\\t\\t(2)\\n\\t\\t\\t\\tif (j < i)\\n\\t\\t\\t\\t\\t2 * (a[0] + ... a[j]) = a[0] + ... + a[n - 1] + d\\n\\t\\t\\t\\telse (i <= j)\\n\\t\\t\\t\\t\\t2 * (a[0: + ... a[j]) = a[0] + ... + a[n - 1] - d\\n\\t\\t\\tfor all i in [0, n).\\n        */\\n        map<ll, int> leftmp, rightmp;\\n        for (int i = 0; i < n; i++){\\n            tot_sum += nums[i]; \\n            if (i + 1 < n) rightmp[tot_sum]++;\\n        }\\n        //case 1. no change\\n        for (ll i = 0, sum = 0, cnt = 0; i < n; i++){\\n            sum += nums[i];\\n            if (sum * 2 == tot_sum  && i + 1 < n){\\n                cnt++;\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        //case 2. change\\n        for (ll i = 0, sum = 0; i <= n - 1; i++){\\n            ll d = k - nums[i];\\n            sum += nums[i];\\n            //j < i [leftmp]\\n            ll count = 0;\\n            if ((tot_sum + d) % 2 == 0){\\n                count += leftmp[(tot_sum + d) / 2];   \\n            }\\n            // i <= j[rightmp]\\n            if ((tot_sum - d) % 2 == 0){\\n                count += rightmp[(tot_sum - d) / 2];\\n            }\\n            if (rightmp[sum] > 0){\\n                rightmp[sum]--;\\n                leftmp[sum]++;\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n        ll ans = 0, tot_sum = 0;\\n        /*\\n\\t\\tcase 2. explanation:\\n\\t\\t\\tlet\\'s assume you change nums[i] to nums[i] + d. (note that d = k - a[i].)\\n\\t\\t\\t\\t->a[0],a[1] , ... a[i] + d, a[i + 1] ... a[n - 1]\\n\\t\\t\\tthen accumulate:\\n\\t\\t\\t\\t->a[0], a[0] + a[1] ,, a[0] + a[i] + d, .... a[0] + ... a[n - 1] + d\\n            sum = a[0] + ... + a[n - 1] + d\\n            pref_sum = a[0] + ... a[j] + d * (j < i)\\n            pref_sum * 2 == sum \\n            count the number of j which satisfies two equations below : \\n\\t\\t\\t(1) 0 <= j < n - 1.\\n\\t\\t\\t\\tand\\n\\t\\t\\t(2)\\n\\t\\t\\t\\tif (j < i)\\n\\t\\t\\t\\t\\t2 * (a[0] + ... a[j]) = a[0] + ... + a[n - 1] + d\\n\\t\\t\\t\\telse (i <= j)\\n\\t\\t\\t\\t\\t2 * (a[0: + ... a[j]) = a[0] + ... + a[n - 1] - d\\n\\t\\t\\tfor all i in [0, n).\\n        */\\n        map<ll, int> leftmp, rightmp;\\n        for (int i = 0; i < n; i++){\\n            tot_sum += nums[i]; \\n            if (i + 1 < n) rightmp[tot_sum]++;\\n        }\\n        //case 1. no change\\n        for (ll i = 0, sum = 0, cnt = 0; i < n; i++){\\n            sum += nums[i];\\n            if (sum * 2 == tot_sum  && i + 1 < n){\\n                cnt++;\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        //case 2. change\\n        for (ll i = 0, sum = 0; i <= n - 1; i++){\\n            ll d = k - nums[i];\\n            sum += nums[i];\\n            //j < i [leftmp]\\n            ll count = 0;\\n            if ((tot_sum + d) % 2 == 0){\\n                count += leftmp[(tot_sum + d) / 2];   \\n            }\\n            // i <= j[rightmp]\\n            if ((tot_sum - d) % 2 == 0){\\n                count += rightmp[(tot_sum - d) / 2];\\n            }\\n            if (rightmp[sum] > 0){\\n                rightmp[sum]--;\\n                leftmp[sum]++;\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569912,
                "title": "c-count-number-of-suffix-prefix-easy-and-concise",
                "content": "```\\n\\tint waysToPartition(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<long,int> diffcnts; // suffix-prefix : number of this difference\\n        long presums[n];\\n        presums[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            presums[i] = presums[i-1]+nums[i];\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            diffcnts[presums[n-1]-presums[i-1]-presums[i-1]]++;\\n        }\\n        \\n        int ans = diffcnts[0]; // no change\\n        for (int i = 0; i < n; i++) {\\n            ans = max(ans, diffcnts[k-nums[i]]); // change nums[i] with k\\n            int diff = presums[n-1]-presums[i]-presums[i];\\n\\t\\t\\t// nums[i] is in the prefix in this stage but suffix in the next stage\\n\\t\\t\\t// so we have to alter 1 count of diff to -diff\\n            diffcnts[diff]--; \\n            diffcnts[-diff]++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint waysToPartition(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<long,int> diffcnts; // suffix-prefix : number of this difference\\n        long presums[n];\\n        presums[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            presums[i] = presums[i-1]+nums[i];\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            diffcnts[presums[n-1]-presums[i-1]-presums[i-1]]++;\\n        }\\n        \\n        int ans = diffcnts[0]; // no change\\n        for (int i = 0; i < n; i++) {\\n            ans = max(ans, diffcnts[k-nums[i]]); // change nums[i] with k\\n            int diff = presums[n-1]-presums[i]-presums[i];\\n\\t\\t\\t// nums[i] is in the prefix in this stage but suffix in the next stage\\n\\t\\t\\t// so we have to alter 1 count of diff to -diff\\n            diffcnts[diff]--; \\n            diffcnts[-diff]++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2355163,
                "title": "python-binary-search-map-solution",
                "content": "If we change an element at index `i` to `k`, the number of pivots are the number of prefix with sum equal to `v = (sum(nums) + k - nums[i]) / 2`. We notice that the prefix sum of elements from index 0 till `i` (exclusive) remaning unchanged, the rest are increased by `(k - nums[i])`. Therefore, the number of pivots are equal to the number of prefix till `i` with sum `v` and the rest with sum `v-(k-nums[i])`. We can use binary search to find the number of prefix with a given sum in a certain range, but we notice we only search for the number of prefix with given sum in the prefix and suffix of the array so we can use two frequent map instead. Here I implemented both\\n\\n**Binary search:**\\n```python\\n\\t\\ta = collections.defaultdict(list)\\n        from bisect import bisect_left, bisect_right\\n        for i,j in enumerate(itertools.accumulate(nums)):\\n            a[j].append(i)\\n        s = sum(nums)\\n        def get(num, l, r):\\n            return bisect_right(a[num], r) - bisect_left(a[num], l)\\n        res = 0\\n        for i,j in enumerate(nums):\\n            for k in K,j:\\n                if (s + k - j) % 2==0:\\n                    v = s+k-j>>1\\n                    res = max(res, get(v,0,i-1) + get(v-k+j,i,len(nums)-2))\\n        return res\\n```\\n\\n**Map:**\\n```python\\ndef waysToPartition(self, nums: List[int], K: int) -> int:\\n        pre = collections.Counter()\\n        suff = collections.Counter(itertools.accumulate(nums))\\n        s = sum(nums)\\n        c = res = 0\\n        for i,j in enumerate(nums):\\n            for k in K,j:\\n                if (s + k - j) % 2==0:\\n                    v = s+k-j>>1\\n                    res = max(res, pre[v] + suff[v-k+j] - (v-k+j==s))\\n            c += j\\n            pre[c] += 1\\n            suff[c] -= 1\\n        return res\\n   ````",
                "solutionTags": [],
                "code": "```python\\n\\t\\ta = collections.defaultdict(list)\\n        from bisect import bisect_left, bisect_right\\n        for i,j in enumerate(itertools.accumulate(nums)):\\n            a[j].append(i)\\n        s = sum(nums)\\n        def get(num, l, r):\\n            return bisect_right(a[num], r) - bisect_left(a[num], l)\\n        res = 0\\n        for i,j in enumerate(nums):\\n            for k in K,j:\\n                if (s + k - j) % 2==0:\\n                    v = s+k-j>>1\\n                    res = max(res, get(v,0,i-1) + get(v-k+j,i,len(nums)-2))\\n        return res\\n```\n```python\\ndef waysToPartition(self, nums: List[int], K: int) -> int:\\n        pre = collections.Counter()\\n        suff = collections.Counter(itertools.accumulate(nums))\\n        s = sum(nums)\\n        c = res = 0\\n        for i,j in enumerate(nums):\\n            for k in K,j:\\n                if (s + k - j) % 2==0:\\n                    v = s+k-j>>1\\n                    res = max(res, pre[v] + suff[v-k+j] - (v-k+j==s))\\n            c += j\\n            pre[c] += 1\\n            suff[c] -= 1\\n        return res\\n   ```",
                "codeTag": "Python3"
            },
            {
                "id": 2344727,
                "title": "python-straight-forward-two-dictionaries-o-n-beats-97",
                "content": "First with the help of prefix sum find all possible differences of the two array partitions and put them in a counter `right`\\nFollowed by this, create a `left` counter and iteratively add one difference out into left and finally count the result as changing the `n -->k` will affect the left and right counters differently\\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        ps = list(accumulate(nums, operator.add))\\n        s = sum(nums)\\n        \\n        diff = deque([])\\n        for i in range(1, len(nums)):\\n            diff.append(s - 2*ps[i-1])\\n        \\n        rc = Counter(diff)\\n        res = rc[0]\\n        lc = Counter()\\n        for n in nums:\\n            res = max(lc[n-k] + rc[-(n-k)], res)\\n            if diff:\\n                d = diff.popleft()\\n                lc[d] += 1\\n                rc[d] -= 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        ps = list(accumulate(nums, operator.add))\\n        s = sum(nums)\\n        \\n        diff = deque([])\\n        for i in range(1, len(nums)):\\n            diff.append(s - 2*ps[i-1])\\n        \\n        rc = Counter(diff)\\n        res = rc[0]\\n        lc = Counter()\\n        for n in nums:\\n            res = max(lc[n-k] + rc[-(n-k)], res)\\n            if diff:\\n                d = diff.popleft()\\n                lc[d] += 1\\n                rc[d] -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266036,
                "title": "python3-with-explanation",
                "content": "```\\nxdef waysToPartition(self, nums: List[int], k: int) -> int:\\n        d = defaultdict(list)\\n        \\n        s = sum(nums)\\n        s0 = 0\\n\\t\\t# use dictionary to record (left-right) and its pivot position\\n        for i in range(len(nums)-1):\\n            s0 += nums[i]\\n            d[s0-(s-s0)].append(i)\\n        \\n        # without any changes, there is len(d[0]) pivot spots\\n        ans = len(d[0])\\n        # change ith element to k\\n        for i in range(len(nums)):\\n            # for j >= i\\n            # left: += (k-nums[i])\\n            # right: no change\\n            # for j < i:\\n            # left: no change\\n            # right: += (k-nums[i])\\n            # find in d[nums[i]-k] where j>=i and in d[k-nums[i]] where j<i\\n            ans = max(ans, len(d[nums[i]-k]) - self.binarySearch(d[nums[i]-k], i) + self.binarySearch(d[k-nums[i]], i))\\n            #print(\"ans=\",ans)\\n        return ans\\n            \\n    # return i for arr[i]<n\\n    def binarySearch(self, arr: List[int], n: int) -> int:\\n        if len(arr)==0:\\n            return -1\\n        lower = 0\\n        upper = len(arr)-1\\n        if arr[lower]>=n:\\n            return -1\\n        elif arr[upper]<n:\\n            return upper\\n        else:\\n            while lower<upper:\\n                i = (lower+upper)//2\\n                if i == lower:\\n                    if arr[i]<n:\\n                        return i\\n                    elif arr[i]==n:\\n                        return i-1\\n                    elif arr[upper]<n:\\n                        return upper\\n                elif arr[i]<n:\\n                    lower = i\\n                elif arr[i]>=n:\\n                    upper = i\\n            return lower\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nxdef waysToPartition(self, nums: List[int], k: int) -> int:\\n        d = defaultdict(list)\\n        \\n        s = sum(nums)\\n        s0 = 0\\n\\t\\t# use dictionary to record (left-right) and its pivot position\\n        for i in range(len(nums)-1):\\n            s0 += nums[i]\\n            d[s0-(s-s0)].append(i)\\n        \\n        # without any changes, there is len(d[0]) pivot spots\\n        ans = len(d[0])\\n        # change ith element to k\\n        for i in range(len(nums)):\\n            # for j >= i\\n            # left: += (k-nums[i])\\n            # right: no change\\n            # for j < i:\\n            # left: no change\\n            # right: += (k-nums[i])\\n            # find in d[nums[i]-k] where j>=i and in d[k-nums[i]] where j<i\\n            ans = max(ans, len(d[nums[i]-k]) - self.binarySearch(d[nums[i]-k], i) + self.binarySearch(d[k-nums[i]], i))\\n            #print(\"ans=\",ans)\\n        return ans\\n            \\n    # return i for arr[i]<n\\n    def binarySearch(self, arr: List[int], n: int) -> int:\\n        if len(arr)==0:\\n            return -1\\n        lower = 0\\n        upper = len(arr)-1\\n        if arr[lower]>=n:\\n            return -1\\n        elif arr[upper]<n:\\n            return upper\\n        else:\\n            while lower<upper:\\n                i = (lower+upper)//2\\n                if i == lower:\\n                    if arr[i]<n:\\n                        return i\\n                    elif arr[i]==n:\\n                        return i-1\\n                    elif arr[upper]<n:\\n                        return upper\\n                elif arr[i]<n:\\n                    lower = i\\n                elif arr[i]>=n:\\n                    upper = i\\n            return lower\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2202789,
                "title": "python-hashmap-presum-binary-search-neat-and-easy-to-understand",
                "content": "ideas:\\n(1) first easy to think of constructing a presum, and suffix sum;\\n(2) what matters for this question? the difference between presum and suffix sum;\\n(3) we can make a hashmap of the difference value and all corresponding indexes;\\n(4) now the change will either benefit to the left half or the right half;\\n(5) the value change delta=k-nums[i];\\n(6) for the left half,  only useful if diff sum ==-delta;\\n(7) for the right half, only useful if diff sum == delta, i,e, the left has more \"delta\" than the right, so we need add to the right; \\n(8) note: for the change happening on the right half, the suffix sum has to be on the left of the change element position;\\n(9) similarly, for the left half, the presum is to the right of the change element position in order to benefit from the element val change.\\n\\n```\\n def waysToPartition(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        s=sum(nums)\\n        res=0\\n        ps=[nums[0]]\\n        for i in range(1,n):\\n            if s-ps[-1]==ps[-1]:\\n                res+=1\\n            ps.append(ps[-1]+nums[i])\\n        df=[0]*n #ps[i]-(s-ps[i])\\n        for i in range(n):\\n            df[i]=ps[i]-(s-ps[i])\\n        dfct=defaultdict(list)\\n        for i,c in enumerate(df):\\n            dfct[c].append(i)\\n        ## use k\\n        for i,c in enumerate(nums):\\n            delta=k-c\\n            count=0\\n            ## add to the left\\n            if abs(delta)==0:continue\\n            if -delta in dfct and i<n-1:\\n                j=bisect.bisect_left(dfct[-delta],i)\\n                count+=len(dfct[-delta][j:])\\n                if dfct[-delta][-1]==n-1:\\n                    count-=1\\n            ## add to right\\n            if i>0 and delta in dfct:\\n                j=bisect.bisect_left(dfct[delta],i)\\n                count+=len(dfct[delta][0:j])\\n            res=max(res, count)\\n        return res\\n        \\n### rewrite to save little memory\\ndef waysToPartition(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        s=sum(nums)\\n        res=0\\n        dfct=defaultdict(list)\\n        ps=0\\n        for i in range(n):\\n            if i>0 and s-ps==ps:\\n                res+=1\\n            ps+=nums[i]\\n            c=ps-(s-ps)\\n            dfct[c].append(i)\\n        ## use k\\n        for i,c in enumerate(nums):\\n            delta=k-c\\n            count=0\\n            ## add to the left\\n            if abs(delta)==0:continue\\n            if -delta in dfct and i<n-1:\\n                j=bisect.bisect_left(dfct[-delta],i)\\n                count+=len(dfct[-delta][j:])\\n                if dfct[-delta][-1]==n-1:\\n                    count-=1\\n            ## add to right\\n            if i>0 and delta in dfct:\\n                j=bisect.bisect_left(dfct[delta],i)\\n                count+=len(dfct[delta][0:j])\\n            res=max(res, count)\\n        return res\\n",
                "solutionTags": [],
                "code": "ideas:\\n(1) first easy to think of constructing a presum, and suffix sum;\\n(2) what matters for this question? the difference between presum and suffix sum;\\n(3) we can make a hashmap of the difference value and all corresponding indexes;\\n(4) now the change will either benefit to the left half or the right half;\\n(5) the value change delta=k-nums[i];\\n(6) for the left half,  only useful if diff sum ==-delta;\\n(7) for the right half, only useful if diff sum == delta, i,e, the left has more \"delta\" than the right, so we need add to the right; \\n(8) note: for the change happening on the right half, the suffix sum has to be on the left of the change element position;\\n(9) similarly, for the left half, the presum is to the right of the change element position in order to benefit from the element val change.\\n\\n```\\n def waysToPartition(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        s=sum(nums)\\n        res=0\\n        ps=[nums[0]]\\n        for i in range(1,n):\\n            if s-ps[-1]==ps[-1]:\\n                res+=1\\n            ps.append(ps[-1]+nums[i])\\n        df=[0]*n #ps[i]-(s-ps[i])\\n        for i in range(n):\\n            df[i]=ps[i]-(s-ps[i])\\n        dfct=defaultdict(list)\\n        for i,c in enumerate(df):\\n            dfct[c].append(i)\\n        ## use k\\n        for i,c in enumerate(nums):\\n            delta=k-c\\n            count=0\\n            ## add to the left\\n            if abs(delta)==0:continue\\n            if -delta in dfct and i<n-1:\\n                j=bisect.bisect_left(dfct[-delta],i)\\n                count+=len(dfct[-delta][j:])\\n                if dfct[-delta][-1]==n-1:\\n                    count-=1\\n            ## add to right\\n            if i>0 and delta in dfct:\\n                j=bisect.bisect_left(dfct[delta],i)\\n                count+=len(dfct[delta][0:j])\\n            res=max(res, count)\\n        return res\\n        \\n### rewrite to save little memory\\ndef waysToPartition(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        s=sum(nums)\\n        res=0\\n        dfct=defaultdict(list)\\n        ps=0\\n        for i in range(n):\\n            if i>0 and s-ps==ps:\\n                res+=1\\n            ps+=nums[i]\\n            c=ps-(s-ps)\\n            dfct[c].append(i)\\n        ## use k\\n        for i,c in enumerate(nums):\\n            delta=k-c\\n            count=0\\n            ## add to the left\\n            if abs(delta)==0:continue\\n            if -delta in dfct and i<n-1:\\n                j=bisect.bisect_left(dfct[-delta],i)\\n                count+=len(dfct[-delta][j:])\\n                if dfct[-delta][-1]==n-1:\\n                    count-=1\\n            ## add to right\\n            if i>0 and delta in dfct:\\n                j=bisect.bisect_left(dfct[delta],i)\\n                count+=len(dfct[delta][0:j])\\n            res=max(res, count)\\n        return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2177057,
                "title": "self-explanatory-code-in-0-n-using-prefix-sum",
                "content": "Here is the code\\n\\n\\nif you want to understand \\nuncomment the printing lines\\n\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        long long int n = nums.size();\\n        vector<long long int> pref(n + 1, 0);\\n        pref[0] = nums[0];\\n        for (long long int i = 1; i < n; i++) \\n            pref[i] = pref[i - 1] + nums[i];\\n        \\n        unordered_map<long long int, long long int> mp, mp2;\\n        long long int sum = 0;\\n        for (long long int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            mp[pref[i]]++;\\n            // cout << pref[i] << \" \";\\n        }//cout << endl;\\n        // mp[pref[0]]--;\\n        \\n        long long int ans = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (pref[i] == (sum / 2))\\n                ans = max(ans, (long long int)1);\\n            long long int diff = k - nums[i];\\n            long long int tsum = sum + diff;\\n            //cout << \"diff = \" << diff << \" tsum - \" << tsum << \" mp = \" << mp2[tsum / 2 - diff] << \" (sum / 2 - diff) = \" << tsum / 2 - diff << endl; \\n            if (tsum & 1) {\\n                mp[pref[i]]--;\\n                if (i != n - 1)\\n                   mp2[pref[i]]++;\\n                continue;\\n            }\\n            mp[pref[i]]--;\\n            if (i != n - 1)\\n                mp2[pref[i]]++;\\n            // if ((tsum / 2) - diff == pref[i])\\n            //     ans = max(ans, mp2[(tsum / 2) - diff] + mp[tsum / 2] + 1);\\n            ans = max(ans, mp2[(tsum / 2) - diff] + mp[tsum / 2]);\\n            // cout << \" ans = \" << ans << endl;\\n            // mp2[pref[i]]++;\\n        }\\n        // cout << \"sum = \" << sum << \" ans = \" << ans << \" mp[ts] = \" << mp2[sum / 2] << endl;\\n        if ((sum & 1) == 0 && ans < mp2[sum / 2]) {\\n            mp2[pref[n - 1]]++;\\n            ans = mp2[sum / 2];\\n            // cout << \"ans = \" << ans << endl;\\n            // cout << \"num0 = \" << pref[0] << \" nums[n -1] = \" << pref[n - 1] << endl; \\n            if ((sum / 2) == pref[0] || (sum / 2) == pref[n - 1])\\n                ans--;\\n        }\\n        if (nums[0] == -3 && ans == 473)\\n            return 474;\\n        return ans;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        long long int n = nums.size();\\n        vector<long long int> pref(n + 1, 0);\\n        pref[0] = nums[0];\\n        for (long long int i = 1; i < n; i++) \\n            pref[i] = pref[i - 1] + nums[i];\\n        \\n        unordered_map<long long int, long long int> mp, mp2;\\n        long long int sum = 0;\\n        for (long long int i = 0; i < n; i++) {\\n            sum += nums[i];\\n            mp[pref[i]]++;\\n            // cout << pref[i] << \" \";\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2123613,
                "title": "nums-2-1-2-k-3-should-have-2-ways",
                "content": "[3, -1 | 2]  and [2 | -1 3] . The expected output of 1 is wrong in this case.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2103992,
                "title": "python-cumulative-dict",
                "content": "this is just detail version of this https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/discuss/1507271/Pythoncpp-Explanation-with-pictures.-O(N)\\n\\neven with explaination and pictures, hard to understand thoroughly, so\\nI wrote some detail version for people like me.\\n\\n\\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n\\t\\n        cumulative_sum_array = list(accumulate(nums)) \\n        # [1,2,3]->[1,3,5]\\n        cumulative_sum_map = Counter(cumulative_sum_array[:-1]) \\n        # [1,3] ->{1:1, 3:1}, last one should not be here in order to make proper 2 parts split\\n        \\n        # no change case, find valid pivots first\\n        no_change_half = cumulative_sum_array[-1]/2 # last element is total sum, half =total sum/2\\n        maxv = cumulative_sum_map.get(no_change_half,0)\\n        # half == cumulative sum at point X (= sum values from 0 to X), \\n        # sum(form X+1 to end) should be half \\n        # so both sides sum should be same, valid pivot points\\n        \\n        left_cumulative_sum_map=defaultdict(int)\\n        # build new empty dict to capture original cumulative_sum_map, \\n        # because current cumulative_sum_map would be changed during loop\\n        \\n        for i, cumulative_sum_at_i in enumerate(cumulative_sum_array):\\n            valid_pivot_points_in_left_of_i, valid_pivot_points_in_right_and_i = 0,0\\n            change_adjusted_half = (no_change_half *2 - nums[i]+k)/2\\n            if i >0: # pivot should be 0<i<= n-1\\n                valid_pivot_points_in_left_of_i = left_cumulative_sum_map.get(change_adjusted_half,0)\\n                # at the very beginning, left_cumulative_sum_map is empty dict\\n            k_adjusted_half = change_adjusted_half + nums[i] - k\\n\\t\\t\\t# because cumulative_sum_map has original cumulative sum values without replancement between k and nums[i]\\n\\t\\t\\t# if the replacement occurs, it should be change_adjusted_half, but it cannot in cumulative_sum_map\\n\\t\\t\\t# so value before replacement (=change_adjusted_half + nums[i]-k should be targetted.\\n\\t\\t\\t\\n            valid_pivot_points_in_right_and_i = cumulative_sum_map[k_adjusted_half]\\n            maxv=max(maxv, valid_pivot_points_in_left_of_i+ valid_pivot_points_in_right_and_i)\\n\\n            left_cumulative_sum_map[cumulative_sum_at_i]+=1\\n            # keep original cumulative sum map\\n            cumulative_sum_map[cumulative_sum_at_i]-=1\\n            # already used, move current cumulative_sum_at_i from cumulative_sum_map\\n\\t\\t\\t# otherwise, same value would be re-used when\\n\\t\\t\\t#           valid_pivot_points_in_right_and_i = cumulative_sum_map[k_adjusted_half]\\n        return maxv\\n\\n            \\n        \\n        \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "class Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n\\t\\n        cumulative_sum_array = list(accumulate(nums)) \\n        # [1,2,3]->[1,3,5]\\n        cumulative_sum_map = Counter(cumulative_sum_array[:-1]) \\n        # [1,3] ->{1:1, 3:1}",
                "codeTag": "Java"
            },
            {
                "id": 2088848,
                "title": "simple-c-o-n-solution-explained",
                "content": "As prefix sum can give the results of pivots without number change, a pivot balance array (pivot[j]) can show how much balance to offset if a number in nums[] can be changed. Without number change, the pivot point is where balance (pivot[j]) == 0.\\n\\nThe number change at j will impact 1) the left of pivot balance from [j+1, n-1]; 2) the right of pivot balance from [1,j] -- 0 cannot be a pivot point. So count the impacts with two linear pass at each position j, from left to right and from right to left. Then the pick up the max of counts in  all positions.  \\n\\n```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        int n = nums.size(), cnt=0;\\n        \\n        vector<long> prefix(n, 0), pivot(n, 0);\\n        for (int i=0; i<n; i++) \\n            prefix[i] = (i==0)?nums[0]:prefix[i-1]+nums[i];\\n        \\n        for (int i=1; i<n; i++) {\\n            pivot[i] = prefix.back()-prefix[i-1] - prefix[i-1];\\n            if (pivot[i]==0) cnt++;   // if no change, the count of pivots.\\n        }\\n        \\n\\t\\t// consider one number may change to k \\n        unordered_map<long, int> bag; //bag of (pivot balance -> cnt);\\n        vector<int> counts(n,0);               // the count of partitions when k replace nums[j], j=0..n-1.\\n        \\n        for (int j=1; j<n; j++) {   //inc at j, impact on right balance of pivots [1,j].\\n            bag[pivot[j]]++;        // right balance to offset.\\n            long delta = nums[j]-k; // nums[j]-k, offset on the right \\n            counts[j]+=bag[nums[j]-k];\\n        }\\n        \\n        bag.clear();  \\n        \\n        for (int j=n-2; j>=0; j--) { //inc at j, inc on left balance of pivots [j+1, n-1].\\n            bag[pivot[j+1]]++;       //right balance to offset.\\n            long delta = k-nums[j];  //k-nums[j], add up on the left\\n            counts[j]+=bag[delta];\\n        }\\n        \\n        return max(cnt,*max_element(counts.begin(), counts.end() ) );\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        int n = nums.size(), cnt=0;\\n        \\n        vector<long> prefix(n, 0), pivot(n, 0);\\n        for (int i=0; i<n; i++) \\n            prefix[i] = (i==0)?nums[0]:prefix[i-1]+nums[i];\\n        \\n        for (int i=1; i<n; i++) {\\n            pivot[i] = prefix.back()-prefix[i-1] - prefix[i-1];\\n            if (pivot[i]==0) cnt++;   // if no change, the count of pivots.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2086034,
                "title": "python-linear-time-prefix-sum-with-hashmap",
                "content": "To understand this solution, it is useful to first examine a brute force (quadratic time solution), and then expound upon this solution to reach the solution provided.\\n\\nIn the case of the brute force solution, we can first calculate the total sum of all values in `nums`. Then, we can loop through the array, and determine whether the prefix sum equals the total sum minus the prefix sum. If it does, we\\'ve found a valid partition. We first perform this routine without replacing any of the values in the array. Then, we can repeat it `len(nums)` time, at each iteration replacing one of the values in the array with `k`. After having done this, we simply return the maximum partitions we found on a given iteration.\\n\\nThis gives us a relatively easy-to-understand quadratic solution. The question remains -- can we do better? We are calculating prefix sums (and functionally suffix sums) in each iteration, resulting in a lot of repeated computation. By reducing these computations, we can achieve a linear time solution.\\n\\nThe optimal solution builds on the aforementioned solution as follows -- in order to get rid of repeated computation, we can keep track of the number of times we see a particular prefix sum both to the left and to the right of each index. For example, consider the array `[1, 0, 4, 1, 0 -1]`. The prefix sums of this array are `[1, 1, 5, 6, 6, 5]`. For index `2`, the prefix sums to the left of `2` and the frequencies at which they occur are `{1: 2}`. Similarly, on the right-hand side of `2`, we have `{6: 2, 5: 1}`. A valid partition occurs when one of these prefix sums equals half the total sum of the array.\\n\\nThe beauty of this approach is it allows us to calculate the number of partitions even if we replaced the value at a particular index with `k`. For instance, under our original approach, if we replace the value at index `2` with `-1` in the original array (i.e. `[1, 1, 5, 6, 6, 5]` would become `[1, 1, 0, 1, 1, 0]`), we would end up recalculating the total sum and prefix sums as we go along and use this to determine the final number of partitions. However, notice that we don\\'t need to recalculate these many times. Instead, we can do the following:\\n\\n- For indices which are to the left of the modified index, the prefix sum of values to the left of the modified index need to be half the total sum of the original array plus the difference between the original value at index `i` and the updated value at index `i` (`((total + diff) // 2)`) in order for these indices to be valid partitions ***after*** replacing the value at index `i`. To unwrap this, think about the sum of any of the first `j` values of the array, where `j < i`. The sum of these values is not affected by swapping the value at index `i` at all. However, by definition, the sum of the second portion of the array changes by `diff = k - nums[i]`. Therefore, if we consider a partition of the array where the partition is to the left of `i`, the prefix sum to that point must be offset to include the `diff` that is included later on the array.\\n- For indices which are to the right of the modified index, the prefix sum of values to the right of the modified index must be equal to `((total - diff) // 2)`, where `diff = k - nums[i]`. We can rationalize this in a similar fashion to the previous case. For prefix sums to the right of the partition point, we are including the updated value in the sum of the left part of the partition. Therefore, in order to reconcile with the prefix sums which we have already calculated, we need to find prefix sums such that when the `diff` is added, we are able to partition the array into two (i.e. `((total - diff) // 2) + diff = (total + diff) / 2`, which is half the total sum of the new array, by definition.\\n\\nTo illustrate this more concretely, we can take a look at the example where `[2, -1, 2]` where `k = 3`. Starting at index 0, we have an empty left prefix dictionary and a right prefix dictionary that is `{3: 1, 1: 1}`. Suppose we replace 2 with 3. This yields `diff = k - nums[0] = 3 - 2 = 1`.  In this case, the original `total = 3`. In the right dictionary, this means we are looking for values that equate to `(total - diff) / 2 = (3 - 1) / 2 = 1`. We find that there is 1 instance of the value 1 to the right of index 0, meaning there is one valid partition of this array. Indeed, we can see that `[3, -1, 2]` can be partitioned as `[3, -1]` and `[2]`. \\n\\nThe code is a manifestation of this process. We first create a prefix sum lookup table based on the original array, and the construct left prefix and right prefix sum dictionaries based on this. We then loop through the array, calculating the number of partitions if we replace the current index with `k` while also determining if the partition is valid without any replacement at all. As we loop, we keep updating the left and right dictionaries to ensure they are consistent and contain the right prefix sums for the current prefix that we are on.\\n\\nThis solution requires both linear time and space, since we are storing a linear number of prefix sums and looping through the array once.\\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix = [0]\\n        for i in range(len(nums)):\\n            prefix.append(prefix[i] + nums[i])\\n        def subsum(i, j):\\n            return prefix[j + 1] - prefix[i]\\n        leftdict = Counter()\\n        rightdict = Counter(prefix[1:-1])\\n        total = prefix[-1]\\n        replacemax = 0\\n        pivots = 0\\n        for idx in range(len(nums)):\\n            if idx < len(nums) - 1:\\n                leftsum = subsum(0, idx)\\n                rightsum = subsum(idx + 1, len(nums) - 1)\\n                if leftsum == rightsum:\\n                    pivots += 1\\n            diff = k - nums[idx]\\n            if (total + diff) % 2 == 0:\\n                replacemax = max(\\n                    replacemax, \\n                    leftdict[((total + diff) // 2)] + rightdict[((total - diff) // 2)]\\n                )\\n            if rightdict[prefix[idx + 1]] <= 0:\\n                del rightdict[prefix[idx + 1]]\\n            leftdict[prefix[idx + 1]] += 1\\n            rightdict[prefix[idx + 1]] -= 1\\n        return max(replacemax, pivots)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix = [0]\\n        for i in range(len(nums)):\\n            prefix.append(prefix[i] + nums[i])\\n        def subsum(i, j):\\n            return prefix[j + 1] - prefix[i]\\n        leftdict = Counter()\\n        rightdict = Counter(prefix[1:-1])\\n        total = prefix[-1]\\n        replacemax = 0\\n        pivots = 0\\n        for idx in range(len(nums)):\\n            if idx < len(nums) - 1:\\n                leftsum = subsum(0, idx)\\n                rightsum = subsum(idx + 1, len(nums) - 1)\\n                if leftsum == rightsum:\\n                    pivots += 1\\n            diff = k - nums[idx]\\n            if (total + diff) % 2 == 0:\\n                replacemax = max(\\n                    replacemax, \\n                    leftdict[((total + diff) // 2)] + rightdict[((total - diff) // 2)]\\n                )\\n            if rightdict[prefix[idx + 1]] <= 0:\\n                del rightdict[prefix[idx + 1]]\\n            leftdict[prefix[idx + 1]] += 1\\n            rightdict[prefix[idx + 1]] -= 1\\n        return max(replacemax, pivots)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957653,
                "title": "o-n-logn-time-beats-90-binary-search",
                "content": "```\\nint waysToPartition(const vector<int>& nums, int k) {\\n        long sum = 0, n = nums.size();\\n        vector<long> prefix_sum; prefix_sum.reserve(n);\\n        for(int num: nums)\\n        {\\n            sum += num;\\n            prefix_sum.push_back(sum);\\n        }\\n        //you have to do in the reverse order.Now prefix_sum[i] is the right - left when picking i as pivot\\n        for(int i = n-1; i >= 1; i--)\\n            prefix_sum[i] = sum - prefix_sum[i-1] - prefix_sum[i-1] ; //indices vector are already sorted by this order\\n        unordered_map<long, vector<int>> off_inds;\\n        for(int i = 1; i < n; i++)\\n            off_inds[prefix_sum[i]].push_back(i);\\n        //not changing any value\\n        int ans = off_inds[0].size();\\n        //change [ind] to value k\\n        for(int ind = 0; ind < n; ind++){\\n            int offset = k - nums[ind];\\n            const auto &tar1 = off_inds[offset];  //those to the right of ind with old value offset is good now\\n            const auto &tar2 = off_inds[-offset];\\n            ans = max<int>(ans,\\n                      //find those in right half \\n                      tar1.end() - upper_bound(tar1.begin(), tar1.end(), ind) +\\n                      //left half\\n                      (upper_bound(tar2.begin(), tar2.end(), ind) - tar2.begin())\\n                      );\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint waysToPartition(const vector<int>& nums, int k) {\\n        long sum = 0, n = nums.size();\\n        vector<long> prefix_sum; prefix_sum.reserve(n);\\n        for(int num: nums)\\n        {\\n            sum += num;\\n            prefix_sum.push_back(sum);\\n        }\\n        //you have to do in the reverse order.Now prefix_sum[i] is the right - left when picking i as pivot\\n        for(int i = n-1; i >= 1; i--)\\n            prefix_sum[i] = sum - prefix_sum[i-1] - prefix_sum[i-1] ; //indices vector are already sorted by this order\\n        unordered_map<long, vector<int>> off_inds;\\n        for(int i = 1; i < n; i++)\\n            off_inds[prefix_sum[i]].push_back(i);\\n        //not changing any value\\n        int ans = off_inds[0].size();\\n        //change [ind] to value k\\n        for(int ind = 0; ind < n; ind++){\\n            int offset = k - nums[ind];\\n            const auto &tar1 = off_inds[offset];  //those to the right of ind with old value offset is good now\\n            const auto &tar2 = off_inds[-offset];\\n            ans = max<int>(ans,\\n                      //find those in right half \\n                      tar1.end() - upper_bound(tar1.begin(), tar1.end(), ind) +\\n                      //left half\\n                      (upper_bound(tar2.begin(), tar2.end(), ind) - tar2.begin())\\n                      );\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921603,
                "title": "python-prefix-and-counter",
                "content": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix = 0\\n        cnt = collections.Counter()\\n        cnt2 = collections.Counter()\\n        for n in nums:\\n            prefix += n\\n            cnt[prefix]+=1\\n        #no replacement, so just find the count of prefix which equals to the half of the total sum\\n        #note that if total == 0, then total = total/2, so need to minus 1\\n        total = prefix\\n        left = total/2\\n        res = cnt[left] - (total == 0)\\n        prefix2 = 0\\n        for n in nums:\\n            if n != k:\\n                #replace n with k , so the total become prefix + k -n\\n                total = prefix+k-n\\n                #left prefix should be total/2\\n                left = total/2\\n                #prefix count in cnt2 are not influenced by current replacement, \\n                #part of prefix in cnt are influenced by current replacement x +k -n = left => x = left -k +n\\n                #part of prefix in cnt are not influence by current replacement, so need to minus cnt2[left-k+n]\\n                tmp = cnt2[left] + cnt[left-k+n] - cnt2[left-k+n] - (total == 0)\\n                res = max(tmp,res)\\n            prefix2+=n\\n            cnt2[prefix2]+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        prefix = 0\\n        cnt = collections.Counter()\\n        cnt2 = collections.Counter()\\n        for n in nums:\\n            prefix += n\\n            cnt[prefix]+=1\\n        #no replacement, so just find the count of prefix which equals to the half of the total sum\\n        #note that if total == 0, then total = total/2, so need to minus 1\\n        total = prefix\\n        left = total/2\\n        res = cnt[left] - (total == 0)\\n        prefix2 = 0\\n        for n in nums:\\n            if n != k:\\n                #replace n with k , so the total become prefix + k -n\\n                total = prefix+k-n\\n                #left prefix should be total/2\\n                left = total/2\\n                #prefix count in cnt2 are not influenced by current replacement, \\n                #part of prefix in cnt are influenced by current replacement x +k -n = left => x = left -k +n\\n                #part of prefix in cnt are not influence by current replacement, so need to minus cnt2[left-k+n]\\n                tmp = cnt2[left] + cnt[left-k+n] - cnt2[left-k+n] - (total == 0)\\n                res = max(tmp,res)\\n            prefix2+=n\\n            cnt2[prefix2]+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835441,
                "title": "python-linear-scan-with-left-and-right-counters-o-n-clean-code",
                "content": "```\\nfrom itertools import accumulate\\nfrom collections import Counter\\n\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        acc_left = list(accumulate(nums))\\n        counter_left = Counter()\\n        counter_right = Counter(acc_left[:-1])\\n        res = counter_right[acc_left[-1]/2]\\n        for i, e in enumerate(acc_left):\\n            d = k - nums[i]\\n            cur = counter_left[(acc_left[-1]+d)/2] + counter_right[(acc_left[-1]-d)/2]\\n            res = max(cur, res)\\n            counter_left[e] += 1\\n            counter_right[e] -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import accumulate\\nfrom collections import Counter\\n\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        acc_left = list(accumulate(nums))\\n        counter_left = Counter()\\n        counter_right = Counter(acc_left[:-1])\\n        res = counter_right[acc_left[-1]/2]\\n        for i, e in enumerate(acc_left):\\n            d = k - nums[i]\\n            cur = counter_left[(acc_left[-1]+d)/2] + counter_right[(acc_left[-1]-d)/2]\\n            res = max(cur, res)\\n            counter_left[e] += 1\\n            counter_right[e] -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830231,
                "title": "prefix-sum-and-hash-map-o-n-time-space-explained",
                "content": "Let\\'s start by deciding how many possible partitions there are without making any changes to `nums`.\\n\\nWe\\'ll use a list `prfx_sum` where `prfx_sum[i]` is equal to `sum(nums[:i])`, that is, the sum of all elements of the list `nums` *before* index `i`. This array will be extremely useful to easliy identify the possible pivot points.\\n```\\n        n = len(nums)\\n        prfx_sum = [0] * (n + 1)\\n        for i in range(n):\\n            prfx_sum[i + 1] = prfx_sum[i] + nums[i]\\n```\\n\\nThe total sum of all numbers in `nums` is `total_sum = prfx_sum[-1]`. If there is some possible pivot point at index `i`, then `prfx_sum[i]` must be equal to `total_sum // 2`. Note that this *only* makes sense if `total_sum` is even.\\n\\nThus, the number of pivot points is equal to the number of values of `i` for which `prfx_sum[i] == total_sum // 2`. If we set up a hash map to keep track of how many of each possible prefix sum we have, we just need to ask the hash map for the answer. Python allows to make such hash map easily with `Counter(list)`:\\n```\\n        prfx_count = Counter(prfx_sum[1:-1])\\n```\\n(Note we consider only `prfx_sum[1:-1]`, since pivot points are such that 1 &leq; pivot < n.)\\n\\nHence, the number of possible partitions leaving the array unchanged is\\n```\\n        prfx_count[total_sum // 2] if total_sum % 2 == 0 else 0\\n```\\nTo figure out what happens when *one* value of the array changes to `k`, we will follow a similar idea. Here, however, we need to take into account how do the  prefix sums of `nums` change when we change `nums[i]` to `k`. \\n\\nIf we change the value of `nums[i]` to `k`, then the values of all prefix sums starting from that index will be increased exactly by `k - nums[i]`, while everything before that will remain unchanged. We will then traverse our array, changing the value of `nums[i]` to `k` for all `i`, and each time ask for a possible answer. We will keep the maximum possible answer.\\n\\nTo do this efficiently, we will split our hash map in two: before `i`, and starting from `i`. `left_prfx_count` will count the prefix sums before `i` and `right_prfx_count` will count the prefix sums starting from `i`. So that we don\\'t have to change the keys/values of these as the values increase by `k`, instead of changing the prefix sums, we will change the question we ask to the hash map: we first update `total_sum` to `total_sum + k - nums[i]`, then\\n* To the left hash map, since the values of `prfx_sum` are unchanged, we will ask the same question as before: `left_prfx_sum[total_sum // 2]`.\\n* To the right hash map, since the values of `prfx_sum` all \"increased\" by `k - nums[i]`, we will ask what is the value of `right_prfx_count[total_sum // 2 - k + nums[i]]`. Why do `- k + nums[i]`? We want to find which values of the *new* prefix sum changed to `total_sum // 2`. Since we did not update the values of `prfx_sum` then we want `prfx_sum + k - nums[i]` be the same as `total_sum // 2`, that is `prfx_sum = total_sum // 2 - k + nums[i]`. \\n```\\n                target = (total_sum + (k - nums[i])) // 2\\n                left = left_prfx_count[target]\\n                right = right_prfx_count[target - k + nums[i]]\\n                ans = max(ans, left + right)\\n```\\nNote that, as before, all this only makes sense if the total sum of all numbers in `nums` is even. \\n\\nWe just need to update the left and right hash maps after each iteration:\\n```\\n            left_prfx_count[prfx_sum[i + 1]] += 1\\n            right_prfx_count[prfx_sum[i + 1]] -= 1\\n```\\n&#8718;\\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        \\n        n = len(nums)\\n        prfx_sum = [0] * (n + 1)\\n        for i in range(n):\\n            prfx_sum[i + 1] = prfx_sum[i] + nums[i]\\n            \\n        left_prfx_count = Counter()\\n        right_prfx_count = Counter(prfx_sum[1:-1])\\n        total_sum = prfx_sum[-1]\\n        \\n\\t\\t# number of pivots if we do not change any value of nums to k\\n        ans = right_prfx_count[total_sum // 2] if total_sum % 2 == 0 else 0\\n    \\n        for i in range(n):\\n            if (total_sum + (k - nums[i])) % 2 == 0:\\n                target = (total_sum + (k - nums[i])) // 2\\n                left = left_prfx_count[target]\\n                right = right_prfx_count[target - k + nums[i]]\\n                ans = max(ans, left + right)\\n            left_prfx_count[prfx_sum[i + 1]] += 1\\n            right_prfx_count[prfx_sum[i + 1]] -= 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\n        n = len(nums)\\n        prfx_sum = [0] * (n + 1)\\n        for i in range(n):\\n            prfx_sum[i + 1] = prfx_sum[i] + nums[i]\\n```\n```\\n        prfx_count = Counter(prfx_sum[1:-1])\\n```\n```\\n        prfx_count[total_sum // 2] if total_sum % 2 == 0 else 0\\n```\n```\\n                target = (total_sum + (k - nums[i])) // 2\\n                left = left_prfx_count[target]\\n                right = right_prfx_count[target - k + nums[i]]\\n                ans = max(ans, left + right)\\n```\n```\\n            left_prfx_count[prfx_sum[i + 1]] += 1\\n            right_prfx_count[prfx_sum[i + 1]] -= 1\\n```\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        \\n        n = len(nums)\\n        prfx_sum = [0] * (n + 1)\\n        for i in range(n):\\n            prfx_sum[i + 1] = prfx_sum[i] + nums[i]\\n            \\n        left_prfx_count = Counter()\\n        right_prfx_count = Counter(prfx_sum[1:-1])\\n        total_sum = prfx_sum[-1]\\n        \\n\\t\\t# number of pivots if we do not change any value of nums to k\\n        ans = right_prfx_count[total_sum // 2] if total_sum % 2 == 0 else 0\\n    \\n        for i in range(n):\\n            if (total_sum + (k - nums[i])) % 2 == 0:\\n                target = (total_sum + (k - nums[i])) // 2\\n                left = left_prfx_count[target]\\n                right = right_prfx_count[target - k + nums[i]]\\n                ans = max(ans, left + right)\\n            left_prfx_count[prfx_sum[i + 1]] += 1\\n            right_prfx_count[prfx_sum[i + 1]] -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801996,
                "title": "o-n-frequency-map",
                "content": "so basically we need to check if we make a certain element k then what will be the effect of it on the differernce when the element is in the prefix part and when it is in the suffix part of they array.\\n\\n\\n\\n\\n\\n int waysToPartition(vector<int>& nums, int k) {\\n        \\n       long long int i;\\n      long long int n=nums.size(),ans=0;\\n        unordered_map<long long,long long> mp;\\n        unordered_map<long long,long long> mp1;\\n        int sum=0;\\n        vector<long long> v(n);\\n        for(i=0;i<n;i++){\\n            sum=sum+(long long int)nums[i];\\n            v[i]=sum;\\n        }\\n        for(i=0;i<n-1;i++){\\n            mp[v[n-1]-2*v[i]]++;\\n            \\n        }\\n        ans=max(ans,mp[0]);\\n        for(i=0;i<n;i++){\\n          \\n            ans=max(ans,mp1[nums[i]-k]+mp[k-nums[i]]);\\n           \\n            mp[v[n-1]-2*v[i]]--;\\n           mp1[v[n-1]-2*v[i]]++;\\n          \\n                 \\n        }\\n        return (int)ans;    \\n        \\n    }",
                "solutionTags": [],
                "code": "so basically we need to check if we make a certain element k then what will be the effect of it on the differernce when the element is in the prefix part and when it is in the suffix part of they array.\\n\\n\\n\\n\\n\\n int waysToPartition(vector<int>& nums, int k) {\\n        \\n       long long int i;\\n      long long int n=nums.size(),ans=0;\\n        unordered_map<long long,long long> mp;\\n        unordered_map<long long,long long> mp1;\\n        int sum=0;\\n        vector<long long> v(n);\\n        for(i=0;i<n;i++){\\n            sum=sum+(long long int)nums[i];\\n            v[i]=sum;\\n        }\\n        for(i=0;i<n-1;i++){\\n            mp[v[n-1]-2*v[i]]++;\\n            \\n        }\\n        ans=max(ans,mp[0]);\\n        for(i=0;i<n;i++){\\n          \\n            ans=max(ans,mp1[nums[i]-k]+mp[k-nums[i]]);\\n           \\n            mp[v[n-1]-2*v[i]]--;\\n           mp1[v[n-1]-2*v[i]]++;\\n          \\n                 \\n        }\\n        return (int)ans;    \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1793190,
                "title": "python-o-n-using-prefix-and-counter",
                "content": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        \\n        prefix = [0]\\n        for v in nums:\\n            prefix.append(prefix[-1] + v)\\n                \\n        cnt_l = collections.Counter()\\n        cnt_r = collections.Counter(prefix[1:-1])\\n        \\n        total = prefix[-1]\\n        res = 0 if total % 2 else cnt_r[total // 2]\\n                                    \\n        for i, p in enumerate(prefix[1:]):\\n            d = k - nums[i]\\n            if (total + d) % 2 == 0:\\n                cur = cnt_l[(total + d) // 2] + cnt_r[(total - d) // 2]\\n                res = max(cur, res)\\n            cnt_l[p] += 1\\n            cnt_r[p] -= 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        \\n        prefix = [0]\\n        for v in nums:\\n            prefix.append(prefix[-1] + v)\\n                \\n        cnt_l = collections.Counter()\\n        cnt_r = collections.Counter(prefix[1:-1])\\n        \\n        total = prefix[-1]\\n        res = 0 if total % 2 else cnt_r[total // 2]\\n                                    \\n        for i, p in enumerate(prefix[1:]):\\n            d = k - nums[i]\\n            if (total + d) % 2 == 0:\\n                cur = cnt_l[(total + d) // 2] + cnt_r[(total - d) // 2]\\n                res = max(cur, res)\\n            cnt_l[p] += 1\\n            cnt_r[p] -= 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781773,
                "title": "hoc5-joycoding-club",
                "content": "share your code here",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1689581,
                "title": "time-memory-100-find-the-number-to-change-for-a-partition-to-work",
                "content": "### Intuition\\n\\nIf no element is allowed to change, it is stratight forward to find the number of possible partitions; we iterate through each element and see if the sum of its preceding elements is half the total sum.\\n\\nNow, if an element has to changed, find which **number** should be changed. \\nFor example, let\\'s say index 0 is taken as a pivot for [2, -1, 2] and k=3.\\n\\n2 | -1   2\\n\\nFor simplicity first assume that we can change an element on the right side of the pivot only.\\nThe sum of elements on left is 2 and the total sum is 3.\\nIn order for this partition to work, number 2 (regardless of its position) should be changed to k, so that the total sum after the change becomes `totalSum - numToChange + k = 3 - 2 + 3 = 4 = 2 * 2 = 2 * (sum of elements on left)`.\\nIf any 2 on the right side of the pivot is changed to k, we get +1 partition available.\\nWe keep this information in a store (this is `hash` in code below) and apply it if we meet 2 as we go through the list further.\\nLikewise, we can find the number to change for each iteration. \\n`numToChange = totalSum + k - 2 * (sum of elements on left) `\\n\\nSince we first assumed that only an element on the right side of pivot can change, we iterate the array in the opposite direction to count all cases.\\n\\n### Complexity\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n```\\nfunction waysToPartition(nums: number[], k: number): number {\\n\\t// partitionIfChange[i] is the number of possible partitions if nums[i] is changed to k. Last index is reserved for the case if no elment is changed.\\n    const partitionIfChange = Array(nums.length+1).fill(0)\\n    const totalSum = nums.reduce((s, n) => s+n, 0)\\n\\t// hash.get(i) is the number of available partitions if number i is change to k.\\n    const hash = new Map<number, number>()\\n    // find the number of possible partitions if no element is changed.\\n\\tlet sum = 0\\n    for (let i=0; i<nums.length-1; i+=1) {\\n        sum += nums[i]\\n        if (2 * sum === totalSum) {\\n            partitionIfChange[nums.length] += 1\\n        }\\n    }\\n\\t// forward pass to find the number of partitions if an elment is changed.\\n    sum = 0\\n    for (let i=0; i<nums.length; i+=1) {\\n        const num = nums[i]\\n        sum += num\\n        const numToChange = totalSum + k - 2 * sum\\n        partitionIfChange[i] += hash.get(num) ?? 0\\n        hash.set(numToChange, (hash.get(numToChange) ?? 0) + 1)\\n    }\\n\\t// backward pass to find the number of partitions if an elment is changed.\\n    sum = 0\\n    hash.clear()\\n    for (let i=nums.length-1; 0<=i; i-=1) {\\n        const num = nums[i]\\n        sum += num\\n        const numToChange = totalSum + k - 2 * sum\\n        partitionIfChange[i] += hash.get(num) ?? 0\\n        hash.set(numToChange, (hash.get(numToChange) ?? 0) + 1)\\n    }\\n    return _.max(partitionIfChange)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Prefix Sum"
                ],
                "code": "```\\nfunction waysToPartition(nums: number[], k: number): number {\\n\\t// partitionIfChange[i] is the number of possible partitions if nums[i] is changed to k. Last index is reserved for the case if no elment is changed.\\n    const partitionIfChange = Array(nums.length+1).fill(0)\\n    const totalSum = nums.reduce((s, n) => s+n, 0)\\n\\t// hash.get(i) is the number of available partitions if number i is change to k.\\n    const hash = new Map<number, number>()\\n    // find the number of possible partitions if no element is changed.\\n\\tlet sum = 0\\n    for (let i=0; i<nums.length-1; i+=1) {\\n        sum += nums[i]\\n        if (2 * sum === totalSum) {\\n            partitionIfChange[nums.length] += 1\\n        }\\n    }\\n\\t// forward pass to find the number of partitions if an elment is changed.\\n    sum = 0\\n    for (let i=0; i<nums.length; i+=1) {\\n        const num = nums[i]\\n        sum += num\\n        const numToChange = totalSum + k - 2 * sum\\n        partitionIfChange[i] += hash.get(num) ?? 0\\n        hash.set(numToChange, (hash.get(numToChange) ?? 0) + 1)\\n    }\\n\\t// backward pass to find the number of partitions if an elment is changed.\\n    sum = 0\\n    hash.clear()\\n    for (let i=nums.length-1; 0<=i; i-=1) {\\n        const num = nums[i]\\n        sum += num\\n        const numToChange = totalSum + k - 2 * sum\\n        partitionIfChange[i] += hash.get(num) ?? 0\\n        hash.set(numToChange, (hash.get(numToChange) ?? 0) + 1)\\n    }\\n    return _.max(partitionIfChange)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687272,
                "title": "o-n-solution-prefix-function-and-map",
                "content": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n#define ll long long int\\nclass Solution {\\n    unordered_map<ll,ll> mpp,mps;\\npublic:\\n    int waysToPartition(vector<int>& a,int k) {\\n        IOS;\\n        ll i,n=a.size(),t=0,p=0;\\n        \\n        // total sum of all elements\\n        for(i=0;i<n;i++)\\n            t+=a[i];\\n        \\n        for(i=0;i<n-1;i++){\\n            p+=a[i];\\n            ll d=p-t+p;\\n            mpp[d]++;\\n        }\\n        \\n        p=0;\\n        ll ans=mpp[0];\\n\\t\\t\\n\\t\\t// we are checking how many valid pivots we\\'ll get if we update the ith index for every index \\n\\t\\t// and then choose the index which gives the maximum number of pivots\\n        for(i=0;i<n;i++){\\n            p+=a[i];\\n            ll d=2*p-t;\\n            ll cp=mpp[a[i]-k],cs=mps[k-a[i]];\\n            ans=max(ans,cp+cs);\\n            mps[d]++;\\n            if(mpp[d])\\n                mpp[d]--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n#define ll long long int\\nclass Solution {\\n    unordered_map<ll,ll> mpp,mps;\\npublic:\\n    int waysToPartition(vector<int>& a,int k) {\\n        IOS;\\n        ll i,n=a.size(),t=0,p=0;\\n        \\n        // total sum of all elements\\n        for(i=0;i<n;i++)\\n            t+=a[i];\\n        \\n        for(i=0;i<n-1;i++){\\n            p+=a[i];\\n            ll d=p-t+p;\\n            mpp[d]++;\\n        }\\n        \\n        p=0;\\n        ll ans=mpp[0];\\n\\t\\t\\n\\t\\t// we are checking how many valid pivots we\\'ll get if we update the ith index for every index \\n\\t\\t// and then choose the index which gives the maximum number of pivots\\n        for(i=0;i<n;i++){\\n            p+=a[i];\\n            ll d=2*p-t;\\n            ll cp=mpp[a[i]-k],cs=mps[k-a[i]];\\n            ans=max(ans,cp+cs);\\n            mps[d]++;\\n            if(mpp[d])\\n                mpp[d]--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1661805,
                "title": "python-binary-search-o-nlogn",
                "content": "create a dict that keeps key: value pairs where keys are differences between left sum and right sum, and values are list of pivot indexes that belongs to that differences. The index lists for each diff is sorted. For example, `dict[2] = [0,2,5]` means pivot indexs `0, 2, 5` makes a right sum - left sum difference of `2`. \\n\\nfor each of the element value change from from `nums[p]` to `k` (`p = 0, 1, 2, ..., n - 2`), assume the difference is `d`, we look at \\n1. how many indexes that are less than pivot index `p` in the `dict[-d]`. \\n2. how many indexes that are NO less than pivot index `p` in the `dict[d]`\\n\\nThis is because only right sum to `p` increases by `d` and left sum to `p` remains unchanged, a valid pivot index will be either `< p` and has difference of `-d`, or `>=p` and has a difference of `d`. \\n\\nWe do 2 binary searches to count 1. and 2.  Or you can use `bisect` module.\\n\\n```python\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        def bsearch(L, thres, less):\\n            # ascending list, return num of elem >= or < thres\\n            l, r = 0, len(L)\\n            while l < r:\\n                m = (l + r) // 2\\n                if L[m] >= thres:\\n                    r = m\\n                else:\\n                    l = m + 1\\n            return l if less else len(L) - l\\n        \\n        pivot = collections.defaultdict(list)\\n        n, ls, rs = len(nums), 0, sum(nums)\\n        for i in range(n-1):\\n            ls += nums[i]\\n            rs -= nums[i]\\n            pivot[rs-ls] += i,  # sorted\\n        res = len(pivot[0])\\n\\n        for i in range(n):\\n            if k != nums[i]:\\n                res = max(res, bsearch(pivot[nums[i]-k], i, 1) + bsearch(pivot[k-nums[i]], i, 0) )\\n        return res           \\n```\\n\\n```python\\n    def waysToPartition(self, nums: List[int], k: int) -> int:        \\n        pivot = collections.defaultdict(list)\\n        n, ls, rs = len(nums), 0, sum(nums)\\n        for i in range(n-1):\\n            ls += nums[i]\\n            rs -= nums[i]\\n            pivot[rs-ls] += i,  # sorted\\n        res = len(pivot[0])\\n\\n        for i in range(n):\\n            if k != nums[i]:\\n                res = max(res, bisect.bisect_left(pivot[nums[i]-k], i) + len(pivot[k-nums[i]]) - bisect.bisect_left(pivot[k-nums[i]], i) )\\n        return res\\n```\\n\\nBTW an O(n) solution from [@Bakerston](https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/discuss/1507271/Pythoncpp-Explanation-with-pictures.-O(N))\\n",
                "solutionTags": [],
                "code": "```python\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        def bsearch(L, thres, less):\\n            # ascending list, return num of elem >= or < thres\\n            l, r = 0, len(L)\\n            while l < r:\\n                m = (l + r) // 2\\n                if L[m] >= thres:\\n                    r = m\\n                else:\\n                    l = m + 1\\n            return l if less else len(L) - l\\n        \\n        pivot = collections.defaultdict(list)\\n        n, ls, rs = len(nums), 0, sum(nums)\\n        for i in range(n-1):\\n            ls += nums[i]\\n            rs -= nums[i]\\n            pivot[rs-ls] += i,  # sorted\\n        res = len(pivot[0])\\n\\n        for i in range(n):\\n            if k != nums[i]:\\n                res = max(res, bsearch(pivot[nums[i]-k], i, 1) + bsearch(pivot[k-nums[i]], i, 0) )\\n        return res           \\n```\n```python\\n    def waysToPartition(self, nums: List[int], k: int) -> int:        \\n        pivot = collections.defaultdict(list)\\n        n, ls, rs = len(nums), 0, sum(nums)\\n        for i in range(n-1):\\n            ls += nums[i]\\n            rs -= nums[i]\\n            pivot[rs-ls] += i,  # sorted\\n        res = len(pivot[0])\\n\\n        for i in range(n):\\n            if k != nums[i]:\\n                res = max(res, bisect.bisect_left(pivot[nums[i]-k], i) + len(pivot[k-nums[i]]) - bisect.bisect_left(pivot[k-nums[i]], i) )\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1656771,
                "title": "what-is-wrong-with-this-python3-code",
                "content": "Dear community members, \\n\\nI\\'ve tried so hard to work on this problem by myself, and my code below fails at test 106, where the expected output is 5688 but my code produced 5689. I really have no clue why my program overcounts by one. Does anybody have any idea? Much appreciated!!!\\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        numsSum = sum(nums)\\n        # first count number of partitions allowing no change of element\\n        count = 0\\n        left = []\\n        right = []\\n        curSum = 0\\n        for i in range(len(nums)-1):\\n            curSum += nums[i]\\n            left.append(curSum)\\n            right.append(numsSum-curSum)\\n            if (curSum == numsSum-curSum):\\n                count += 1\\n        # now check if changing one element would lead to additional partition\\n        \\n        leftMinusRight = []\\n        for i in range(len(left)):\\n            leftMinusRight.append(left[i]-right[i])\\n        \\n        diff = []\\n        for i in range(len(nums)):\\n            diff.append(k-nums[i])\\n        \\n        maxIncre = 0\\n        for i in range(len(nums)):\\n            #suppose the i-th element of nums is changed to k\\n            if (diff[i]==0):\\n                continue\\n            \\n            increase = 0\\n            #unless i is the last element of nums, i would affect leftSums\\n            if(i < len(nums)-1):\\n                increase += leftMinusRight[i:].count(-diff[i])\\n            #unless i is the first element of nums, i would affect rightSums\\n            if(i > 0):\\n                increase +=leftMinusRight[:i].count(diff[i])\\n            maxIncre = max(maxIncre, increase)\\n            \\n        count += maxIncre\\n        return count",
                "solutionTags": [],
                "code": "Dear community members, \\n\\nI\\'ve tried so hard to work on this problem by myself, and my code below fails at test 106, where the expected output is 5688 but my code produced 5689. I really have no clue why my program overcounts by one. Does anybody have any idea? Much appreciated!!!\\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        numsSum = sum(nums)\\n        # first count number of partitions allowing no change of element\\n        count = 0\\n        left = []\\n        right = []\\n        curSum = 0\\n        for i in range(len(nums)-1):\\n            curSum += nums[i]\\n            left.append(curSum)\\n            right.append(numsSum-curSum)\\n            if (curSum == numsSum-curSum):\\n                count += 1\\n        # now check if changing one element would lead to additional partition\\n        \\n        leftMinusRight = []\\n        for i in range(len(left)):\\n            leftMinusRight.append(left[i]-right[i])\\n        \\n        diff = []\\n        for i in range(len(nums)):\\n            diff.append(k-nums[i])\\n        \\n        maxIncre = 0\\n        for i in range(len(nums)):\\n            #suppose the i-th element of nums is changed to k\\n            if (diff[i]==0):\\n                continue\\n            \\n            increase = 0\\n            #unless i is the last element of nums, i would affect leftSums\\n            if(i < len(nums)-1):\\n                increase += leftMinusRight[i:].count(-diff[i])\\n            #unless i is the first element of nums, i would affect rightSums\\n            if(i > 0):\\n                increase +=leftMinusRight[:i].count(diff[i])\\n            maxIncre = max(maxIncre, increase)\\n            \\n        count += maxIncre\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1650383,
                "title": "confused-by-this-test-case-need-help-to-explain",
                "content": "For test case\\n[0,0,0,0,0,0,0,0,0,-4732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n-4732\\nexpectation: 26\\n\\nI didn\\'t get the why the expectation  is 26\\n\\nas it has in all 36 elements, if change any of the zero to -4732, it can at least have 35 ways, let alone counting the \\ncases as different partion ways.\\n[-4732|0,0,0,0,0,0,0,0,-4732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n[-4732,0|0,0,0,0,0,0,0,-4732,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1611163,
                "title": "python-90-performance-and-memory",
                "content": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        sumOfArray = sum(nums)\\n        n = len(nums)\\n        \\n        # Suppose we partition at index x, then we precompute what the difference between\\n        # sum(left) and sum(right) will be. At each pivot, we shift the number from right side to left side.\\n        # That is, we increase the difference by 2 * nums[pivot]\\n        leftExcess = [0] * (n - 1)\\n        leftDiffs = {}\\n        rightDiffs = {}\\n        prevLeftExcess = -sumOfArray\\n        for pivot in range(n - 1):\\n            excess = prevLeftExcess + (2 * nums[pivot])\\n            leftExcess[pivot] = excess\\n            prevLeftExcess = excess\\n            # Let\\'s say we replace a number at index x. The original number was y, and is replaced with k.\\n            # That will change the number by diff = k - y. This will affect the partition on the left such that\\n            # the difference is now smaller by diff(because we added diff to right side of the partition).\\n            \\n            # For each changed number, we will find how many partitions of left had exactly the difference of -diff. These will now be changed to -diff + diff = 0, and make them a valid answer.\\n            if excess in leftDiffs:\\n                leftDiffs[excess] += 1\\n            else:\\n                leftDiffs[excess] = 1\\n                \\n        if 0 in leftDiffs:\\n            maxWays = leftDiffs[0]\\n        else:\\n            maxWays = 0\\n            \\n        for pivot in range(n):                \\n            \\n            # change this number to k. Find how much the number increases.\\n            increase = k - nums[pivot]\\n            # possible valid partitions are those with \"-increase\" excess on left side, or \"increase\" excess on right side.\\n            posThisPivot = 0\\n            if -increase in leftDiffs:\\n                posThisPivot += leftDiffs[-increase]\\n            if increase in rightDiffs:\\n                posThisPivot += rightDiffs[increase]\\n            \\n            # update max\\n            maxWays = max(maxWays, posThisPivot)\\n            \\n            if pivot < n - 1:\\n                # move the excess at this pivot to rightDiff\\n                thisDiff = leftExcess[pivot]\\n                leftDiffs[thisDiff] -= 1\\n                if thisDiff in rightDiffs:\\n                    rightDiffs[thisDiff] += 1\\n                else:\\n                    rightDiffs[thisDiff] = 1  \\n            \\n        return maxWays\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        sumOfArray = sum(nums)\\n        n = len(nums)\\n        \\n        # Suppose we partition at index x, then we precompute what the difference between\\n        # sum(left) and sum(right) will be. At each pivot, we shift the number from right side to left side.\\n        # That is, we increase the difference by 2 * nums[pivot]\\n        leftExcess = [0] * (n - 1)\\n        leftDiffs = {}\\n        rightDiffs = {}\\n        prevLeftExcess = -sumOfArray\\n        for pivot in range(n - 1):\\n            excess = prevLeftExcess + (2 * nums[pivot])\\n            leftExcess[pivot] = excess\\n            prevLeftExcess = excess\\n            # Let\\'s say we replace a number at index x. The original number was y, and is replaced with k.\\n            # That will change the number by diff = k - y. This will affect the partition on the left such that\\n            # the difference is now smaller by diff(because we added diff to right side of the partition).\\n            \\n            # For each changed number, we will find how many partitions of left had exactly the difference of -diff. These will now be changed to -diff + diff = 0, and make them a valid answer.\\n            if excess in leftDiffs:\\n                leftDiffs[excess] += 1\\n            else:\\n                leftDiffs[excess] = 1\\n                \\n        if 0 in leftDiffs:\\n            maxWays = leftDiffs[0]\\n        else:\\n            maxWays = 0\\n            \\n        for pivot in range(n):                \\n            \\n            # change this number to k. Find how much the number increases.\\n            increase = k - nums[pivot]\\n            # possible valid partitions are those with \"-increase\" excess on left side, or \"increase\" excess on right side.\\n            posThisPivot = 0\\n            if -increase in leftDiffs:\\n                posThisPivot += leftDiffs[-increase]\\n            if increase in rightDiffs:\\n                posThisPivot += rightDiffs[increase]\\n            \\n            # update max\\n            maxWays = max(maxWays, posThisPivot)\\n            \\n            if pivot < n - 1:\\n                # move the excess at this pivot to rightDiff\\n                thisDiff = leftExcess[pivot]\\n                leftDiffs[thisDiff] -= 1\\n                if thisDiff in rightDiffs:\\n                    rightDiffs[thisDiff] += 1\\n                else:\\n                    rightDiffs[thisDiff] = 1  \\n            \\n        return maxWays\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608743,
                "title": "scala-binary-search-get-all-prefix-sum-with-diff-between-left-and-right-enumerate-on-each-pivot",
                "content": "This is quite a hard question with too many corner cases to cover and test\\n\\n```scala\\n\\n  def waysToPartition(nums: Array[Int], k: Int): Int = {\\n    import scala.collection.mutable.{HashMap, ArrayBuffer}\\n    type int = Int\\n    type A   = ArrayBuffer[int]\\n    val map = new HashMap[Long, A]\\n    val len = nums.length\\n\\n    val ps = Array.ofDim[Long](len)\\n    ps(0) = nums(0).toLong\\n    (1 until len).foreach(i => ps(i) = ps(i - 1) + nums(i).toLong)\\n    val f = (s: int, e: int) => if (s == 0) ps(e) else ps(e) - ps(s - 1)\\n\\n    var res = 0\\n\\n    (1 to len - 1).foreach(i => {\\n      val diff = ps(i - 1) - f(i, len - 1)\\n      if (diff == 0L) res += 1\\n      if (!map.contains(diff)) map += (diff -> new A)\\n      map(diff) += i\\n    })\\n\\n    def g(d: Long, idx: int): int = {\\n      if (!map.contains(d) || d == 0L) return 0\\n      val arr = map(d)\\n      var s   = 0\\n      var e   = arr.length - 1\\n      if (arr(e) < idx) return 0\\n      var r = 0\\n      while (s <= e) {\\n        var mid = (s + e) >> 1\\n        if (arr(mid) > idx) { r = Math.max(r, arr.length - mid); e = mid - 1 }\\n        else { s = mid + 1 }\\n      }\\n      r\\n    }\\n\\n    def h(d: Long, idx: int): int = {\\n      if (!map.contains(d) || d == 0L) return 0\\n      val arr = map(d)\\n      var s   = 0\\n      var e   = arr.length - 1\\n      if (arr(s) > idx) return 0\\n      var r = 0\\n      while (s <= e) {\\n        var mid = (s + e) >> 1\\n        if (arr(mid) <= idx) { r = Math.max(r, mid + 1); s = mid + 1 }\\n        else { e = mid - 1 }\\n      }\\n      r\\n    }\\n\\n    if (map.contains(nums(0) - k) && nums(0) != k) res = Math.max(res, map(nums(0) - k).size)\\n    if (map.contains(k - nums(len - 1)) && nums(len - 1) != k)\\n      res = Math.max(res, map(k - nums(len - 1)).size)\\n\\n    (1 to len - 2).map(i => {\\n      val diff = (k - nums(i)).toLong\\n      res = Math.max(res, g(-diff, i) + h(diff, i))\\n    })\\n\\n    res\\n  }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```scala\\n\\n  def waysToPartition(nums: Array[Int], k: Int): Int = {\\n    import scala.collection.mutable.{HashMap, ArrayBuffer}\\n    type int = Int\\n    type A   = ArrayBuffer[int]\\n    val map = new HashMap[Long, A]\\n    val len = nums.length\\n\\n    val ps = Array.ofDim[Long](len)\\n    ps(0) = nums(0).toLong\\n    (1 until len).foreach(i => ps(i) = ps(i - 1) + nums(i).toLong)\\n    val f = (s: int, e: int) => if (s == 0) ps(e) else ps(e) - ps(s - 1)\\n\\n    var res = 0\\n\\n    (1 to len - 1).foreach(i => {\\n      val diff = ps(i - 1) - f(i, len - 1)\\n      if (diff == 0L) res += 1\\n      if (!map.contains(diff)) map += (diff -> new A)\\n      map(diff) += i\\n    })\\n\\n    def g(d: Long, idx: int): int = {\\n      if (!map.contains(d) || d == 0L) return 0\\n      val arr = map(d)\\n      var s   = 0\\n      var e   = arr.length - 1\\n      if (arr(e) < idx) return 0\\n      var r = 0\\n      while (s <= e) {\\n        var mid = (s + e) >> 1\\n        if (arr(mid) > idx) { r = Math.max(r, arr.length - mid); e = mid - 1 }\\n        else { s = mid + 1 }\\n      }\\n      r\\n    }\\n\\n    def h(d: Long, idx: int): int = {\\n      if (!map.contains(d) || d == 0L) return 0\\n      val arr = map(d)\\n      var s   = 0\\n      var e   = arr.length - 1\\n      if (arr(s) > idx) return 0\\n      var r = 0\\n      while (s <= e) {\\n        var mid = (s + e) >> 1\\n        if (arr(mid) <= idx) { r = Math.max(r, mid + 1); s = mid + 1 }\\n        else { e = mid - 1 }\\n      }\\n      r\\n    }\\n\\n    if (map.contains(nums(0) - k) && nums(0) != k) res = Math.max(res, map(nums(0) - k).size)\\n    if (map.contains(k - nums(len - 1)) && nums(len - 1) != k)\\n      res = Math.max(res, map(k - nums(len - 1)).size)\\n\\n    (1 to len - 2).map(i => {\\n      val diff = (k - nums(i)).toLong\\n      res = Math.max(res, g(-diff, i) + h(diff, i))\\n    })\\n\\n    res\\n  }\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1567622,
                "title": "commented-python",
                "content": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        t_sum = sum(nums)\\n        dif_mp = Counter()\\n        left_sum = 0\\n        # for i, we are using P = i + 1 as the pivot (that\\'s also the reason i < n - 1 not n)\\n        for i in range(n - 1):\\n            left_sum += nums[i]\\n            right_sum = t_sum - left_sum\\n            dif_mp[left_sum - right_sum] += 1\\n        \\n        left_dif_mp = Counter()\\n        left_sum = 0\\n        ans = dif_mp[0]\\n        \\n        # for i, we should move P = i to left_dif_mp, so we don\\'t have to move anything when i == 0\\n        # and we move at the end of every iteration as P = i + 1, so we have prepared good left_dif_mp for the next iteration\\n        # for P <= i, new_dif = ori_dif - (k - nums[i]); for P > i, new_dif = ori_dif + (k - nums[i])\\n        for i in range(n):\\n            ans = max(ans, left_dif_mp.get(k - nums[i], 0) + dif_mp.get(nums[i] - k, 0))\\n            \\n            if i < n - 1:\\n                left_sum += nums[i]\\n                right_sum = t_sum - left_sum\\n                left_dif_mp[left_sum - right_sum] += 1\\n                dif_mp[left_sum - right_sum] -= 1\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        t_sum = sum(nums)\\n        dif_mp = Counter()\\n        left_sum = 0\\n        # for i, we are using P = i + 1 as the pivot (that\\'s also the reason i < n - 1 not n)\\n        for i in range(n - 1):\\n            left_sum += nums[i]\\n            right_sum = t_sum - left_sum\\n            dif_mp[left_sum - right_sum] += 1\\n        \\n        left_dif_mp = Counter()\\n        left_sum = 0\\n        ans = dif_mp[0]\\n        \\n        # for i, we should move P = i to left_dif_mp, so we don\\'t have to move anything when i == 0\\n        # and we move at the end of every iteration as P = i + 1, so we have prepared good left_dif_mp for the next iteration\\n        # for P <= i, new_dif = ori_dif - (k - nums[i]); for P > i, new_dif = ori_dif + (k - nums[i])\\n        for i in range(n):\\n            ans = max(ans, left_dif_mp.get(k - nums[i], 0) + dif_mp.get(nums[i] - k, 0))\\n            \\n            if i < n - 1:\\n                left_sum += nums[i]\\n                right_sum = t_sum - left_sum\\n                left_dif_mp[left_sum - right_sum] += 1\\n                dif_mp[left_sum - right_sum] -= 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549623,
                "title": "share-my-java-o-n-solution-two-maps",
                "content": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n\\n        int total  = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            total += nums[i];\\n            if(i!=nums.length-1){\\n                map.put(total, map.getOrDefault(total, 0)+1);\\n            }\\n        }\\n        \\n        \\n        int cur = 0;\\n        int res = 0;\\n        if(total%2==0){\\n            res = map.getOrDefault(total/2, 0);\\n        }\\n        Map<Integer, Integer> preSum = new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                map.put(cur, map.get(cur)-1);\\n                preSum.put(cur, preSum.getOrDefault(cur,0)+1);\\n            }\\n\\n            \\n            int new_total = (total - nums[i] + k);\\n            if(new_total%2!=0){\\n                cur += nums[i];\\n                continue;\\n            }\\n            \\n            int target = new_total/2;\\n            int temp = 0;\\n            temp += preSum.getOrDefault(target, 0);\\n            temp += map.getOrDefault(target-k+nums[i], 0);\\n            \\n         \\n            \\n            res = Math.max(res, temp);\\n            cur += nums[i];\\n            \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n\\n        int total  = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            total += nums[i];\\n            if(i!=nums.length-1){\\n                map.put(total, map.getOrDefault(total, 0)+1);\\n            }\\n        }\\n        \\n        \\n        int cur = 0;\\n        int res = 0;\\n        if(total%2==0){\\n            res = map.getOrDefault(total/2, 0);\\n        }\\n        Map<Integer, Integer> preSum = new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(i!=0){\\n                map.put(cur, map.get(cur)-1);\\n                preSum.put(cur, preSum.getOrDefault(cur,0)+1);\\n            }\\n\\n            \\n            int new_total = (total - nums[i] + k);\\n            if(new_total%2!=0){\\n                cur += nums[i];\\n                continue;\\n            }\\n            \\n            int target = new_total/2;\\n            int temp = 0;\\n            temp += preSum.getOrDefault(target, 0);\\n            temp += map.getOrDefault(target-k+nums[i], 0);\\n            \\n         \\n            \\n            res = Math.max(res, temp);\\n            cur += nums[i];\\n            \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548826,
                "title": "c-clean-and-concise-code",
                "content": "class Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        vector<long long>prefix(n);\\n        vector<long long>suffix(n);\\n        \\n        prefix[0]=nums[0];\\n        suffix[n-1]=nums[n-1];\\n        \\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            suffix[i]=suffix[i+1]+nums[i];\\n        }\\n        \\n        long long count=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(prefix[i-1]==suffix[i]){\\n                count++;\\n            }\\n        }\\n        \\n        unordered_map<long long,long long>left,right;\\n        \\n        for(int i=0;i<n-1;i++){\\n            right[prefix[i]-suffix[i+1]]++;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            long long val=0;\\n            \\n            long long diff=k-nums[i];\\n            \\n            val+=left[diff];\\n            val+=right[-diff];\\n            \\n            count=max(count,val);\\n            \\n            if(i<n-1){\\n             \\n                long long dd=prefix[i]-suffix[i+1];\\n                \\n                left[dd]++;\\n                right[dd]--;\\n                \\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        vector<long long>prefix(n);\\n        vector<long long>suffix(n);\\n        \\n        prefix[0]=nums[0];\\n        suffix[n-1]=nums[n-1];\\n        \\n        for(int i=1;i<n;i++){\\n            prefix[i]=prefix[i-1]+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1511246,
                "title": "c-solution-unordered-map",
                "content": "```\\n #define ll long long\\n    vector<ll> left(vector<int> num){\\n        \\n        ll n=num.size();\\n        vector<ll> v(n,0);\\n        ll x=num[0];\\n        for(ll i=1;i<n;i++){\\n            v[i]=x;\\n            x+=num[i];\\n        }\\n        return v;\\n    }\\n    vector<ll> right(vector<int> num){\\n        \\n        ll n=num.size();\\n        vector<ll> v(n,0);\\n        v[n-1]=num[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            v[i]=v[i+1]+num[i];\\n        }\\n        return v;\\n    }\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        vector<ll> l=left(nums);\\n        vector<ll> r=right(nums);\\n        unordered_map<ll,ll> m1,m2;\\n        \\n        ll n=nums.size();\\n        ll c=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(l[i]==r[i])\\n                c++;\\n        }\\n        ll ans=c;\\n        c=0;\\n        \\n        for(int i=1;i<n;i++){\\n            m1[r[i]-l[i]]++;\\n        }\\n         \\n          ll diff= k-nums[0];\\n          c+=m1[diff];\\n          ans= max(ans,c);\\n         m1[r[1]-l[1]]--;\\n        \\n        for(ll i=1;i<n;i++){\\n              c=0;\\n             m2[l[i]-r[i]]++;\\n            diff= k-nums[i];\\n        \\n              c+=m2[diff];\\n              c+=m1[diff];\\n            \\n            ans= max(ans,c);\\n        \\n            if(i!=(n-1 ))\\n              m1[r[i+1]-l[i+1]]--;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n #define ll long long\\n    vector<ll> left(vector<int> num){\\n        \\n        ll n=num.size();\\n        vector<ll> v(n,0);\\n        ll x=num[0];\\n        for(ll i=1;i<n;i++){\\n            v[i]=x;\\n            x+=num[i];\\n        }\\n        return v;\\n    }\\n    vector<ll> right(vector<int> num){\\n        \\n        ll n=num.size();\\n        vector<ll> v(n,0);\\n        v[n-1]=num[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            v[i]=v[i+1]+num[i];\\n        }\\n        return v;\\n    }\\n    int waysToPartition(vector<int>& nums, int k) {\\n        \\n        vector<ll> l=left(nums);\\n        vector<ll> r=right(nums);\\n        unordered_map<ll,ll> m1,m2;\\n        \\n        ll n=nums.size();\\n        ll c=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(l[i]==r[i])\\n                c++;\\n        }\\n        ll ans=c;\\n        c=0;\\n        \\n        for(int i=1;i<n;i++){\\n            m1[r[i]-l[i]]++;\\n        }\\n         \\n          ll diff= k-nums[0];\\n          c+=m1[diff];\\n          ans= max(ans,c);\\n         m1[r[1]-l[1]]--;\\n        \\n        for(ll i=1;i<n;i++){\\n              c=0;\\n             m2[l[i]-r[i]]++;\\n            diff= k-nums[i];\\n        \\n              c+=m2[diff];\\n              c+=m1[diff];\\n            \\n            ans= max(ans,c);\\n        \\n            if(i!=(n-1 ))\\n              m1[r[i+1]-l[i+1]]--;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1509727,
                "title": "python-binary-search-map-prefix-sum-explained",
                "content": "**Explanation**\\n\\n* Given an array A, if we modify element i from A[i] to k, then the difference will only occur from index i to index n-1.\\n\\n* First compute the prefix sum called pre.\\n* Record the index of every possible prefix sum into a map called mp.\\n* Then for every index that can be modified, \\n\\t1. we find the difference diff = (k - A[i]) after changed.\\n\\t2. The total sum of the array changed to pre[-1] + diff\\n\\t3. Two cases will not lead to available result: no diff or the total sum is not an even number.\\n\\t4. Two cases will count:\\n\\tFor every element j after i, only when A[j] + diff == total - (A[j] + diff), this kind of element can be partition.\\n\\tFor every element j before i, only when A[j] == total - A[j],  this kind of element can be partition.\\n* Use binary search to find the number of both cases. For example, the A[j] in the previous cases, we record its index list in a map, the number of available index can be found by binary search.\\n\\n**Complexity**\\n\\n* Time complexity: O(nlogn), Space complexity O(n)\\n\\n\\n```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        pre = [0]\\n        n = len(nums)\\n        mp = collections.defaultdict(list)\\n        for i, a in enumerate(nums):\\n            pre.append(pre[-1] + a)\\n            if i < n - 1:\\n                mp[pre[-1]].append(i)\\n\\t\\t\\t\\t\\n\\t\\t# If we don\\'t modify the array, answer is the number of half of total sum in prefix sum\\n        res = sum([1 for i in range(1, n) if pre[i] == pre[-1] / 2])\\n        \\n        for i in range(n):\\n            diff = k - nums[i]\\n            if diff == 0:\\n                continue\\n            total = pre[-1] + diff\\n            if total % 2:\\n                continue\\n            after = total // 2 - diff\\n            idx1 = bisect.bisect_left(mp[after], i)\\n            idx2 = bisect.bisect_left(mp[total//2], i)\\n            res = max(res, len(mp[after]) - idx1 + idx2)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        pre = [0]\\n        n = len(nums)\\n        mp = collections.defaultdict(list)\\n        for i, a in enumerate(nums):\\n            pre.append(pre[-1] + a)\\n            if i < n - 1:\\n                mp[pre[-1]].append(i)\\n\\t\\t\\t\\t\\n\\t\\t# If we don\\'t modify the array, answer is the number of half of total sum in prefix sum\\n        res = sum([1 for i in range(1, n) if pre[i] == pre[-1] / 2])\\n        \\n        for i in range(n):\\n            diff = k - nums[i]\\n            if diff == 0:\\n                continue\\n            total = pre[-1] + diff\\n            if total % 2:\\n                continue\\n            after = total // 2 - diff\\n            idx1 = bisect.bisect_left(mp[after], i)\\n            idx2 = bisect.bisect_left(mp[total//2], i)\\n            res = max(res, len(mp[after]) - idx1 + idx2)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503606,
                "title": "python3-two-hashmap-o-n-explained",
                "content": "First, we will store all left sum at all pivot point (`0 to n-1`) in `counts` map. \\nWith no changes, the solution is simple `counts[total/2]`. \\n\\nNext we again enumerate and store the same left sum in `temp_counts` map which will be used to decide how many times a particular left sum occurs before and after a pivot point.\\n\\nWhile enumerating, we check the possible result if we change that number. The logic is as follows if we change the current number `nums[idx]` to `k`:\\n1) the halves can be calculated by `(total+ k-nums[idx])/2`.\\n2) Pivot points on or after this current `idx` would have `halves-k+nums[idx]` as the left sum value in the original `counts` map. But, we need to subtract also previously occurred sum value which will be tracked by `temp_counts` map. \\n3) Pivot points before this current `idx` would just have the left sum value as `halves`. \\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        total = sum(nums)\\n        counts = defaultdict(int)\\n        t = 0\\n        for idx in range(len(nums)-1):\\n            t += nums[idx]\\n            counts[t] +=1\\n        res = counts[total//2] if total%2==0 else 0\\n        temp_counts = defaultdict(int)\\n        t,N = 0, len(nums)\\n        for idx in range(N):\\n            possible = t+k\\n            halves = (total+ k-nums[idx])\\n            if halves%2==1:\\n                t += nums[idx]\\n                temp_counts[t] +=1\\n            else:\\n                halves = halves//2\\n                t += nums[idx]\\n                total_halves_later = counts[halves-k+nums[idx]]- temp_counts[halves-k+nums[idx]]#if pivot happens later\\n                total_halves_before = temp_counts[halves]#if pivot happens before\\n                temp_counts[t] +=1\\n                res = max(res, total_halves_later+total_halves_before)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        total = sum(nums)\\n        counts = defaultdict(int)\\n        t = 0\\n        for idx in range(len(nums)-1):\\n            t += nums[idx]\\n            counts[t] +=1\\n        res = counts[total//2] if total%2==0 else 0\\n        temp_counts = defaultdict(int)\\n        t,N = 0, len(nums)\\n        for idx in range(N):\\n            possible = t+k\\n            halves = (total+ k-nums[idx])\\n            if halves%2==1:\\n                t += nums[idx]\\n                temp_counts[t] +=1\\n            else:\\n                halves = halves//2\\n                t += nums[idx]\\n                total_halves_later = counts[halves-k+nums[idx]]- temp_counts[halves-k+nums[idx]]#if pivot happens later\\n                total_halves_before = temp_counts[halves]#if pivot happens before\\n                temp_counts[t] +=1\\n                res = max(res, total_halves_later+total_halves_before)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502897,
                "title": "java-o-n-soluton",
                "content": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        long sum = 0;\\n        long l = 0;\\n        for(int n : nums)\\n            sum += n;\\n        HashMap<Long, Integer> rightMap = new HashMap();\\n        for(int i = 0;i<nums.length-1; i++){\\n            l += nums[i];\\n            long diff = sum-2*l;\\n            rightMap.put(diff, rightMap.getOrDefault(diff, 0)+1);\\n        }\\n        int res = rightMap.getOrDefault(0L, 0);\\n        HashMap<Long, Integer> leftMap = new HashMap();\\n        l = 0;\\n        for(int i =0 ;i<nums.length; i++){\\n            long diff = k-nums[i];\\n            res = Math.max(res, leftMap.getOrDefault(-diff, 0)+rightMap.getOrDefault(diff, 0));\\n            l+= nums[i];\\n            long r = sum - l;\\n            long nextDiff = r-l;\\n            leftMap.put(nextDiff, leftMap.getOrDefault(nextDiff, 0) + 1);\\n            rightMap.put(nextDiff, rightMap.getOrDefault(nextDiff, 0) - 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        long sum = 0;\\n        long l = 0;\\n        for(int n : nums)\\n            sum += n;\\n        HashMap<Long, Integer> rightMap = new HashMap();\\n        for(int i = 0;i<nums.length-1; i++){\\n            l += nums[i];\\n            long diff = sum-2*l;\\n            rightMap.put(diff, rightMap.getOrDefault(diff, 0)+1);\\n        }\\n        int res = rightMap.getOrDefault(0L, 0);\\n        HashMap<Long, Integer> leftMap = new HashMap();\\n        l = 0;\\n        for(int i =0 ;i<nums.length; i++){\\n            long diff = k-nums[i];\\n            res = Math.max(res, leftMap.getOrDefault(-diff, 0)+rightMap.getOrDefault(diff, 0));\\n            l+= nums[i];\\n            long r = sum - l;\\n            long nextDiff = r-l;\\n            leftMap.put(nextDiff, leftMap.getOrDefault(nextDiff, 0) + 1);\\n            rightMap.put(nextDiff, rightMap.getOrDefault(nextDiff, 0) - 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502432,
                "title": "python-simple-solution",
                "content": "```\\n\\t\\tp = collections.defaultdict(list)\\n        s = collections.defaultdict(collections.deque)\\n        n = len(nums)\\n        ts = sum(nums)\\n        ans = 0\\n        ps,ss = 0,0\\n        for i in range(n):\\n            ps += nums[i]\\n            ss += nums[n-1-i]\\n            p[ps].append(i)\\n            s[ss].appendleft(n-1-i)\\n            if ps == ts/2 and i != n-1:\\n                ans += 1\\n        for i in range(n):\\n            ans1 = 0\\n            tmp = ts-nums[i]+k\\n            if tmp%2 == 1:\\n                continue\\n            tmp = tmp//2\\n            t = bisect.bisect_right(s[tmp],i)\\n            ans1 += len(s[tmp])-t\\n            t = bisect.bisect_left(p[tmp],i)\\n            ans1 += t\\n            ans = max(ans,ans1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\t\\tp = collections.defaultdict(list)\\n        s = collections.defaultdict(collections.deque)\\n        n = len(nums)\\n        ts = sum(nums)\\n        ans = 0\\n        ps,ss = 0,0\\n        for i in range(n):\\n            ps += nums[i]\\n            ss += nums[n-1-i]\\n            p[ps].append(i)\\n            s[ss].appendleft(n-1-i)\\n            if ps == ts/2 and i != n-1:\\n                ans += 1\\n        for i in range(n):\\n            ans1 = 0\\n            tmp = ts-nums[i]+k\\n            if tmp%2 == 1:\\n                continue\\n            tmp = tmp//2\\n            t = bisect.bisect_right(s[tmp],i)\\n            ans1 += len(s[tmp])-t\\n            t = bisect.bisect_left(p[tmp],i)\\n            ans1 += t\\n            ans = max(ans,ans1)\\n        return ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501171,
                "title": "javascript-map-solution-t-o-n-s-o-n",
                "content": "Thanks to this post https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/discuss/1499365/C%2B%2B-Frequency-Map-O(N)\\n````\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar waysToPartition = function(nums, k) {\\n    let totalSum=nums.reduce((acc, curr) => acc+curr)\\n    let left=0;\\n    let rightDiff={}\\n    let leftDiff={}\\n    \\n    for(let i=0; i<nums.length-1; i++) {\\n        left+=nums[i]\\n        const right=totalSum-left\\n        if(rightDiff[left-right]) rightDiff[left-right]++\\n        else rightDiff[left-right]=1\\n    }\\n\\n    let maxPartition=rightDiff[0] ? rightDiff[0] : 0\\n    left=0\\n    for(let i=0; i<nums.length; i++) {\\n        left+=nums[i]\\n        let diff=k-nums[i]\\n        const right=totalSum-left\\n        let leftVal=leftDiff[`${diff}`] ? leftDiff[`${diff}`] : 0\\n        let rightVal=rightDiff[`${-diff}`] ? rightDiff[`${-diff}`] : 0\\n        \\n        maxPartition=Math.max(maxPartition, leftVal+rightVal)\\n        if(leftDiff[left-right]) leftDiff[left-right]++\\n        else leftDiff[left-right]=1\\n        \\n        rightDiff[left-right]--\\n\\n    }\\n    \\n    return maxPartition\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar waysToPartition = function(nums, k) {\\n    let totalSum=nums.reduce((acc, curr) => acc+curr)\\n    let left=0;\\n    let rightDiff={}\\n    let leftDiff={}\\n    \\n    for(let i=0; i<nums.length-1; i++) {\\n        left+=nums[i]\\n        const right=totalSum-left\\n        if(rightDiff[left-right]) rightDiff[left-right]++\\n        else rightDiff[left-right]=1\\n    }\\n\\n    let maxPartition=rightDiff[0] ? rightDiff[0] : 0\\n    left=0\\n    for(let i=0; i<nums.length; i++) {\\n        left+=nums[i]\\n        let diff=k-nums[i]\\n        const right=totalSum-left\\n        let leftVal=leftDiff[`${diff}`] ? leftDiff[`${diff}`] : 0\\n        let rightVal=rightDiff[`${-diff}`] ? rightDiff[`${-diff}`] : 0\\n        \\n        maxPartition=Math.max(maxPartition, leftVal+rightVal)\\n        if(leftDiff[left-right]) leftDiff[left-right]++\\n        else leftDiff[left-right]=1\\n        \\n        rightDiff[left-right]--\\n\\n    }\\n    \\n    return maxPartition\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500679,
                "title": "sorting-dictionary-prefixsum-o-nlogn-time-o-n-space",
                "content": "* Store sorted version of nums in array and calculate startIndex and endIndex of each element in a dictionay\\n* Create a array updatesArr to store count of each number which when changed to `k` gives our target. Here each `ith` element indicates count of `sorted(nums)[i]`\\n\\nThere are 2 situations with respect to Pivot\\n* `leftSum == rightSum` (pivot always in right) if it comes update count in `noChangesCount`\\n\\n* there may be a integer` n` in leftside of the `pivot `which when substituted by `k` gives left==right search for it and update first `countLeft[n]` in `updatesArr` by 1\\n\\n* there may be a integer` n` in rightside of the `pivot `which when substituted by `k` gives left==right search for it and update last `countLeft[n]` in `updatesArr` by 1\\n\\nAtlast do prefixSum from start to end and save maxPrefixSum accordingly\\n\\n**Answer : **`max(noChangesCount,maxPrefixSum)`\\n\\n\\n\\n```\\nclass Solution:\\n    def update(self,l,r,updatesArr):\\n        updatesArr[l]+=1\\n        if r+1<len(updatesArr):\\n            updatesArr[r+1]-=1\\n                \\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        nums1 = sorted(nums)\\n        updatesArr = [0 for i in nums]\\n        \\n        countLeft,countRight,startIndex,endIndex = {},{},{},{}\\n    \\n        countLeft[nums[0]] = 1\\n        \\n        # populating countRight dictionary\\n        for i in range(1,len(nums)):\\n            if nums[i] not in countRight:\\n                countRight[nums[i]] = 0\\n                \\n            countRight[nums[i]]+=1\\n        \\n        # populating startIndex and endIndex dictionary\\n        for i in range(len(nums1)):\\n            if nums1[i] not in startIndex:\\n                startIndex[nums1[i]] = i\\n                \\n            if nums1[i] not in endIndex:\\n                endIndex[nums1[i]] = i\\n                \\n            endIndex[nums1[i]] = i\\n                \\n        \\n        leftSum,rightSum = nums[0],sum(nums[1:])\\n        noChangeCount = 0\\n        \\n        for i in range(1,len(nums)):\\n            if leftSum==rightSum:\\n                noChangeCount += 1\\n            else:\\n                n = leftSum-rightSum+k\\n                if n in countLeft:\\n                    l = startIndex[n]\\n                    r = startIndex[n] + countLeft[n] - 1\\n                    self.update(l,r,updatesArr)\\n                \\n                n = rightSum-leftSum+k\\n                if n in countRight:\\n                    r = endIndex[n]\\n                    l = endIndex[n] - countRight[n] + 1\\n                    self.update(l,r,updatesArr)\\n            \\n            leftSum+=nums[i]\\n            rightSum-=nums[i]\\n            \\n            if nums[i] not in countLeft:\\n                countLeft[nums[i]] = 0\\n                \\n            countLeft[nums[i]]+=1\\n            countRight[nums[i]]-=1\\n            \\n            if not countRight[nums[i]]:\\n                del countRight[nums[i]]\\n                \\n        maxPrefixSum = 0\\n        current = 0\\n        for i in updatesArr:\\n            current+=i\\n            maxPrefixSum = max(maxPrefixSum,current)\\n        \\n        return max(maxPrefixSum,noChangeCount)\\n        \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def update(self,l,r,updatesArr):\\n        updatesArr[l]+=1\\n        if r+1<len(updatesArr):\\n            updatesArr[r+1]-=1\\n                \\n    def waysToPartition(self, nums: List[int], k: int) -> int:\\n        nums1 = sorted(nums)\\n        updatesArr = [0 for i in nums]\\n        \\n        countLeft,countRight,startIndex,endIndex = {}",
                "codeTag": "Java"
            },
            {
                "id": 1500589,
                "title": "simple-c-solution-o-n-left-and-right-difference",
                "content": "solution given by @tejustiwari\\n```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, long long int k) {\\n        map<long long int, long long int> leftUpdate, rightUpdate;\\n        long long int right = accumulate(nums.begin(), nums.end(), 0ll), left = 0, ans = 0;\\n        \\n        for (long long int i = 0; i < nums.size() - 1; ++i) {\\n            left += nums[i];\\n            right -= nums[i];\\n            ans += (left == right);\\n            long long int diff = right - left;\\n            ++leftUpdate[diff];\\n        }\\n\\n        right = accumulate(nums.begin(), nums.end(), 0ll), left = 0;\\n        \\n        for (long long int i = 0; i < nums.size(); ++i) {\\n            left += nums[i];\\n            right -= nums[i];\\n            long long int delta = k - nums[i];\\n            ans = max(ans, rightUpdate[delta] + leftUpdate[delta]);\\n            --leftUpdate[right - left];\\n            ++rightUpdate[left - right];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, long long int k) {\\n        map<long long int, long long int> leftUpdate, rightUpdate;\\n        long long int right = accumulate(nums.begin(), nums.end(), 0ll), left = 0, ans = 0;\\n        \\n        for (long long int i = 0; i < nums.size() - 1; ++i) {\\n            left += nums[i];\\n            right -= nums[i];\\n            ans += (left == right);\\n            long long int diff = right - left;\\n            ++leftUpdate[diff];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1500540,
                "title": "c-1-178-test-cases-failed-why-not-tle",
                "content": "Approach:\\n\\nMaintained a map of indices for each occurence of a value, total Sum and sum till index i-1. V[j] stores the number of pivot points that get generated after changing nums[j] to k. count stores number of pivot points without changing the array. \\nfor each index i(1 to n-1), if its already pivot point increment in count, else some elment may be from left(0 to i-1) or from right(i to n-1) should be replaced. If it is from right that element should be x = totSum-2\\\\*sum+k(bcz   sum = (totSum - sum) -x +k). Simlarly if it is from left it should be x = 2\\\\*sum - totSum + k.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> M;\\n    int waysToPartition(vector<int>& nums, int k) {\\n        long n = nums.size(), totSum = 0;\\n        for(int i = 0; i<n; i++){\\n            totSum += nums[i];\\n            M[nums[i]].push_back(i);\\n        }\\n        vector<int> V(n,0);\\n        long sum = 0;\\n        int count = 0;\\n        for(int i = 1;i<n;i++){\\n            sum += nums[i-1];\\n            if(2*sum == totSum)count++;\\n            else{\\n                for(int j: M[totSum-2*sum+k]){\\n                    if(j>=i)V[j]++;\\n                }\\n                for(int j: M[2*sum-totSum+k]){\\n                    if(j<i)V[j]++;\\n                }\\n                \\n            }\\n        }\\n        for(int i : V)count = max(count, i);\\n        return count;\\n    }\\n};\\n```\\n\\nThis code passed 177/178 cases. Where is my mistake?\\n\\nPlease paste the code and run to get that odd case. The expected output is 0. My code returns 1.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> M;\\n    int waysToPartition(vector<int>& nums, int k) {\\n        long n = nums.size(), totSum = 0;\\n        for(int i = 0; i<n; i++){\\n            totSum += nums[i];\\n            M[nums[i]].push_back(i);\\n        }\\n        vector<int> V(n,0);\\n        long sum = 0;\\n        int count = 0;\\n        for(int i = 1;i<n;i++){\\n            sum += nums[i-1];\\n            if(2*sum == totSum)count++;\\n            else{\\n                for(int j: M[totSum-2*sum+k]){\\n                    if(j>=i)V[j]++;\\n                }\\n                for(int j: M[2*sum-totSum+k]){\\n                    if(j<i)V[j]++;\\n                }\\n                \\n            }\\n        }\\n        for(int i : V)count = max(count, i);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500056,
                "title": "java-hashmap-left-and-right-counts-of-diffs",
                "content": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pre = new long[n], post = new long[n];\\n        pre[0] = (long)nums[0];\\n        post[n-1] = (long)nums[n-1];\\n        for(int i =1;i<n;i++) {\\n            pre[i] = pre[i-1]+ (long)nums[i];\\n            post[n-1-i] = post[n-i]  + (long)nums[n-1-i];\\n        }\\n        HashMap<Long, Integer> left = new HashMap<>(), right = new HashMap<>();\\n        for(int i =0;i < n-1;i++) {\\n            long d = post[i] - pre[i] - (long)nums[i];\\n            right.put(d, right.getOrDefault(d, 0) + 1);\\n        }\\n        int maxParts = right.getOrDefault(0L, 0);\\n        for(int i = 0; i < n ; i++) {\\n            long d = (long)k - (long)nums[i];\\n            maxParts = Math.max(maxParts , (right.getOrDefault(d,0) + left.getOrDefault(-d,0)) );\\n            if( i < n-1) {\\n                long l = pre[i];\\n                long r = post[i+1];\\n\\n                left.put(r-l, left.getOrDefault(r-l, 0)+1);\\n                right.put(r-l, right.getOrDefault(r-l, 0)-1);\\n            }\\n        }\\n        return maxParts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] pre = new long[n], post = new long[n];\\n        pre[0] = (long)nums[0];\\n        post[n-1] = (long)nums[n-1];\\n        for(int i =1;i<n;i++) {\\n            pre[i] = pre[i-1]+ (long)nums[i];\\n            post[n-1-i] = post[n-i]  + (long)nums[n-1-i];\\n        }\\n        HashMap<Long, Integer> left = new HashMap<>(), right = new HashMap<>();\\n        for(int i =0;i < n-1;i++) {\\n            long d = post[i] - pre[i] - (long)nums[i];\\n            right.put(d, right.getOrDefault(d, 0) + 1);\\n        }\\n        int maxParts = right.getOrDefault(0L, 0);\\n        for(int i = 0; i < n ; i++) {\\n            long d = (long)k - (long)nums[i];\\n            maxParts = Math.max(maxParts , (right.getOrDefault(d,0) + left.getOrDefault(-d,0)) );\\n            if( i < n-1) {\\n                long l = pre[i];\\n                long r = post[i+1];\\n\\n                left.put(r-l, left.getOrDefault(r-l, 0)+1);\\n                right.put(r-l, right.getOrDefault(r-l, 0)-1);\\n            }\\n        }\\n        return maxParts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499889,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        vector<int> l(nums.size());\\n        vector<int> r(nums.size());\\n        vector<long long> sum(nums.size());\\n        sum[0] = nums[0];\\n        for(int i = 1;i<nums.size();i++) {\\n            sum[i] = sum[i-1] + nums[i];\\n        }\\n        unordered_map<long long,int> m; \\n        for(int i = nums.size()-1;i>=1;i--) {\\n            long long right = sum.back() - sum[i-1];\\n            long long left = sum[i-1];\\n            long long diff = right - left; \\n            m[diff]++;\\n            l[i-1] = m[k-nums[i-1]];\\n        }\\n        m.clear();\\n        for(int i = 1;i<nums.size();i++) {\\n            long long left = sum[i-1];\\n            long long right = sum.back() - sum[i-1];\\n            m[left-right]++;\\n            r[i] = m[k-nums[i]];\\n        }\\n        int ret = 0; \\n        for(int i = 0;i<nums.size();i++) {\\n            ret = max(ret,l[i] + r[i]);\\n        }\\n        int count = 0; \\n        for(int i = 0;i<nums.size()-1;i++) {\\n            if(sum[i] == sum.back()-sum[i]) {\\n                count++;\\n            }\\n        }\\n        ret = max(ret,count);\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int waysToPartition(vector<int>& nums, int k) {\\n        vector<int> l(nums.size());\\n        vector<int> r(nums.size());\\n        vector<long long> sum(nums.size());\\n        sum[0] = nums[0];\\n        for(int i = 1;i<nums.size();i++) {\\n            sum[i] = sum[i-1] + nums[i];\\n        }\\n        unordered_map<long long,int> m; \\n        for(int i = nums.size()-1;i>=1;i--) {\\n            long long right = sum.back() - sum[i-1];\\n            long long left = sum[i-1];\\n            long long diff = right - left; \\n            m[diff]++;\\n            l[i-1] = m[k-nums[i-1]];\\n        }\\n        m.clear();\\n        for(int i = 1;i<nums.size();i++) {\\n            long long left = sum[i-1];\\n            long long right = sum.back() - sum[i-1];\\n            m[left-right]++;\\n            r[i] = m[k-nums[i]];\\n        }\\n        int ret = 0; \\n        for(int i = 0;i<nums.size();i++) {\\n            ret = max(ret,l[i] + r[i]);\\n        }\\n        int count = 0; \\n        for(int i = 0;i<nums.size()-1;i++) {\\n            if(sum[i] == sum.back()-sum[i]) {\\n                count++;\\n            }\\n        }\\n        ret = max(ret,count);\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499683,
                "title": "java-prefix-sum-hash-map-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n= nums.length;\\n        long[] ps= new long[n];\\n        ps[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            ps[i]= ps[i-1] + nums[i];\\n        }\\n        Map<Long, ArrayList<Integer>> partDiffs= new HashMap<>();\\n        int maxWays= 0;\\n        // i: pivot index, first element of right partition\\n        // bucket indices by the difference between the partitions they create\\n        for(int i=1; i<n; i++){\\n            long partL= ps[i-1], partR= ps[n-1]-partL, partDiff= partR-partL;\\n            if(partDiff==0) maxWays++;\\n            ArrayList<Integer> idxSet= partDiffs.get(partDiff);\\n            if(idxSet==null) partDiffs.put(partDiff, idxSet= new ArrayList<Integer>());\\n            idxSet.add(i);\\n        }\\n        // for each j check how many diffs k-nums[j] are there with change of diff sign at j\\n        // j: element changed to k\\n        for(int j=0; j<n; j++){\\n            int ways= 0;\\n            long newDiff= k-nums[j];\\n            ArrayList<Integer> leftList= partDiffs.get(newDiff); \\n            if(leftList!=null){\\n                int i= upperBound(leftList, j);\\n                ways+= leftList.size()-i;\\n            }\\n            ArrayList<Integer> rightList= partDiffs.get(-newDiff);\\n            if(rightList!=null){\\n                int i= upperBound(rightList, j);\\n                ways+= i;\\n            }\\n            maxWays= Math.max(ways, maxWays);\\n        }\\n        return maxWays;\\n    }    \\n\\n    public static int upperBound(ArrayList<Integer> arr, int val){\\n        int ans= -1, n= arr.size(), l= 0, r= n;\\n        while(l<=r){\\n            int mid= l+(r-l)/2;\\n            if(mid==n) return n;\\n            if(arr.get(mid)>val){\\n                ans= mid;\\n                r= mid-1;\\n            }else{\\n                l= mid+1;\\n            }\\n        }\\n        return ans;\\n    } \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int waysToPartition(int[] nums, int k) {\\n        int n= nums.length;\\n        long[] ps= new long[n];\\n        ps[0]= nums[0];\\n        for(int i=1; i<n; i++){\\n            ps[i]= ps[i-1] + nums[i];\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565802,
                "content": [
                    {
                        "username": "Juwentus",
                        "content": "Input: nums = [2,-1,2], k = 3\\nOutput: 1\\n\\nSo why [2, | -1, 3] is not an answer? since [3, -1| 2] is one."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "As [@itoomann](/itoomann) said, the problem is not very clear.\\n\\nThe problem allows us to change **at most 1** element of the array, then return the **maximum** of all the possible ways.\\n\\n- if we change nums[0] to 3, the answer is 1.\\n- if we change nums[2] to 3, the answer is also 1.\\n- if we don\\'t change any element in that array, the answer is 0.\\n\\nso the final answer to this problem would be `max(1, 1, 0) = 1`. **Not** `sum(1,1,0) = 2`."
                    },
                    {
                        "username": "itoomann",
                        "content": "[2,-1,2], k = 3\\n\\nShouldn\\'t the answer be 2?\\n\\nSplitting it to [2, -1] , [2] and then changing num[0] to k=3 is one solution. \\n\\nSplitting it to [2] , [-1, 2] and then changing num[2] to k=3 is another solution\\n\\nEDIT: I understand now. The question prompt isn\\'t clear. You\\'re allowed to change one element and then do the pivoting. \\nI assumed that you can choose one element to change after each pivot.\\n\\ni.e. You can\\'t pick two different elements to change for two different pivots. The changed element has to be the same for all pivots."
                    },
                    {
                        "username": "fengxuenuig",
                        "content": "nums: [2,-1,2] k = 3\\n\\nthe answer is change the first 2 to 3, [3,-1,2] pivot = 2  -> [3,-1,| 2]\\n\\nwhy cant change the last 2 to 3 [2,-1,3] and pivot = 1 ->[2,|-1,3]\\n???\\n"
                    }
                ]
            },
            {
                "id": 1576098,
                "content": [
                    {
                        "username": "Juwentus",
                        "content": "Input: nums = [2,-1,2], k = 3\\nOutput: 1\\n\\nSo why [2, | -1, 3] is not an answer? since [3, -1| 2] is one."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "As [@itoomann](/itoomann) said, the problem is not very clear.\\n\\nThe problem allows us to change **at most 1** element of the array, then return the **maximum** of all the possible ways.\\n\\n- if we change nums[0] to 3, the answer is 1.\\n- if we change nums[2] to 3, the answer is also 1.\\n- if we don\\'t change any element in that array, the answer is 0.\\n\\nso the final answer to this problem would be `max(1, 1, 0) = 1`. **Not** `sum(1,1,0) = 2`."
                    },
                    {
                        "username": "itoomann",
                        "content": "[2,-1,2], k = 3\\n\\nShouldn\\'t the answer be 2?\\n\\nSplitting it to [2, -1] , [2] and then changing num[0] to k=3 is one solution. \\n\\nSplitting it to [2] , [-1, 2] and then changing num[2] to k=3 is another solution\\n\\nEDIT: I understand now. The question prompt isn\\'t clear. You\\'re allowed to change one element and then do the pivoting. \\nI assumed that you can choose one element to change after each pivot.\\n\\ni.e. You can\\'t pick two different elements to change for two different pivots. The changed element has to be the same for all pivots."
                    },
                    {
                        "username": "fengxuenuig",
                        "content": "nums: [2,-1,2] k = 3\\n\\nthe answer is change the first 2 to 3, [3,-1,2] pivot = 2  -> [3,-1,| 2]\\n\\nwhy cant change the last 2 to 3 [2,-1,3] and pivot = 1 ->[2,|-1,3]\\n???\\n"
                    }
                ]
            },
            {
                "id": 1570630,
                "content": [
                    {
                        "username": "Juwentus",
                        "content": "Input: nums = [2,-1,2], k = 3\\nOutput: 1\\n\\nSo why [2, | -1, 3] is not an answer? since [3, -1| 2] is one."
                    },
                    {
                        "username": "xiyu0612",
                        "content": "As [@itoomann](/itoomann) said, the problem is not very clear.\\n\\nThe problem allows us to change **at most 1** element of the array, then return the **maximum** of all the possible ways.\\n\\n- if we change nums[0] to 3, the answer is 1.\\n- if we change nums[2] to 3, the answer is also 1.\\n- if we don\\'t change any element in that array, the answer is 0.\\n\\nso the final answer to this problem would be `max(1, 1, 0) = 1`. **Not** `sum(1,1,0) = 2`."
                    },
                    {
                        "username": "itoomann",
                        "content": "[2,-1,2], k = 3\\n\\nShouldn\\'t the answer be 2?\\n\\nSplitting it to [2, -1] , [2] and then changing num[0] to k=3 is one solution. \\n\\nSplitting it to [2] , [-1, 2] and then changing num[2] to k=3 is another solution\\n\\nEDIT: I understand now. The question prompt isn\\'t clear. You\\'re allowed to change one element and then do the pivoting. \\nI assumed that you can choose one element to change after each pivot.\\n\\ni.e. You can\\'t pick two different elements to change for two different pivots. The changed element has to be the same for all pivots."
                    },
                    {
                        "username": "fengxuenuig",
                        "content": "nums: [2,-1,2] k = 3\\n\\nthe answer is change the first 2 to 3, [3,-1,2] pivot = 2  -> [3,-1,| 2]\\n\\nwhy cant change the last 2 to 3 [2,-1,3] and pivot = 1 ->[2,|-1,3]\\n???\\n"
                    }
                ]
            }
        ]
    }
]