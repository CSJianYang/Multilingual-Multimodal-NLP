[
    {
        "title": "Minimum Cost to Make Array Equal",
        "question_content": "You are given two 0-indexed arrays nums and cost consisting each of n positive integers.\nYou can do the following operation any number of times:\n\n\tIncrease or decrease any element of the array nums by 1.\n\nThe cost of doing one operation on the ith element is cost[i].\nReturn the minimum total cost such that all the elements of the array nums become equal.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,5,2], cost = [2,3,1,14]\nOutput: 8\nExplanation: We can make all the elements equal to 2 in the following way:\n- Increase the 0th element one time. The cost is 2.\n- Decrease the 1st element one time. The cost is 3.\n- Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3.\nThe total cost is 2 + 3 + 3 = 8.\nIt can be shown that we cannot make the array equal with a smaller cost.\n\nExample 2:\n\nInput: nums = [2,2,2,2,2], cost = [4,2,8,1,3]\nOutput: 0\nExplanation: All the elements are already equal, so no operations are needed.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length == cost.length\n\t1 <= n <= 105\n\t1 <= nums[i], cost[i] <= 106\n\tTest cases are generated in a way that the output doesn't exceed&nbsp;253-1",
        "solutions": [
            {
                "id": 2734162,
                "title": "java-c-python-binary-search",
                "content": "# **Explanation**\\nAssume the final equal values are `x`\\nthe total cost function `y = f(x)` is a **convex function**\\non the range of `[min(A), max(A)]`.\\n\\nTo find the minimum value of `f(x)`,\\nwe can binary search `x` by comparing `f(mid)` and `f(mid + 1)`.\\n\\nIf `f(mid) <= f(mid + 1)`,\\nthe minimum `f(x)` is on the left of `mid`,\\nwhere `x <= mid`\\n\\nIf `f(mid) >= f(mid + 1)`,\\nthe minimum `f(x)` is on the right of `mid + 1`,\\nwhere `x >= mid`.\\n\\nRepeatly doing this while `left < right`,\\nuntil we find the minimum value and return it.\\n\\nThis method is known as trinary search,\\nif we check `f(mid1)` and `f(mid2)`.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog(a))`, where a is the range of `A[i]`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\nBy @nitwmanish\\n```java\\n    private long findCost(int[] nums, int[] cost, long x) {\\n        long res = 0L;\\n        for (int i = 0; i < nums.length; i++){\\n            res += Math.abs(nums[i] - x) * cost[i];\\n        }\\n        return res;\\n    }\\n    public long minCost(int[] nums, int[] cost) {\\n        long left = 1L;\\n        long right = 1000000L;\\n        for (int num : nums) {\\n            left = Math.min(num, left);\\n            right = Math.max(num, right);\\n        }\\n        long ans = findCost(nums, cost, 1);\\n        while (left < right) {\\n            long mid = (left + right) / 2;\\n            long y1 = findCost(nums, cost, mid);\\n            long y2 = findCost(nums, cost, mid + 1);\\n            ans = Math.min(y1, y2);\\n            if (y1 < y2){\\n                right = mid;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**C++**\\n```cpp\\n    long long minCost(vector<int>& A, vector<int>& cost) {\\n        long long l = 1, r = 1000000, res = f(A, cost, 1), x;\\n        while (l < r) {\\n            x = (l + r) / 2;\\n            long long y1 = f(A, cost, x), y2 = f(A, cost, x + 1);\\n            res = min(y1, y2);\\n            if (y1 < y2)\\n                r = x;\\n            else\\n                l = x + 1;\\n        }\\n        return res;\\n    }\\n\\n    long long f(vector<int>& A, vector<int>& cost, int x) {\\n        long long res = 0;\\n        for (int i = 0; i < A.size(); ++i)\\n            res += 1L * abs(A[i] - x) * cost[i];\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def minCost(self, A, cost):\\n        def f(x):\\n            return sum(abs(a - x) * c for a,c in zip(A, cost))\\n\\n        l, r = min(A), max(A)\\n        res = f(l)\\n        while l < r:\\n            x = (l + r) // 2\\n            y1, y2 = f(x), f(x + 1)\\n            res = min(y1, y2)\\n            if y1 < y2:\\n                r = x\\n            else:\\n                l = x + 1\\n        return res\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    private long findCost(int[] nums, int[] cost, long x) {\\n        long res = 0L;\\n        for (int i = 0; i < nums.length; i++){\\n            res += Math.abs(nums[i] - x) * cost[i];\\n        }\\n        return res;\\n    }\\n    public long minCost(int[] nums, int[] cost) {\\n        long left = 1L;\\n        long right = 1000000L;\\n        for (int num : nums) {\\n            left = Math.min(num, left);\\n            right = Math.max(num, right);\\n        }\\n        long ans = findCost(nums, cost, 1);\\n        while (left < right) {\\n            long mid = (left + right) / 2;\\n            long y1 = findCost(nums, cost, mid);\\n            long y2 = findCost(nums, cost, mid + 1);\\n            ans = Math.min(y1, y2);\\n            if (y1 < y2){\\n                right = mid;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```cpp\\n    long long minCost(vector<int>& A, vector<int>& cost) {\\n        long long l = 1, r = 1000000, res = f(A, cost, 1), x;\\n        while (l < r) {\\n            x = (l + r) / 2;\\n            long long y1 = f(A, cost, x), y2 = f(A, cost, x + 1);\\n            res = min(y1, y2);\\n            if (y1 < y2)\\n                r = x;\\n            else\\n                l = x + 1;\\n        }\\n        return res;\\n    }\\n\\n    long long f(vector<int>& A, vector<int>& cost, int x) {\\n        long long res = 0;\\n        for (int i = 0; i < A.size(); ++i)\\n            res += 1L * abs(A[i] - x) * cost[i];\\n        return res;\\n    }\\n```\n```py\\n    def minCost(self, A, cost):\\n        def f(x):\\n            return sum(abs(a - x) * c for a,c in zip(A, cost))\\n\\n        l, r = min(A), max(A)\\n        res = f(l)\\n        while l < r:\\n            x = (l + r) // 2\\n            y1, y2 = f(x), f(x + 1)\\n            res = min(y1, y2)\\n            if y1 < y2:\\n                r = x\\n            else:\\n                l = x + 1\\n        return res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734728,
                "title": "pure-math-based-explanation-of-why-cost-function-is-convex",
                "content": "Apologies for poor handwriting and diagrams. I hope the idea gets clear though.\\n\\n![image](https://assets.leetcode.com/users/images/be94aac3-a5cb-4e00-94aa-d58cb46a7fe7_1666503759.96698.png)\\n\\n![image](https://assets.leetcode.com/users/images/4e24bb35-98d2-4cc8-a466-47f86a866656_1666503760.122056.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/aed4a3e8-3868-4912-b69c-746f2b118a49_1666503778.3573084.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/808868e3-583a-4cc5-8174-6904c54163a1_1666503792.12889.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "Apologies for poor handwriting and diagrams. I hope the idea gets clear though.\\n\\n![image](https://assets.leetcode.com/users/images/be94aac3-a5cb-4e00-94aa-d58cb46a7fe7_1666503759.96698.png)\\n\\n![image](https://assets.leetcode.com/users/images/4e24bb35-98d2-4cc8-a466-47f86a866656_1666503760.122056.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/aed4a3e8-3868-4912-b69c-746f2b118a49_1666503778.3573084.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/808868e3-583a-4cc5-8174-6904c54163a1_1666503792.12889.jpeg)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2734183,
                "title": "python3-weighted-median-o-nlogn-with-explanations",
                "content": "**Observation**\\nThink of the `cost` array as the **weight** of the corresponding `num` in the `nums` array. For example when `nums = [1, 3, 5, 2]` and `cost = [2, 3, 1, 14]`, suppose we want to increase `1` in `nums` to `2`, we know that the cost for this operation is 2. However, this is equivalent as if there are two `1`\\u2019s in `nums` and we increase both of them to `2`. Therefore, the minimum total cost such that all the elements of the array `nums` become equal is equivalent to the minimum total cost such that all the elements of the array\\n`nums = [1, 1, 3, 3, 3, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]`\\nbecome equal, with the cost of doing one operation on each element being 1. As such, the answer to this question is the total cost for moving all elements to the (unweighted) median in the new (collapsed) array. See also [LC 462. Minimum Moves to Equal Array Elements II](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/) and [LC 296. Best Meeting Point](https://leetcode.com/problems/best-meeting-point/) for practice of unweighted median problems.\\n\\n**Implementation**\\nWe find the **weighted median** of `nums` by sorting the `(num, weight)` pair of the original arrays. We then use the weighted median (`target`) to calculate the minimum total cost such that all the elements of the array `nums` becomes equal, which is the answer to this question.\\n\\n**Complexity**\\nTime Complexity: `O(NlogN)`\\nSpace Complexity: `O(N)`, for the use of `arr`\\n \\n **Solution**\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        arr = sorted(zip(nums, cost))\\n        total, cnt = sum(cost), 0\\n        for num, c in arr:\\n            cnt += c\\n            if cnt > total // 2:\\n                target = num\\n                break\\n        return sum(c * abs(num - target) for num, c in arr)\\n```\\n\\n **Follow-up (open question)** Can we improve the time complexity from `O(NlogN)` to `O(N)` on average by using quick-select on finding the weighted median?",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        arr = sorted(zip(nums, cost))\\n        total, cnt = sum(cost), 0\\n        for num, c in arr:\\n            cnt += c\\n            if cnt > total // 2:\\n                target = num\\n                break\\n        return sum(c * abs(num - target) for num, c in arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734091,
                "title": "dp-vs-w-median-vs-binary-search",
                "content": "I\\'d say DP is the \"go to\" solution for the interview.\\n\\nBinary search needs some reasoning, and the weighted median is quite tricky.\\n\\n#### DP\\nIn the end, all elements of the array will be equal to some element `n[i]`.\\n\\n> Well, you say, if our array is `[2, 5]`, what if we can achieve min cost by making them `3` or `4`?\\n> For this to be the case, the cost for both `2` and `5` must be the same. But if the cost the same, we can achieve the same min cost if we pick `2` or `5`.\\n    \\nLet\\'s call it a pivot.\\n    \\nIf we sort the array, elements on the left of the pivot will increase, and on the right - decrease.\\n\\nWe go left-to-right in the sorted array, and compute cost for each pivot (`cost_l[i]`).\\n    \\nThen we do the same right-to-left, compute cost (`cost_r`), track and the minimum total cost (`min(cost_l[i], cost_r)`).\\n    \\n**C++**\\n```cpp\\nlong long minCost(vector<int>& n, vector<int>& cost) {\\n    vector<long long> id(n.size()), cost_l(n.size());\\n    iota(begin(id), end(id), 0);\\n    sort(begin(id), end(id), [&](int i, int j){\\n        return n[i] < n[j];\\n    });\\n    for (long long i = 0, psum = 0; i < n.size() - 1; ++i) {\\n        psum += cost[id[i]];\\n        cost_l[i + 1] = cost_l[i] + psum * (n[id[i + 1]] - n[id[i]]);\\n    }\\n    long long res = cost_l.back(), cost_r = 0;\\n    for (long long j = n.size() - 1, psum = 0; j > 0; --j) {\\n        psum += cost[id[j]];\\n        cost_r += psum * (n[id[j]] - n[id[j - 1]]);\\n        res = min(res, cost_l[j - 1] + cost_r);\\n    }\\n    return res;\\n}\\n```\\n#### Binary Search\\nThis solution is based on the fact that the cost is the convex function (monotonically descending to, and then ascending from, a single minimum).\\n\\nFor a given point, we compute the cost for it and its neighbor. By comparing those costs, we can tell whether the minimum is on the left or on the right.\\n\\nWe binary-search for that minimum.\\n\\n**C++**\\n```cpp\\nlong long minCost(vector<int>& n, vector<int>& cost) {\\n    long long l = 1, r = 1000000, res = 0, res1 = 0;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        res = res1 = 0;\\n        for (int i = 0; i < n.size(); ++i) {\\n            res += (long long)cost[i] * abs(n[i] - m);\\n            res1 += (long long)cost[i] * abs(n[i] - (m + 1));\\n        }\\n        if (res < res1)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return min(res, res1);    \\n}\\n```\\n\\n#### Weighted Median\\nIf the cost for all element is the same, then the minimum cost is when all numbers converge at the median.\\n\\nSince the cost is not the same, we need to find a weighted median.\\n\\nTo find a weighted median, we sort elements, \"repeating\" each element based on its weight.\\n\\nFor `[1,3,5,2], [2,3,1,4]` case, the repeated array looks like this (median is in bold): [1,1,2,2,**2,2**,3,3,3,5].\\n\\nWe do not need to actually generate that repeated array, we can just simulate it.\\n\\nWe find the total weight (10), aggregate the current weight going from one side, and stop when `current >= total / 2`.\\n\\n**C++**\\nWe sort the index array, so we do not have to combine `n` and `cost` and sort them together.\\n```cpp\\nlong long minCost(vector<int>& n, vector<int>& cost) {\\n    vector<long long> id(n.size());\\n    iota(begin(id), end(id), 0);\\n    sort(begin(id), end(id), [&](int i, int j){ return n[i] < n[j]; });\\n    long long total = accumulate(begin(cost), end(cost), 0LL), j = 0;\\n    for (long long cur = 0; cur + cost[id[j]] < total / 2; ++j)\\n        cur += cost[id[j]];\\n    return accumulate(begin(id), end(id), 0LL, [&](long long sum, int i){\\n        return sum + (long long)cost[id[i]] * abs(n[id[i]] - n[id[j]]);\\n    });\\n}\\n```\\n#### Weighted Median + Binary Search\\nInstead of sorting, we can use binary search to find the weigthed median.\\n\\n**C++**\\n```cpp\\nlong long minCost(vector<int>& n, vector<int>& cost) {\\n    long long total = accumulate(begin(cost), end(cost), 0LL), res = 0;\\n    int l = 0, r = 1000000;\\n    while (l < r) {\\n        long long sum = 0, m = (l + r) / 2;\\n        for (int i = 0; i < n.size(); ++i)\\n            sum += n[i] <= m ? cost[i] : 0;\\n        if (sum <= total / 2)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    for (int i = 0; i < n.size(); ++i)\\n        res += (long long)cost[i] * abs(n[i] - l);\\n    return res;    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minCost(vector<int>& n, vector<int>& cost) {\\n    vector<long long> id(n.size()), cost_l(n.size());\\n    iota(begin(id), end(id), 0);\\n    sort(begin(id), end(id), [&](int i, int j){\\n        return n[i] < n[j];\\n    });\\n    for (long long i = 0, psum = 0; i < n.size() - 1; ++i) {\\n        psum += cost[id[i]];\\n        cost_l[i + 1] = cost_l[i] + psum * (n[id[i + 1]] - n[id[i]]);\\n    }\\n    long long res = cost_l.back(), cost_r = 0;\\n    for (long long j = n.size() - 1, psum = 0; j > 0; --j) {\\n        psum += cost[id[j]];\\n        cost_r += psum * (n[id[j]] - n[id[j - 1]]);\\n        res = min(res, cost_l[j - 1] + cost_r);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nlong long minCost(vector<int>& n, vector<int>& cost) {\\n    long long l = 1, r = 1000000, res = 0, res1 = 0;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        res = res1 = 0;\\n        for (int i = 0; i < n.size(); ++i) {\\n            res += (long long)cost[i] * abs(n[i] - m);\\n            res1 += (long long)cost[i] * abs(n[i] - (m + 1));\\n        }\\n        if (res < res1)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return min(res, res1);    \\n}\\n```\n```cpp\\nlong long minCost(vector<int>& n, vector<int>& cost) {\\n    vector<long long> id(n.size());\\n    iota(begin(id), end(id), 0);\\n    sort(begin(id), end(id), [&](int i, int j){ return n[i] < n[j]; });\\n    long long total = accumulate(begin(cost), end(cost), 0LL), j = 0;\\n    for (long long cur = 0; cur + cost[id[j]] < total / 2; ++j)\\n        cur += cost[id[j]];\\n    return accumulate(begin(id), end(id), 0LL, [&](long long sum, int i){\\n        return sum + (long long)cost[id[i]] * abs(n[id[i]] - n[id[j]]);\\n    });\\n}\\n```\n```cpp\\nlong long minCost(vector<int>& n, vector<int>& cost) {\\n    long long total = accumulate(begin(cost), end(cost), 0LL), res = 0;\\n    int l = 0, r = 1000000;\\n    while (l < r) {\\n        long long sum = 0, m = (l + r) / 2;\\n        for (int i = 0; i < n.size(); ++i)\\n            sum += n[i] <= m ? cost[i] : 0;\\n        if (sum <= total / 2)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    for (int i = 0; i < n.size(); ++i)\\n        res += (long long)cost[i] * abs(n[i] - l);\\n    return res;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734766,
                "title": "c-prefix-sum-precomputation-detailed-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/abde0d3b-d9a0-410f-b16c-bf36e57ad673_1666504386.861779.jpeg)\\n\\nIn The Result Equation, it should be \\'-\\' between to summation.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        long long ans = 1e18;\\n        vector<pair<int,int>> v(n);\\n        for(int i = 0; i < nums.size(); i++)\\n            v[i] = {nums[i], cost[i]};\\n        \\n        sort(v.begin(), v.end());\\n        vector<long long> pref(n), suff(n);\\n        long long c_sum = 0, nc = 0;\\n        for(int i = 0; i < n; i++){\\n            pref[i] = (v[i].first * c_sum - nc);\\n            c_sum += (long long)v[i].second;\\n            nc += (long long)v[i].first * (long long)v[i].second;\\n        }\\n        c_sum = 0, nc = 0;\\n        for(int i = n - 1; i >= 0; i--){\\n            ans = min(ans, abs(v[i].first * c_sum - nc) + pref[i]);\\n            c_sum += (long long)v[i].second;\\n            nc += (long long)v[i].first * (long long)v[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do Upvote if this was helpful to you!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        long long ans = 1e18;\\n        vector<pair<int,int>> v(n);\\n        for(int i = 0; i < nums.size(); i++)\\n            v[i] = {nums[i], cost[i]};\\n        \\n        sort(v.begin(), v.end());\\n        vector<long long> pref(n), suff(n);\\n        long long c_sum = 0, nc = 0;\\n        for(int i = 0; i < n; i++){\\n            pref[i] = (v[i].first * c_sum - nc);\\n            c_sum += (long long)v[i].second;\\n            nc += (long long)v[i].first * (long long)v[i].second;\\n        }\\n        c_sum = 0, nc = 0;\\n        for(int i = n - 1; i >= 0; i--){\\n            ans = min(ans, abs(v[i].first * c_sum - nc) + pref[i]);\\n            c_sum += (long long)v[i].second;\\n            nc += (long long)v[i].first * (long long)v[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734625,
                "title": "dp-solution-intuitive-and-clear-python",
                "content": "# Intuition & Approach\\nYou are not required a good math to come up with this solution in the contest.\\n\\nWe can construct two DP array where `left2right[i]` is the cost for increasing the elements which cost less than `nums[i]` to `nums[i]` (`nums` is sorted), and `right2left[i]` is the cost for decreasing the elements which cost greater than `nums[i]` to `nums[i]`.\\n\\nTo compute the DP array. For`left2right[i]` we can cost `left2right[i-1]` to increase every element before `i` to `nums[i-1]`, then cost `(nums[i] - nums[i-1]) * sum(cost[0 ~ i-1])` to increase all of them to `nums[i]`. Similar for `right2left`.\\n\\nFinally, the result will be the minimum of `left2right[i] + right2left[i]`, for `0 <= i < n`.\\n\\n<!-- This DP intuition is something like the [42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/). -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        n = len(nums)\\n        # Sort by nums\\n        arr = sorted((nums[i], cost[i]) for i in range(n))\\n        nums = [i[0] for i in arr]\\n        cost = [i[1] for i in arr]\\n\\n        # Compute DP left to right\\n        left2right = [0] * n\\n        curr = cost[0]\\n        for i in range(1, n):\\n            left2right[i] = left2right[i - 1] + (nums[i] - nums[i - 1]) * curr\\n            curr += cost[i]\\n\\n        # Compute DP right to left\\n        right2left = [0] * n\\n        curr = cost[-1]\\n        for i in range(n - 2, -1, -1):\\n            right2left[i] = right2left[i + 1] + (nums[i + 1] - nums[i]) * curr\\n            curr += cost[i]\\n            \\n        return min(left2right[i] + right2left[i] for i in range(n))\\n        \\n```\\n # Complexity\\nTime: `O(nlogn)` for sorting.\\nSpace: `O(n)`\\n\\n# Appendix\\nSome proof\\n\\n- The final equal number for min cost **could** always in nums.\\n\\nLet value `V` be the final equal number for min cost that not in nums, and `C` is the corresponding cost.\\n\\nFirst, it is clear that `V` can\\'t be less than `min(nums)` or greater than `max(nums)` since we can decrease the cost by getting close to the min/max.\\n\\nAssume `nums[i] < V < nums[i + 1]` for some `i`. If we move `V` to `nums[i + 1]`, the cost will increase `sum(cost[0 ~ i]) * (nums[i + 1] - V)` and decrease `sum(cost[i + 1 ~ n - 1]) * (nums[i + 1] - V)`, witch the cost will be `C + (sum(cost[i + 1 ~ n - 1]) - sum(cost[0 ~ i])) * (nums[i + 1] - V)`. Similarly, If we move `V` to `nums[i]`, the cost will be `C + (sum(cost[i + 1 ~ n - 1]) - sum(cost[0 ~ i])) * (V - nums[i])`. \\n\\nIf `sum(cost[i + 1 ~ n - 1]) == sum(cost[0 ~ i]))` than the cost will be the same in both case. If not , one of them will be less than `C`. Witch is a contradiction.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        n = len(nums)\\n        # Sort by nums\\n        arr = sorted((nums[i], cost[i]) for i in range(n))\\n        nums = [i[0] for i in arr]\\n        cost = [i[1] for i in arr]\\n\\n        # Compute DP left to right\\n        left2right = [0] * n\\n        curr = cost[0]\\n        for i in range(1, n):\\n            left2right[i] = left2right[i - 1] + (nums[i] - nums[i - 1]) * curr\\n            curr += cost[i]\\n\\n        # Compute DP right to left\\n        right2left = [0] * n\\n        curr = cost[-1]\\n        for i in range(n - 2, -1, -1):\\n            right2left[i] = right2left[i + 1] + (nums[i + 1] - nums[i]) * curr\\n            curr += cost[i]\\n            \\n        return min(left2right[i] + right2left[i] for i in range(n))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663660,
                "title": "binary-search-video-java-c-python",
                "content": "# Intuition and Pattern\\nnums = [1,3,5,2] cost = [2,3,1,14]\\nThe ans definetly lies b/w 1 and 5 i.e the min and max of the array.\\n\\n1 == >[0,6,4,14]\\n2 == >[ 2,3,3,0]\\n3 ==> [4,0,2,14]\\n4 ==> [6,3,1,28]\\n5 ==> [8,6,0,42]\\n\\nEach number and the sum is forming a pettern where it decreses first and then increses. This pattern easily leads to Binary Search.The range is (min, max) and The ans is updated at each step.\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/3r4lQepG_-8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n\\n\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int left = nums[0];\\n        int right = nums[0];\\n        for(int i: nums){\\n            left = Math.min(left,i);\\n            right = Math.max(right,i);\\n        }\\n        long ans = 0;\\n        while(left<right){\\n            int mid = (left+right)/2;\\n            long cost1 = helper(nums, cost, mid);\\n            long cost2 = helper(nums,cost, mid+1);\\n            if(cost1>cost2){\\n                left = mid+1;\\n                ans = cost2;\\n            }else{\\n                right = mid;\\n                ans = cost1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public long helper(int [] nums, int [] cost, int all){\\n        long totalCost = 0L;\\n        for(int i = 0;i<nums.length;i++){\\n            totalCost += 1L*Math.abs(nums[i]-all)*cost[i];\\n        }\\n        return totalCost;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    long long helper(vector<int>& nums, vector<int>& cost, int all) {\\n    long long totalCost = 0LL;\\n    for (int i = 0; i < nums.size(); i++) {\\n        totalCost += 1LL * abs(nums[i] - all) * cost[i];\\n    }\\n    return totalCost;\\n}\\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n    int left = nums[0];\\n    int right = nums[0];\\n    for (int i : nums) {\\n        left = min(left, i);\\n        right = max(right, i);\\n    }\\n    long long ans = 0;\\n    while (left < right) {\\n        int mid = (left + right) / 2;\\n        long long cost1 = helper(nums, cost, mid);\\n        long long cost2 = helper(nums, cost, mid + 1);\\n        if (cost1 > cost2) {\\n            left = mid + 1;\\n            ans = cost2;\\n        } else {\\n            right = mid;\\n            ans = cost1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\\n\\n\\n```\\nclass Solution:\\n    def helper(self, nums, cost, all):\\n        total_cost = 0\\n        for i in range(len(nums)):\\n            total_cost += abs(nums[i] - all) * cost[i]\\n        return total_cost\\n\\n    def minCost(self, nums, cost):\\n        left = nums[0]\\n        right = nums[0]\\n        for i in nums:\\n            left = min(left, i)\\n            right = max(right, i)\\n        ans = 0\\n        while left < right:\\n            mid = (left + right) // 2\\n            cost1 = self.helper(nums, cost, mid)\\n            cost2 = self.helper(nums, cost, mid + 1)\\n            if cost1 > cost2:\\n                left = mid + 1\\n                ans = cost2\\n            else:\\n                right = mid\\n                ans = cost1\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int left = nums[0];\\n        int right = nums[0];\\n        for(int i: nums){\\n            left = Math.min(left,i);\\n            right = Math.max(right,i);\\n        }\\n        long ans = 0;\\n        while(left<right){\\n            int mid = (left+right)/2;\\n            long cost1 = helper(nums, cost, mid);\\n            long cost2 = helper(nums,cost, mid+1);\\n            if(cost1>cost2){\\n                left = mid+1;\\n                ans = cost2;\\n            }else{\\n                right = mid;\\n                ans = cost1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public long helper(int [] nums, int [] cost, int all){\\n        long totalCost = 0L;\\n        for(int i = 0;i<nums.length;i++){\\n            totalCost += 1L*Math.abs(nums[i]-all)*cost[i];\\n        }\\n        return totalCost;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long helper(vector<int>& nums, vector<int>& cost, int all) {\\n    long long totalCost = 0LL;\\n    for (int i = 0; i < nums.size(); i++) {\\n        totalCost += 1LL * abs(nums[i] - all) * cost[i];\\n    }\\n    return totalCost;\\n}\\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n    int left = nums[0];\\n    int right = nums[0];\\n    for (int i : nums) {\\n        left = min(left, i);\\n        right = max(right, i);\\n    }\\n    long long ans = 0;\\n    while (left < right) {\\n        int mid = (left + right) / 2;\\n        long long cost1 = helper(nums, cost, mid);\\n        long long cost2 = helper(nums, cost, mid + 1);\\n        if (cost1 > cost2) {\\n            left = mid + 1;\\n            ans = cost2;\\n        } else {\\n            right = mid;\\n            ans = cost1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution:\\n    def helper(self, nums, cost, all):\\n        total_cost = 0\\n        for i in range(len(nums)):\\n            total_cost += abs(nums[i] - all) * cost[i]\\n        return total_cost\\n\\n    def minCost(self, nums, cost):\\n        left = nums[0]\\n        right = nums[0]\\n        for i in nums:\\n            left = min(left, i)\\n            right = max(right, i)\\n        ans = 0\\n        while left < right:\\n            mid = (left + right) // 2\\n            cost1 = self.helper(nums, cost, mid)\\n            cost2 = self.helper(nums, cost, mid + 1)\\n            if cost1 > cost2:\\n                left = mid + 1\\n                ans = cost2\\n            else:\\n                right = mid\\n                ans = cost1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734166,
                "title": "binary-search-c",
                "content": "# Intuition/Approach\\n\\nThis is a typical binary search problem , except that we had to bound out ans to mid for both sum(mid+1) and sum(mid-1) less than sum(mid).This is because the sum will always be increasing in a particular direction on both sides of our ans.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n long long getSum(vector<int>& nums, vector<int>& cost,int mid){\\n         long long sum = 0;\\n            for(int i =0;i<nums.size();i++){\\n                long long k = abs(nums[i]-mid);\\n                sum+= k*cost[i];  \\n            }   return sum;\\n    }\\n    \\n           long long minCost(vector<int>& nums, vector<int>& cost) {\\n           \\n        long long lo = 1,hi=1e6;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            long long sum1 = getSum(nums,cost,mid);\\n            if(lo==hi)return sum1;\\n             long long sum3 = getSum(nums,cost,mid+1);\\n             long long sum2 = getSum(nums,cost,mid-1);\\n          \\n            if(sum2>=sum1 && sum1<=sum3)return sum1; \\n            if(sum2<sum1){\\n                hi = mid;\\n                continue; } \\n            if(sum3<sum1){\\n                lo = mid;\\n                continue;\\n            }\\n        }\\n        \\n        return 0;   \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n long long getSum(vector<int>& nums, vector<int>& cost,int mid){\\n         long long sum = 0;\\n            for(int i =0;i<nums.size();i++){\\n                long long k = abs(nums[i]-mid);\\n                sum+= k*cost[i];  \\n            }   return sum;\\n    }\\n    \\n           long long minCost(vector<int>& nums, vector<int>& cost) {\\n           \\n        long long lo = 1,hi=1e6;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            long long sum1 = getSum(nums,cost,mid);\\n            if(lo==hi)return sum1;\\n             long long sum3 = getSum(nums,cost,mid+1);\\n             long long sum2 = getSum(nums,cost,mid-1);\\n          \\n            if(sum2>=sum1 && sum1<=sum3)return sum1; \\n            if(sum2<sum1){\\n                hi = mid;\\n                continue; } \\n            if(sum3<sum1){\\n                lo = mid;\\n                continue;\\n            }\\n        }\\n        \\n        return 0;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735047,
                "title": "c-complete-explanation-in-layman-terms",
                "content": "```\\n/*\\n\\n Point to be remembered : \\n \\n (1) For these type of problems \"Make all the array elements equal\" --> we will convert all \\n the elements of the array into any one of the array element (that is currently present in the array) , \\n and then we will calculate the associated cost for it.\\n \\n (2) We need to sort the array in non-decreasing order , in such a way after which all the elements less than or \\n equal to the pivot element (here we will inc/dec all the array elements into the \\'pivot\\' element) lie in its left \\n side and all the elements greater than or equal to the pivot will lie in exact right side.\\n \\n Approach : \\n \\n Let\\'s say we have an array in non-decreasing order [a , b , c , d , e , f , g]\\n \\n Definitely a <= b <= c <= d <= e <= f <= g <= ......\\n \\n Assume for now , our target pivot element is \\'d\\' , then we need to decrease \\'e\\' , \\'f\\' , \\'g\\' to \\'d\\'.\\n \\n Say the cost associated to \\'e\\' , \\'f\\' , \\'g\\' is  \\'x\\' , \\'y\\' , \\'z\\'\\n \\n Required number of operations = (e-d)*x + (f-d)*y + (g-d)*z  ....... (i)\\n \\n Simplify eqn (i) == e*x + f*y + g*z - d*x - d*y - d*z \\n \\n                  == (e*x + f*y + g*z) - d*(x+y+z)\\n                  \\n What we can observe over here is the pivot value (i.e \\'d\\') is already known to us , then we are left with two \\n variable quantities (x+y+z) and (ex + fy + gz)\\n \\n Cool , (x+y+z) is the suffix sum of all the costs after the pivot element.\\n \\n Again , we can maintain another suffix sum array which will store the (ex + fy + gz) quantity\\n \\n Where Suffix2[i] = (ex+fy+gz , fy+gz , gz)\\n \\n And   Suffix1[i] = (x+y+z , y+z , z)\\n \\n \\n Now the expression(i) can be further simplified as (Suffix2[i+1] - (pivot[i]*Suffix1[i+1])) [considering i-th \\n index element as the pivot element]\\n \\n After that do the same thing for the elements , which are currently at the left side of the pivot element using \\n Prefix1[i] and Prefix2[i] array with precomputations.\\n \\n And after calculating in a same way we will get the similar kind of expression ((pivot[i]*Prefix1[i-1]) - \\n Prefix2[i-1])\\n \\n Overall Cost Associated with it = \\n \\n (Suffix2[i+1] - (pivot[i]*Suffix1[i+1])) + ((pivot[i]*Prefix1[i-1]) - Prefix2[i-1])\\n \\n*/\\n\\n/*\\n\\nT.C : O(N*logN)\\nS.C : O(N)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int n = nums.size();\\n        vector<pair<ll,ll>>vec(n);\\n        \\n        for(int i=0;i<n;i++){\\n            vec[i]={nums[i],cost[i]};\\n        }\\n        \\n        sort(vec.begin(),vec.end());\\n        \\n        vector<ll>prefix1(n,0LL);\\n        vector<ll>suffix1(n,0LL);\\n        vector<ll>prefix2(n,0LL);\\n        vector<ll>suffix2(n,0LL);\\n        \\n        prefix1[0] = vec[0].second;\\n        prefix2[0] = vec[0].second*vec[0].first;\\n\\n        suffix1[n-1] = vec[n-1].second;\\n        suffix2[n-1] = vec[n-1].second*vec[n-1].first;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            prefix1[i] = prefix1[i-1];\\n            prefix2[i] = prefix2[i-1];\\n       \\n            prefix1[i] += vec[i].second;\\n            prefix2[i] += (vec[i].second*vec[i].first);\\n            \\n        }\\n        \\n         for(int i=n-2;i>=0;i--){\\n             \\n            suffix1[i] = suffix1[i+1];\\n            suffix2[i] = suffix2[i+1];\\n            \\n            suffix1[i] += vec[i].second;\\n            suffix2[i] += (vec[i].second*vec[i].first);\\n             \\n        }\\n        \\n        \\n        ll ans = LONG_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            ll curr_cost = 0LL;\\n            if(i>0){\\n                curr_cost += (vec[i].first*prefix1[i-1]) - prefix2[i-1];\\n            }\\n            if(i<n-1){\\n                curr_cost += suffix2[i+1] - (vec[i].first*suffix1[i+1]);\\n            }\\n            ans = min(ans,curr_cost);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n**IF YOU LIKE IT PLEASE DON\\'T FORGET TO UPVOTE :)**\\n   \\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n Point to be remembered : \\n \\n (1) For these type of problems \"Make all the array elements equal\" --> we will convert all \\n the elements of the array into any one of the array element (that is currently present in the array) , \\n and then we will calculate the associated cost for it.\\n \\n (2) We need to sort the array in non-decreasing order , in such a way after which all the elements less than or \\n equal to the pivot element (here we will inc/dec all the array elements into the \\'pivot\\' element) lie in its left \\n side and all the elements greater than or equal to the pivot will lie in exact right side.\\n \\n Approach : \\n \\n Let\\'s say we have an array in non-decreasing order [a , b , c , d , e , f , g]\\n \\n Definitely a <= b <= c <= d <= e <= f <= g <= ......\\n \\n Assume for now , our target pivot element is \\'d\\' , then we need to decrease \\'e\\' , \\'f\\' , \\'g\\' to \\'d\\'.\\n \\n Say the cost associated to \\'e\\' , \\'f\\' , \\'g\\' is  \\'x\\' , \\'y\\' , \\'z\\'\\n \\n Required number of operations = (e-d)*x + (f-d)*y + (g-d)*z  ....... (i)\\n \\n Simplify eqn (i) == e*x + f*y + g*z - d*x - d*y - d*z \\n \\n                  == (e*x + f*y + g*z) - d*(x+y+z)\\n                  \\n What we can observe over here is the pivot value (i.e \\'d\\') is already known to us , then we are left with two \\n variable quantities (x+y+z) and (ex + fy + gz)\\n \\n Cool , (x+y+z) is the suffix sum of all the costs after the pivot element.\\n \\n Again , we can maintain another suffix sum array which will store the (ex + fy + gz) quantity\\n \\n Where Suffix2[i] = (ex+fy+gz , fy+gz , gz)\\n \\n And   Suffix1[i] = (x+y+z , y+z , z)\\n \\n \\n Now the expression(i) can be further simplified as (Suffix2[i+1] - (pivot[i]*Suffix1[i+1])) [considering i-th \\n index element as the pivot element]\\n \\n After that do the same thing for the elements , which are currently at the left side of the pivot element using \\n Prefix1[i] and Prefix2[i] array with precomputations.\\n \\n And after calculating in a same way we will get the similar kind of expression ((pivot[i]*Prefix1[i-1]) - \\n Prefix2[i-1])\\n \\n Overall Cost Associated with it = \\n \\n (Suffix2[i+1] - (pivot[i]*Suffix1[i+1])) + ((pivot[i]*Prefix1[i-1]) - Prefix2[i-1])\\n \\n*/\\n\\n/*\\n\\nT.C : O(N*logN)\\nS.C : O(N)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int n = nums.size();\\n        vector<pair<ll,ll>>vec(n);\\n        \\n        for(int i=0;i<n;i++){\\n            vec[i]={nums[i],cost[i]};\\n        }\\n        \\n        sort(vec.begin(),vec.end());\\n        \\n        vector<ll>prefix1(n,0LL);\\n        vector<ll>suffix1(n,0LL);\\n        vector<ll>prefix2(n,0LL);\\n        vector<ll>suffix2(n,0LL);\\n        \\n        prefix1[0] = vec[0].second;\\n        prefix2[0] = vec[0].second*vec[0].first;\\n\\n        suffix1[n-1] = vec[n-1].second;\\n        suffix2[n-1] = vec[n-1].second*vec[n-1].first;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            prefix1[i] = prefix1[i-1];\\n            prefix2[i] = prefix2[i-1];\\n       \\n            prefix1[i] += vec[i].second;\\n            prefix2[i] += (vec[i].second*vec[i].first);\\n            \\n        }\\n        \\n         for(int i=n-2;i>=0;i--){\\n             \\n            suffix1[i] = suffix1[i+1];\\n            suffix2[i] = suffix2[i+1];\\n            \\n            suffix1[i] += vec[i].second;\\n            suffix2[i] += (vec[i].second*vec[i].first);\\n             \\n        }\\n        \\n        \\n        ll ans = LONG_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            ll curr_cost = 0LL;\\n            if(i>0){\\n                curr_cost += (vec[i].first*prefix1[i-1]) - prefix2[i-1];\\n            }\\n            if(i<n-1){\\n                curr_cost += suffix2[i+1] - (vec[i].first*suffix1[i+1]);\\n            }\\n            ans = min(ans,curr_cost);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n**IF YOU LIKE IT PLEASE DON\\'T FORGET TO UPVOTE :)**\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665043,
                "title": "5-solutions-prefix-sum-dp-binary-search-median-maths",
                "content": "# DO upvote\\uD83D\\uDD3C if it adds value!\\n\\n# \\uD83D\\uDCA1Prefix Sum\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Here we have a pictorial representation of nums and cost when sorted according to nums in ascending order . Red region represents cost of elements of nums smaller than nums[k] to make it nums[k] . Similarly blue region represents cost to make elements of nums greater than nums[k] to make it nums[k].\\n\\n\\n![Leetcode solution img.jpg](https://assets.leetcode.com/users/images/9813df1b-92d9-4d2e-b647-e693731e8dbe_1687339389.5378778.jpeg)\\n\\n![image.png](https://assets.leetcode.com/users/images/0a1f752e-415a-49a0-887b-a1a21b167370_1687341956.922477.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        //sorting nums and cost based on nums\\n        int n=nums.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0 ; i<n ; i++){\\n            v.push_back({nums[i],cost[i]});\\n        }    \\n        sort(v.begin(),v.end());\\n        for(int i=0 ; i<n ; i++){\\n            cost[i]=v[i].second;\\n            nums[i]=v[i].first;\\n        }\\n\\n        //prefix_cost[i] = \\u2211cost[j]    j=0 to j=i\\n        //prefix_cost_nums= \\u2211(cost[j]*nums[j])   j=0 to j=i\\n\\n        vector<ll> prefix_cost(n,0);\\n        vector<ll> prefix_cost_nums(n,0);\\n        prefix_cost[0]=(ll)cost[0];\\n        prefix_cost_nums[0]=(ll)cost[0]*(ll)nums[0];\\n        for(int i=1 ; i<n ; i++){\\n            prefix_cost[i]=prefix_cost[i-1]+(ll)cost[i];\\n            prefix_cost_nums[i]=prefix_cost_nums[i-1]+((ll)cost[i]*(ll)nums[i]);\\n        }\\n\\n        // Calulating total cost for each index k and getting minimum possible cost.\\n        ll mini=1e18;\\n        for(int k=0 ; k<n ; k++){\\n            ll red=(((ll)nums[k]*prefix_cost[k])-prefix_cost_nums[k]);\\n            ll blue=((prefix_cost_nums[n-1]-prefix_cost_nums[k])-((ll)nums[k]*(prefix_cost[n-1]-prefix_cost[k])));\\n            ll curr=red+blue;\\n            mini=min(mini,curr);\\n        }\\n        return mini;\\n    }\\n};\\n```\\n\\n# \\uD83D\\uDCA1Dynamic Programming\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    //dynamic programming \\n    \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n=nums.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0 ; i<n ; i++){\\n            v.push_back({nums[i],cost[i]});\\n        }    \\n        sort(v.begin(),v.end());\\n\\n        //left cost : making all elements in left equal to curr element\\n        vector<ll> cost_l(n,0);\\n        ll curr=0;\\n        for(int i=0 ; i<n-1 ; i++){\\n            curr+=(ll)v[i].second;\\n            cost_l[i+1]=cost_l[i]+curr*(ll)(v[i+1].first-v[i].first);\\n        }\\n\\n        //right cost : making all elements in right equal to curr element\\n        vector<ll> cost_r(n,0);\\n        curr=0;\\n        for(int i=n-1 ;i>0 ; i--){\\n            curr+=(ll)v[i].second;\\n            cost_r[i-1]=cost_r[i]+curr*(ll)(v[i].first-v[i-1].first);\\n        }\\n\\n        ll ans=cost_l[0]+cost_r[0];\\n        for(int i=1 ; i<n ; i++){\\n            ans=min(ans,cost_l[i]+cost_r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# \\uD83D\\uDCA1Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe total cost is a convex function .\\nRefer below for explainations: \\n\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/2734728/pure-math-based-explanation-of-why-cost-function-is-convex/\\n\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/2734091/dp-vs-w-median-vs-binary-search/\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long l=0,r=1e6;\\n        long long res1=0,res2=0;\\n        while(l<r){\\n            long long m=l+((r-l)/2);\\n            res1=0,res2=0;\\n            for(int i=0 ; i<nums.size() ; i++){\\n                res1+=(long long)abs(m-nums[i])*cost[i];\\n                res2+=(long long)abs(m+1-nums[i])*cost[i];\\n            }\\n            if(res2>res1){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return min(res1,res2);\\n    }\\n};\\n```\\n\\n\\n# \\uD83D\\uDCA1Calculating Median by virtually making cost same.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //If the cost for all element is the same, then the minimum cost is when all numbers converge at the median.\\n    //Since the cost is not the same, we need to find a weighted median.\\n\\n    //To find a weighted median, we sort elements, \"repeating\" each element based on its weight.\\n\\n    //For [1,3,5,2], [2,3,1,4] case, the repeated array looks like this: [1,1,2,2,2,2,3,3,3,5].\\n\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long total=0;\\n        vector<pair<long long , long long>> v;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            total+=(long long)cost[i];\\n            v.push_back({(long long)nums[i],(long long)cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        // i is index at which our virtual median exists.\\n        int i=0;\\n        for(long long curr=0 ; curr+v[i].second<(total+1)/2 ; i++){\\n            curr+=v[i].second;\\n        }\\n\\n        long long ans=0;\\n        for(int k=0;k<v.size() ; k++){\\n            ans+=abs(v[i].first-v[k].first)*v[k].second;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# \\uD83D\\uDCA1Mathematical Solution (Observe Pattern)\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long totalcost=0;\\n        long long sum=0;\\n        long long mini=1e18;\\n        vector<pair<long long , long long>> v;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            totalcost+=((long long)nums[i]*(long long)cost[i]);\\n            sum+=(long long)cost[i];\\n            v.push_back({(long long)nums[i],(long long)cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long ts=totalcost;\\n\\n        // Here C represents cost and x1,x2,.... are values of nums(sorted). \\n\\n        //   for i=k : C1(xk-x1)+C2(xk-x2)+...+Ck(xk-xk)+Ck+1(xk+1-xk)+....Cn(xn-xk)\\n        //   or it could be written as\\n        //   total cost = (-C1x1-C2x2....+Ckxk+....Cnxn)-xk(-C1-C2...+Ck+ ...+Cn)\\n        //   Observe pattern for consecutive i\\'s.\\n        //   i=0 total cost=  (+C1x1+C2x2.....Cnxn)-x1(+C1+C2....+Cn)\\n        //   i=1 total cost=  (-C1x1+C2x2.....Cnxn)-x2(-C1+C2....+Cn)\\n        //   i=2 total cost=  (-C1x1-C2x2+C3x3.....Cnxn)-x3(-C1-C2+C3....+Cn)\\n        for(int i=0 ; i<v.size() ; i++){\\n            int num=v[i].first;\\n            totalcost=ts-num*(sum);\\n            if(totalcost<mini){\\n                mini=totalcost;\\n            }\\n            sum-=2*v[i].second;\\n            ts-=2*num*v[i].second;\\n        }\\n        return mini;\\n    }\\n};\\n```\\n## If you have come till here do consider UPVOTING\\uD83D\\uDD3C. \\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        //sorting nums and cost based on nums\\n        int n=nums.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0 ; i<n ; i++){\\n            v.push_back({nums[i],cost[i]});\\n        }    \\n        sort(v.begin(),v.end());\\n        for(int i=0 ; i<n ; i++){\\n            cost[i]=v[i].second;\\n            nums[i]=v[i].first;\\n        }\\n\\n        //prefix_cost[i] = \\u2211cost[j]    j=0 to j=i\\n        //prefix_cost_nums= \\u2211(cost[j]*nums[j])   j=0 to j=i\\n\\n        vector<ll> prefix_cost(n,0);\\n        vector<ll> prefix_cost_nums(n,0);\\n        prefix_cost[0]=(ll)cost[0];\\n        prefix_cost_nums[0]=(ll)cost[0]*(ll)nums[0];\\n        for(int i=1 ; i<n ; i++){\\n            prefix_cost[i]=prefix_cost[i-1]+(ll)cost[i];\\n            prefix_cost_nums[i]=prefix_cost_nums[i-1]+((ll)cost[i]*(ll)nums[i]);\\n        }\\n\\n        // Calulating total cost for each index k and getting minimum possible cost.\\n        ll mini=1e18;\\n        for(int k=0 ; k<n ; k++){\\n            ll red=(((ll)nums[k]*prefix_cost[k])-prefix_cost_nums[k]);\\n            ll blue=((prefix_cost_nums[n-1]-prefix_cost_nums[k])-((ll)nums[k]*(prefix_cost[n-1]-prefix_cost[k])));\\n            ll curr=red+blue;\\n            mini=min(mini,curr);\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    //dynamic programming \\n    \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n=nums.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0 ; i<n ; i++){\\n            v.push_back({nums[i],cost[i]});\\n        }    \\n        sort(v.begin(),v.end());\\n\\n        //left cost : making all elements in left equal to curr element\\n        vector<ll> cost_l(n,0);\\n        ll curr=0;\\n        for(int i=0 ; i<n-1 ; i++){\\n            curr+=(ll)v[i].second;\\n            cost_l[i+1]=cost_l[i]+curr*(ll)(v[i+1].first-v[i].first);\\n        }\\n\\n        //right cost : making all elements in right equal to curr element\\n        vector<ll> cost_r(n,0);\\n        curr=0;\\n        for(int i=n-1 ;i>0 ; i--){\\n            curr+=(ll)v[i].second;\\n            cost_r[i-1]=cost_r[i]+curr*(ll)(v[i].first-v[i-1].first);\\n        }\\n\\n        ll ans=cost_l[0]+cost_r[0];\\n        for(int i=1 ; i<n ; i++){\\n            ans=min(ans,cost_l[i]+cost_r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long l=0,r=1e6;\\n        long long res1=0,res2=0;\\n        while(l<r){\\n            long long m=l+((r-l)/2);\\n            res1=0,res2=0;\\n            for(int i=0 ; i<nums.size() ; i++){\\n                res1+=(long long)abs(m-nums[i])*cost[i];\\n                res2+=(long long)abs(m+1-nums[i])*cost[i];\\n            }\\n            if(res2>res1){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return min(res1,res2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //If the cost for all element is the same, then the minimum cost is when all numbers converge at the median.\\n    //Since the cost is not the same, we need to find a weighted median.\\n\\n    //To find a weighted median, we sort elements, \"repeating\" each element based on its weight.\\n\\n    //For [1,3,5,2], [2,3,1,4] case, the repeated array looks like this: [1,1,2,2,2,2,3,3,3,5].\\n\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long total=0;\\n        vector<pair<long long , long long>> v;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            total+=(long long)cost[i];\\n            v.push_back({(long long)nums[i],(long long)cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        // i is index at which our virtual median exists.\\n        int i=0;\\n        for(long long curr=0 ; curr+v[i].second<(total+1)/2 ; i++){\\n            curr+=v[i].second;\\n        }\\n\\n        long long ans=0;\\n        for(int k=0;k<v.size() ; k++){\\n            ans+=abs(v[i].first-v[k].first)*v[k].second;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long totalcost=0;\\n        long long sum=0;\\n        long long mini=1e18;\\n        vector<pair<long long , long long>> v;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            totalcost+=((long long)nums[i]*(long long)cost[i]);\\n            sum+=(long long)cost[i];\\n            v.push_back({(long long)nums[i],(long long)cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long ts=totalcost;\\n\\n        // Here C represents cost and x1,x2,.... are values of nums(sorted). \\n\\n        //   for i=k : C1(xk-x1)+C2(xk-x2)+...+Ck(xk-xk)+Ck+1(xk+1-xk)+....Cn(xn-xk)\\n        //   or it could be written as\\n        //   total cost = (-C1x1-C2x2....+Ckxk+....Cnxn)-xk(-C1-C2...+Ck+ ...+Cn)\\n        //   Observe pattern for consecutive i\\'s.\\n        //   i=0 total cost=  (+C1x1+C2x2.....Cnxn)-x1(+C1+C2....+Cn)\\n        //   i=1 total cost=  (-C1x1+C2x2.....Cnxn)-x2(-C1+C2....+Cn)\\n        //   i=2 total cost=  (-C1x1-C2x2+C3x3.....Cnxn)-x3(-C1-C2+C3....+Cn)\\n        for(int i=0 ; i<v.size() ; i++){\\n            int num=v[i].first;\\n            totalcost=ts-num*(sum);\\n            if(totalcost<mini){\\n                mini=totalcost;\\n            }\\n            sum-=2*v[i].second;\\n            ts-=2*num*v[i].second;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664473,
                "title": "c-prefix-sums",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Here is a description of the approach used in the code:\\n\\n1. Create a vector of pairs (`p`) to store the pairs of values from `nums` and `cost` arrays.\\n\\n2. Sort the pairs based on the `nums` values. This sorting ensures that we process the pairs in increasing order of `nums` values.\\n\\n3. Create a prefix sum array (`pref`) to store the cumulative sum of costs. This array helps us calculate the cost of changing a range of elements efficiently.\\n\\n4. Initialize `left` and `right` costs to 0. These variables will keep track of the costs on the left and right sides of the split.\\n\\n5. Iterate through the `nums` array. For each element, calculate the elevation (the difference between the current and previous `nums` values) and update the `left` and `right` costs accordingly.\\n\\n6. Update the `right` cost by subtracting the cost associated with the elevation and the remaining prefix sum on the right side.\\n\\n7. Update the `left` cost by adding the cost associated with the elevation and the prefix sum on the left side.\\n\\n8. Check if the current cost (`left + right`) is smaller than the current minimum cost (`ans`). If so, update `ans` with the new minimum cost.\\n\\n9. Finally, return the minimum cost (`ans`) as the result.\\n\\nThe approach optimizes the calculation of costs by using prefix sums and considers different splits in the `nums` array to find the minimum cost. By processing the pairs in increasing order of `nums` values, it ensures that we consider the optimal elements to change.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->**Prefix Sum**\\n\\n# Complexity\\n- Time complexity:  O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) \\n    {\\n        long long ans = LLONG_MAX; // Initialize ans with maximum possible value\\n        vector<long long> pref; // Prefix sum array\\n        vector<pair<long, long>> p; // Array of pairs (nums[i], cost[i])\\n        \\n        // Create pairs and store them in array p\\n        for(int i = 0; i < cost.size(); i++)\\n         {\\n            p.push_back({nums[i], cost[i]});\\n        }\\n        \\n        sort(p.begin(), p.end()); // Sort the pairs based on nums values\\n        \\n        pref.push_back(0); // Add initial 0 to prefix sum array\\n        // Calculate prefix sum of costs\\n        for(int i = 0; i < p.size(); i++)\\n         {\\n            pref.push_back(pref[i] + p[i].second);\\n        }\\n        long long left = 0, right = 0; // Initialize left and right costs\\n        for(int i = 0; i < nums.size(); i++)\\n         {\\n            if(i == 0)\\n             {\\n                left = 0;\\n                // Calculate the right cost from the second pair to the last pair\\n                for(int j = 1; j < cost.size(); j++)\\n                 {\\n                    right += (long long)(p[j].first - p[0].first) * (long long)p[j].second;\\n                }\\n                // Update ans if the current cost is smaller\\n                if(ans > right + left)\\n                 {\\n                    ans = left + right;\\n                }\\n                continue;\\n            }\\n            long long elevation = p[i].first - p[i - 1].first; // Calculate the elevation\\n            \\n            // Update right cost by subtracting the elevation cost and the remaining prefix sum\\n            right -= elevation * (long long)(p[i].second);\\n            right -= elevation * (pref[pref.size() - 1] - pref[i + 1]);\\n            // Update left cost by adding the elevation cost and the prefix sum\\n            left += elevation * (pref[i] - pref[0]);\\n            // Update ans if the current cost is smaller\\n            if(ans > right + left)\\n             {\\n                ans = left + right;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/02387d14-0c9b-408b-997f-3733158cb7b7_1687330010.5696952.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) \\n    {\\n        long long ans = LLONG_MAX; // Initialize ans with maximum possible value\\n        vector<long long> pref; // Prefix sum array\\n        vector<pair<long, long>> p; // Array of pairs (nums[i], cost[i])\\n        \\n        // Create pairs and store them in array p\\n        for(int i = 0; i < cost.size(); i++)\\n         {\\n            p.push_back({nums[i], cost[i]});\\n        }\\n        \\n        sort(p.begin(), p.end()); // Sort the pairs based on nums values\\n        \\n        pref.push_back(0); // Add initial 0 to prefix sum array\\n        // Calculate prefix sum of costs\\n        for(int i = 0; i < p.size(); i++)\\n         {\\n            pref.push_back(pref[i] + p[i].second);\\n        }\\n        long long left = 0, right = 0; // Initialize left and right costs\\n        for(int i = 0; i < nums.size(); i++)\\n         {\\n            if(i == 0)\\n             {\\n                left = 0;\\n                // Calculate the right cost from the second pair to the last pair\\n                for(int j = 1; j < cost.size(); j++)\\n                 {\\n                    right += (long long)(p[j].first - p[0].first) * (long long)p[j].second;\\n                }\\n                // Update ans if the current cost is smaller\\n                if(ans > right + left)\\n                 {\\n                    ans = left + right;\\n                }\\n                continue;\\n            }\\n            long long elevation = p[i].first - p[i - 1].first; // Calculate the elevation\\n            \\n            // Update right cost by subtracting the elevation cost and the remaining prefix sum\\n            right -= elevation * (long long)(p[i].second);\\n            right -= elevation * (pref[pref.size() - 1] - pref[i + 1]);\\n            // Update left cost by adding the elevation cost and the prefix sum\\n            left += elevation * (pref[i] - pref[0]);\\n            // Update ans if the current cost is smaller\\n            if(ans > right + left)\\n             {\\n                ans = left + right;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664261,
                "title": "python-o-n-log-n-time-o-n-space-two-pointers-beats-97-5-for-time",
                "content": "# Intuition\\nWe are accumulating costs of bringing low numbers up and high numbers down to some unknown target. If the numbers were sorted, we could keep a running tally from the beginning on one side and the end on the other, until we meet in the middle. Sorting is not ruled out by the problem, so we should be able to do that.\\n\\n\\nConceptually it works a little similarly to the prefix sum in the editorial, but instead of iterating over the array each time, it keeps a running tally building the total cost per side at each transition to the next element. We grow whichever side is cheapest, so we end up meeting in the middle at the minimum total cost\\n\\nHow do we meet in the middle at the right spot? Consider a very simple example: `nums:[10,20], cost:[1,4]` When there are only 2 options, you pick the one with lower cost. How does that change with slightly more complexity: `nums:[10,15, 20], cost:[1,2,4]`? If we pick the lowest, we pay 5 to get to `nums:[15,15,20]`. What\\'s lowest now? going from 15 to 20, or reverse? Well, the cost to move 2 numbers is the sum of thier costs. We compare 3 to 4, it\\'s still cheaper to move the low number, so we do that. If we accumulate both cost and rate increases from each side going by whichver is cheapest, in the end, you are left with a problem equivlant to my first example. 2 numbers, with 2 prices, pick the lower cost.\\n\\n# Approach\\nStarting from a basic skeleton of things that are needed: we need a sorted array, maintaing the relationship between nums and costs, and eventually we need to return a cost. We know we are going to keep track of at least 2 things with our 2 pointers approach, the left and right pointerst themselves, and a running tally of cost to give as the answer at the end. The sorted array here is responsible for both the Time and Space constraints.\\n\\n```\\n+class Solution:\\n+    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n+        size = len(nums)\\n+        nums_costs = sorted([(nums[i], cost[i]) for i in range(size)], key=itemgetter(0))\\n+        #nums_costs.item = (num, cost) sorted by num low to high\\n+        \\n+        left_index = 0\\n+        left_cost_accrued = 0\\n+        right_index = size - 1\\n+        right_cost_accrued = 0\\n+\\n+        # TODO: Gather left and right costs\\n+\\n+        total_cost = left_cost_accrued + right_cost_accrued\\n+        return total_cost\\n```\\n\\nBecause the span from min num to max num is fixed, minimizing total cost can be done by taking the minimum cost option. At each step of the loop we will consider the cost of shifting the low numbers up to the next element, or the high numbers down to the next element. For our purposes, at each current loop we should consider that everything to the left of left pointer has had the cost paid to bring it up to the current value, and everything to the right of the right pointer are similar. The already sunk costs don\\'t factor in to the question of whether shifting the low or high elements by 1 is cheaper. Similarly, the amount the shift is by is not a factor. Whatever that amount is, we want it at the cheaper rate. That said, the cost rate we are evaluating is not as simple as looking up the current element. We do need this element\\'s cost, but we also need the cost of all previous elements on this side. Instead of calculating a sum each time, or doing fanciness with prefix sum, we can just keep a tally by adding an elements cost rate to the side\\'s total when we reach it.\\n\\n```\\n=        left_index = 0\\n=        left_cost_accrued = 0\\n+        left_per_unit_cost = nums_costs[left_index][1]\\n=        right_index = size - 1\\n=        right_cost_accrued = 0\\n+        right_per_unit_cost = nums_costs[right_index][1]\\n=\\n-        # TODO: Gather left and right costs\\n+        while right_index - left_index > 0:            \\n+            if left_per_unit_cost < right_per_unit_cost:\\n+                # TODO left_cost_accrued += something\\n+                left_per_unit_cost += nums_costs[left_index + 1][1]\\n+                left_index += 1\\n+            else:\\n+                # TODO right_cost_accrued += something\\n+                right_per_unit_cost += nums_costs[right_index - 1][1]\\n+                right_index -= 1\\n=        \\n=        total_cost = left_cost_accrued + right_cost_accrued\\n=        return total_cost\\n```\\n\\nThe hard work is already done, we just need to keep the running total of the cost when we shift to the next element. Conceptually, that will be amount times rate. The amount is difference between the elements we are shifting between, and the rate is the sum of the costs of the side we are shifting. Luckily, that rate is the same rate we have been comparing, so we have it on hand. We don\\'t have the difference, but that\\'s easy to grab quickly.  \\n\\n```\\n=        while right_index - left_index > 0:\\n=            if left_per_unit_cost < right_per_unit_cost:\\n-                # TODO left_cost_accrued += something\\n+                low_value = nums_costs[left_index][0]\\n+                next_lowest_value = nums_costs[left_index + 1][0]\\n+                left_cost_accrued += (next_lowest_value - low_value) * left_per_unit_cost\\n=                left_per_unit_cost += nums_costs[left_index + 1][1]\\n=                left_index += 1\\n=            else:\\n+                # TODO right_cost_accrued += something\\n+                high_value = nums_costs[right_index][0]\\n+                next_highest_value = nums_costs[right_index - 1][0]\\n+                right_cost_accrued += (high_value - next_highest_value) * right_per_unit_cost\\n=                right_per_unit_cost += nums_costs[right_index - 1][1]\\n=                right_index -= 1\\n=        \\n```\\n\\nAnd that\\'s job done!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\nSorting takes O(n log n). Creating the array is O(n). The while loop is O(n), so sorting is the longest.\\n\\n- Space complexity:\\nO(n)\\n\\nThe sorted array is O(n), all others are constant space.\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        size = len(nums)\\n        nums_costs = sorted([(nums[i], cost[i]) for i in range(size)], key=itemgetter(0))\\n        #nums_costs.item = (num, cost) sorted by num low to high\\n        \\n        left_index = 0\\n        left_cost_accrued = 0\\n        left_per_unit_cost = nums_costs[left_index][1]\\n        right_index = size - 1\\n        right_cost_accrued = 0\\n        right_per_unit_cost = nums_costs[right_index][1]\\n\\n        while right_index - left_index > 0:\\n            if left_per_unit_cost < right_per_unit_cost:\\n                low_value = nums_costs[left_index][0]\\n                next_lowest_value = nums_costs[left_index + 1][0]\\n                left_cost_accrued += (next_lowest_value - low_value) * left_per_unit_cost\\n                left_per_unit_cost += nums_costs[left_index + 1][1]\\n                left_index += 1\\n            else:\\n                high_value = nums_costs[right_index][0]\\n                next_highest_value = nums_costs[right_index - 1][0]\\n                right_cost_accrued += (high_value - next_highest_value) * right_per_unit_cost\\n                right_per_unit_cost += nums_costs[right_index - 1][1]\\n                right_index -= 1\\n        \\n        total_cost = left_cost_accrued + right_cost_accrued\\n        return total_cost\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n+class Solution:\\n+    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n+        size = len(nums)\\n+        nums_costs = sorted([(nums[i], cost[i]) for i in range(size)], key=itemgetter(0))\\n+        #nums_costs.item = (num, cost) sorted by num low to high\\n+        \\n+        left_index = 0\\n+        left_cost_accrued = 0\\n+        right_index = size - 1\\n+        right_cost_accrued = 0\\n+\\n+        # TODO: Gather left and right costs\\n+\\n+        total_cost = left_cost_accrued + right_cost_accrued\\n+        return total_cost\\n```\n```\\n=        left_index = 0\\n=        left_cost_accrued = 0\\n+        left_per_unit_cost = nums_costs[left_index][1]\\n=        right_index = size - 1\\n=        right_cost_accrued = 0\\n+        right_per_unit_cost = nums_costs[right_index][1]\\n=\\n-        # TODO: Gather left and right costs\\n+        while right_index - left_index > 0:            \\n+            if left_per_unit_cost < right_per_unit_cost:\\n+                # TODO left_cost_accrued += something\\n+                left_per_unit_cost += nums_costs[left_index + 1][1]\\n+                left_index += 1\\n+            else:\\n+                # TODO right_cost_accrued += something\\n+                right_per_unit_cost += nums_costs[right_index - 1][1]\\n+                right_index -= 1\\n=        \\n=        total_cost = left_cost_accrued + right_cost_accrued\\n=        return total_cost\\n```\n```\\n=        while right_index - left_index > 0:\\n=            if left_per_unit_cost < right_per_unit_cost:\\n-                # TODO left_cost_accrued += something\\n+                low_value = nums_costs[left_index][0]\\n+                next_lowest_value = nums_costs[left_index + 1][0]\\n+                left_cost_accrued += (next_lowest_value - low_value) * left_per_unit_cost\\n=                left_per_unit_cost += nums_costs[left_index + 1][1]\\n=                left_index += 1\\n=            else:\\n+                # TODO right_cost_accrued += something\\n+                high_value = nums_costs[right_index][0]\\n+                next_highest_value = nums_costs[right_index - 1][0]\\n+                right_cost_accrued += (high_value - next_highest_value) * right_per_unit_cost\\n=                right_per_unit_cost += nums_costs[right_index - 1][1]\\n=                right_index -= 1\\n=        \\n```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        size = len(nums)\\n        nums_costs = sorted([(nums[i], cost[i]) for i in range(size)], key=itemgetter(0))\\n        #nums_costs.item = (num, cost) sorted by num low to high\\n        \\n        left_index = 0\\n        left_cost_accrued = 0\\n        left_per_unit_cost = nums_costs[left_index][1]\\n        right_index = size - 1\\n        right_cost_accrued = 0\\n        right_per_unit_cost = nums_costs[right_index][1]\\n\\n        while right_index - left_index > 0:\\n            if left_per_unit_cost < right_per_unit_cost:\\n                low_value = nums_costs[left_index][0]\\n                next_lowest_value = nums_costs[left_index + 1][0]\\n                left_cost_accrued += (next_lowest_value - low_value) * left_per_unit_cost\\n                left_per_unit_cost += nums_costs[left_index + 1][1]\\n                left_index += 1\\n            else:\\n                high_value = nums_costs[right_index][0]\\n                next_highest_value = nums_costs[right_index - 1][0]\\n                right_cost_accrued += (high_value - next_highest_value) * right_per_unit_cost\\n                right_per_unit_cost += nums_costs[right_index - 1][1]\\n                right_index -= 1\\n        \\n        total_cost = left_cost_accrued + right_cost_accrued\\n        return total_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735301,
                "title": "python-rust-c-weighted-median-concise-proof-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs calculation of a weighted median. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**. \\n****\\n**Comment.** The proof of the *weighted median* strategy is as follows. \\n* First, let us consider all costs to be equal **1** and imagine \\'nums\\' as points (with integer coordinates) on a line. Then our task is to find another point on this line with the following property: the sum of all distances to this point is minimal. We know (see, this [**problem**](https://leetcode.com/problems/best-meeting-point/) and my [**solution**](https://leetcode.com/problems/best-meeting-point/discuss/2733517/PythonRustC%2B%2B-fast-and-concise-using-median-%2B-PROOF-(with-detailed-comments))) that this point would be the median of sorted \\'nums\\'. Why\\'s that? Well, it has the following property: any shift from the median may only increase the total distance, because an equal number of points lies on each side of this point. If we move this point, e.g., one step to the left then any decrease of total distance for the points on the left will be compensated by at least the same amount due to the points on the right.\\n*  Now, consider weights being arbitrary positive integers. Making an operation (decrease or increase) on a number **N** with cost **C** is the same (in terms of cost) as doing the same operation, however, replicated for **C** numbers of value **N** with cost **1**.\\n*  The median of such replicated (and sorted) list is what we call a weighted median of the original list.\\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/828487569/) | **921 ms (100.00%)** | **38.4 MB  (84.62%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/828494941/) | **25 ms (100.00%)** | **3.8 MB (100.00%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/828499259/) | **172 ms (100.00%)** | **85.1 MB  (23.08%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/fMzK7MnX/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs calculation of a weighted median. Time complexity is log-linear: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**. \\n****\\n**Comment.** The proof of the *weighted median* strategy is as follows. \\n* First, let us consider all costs to be equal **1** and imagine \\'nums\\' as points (with integer coordinates) on a line. Then our task is to find another point on this line with the following property: the sum of all distances to this point is minimal. We know (see, this [**problem**](https://leetcode.com/problems/best-meeting-point/) and my [**solution**](https://leetcode.com/problems/best-meeting-point/discuss/2733517/PythonRustC%2B%2B-fast-and-concise-using-median-%2B-PROOF-(with-detailed-comments))) that this point would be the median of sorted \\'nums\\'. Why\\'s that? Well, it has the following property: any shift from the median may only increase the total distance, because an equal number of points lies on each side of this point. If we move this point, e.g., one step to the left then any decrease of total distance for the points on the left will be compensated by at least the same amount due to the points on the right.\\n*  Now, consider weights being arbitrary positive integers. Making an operation (decrease or increase) on a number **N** with cost **C** is the same (in terms of cost) as doing the same operation, however, replicated for **C** numbers of value **N** with cost **1**.\\n*  The median of such replicated (and sorted) list is what we call a weighted median of the original list.\\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/828487569/) | **921 ms (100.00%)** | **38.4 MB  (84.62%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/828494941/) | **25 ms (100.00%)** | **3.8 MB (100.00%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/828499259/) | **172 ms (100.00%)** | **85.1 MB  (23.08%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/fMzK7MnX/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2734246,
                "title": "two-pointers-java",
                "content": "```java\\npublic long minCost(int[] nums, int[] cost) {\\n    long ans = 0;\\n    Map<Integer,Integer> map = new HashMap<>();\\n    int min = Integer.MAX_VALUE, max = 0;\\n    for(int i=0; i<nums.length; i++){\\n        map.put(nums[i], cost[i]+map.getOrDefault(nums[i], 0));\\n        min = Math.min(min,nums[i]);\\n        max = Math.max(max,nums[i]);\\n    }\\n    long cmin = map.get(min);\\n    long cmax = map.get(max);\\n    while(min<max){\\n        if(cmin<=cmax){\\n            ans += cmin;\\n            min++;\\n            cmin += map.getOrDefault(min,0);\\n        }else{\\n            ans += cmax;\\n            max--;\\n            cmax += map.getOrDefault(max,0);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\npublic long minCost(int[] nums, int[] cost) {\\n    long ans = 0;\\n    Map<Integer,Integer> map = new HashMap<>();\\n    int min = Integer.MAX_VALUE, max = 0;\\n    for(int i=0; i<nums.length; i++){\\n        map.put(nums[i], cost[i]+map.getOrDefault(nums[i], 0));\\n        min = Math.min(min,nums[i]);\\n        max = Math.max(max,nums[i]);\\n    }\\n    long cmin = map.get(min);\\n    long cmax = map.get(max);\\n    while(min<max){\\n        if(cmin<=cmax){\\n            ans += cmin;\\n            min++;\\n            cmin += map.getOrDefault(min,0);\\n        }else{\\n            ans += cmax;\\n            max--;\\n            cmax += map.getOrDefault(max,0);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734089,
                "title": "python-c-binary-search-clean-solution",
                "content": "Do binary search starting from `min` and `max` values of `nums` to find an optimal target number.\\n\\nTime complexity - `O(n * log(maxVal - minVal))`\\n\\nThe problem is quite similar to [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def calculateSum(self, nums, cost, target):\\n        res = 0\\n        for n, c in zip(nums, cost):\\n            res += abs(n - target) * c\\n        return res\\n    \\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        s, e = min(nums), max(nums)\\n        \\n        while s < e:\\n            mid = (s + e) // 2\\n            leftSum, rightSum = self.calculateSum(nums, cost, mid), self.calculateSum(nums, cost, mid + 1)\\n            if leftSum < rightSum:\\n                e = mid\\n            else:\\n                s = mid + 1\\n        \\n        return self.calculateSum(nums, cost, s)\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    long long calculateSum(vector<int>& nums, vector<int>& cost, long long target) {\\n        long long res = 0;\\n        for (int i = 0; i < (int) nums.size(); ++i) {\\n            res += abs(nums[i] - target) * cost[i];\\n        }\\n        return res;\\n    }\\n\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long s = *min_element(nums.begin(), nums.end());\\n        long long e = *max_element(nums.begin(), nums.end());\\n        while (s < e) {\\n            long long mid = (s + e) / 2;\\n            long long leftSum = calculateSum(nums, cost, mid);\\n            long long rightSum = calculateSum(nums, cost, mid + 1);\\n            if (leftSum < rightSum) {\\n                e = mid;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return calculateSum(nums, cost, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def calculateSum(self, nums, cost, target):\\n        res = 0\\n        for n, c in zip(nums, cost):\\n            res += abs(n - target) * c\\n        return res\\n    \\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        s, e = min(nums), max(nums)\\n        \\n        while s < e:\\n            mid = (s + e) // 2\\n            leftSum, rightSum = self.calculateSum(nums, cost, mid), self.calculateSum(nums, cost, mid + 1)\\n            if leftSum < rightSum:\\n                e = mid\\n            else:\\n                s = mid + 1\\n        \\n        return self.calculateSum(nums, cost, s)\\n```\n```\\nclass Solution {\\npublic:\\n    long long calculateSum(vector<int>& nums, vector<int>& cost, long long target) {\\n        long long res = 0;\\n        for (int i = 0; i < (int) nums.size(); ++i) {\\n            res += abs(nums[i] - target) * cost[i];\\n        }\\n        return res;\\n    }\\n\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long s = *min_element(nums.begin(), nums.end());\\n        long long e = *max_element(nums.begin(), nums.end());\\n        while (s < e) {\\n            long long mid = (s + e) / 2;\\n            long long leftSum = calculateSum(nums, cost, mid);\\n            long long rightSum = calculateSum(nums, cost, mid + 1);\\n            if (leftSum < rightSum) {\\n                e = mid;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return calculateSum(nums, cost, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734581,
                "title": "easy-iterative-way-prefix-and-sufix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n--> sort on the basis of nums\\n \\n--> Now make a prefix and sufix vector...where prefix will Store the total cost to make the 0 to ith index element equal to nums[i]\\nans sufix will Store the total cost to make the n-1 to ith index element equal to nums[i]\\n\\n--> Atlast for every i find the minimum of prefix + sufix\\nbecause prefix  + sufix will tell you the total cost to make all the elements equal to nums[i]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow take an example: nums = [1,3,5,2], cost = [2,3,1,14]\\n\\n--> first sort nums = [1,2,3,5] cost = [2,14,3,1]\\n\\nprefix[0] will always be 0 because we can\\'t make any other elements equal to nums[0] because there is no other element present before 0th index\\n\\ntotcost = cost[0];\\n\\nmake 0 to 1 elements equal to nums[1]\\nprefix[1] = (2-1)*2 = 2;\\noriginal nums = [2,2,3,5]\\n\\nnow can we write in this way nums = [2,3,5] cost = [16,3,1]\\n \\nNow make 2 and 3 equal\\nprefix[2] = (3-2)*16 = 16;\\noriginal nums = [3,3,3,5]\\n\\nnow can we write in this way nums = [3,5] cost = [19,1]\\n\\nNow make 3 ans 5 equal\\nprefix[3] = (3-5)*19 = 38\\noriginal nums = [5,5,5,5]\\n\\nso atlast our prefix vector is:\\nprefix = [0,2,16,38]\\nwhere prefix will Store the total cost to make the 0 to ith index element equal to nums[i]\\n\\nsimilarly do this for sufix and atlast find the minimum of their sum for every 0 to nth index\\n\\n\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        vector<pair<int,int>> v;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        \\n        sort(begin(v),end(v));\\n        // to store the total cost to make all the elements before ith index...equal to nums[i] (Store the total cost to make the 0 to ith index element equal to nums[i])\\n        long long prefix[n]; \\n        prefix[0] = 0;\\n        long long totCost = v[0].second;\\n \\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i] = prefix[i-1] + abs(v[i].first - v[i-1].first)*totCost;\\n            totCost += v[i].second;\\n        }\\n        \\n        // to store the total cost to make all the element after ith index....equal to nums[i] (Store the total cost to make the n-1 to ith index element equal to nums[i])\\n        long long sufix[n];\\n        totCost = v[n-1].second;\\n        sufix[n-1] = 0;\\n        for(int i= n-2;i>=0;i--)\\n        {\\n            sufix[i] = sufix[i+1] + abs(v[i].first - v[i+1].first)*totCost;\\n            totCost += v[i].second;\\n        }\\n        \\n        long long ans = LLONG_MAX;\\n        // atlast...NOW (sufix + prefix) will give you the total cost to make all the elements equal to nums[i]\\n        // so take the minimum of all\\n        for(int i=0;i<n;i++)\\n        {\\n            ans = min(ans, prefix[i]+sufix[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        vector<pair<int,int>> v;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        \\n        sort(begin(v),end(v));\\n        // to store the total cost to make all the elements before ith index...equal to nums[i] (Store the total cost to make the 0 to ith index element equal to nums[i])\\n        long long prefix[n]; \\n        prefix[0] = 0;\\n        long long totCost = v[0].second;\\n \\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i] = prefix[i-1] + abs(v[i].first - v[i-1].first)*totCost;\\n            totCost += v[i].second;\\n        }\\n        \\n        // to store the total cost to make all the element after ith index....equal to nums[i] (Store the total cost to make the n-1 to ith index element equal to nums[i])\\n        long long sufix[n];\\n        totCost = v[n-1].second;\\n        sufix[n-1] = 0;\\n        for(int i= n-2;i>=0;i--)\\n        {\\n            sufix[i] = sufix[i+1] + abs(v[i].first - v[i+1].first)*totCost;\\n            totCost += v[i].second;\\n        }\\n        \\n        long long ans = LLONG_MAX;\\n        // atlast...NOW (sufix + prefix) will give you the total cost to make all the elements equal to nums[i]\\n        // so take the minimum of all\\n        for(int i=0;i<n;i++)\\n        {\\n            ans = min(ans, prefix[i]+sufix[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663609,
                "title": "2-easy-solution-c-fastest",
                "content": "\\n\\n# Approach : Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 1\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        vector<long long> pref;\\n        vector<pair<long, long>> p;\\n        \\n        for(int i=0; i<cost.size(); i++){\\n            p.push_back({nums[i], cost[i]});\\n        }\\n        \\n        sort(p.begin(), p.end());\\n        \\n        pref.push_back(0);\\n        for(int i=0; i<p.size(); i++){\\n            pref.push_back(pref[i]+p[i].second);\\n        }\\n        \\n        long long left=0, right=0;\\n        for(int i=0; i<nums.size(); i++){\\n           \\n            if(i==0){\\n                left=0;\\n                for(int j=1; j<cost.size(); j++){\\n                    right+=(long long)(p[j].first-p[0].first)*(long long)p[j].second;\\n                }\\n                if(ans>right+left){\\n                    ans=left+right;\\n                }\\n                continue;\\n            }\\n            long long elavation=p[i].first-p[i-1].first;\\n    \\n            right-=elavation*(long long)(p[i].second);\\n            right-=elavation*(pref[pref.size()-1]-pref[i+1]);\\n            \\n        \\n            left+=elavation*(pref[i]-pref[0]);\\n            \\n          \\n            if(ans>right+left){\\n                    ans=left+right;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n# Approach : Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    long long mod(int x){\\n        if(x>0)return x;\\n        return -x;\\n    }\\n    \\n    long long minCost(vector<int>& nums, vector<int>& costs) {\\n        auto findCost = [&](long long pivot) -> long long{\\n            long long ans=0;\\n            for(int j=0;j<nums.size();j++){\\n                long long diff = mod(nums[j]-pivot);\\n                ans+=diff*(long long)costs[j];     \\n            }\\n\\n            return ans;\\n        };\\n        \\n        vector<pair<int,int>>arr;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)arr.push_back({nums[i],costs[i]});\\n        sort(arr.begin(),arr.end());\\n        int low=0, high=n-1;\\n        \\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            if(findCost(arr[mid].first)< findCost(arr[mid].first +1))high=mid;\\n            else low=mid+1;\\n        }\\n        \\n        return findCost(arr[low].first);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        vector<long long> pref;\\n        vector<pair<long, long>> p;\\n        \\n        for(int i=0; i<cost.size(); i++){\\n            p.push_back({nums[i], cost[i]});\\n        }\\n        \\n        sort(p.begin(), p.end());\\n        \\n        pref.push_back(0);\\n        for(int i=0; i<p.size(); i++){\\n            pref.push_back(pref[i]+p[i].second);\\n        }\\n        \\n        long long left=0, right=0;\\n        for(int i=0; i<nums.size(); i++){\\n           \\n            if(i==0){\\n                left=0;\\n                for(int j=1; j<cost.size(); j++){\\n                    right+=(long long)(p[j].first-p[0].first)*(long long)p[j].second;\\n                }\\n                if(ans>right+left){\\n                    ans=left+right;\\n                }\\n                continue;\\n            }\\n            long long elavation=p[i].first-p[i-1].first;\\n    \\n            right-=elavation*(long long)(p[i].second);\\n            right-=elavation*(pref[pref.size()-1]-pref[i+1]);\\n            \\n        \\n            left+=elavation*(pref[i]-pref[0]);\\n            \\n          \\n            if(ans>right+left){\\n                    ans=left+right;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long mod(int x){\\n        if(x>0)return x;\\n        return -x;\\n    }\\n    \\n    long long minCost(vector<int>& nums, vector<int>& costs) {\\n        auto findCost = [&](long long pivot) -> long long{\\n            long long ans=0;\\n            for(int j=0;j<nums.size();j++){\\n                long long diff = mod(nums[j]-pivot);\\n                ans+=diff*(long long)costs[j];     \\n            }\\n\\n            return ans;\\n        };\\n        \\n        vector<pair<int,int>>arr;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)arr.push_back({nums[i],costs[i]});\\n        sort(arr.begin(),arr.end());\\n        int low=0, high=n-1;\\n        \\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            if(findCost(arr[mid].first)< findCost(arr[mid].first +1))high=mid;\\n            else low=mid+1;\\n        }\\n        \\n        return findCost(arr[low].first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664074,
                "title": "using-median-java-solution",
                "content": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int n=nums.length;\\n        //storing pref sum of cost after it sorted wrt to nums\\n        long pref[]=new long[n];\\n        int arr[][]=new int[n][2];\\n        for(int i=0;i<n;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=cost[i];\\n        }\\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\\n        pref[0]=arr[0][1];\\n        //finding out index of median\\n        for(int i=1;i<n;i++){\\n            pref[i]+=pref[i-1]+arr[i][1];\\n         \\n        }\\n        int p1=0;\\n        //calculating median\\n        long med=pref[n-1]/2;\\n        for(int i=0;i<n;i++){\\n            if(pref[i]>med){\\n                p1=i;\\n                break;\\n            }\\n        }\\n        long get=arr[p1][0];long sum=0;\\n        //substracting and calculating median\\n        for(int i=0;i<n;i++){\\n            sum+=1l*Math.abs(arr[i][0]-get)*arr[i][1]*1l;\\n        }\\n        return sum;\\n    }\\n}\\n/*\\n  --> 1,3,5,2   //sorting it and accordingly the cost array also\\n  --> 2,3,1,14  // total sum of cost array 20 then median will be 20/2=10\\n  --> 1,1,2,2,2,2,2,2,2,\\'2\\',2,2,2,2,2,2,3,3,3,5  //treating cost array as frequencies\\n  --> \\'2\\' is the median as it is in 10th place now substracting all the rest elements \\n        from 2 to get the min total cost\\n  */\\n time complexity->O(NlogN)\\n space complexity->O(2*N)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int n=nums.length;\\n        //storing pref sum of cost after it sorted wrt to nums\\n        long pref[]=new long[n];\\n        int arr[][]=new int[n][2];\\n        for(int i=0;i<n;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=cost[i];\\n        }\\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\\n        pref[0]=arr[0][1];\\n        //finding out index of median\\n        for(int i=1;i<n;i++){\\n            pref[i]+=pref[i-1]+arr[i][1];\\n         \\n        }\\n        int p1=0;\\n        //calculating median\\n        long med=pref[n-1]/2;\\n        for(int i=0;i<n;i++){\\n            if(pref[i]>med){\\n                p1=i;\\n                break;\\n            }\\n        }\\n        long get=arr[p1][0];long sum=0;\\n        //substracting and calculating median\\n        for(int i=0;i<n;i++){\\n            sum+=1l*Math.abs(arr[i][0]-get)*arr[i][1]*1l;\\n        }\\n        return sum;\\n    }\\n}\\n/*\\n  --> 1,3,5,2   //sorting it and accordingly the cost array also\\n  --> 2,3,1,14  // total sum of cost array 20 then median will be 20/2=10\\n  --> 1,1,2,2,2,2,2,2,2,\\'2\\',2,2,2,2,2,2,3,3,3,5  //treating cost array as frequencies\\n  --> \\'2\\' is the median as it is in 10th place now substracting all the rest elements \\n        from 2 to get the min total cost\\n  */\\n time complexity->O(NlogN)\\n space complexity->O(2*N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734452,
                "title": "impossible-for-js",
                "content": "Ran into an error during submission resulting I believe from the imprecision of a BigInt => Int/Number conversion in javascript (I know I know --- why use js lol)\\n\\nI believe the test fixture must convert return of `minCost` function to a number but that some of the test cases have expected results greater than the maximum safe number size for js --- if there is a way around this I would love to know\\n\\nEither way --- maybe we could in the future return the answer % 10^9 + 7 as is  common for problems w/ very large answers?\\n\\n(also ----- and I know it doesnt matter at alll -- but is there wany way to request my score in a contest to be changed if I believe a problem was unfair? )\\n\\nlink to my submission detailing a failing case: https://leetcode.com/submissions/detail/828379812/\\n\\nSee this more concise and better documented comment on contest FAQ: https://leetcode.com/discuss/general-discussion/2734067/Weekly-Contest-316/1655342",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Ran into an error during submission resulting I believe from the imprecision of a BigInt => Int/Number conversion in javascript (I know I know --- why use js lol)\\n\\nI believe the test fixture must convert return of `minCost` function to a number but that some of the test cases have expected results greater than the maximum safe number size for js --- if there is a way around this I would love to know\\n\\nEither way --- maybe we could in the future return the answer % 10^9 + 7 as is  common for problems w/ very large answers?\\n\\n(also ----- and I know it doesnt matter at alll -- but is there wany way to request my score in a contest to be changed if I believe a problem was unfair? )\\n\\nlink to my submission detailing a failing case: https://leetcode.com/submissions/detail/828379812/\\n\\nSee this more concise and better documented comment on contest FAQ: https://leetcode.com/discuss/general-discussion/2734067/Weekly-Contest-316/1655342",
                "codeTag": "Unknown"
            },
            {
                "id": 3664982,
                "title": "c-detailed-explanation-binary-search-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe need to make all values equal. Let us say I am making all values equal to $$x$$. I can see that $$x$$ is limited in the range $$1<=x<=1e6$$ which is the range of values $$nums[i]$$ can take.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet us say we make all elements equal to a number (say x), then the cost will be \\n\\n```\\ncost = abs(a1-x)*c1 + abs(a2-x)*c2 + ... + abs(an-x)*cn\\n```\\n\\nwhere $$ai -> nums[i-1]$$ and $$ci -> cost[i-1]$$.\\n\\nAssume the nums array is sorted for this explanation. If we observe the derivative of this function wrt x, It will be something like \\n\\n$$d (cost )/ dx = -c1 -c2 -c3 -.. -ck + c(k+1) + .. +cn$$\\n\\ndepending on the exact value of x. i.e, it is a valey shaped function, which decreases at the start and then increases \\n\\n*Note: ( In case of unsorted array, the -ve and +ve signs are not grouped together like shown, but they behave similarly )*\\n\\nSo, for each x, I can find if increasing x to x+1 will increase of decrease my cost from this derivative. This means, I have a monotonic functino which I can perform Binary Search on!\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\nPlease upvote if you found this useful\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size(),\\n            l = 1, r = 1e6,\\n            mid;\\n        long long temp;\\n\\n        while( l<=r ) {\\n            mid = l+(r-l)/2;\\n            \\n            // temp will be used to find what will be the cost difference \\n            // if I take mid+1 instead of mid as the target value.\\n            // This is like the derivative discussed in the above explanation.\\n            temp = 0;\\n\\n            for( int i=0; i<n; i++ ) {\\n                // if target is lesser than value, increasing target reduces cost \\n                // because target is on the left side of val, whiich has -1 slope\\n                if( mid < nums[i] ) temp-=cost[i]; \\n                \\n                // if target is not lesser than value, increasing target increases cost \\n                // because target is on the right side of val, whiich has +1 slope\\n                else temp+=cost[i];\\n            }\\n\\n            //    if moving target to target+1 reduces cost,\\n            // the target value for min cost lies on the \\n            // right side of current target\\n            //    else we search on the left\\n            if( temp <0 ) l = mid+1;\\n            else r = mid-1;\\n        }\\n        // imagine the target for min cost is x\\n        // if l == r == x, mid = x which makes the gradient positive\\n        // so, when the loop is exited, r=x-1 and l = x\\n\\n        // loop to calculate actual cost for the target value\\n        temp = 0;\\n        for( int i=0; i<n; i++ ) {\\n            temp += (long long)abs( nums[i]-l ) * cost[i];\\n        }\\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ncost = abs(a1-x)*c1 + abs(a2-x)*c2 + ... + abs(an-x)*cn\\n```\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size(),\\n            l = 1, r = 1e6,\\n            mid;\\n        long long temp;\\n\\n        while( l<=r ) {\\n            mid = l+(r-l)/2;\\n            \\n            // temp will be used to find what will be the cost difference \\n            // if I take mid+1 instead of mid as the target value.\\n            // This is like the derivative discussed in the above explanation.\\n            temp = 0;\\n\\n            for( int i=0; i<n; i++ ) {\\n                // if target is lesser than value, increasing target reduces cost \\n                // because target is on the left side of val, whiich has -1 slope\\n                if( mid < nums[i] ) temp-=cost[i]; \\n                \\n                // if target is not lesser than value, increasing target increases cost \\n                // because target is on the right side of val, whiich has +1 slope\\n                else temp+=cost[i];\\n            }\\n\\n            //    if moving target to target+1 reduces cost,\\n            // the target value for min cost lies on the \\n            // right side of current target\\n            //    else we search on the left\\n            if( temp <0 ) l = mid+1;\\n            else r = mid-1;\\n        }\\n        // imagine the target for min cost is x\\n        // if l == r == x, mid = x which makes the gradient positive\\n        // so, when the loop is exited, r=x-1 and l = x\\n\\n        // loop to calculate actual cost for the target value\\n        temp = 0;\\n        for( int i=0; i<n; i++ ) {\\n            temp += (long long)abs( nums[i]-l ) * cost[i];\\n        }\\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664605,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long c(long long val ,vector<pair<long long,long long>>&vp){\\n        long long sum = 0;\\n        for(int i=0;i<vp.size();i++){\\n            sum += abs(val-vp[i].first)*vp[i].second;\\n        }\\n        return sum;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<long long,long long>>vp;\\n         long long weight = 0;\\n        for(int i=0;i<nums.size();i++){\\n            vp.push_back({nums[i],cost[i]});\\n            weight += cost[i];\\n        }\\n       long long l=*min_element(nums.begin(),nums.end());\\n       long long r=*max_element(nums.begin(),nums.end());\\n       long long ans=l;\\n        while(l<r){\\n            long long mid=(l+r)/2;\\n            long long c1=c(mid,vp);\\n            long long c2=c(mid+1,vp);\\n            if(c1>c2){\\n                l = mid+1;\\n                ans = l;\\n            }   \\n            else{\\n                r = mid;\\n                ans = r;\\n            }\\n        }\\n        return c(ans,vp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/e9cf7a74-166c-4800-889a-d78fc6a9bc16_1687332008.0743086.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long c(long long val ,vector<pair<long long,long long>>&vp){\\n        long long sum = 0;\\n        for(int i=0;i<vp.size();i++){\\n            sum += abs(val-vp[i].first)*vp[i].second;\\n        }\\n        return sum;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<long long,long long>>vp;\\n         long long weight = 0;\\n        for(int i=0;i<nums.size();i++){\\n            vp.push_back({nums[i],cost[i]});\\n            weight += cost[i];\\n        }\\n       long long l=*min_element(nums.begin(),nums.end());\\n       long long r=*max_element(nums.begin(),nums.end());\\n       long long ans=l;\\n        while(l<r){\\n            long long mid=(l+r)/2;\\n            long long c1=c(mid,vp);\\n            long long c2=c(mid+1,vp);\\n            if(c1>c2){\\n                l = mid+1;\\n                ans = l;\\n            }   \\n            else{\\n                r = mid;\\n                ans = r;\\n            }\\n        }\\n        return c(ans,vp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664600,
                "title": "c-weighted-median",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<long long,long long>>vp;\\n         long long weight = 0;\\n        for(int i=0;i<nums.size();i++){\\n            vp.push_back({nums[i],cost[i]});\\n            weight += cost[i];\\n        }\\n        long long index = (weight)/2;\\n        sort(vp.begin(),vp.end());\\n        long long v1=-1,v2=-1;\\n        long long add=0;\\n        for(int i=0;i<nums.size();i++){\\n            add += vp[i].second;\\n            if(add>=index && v1==-1)v1=vp[i].first;\\n            if(add>=(index+1) && v2==-1)v2=vp[i].first;\\n        }\\n        cout<<index;\\n        long long s1=0,s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            s1 += 1LL*abs(v1-vp[i].first)*vp[i].second;\\n            s2 += 1LL*abs(v2-vp[i].first)*vp[i].second;\\n        }\\n        return min(s1,s2);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/8aa785f9-2279-4ab3-a09b-43fdfa6a0f15_1687331938.1796575.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<long long,long long>>vp;\\n         long long weight = 0;\\n        for(int i=0;i<nums.size();i++){\\n            vp.push_back({nums[i],cost[i]});\\n            weight += cost[i];\\n        }\\n        long long index = (weight)/2;\\n        sort(vp.begin(),vp.end());\\n        long long v1=-1,v2=-1;\\n        long long add=0;\\n        for(int i=0;i<nums.size();i++){\\n            add += vp[i].second;\\n            if(add>=index && v1==-1)v1=vp[i].first;\\n            if(add>=(index+1) && v2==-1)v2=vp[i].first;\\n        }\\n        cout<<index;\\n        long long s1=0,s2=0;\\n        for(int i=0;i<nums.size();i++){\\n            s1 += 1LL*abs(v1-vp[i].first)*vp[i].second;\\n            s2 += 1LL*abs(v2-vp[i].first)*vp[i].second;\\n        }\\n        return min(s1,s2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2735302,
                "title": "java-2-solutions-binary-search-sort-prefix-sum",
                "content": "# 4.Binary Search\\n```\\n    //4.Binary Search based on 1.brute force \\n    //Runtime: 54 ms, faster than 100.00% of Java online submissions for Minimum Cost to Make Array Equal.\\n    //Memory Usage: 80.5 MB, less than 100.00% of Java online submissions for Minimum Cost to Make Array Equal.\\n    //Time: O(N + N + logN * (N + N)); Space(1)\\n    //Time: O(N * logN); Space(1)\\n    public long minCost(int[] nums, int[] cost) {\\n        long minNum = Integer.MAX_VALUE, maxNum = Integer.MIN_VALUE;\\n        //Time: O(N)\\n        for(int n : nums){\\n            minNum = Math.min(minNum, n);\\n            maxNum = Math.max(maxNum, n);\\n        }\\n        \\n        //Time: O(N)\\n        long res = findCost(nums, cost, minNum);\\n\\n        //Time: O(logN * (N + N))\\n        while (minNum < maxNum) {\\n            long mid = (minNum + maxNum) / 2;\\n            long costLeft = findCost(nums, cost, mid);         //Time: O(N)\\n            long costRight = findCost(nums, cost, mid + 1); //Time: O(N)\\n            res = Math.min(costLeft, costRight);\\n            if (costLeft < costRight) maxNum = mid;\\n            else minNum = mid + 1;\\n        }\\n        return res;\\n    }\\n\\n    //Time: O(N)\\n    private long findCost(int[] nums, int[] cost, long x) {\\n        long res = 0L;\\n        for (int i = 0; i < nums.length; i++)\\n            res += Math.abs(nums[i] - x) * cost[i];\\n        return res;\\n    }\\n```\\n# 3.sort + prefix sum\\n```\\n    //3.sort + prefix sum\\n\\t //idea:\\n    //Before this, I code brute force first. But they are all TLE.... Then I tried to solve TLE.\\n    //The time complexity is O(N * N), which means I DO compute the cost for N times. It\\'s too much.\\n    //\\n    //Then I try to do the compute only once.(if so, we can save a lot of time...)\\n    //If we already have a cost, then I wonder if possible to add or minus something to get the next smaller cost?\\n    //\\n    //Let\\'s pickup one number which has the largest cost, let it be X, its cost is costOfX,  its position is positionX.\\n    //then we can easily get the whole cost, let be costX.\\n    //\\n    //now next step : shall we move to positionX + 1 or positionX - 1 ? or just stay at positionX?\\n    //we know we want to get the smaller cost.\\n    //if we move to the right neighbour (move from positionX to positionX + 1):\\n    //1.every number on the right side, their costs should be removed from costX;\\n    //2.every number on the left side, their costs should be added to costX;\\n    //3.costOfX also need to be added to costX.\\n    //   costX1 = costX - costRight + costLeft + costOfX\\n    //  if costX1 is smaller than original cost costX, then we should move to right neighbour.\\n    //   costX1 < costX\\n    //   ==> costX - costRight + costLeft + costOfX < costX\\n    //   ==> costLeft + costOfX < costRight\\n    //   now we get the equation\\n    // similarly, we can get the other equation for positionX - 1\\n    //  costX_1 = costX - costLeft + costRight + costOfX < costX\\n    //   ==> costRight + costOfX < costLeft\\n    //  now, we can use these two equations to chose : positionX + 1 or positionX - 1 ? or positionX?\\n    //  In equations we need the costRight and costLeft, the prefix sum is very useful to such scenarios. so I add prefix sum.\\n    //\\n    // In the end, we get the index of number which is the element in the final array.\\n\\t// The last step is easy, jsut compute the cost and return.\\n\\t//\\n    //\\n    //Runtime: 189 ms, faster than 50.00% of Java online submissions for Minimum Cost to Make Array Equal.\\n    //Memory Usage: 95.2 MB, less than 75.00% of Java online submissions for Minimum Cost to Make Array Equal.\\n    //Time: O(N + N * logN + N + N + N); Space: O(N + logN + N)\\n    //Time: O(4N + N * logN); Space: O(N)\\n    //Time: O(N * logN); Space: O(N)\\n    public long minCost_3(int[] nums, int[] cost) {\\n\\n        //Time: O(N); Space: O(N)\\n        int[][] data = new int[nums.length][2];\\n        for (int i = 0; i < nums.length; i++)\\n            data[i] = new int[]{nums[i],cost[i]};\\n\\n        //Time: O(N * logN); Space: O(logN)\\n        Arrays.sort(data, Comparator.comparingInt(a -> a[0]));\\n\\n        //prefix sum, max cost\\n        //Time: O(N); Space: O(N)\\n        int idx = 0, maxCost = Integer.MIN_VALUE;\\n        long[] preSum = new long[nums.length + 1];\\n        for (int i = 0; i < data.length; i++) {\\n            preSum[i + 1] = preSum[i] + data[i][1];\\n            if (data[i][1] > maxCost){\\n                idx = i;\\n                maxCost = data[i][1];\\n            }\\n        }\\n\\n        //Time: worstCase : O(N)\\n        long sum = preSum[preSum.length - 1];\\n        int lastIdx = -1;\\n        while (lastIdx != idx) {\\n            lastIdx = idx;\\n            if (preSum[idx + 1] < sum - preSum[idx + 1]) idx++;\\n            else if (preSum[idx] > sum - preSum[idx]) idx--;\\n        }\\n\\n        //Time: O(N)\\n        long res = 0l;\\n        for (int i = 0; i < nums.length; i++)\\n            res += 1l * Math.abs(nums[i] - data[idx][0]) * cost[i];\\n        return res;\\n    }\\n\\t\\n```\\n2.Brute force 2\\n```\\n\\n    //2.Brute force 2\\n    //TLE\\n    //Time: O(N * N)\\n    public long minCost_2(int[] nums, int[] cost) {\\n\\n        Set<Integer> set = new HashSet<>();\\n        long res = Long.MAX_VALUE;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (!set.add(nums[j])) continue;\\n            long sum = 0;\\n            for (int i = 0; i < nums.length; i++)\\n                sum += 1l * Math.abs(nums[i] - nums[j]) * cost[i];\\n            res = Math.min(res, sum);\\n        }\\n        return res;\\n    }\\n```\\n# 1.Brute force\\n```\\n    //1.Brute force\\n    //TLE\\n    //Time: O(N * N)\\n    public long minCost_1(int[] nums, int[] cost) {\\n        int minNum = Integer.MAX_VALUE;\\n        int maxNum = Integer.MIN_VALUE;\\n\\n        for(int n : nums){\\n            minNum = Math.min(minNum, n);\\n            maxNum = Math.max(maxNum, n);\\n        }\\n\\n        long res = Long.MAX_VALUE;\\n        for (int k = minNum; k <= maxNum; k++){\\n            long sum = 0;\\n            for (int i = 0; i < nums.length; i++)\\n                sum += 1l * Math.abs(nums[i] - k) * cost[i];\\n            res = Math.min(res, sum);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n    //4.Binary Search based on 1.brute force \\n    //Runtime: 54 ms, faster than 100.00% of Java online submissions for Minimum Cost to Make Array Equal.\\n    //Memory Usage: 80.5 MB, less than 100.00% of Java online submissions for Minimum Cost to Make Array Equal.\\n    //Time: O(N + N + logN * (N + N)); Space(1)\\n    //Time: O(N * logN); Space(1)\\n    public long minCost(int[] nums, int[] cost) {\\n        long minNum = Integer.MAX_VALUE, maxNum = Integer.MIN_VALUE;\\n        //Time: O(N)\\n        for(int n : nums){\\n            minNum = Math.min(minNum, n);\\n            maxNum = Math.max(maxNum, n);\\n        }\\n        \\n        //Time: O(N)\\n        long res = findCost(nums, cost, minNum);\\n\\n        //Time: O(logN * (N + N))\\n        while (minNum < maxNum) {\\n            long mid = (minNum + maxNum) / 2;\\n            long costLeft = findCost(nums, cost, mid);         //Time: O(N)\\n            long costRight = findCost(nums, cost, mid + 1); //Time: O(N)\\n            res = Math.min(costLeft, costRight);\\n            if (costLeft < costRight) maxNum = mid;\\n            else minNum = mid + 1;\\n        }\\n        return res;\\n    }\\n\\n    //Time: O(N)\\n    private long findCost(int[] nums, int[] cost, long x) {\\n        long res = 0L;\\n        for (int i = 0; i < nums.length; i++)\\n            res += Math.abs(nums[i] - x) * cost[i];\\n        return res;\\n    }\\n```\n```\\n    //3.sort + prefix sum\\n\\t //idea:\\n    //Before this, I code brute force first. But they are all TLE.... Then I tried to solve TLE.\\n    //The time complexity is O(N * N), which means I DO compute the cost for N times. It\\'s too much.\\n    //\\n    //Then I try to do the compute only once.(if so, we can save a lot of time...)\\n    //If we already have a cost, then I wonder if possible to add or minus something to get the next smaller cost?\\n    //\\n    //Let\\'s pickup one number which has the largest cost, let it be X, its cost is costOfX,  its position is positionX.\\n    //then we can easily get the whole cost, let be costX.\\n    //\\n    //now next step : shall we move to positionX + 1 or positionX - 1 ? or just stay at positionX?\\n    //we know we want to get the smaller cost.\\n    //if we move to the right neighbour (move from positionX to positionX + 1):\\n    //1.every number on the right side, their costs should be removed from costX;\\n    //2.every number on the left side, their costs should be added to costX;\\n    //3.costOfX also need to be added to costX.\\n    //   costX1 = costX - costRight + costLeft + costOfX\\n    //  if costX1 is smaller than original cost costX, then we should move to right neighbour.\\n    //   costX1 < costX\\n    //   ==> costX - costRight + costLeft + costOfX < costX\\n    //   ==> costLeft + costOfX < costRight\\n    //   now we get the equation\\n    // similarly, we can get the other equation for positionX - 1\\n    //  costX_1 = costX - costLeft + costRight + costOfX < costX\\n    //   ==> costRight + costOfX < costLeft\\n    //  now, we can use these two equations to chose : positionX + 1 or positionX - 1 ? or positionX?\\n    //  In equations we need the costRight and costLeft, the prefix sum is very useful to such scenarios. so I add prefix sum.\\n    //\\n    // In the end, we get the index of number which is the element in the final array.\\n\\t// The last step is easy, jsut compute the cost and return.\\n\\t//\\n    //\\n    //Runtime: 189 ms, faster than 50.00% of Java online submissions for Minimum Cost to Make Array Equal.\\n    //Memory Usage: 95.2 MB, less than 75.00% of Java online submissions for Minimum Cost to Make Array Equal.\\n    //Time: O(N + N * logN + N + N + N); Space: O(N + logN + N)\\n    //Time: O(4N + N * logN); Space: O(N)\\n    //Time: O(N * logN); Space: O(N)\\n    public long minCost_3(int[] nums, int[] cost) {\\n\\n        //Time: O(N); Space: O(N)\\n        int[][] data = new int[nums.length][2];\\n        for (int i = 0; i < nums.length; i++)\\n            data[i] = new int[]{nums[i],cost[i]};\\n\\n        //Time: O(N * logN); Space: O(logN)\\n        Arrays.sort(data, Comparator.comparingInt(a -> a[0]));\\n\\n        //prefix sum, max cost\\n        //Time: O(N); Space: O(N)\\n        int idx = 0, maxCost = Integer.MIN_VALUE;\\n        long[] preSum = new long[nums.length + 1];\\n        for (int i = 0; i < data.length; i++) {\\n            preSum[i + 1] = preSum[i] + data[i][1];\\n            if (data[i][1] > maxCost){\\n                idx = i;\\n                maxCost = data[i][1];\\n            }\\n        }\\n\\n        //Time: worstCase : O(N)\\n        long sum = preSum[preSum.length - 1];\\n        int lastIdx = -1;\\n        while (lastIdx != idx) {\\n            lastIdx = idx;\\n            if (preSum[idx + 1] < sum - preSum[idx + 1]) idx++;\\n            else if (preSum[idx] > sum - preSum[idx]) idx--;\\n        }\\n\\n        //Time: O(N)\\n        long res = 0l;\\n        for (int i = 0; i < nums.length; i++)\\n            res += 1l * Math.abs(nums[i] - data[idx][0]) * cost[i];\\n        return res;\\n    }\\n\\t\\n```\n```\\n\\n    //2.Brute force 2\\n    //TLE\\n    //Time: O(N * N)\\n    public long minCost_2(int[] nums, int[] cost) {\\n\\n        Set<Integer> set = new HashSet<>();\\n        long res = Long.MAX_VALUE;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (!set.add(nums[j])) continue;\\n            long sum = 0;\\n            for (int i = 0; i < nums.length; i++)\\n                sum += 1l * Math.abs(nums[i] - nums[j]) * cost[i];\\n            res = Math.min(res, sum);\\n        }\\n        return res;\\n    }\\n```\n```\\n    //1.Brute force\\n    //TLE\\n    //Time: O(N * N)\\n    public long minCost_1(int[] nums, int[] cost) {\\n        int minNum = Integer.MAX_VALUE;\\n        int maxNum = Integer.MIN_VALUE;\\n\\n        for(int n : nums){\\n            minNum = Math.min(minNum, n);\\n            maxNum = Math.max(maxNum, n);\\n        }\\n\\n        long res = Long.MAX_VALUE;\\n        for (int k = minNum; k <= maxNum; k++){\\n            long sum = 0;\\n            for (int i = 0; i < nums.length; i++)\\n                sum += 1l * Math.abs(nums[i] - k) * cost[i];\\n            res = Math.min(res, sum);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663956,
                "title": "simple-binary-search-c-intituitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy looking at the test cases we need a solution in nlogn.So we can try binary search. And when we think about binary search in this question We can easily thought of our solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use Binary in the ranges of min and max element of nums. And we try to find the total cost at the middle element and middle + 1 And then we compare there total cost whichever is smallest we will go to the side.\\nDon\\'t look at the solution this time and try by yourself.\\nThank you You can Upvote If you like the silution and approach.\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long totalcost(vector<int>& nums, vector<int>& cost,int nn) {\\n      long long ans=0;\\n      for(int i=0;i<nums.size();i++) ans+=(long long)((long long)abs((long long)nums[i]-(long long)nn)*(long long)cost[i]);\\n      return ans;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n\\n            int i=nums[0],j=nums[0];\\n            for(auto it:nums) {\\n                i=min(i,it);\\n                j=max(j,it);\\n            }\\n            long long ans=0;\\n            while(i<=j){\\n                int m=(i+j)/2;\\n                auto it1=totalcost(nums,cost,m);\\n                auto it2=totalcost(nums,cost,m+1);\\n                if(it1>it2){\\n                    ans=it2;\\n                    i=m+1;\\n                }\\n                else{\\n                    j=m-1;\\n                    ans=it1;\\n                }\\n            }\\n            return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long totalcost(vector<int>& nums, vector<int>& cost,int nn) {\\n      long long ans=0;\\n      for(int i=0;i<nums.size();i++) ans+=(long long)((long long)abs((long long)nums[i]-(long long)nn)*(long long)cost[i]);\\n      return ans;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n\\n            int i=nums[0],j=nums[0];\\n            for(auto it:nums) {\\n                i=min(i,it);\\n                j=max(j,it);\\n            }\\n            long long ans=0;\\n            while(i<=j){\\n                int m=(i+j)/2;\\n                auto it1=totalcost(nums,cost,m);\\n                auto it2=totalcost(nums,cost,m+1);\\n                if(it1>it2){\\n                    ans=it2;\\n                    i=m+1;\\n                }\\n                else{\\n                    j=m-1;\\n                    ans=it1;\\n                }\\n            }\\n            return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772953,
                "title": "javascript-java-python3-sorting-prefix-and-suffix-sum-js-no-bigint-can-accepted",
                "content": "If we want to minimize operations, pick a value in the section.\\n\\n## 1. Brute Force : O(n^2), TLE\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minCost = function(nums, cost) {\\n    const n = nums.length;\\n    \\n    let res = Infinity;\\n    for(let i = 0; i < n; i++){\\n        const target = nums[i];\\n        let total = 0;\\n        for(let j = 0; j < n; j++){\\n            total += Math.abs(target - nums[j]) * cost[j];\\n        }\\n        res = Math.min(res, total);\\n    }\\n    return res;\\n};\\n```\\n\\n***\\n\\n## 2. Optimize\\n\\n```\\n\\n\\t\\t  --->         <---\\ntarget =  *\\n        --|---|---|-----|-----------\\n  nums =  1   2   3     5\\n  cost =  2   14  3     1\\n\\nnums and cost array should be sorting Ascending order by nums.\\n```\\n\\n### Explain : \\n\\nBase Case : sum all steps reach to first number ==> memo in preSum\\n\\n\\n```\\n\\t\\t      \\ntarget =  *  <-----------\\n        --|---|---|-----|-----------\\n  nums =  1   2   3     5\\n  cost =  2   14  3     1\\n  \\n preSum => (1-1)*2 + (2-1)*14 + (3-1)*3 + (5-1)*1\\n        => 0 + 14 + 6 + 4 = \\n\\t\\t=> 24\\n```\\n\\n### So, what that mean? \\n```\\ntarget =  *  <-----------\\n        --|---|---|-----|-----------\\n          ^\\n\\tIf we stand here, that means the total cost of moving each point here.\\n```\\n\\n```\\nOk, we move on the right next.\\n\\ntarget =   -> *  <------\\n        --|---|---|-----|-----------\\n\\t\\t  1   2   3     5\\n```\\n\\n#### When we move on next, means every point on the left side should move more costs to the right.\\n#### While moving to the right, all points on the right side are closer to the target point, so the cost needs to be reduced.\\n\\n#### How can we do it easy ? we can build prefix sum and suffix sum.\\n\\n```\\ntarget =  --> *  <------\\n        --|---|---|-----|-----------\\n\\t\\t  1   2   3     5\\n  nums =  1   2   3     5\\n  cost =  2   14  3     1\\n\\nprefix =  2   16  19   20\\nsuffix = 20   18   4    1\\n\\t     i-1   i\\n\\t\\t       ^\\n\\t      We stand here\\n\\n// Formula\\nsteps = nums[i] - nums[i - 1]\\ntotalSteps = steps * (prefix[i - 1] - suffix[i])\\ncur = 0;\\ncur = ABS(preSum + totalSteps);\\n\\nres = MIN(res, cur)\\n\\n// update curSum\\npreSum = cur\\n```\\n***\\n**Code**\\nTime : O(nlogn + n)\\nSpace : O(n)\\n\\n* 2023/6/21 Daily Challenge update Python3 code\\n\\t\\n<iframe src=\"https://leetcode.com/playground/Wxvc64tn/shared\" frameBorder=\"0\" width=\"100%\" height=\"1000\"></iframe>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minCost = function(nums, cost) {\\n    const n = nums.length;\\n    \\n    let res = Infinity;\\n    for(let i = 0; i < n; i++){\\n        const target = nums[i];\\n        let total = 0;\\n        for(let j = 0; j < n; j++){\\n            total += Math.abs(target - nums[j]) * cost[j];\\n        }\\n        res = Math.min(res, total);\\n    }\\n    return res;\\n};\\n```\n```\\n\\n\\t\\t  --->         <---\\ntarget =  *\\n        --|---|---|-----|-----------\\n  nums =  1   2   3     5\\n  cost =  2   14  3     1\\n\\nnums and cost array should be sorting Ascending order by nums.\\n```\n```\\n\\t\\t      \\ntarget =  *  <-----------\\n        --|---|---|-----|-----------\\n  nums =  1   2   3     5\\n  cost =  2   14  3     1\\n  \\n preSum => (1-1)*2 + (2-1)*14 + (3-1)*3 + (5-1)*1\\n        => 0 + 14 + 6 + 4 = \\n\\t\\t=> 24\\n```\n```\\ntarget =  *  <-----------\\n        --|---|---|-----|-----------\\n          ^\\n\\tIf we stand here, that means the total cost of moving each point here.\\n```\n```\\nOk, we move on the right next.\\n\\ntarget =   -> *  <------\\n        --|---|---|-----|-----------\\n\\t\\t  1   2   3     5\\n```\n```\\ntarget =  --> *  <------\\n        --|---|---|-----|-----------\\n\\t\\t  1   2   3     5\\n  nums =  1   2   3     5\\n  cost =  2   14  3     1\\n\\nprefix =  2   16  19   20\\nsuffix = 20   18   4    1\\n\\t     i-1   i\\n\\t\\t       ^\\n\\t      We stand here\\n\\n// Formula\\nsteps = nums[i] - nums[i - 1]\\ntotalSteps = steps * (prefix[i - 1] - suffix[i])\\ncur = 0;\\ncur = ABS(preSum + totalSteps);\\n\\nres = MIN(res, cur)\\n\\n// update curSum\\npreSum = cur\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734477,
                "title": "python-o-nlogn-gradient-descent-easy-to-understand-if-you-re-familiar-with-ml-concepts",
                "content": "Basically we need to find a `target` that minimize the total `loss(target) = sum([abs(nums[i]-target)*cost[i])`. For a candidate `target`, we can calculate its `loss(target)` and the loss of the 2 neighboring target `loss(target-1)` and `loss(target+1)`.\\n1) Initialize 2 `low` and `high` boundaries as the min and max of the `nums` array\\n2) Let `target = (low+high)//2` (common binary search procedure)\\n- If `loss(target-1) >= loss(target) <= loss(target+1)`, this mean the target is at local minimum, since this is a convex optimization problem, this is also a global minimum and you can just return `loss(target)`\\n- If `loss(target-1) < loss(target)`, this mean the gradient positive, then is at local minimum is at the `target` with lower value, set `high=target-1`\\n- If `loss(target+1) < loss(target)`, this mean the gradient negative, then is at local minimum is at the `target` with higher value, set `low=target+1`\\n\\nRepeat 2) until `low > high`\\n\\n```\\ndef cal_cost(self, nums, cost, target):\\n\\tans = 0\\n\\tfor n, c in zip(nums, cost):\\n\\t\\tans += abs(n-target) * c\\n\\treturn ans\\n\\ndef minCost(self, nums: List[int], cost: List[int]) -> int:\\n\\tlow, high = min(nums), max(nums)\\n\\twhile (low <= high):\\n\\t\\ttarget = (low+high)//2\\n\\t\\tcost_curr = self.cal_cost(nums, cost, target)\\n\\t\\tcost_left = self.cal_cost(nums, cost, target-1)\\n\\t\\tcost_right = self.cal_cost(nums, cost, target+1)\\n\\t\\tif cost_left >= cost_curr <= cost_right:\\n\\t\\t\\treturn cost_curr\\n\\t\\telif cost_left < cost_curr:\\n\\t\\t\\thigh = target-1\\n\\t\\telse:   # cost_right < cost:\\n\\t\\t\\tlow = target+1\\n\\treturn low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef cal_cost(self, nums, cost, target):\\n\\tans = 0\\n\\tfor n, c in zip(nums, cost):\\n\\t\\tans += abs(n-target) * c\\n\\treturn ans\\n\\ndef minCost(self, nums: List[int], cost: List[int]) -> int:\\n\\tlow, high = min(nums), max(nums)\\n\\twhile (low <= high):\\n\\t\\ttarget = (low+high)//2\\n\\t\\tcost_curr = self.cal_cost(nums, cost, target)\\n\\t\\tcost_left = self.cal_cost(nums, cost, target-1)\\n\\t\\tcost_right = self.cal_cost(nums, cost, target+1)\\n\\t\\tif cost_left >= cost_curr <= cost_right:\\n\\t\\t\\treturn cost_curr\\n\\t\\telif cost_left < cost_curr:\\n\\t\\t\\thigh = target-1\\n\\t\\telse:   # cost_right < cost:\\n\\t\\t\\tlow = target+1\\n\\treturn low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734422,
                "title": "kotlin-prefix-suffix-simple-solution",
                "content": "```\\nclass Solution {\\n    fun minCost(nums: IntArray, cost: IntArray): Long {\\n        val max = Collections.max(nums.toList())\\n        val arr = IntArray(max + 1)\\n        for (i in nums.indices) {\\n            arr[nums[i]] += cost[i]\\n        }\\n        val pref = LongArray(arr.size)\\n    \\n        var currAdd = 0L\\n        var curr = 0L\\n        for (i in arr.indices) {\\n            currAdd += arr[i]\\n            curr += currAdd\\n            pref[i] = curr\\n        }\\n        currAdd = 0L\\n        curr = 0L\\n        val suf = LongArray(arr.size + 1)\\n        for (i in arr.size - 1 downTo 0) {\\n            currAdd += arr[i]\\n            curr += currAdd\\n            suf[i] = curr\\n        }\\n        var minT = Long.MAX_VALUE\\n        for (i in nums) {\\n            minT = Math.min(minT, pref[i - 1] + suf[i + 1])\\n        }\\n        return minT\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    fun minCost(nums: IntArray, cost: IntArray): Long {\\n        val max = Collections.max(nums.toList())\\n        val arr = IntArray(max + 1)\\n        for (i in nums.indices) {\\n            arr[nums[i]] += cost[i]\\n        }\\n        val pref = LongArray(arr.size)\\n    \\n        var currAdd = 0L\\n        var curr = 0L\\n        for (i in arr.indices) {\\n            currAdd += arr[i]\\n            curr += currAdd\\n            pref[i] = curr\\n        }\\n        currAdd = 0L\\n        curr = 0L\\n        val suf = LongArray(arr.size + 1)\\n        for (i in arr.size - 1 downTo 0) {\\n            currAdd += arr[i]\\n            curr += currAdd\\n            suf[i] = curr\\n        }\\n        var minT = Long.MAX_VALUE\\n        for (i in nums) {\\n            minT = Math.min(minT, pref[i - 1] + suf[i + 1])\\n        }\\n        return minT\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666600,
                "title": "how-this-worked-please-explain-me-brute-force",
                "content": "# Approach\\nI have literally Coded the Fist Intution of Binary Search and Did\\'nt have any idea ! why this Worked \\n\\nThe Optimal Solution must lie in the Range of **MAX** and **MIN** of nums Array\\n\\nComparing value of 2 calls and deciding the window accordingly\\n\\n# Complexity\\n- Time complexity: $$O(2*n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n     ll isPossible(vector<int>& nums, vector<int>& cost, int FinalValue, int n){\\n         ll cnt = 0;\\n         for(int i = 0; i<n ;i++){\\n             cnt  += abs(nums[i]-FinalValue)*1LL*cost[i];\\n         }\\n         return cnt;\\n     }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n         ll start = *min_element(nums.begin(), nums.end());\\n         ll end = *max_element(nums.begin(), nums.end());\\n         int n = nums.size();\\n         ll ans = 0;\\n         while(start < end){\\n             ll mid = start+(end-start)/2;\\n             ll first = isPossible(nums,cost, mid, n);\\n             ll second = isPossible(nums, cost, mid+1, n);\\n             if(first < second){\\n                 ans = first;\\n                 end = mid;\\n             }\\n             else{\\n                 ans = second;\\n                 start = mid+1;\\n             }\\n         }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n     ll isPossible(vector<int>& nums, vector<int>& cost, int FinalValue, int n){\\n         ll cnt = 0;\\n         for(int i = 0; i<n ;i++){\\n             cnt  += abs(nums[i]-FinalValue)*1LL*cost[i];\\n         }\\n         return cnt;\\n     }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n         ll start = *min_element(nums.begin(), nums.end());\\n         ll end = *max_element(nums.begin(), nums.end());\\n         int n = nums.size();\\n         ll ans = 0;\\n         while(start < end){\\n             ll mid = start+(end-start)/2;\\n             ll first = isPossible(nums,cost, mid, n);\\n             ll second = isPossible(nums, cost, mid+1, n);\\n             if(first < second){\\n                 ans = first;\\n                 end = mid;\\n             }\\n             else{\\n                 ans = second;\\n                 start = mid+1;\\n             }\\n         }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663752,
                "title": "solution-in-4-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @param {Integer[]} costs\\n# @return {Integer}\\ndef min_cost(nums, costs)\\n  min, max = nums.minmax\\n  return 0 if min == max\\n\\n  memo = Hash.new { |h, k| h[k] = nums.zip(costs).sum(0) { |number, cost| cost * (k - number).abs } }\\n  memo[(min..max).bsearch { |number| memo[number] < memo[number + 1] }]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer[]} costs\\n# @return {Integer}\\ndef min_cost(nums, costs)\\n  min, max = nums.minmax\\n  return 0 if min == max\\n\\n  memo = Hash.new { |h, k| h[k] = nums.zip(costs).sum(0) { |number, cost| cost * (k - number).abs } }\\n  memo[(min..max).bsearch { |number| memo[number] < memo[number + 1] }]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2734540,
                "title": "c-binary-search-o-nlogn-easy-understanding",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll cos(vector<int>& nums, vector<int>& cost,int m){\\n        ll ans=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            ans += 1LL*(1LL*abs(nums[i]-m)*1LL*cost[i]);\\n        }\\n        return ans;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        int s = *min_element(nums.begin(),nums.end());\\n        int e = *max_element(nums.begin(),nums.end());\\n        ll ans=LLONG_MAX;\\n        while(s<=e){\\n            int m = s+ (e-s)/2;\\n            ll p = cos(nums,cost,m);\\n            ll q = cos(nums,cost,m+1);\\n            if(p<q){\\n                e = m-1;\\n                ans = min(ans,p);\\n            }else{\\n                s = m+2;\\n                ans = min(ans,q);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll cos(vector<int>& nums, vector<int>& cost,int m){\\n        ll ans=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            ans += 1LL*(1LL*abs(nums[i]-m)*1LL*cost[i]);\\n        }\\n        return ans;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        int s = *min_element(nums.begin(),nums.end());\\n        int e = *max_element(nums.begin(),nums.end());\\n        ll ans=LLONG_MAX;\\n        while(s<=e){\\n            int m = s+ (e-s)/2;\\n            ll p = cos(nums,cost,m);\\n            ll q = cos(nums,cost,m+1);\\n            if(p<q){\\n                e = m-1;\\n                ans = min(ans,p);\\n            }else{\\n                s = m+2;\\n                ans = min(ans,q);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734179,
                "title": "minimum-cost-to-make-array-equal",
                "content": "Only one wrong step just cost me extra 5 min\\n\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int lo = Integer.MAX_VALUE, hi = Integer.MIN_VALUE;\\n        for(int val : nums){\\n            lo = Math.min(lo, val);\\n            hi= Math.max(hi, val);\\n        }\\n        //System.out.println(lo + \" \" + hi);\\n        long res = (long)(1e18);\\n        while(lo <= hi){\\n            int mid = (lo + hi) >> 1;\\n            res = Math.min(res, change(nums, cost, mid));\\n            long left = change(nums, cost, mid-1); // this two steps are done to check which side should we go for further answer.\\n            long right = change(nums, cost, mid+1); // if left is smaller then the possible answer should lie in the left part or vise versa\\n            if(left < right){\\n                hi = mid-1;\\n            }else{\\n                lo = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public long change(int[] nums, int[] costs, int tar){\\n        long ans = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] != tar){\\n                int diff = Math.abs(nums[i] - tar); \\n                ans+=(long) diff*costs[i]; // I just forget to typecast long here, which cost me extra 5min\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int lo = Integer.MAX_VALUE, hi = Integer.MIN_VALUE;\\n        for(int val : nums){\\n            lo = Math.min(lo, val);\\n            hi= Math.max(hi, val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2734146,
                "title": "c-binary-search-on-range",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:  \\n    ll find(ll mid,vector<int>& nums, vector<int>& cost){\\n        ll sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            ll temp = abs(nums[i]-mid)*cost[i];\\n            sum+=temp;\\n        }\\n        return sum;\\n    }\\n    \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll ans=LONG_MAX;\\n        ll mn=*min_element(nums.begin(),nums.end());\\n        ll mx=*max_element(nums.begin(),nums.end());\\n        while(mn<=mx){\\n            ll mid = mn+(mx-mn)/2;\\n            ll sum = find(mid,nums,cost);\\n            if(sum<ans){\\n                ans=sum;\\n            }\\n            ll sum1 = find(mid-1,nums,cost);\\n            ll sum2 = find(mid+1,nums,cost);\\n            if(sum<=sum1 and sum<=sum2) break;\\n            if(sum1<sum2){\\n                ans=min(ans,sum1);\\n                mx=mid-1;\\n            }\\n            else{\\n                ans=min(ans,sum2);\\n                mn=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:  \\n    ll find(ll mid,vector<int>& nums, vector<int>& cost){\\n        ll sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            ll temp = abs(nums[i]-mid)*cost[i];\\n            sum+=temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3665592,
                "title": "optimized-cost-calculation-algorithm-for-number-array",
                "content": "# Intuition\\n    The intuition behind this approach is to calculate the minimum cost required\\n     by considering different starting points in the given array of numbers and costs.\\n\\n\\n# Approach\\n    The given code first sorts the numbers and their corresponding costs in ascending order based on the numbers.\\n    It then calculates the total cost by iterating over the sorted numbers from the second element onwards.\\n    For each iteration, it calculates the difference between the current number and the first number as DX.\\n    It updates the total cost by adding DX multiplied by the cost of the current number.\\n    After calculating the cost with the first number as the starting point, it sets the initial answer to the total cost.\\n    Next, the code starts a new iteration from the second element onwards.\\n    For each iteration, it calculates DX as the difference between the current number and the previous number.\\n    It updates the total cost by subtracting the cost of subsequent numbers multiplied by DX, and adding the cost of previous numbers multiplied by DX.\\n    It checks if the new total cost is less than the current answer and updates answer if necessary.\\n    Finally, it returns the answer as the minimum cost.\\n# Complexity\\n    Time complexity: The time complexity of this approach is O(n log n) due to the sorting operation performed on the numbers and costs.\\n    Space complexity: The space complexity is O(n) as the sorted numbers and costs are stored in separate arrays.\\n![R.gif](https://assets.leetcode.com/users/images/281d3b32-91a4-4062-bb94-9513d3674da6_1687350399.6921966.gif)\\n\\n# Code\\n```\\npublic class Solution {\\n   public long MinCost(int[] nums, int[] cost)\\n{\\n    var sortedArrays = nums.Select((num, index) => new { Num = (long)num, Cost = (long)cost[index] })\\n        .OrderBy(item => item.Num)\\n        .ToArray();\\n\\n\\n    long[] sortedNums = sortedArrays.Select(item =>item.Num).ToArray();\\n    long[] sortedCost = sortedArrays.Select(item =>item.Cost).ToArray();\\n\\n     long[] prefixCost = new long[sortedCost.Length];\\n       prefixCost[0] = sortedCost[0];\\nfor (int i = 1; i < sortedCost.Length; ++i)\\n    prefixCost[i] = sortedCost[i] + prefixCost[i - 1];\\n\\n\\n\\n\\n    long totalCost = 0;\\n    long DX;\\n    for (int i = 1; i < sortedNums.Length; i++)\\n    {\\n        DX = sortedNums[i] - sortedNums[0];\\n        totalCost += DX * (long)sortedCost[i];\\n    }\\n    long answer = totalCost;\\n\\n    for (int i = 1; i < sortedNums.Length; i++)\\n    {\\n        DX = sortedNums[i] - sortedNums[i - 1];\\n            totalCost +=  prefixCost[i - 1] * DX;\\n            totalCost -=  (prefixCost[sortedCost.Length - 1] - prefixCost[i - 1]) * DX;\\n        answer = totalCost < answer ? totalCost : answer;\\n    }\\n\\n    return answer;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\npublic class Solution {\\n   public long MinCost(int[] nums, int[] cost)\\n{\\n    var sortedArrays = nums.Select((num, index) => new { Num = (long)num, Cost = (long)cost[index] })\\n        .OrderBy(item => item.Num)\\n        .ToArray();\\n\\n\\n    long[] sortedNums = sortedArrays.Select(item =>item.Num).ToArray();\\n    long[] sortedCost = sortedArrays.Select(item =>item.Cost).ToArray();\\n\\n     long[] prefixCost = new long[sortedCost.Length];\\n       prefixCost[0] = sortedCost[0];\\nfor (int i = 1; i < sortedCost.Length; ++i)\\n    prefixCost[i] = sortedCost[i] + prefixCost[i - 1];\\n\\n\\n\\n\\n    long totalCost = 0;\\n    long DX;\\n    for (int i = 1; i < sortedNums.Length; i++)\\n    {\\n        DX = sortedNums[i] - sortedNums[0];\\n        totalCost += DX * (long)sortedCost[i];\\n    }\\n    long answer = totalCost;\\n\\n    for (int i = 1; i < sortedNums.Length; i++)\\n    {\\n        DX = sortedNums[i] - sortedNums[i - 1];\\n            totalCost +=  prefixCost[i - 1] * DX;\\n            totalCost -=  (prefixCost[sortedCost.Length - 1] - prefixCost[i - 1]) * DX;\\n        answer = totalCost < answer ? totalCost : answer;\\n    }\\n\\n    return answer;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664440,
                "title": "c-prefix-suffix",
                "content": "# Hints\\n1. Is it possible to compute for all nums[i], the cost of making all elements equal to it ? \"YES\"\\n2. how can we do above ? \"Create prefix and suffix cost arrays\"\\n3. Now just taken min({ pre[i] + suf[i] });\\n\\n\\n# Complexity\\n- Time complexity:\\n```\\nO(nlogn)\\n```\\n\\n- Space complexity:\\n```\\nO(n)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n    \\tint n = nums.size();\\n    \\tvector<pair<int, int>>arr(n);\\n    \\tfor(int i = 0; i < n; i++)\\n    \\t\\tarr[i] = {nums[i], cost[i]};\\n    \\tsort(arr.begin(), arr.end());\\n\\n    \\tvector<long long>pre(n);\\n    \\tpre[0] = 0;\\n    \\tlong long base = arr[0].second;\\n    \\tfor(int i = 1; i < n; i++) {\\n    \\t\\tpre[i] = pre[i - 1] + base * (arr[i].first - arr[i - 1].first);\\n    \\t\\tbase += arr[i].second;\\n  \\n    \\t}\\n    \\t\\n    \\tvector<long long>post(n);\\n    \\tpost[n - 1] = 0;\\n    \\tbase = arr[n - 1].second;\\n    \\tfor(int i = n - 2; i >= 0; i--) {\\n    \\t\\tpost[i] = post[i + 1] + base * (arr[i + 1].first - arr[i].first);\\n    \\t\\tbase += arr[i].second;\\n\\n    \\t}\\n    \\t\\n    \\tlong long ans = post[0];\\n    \\tfor(int i = 0; i < n; i++)\\n    \\t\\tans = min(ans, pre[i] + post[i]);\\n    \\treturn ans;\\n    }\\n};\\n```\\n\\n# NOTE\\n\\nwe can easily use above code for various variations of same problem, for example the author can ask us to find cost to make all elements equal to x, for q queries.\\n\\n\\n# Happy learning \\uD83D\\uDC97",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nO(nlogn)\\n```\n```\\nO(n)\\n```\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n    \\tint n = nums.size();\\n    \\tvector<pair<int, int>>arr(n);\\n    \\tfor(int i = 0; i < n; i++)\\n    \\t\\tarr[i] = {nums[i], cost[i]};\\n    \\tsort(arr.begin(), arr.end());\\n\\n    \\tvector<long long>pre(n);\\n    \\tpre[0] = 0;\\n    \\tlong long base = arr[0].second;\\n    \\tfor(int i = 1; i < n; i++) {\\n    \\t\\tpre[i] = pre[i - 1] + base * (arr[i].first - arr[i - 1].first);\\n    \\t\\tbase += arr[i].second;\\n  \\n    \\t}\\n    \\t\\n    \\tvector<long long>post(n);\\n    \\tpost[n - 1] = 0;\\n    \\tbase = arr[n - 1].second;\\n    \\tfor(int i = n - 2; i >= 0; i--) {\\n    \\t\\tpost[i] = post[i + 1] + base * (arr[i + 1].first - arr[i].first);\\n    \\t\\tbase += arr[i].second;\\n\\n    \\t}\\n    \\t\\n    \\tlong long ans = post[0];\\n    \\tfor(int i = 0; i < n; i++)\\n    \\t\\tans = min(ans, pre[i] + post[i]);\\n    \\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664048,
                "title": "java-convex-optimisation-time-13ms-98-space-55mb-95",
                "content": "# Approach\\nWe need to minimise the absolute difference between the elements and the unknown equal value, multiplied by the cost coefficient. This is a convex function, so we can simply find the global minimum by walking down the slope. Since it is a simple convex function, binary search would be the most efficient (as compared to gradient descent, etc).\\n\\n# Complexity\\n- Time complexity:\\nO(n log d) *, where n is the size of the array and d is the difference b/w the max and min elements*\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\tint[] nums, cost; // input to minCost()\\n\\n\\t/**\\n\\t * Finds the cost to make all elements in the array equal to the given value.\\n\\t * @param val given value to make all elements equal to\\n\\t * @return cost to make all elements equal to val\\n\\t */\\n\\tprivate long cost(int val) {\\n\\t\\tlong totalCost = 0L;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\ttotalCost += 1L * Math.abs(nums[i] - val) * cost[i];\\n\\t\\t}\\n\\t\\treturn totalCost;\\n\\t}\\n\\n\\t/**\\n\\t * Finds the minimum cost to make all elements in the array equal.\\n\\t * @param nums elements of the array\\n\\t * @param cost cost[i] = cost of changing nums[i] by 1\\n\\t * @return minimum cost to make all elements equal\\n\\t */\\n\\tpublic long minCost(int[] nums, int[] cost) {\\n\\t\\t// pass by reference\\n\\t\\tthis.nums = nums;\\n\\t\\tthis.cost = cost;\\n\\n\\t\\t// find max and min element\\n\\t\\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int elem : nums) {\\n\\t\\t\\tif (elem < min) min = elem;\\n\\t\\t\\tif (elem > max) max = elem;\\n\\t\\t}\\n\\n\\t\\t// binary search\\n\\t\\tint mid;\\n\\t\\twhile (max - min > 1) {\\n\\t\\t\\tmid = (min + max) / 2;\\n\\t\\t\\tif (cost(mid) < cost(mid + 1)) max = mid; // positive slope\\n\\t\\t\\telse min = mid; // negative slope\\n\\t\\t}\\n\\n\\t\\t// return minimum cost\\n\\t\\treturn Math.min(cost(min), cost(max));\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tint[] nums, cost; // input to minCost()\\n\\n\\t/**\\n\\t * Finds the cost to make all elements in the array equal to the given value.\\n\\t * @param val given value to make all elements equal to\\n\\t * @return cost to make all elements equal to val\\n\\t */\\n\\tprivate long cost(int val) {\\n\\t\\tlong totalCost = 0L;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\ttotalCost += 1L * Math.abs(nums[i] - val) * cost[i];\\n\\t\\t}\\n\\t\\treturn totalCost;\\n\\t}\\n\\n\\t/**\\n\\t * Finds the minimum cost to make all elements in the array equal.\\n\\t * @param nums elements of the array\\n\\t * @param cost cost[i] = cost of changing nums[i] by 1\\n\\t * @return minimum cost to make all elements equal\\n\\t */\\n\\tpublic long minCost(int[] nums, int[] cost) {\\n\\t\\t// pass by reference\\n\\t\\tthis.nums = nums;\\n\\t\\tthis.cost = cost;\\n\\n\\t\\t// find max and min element\\n\\t\\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int elem : nums) {\\n\\t\\t\\tif (elem < min) min = elem;\\n\\t\\t\\tif (elem > max) max = elem;\\n\\t\\t}\\n\\n\\t\\t// binary search\\n\\t\\tint mid;\\n\\t\\twhile (max - min > 1) {\\n\\t\\t\\tmid = (min + max) / 2;\\n\\t\\t\\tif (cost(mid) < cost(mid + 1)) max = mid; // positive slope\\n\\t\\t\\telse min = mid; // negative slope\\n\\t\\t}\\n\\n\\t\\t// return minimum cost\\n\\t\\treturn Math.min(cost(min), cost(max));\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663916,
                "title": "c-binary-search-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    long long findCost(vector<int>& nums, vector<int>& cost, int converge) {\\n        long long totalc=0;\\n        for (int i=0;i<nums.size();i++) {\\n            totalc += 1L * abs(nums[i]-converge) * cost[i];\\n        }\\n        return totalc;\\n    }\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int l=nums[0],r=nums[0];\\n        for (auto i: nums) {\\n            l=min(l,i); // min element of array\\n            r=max(r,i); // max element of array\\n        }\\n        long long ans=0;\\n        while (l<r) { // binary search\\n            int mid=(l+r)/2;\\n            long long cost1=findCost(nums,cost,mid);\\n            long long cost2=findCost(nums,cost,mid+1);\\n            if (cost1>cost2) {\\n                l=mid+1;\\n                ans=cost2;\\n            }\\n            else {\\n                r=mid;\\n                ans=cost1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    long long findCost(vector<int>& nums, vector<int>& cost, int converge) {\\n        long long totalc=0;\\n        for (int i=0;i<nums.size();i++) {\\n            totalc += 1L * abs(nums[i]-converge) * cost[i];\\n        }\\n        return totalc;\\n    }\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int l=nums[0],r=nums[0];\\n        for (auto i: nums) {\\n            l=min(l,i); // min element of array\\n            r=max(r,i); // max element of array\\n        }\\n        long long ans=0;\\n        while (l<r) { // binary search\\n            int mid=(l+r)/2;\\n            long long cost1=findCost(nums,cost,mid);\\n            long long cost2=findCost(nums,cost,mid+1);\\n            if (cost1>cost2) {\\n                l=mid+1;\\n                ans=cost2;\\n            }\\n            else {\\n                r=mid;\\n                ans=cost1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740638,
                "title": "c-most-easy-detailed-weighted-median-solution-with-explanation",
                "content": "suppose we have nums array as [1,2,3,4] and corresponding cost array as [2,3,1,4] theresfore we will have to consider cost as weights and therefore 1,1,2,2,2,3,4,4,4,4 so we will se the trend as we approach the middle meaning the median the total cost would decrease and again it would increase as we approach the end of the array therefore we need to find the median  and make all the array elements equal to the median and our work is done!!\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll f(ll med,vector<pair<int,int>> &nums)\\n    {\\n        ll s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s+=abs(med-nums[i].first)*nums[i].second*1LL;//(med-nums[i])->for making nums[i] equal to median and multiplying withe cost[i] and finding out the total sum would give the total cost\\n        }\\n        return s;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<int,int>> v;\\n        ll n=nums.size();\\n        for(int i=0;i<n;i++)\\n            v.push_back({nums[i],cost[i]});\\n        sort(v.begin(),v.end());//sorting according to nums \\n        ll cnt=0;\\n        ll tar=0;\\n\\t\\tll med=0;//median\\n        tar=accumulate(cost.begin(),cost.end(),tar);// calculating sum of all the cost elements\\n        for(int i=0;i<n;i++)\\n        {\\n            cnt+=1LL*v[i].second;\\n            if(cnt>(tar/2))\\n            {\\n                med=v[i].first;// finding out the median \\n                break;\\n            }\\n        }\\n        return f(med,v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll f(ll med,vector<pair<int,int>> &nums)\\n    {\\n        ll s=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s+=abs(med-nums[i].first)*nums[i].second*1LL;//(med-nums[i])->for making nums[i] equal to median and multiplying withe cost[i] and finding out the total sum would give the total cost\\n        }\\n        return s;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<int,int>> v;\\n        ll n=nums.size();\\n        for(int i=0;i<n;i++)\\n            v.push_back({nums[i],cost[i]});\\n        sort(v.begin(),v.end());//sorting according to nums \\n        ll cnt=0;\\n        ll tar=0;\\n\\t\\tll med=0;//median\\n        tar=accumulate(cost.begin(),cost.end(),tar);// calculating sum of all the cost elements\\n        for(int i=0;i<n;i++)\\n        {\\n            cnt+=1LL*v[i].second;\\n            if(cnt>(tar/2))\\n            {\\n                med=v[i].first;// finding out the median \\n                break;\\n            }\\n        }\\n        return f(med,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739699,
                "title": "python-3-7-lines-binary-search-t-m-978-ms-28-6-mb-100-100",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        \\n        price = lambda x:sum(abs(n-x)*c for n,c in zip(nums,cost)) # <-- find the total cost of making array [x,x, ...,x]\\n\\n        left,right = min(nums),max(nums)                           # <-- binary search over [min(nums) <= x <= max(nums)]\\n                                                                   #\\n\\t\\t#print([(x, price(x)) for x in range (min(nums),max(nums)+1)])     # <-- see reply to @Code_Hard17 comment below\\n\\n\\t\\twhile left < right:                                        #\\n            mid = (left + right)//2                                # \\n            if price(mid) < price(mid+1): right = mid              # \\n            else: left = mid+1                                     #\\n\\n        return price(left)                                         # <--  return answer when left = right\\n```\\n[https://leetcode.com/submissions/detail/829392621/](http://)",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        \\n        price = lambda x:sum(abs(n-x)*c for n,c in zip(nums,cost)) # <-- find the total cost of making array [x,x, ...,x]\\n\\n        left,right = min(nums),max(nums)                           # <-- binary search over [min(nums) <= x <= max(nums)]\\n                                                                   #\\n\\t\\t#print([(x, price(x)) for x in range (min(nums),max(nums)+1)])     # <-- see reply to @Code_Hard17 comment below\\n\\n\\t\\twhile left < right:                                        #\\n            mid = (left + right)//2                                # \\n            if price(mid) < price(mid+1): right = mid              # \\n            else: left = mid+1                                     #\\n\\n        return price(left)                                         # <--  return answer when left = right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735959,
                "title": "java-weighted-median-o-nlogn",
                "content": "# Intuition\\nCalculate the weighted median. The number that tips the weight above 50% is the number we want to minimize to.\\n\\n# Code\\n\\n```\\nimport java.util.List;\\nimport java.util.stream.Collectors;\\nimport java.util.stream.IntStream;\\n\\nclass WeightedNum implements Comparable<WeightedNum> {\\n    public int num;\\n    public int weight;\\n\\n    public WeightedNum(int num, int weight) {\\n        this.num = num;\\n        this.weight = weight;\\n    }\\n\\n    @Override\\n    public int compareTo(WeightedNum other) {\\n        return num - other.num;\\n    }\\n}\\n\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        List<WeightedNum> weightedNums = IntStream\\n                .range(0, nums.length)\\n                .boxed()\\n                .map(i -> new WeightedNum(nums[i], cost[i]))\\n                .sorted()\\n                .toList();\\n\\n        long totalWeight = 0;\\n        for (int weight : cost) totalWeight += weight;\\n\\t\\t\\n        long currentRunningWeight = 0L;\\n        int numberToMinimizeTo = 0;\\n        for (WeightedNum weightedNum : weightedNums) {\\n            currentRunningWeight += weightedNum.weight;\\n\\t\\t\\t\\n\\t\\t\\t// If weight tips above 50% percentile we found the target num\\n            if ((double) currentRunningWeight / (double) totalWeight >= 0.5) {\\n                numberToMinimizeTo = weightedNum.num;\\n                break;\\n            }\\n        }\\n\\n       final int number = numberToMinimizeTo;\\n       return weightedNums\\n               .stream()\\n               .filter(x -> x.num != number)\\n               .reduce(0L, (acc, weightedNum) -> acc + (long)Math.abs(weightedNum.num - number) * weightedNum.weight, Long::sum);\\n\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        List<WeightedNum> weightedNums = IntStream\\n                .range(0, nums.length)\\n                .boxed()\\n                .map(i -> new WeightedNum(nums[i], cost[i]))\\n                .sorted()\\n                .toList();\\n\\n        long totalWeight = 0;\\n        for (int weight : cost) totalWeight += weight;\\n\\t\\t\\n        long currentRunningWeight = 0L;\\n        int numberToMinimizeTo = 0;\\n        for (WeightedNum weightedNum : weightedNums) {\\n            currentRunningWeight += weightedNum.weight;\\n\\t\\t\\t\\n\\t\\t\\t// If weight tips above 50% percentile we found the target num\\n            if ((double) currentRunningWeight / (double) totalWeight >= 0.5) {\\n                numberToMinimizeTo = weightedNum.num;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2734878,
                "title": "c-mathematical-approach-o-nlogn-with-proof-explanations",
                "content": "**Proof**\\nnums = n1, n2\\ncost = c1, c2\\n\\nlet \\'x\\' be the optimal point.\\n\\nCase(i)\\nwhere all the elements of nums is greater than \\'x\\' i.e nums[i] > x for all 0 <= i < num.size()\\n\\nans = (y * c1) + (z * c2)\\nwhere n1 - y = x => y = n1 - x\\n  and n2 - z = x => z = n2 - x\\n\\nTherefore, ans = {(n1 - x) * c1} + {(n2 - x) * c2}\\n               = (n1 * c1) - (x * c1) + (n2 * c2) + (x * c2)\\n               = (n1 * c1) + (n2 * c2) + - {(c1 + c2) * x}\\n               = pro + (sum * x)\\n\\nwhere  pro = (n1 * c1) + (n2 * c2) + (n3 * c3) +.... till size of array\\n       sum = c1 + c2 + c3 + ....+ till size of array\\n\\n\\n\\nCase(ii):\\nwhen there exits some i such that nums[i] <= x for 0 <= i < nums.size()\\n\\nsuppose n1 < x\\nans = (y * c1) + (z * c2)\\nwhere n1 + y = x (as n1 < y)\\n\\t\\t=> y = x - n1\\n  and n2 - z = x => z = n2 - x\\n\\n\\nNow, ans = {(n1 - x) * c1} + {(n2 - x) * c2}\\nBut, we have to change the (n1 - x) to (x - n1) as (n1 < x)\\n\\nSupose we have to change a exp (a + b) to (a - b)\\nSo, (a + b) = (((a + b) - b) - b) = a - b\\ni.e we have to subtract b two times from given exp\\n\\nTherefore, ans = [{(n1 - x) * c1} - {(n1 - x) * c1} - {(n1 - x) * c1}] + {(n2 - x) * c2}\\n\\t\\t\\t\\t  = {{(n1 - x) * c1} - [2 * {(n1 - x) * c1}]} + {(n2 - x) * c2}\\n\\t\\t\\t\\t  = {(n1 - x) * c1} + {(n2 - x) * c2} - [2 * {(n1 - x) * c1}]\\n\\t\\t\\t\\t  = pro + (sum * x) - [2 * {currPro + (currSum + x)}]\\n\\nwhere  pro = (n1 * c1) + (n2 * c2) + (n3 * c3) +.... till size of array\\n       sum = c1 + c2 + c3 + ....+ till size of array\\n       currPro = (n1 * c1) + (n2 * c2) + ... till nums[i] <= x\\n       currSum = c1 + c2 + .... till nums[i] <= x\\n\\t   \\n**Implementation**\\nWe will store {nums[i], cost[i]} in vector of pairs to handle case(ii).\\nAnd we will sort it to find all nums[i] <= x \\n\\t   \\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n\\tlong long minCost(vector<int> &nums, vector<int> &cost) {\\n\\t\\tll n = nums.size(), range = 0, sum = 0, pro = 0;\\n\\t\\tvector <pair<int, int>> temp;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += cost[i];\\n\\t\\t\\tpro += (1ll * nums[i] * cost[i]);\\n\\t\\t\\trange = max(range, 1ll * nums[i]);\\n\\t\\t\\ttemp.push_back({nums[i], cost[i]});\\n\\t\\t} sort(temp.begin(), temp.end());\\n\\n\\t\\tll currSum = 0, currPro = 0, j = 0, ans = 1e18;\\n\\t\\tfor (int i = 0; i <= range; i++) {\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tif (j + 1 == n) break;\\n\\t\\t\\t\\telse if (temp[j].first > i) break;\\n\\t\\t\\t\\tcurrSum += temp[j].second;\\n\\t\\t\\t\\tcurrPro += (1ll * temp[j].first * temp[j].second);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tans = min(ans, (pro - (i * sum)) - (2 * (currPro - (i * currSum))));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n**Complexity**\\nTime Complexity: O(NlogN)\\nSpace Complexity: O(N)",
                "solutionTags": [
                    "C",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n\\tlong long minCost(vector<int> &nums, vector<int> &cost) {\\n\\t\\tll n = nums.size(), range = 0, sum = 0, pro = 0;\\n\\t\\tvector <pair<int, int>> temp;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tsum += cost[i];\\n\\t\\t\\tpro += (1ll * nums[i] * cost[i]);\\n\\t\\t\\trange = max(range, 1ll * nums[i]);\\n\\t\\t\\ttemp.push_back({nums[i], cost[i]});\\n\\t\\t} sort(temp.begin(), temp.end());\\n\\n\\t\\tll currSum = 0, currPro = 0, j = 0, ans = 1e18;\\n\\t\\tfor (int i = 0; i <= range; i++) {\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tif (j + 1 == n) break;\\n\\t\\t\\t\\telse if (temp[j].first > i) break;\\n\\t\\t\\t\\tcurrSum += temp[j].second;\\n\\t\\t\\t\\tcurrPro += (1ll * temp[j].first * temp[j].second);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tans = min(ans, (pro - (i * sum)) - (2 * (currPro - (i * currSum))));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734735,
                "title": "c-easy-explaination-prefix-proof",
                "content": "lets say the array is [a1,a2,a3,a4,a5] , we will pick a pivot **x** and then try to make each number equal to it, we will later prove that **x** is always a number in nums[i] for now assume **x=a3** and les the cost array be **c**\\n```\\n\\ncost = (x-a2)cost2  + (x-a1)cost1 + (a4-x) cost4 + (a5-x) cost5\\ncost = x( (cost1+cost2) -  (cost4+cost5) )  + ( (a4*cost4) - (a5*cost5) )\\n\\nso basically for each x we need sum of cost on left and right , lets call it simply cost\\nand sum of ai*costi on left and right  , lets call this simply mulcost\\n\\nNow we can simply create a prefix array for both and calculate while iterating for each x\\n```\\n\\n**Now comes the part why x is always an element in nums**\\nconsider 3 number **x,y,z** and **c=[cx,cy,cz]**\\nhere x and z are part of nums and y is the arbitrary pivot we chose between them \\n\\ncost = (y-x)cx + (z-y)*cy   and totdis = z-x\\nif(cx==cy)simply solve the above eq we get  **(z-x)cx** i.e y can be taken as either x or y\\nif(cx < cy) then  , **we can cover the dis (z-y)  with lesser cost cx** and therefore we we have less overall cost\\n\\n**Similarly while traversing for pivot we will have cost from left and right and we will use the lesser cost to shift pivot to  one of the elements of nums**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minCost(vector<int>& nums, vector<int>& c) {\\n        int n=nums.size();\\n        vector<pair<int,int> > v;\\n        for(int i=0;i<nums.size();i++) v.push_back({nums[i],c[i]});\\n        sort(v.begin(),v.end());\\n        \\n        vector<long long> pre1(n+1) , pre2(n+1);\\n        for(int i=0;i<n;i++){\\n            pre1[i+1] = pre1[i] + v[i].second;\\n            pre2[i+1] = pre2[i] + (long long)v[i].second *  v[i].first;\\n        }\\n        \\n        long long ans = 1e18;\\n        for(int i=0;i<n;i++){\\n            long long lcost = pre1[i] - pre1[0];\\n            long long rcost = pre1[n] - pre1[i+1];\\n            \\n            long long lmulcost = pre2[i] - pre2[0];\\n            long long rmulcost = pre2[n] - pre2[i+1];\\n            \\n            long long curr = v[i].first * (lcost - rcost) + (rmulcost - lmulcost);\\n            ans = min(ans,curr);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```\\n\\n\\n**before proving that pivot is one of the element of nums , i tried iterating all elements form 1 to 10^6 but got TLE**\\n```\\nclass Solution {\\npublic:\\n    int N = 1e6+1;\\n    long long minCost(vector<int>& nums, vector<int>& c) {\\n        int n=nums.size();\\n        vector<long long> cost(N+1) , mulCost(N+1);\\n        \\n        for(int i=0;i<n;i++){\\n            cost[nums[i]] += c[i];\\n            mulCost[nums[i]] += (long long)nums[i]*c[i];\\n        }\\n        \\n        vector<long long > pre1(N+1) ,  pre2(N+1);\\n        for(int i=0;i<N;i++){\\n            pre1[i+1] = pre1[i] + cost[i];\\n            pre2[i+1] = pre2[i] + mulCost[i];\\n        }\\n        \\n        long long ans = 1e18;\\n        \\n        for(int i=0;i<N;i++){\\n            \\n            //cost on left\\n            long long l = pre1[i] - pre1[1];\\n//             //cost on right \\n            long long r = pre1[N] - pre1[i+1];\\n            \\n//             //mulcost on left\\n            long long ml = pre2[i] - pre2[1];\\n            long long mr = pre2[N] - pre2[i+1];\\n            \\n            long long cur = i*(l - r)+  (mr-ml);\\n            ans = min(ans,cur);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\ncost = (x-a2)cost2  + (x-a1)cost1 + (a4-x) cost4 + (a5-x) cost5\\ncost = x( (cost1+cost2) -  (cost4+cost5) )  + ( (a4*cost4) - (a5*cost5) )\\n\\nso basically for each x we need sum of cost on left and right , lets call it simply cost\\nand sum of ai*costi on left and right  , lets call this simply mulcost\\n\\nNow we can simply create a prefix array for both and calculate while iterating for each x\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    long long minCost(vector<int>& nums, vector<int>& c) {\\n        int n=nums.size();\\n        vector<pair<int,int> > v;\\n        for(int i=0;i<nums.size();i++) v.push_back({nums[i],c[i]});\\n        sort(v.begin(),v.end());\\n        \\n        vector<long long> pre1(n+1) , pre2(n+1);\\n        for(int i=0;i<n;i++){\\n            pre1[i+1] = pre1[i] + v[i].second;\\n            pre2[i+1] = pre2[i] + (long long)v[i].second *  v[i].first;\\n        }\\n        \\n        long long ans = 1e18;\\n        for(int i=0;i<n;i++){\\n            long long lcost = pre1[i] - pre1[0];\\n            long long rcost = pre1[n] - pre1[i+1];\\n            \\n            long long lmulcost = pre2[i] - pre2[0];\\n            long long rmulcost = pre2[n] - pre2[i+1];\\n            \\n            long long curr = v[i].first * (lcost - rcost) + (rmulcost - lmulcost);\\n            ans = min(ans,curr);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int N = 1e6+1;\\n    long long minCost(vector<int>& nums, vector<int>& c) {\\n        int n=nums.size();\\n        vector<long long> cost(N+1) , mulCost(N+1);\\n        \\n        for(int i=0;i<n;i++){\\n            cost[nums[i]] += c[i];\\n            mulCost[nums[i]] += (long long)nums[i]*c[i];\\n        }\\n        \\n        vector<long long > pre1(N+1) ,  pre2(N+1);\\n        for(int i=0;i<N;i++){\\n            pre1[i+1] = pre1[i] + cost[i];\\n            pre2[i+1] = pre2[i] + mulCost[i];\\n        }\\n        \\n        long long ans = 1e18;\\n        \\n        for(int i=0;i<N;i++){\\n            \\n            //cost on left\\n            long long l = pre1[i] - pre1[1];\\n//             //cost on right \\n            long long r = pre1[N] - pre1[i+1];\\n            \\n//             //mulcost on left\\n            long long ml = pre2[i] - pre2[1];\\n            long long mr = pre2[N] - pre2[i+1];\\n            \\n            long long cur = i*(l - r)+  (mr-ml);\\n            ans = min(ans,cur);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734193,
                "title": "ternary-search-c",
                "content": "# Intuition\\nthe range is clearly a unimodular range\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int l = *min_element(nums.begin(),nums.end());\\n        int r = *max_element(nums.begin(),nums.end());\\n        long long ans = 1e18;\\n        while (r >= l) {\\n            long long mid1 = l + (r - l) / 3;\\n            long long mid2 = r - (r - l) / 3;\\n            \\n            long long a1 = 0, a2 = 0;\\n            \\n            for(int i=0;i<nums.size();i++){\\n                a1 += (abs(mid1 - nums[i]) * cost[i]);\\n                a2 += (abs(mid2 - nums[i]) * cost[i]);\\n            }\\n            \\n            if(a1 < a2) r = mid2-1;\\n            else l = mid1+1;\\n\\t\\t\\tans = min({ans,a1,a2});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int l = *min_element(nums.begin(),nums.end());\\n        int r = *max_element(nums.begin(),nums.end());\\n        long long ans = 1e18;\\n        while (r >= l) {\\n            long long mid1 = l + (r - l) / 3;\\n            long long mid2 = r - (r - l) / 3;\\n            \\n            long long a1 = 0, a2 = 0;\\n            \\n            for(int i=0;i<nums.size();i++){\\n                a1 += (abs(mid1 - nums[i]) * cost[i]);\\n                a2 += (abs(mid2 - nums[i]) * cost[i]);\\n            }\\n            \\n            if(a1 < a2) r = mid2-1;\\n            else l = mid1+1;\\n\\t\\t\\tans = min({ans,a1,a2});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734136,
                "title": "java-solution-with-ternary-search",
                "content": "```\\npublic long minCost(int arr[], int cos[]) {\\n\\tint low = Integer.MAX_VALUE;\\n\\tint high = Integer.MIN_VALUE;\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tlow = Integer.min(low, arr[i]);\\n\\t\\thigh = Integer.max(high, arr[i]);\\n\\t}\\n\\n\\twhile ((high - low) >= 3) {\\n\\t\\tint mid1 = low + (high - low) / 3;\\n\\t\\tint mid2 = high - (high - low) / 3;\\n\\t\\tif (computeCost(arr, cos, mid1) < computeCost(arr, cos, mid2)) {\\n\\t\\t\\thigh = mid2;\\n\\t\\t} else {\\n\\t\\t\\tlow = mid1;\\n\\t\\t}\\n\\t}\\n\\n\\tlong res = computeCost(arr, cos, low);\\n\\tfor (int i = low + 1; i <= high; i++) {\\n\\t\\tres = Long.min(res, computeCost(arr, cos, i));\\n\\t}\\n\\treturn res;\\n}\\n\\nlong computeCost(int arr[], int cos[], int X) {\\n\\tlong cost = 0;\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tcost += Math.abs(arr[i] - X) * ((long)cos[i]);\\n\\t}\\n\\treturn cost;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic long minCost(int arr[], int cos[]) {\\n\\tint low = Integer.MAX_VALUE;\\n\\tint high = Integer.MIN_VALUE;\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tlow = Integer.min(low, arr[i]);\\n\\t\\thigh = Integer.max(high, arr[i]);\\n\\t}\\n\\n\\twhile ((high - low) >= 3) {\\n\\t\\tint mid1 = low + (high - low) / 3;\\n\\t\\tint mid2 = high - (high - low) / 3;\\n\\t\\tif (computeCost(arr, cos, mid1) < computeCost(arr, cos, mid2)) {\\n\\t\\t\\thigh = mid2;\\n\\t\\t} else {\\n\\t\\t\\tlow = mid1;\\n\\t\\t}\\n\\t}\\n\\n\\tlong res = computeCost(arr, cos, low);\\n\\tfor (int i = low + 1; i <= high; i++) {\\n\\t\\tres = Long.min(res, computeCost(arr, cos, i));\\n\\t}\\n\\treturn res;\\n}\\n\\nlong computeCost(int arr[], int cos[], int X) {\\n\\tlong cost = 0;\\n\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\tcost += Math.abs(arr[i] - X) * ((long)cos[i]);\\n\\t}\\n\\treturn cost;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664792,
                "title": "binary-search-greedy-py",
                "content": "# Approach\\n<h3>Binary Search</h1>\\n\\n# Complexity\\n- Time complexity:\\n $$O(N log N)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n![](https://media.tenor.com/Jl0YrqxnHmAAAAAC/binary-search-sequence-search.gif)\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        ii,j=min(nums),max(nums)\\n        while ii<j:\\n            mid=(ii+j)//2\\n            total1,total2=0,0\\n            for i in range(len(nums)):\\n                total1+=abs(mid-nums[i])*cost[i]\\n                total2+=abs(mid+1-nums[i])*cost[i]\\n            if total1<total2:\\n                j=mid\\n            else:\\n                ii=mid+1\\n        ans=0\\n        for i in range(len(nums)):\\n            ans+=abs(ii-nums[i])*cost[i]\\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        ii,j=min(nums),max(nums)\\n        while ii<j:\\n            mid=(ii+j)//2\\n            total1,total2=0,0\\n            for i in range(len(nums)):\\n                total1+=abs(mid-nums[i])*cost[i]\\n                total2+=abs(mid+1-nums[i])*cost[i]\\n            if total1<total2:\\n                j=mid\\n            else:\\n                ii=mid+1\\n        ans=0\\n        for i in range(len(nums)):\\n            ans+=abs(ii-nums[i])*cost[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663976,
                "title": "java-solution-for-minimum-cost-to-make-array-equal-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to minimize the total cost required to make all elements of the nums array equal\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The solution starts by sorting the nums and cost arrays together based on the values in the nums array.\\n1. It then computes the prefix sum of the costs, creating an array prefixCost where prefixCost[i] represents the sum of costs from index 0 to i.\\n1. The initial total cost is calculated by considering every element except the first (nums[0]) as the target value and multiplying the cost of each element by the difference between its value and nums[0].\\n1. The minimum cost encountered so far is stored in the answer variable.\\n1. Next, the solution iterates from the second element (nums[1]) to the last element of nums.\\n1. For each iteration, it calculates the cost difference made by the change in two parts:\\n- The prefix sum of costs (prefixCost[i-1]) multiplied by the gap between the current element and the previous element (gap).\\n- The suffix sum of costs (prefixCost[n-1] - prefixCost[i-1]) multiplied by the same gap.\\n- It updates the total cost by adding the first part and subtracting the second part.\\n- The minimum cost (answer) is updated if a smaller cost is encountered.\\n1. Finally, the answer is returned, representing the minimum total cost to make all elements equal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n log n) due to the sorting step. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) for the additional arrays created (numsAndCost and prefixCost).\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        // Sort integers by values.\\n        int n = nums.length;\\n        int[][] numsAndCost = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            numsAndCost[i][0] = nums[i];\\n            numsAndCost[i][1] = cost[i];\\n        }\\n        Arrays.sort(numsAndCost, (a, b) -> a[0] - b[0]);\\n\\n        // Get the prefix sum array of the costs.\\n        long[] prefixCost = new long[n];\\n        prefixCost[0] = numsAndCost[0][1];\\n        for (int i = 1; i < n; ++i)\\n            prefixCost[i] = numsAndCost[i][1] + prefixCost[i - 1];\\n\\n        // Then we try every integer nums[i] and make every element equals nums[i],\\n        // Start with nums[0]\\n        long totalCost = 0l;\\n        for (int i = 1; i < n; ++i)\\n            totalCost += 1l * numsAndCost[i][1] * (numsAndCost[i][0] - numsAndCost[0][0]);\\n        long answer = totalCost;\\n        \\n        // Then we try nums[1], nums[2] and so on. The cost difference is made by the change of\\n        // two parts: 1. prefix sum of costs. 2. suffix sum of costs. \\n        // During the iteration, record the minimum cost we have met.\\n        for (int i = 1; i < n; ++i) {\\n            int gap = numsAndCost[i][0] - numsAndCost[i - 1][0];\\n            totalCost += 1l * prefixCost[i - 1] * gap;\\n            totalCost -= 1l * (prefixCost[n - 1] - prefixCost[i - 1]) * gap;\\n            answer = Math.min(answer, totalCost);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        // Sort integers by values.\\n        int n = nums.length;\\n        int[][] numsAndCost = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            numsAndCost[i][0] = nums[i];\\n            numsAndCost[i][1] = cost[i];\\n        }\\n        Arrays.sort(numsAndCost, (a, b) -> a[0] - b[0]);\\n\\n        // Get the prefix sum array of the costs.\\n        long[] prefixCost = new long[n];\\n        prefixCost[0] = numsAndCost[0][1];\\n        for (int i = 1; i < n; ++i)\\n            prefixCost[i] = numsAndCost[i][1] + prefixCost[i - 1];\\n\\n        // Then we try every integer nums[i] and make every element equals nums[i],\\n        // Start with nums[0]\\n        long totalCost = 0l;\\n        for (int i = 1; i < n; ++i)\\n            totalCost += 1l * numsAndCost[i][1] * (numsAndCost[i][0] - numsAndCost[0][0]);\\n        long answer = totalCost;\\n        \\n        // Then we try nums[1], nums[2] and so on. The cost difference is made by the change of\\n        // two parts: 1. prefix sum of costs. 2. suffix sum of costs. \\n        // During the iteration, record the minimum cost we have met.\\n        for (int i = 1; i < n; ++i) {\\n            int gap = numsAndCost[i][0] - numsAndCost[i - 1][0];\\n            totalCost += 1l * prefixCost[i - 1] * gap;\\n            totalCost -= 1l * (prefixCost[n - 1] - prefixCost[i - 1]) * gap;\\n            answer = Math.min(answer, totalCost);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663651,
                "title": "c-binary-search-o-n-logn",
                "content": "Just binary search on the possible values, for which when the whole array would be made equal to that value the cost should be minimum.\\nWe do this by comparing mid and mid+1 costs, if mid+1 is lesser, minCost is on right side, else minCost is on left side. Easy.\\n```\\nclass Solution {\\npublic:\\n    long long solveCost(vector<int>& nums, vector<int>& cost_arr, int x){\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            ans += (long)abs(nums[i]-x)*cost_arr[i];\\n        }\\n        return ans;\\n    } \\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        int start = 1, end = 1e6;\\n        long long y1,y2;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            y1 = solveCost(nums,cost,mid);\\n            y2 = solveCost(nums,cost,mid+1);\\n            if(y1>y2){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n        }\\n        return min(y1,y2);\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solveCost(vector<int>& nums, vector<int>& cost_arr, int x){\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            ans += (long)abs(nums[i]-x)*cost_arr[i];\\n        }\\n        return ans;\\n    } \\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        int start = 1, end = 1e6;\\n        long long y1,y2;\\n        while(start<end){\\n            int mid = start + (end-start)/2;\\n            y1 = solveCost(nums,cost,mid);\\n            y2 = solveCost(nums,cost,mid+1);\\n            if(y1>y2){\\n                start = mid+1;\\n            }\\n            else{\\n                end = mid;\\n            }\\n        }\\n        return min(y1,y2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663612,
                "title": "c-solutions-using-sort-binary-search-derivative-weighted-median",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nToday is Wednesday. Hard Wednesday!!!\\nLet me translate into the form what I can understand.\\nConsider the function\\n$$\\nf(x)=\\\\sum_i |nums[i]-x|cost[i]\\n$$\\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we provide several approaches. One is binary approach, other is using weighted median! The approach using derivative is also possible.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        \\n        // Create a vector of pairs to associate each number with its cost\\n        vector<pair<int, int>> numsWcost(n);\\n        for (int i = 0; i < n; i++)\\n            numsWcost[i] = { nums[i], cost[i] };\\n        \\n        // Sort the vector in ascending order based on the numbers\\n        sort(numsWcost.begin(), numsWcost.end(), less<>());\\n        \\n        // Define a lambda function to calculate the cost based on the target number\\n        function<long long(int)> f = [&](int x) {\\n            long long sum = 0LL;\\n            for (auto& [n, c] : numsWcost) {\\n                sum += llabs(n - x) * c; // Calculate the cost as absolute difference multiplied by the cost\\n            }\\n            return sum;\\n        };\\n        \\n        // Set the left and right boundaries for binary search\\n        int l = numsWcost[0].first; // First element in sorted numsWcost\\n        int r = numsWcost[n - 1].first; // Last element in sorted numsWcost\\n        \\n        // Handle a very extreme case where all numbers are the same\\n        if (l == r)\\n            return f(l);\\n        \\n        long long ans;\\n        // Perform binary search to find the minimum cost\\n        while (l < r) {\\n            int mid = (r + l) / 2; // Calculate the midpoint\\n            \\n            // Calculate the cost of choosing mid as the target number\\n            long long f1 = f(mid);\\n            \\n            // Calculate the cost of choosing mid+1 as the target number\\n            long long f2 = f(mid + 1);\\n            \\n            // Store the minimum cost between f1 and f2\\n            ans = min(f1, f2);\\n            \\n            if (f1 > f2)\\n                l = mid + 1; // Minimum cost lies to the right of mid\\n            else\\n                r = mid; // Minimum cost lies to the left of mid\\n        }\\n        \\n        // Return the minimum cost\\n        return ans;\\n    }\\n};\\n\\n```\\nIn addition, one can consider the following \"improper\" derivative Df.(f is not diffentiable at x $\\\\in\\\\{ nums[i]| i\\\\}$) When Df(x)=0 means f(x) attains its exrema, and when Df(x)>0 means f is ascending and when Df(x)<0 means f is descending. Df will change sign around the weighted median.\\n```\\n  function<long long(int)> Df=[&](int x)-> long long\\n        {\\n            long long sum=0LL;\\n            for(auto& [num, weight]: numsWcost){\\n                sum+=sgn(x-num)*weight;\\n            }\\n            return sum;\\n        };\\n```\\n# Code computing weighted median w/o binary search\\n```\\n        sort(numsWcost.begin(), numsWcost.end(), less<>());\\n\\n        function<int(void)> median=[&]()->int\\n        {\\n            long long total_cost=accumulate(cost.begin(), cost.end(), 0LL);\\n            long long sum=0LL;\\n            int ans;\\n            int i;\\n            for(i=0; i<n && sum<(total_cost+1)/2; i++){\\n                auto& [num, weight]=numsWcost[i];\\n                sum+=weight;\\n                ans=num;\\n            }\\n            return ans;\\n        };\\n        return f(median());\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        \\n        // Create a vector of pairs to associate each number with its cost\\n        vector<pair<int, int>> numsWcost(n);\\n        for (int i = 0; i < n; i++)\\n            numsWcost[i] = { nums[i], cost[i] };\\n        \\n        // Sort the vector in ascending order based on the numbers\\n        sort(numsWcost.begin(), numsWcost.end(), less<>());\\n        \\n        // Define a lambda function to calculate the cost based on the target number\\n        function<long long(int)> f = [&](int x) {\\n            long long sum = 0LL;\\n            for (auto& [n, c] : numsWcost) {\\n                sum += llabs(n - x) * c; // Calculate the cost as absolute difference multiplied by the cost\\n            }\\n            return sum;\\n        };\\n        \\n        // Set the left and right boundaries for binary search\\n        int l = numsWcost[0].first; // First element in sorted numsWcost\\n        int r = numsWcost[n - 1].first; // Last element in sorted numsWcost\\n        \\n        // Handle a very extreme case where all numbers are the same\\n        if (l == r)\\n            return f(l);\\n        \\n        long long ans;\\n        // Perform binary search to find the minimum cost\\n        while (l < r) {\\n            int mid = (r + l) / 2; // Calculate the midpoint\\n            \\n            // Calculate the cost of choosing mid as the target number\\n            long long f1 = f(mid);\\n            \\n            // Calculate the cost of choosing mid+1 as the target number\\n            long long f2 = f(mid + 1);\\n            \\n            // Store the minimum cost between f1 and f2\\n            ans = min(f1, f2);\\n            \\n            if (f1 > f2)\\n                l = mid + 1; // Minimum cost lies to the right of mid\\n            else\\n                r = mid; // Minimum cost lies to the left of mid\\n        }\\n        \\n        // Return the minimum cost\\n        return ans;\\n    }\\n};\\n\\n```\n```\\n  function<long long(int)> Df=[&](int x)-> long long\\n        {\\n            long long sum=0LL;\\n            for(auto& [num, weight]: numsWcost){\\n                sum+=sgn(x-num)*weight;\\n            }\\n            return sum;\\n        };\\n```\n```\\n        sort(numsWcost.begin(), numsWcost.end(), less<>());\\n\\n        function<int(void)> median=[&]()->int\\n        {\\n            long long total_cost=accumulate(cost.begin(), cost.end(), 0LL);\\n            long long sum=0LL;\\n            int ans;\\n            int i;\\n            for(i=0; i<n && sum<(total_cost+1)/2; i++){\\n                auto& [num, weight]=numsWcost[i];\\n                sum+=weight;\\n                ans=num;\\n            }\\n            return ans;\\n        };\\n        return f(median());\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558418,
                "title": "binary-search-c-easy-to-understand",
                "content": "solve for mid and mid+1 \\nans = min({ans,cost for mid, cost for mid+1});\\nif cost for mid > mid+1\\n    than mn = mid+1;\\nelse mx = mid-1;\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(1e6))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long mn = 0, mx = 1e6+2, mid,a,b,ans = LONG_LONG_MAX;\\n        int i, n = nums.size();\\n        while(mn <= mx){\\n            mid = (mx-mn)/2+mn;\\n            a = 0, b = 0;\\n            for(i = 0; i < n; i++){\\n                a += abs(mid-nums[i])*1LL*cost[i];\\n                b += abs(mid+1-nums[i])*1LL*cost[i];\\n            }\\n            ans = min({a,b,ans});\\n            if(b>a){\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long mn = 0, mx = 1e6+2, mid,a,b,ans = LONG_LONG_MAX;\\n        int i, n = nums.size();\\n        while(mn <= mx){\\n            mid = (mx-mn)/2+mn;\\n            a = 0, b = 0;\\n            for(i = 0; i < n; i++){\\n                a += abs(mid-nums[i])*1LL*cost[i];\\n                b += abs(mid+1-nums[i])*1LL*cost[i];\\n            }\\n            ans = min({a,b,ans});\\n            if(b>a){\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847458,
                "title": "c-finding-median",
                "content": "**Intution** *Using Fact that Minimum Cost will occur at Median*\\n**Approach** : \\nWe can modify the question by converting it as of single array where each element of nums[i] occurs costs[i] times in a sorted format :\\nLets say:\\n\\nnums array =[1,3,5,2]\\ncost array  =[2,3,1,4]\\nis equivalent to new array=[1,1,2,2,2,2,3,3,3,5]\\nNo: of elements in this array will be equal to \\u03A3 (costs[i]) for 0<=i< n\\nMedian will the middle index\\n\\n```\\n       long long total_cost(vector<int> &nums,vector<int> &costs,long long m,int n){ //Function For Finding cost\\n                long long res=0,f=0;\\n                for(int i=0;i<n;i++){\\n                        res+=abs(nums[i]-m)*costs[i];\\n                }\\n        return res;\\n        }\\n    long long minCost(vector<int>& nums, vector<int>& costs) {\\n           \\n            long long sum=0;\\n            for(auto &i:costs){\\n                  sum+=i;  \\n                    \\n            } // sum= total no of elements that will be there in the new array\\n           //we need element just the middle index so we need not to create the actual array\\n\\t\\t   //we will use prefix sum technique to find the middle element\\n\\t\\t   \\n            vector<pair<int,int>> arr;\\n            int n=nums.size();\\n            for(int i=0;i<n;i++){\\n                    arr.push_back({nums[i],costs[i]});\\n            }\\n            sort(arr.begin(),arr.end());\\n            long long cur_sum=0,median=0;\\n            int i=0;\\n            while(i<n && cur_sum<=sum/2){ \\n                    median=arr[i].first;\\n                    cur_sum+=arr[i].second;\\n\\t\\t\\t\\t\\ti++;\\n            }\\n\\t\\t\\t\\n            return total_cost(nums,costs,median,n);\\n            \\n    }\\n\\t```\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\n       long long total_cost(vector<int> &nums,vector<int> &costs,long long m,int n){ //Function For Finding cost\\n                long long res=0,f=0;\\n                for(int i=0;i<n;i++){\\n                        res+=abs(nums[i]-m)*costs[i];\\n                }\\n        return res;\\n        }\\n    long long minCost(vector<int>& nums, vector<int>& costs) {\\n           \\n            long long sum=0;\\n            for(auto &i:costs){\\n                  sum+=i;  \\n                    \\n            } // sum= total no of elements that will be there in the new array\\n           //we need element just the middle index so we need not to create the actual array\\n\\t\\t   //we will use prefix sum technique to find the middle element\\n\\t\\t   \\n            vector<pair<int,int>> arr;\\n            int n=nums.size();\\n            for(int i=0;i<n;i++){\\n                    arr.push_back({nums[i],costs[i]});\\n            }\\n            sort(arr.begin(),arr.end());\\n            long long cur_sum=0,median=0;\\n            int i=0;\\n            while(i<n && cur_sum<=sum/2){ \\n                    median=arr[i].first;\\n                    cur_sum+=arr[i].second;\\n\\t\\t\\t\\t\\ti++;\\n            }\\n\\t\\t\\t\\n            return total_cost(nums,costs,median,n);\\n            \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739074,
                "title": "python-3-solution-binary-search",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        \\n        def cost_el(l):\\n            c=0\\n            for i, x in enumerate(nums):\\n                c+=abs(l-x)*cost[i]\\n            return c\\n        \\n        best_c=float(inf)\\n        left=min(nums)\\n        right=max(nums)+1\\n        mid=(left+right)//2\\n        \\n        while left<right:\\n            if cost_el(mid)<cost_el(mid+1):\\n                right=mid\\n            else:\\n                left=mid+1\\n            mid=(left+right)//2\\n        \\n        for i in range(left, right+1):\\n            best_c=min(best_c, cost_el(i))\\n            \\n        return best_c\\n```\\n\\nIf my solution was helpful, rae it ;)",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        \\n        def cost_el(l):\\n            c=0\\n            for i, x in enumerate(nums):\\n                c+=abs(l-x)*cost[i]\\n            return c\\n        \\n        best_c=float(inf)\\n        left=min(nums)\\n        right=max(nums)+1\\n        mid=(left+right)//2\\n        \\n        while left<right:\\n            if cost_el(mid)<cost_el(mid+1):\\n                right=mid\\n            else:\\n                left=mid+1\\n            mid=(left+right)//2\\n        \\n        for i in range(left, right+1):\\n            best_c=min(best_c, cost_el(i))\\n            \\n        return best_c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734569,
                "title": "wrong-judge-in-javascript-bigint-result",
                "content": "I think my solution in correct, rewrite in java and AC https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/2734513/java-ternary-search-114ms/\\n\\nIn JS, one of the hidden case (... very long)\\n\\nthe answer is 11883552859682561. \\nmy answer console.log() result is 11883552859682561n, but LC result is 11883552859682560\\n\\nI think it is BigInt Judge issue same from here \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/1823867/problem-there-s-a-bigint-problem-with-javascript-updated-js-can-pass-now/\\n```\\nlet a, b, n;\\nconst minCost = (A, B) => {\\n    a = A, b = B, n = a.length;\\n    let low = Math.min(...a), high = Math.max(...a);\\n    while ((high - low) > 2) {\\n        let mid1 = low + parseInt((high - low) / 3);\\n        let mid2 = high - parseInt((high - low) / 3);\\n        let cost1 = computeCost(mid1);\\n        let cost2 = computeCost(mid2);\\n        if (cost1 < cost2) {\\n            high = mid2;\\n        } else {\\n            low = mid1;\\n        }\\n    }\\n    let res = 10n ** 19n;\\n    for (let v = low; v <= high; v++) {\\n        let ct = computeCost(v);\\n        if (ct < res) res = ct;\\n    }\\n    // console.log(res);\\n    return res;\\n};\\n\\nconst ll = BigInt;\\nconst computeCost = (v) => {\\n    let res = 0n;\\n    for (let i = 0; i < n; i++) res += ll(Math.abs(a[i] - v)) * ll(b[i]);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet a, b, n;\\nconst minCost = (A, B) => {\\n    a = A, b = B, n = a.length;\\n    let low = Math.min(...a), high = Math.max(...a);\\n    while ((high - low) > 2) {\\n        let mid1 = low + parseInt((high - low) / 3);\\n        let mid2 = high - parseInt((high - low) / 3);\\n        let cost1 = computeCost(mid1);\\n        let cost2 = computeCost(mid2);\\n        if (cost1 < cost2) {\\n            high = mid2;\\n        } else {\\n            low = mid1;\\n        }\\n    }\\n    let res = 10n ** 19n;\\n    for (let v = low; v <= high; v++) {\\n        let ct = computeCost(v);\\n        if (ct < res) res = ct;\\n    }\\n    // console.log(res);\\n    return res;\\n};\\n\\nconst ll = BigInt;\\nconst computeCost = (v) => {\\n    let res = 0n;\\n    for (let i = 0; i < n; i++) res += ll(Math.abs(a[i] - v)) * ll(b[i]);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734555,
                "title": "c-binary-search-o-nlogn-easy-explained",
                "content": "The cost can only lie between the maximum and the minimum elmenent of the array and we are trying to find the element using binary search.\\n\\nApproach - Find the cost of converting every element to a certain element mid.\\nThere can be 3 scenarios then\\n1. If mid is the answer then its immediate cost to convert array to its immediate left and immediate right will be greater.\\n2. If the cost of converting either left or right is lesser than we should try to move in that direction for the answer.\\n```\\nclass Solution {\\npublic:\\n    \\n    long long find_cost(vector<int>& nums, vector<int>& cost, int ele)\\n    {\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            long long a = abs(nums[i] - ele);\\n            ans = ans + (a * cost[i]);\\n        }\\n            \\n        return ans;\\n    }\\n    \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int minele = INT_MAX, mxele = INT_MIN;\\n        for(auto i:nums)\\n        {\\n            minele = min(minele, i);\\n            mxele = max(mxele, i);\\n        }\\n        long long ans = LLONG_MAX;\\n        while(minele <= mxele)\\n        {\\n            int mid = minele + (mxele - minele) / 2;\\n            long long temp = find_cost(nums, cost, mid);\\n            ans = min(ans, temp);\\n            long long r = find_cost(nums, cost, mid+1);\\n            long long l = find_cost(nums, cost, mid-1);\\n            // If mid is less than both it\\'s immediate neighbours than it is the answer.\\n            if(temp < l && temp < r)\\n                return ans;\\n\\t\\t\\t// Shifting mid corresponding to the smallest possible answer.\\n            else if(temp < l && temp > r) // \\n                minele = mid+1;\\n            else\\n                mxele = mid-1;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long find_cost(vector<int>& nums, vector<int>& cost, int ele)\\n    {\\n        long long ans = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            long long a = abs(nums[i] - ele);\\n            ans = ans + (a * cost[i]);\\n        }\\n            \\n        return ans;\\n    }\\n    \\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int minele = INT_MAX, mxele = INT_MIN;\\n        for(auto i:nums)\\n        {\\n            minele = min(minele, i);\\n            mxele = max(mxele, i);\\n        }\\n        long long ans = LLONG_MAX;\\n        while(minele <= mxele)\\n        {\\n            int mid = minele + (mxele - minele) / 2;\\n            long long temp = find_cost(nums, cost, mid);\\n            ans = min(ans, temp);\\n            long long r = find_cost(nums, cost, mid+1);\\n            long long l = find_cost(nums, cost, mid-1);\\n            // If mid is less than both it\\'s immediate neighbours than it is the answer.\\n            if(temp < l && temp < r)\\n                return ans;\\n\\t\\t\\t// Shifting mid corresponding to the smallest possible answer.\\n            else if(temp < l && temp > r) // \\n                minele = mid+1;\\n            else\\n                mxele = mid-1;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734479,
                "title": "python-simple-solution-easy-to-understand-explanation-binary-search-o-n-log-n",
                "content": "Approach:\\nThe value to which every element has to be made equal to, lies in the range <b> [min(nums), max(nums)] </b>\\n(because the cost of each operation is a positve number)\\n\\nTo find this value we can use binary search from the minimum values in nums to the maximum value.\\nAt every step we can find the mid and calculate the cost of making every element equal to mid.\\n\\n<b> But now we have a problem, where do we continue to search?? (i.e. should we search in the lower or the upper half)???\\n\\nTo solve this issue we can calculate the cost of using the value (mid + 1)\\n\\tif this cost is lesser than the original cost then we should continue searching in the upper half or else in the lower half.\\n\\n\\n```\\nclass Solution(object):\\n    def minCost(self, nums, cost):\\n\\t\\t#function to return the cost of making array elements equal to value curr\\n        def costof(curr):\\n            val = 0\\n            val2 = 0\\n            for i in range(n):\\n                val += abs(nums[i] - curr) * cost[i] # this stores the cost of making array elements equal to value curr\\n                val2 += abs(nums[i] - (curr + 1)) * cost[i] #this stores the cost of  making array elements equal to value curr + 1\\n\\t\\t\\t\\t\\n\\t\\t\\t#return the cost of using mid and also return wheather the cost of using (mid + 1) is smaller.\\n            return val, val2 < val\\n        \\n        lo = min(nums)\\n        hi = max(nums)\\n        n = len(nums)\\n        \\n        ans = None\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            t = costof(mid)\\n            ans = min(ans, t[0]) if ans is not None else t[0]\\n            \\n            if t[1]: # search in upper half because cost of (mid + 1) < cost of (mid)\\n                lo = mid + 1\\n            else: # otherwise search in lower half\\n                hi = mid - 1\\n                \\n        return ans\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "Approach:\\nThe value to which every element has to be made equal to, lies in the range <b> [min(nums), max(nums)] </b>\\n(because the cost of each operation is a positve number)\\n\\nTo find this value we can use binary search from the minimum values in nums to the maximum value.\\nAt every step we can find the mid and calculate the cost of making every element equal to mid.\\n\\n<b> But now we have a problem, where do we continue to search?? (i.e. should we search in the lower or the upper half)???\\n\\nTo solve this issue we can calculate the cost of using the value (mid + 1)\\n\\tif this cost is lesser than the original cost then we should continue searching in the upper half or else in the lower half.\\n\\n\\n```\\nclass Solution(object):\\n    def minCost(self, nums, cost):\\n\\t\\t#function to return the cost of making array elements equal to value curr\\n        def costof(curr):\\n            val = 0\\n            val2 = 0\\n            for i in range(n):\\n                val += abs(nums[i] - curr) * cost[i] # this stores the cost of making array elements equal to value curr\\n                val2 += abs(nums[i] - (curr + 1)) * cost[i] #this stores the cost of  making array elements equal to value curr + 1\\n\\t\\t\\t\\t\\n\\t\\t\\t#return the cost of using mid and also return wheather the cost of using (mid + 1) is smaller.\\n            return val, val2 < val\\n        \\n        lo = min(nums)\\n        hi = max(nums)\\n        n = len(nums)\\n        \\n        ans = None\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            t = costof(mid)\\n            ans = min(ans, t[0]) if ans is not None else t[0]\\n            \\n            if t[1]: # search in upper half because cost of (mid + 1) < cost of (mid)\\n                lo = mid + 1\\n            else: # otherwise search in lower half\\n                hi = mid - 1\\n                \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2734391,
                "title": "clean-c-solution-with-sorting-dp-o-n-log-n",
                "content": "## Minimum Cost to Make Array Equal\\n\\nAnother version of this problem where no costs are involved is to make all elements of the array equal to the median. You can find the problem [here](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/).\\n\\nThe approach here is to choose a candidate element and try making every element equal to that candidate element. Since there are `n` candidate elements to choose from, the time complexity of naively implementing this solution is **O(n^2)**, which is too slow for the given constraints. It is also worth noting that the candidate elements must only be the elements from the array since the optimal solution will not involve changing elements to some value that was not already in the array (proof is left as an exercise).\\n\\nWe can optimise the quadratic time complexity though by making use of prefix and suffix sums. The solution idea is as follows:\\n\\n- Sort the arrays based on the `nums[i]` in non-decreasing order.\\n- Calculate the cost of making all elements equal to nums[0]. Let this be `dp[0]` (`dp[i]` is the cost to make all elements equal to `nums[i]`).\\n- When calculating `nums[i]` (i > 0), we can reuse the computation made for `nums[i - 1]`. The cost from `dp[i - 1]` decreases by `(nums[i] - nums[i - 1]) * suffix_sum_of_costs` and increases by `(nums[i] - nums[i - 1]) * prefix_sum_of_costs`.\\n\\n**C++ Solution**\\n\\n```cpp\\nlong long minCost (vector <int>& nums, vector <int>& cost) {\\n  int n = nums.size();\\n  std::vector <int> order (n);\\n  std::vector <int64_t> dp (n);\\n  \\n  std::iota(order.begin(), order.end(), 0);\\n  std::sort(order.begin(), order.end(), [&] (int i, int j) {\\n    return nums[i] < nums[j];\\n  });\\n  \\n  int64_t left = cost[order[0]], right = 0;\\n  \\n  for (int i = 1, o = order[0]; i < n; ++i) {\\n    int j = order[i];\\n    dp[o] += int64_t(nums[j] - nums[o]) * cost[j];\\n    right += cost[j];\\n  }\\n  \\n  for (int i = 1; i < n; ++i) {\\n    int j = order[i];\\n    int k = order[i - 1];\\n    int64_t diff = nums[j] - nums[k];\\n    \\n    dp[j] = dp[k] - diff * right + diff * left;\\n    left += cost[j];\\n    right -= cost[j];\\n  }\\n  \\n  return *std::min_element(dp.begin(), dp.end());\\n}\\n```\\n\\nYou don\\'t really need the DP array in there and can maintain the cost and minimum using two variables.\\n\\nTime Complexity: **O(n.log(n))**\\nSpace Complexity: **O(n) or O(1)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```cpp\\nlong long minCost (vector <int>& nums, vector <int>& cost) {\\n  int n = nums.size();\\n  std::vector <int> order (n);\\n  std::vector <int64_t> dp (n);\\n  \\n  std::iota(order.begin(), order.end(), 0);\\n  std::sort(order.begin(), order.end(), [&] (int i, int j) {\\n    return nums[i] < nums[j];\\n  });\\n  \\n  int64_t left = cost[order[0]], right = 0;\\n  \\n  for (int i = 1, o = order[0]; i < n; ++i) {\\n    int j = order[i];\\n    dp[o] += int64_t(nums[j] - nums[o]) * cost[j];\\n    right += cost[j];\\n  }\\n  \\n  for (int i = 1; i < n; ++i) {\\n    int j = order[i];\\n    int k = order[i - 1];\\n    int64_t diff = nums[j] - nums[k];\\n    \\n    dp[j] = dp[k] - diff * right + diff * left;\\n    left += cost[j];\\n    right -= cost[j];\\n  }\\n  \\n  return *std::min_element(dp.begin(), dp.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734303,
                "title": "easy-solution-in-java-100-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic long check(int mid,int[] arr,int[] cost){\\n    \\n    long sum=0;\\n        \\n     for(int i=0;i<arr.length;i++){\\n         sum+= 1l* Math.abs(mid-arr[i])*cost[i];\\n     }       \\n     return sum;\\n}\\n\\n    public long minCost(int[] nums, int[] cost) {\\n        int l=0,r=1000000;\\n        while(l<=r){\\n       int mid= (l+r)/2;\\n         long p1=check(mid-1,nums,cost);\\n        long p2=check(mid,nums,cost);\\n        long p3= check(mid+1,nums,cost);\\n       if(p1>=p2 && p3>=p2){\\n           return p2;\\n       }\\n        else if(p1<p2){\\n             r= (mid-1);\\n        }\\n         else  \\n          l=(mid+1);\\n    }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic long check(int mid,int[] arr,int[] cost){\\n    \\n    long sum=0;\\n        \\n     for(int i=0;i<arr.length;i++){\\n         sum+= 1l* Math.abs(mid-arr[i])*cost[i];\\n     }       \\n     return sum;\\n}\\n\\n    public long minCost(int[] nums, int[] cost) {\\n        int l=0,r=1000000;\\n        while(l<=r){\\n       int mid= (l+r)/2;\\n         long p1=check(mid-1,nums,cost);\\n        long p2=check(mid,nums,cost);\\n        long p3= check(mid+1,nums,cost);\\n       if(p1>=p2 && p3>=p2){\\n           return p2;\\n       }\\n        else if(p1<p2){\\n             r= (mid-1);\\n        }\\n         else  \\n          l=(mid+1);\\n    }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734226,
                "title": "python-binary-search-with-better-naming-conversion",
                "content": "\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n\\n        @cache\\n        def guess(x):\\n            \\n            return sum([abs(n-x) * c for n, c in zip(nums, cost)])\\n        \\n        n_min, n_max = min(nums), max(nums)\\n\\n        if guess(n_min) < guess(n_min+1):\\n            return guess(n_min)\\n\\n        if guess(n_max) < guess(n_max-1):\\n            return guess(n_max)\\n        \\n        left, right  = n_min + 1, n_max -1\\n\\n        while left <= right:\\n            \\n            mid = left + (right-left)//2\\n                       \\n            if guess(mid) <= guess(mid+1) and guess(mid) <= guess(mid-1):\\n                \\n                return guess(mid)\\n            \\n            if guess(mid) <= guess(mid+1) and guess(mid) >= guess(mid-1):\\n                \\n                right = mid - 1\\n            else:\\n                left = mid +1\\n        \\n        return 0\\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n\\n        @cache\\n        def guess(x):\\n            \\n            return sum([abs(n-x) * c for n, c in zip(nums, cost)])\\n        \\n        n_min, n_max = min(nums), max(nums)\\n\\n        if guess(n_min) < guess(n_min+1):\\n            return guess(n_min)\\n\\n        if guess(n_max) < guess(n_max-1):\\n            return guess(n_max)\\n        \\n        left, right  = n_min + 1, n_max -1\\n\\n        while left <= right:\\n            \\n            mid = left + (right-left)//2\\n                       \\n            if guess(mid) <= guess(mid+1) and guess(mid) <= guess(mid-1):\\n                \\n                return guess(mid)\\n            \\n            if guess(mid) <= guess(mid+1) and guess(mid) >= guess(mid-1):\\n                \\n                right = mid - 1\\n            else:\\n                left = mid +1\\n        \\n        return 0\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721128,
                "title": "java-solution-binary-search-approach-with-comments",
                "content": "# Approach\\nShown in Comments.\\n\\n# Complexity\\n- Time complexity: $$O(n logn)$$\\n\\n- Space complexity: $$O(1)$$ or $$constant$$\\n\\n# Code\\n```\\nclass Solution {\\n    // Questions specify\\'s that we have to make all array elements equal, it doesn\\'t mean we have to make them equal\\n    // to the elements that are in the array. So we can make them equal to any number just all elements should be equal\\n    \\n    // Binary Sum Approach\\n    public long minCost(int[] nums, int[] cost) {\\n        // Approach:- We will take the maximum and minimum value from the nums Array\\n        // we will check the mid value and mid - 1 or mid + 1 value to make all of them equal with their cost.\\n        // we store the min cost as our answer and will eliminate the side whose cost is higher as we do in Binary S.\\n\\n        long ans = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : nums){\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            \\n            long cost1 = helper(nums, cost, mid);\\n            long cost2 = helper(nums, cost, mid - 1);\\n            ans = Math.min(cost1, cost2);\\n\\n            if(cost1 < cost2){\\n                min = mid + 1;\\n            }else{\\n                max = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public long helper(int[] nums, int[] cost, int mid){\\n        long currCost = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            currCost += (long) Math.abs(nums[i] - mid) * cost[i];\\n        }\\n        return currCost;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    // Questions specify\\'s that we have to make all array elements equal, it doesn\\'t mean we have to make them equal\\n    // to the elements that are in the array. So we can make them equal to any number just all elements should be equal\\n    \\n    // Binary Sum Approach\\n    public long minCost(int[] nums, int[] cost) {\\n        // Approach:- We will take the maximum and minimum value from the nums Array\\n        // we will check the mid value and mid - 1 or mid + 1 value to make all of them equal with their cost.\\n        // we store the min cost as our answer and will eliminate the side whose cost is higher as we do in Binary S.\\n\\n        long ans = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : nums){\\n            min = Math.min(min, i);\\n            max = Math.max(max, i);\\n        }\\n\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            \\n            long cost1 = helper(nums, cost, mid);\\n            long cost2 = helper(nums, cost, mid - 1);\\n            ans = Math.min(cost1, cost2);\\n\\n            if(cost1 < cost2){\\n                min = mid + 1;\\n            }else{\\n                max = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public long helper(int[] nums, int[] cost, int mid){\\n        long currCost = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            currCost += (long) Math.abs(nums[i] - mid) * cost[i];\\n        }\\n        return currCost;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667209,
                "title": "java-solution-beats-98-9-best-solution-using-binary-search-full-explanation",
                "content": "# Intution :\\nwe have nums = [1,3,5,2]\\n        cost = [2,3,1,14]\\nHere, l = 1 and r=5\\nso mid = 3\\ncost1 = (2*2+2*1+1*14)=20\\ncost2 for mid+1  so mid =4 \\ncost2 =(3*2+1*3+1*1+2*14)=38\\nas cost1 < cost2 here that means we can find the less cost in the left side so we will assign r=mid=3 and l=1\\nso new mid = 2\\nnow cost1 = (1*2+1*3+2*1)=8\\nnow cos2 for (2+1=3) is 20\\nas cost1<cost2  again so r=mid=2 and l=1\\nso new mid is 1\\ncost1=(2*3+4*1+1*14)=38\\ncost2 for mid=(1+1=2) is 8\\nNow as cost2>cost1 so l=mid+1=2 and r=2\\nas now l=r therefore ans=2\\n\\n# Approach\\n1. Firstly find the lowest and the greatest elemnt of an array \\nnamed lowest as l and greates elemnt as r. \\n2. Now use the binary seacrh in this while l is less than r firstly find the mid of the array.\\n3. Then find two costs cost1 and cost2 ehich is calculates by the methid take a mid value and then subtract it from all the elemnts of nums array and multiply it with cost at same index and add it in total cost from this method we can find the total cost of the solution.\\n4. cost1 find cost for mid \\n5. where as cost2 will find total cost for mid+1\\n6. Now we have cost1 and cost2 if cost1 is greater than cost2 which means that in right side we can find the lesser cost so we will asign l as mid+1 and ans as cost1 for now.\\n7. And if cost1 is less than cost2 it means we can find the less cost in the right side so we will asign r as mid here and ans as cost2 for now.\\n8. From this method we will be able to find the answer.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\n0(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n    int n = nums.length;\\n       \\n       int l = Integer.MAX_VALUE;\\n       int r = Integer.MIN_VALUE;\\n       for(int i=0;i<nums.length;i++){\\n           if(l>nums[i]){\\n               l=nums[i];\\n           }\\n\\n       }\\n       for(int i=0;i<nums.length;i++){\\n           if(r<nums[i]){\\n               r=nums[i];\\n           }\\n\\n       }\\n        \\n       long ans=0;\\n       while(l<r){\\n           int mid = (l+r)/2;\\n           long cost1 = helper(nums,cost,mid);\\n           long cost2= helper(nums,cost,mid+1);\\n           if(cost1>cost2){\\n               l=mid+1;\\n               ans=cost2;\\n           }\\n           else{\\n               r=mid;\\n               ans=cost1;\\n           }\\n\\n\\n       }\\n       return ans;\\n\\n    }\\n    public long helper(int nums[],int cost[],int mid){\\n        long tc=0L;\\n        for(int i=0;i<nums.length;i++){\\n            tc+=1L*Math.abs(nums[i]-mid)*cost[i];\\n        }\\n        return tc;\\n\\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/9fca51f3-38b2-4aaa-80ba-0fd8afca6cc1_1687417895.762119.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n    int n = nums.length;\\n       \\n       int l = Integer.MAX_VALUE;\\n       int r = Integer.MIN_VALUE;\\n       for(int i=0;i<nums.length;i++){\\n           if(l>nums[i]){\\n               l=nums[i];\\n           }\\n\\n       }\\n       for(int i=0;i<nums.length;i++){\\n           if(r<nums[i]){\\n               r=nums[i];\\n           }\\n\\n       }\\n        \\n       long ans=0;\\n       while(l<r){\\n           int mid = (l+r)/2;\\n           long cost1 = helper(nums,cost,mid);\\n           long cost2= helper(nums,cost,mid+1);\\n           if(cost1>cost2){\\n               l=mid+1;\\n               ans=cost2;\\n           }\\n           else{\\n               r=mid;\\n               ans=cost1;\\n           }\\n\\n\\n       }\\n       return ans;\\n\\n    }\\n    public long helper(int nums[],int cost[],int mid){\\n        long tc=0L;\\n        for(int i=0;i<nums.length;i++){\\n            tc+=1L*Math.abs(nums[i]-mid)*cost[i];\\n        }\\n        return tc;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667040,
                "title": "beats-97-python3-weighted-midpoint-solution-with-explanation-o-nlogn",
                "content": "# Approach\\n**Create pairs:** We create a list of pairs, where each pair consists of a number from the nums list and its corresponding cost from the cost list. This is done by iterating over the indices of the nums list and appending tuples of (nums[i], cost[i]) to the pairs list.\\n\\n**Sort pairs:** The pairs list is then sorted in ascending order based on the numbers. Sorting is performed to ensure that when calculating the minimum cost, the numbers are considered in increasing order.\\n\\n**Calculate the midpoint of costs:** The average cost (cost_mid) is calculated by summing up all the costs in the cost list and dividing by 2. This midpoint will be used as a threshold to determine the target number for calculating the minimum cost.\\n\\n**Calculate the target number:** A loop iterates over the sorted pairs. It starts accumulating the costs (cost_tmp) and checks if the accumulated cost has exceeded or reached the midpoint (cost_mid). Once the midpoint is reached or exceeded, the current number (num) is assigned to the variable i, and the loop is broken. This target number i will be used to calculate the minimum cost.\\n\\n**Calculate the minimum cost:** Another loop iterates over the sorted pairs. For each pair, it calculates the absolute difference between the number (num) and the target number (i), and multiplies it by the corresponding cost. These values are summed up in the min_cost variable to obtain the minimum cost based on the target number i.\\n\\n**Return the minimum cost:** The final result, min_cost is returned as the output of the code.\\n\\n# Complexity\\n- Time complexity: **O(nlogn)** dominated by sort operation\\n\\n- Space complexity: **O(n)** as pairs list takes len(nums) space\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        pairs = []\\n        for i in range(len(nums)):\\n            pairs.append((nums[i], cost[i]))\\n\\n        pairs.sort()\\n        cost_mid = sum(cost) / 2\\n        cost_tmp = 0\\n\\n        for num, cost in pairs:\\n            cost_tmp += cost\\n            if cost_tmp >= cost_mid:\\n                i = num\\n                break\\n\\n        min_cost = 0\\n        for num, cost in pairs:\\n            min_cost += abs(num - i) * cost\\n\\n        return min_cost\\n```\\n\\n**Please do Upvote if you found this helpful!**",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        pairs = []\\n        for i in range(len(nums)):\\n            pairs.append((nums[i], cost[i]))\\n\\n        pairs.sort()\\n        cost_mid = sum(cost) / 2\\n        cost_tmp = 0\\n\\n        for num, cost in pairs:\\n            cost_tmp += cost\\n            if cost_tmp >= cost_mid:\\n                i = num\\n                break\\n\\n        min_cost = 0\\n        for num, cost in pairs:\\n            min_cost += abs(num - i) * cost\\n\\n        return min_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666910,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution Approach 1](https://leetcode.com/problems/minimum-cost-to-make-array-equal/editorial/) but written functionally.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n\\n- Space complexity: $$O(n * log(n))$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minCost(self, nums: list[int], cost: list[int]) -> int:\\n        n = len(nums)\\n        sort_order = itemgetter(*sorted(range(n), key=nums.__getitem__))\\n        \\n        s_nums = sort_order(nums)\\n        s_cost = sort_order(cost)\\n        prefix_cost = tuple(accumulate(s_cost))\\n\\n        init_cost = sum(map(mul, s_nums, s_cost)) - s_nums[0] * prefix_cost[n - 1]\\n        get_next_cost = lambda a, i: a + (s_nums[i] - s_nums[i - 1]) * (2 * prefix_cost[i - 1] - prefix_cost[n - 1])\\n        return min(accumulate(range(1, n), get_next_cost, initial=init_cost))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def minCost(self, nums: list[int], cost: list[int]) -> int:\\n        n = len(nums)\\n        sort_order = itemgetter(*sorted(range(n), key=nums.__getitem__))\\n        \\n        s_nums = sort_order(nums)\\n        s_cost = sort_order(cost)\\n        prefix_cost = tuple(accumulate(s_cost))\\n\\n        init_cost = sum(map(mul, s_nums, s_cost)) - s_nums[0] * prefix_cost[n - 1]\\n        get_next_cost = lambda a, i: a + (s_nums[i] - s_nums[i - 1]) * (2 * prefix_cost[i - 1] - prefix_cost[n - 1])\\n        return min(accumulate(range(1, n), get_next_cost, initial=init_cost))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665326,
                "title": "c-simple-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long calculate(vector<int> &nums, vector<int> &cost, int median){\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            ans+=abs(1ll*(nums[i]-median))*cost[i];\\n        }\\n        return ans;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long n=nums.size();\\n        vector<pair<long long, long long> > vp;\\n        for(int i=0; i<n; i++){\\n            vp.push_back({nums[i], cost[i]});\\n        }\\n        sort(vp.begin(), vp.end());\\n\\n        long long frequency=0, tmp=0, i=0, median;\\n        for(auto &it: vp){\\n            frequency+=it.second;\\n        }\\n        while(i<n and tmp<((frequency+1)/2)){\\n            tmp+=vp[i].second;\\n            median=vp[i].first;\\n            i++;\\n        }\\n        return calculate(nums, cost, median);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long calculate(vector<int> &nums, vector<int> &cost, int median){\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            ans+=abs(1ll*(nums[i]-median))*cost[i];\\n        }\\n        return ans;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long n=nums.size();\\n        vector<pair<long long, long long> > vp;\\n        for(int i=0; i<n; i++){\\n            vp.push_back({nums[i], cost[i]});\\n        }\\n        sort(vp.begin(), vp.end());\\n\\n        long long frequency=0, tmp=0, i=0, median;\\n        for(auto &it: vp){\\n            frequency+=it.second;\\n        }\\n        while(i<n and tmp<((frequency+1)/2)){\\n            tmp+=vp[i].second;\\n            median=vp[i].first;\\n            i++;\\n        }\\n        return calculate(nums, cost, median);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664875,
                "title": "short-simple-crisp-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsorting + prefix sum of cost array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minCost = function(nums, cost) {\\n     \\n    const n = nums.length;\\n    if(n<=1) return 0;\\n    let arr = [];\\n    for(let i=0;i<n;i++) arr[i] = [nums[i],cost[i]];\\n    arr.sort((a,b)=>a[0]-b[0]);\\n    let psum = [arr[0][1]];\\n    for(let i=1;i<n;i++) psum.push(psum[i-1]+arr[i][1]);\\n    let sum = 0;\\n    for(let i=1;i<n;i++){\\n        sum+= (Math.abs(arr[i][0]-arr[0][0]))*arr[i][1];\\n    }\\n    let ans=Infinity;\\n    ans=Math.min(ans,sum);\\n    for(let i=1;i<n;i++){\\n        sum+=(psum[i-1])*(arr[i][0]-arr[i-1][0]);\\n        sum-=(psum[n-1]-psum[i-1])*(arr[i][0]-arr[i-1][0]);\\n        ans=Math.min(ans,sum);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minCost = function(nums, cost) {\\n     \\n    const n = nums.length;\\n    if(n<=1) return 0;\\n    let arr = [];\\n    for(let i=0;i<n;i++) arr[i] = [nums[i],cost[i]];\\n    arr.sort((a,b)=>a[0]-b[0]);\\n    let psum = [arr[0][1]];\\n    for(let i=1;i<n;i++) psum.push(psum[i-1]+arr[i][1]);\\n    let sum = 0;\\n    for(let i=1;i<n;i++){\\n        sum+= (Math.abs(arr[i][0]-arr[0][0]))*arr[i][1];\\n    }\\n    let ans=Infinity;\\n    ans=Math.min(ans,sum);\\n    for(let i=1;i<n;i++){\\n        sum+=(psum[i-1])*(arr[i][0]-arr[i-1][0]);\\n        sum-=(psum[n-1]-psum[i-1])*(arr[i][0]-arr[i-1][0]);\\n        ans=Math.min(ans,sum);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664169,
                "title": "swift-one-solution-to-have-them-all-weighted-median-prefix-sum-two-pointers-binary-ternary-search",
                "content": "[TOC]\\n\\n# Weighted median\\n\\n[Weighted median](https://en.wikipedia.org/wiki/Weighted_median)\\n\\n- Time complexity: $O(n\\\\cdot\\\\log n)$, mainly for sorting\\n- Space complexity: $O(n)$, for sorted array\\n\\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        let numCosts: [NumCost] = zip(nums, costs).sorted() { $0.0 < $1.0 } // sorted by num, ascending\\n        let costsSumHalved = (costs.reduce(0, +) + 1) / 2\\n        \\n        var cost = 0, median = 0\\n        for nc in numCosts {\\n            if cost < costsSumHalved { median = nc.num } else { break }\\n            cost += nc.cost\\n        }\\n        return numCosts.reduce(0) { moves, nc in moves + abs(nc.num - median) * nc.cost }\\n    }\\n}\\n```\\n\\n# Prefix sum\\n\\n- Time complexity: $O(n\\\\cdot\\\\log k)$\\n- Space complexity: $O(n)$\\n$k$ is the difference between the maximal and minimal nums values\\n\\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        let numCosts: [NumCost] = zip(nums, costs).sorted() { $0.0 < $1.0 } // sorted by num, ascending\\n        \\n        // sum of costs in order of increasing num\\n        var costsPrefixSum: [Int] = [0]\\n        for nc in numCosts { costsPrefixSum.append(costsPrefixSum.last! + nc.cost) }\\n\\n        let minNum = numCosts.first!.num, maxNum = numCosts.last!.num\\n        if minNum == maxNum { return 0 }\\n\\n        var totalCost = numCosts.reduce(0) { sum, nc in sum + (nc.num - minNum) * nc.cost }\\n        var minTotalCost = totalCost\\n\\n        var prefixInd = 0\\n        for num in (minNum+1)...maxNum\\n        {\\n            while numCosts[prefixInd].num < num { prefixInd += 1 }\\n            // totalCost -= (costsPrefixSum.last! - costsPrefixSum[prefixInd])\\n            // totalCost += costsPrefixSum[prefixInd]\\n            totalCost += 2 * costsPrefixSum[prefixInd] - costsPrefixSum.last!\\n            minTotalCost = min(totalCost, minTotalCost)\\n        }\\n        return minTotalCost\\n    }\\n}\\n```\\n\\n# Two Pointers\\n\\nWe are accumulating costs of bringing low numbers up and high numbers down to the target value. As the numbers are sorted, we run two pointers from the beginning on one side and the end on the other, until we meet in the middle. \\n\\nConceptually it works similarly to the prefix sum approach, but instead of iterating over the array each time, we build the total cost per side as we go, at each transition to the next num. We greedily grow whichever side is cheapest, so we end up meeting in the middle at the minimum total cost.\\n\\nBased on [this](https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664261/python-o-n-log-n-time-o-n-space-two-pointers-beats-97-5-for-time/) solution by [DennisJohnsonDevOps](/DennisJohnsonDevOps). Check it out, that\\'s a really elaborate explanation there.\\n\\n- Time complexity: $O(n\\\\cdot\\\\log n)$, mainly for sorting\\n- Space complexity: $O(n)$, just for sorted array\\n\\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        let numCosts: [NumCost] = zip(nums, costs).sorted() { $0.0 < $1.0 } // sorted by num, ascending\\n        var leftIndex = 0, rightIndex = nums.count - 1\\n        var leftAccumulatedCost = numCosts.first!.cost, rightAccumulatedCost = numCosts.last!.cost\\n        var leftTotalCost = 0, rightTotalCost = 0\\n\\n        var numsDiff: Int\\n        while leftIndex < rightIndex\\n        { \\n            if leftAccumulatedCost < rightAccumulatedCost\\n            {\\n                numsDiff = numCosts[leftIndex + 1].num - numCosts[leftIndex].num\\n                leftTotalCost += numsDiff * leftAccumulatedCost\\n                leftAccumulatedCost += numCosts[leftIndex + 1].cost\\n                leftIndex += 1\\n            }\\n            else\\n            {\\n                numsDiff = numCosts[rightIndex].num - numCosts[rightIndex - 1].num\\n                rightTotalCost += numsDiff * rightAccumulatedCost\\n                rightAccumulatedCost += numCosts[rightIndex - 1].cost               \\n                rightIndex -= 1                \\n            }\\n        }        \\n        return leftTotalCost + rightTotalCost\\n    }\\n}\\n``` \\n\\n# Binary Search\\n\\n- Time complexity: $O(n\\\\cdot\\\\log k)$\\n- Space complexity: $O(1)$\\n$k$ is the difference between the maximal and minimal nums values\\n\\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        var minNum = Int.max, maxNum = Int.min\\n        for num in nums { minNum = min(num, minNum); maxNum = max(num, maxNum) }\\n        if minNum == maxNum { return 0 }\\n\\n        func totalCost(_ num: Int) -> Int {\\n            nums.indices.reduce(0){ sum, i in sum + abs(nums[i] - num) * costs[i]}\\n        }\\n\\n        var minVal = minNum, maxVal = maxNum, checkVal = 0\\n        var cost1 = 0, cost2 = 0\\n        while minVal <  maxVal\\n        {\\n            checkVal = (minVal + maxVal) / 2\\n            cost1 = totalCost(checkVal)\\n            cost2 = totalCost(checkVal+1)\\n\\n            if cost1 > cost2 {\\n                minVal = checkVal + 1\\n            }\\n            else {\\n                maxVal = checkVal\\n            }\\n        }\\n        return totalCost(minVal)\\n    }\\n}\\n```\\n\\n# Ternary Search\\n\\n- Time complexity: $O(n\\\\cdot\\\\log n)$\\n- Space complexity: $O(n)$\\n\\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        let numCosts: [NumCost] = zip(nums, costs).sorted() { $0.0 < $1.0 } // sorted by num, ascending\\n      \\n        let minNum = numCosts.first!.num, maxNum = numCosts.last!.num\\n        if minNum == maxNum { return 0 }\\n\\n        var memo: [Int:Int] = [:]\\n        func totalCost(_ num: Int) -> Int\\n        {\\n            if let res = memo[num] { return res }            \\n            let res = numCosts.reduce(0){ sum, nc in sum + abs(nc.num - num) * nc.cost}\\n            memo[num] = res\\n            return res\\n        }\\n\\n        var minTotalCost = 0\\n\\n        var minIndex = 0, maxIndex = numCosts.count - 1\\n        var checkIndex1 = 0, checkIndex2 = 0, dist = 0\\n        var num1 = 0, num2 = 0, cost1 = 0, cost2 = 0\\n        while true // ternary search\\n        {\\n            dist = (maxIndex - minIndex) / 3\\n            if dist == 0\\n            {   // final 3 or less elements\\n                let totalCosts = (minIndex...maxIndex).map{totalCost(numCosts[$0].num)}\\n                minTotalCost = totalCosts.min()!; break\\n            }\\n\\n            checkIndex1 = minIndex + dist\\n            checkIndex2 = maxIndex - dist\\n            num1 = numCosts[checkIndex1].num\\n            num2 = numCosts[checkIndex2].num\\n            cost1 = totalCost(num1)\\n            cost2 = totalCost(num2)\\n\\n            if cost1 > cost2 {\\n                minIndex = checkIndex1\\n            }\\n            else {\\n                maxIndex = checkIndex2\\n            }\\n        }\\n        return minTotalCost\\n    }\\n}\\n```\\nBy the way, if we change 3 to 2.618 this way\\n```\\ndist = Int(Double(maxIndex - minIndex) / 2.618)\\n```\\nit will become [Golden section search](https://en.wikipedia.org/wiki/Golden-section_search)",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Binary Search",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        let numCosts: [NumCost] = zip(nums, costs).sorted() { $0.0 < $1.0 } // sorted by num, ascending\\n        let costsSumHalved = (costs.reduce(0, +) + 1) / 2\\n        \\n        var cost = 0, median = 0\\n        for nc in numCosts {\\n            if cost < costsSumHalved { median = nc.num } else { break }\\n            cost += nc.cost\\n        }\\n        return numCosts.reduce(0) { moves, nc in moves + abs(nc.num - median) * nc.cost }\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        let numCosts: [NumCost] = zip(nums, costs).sorted() { $0.0 < $1.0 } // sorted by num, ascending\\n        \\n        // sum of costs in order of increasing num\\n        var costsPrefixSum: [Int] = [0]\\n        for nc in numCosts { costsPrefixSum.append(costsPrefixSum.last! + nc.cost) }\\n\\n        let minNum = numCosts.first!.num, maxNum = numCosts.last!.num\\n        if minNum == maxNum { return 0 }\\n\\n        var totalCost = numCosts.reduce(0) { sum, nc in sum + (nc.num - minNum) * nc.cost }\\n        var minTotalCost = totalCost\\n\\n        var prefixInd = 0\\n        for num in (minNum+1)...maxNum\\n        {\\n            while numCosts[prefixInd].num < num { prefixInd += 1 }\\n            // totalCost -= (costsPrefixSum.last! - costsPrefixSum[prefixInd])\\n            // totalCost += costsPrefixSum[prefixInd]\\n            totalCost += 2 * costsPrefixSum[prefixInd] - costsPrefixSum.last!\\n            minTotalCost = min(totalCost, minTotalCost)\\n        }\\n        return minTotalCost\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        let numCosts: [NumCost] = zip(nums, costs).sorted() { $0.0 < $1.0 } // sorted by num, ascending\\n        var leftIndex = 0, rightIndex = nums.count - 1\\n        var leftAccumulatedCost = numCosts.first!.cost, rightAccumulatedCost = numCosts.last!.cost\\n        var leftTotalCost = 0, rightTotalCost = 0\\n\\n        var numsDiff: Int\\n        while leftIndex < rightIndex\\n        { \\n            if leftAccumulatedCost < rightAccumulatedCost\\n            {\\n                numsDiff = numCosts[leftIndex + 1].num - numCosts[leftIndex].num\\n                leftTotalCost += numsDiff * leftAccumulatedCost\\n                leftAccumulatedCost += numCosts[leftIndex + 1].cost\\n                leftIndex += 1\\n            }\\n            else\\n            {\\n                numsDiff = numCosts[rightIndex].num - numCosts[rightIndex - 1].num\\n                rightTotalCost += numsDiff * rightAccumulatedCost\\n                rightAccumulatedCost += numCosts[rightIndex - 1].cost               \\n                rightIndex -= 1                \\n            }\\n        }        \\n        return leftTotalCost + rightTotalCost\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        var minNum = Int.max, maxNum = Int.min\\n        for num in nums { minNum = min(num, minNum); maxNum = max(num, maxNum) }\\n        if minNum == maxNum { return 0 }\\n\\n        func totalCost(_ num: Int) -> Int {\\n            nums.indices.reduce(0){ sum, i in sum + abs(nums[i] - num) * costs[i]}\\n        }\\n\\n        var minVal = minNum, maxVal = maxNum, checkVal = 0\\n        var cost1 = 0, cost2 = 0\\n        while minVal <  maxVal\\n        {\\n            checkVal = (minVal + maxVal) / 2\\n            cost1 = totalCost(checkVal)\\n            cost2 = totalCost(checkVal+1)\\n\\n            if cost1 > cost2 {\\n                minVal = checkVal + 1\\n            }\\n            else {\\n                maxVal = checkVal\\n            }\\n        }\\n        return totalCost(minVal)\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    typealias NumCost = (num: Int, cost: Int)\\n    func minCost(_ nums: [Int], _ costs: [Int]) -> Int\\n    {\\n        let numCosts: [NumCost] = zip(nums, costs).sorted() { $0.0 < $1.0 } // sorted by num, ascending\\n      \\n        let minNum = numCosts.first!.num, maxNum = numCosts.last!.num\\n        if minNum == maxNum { return 0 }\\n\\n        var memo: [Int:Int] = [:]\\n        func totalCost(_ num: Int) -> Int\\n        {\\n            if let res = memo[num] { return res }            \\n            let res = numCosts.reduce(0){ sum, nc in sum + abs(nc.num - num) * nc.cost}\\n            memo[num] = res\\n            return res\\n        }\\n\\n        var minTotalCost = 0\\n\\n        var minIndex = 0, maxIndex = numCosts.count - 1\\n        var checkIndex1 = 0, checkIndex2 = 0, dist = 0\\n        var num1 = 0, num2 = 0, cost1 = 0, cost2 = 0\\n        while true // ternary search\\n        {\\n            dist = (maxIndex - minIndex) / 3\\n            if dist == 0\\n            {   // final 3 or less elements\\n                let totalCosts = (minIndex...maxIndex).map{totalCost(numCosts[$0].num)}\\n                minTotalCost = totalCosts.min()!; break\\n            }\\n\\n            checkIndex1 = minIndex + dist\\n            checkIndex2 = maxIndex - dist\\n            num1 = numCosts[checkIndex1].num\\n            num2 = numCosts[checkIndex2].num\\n            cost1 = totalCost(num1)\\n            cost2 = totalCost(num2)\\n\\n            if cost1 > cost2 {\\n                minIndex = checkIndex1\\n            }\\n            else {\\n                maxIndex = checkIndex2\\n            }\\n        }\\n        return minTotalCost\\n    }\\n}\\n```\n```\\ndist = Int(Double(maxIndex - minIndex) / 2.618)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663969,
                "title": "minimum-cost-to-make-array-equal-easy-c-solution",
                "content": "Well, it is a binary search on the answer. Still, unlike the predicate function where the answer is unlike the pattern TTTFFF or FFFTTT, it\\'s more likely to be FFFTFFF(also depends on the value), and the graph has one global minimum when plotted against various values. So, we do BS on the answer. \\nWe call two times for a single value of m(i.e. m and m+1); if (ans[m]<=ans[m+1]), it means that the value will increase for the bigger value of m, so we change r=m-1 else it will decrease for the bigger value of m, and we change l to m+1.\\nThe calc function is pretty straightforward; it just calculates the total cost for any random value of m and returns the total sum.\\nAt last, we can have two values(l or l-1, r or r+1, yes you can choose both l or r, it doesn\\'t matter), and the answer is the minimum of these values.\\n\\nI hope you get the solution; if any doubts, you can ask here!\\n```\\nclass Solution {\\npublic:\\n    long long calc(int cur, vector<int>& nums, vector<int>& cost) {\\n        long long ans=0,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            ans+=1LL*abs(cur-nums[i])*1LL*cost[i];\\n        }\\n        return ans;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long l=0,r=1e6,n=nums.size(),ans;\\n        while(l<=r) {\\n            int m=(l+r)/2;\\n            long long a1=calc(m,nums,cost), a2=calc(m+1,nums,cost);\\n            if(a1<=a2) {\\n                r=m-1;\\n            }\\n            else {\\n                l=m+1;\\n            }\\n        }\\n        long long a1=calc(l,nums,cost), a2=calc(l-1,nums,cost);\\n        return min(a1,a2);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    long long calc(int cur, vector<int>& nums, vector<int>& cost) {\\n        long long ans=0,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            ans+=1LL*abs(cur-nums[i])*1LL*cost[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3663799,
                "title": "c-day-21-solution",
                "content": "# Code\\n```\\nstruct Solution {\\n    long long minCost(vector<int>& a, vector<int>& c) {\\n        int n = (int) a.size();\\n        vector<pair<int, int>> b(n);\\n        for (int i = 0; i < n; i++) {\\n            b[i] = make_pair(a[i], c[i]);\\n        }\\n        sort(b.begin(), b.end());\\n        long long ans = (long long) 1e18;\\n        vector<long long> x(n), y(n);\\n        long long sum = 0, t = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0) {\\n                sum += t * (b[i].first - b[i - 1].first);\\n            }\\n            x[i] = sum;\\n            t += b[i].second;\\n        }\\n        sum = t = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (i < n - 1) {\\n                sum += t * (b[i + 1].first - b[i].first);\\n            }\\n            y[i] = sum;\\n            t += b[i].second;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans = min(ans, x[i] + y[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Solution {\\n    long long minCost(vector<int>& a, vector<int>& c) {\\n        int n = (int) a.size();\\n        vector<pair<int, int>> b(n);\\n        for (int i = 0; i < n; i++) {\\n            b[i] = make_pair(a[i], c[i]);\\n        }\\n        sort(b.begin(), b.end());\\n        long long ans = (long long) 1e18;\\n        vector<long long> x(n), y(n);\\n        long long sum = 0, t = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (i > 0) {\\n                sum += t * (b[i].first - b[i - 1].first);\\n            }\\n            x[i] = sum;\\n            t += b[i].second;\\n        }\\n        sum = t = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (i < n - 1) {\\n                sum += t * (b[i + 1].first - b[i].first);\\n            }\\n            y[i] = sum;\\n            t += b[i].second;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            ans = min(ans, x[i] + y[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663677,
                "title": "python-binary-search-2-liner-1-liner",
                "content": "# Intuition\\nIf we try to calculate the cost of any value from min(nums) to max(nums), we see that the cost starts high, goes down to a minimum, and then goes up again. For example, for nums = `[1,3,5,2]` and cost = `[2,3,1,14]`, the cost for any value from 1 (min of nums) to 5 (max of nums) is `[24,8,20,38,56]`.\\n\\nTo find the minimum, simply binary search for the first number whose next number is larger than itself.\\n\\n# Full\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        def total(target):\\n            return sum(abs(target - n) * c for n, c in zip(nums, cost))\\n        \\n        lo, hi = min(nums), max(nums)\\n\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if total(mid) < total(mid + 1):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        \\n        return total(lo)\\n\\n```\\n\\n# 2-liner\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        total = lambda target: sum(abs(target - n) * c for n, c in zip(nums, cost))\\n        return total(min(nums) + bisect_left(range(min(nums), max(nums)), True, key=lambda n: total(n) < total(n + 1)))\\n\\n```\\n\\n# Dumb long 1-liner\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        return (f := lambda target: sum(abs(target - n) * c for n, c in zip(nums, cost)))(min(nums) + bisect_left(range(min(nums), max(nums)), True, key=lambda n: f(n) < f(n + 1)))\\n\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        def total(target):\\n            return sum(abs(target - n) * c for n, c in zip(nums, cost))\\n        \\n        lo, hi = min(nums), max(nums)\\n\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if total(mid) < total(mid + 1):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        \\n        return total(lo)\\n\\n```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        total = lambda target: sum(abs(target - n) * c for n, c in zip(nums, cost))\\n        return total(min(nums) + bisect_left(range(min(nums), max(nums)), True, key=lambda n: total(n) < total(n + 1)))\\n\\n```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        return (f := lambda target: sum(abs(target - n) * c for n, c in zip(nums, cost)))(min(nums) + bisect_left(range(min(nums), max(nums)), True, key=lambda n: f(n) < f(n + 1)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663615,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        pairs=sorted(list(zip(nums,cost)))\\n        cost_mid=sum(cost)/2\\n        cost_tmp=0\\n        for n,c in pairs:\\n            cost_tmp+=c\\n            if cost_tmp>=cost_mid:\\n                f=n\\n                break\\n\\n        min_total_cost=0\\n        for n,c in pairs:\\n            min_total_cost+=abs(n-f)*c\\n\\n        return min_total_cost                  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        pairs=sorted(list(zip(nums,cost)))\\n        cost_mid=sum(cost)/2\\n        cost_tmp=0\\n        for n,c in pairs:\\n            cost_tmp+=c\\n            if cost_tmp>=cost_mid:\\n                f=n\\n                break\\n\\n        min_total_cost=0\\n        for n,c in pairs:\\n            min_total_cost+=abs(n-f)*c\\n\\n        return min_total_cost                  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128288,
                "title": "java-solution-sorting-median-value-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider cost array as frequency array for the nums. We will find the median index in a sorted array. We will make every number in the array equals to the median indexed number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider this Example\\n$$nums = [1,3,5,2]$$\\n$$cost = [2,3,1,14]$$\\n\\nConsider the cost as frequecies of the numbers\\nnow array will look like after sorting.\\n$$arr = [1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,5]$$\\n$$median  = 10$$ \\nnow $$arr[median] = 2$$\\nwe will make every element of this array, equal to $$arr[median] = 2$$\\n\\nNote: For sorting, I am storing a number-cost pair value in an array and sorting the array by the number.\\n\\nExplanation:\\nWe choose every number one by one and make the whole array equals to that choosen number by either decreasing 1 or increasing 1 and will find out the cost.\\nfor $$1$$, cost = $$(1-1)*2 + (2-1)*14 + (3-1)*3 + (5-1)*1 = 24$$\\nfor $$2$$, cost = $$abs(1-2)*2 + (2-2)*14 + (3-2)*3 + (5-2)*1 = 8$$\\nfor $$3$$, cost =$$ abs(1-3)*2 + abs(2-3)*14 + (3-3)*3 + (5-3)*1 = 20$$\\nfor $$5$$, cost = $$abs(1-5)*2 + abs(2-5)*14 + abs(3-5)*3 + (5-5)*1 = 56$$\\n\\nNow you will observe that min cost will always be for the median number if numbers are in sorted order.\\n\\nSo, Answer will be $$8$$.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int n = nums.length;\\n        int[][] numCostPair = new int[n][2];\\n        for(int i = 0; i<n; i++) {\\n            numCostPair[i][0] = nums[i];\\n            numCostPair[i][1] = cost[i];\\n        }\\n        Arrays.sort(numCostPair, (a, b) -> a[0] - b[0]);\\n        // allCost will be the length of the array with frequencies included for each number.\\n        long allCost = 0;\\n        for(int c: cost) {\\n            allCost += c;\\n        }\\n        // median index should be\\n        long median = (allCost + allCost%2)/2;\\n        int j = 0;\\n        //finding the median index in the num-cost pair array.\\n        while(median > 0 && j < n) {\\n            median -= numCostPair[j][1];\\n            j++;\\n        }\\n        //found the median index.\\n        int index = j-1;\\n        //finding the answer for median index\\n        long ans = 0;\\n        for(int i = 0; i<n; i++) {\\n            ans += (long)numCostPair[i][1]*Math.abs(numCostPair[i][0]-numCostPair[index][0]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int n = nums.length;\\n        int[][] numCostPair = new int[n][2];\\n        for(int i = 0; i<n; i++) {\\n            numCostPair[i][0] = nums[i];\\n            numCostPair[i][1] = cost[i];\\n        }\\n        Arrays.sort(numCostPair, (a, b) -> a[0] - b[0]);\\n        // allCost will be the length of the array with frequencies included for each number.\\n        long allCost = 0;\\n        for(int c: cost) {\\n            allCost += c;\\n        }\\n        // median index should be\\n        long median = (allCost + allCost%2)/2;\\n        int j = 0;\\n        //finding the median index in the num-cost pair array.\\n        while(median > 0 && j < n) {\\n            median -= numCostPair[j][1];\\n            j++;\\n        }\\n        //found the median index.\\n        int index = j-1;\\n        //finding the answer for median index\\n        long ans = 0;\\n        for(int i = 0; i<n; i++) {\\n            ans += (long)numCostPair[i][1]*Math.abs(numCostPair[i][0]-numCostPair[index][0]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966098,
                "title": "javascript-sort-median-6-lines-of-code-without-using-bigint",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nvar minCost = function(nums, cost) {\\n   nums = nums.map((num, i) => [num, cost[i]])\\n       .sort(([b], [a]) => b - a);\\n\\n   let prefixCost = 0;\\n   const costSum = cost.reduce((acc, cur) => acc + cur);\\n   const [median] = nums.find(([_, cost]) => (prefixCost += cost) >= costSum / 2);\\n    \\n   return nums\\n        .reduce((acc, [num, cost]) => acc + Math.abs(num - median) * cost, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nvar minCost = function(nums, cost) {\\n   nums = nums.map((num, i) => [num, cost[i]])\\n       .sort(([b], [a]) => b - a);\\n\\n   let prefixCost = 0;\\n   const costSum = cost.reduce((acc, cur) => acc + cur);\\n   const [median] = nums.find(([_, cost]) => (prefixCost += cost) >= costSum / 2);\\n    \\n   return nums\\n        .reduce((acc, [num, cost]) => acc + Math.abs(num - median) * cost, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2892922,
                "title": "easy-way-minimum-cost-to-make-array-equal",
                "content": "\\n\\n# Approach\\nBy using weighted median \\n\\n# Complexity\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        vector<pair<long long,long long>>v;\\n        int n=cost.size();\\n        for(int i=0; i<n; i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long sum=0,total=0;\\n        for(int i=0; i<n; i++){\\n            sum+=v[i].second;\\n        }\\n        long long median;\\n        int i=0;\\n        while(total<(sum+1)/2 and i<n){\\n            total+=v[i].second;\\n            median=v[i].first;\\n            i++;\\n        }\\n       long long ans=0;\\n       for(int i=0; i<nums.size(); i++){\\n           ans+=(abs(nums[i]-median))*cost[i];\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        vector<pair<long long,long long>>v;\\n        int n=cost.size();\\n        for(int i=0; i<n; i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long sum=0,total=0;\\n        for(int i=0; i<n; i++){\\n            sum+=v[i].second;\\n        }\\n        long long median;\\n        int i=0;\\n        while(total<(sum+1)/2 and i<n){\\n            total+=v[i].second;\\n            median=v[i].first;\\n            i++;\\n        }\\n       long long ans=0;\\n       for(int i=0; i<nums.size(); i++){\\n           ans+=(abs(nums[i]-median))*cost[i];\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742382,
                "title": "c-fast-solution-binary-search",
                "content": "**Please upvote if my solution was helpful ;)**\\n```\\npublic class Solution {\\n    public long MinCost(int[] nums, int[] cost) {\\n        \\n        int l = nums.Min();\\n        int r = nums.Max();\\n        long minsum = long.MaxValue;\\n        \\n        while( r - l > 2){\\n           \\n            int mediuml = l + (r - l)/3;\\n            int mediumr = r - (r - l)/3;\\n            if( CountCost(nums, cost, mediuml) > CountCost(nums, cost, mediumr) )\\n\\t\\t\\t{\\n               l = mediuml;\\n            } else{\\n               r = mediumr;\\n            }\\n        }\\n        for(int i = l; i <= r; i++){\\n            \\n            minsum = Math.Min(minsum, CountCost(nums, cost, i) );\\n        }\\n        \\n        return minsum;\\n    }\\n    \\n    public long CountCost(int[] nums, int[] cost, long dest){\\n        \\n            long sum = 0;\\n        \\n            for(int i = 0; i < nums.Length; i++){\\n                sum += (long) Math.Abs(dest-nums[i]) * cost[i]; \\n            }\\n            \\n            return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinCost(int[] nums, int[] cost) {\\n        \\n        int l = nums.Min();\\n        int r = nums.Max();\\n        long minsum = long.MaxValue;\\n        \\n        while( r - l > 2){\\n           \\n            int mediuml = l + (r - l)/3;\\n            int mediumr = r - (r - l)/3;\\n            if( CountCost(nums, cost, mediuml) > CountCost(nums, cost, mediumr) )\\n\\t\\t\\t{\\n               l = mediuml;\\n            } else{\\n               r = mediumr;\\n            }\\n        }\\n        for(int i = l; i <= r; i++){\\n            \\n            minsum = Math.Min(minsum, CountCost(nums, cost, i) );\\n        }\\n        \\n        return minsum;\\n    }\\n    \\n    public long CountCost(int[] nums, int[] cost, long dest){\\n        \\n            long sum = 0;\\n        \\n            for(int i = 0; i < nums.Length; i++){\\n                sum += (long) Math.Abs(dest-nums[i]) * cost[i]; \\n            }\\n            \\n            return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742276,
                "title": "easy-to-understand-c",
                "content": "The whole concept of this question is to find the middle element of nums. Middle element is the element in the nums like if we change all elements of our nums array into middle element then it would take minimum cost and our array elements will be equal that we want. so first of all we have to find the middle element then we gonna calculate minimum cost easily.\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n          long long n = nums.size(),sum=0;\\n         vector<pair<long long,long long>>mp;\\n\\t\\t //First of all treat cost[i] as a frequencies of nums[i] and store it in to a vector.\\n        for(int i=0;i<n;i++){\\n            mp.push_back({nums[i],cost[i]});  \\n        } \\n        sort(mp.begin(),mp.end()); // Sort our vector\\n        for(auto it:mp){\\n            sum = sum +   (it.second); // Sum up total frequencies of all elements.\\n        }\\n   // Here we can also use binary search to find the middle element but I am using linear search here to find the middle element just because it\\'s simple to use.\\n       long long mid = sum/2 ,temp=0,ans=0;\\n       for(auto it:mp){\\n              mid= mid -   it.second;\\n               temp = it.first; // Temp is our middle element.\\n            if(mid<=0) break;\\n       }\\n        // Now we have to make all elements of the nums is equal to temp . If we make all elements of nums to be temp then it would take minimum cost to make array equal.   \\n        for(auto it:mp){\\n            ans = ans + (abs(  it.first - temp)*   it.second); \\n        }\\n         \\n        return ans;\\n    }\\n};\\n//Do a dry run once it would be more clear.\\n```\\nSimilar Question to practice - https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/(This one is so simple).\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n          long long n = nums.size(),sum=0;\\n         vector<pair<long long,long long>>mp;\\n\\t\\t //First of all treat cost[i] as a frequencies of nums[i] and store it in to a vector.\\n        for(int i=0;i<n;i++){\\n            mp.push_back({nums[i],cost[i]});  \\n        } \\n        sort(mp.begin(),mp.end()); // Sort our vector\\n        for(auto it:mp){\\n            sum = sum +   (it.second); // Sum up total frequencies of all elements.\\n        }\\n   // Here we can also use binary search to find the middle element but I am using linear search here to find the middle element just because it\\'s simple to use.\\n       long long mid = sum/2 ,temp=0,ans=0;\\n       for(auto it:mp){\\n              mid= mid -   it.second;\\n               temp = it.first; // Temp is our middle element.\\n            if(mid<=0) break;\\n       }\\n        // Now we have to make all elements of the nums is equal to temp . If we make all elements of nums to be temp then it would take minimum cost to make array equal.   \\n        for(auto it:mp){\\n            ans = ans + (abs(  it.first - temp)*   it.second); \\n        }\\n         \\n        return ans;\\n    }\\n};\\n//Do a dry run once it would be more clear.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735653,
                "title": "ternary-search-with-java",
                "content": "I solved with ternary search. As for a single integer (lets say, it is **x**), the answer will be minimum. \\n\\nThe more x will be decreased, cost to make the array of that element will be increased. Also,\\nThe more x will be increased, cost to make the array of that element will be increased. \\n\\nSuppose, the array is {3, 5, 7, 4}, if we make all elements to 4 then the cost will be minimized. If we increase or decrease x (here x = 4), cost will be increased. \\n\\nI am adding a graph for the element of the array vs cost to make the array of that element. Here, I have showed the cost to make all the element to x = 1 to 8.\\n\\n![image](https://assets.leetcode.com/users/images/a70ebe6e-728f-45cd-b9dc-0b63cad76f9f_1666523775.1109471.png)\\n\\nWhen we search such **x** (here x = 4), that can be solved by ternary search. Taht\\'s why I used this technique here. My solution is: \\n\\n\\n```\\npublic long minCost(int[] nums, int[] cost) {\\n\\tint low = 1;\\n\\tint high = (int) 1e6;\\n\\tlong ret = Long.MAX_VALUE;\\n\\tint i = 1;\\n\\twhile (i<=50) {\\n\\t\\tint mid1 = low + (high - low)/3;\\n\\t\\tint mid2 = high - (high - low)/3;\\n\\t\\tlong costs1 = getCost(mid1, nums, cost);\\n\\t\\tlong costs2 = getCost(mid2, nums, cost);\\n\\t\\tif (costs1 < costs2) {\\n\\t\\t\\thigh = mid2 - 1;\\n\\t\\t\\tret = Long.min(ret, costs1);\\n\\t\\t} else if (costs1 > costs2){\\n\\t\\t\\tlow = mid1 + 1;\\n\\t\\t\\tret = Long.min(ret, costs2);\\n\\t\\t} else {\\n\\t\\t\\tlow = mid1 + 1;\\n\\t\\t\\thigh = mid2 - 1;\\n\\t\\t\\tret = Long.min(ret, costs1);\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\treturn ret;\\n}\\n\\nprivate long getCost(int mid, int[] nums, int[] cost) {\\n\\tlong costs = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tcosts += Math.abs(nums[i] - mid) * (long) cost[i];\\n\\t}\\n\\treturn costs;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long minCost(int[] nums, int[] cost) {\\n\\tint low = 1;\\n\\tint high = (int) 1e6;\\n\\tlong ret = Long.MAX_VALUE;\\n\\tint i = 1;\\n\\twhile (i<=50) {\\n\\t\\tint mid1 = low + (high - low)/3;\\n\\t\\tint mid2 = high - (high - low)/3;\\n\\t\\tlong costs1 = getCost(mid1, nums, cost);\\n\\t\\tlong costs2 = getCost(mid2, nums, cost);\\n\\t\\tif (costs1 < costs2) {\\n\\t\\t\\thigh = mid2 - 1;\\n\\t\\t\\tret = Long.min(ret, costs1);\\n\\t\\t} else if (costs1 > costs2){\\n\\t\\t\\tlow = mid1 + 1;\\n\\t\\t\\tret = Long.min(ret, costs2);\\n\\t\\t} else {\\n\\t\\t\\tlow = mid1 + 1;\\n\\t\\t\\thigh = mid2 - 1;\\n\\t\\t\\tret = Long.min(ret, costs1);\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\treturn ret;\\n}\\n\\nprivate long getCost(int mid, int[] nums, int[] cost) {\\n\\tlong costs = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tcosts += Math.abs(nums[i] - mid) * (long) cost[i];\\n\\t}\\n\\treturn costs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735338,
                "title": "golang-binary-search",
                "content": "```go\\nfunc minCost(nums []int, cost []int) int64 {\\n    arr := [][2]int{}\\n    for i, num := range nums {\\n        arr = append(arr, [2]int{num, cost[i]})\\n    }\\n    \\n    l, r := 0, 0\\n    for _, num := range nums {\\n        l = min(l, num)\\n        r = max(r, num)\\n    }\\n    \\n    for l < r {\\n        mid := l + (r-l)/2\\n        cost1, cost2 := getCost(arr, mid), getCost(arr, mid+1)\\n        if cost1 < cost2 { // minimum exists in left side\\n            r = mid\\n        } else { // minimum exists in right side\\n            l = mid+1\\n        }\\n    }\\n    \\n    return getCost(arr, l)\\n}\\n\\nfunc getCost(numWtCost [][2]int, target int) int64 {\\n    var total int64\\n    for _, item := range numWtCost {\\n        num, cost := item[0], item[1]\\n        total += int64(abs((num-target))*cost)\\n    }\\n    \\n    return total\\n}\\n\\nfunc abs(num int) int {\\n    if num < 0 {\\n        return -num\\n    }\\n    \\n    return num\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minCost(nums []int, cost []int) int64 {\\n    arr := [][2]int{}\\n    for i, num := range nums {\\n        arr = append(arr, [2]int{num, cost[i]})\\n    }\\n    \\n    l, r := 0, 0\\n    for _, num := range nums {\\n        l = min(l, num)\\n        r = max(r, num)\\n    }\\n    \\n    for l < r {\\n        mid := l + (r-l)/2\\n        cost1, cost2 := getCost(arr, mid), getCost(arr, mid+1)\\n        if cost1 < cost2 { // minimum exists in left side\\n            r = mid\\n        } else { // minimum exists in right side\\n            l = mid+1\\n        }\\n    }\\n    \\n    return getCost(arr, l)\\n}\\n\\nfunc getCost(numWtCost [][2]int, target int) int64 {\\n    var total int64\\n    for _, item := range numWtCost {\\n        num, cost := item[0], item[1]\\n        total += int64(abs((num-target))*cost)\\n    }\\n    \\n    return total\\n}\\n\\nfunc abs(num int) int {\\n    if num < 0 {\\n        return -num\\n    }\\n    \\n    return num\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735044,
                "title": "o-n-prefix-and-suffix-sum-to-o-1-space-optimisation-detailed-explanation",
                "content": "* Intially sort the 2 arrays based on nums\\n\\t* So, for example, in given testcase, nums = [1,3,5,2], cost = [2,3,1,14] then create a new array with both **nums** and **cost** and sort it. \\n\\t* Array after sort  = [[1,2],[2,14],[3,3],[5,1]] \\n\\t\\n* As pointed out in hints, evaluate the answer for each value in nums (i.e., convert each value in nums to nums[i] ; 0<=i<n-1).\\n\\t* But evaluating this takes O(n^2) time. \\n\\t* So the trick is to evaluate the intermediate answer in O(1) time so that the overall complexity becomes O(n).\\n\\t\\n* I denote nums -> nums[i] as converting all values in nums to nums[i]\\t\\n\\n* So, the cost of nums -> nums[0] for [[1,2],[2,14],[3,3],[5,1]] is \\n\\t* |1-1|\\\\*2 + |2-1|\\\\*14 + |3-1|\\\\*3 + |5-1|\\\\*1 = 24 \\n\\t* Indirectly, we calculate |nums[j]-nums[0]|\\\\*cost[j] ; 0<=j<n-1 and sum all of them (here |x| is absolute value of x)\\n\\n* Similarly cost of nums -> nums[1] is\\n\\t* |1-2|\\\\*2 + |2-2|\\\\*14 + |3-2|\\\\*3 + |5-2|\\\\*1 = 8 \\n\\t\\n* The **heart of optmization** lies here, we would like to get the current answer from previous answer.\\n\\t* Notice for the case of above test case, the 2 costs are \\n\\t\\t* 0\\\\*2 + 1\\\\*14 + 2\\\\*3 + 4\\\\*1 = 24\\n\\t\\t* 1\\\\*2 + 0\\\\*14 + 1\\\\*3 + 3\\\\*1 = 8\\n\\t* As we see most of the values are repeated but with some minor differences.\\n\\t* As we go from nums -> nums[i-1] to nums -> nums[i]\\n\\t\\t* All the costs before nums[i] increase by a factor of (nums[i]-nums[i-1])\\n\\t\\t* All the costs after nums[i] decrease by a factor of (nums[i]-nums[i-1]) \\n\\t\\t* This can be seen in above example for nums -> nums[0] to nums -> nums[1]\\n\\n* So I am gonna evaluate all the costs manually and then derive current cost from previous cost\\n\\t* Array is [[1,2],[2,14],[3,3],[5,1]]\\n\\t* |1-1|\\\\*2 + |2-1|\\\\*14 + |3-1|\\\\*3 + |5-1|\\\\*1 = 24   ==> nums -> nums[0]\\n\\t* |1-2|\\\\*2 + |2-2|\\\\*14 + |3-2|\\\\*3 + |5-2|\\\\*1 = 8     ==>  nums -> nums[1]\\n\\t* |1-3|\\\\*2 + |2-3|\\\\*14 + |3-3|\\\\*3 + |5-3|\\\\*1 = 20   ==> nums -> nums[2]\\n\\t* |1-5|\\\\*2 + |2-5|\\\\*14 + |3-5|\\\\*3 + |5-5|\\\\*1 = 56   ==> nums -> nums[3]\\n\\t* And we return minimum of all the costs\\n\\n* Now that I evaluated manually, let me show you the method to derive the answer from previous cost.\\n\\t* We have no other option but to evaluate nums -> nums[0] manually\\n\\t*   let\\'s maintain prefix and suffix costs in the process\\n\\t\\t*   prefixCost[i] = sum(cost[j]) 0<=j<i\\n\\t\\t*   suffixCost[i] = sum(cost[j]) i<=j<n\\n\\t* So for the given example [[1,2],[2,14],[3,3],[5,1]]\\n\\t\\t* prefixCost = [0,2,16.19]\\n\\t\\t* suffixCost = [20,18,4,1]\\n\\t* And since we calculated initial cost manually we have current = 24\\n\\t* For transitioning from nums -> nums[0] to nums -> nums[1], as specified earlier, we need to increment each value before nums[1] by a factor of nums[1]-nums[0] and decrease each value after nums[1] by factor of nums[1]-nums[0].\\n\\t* Therefore cost becomes: 24 + (2-1)\\\\*2 - (2-1)\\\\*14 - (2-1)\\\\*3 - (2-1)\\\\*1 = 8\\n\\t* We can take (2-1) as common and we get 24 + (2-1)\\\\*2 - (2-1)\\\\*(14 + 3 +1) = 8\\n\\t* We can rewrite above as 24 + (2-1)*prefixSum[1] - (2-1)*suffixSum[1]\\n\\n* So, now we have curr = 24, prefixCost = [0,2,16,19], suffixCost = [20,18,4,1] , array [[1,2],[2,14],[3,3],[5,1]]\\n\\t* nums -> nums[0] to nums -> nums[1] \\n\\t\\t* = 24 + (nums[1]-nums[0])*prefixCost[1] - (nums[1]-nums[0])*suffixCost[1]\\n\\t\\t* = 24 + 2 - 18 \\n\\t\\t* = 8 (which is precisely nums -> nums[1])\\n\\t* nums -> nums[1] to nums -> nums[2] \\n\\t\\t* = 8 + (nums[2]-nums[1])*prefixCost[2] - (nums[1]-nums[0])*suffixCost[2]\\n\\t\\t* = 8 + 16 - 4\\n\\t\\t* = 20 (which is precisely nums -> nums[2])\\n\\t* nums -> nums[2] to nums -> nums[3] \\n\\t\\t* = 20 + (nums[3]-nums[2])*prefixCost[3] - (nums[3]-nums[2])*suffixCost[3]\\n\\t\\t* = 20 + 38 - 2\\n\\t\\t* = 56  (which is precisely nums -> nums[3])\\n\\n* We then take the minimum of all currents\\n\\n## CODE\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        l=[]\\n        for (i,j) in zip(nums,cost):\\n            l.append([i,j])\\n        l.sort()\\n        \\n        prefCost=[]\\n        s=0\\n        for i in l:\\n            prefCost.append(s)\\n            s+=i[1]\\n        \\n        suffCost=[]\\n        s=0\\n        for i in l[::-1]:\\n            s+=i[1]\\n            suffCost.append(s)\\n            \\n        suffCost=suffCost[::-1]\\n        \\n        # evaluating nums -> nums[0]\\n        curr=0\\n        for i in range(1,len(l)):\\n            curr+=(l[i][0]-l[0][0])*l[i][1]\\n        \\n        ans=curr\\n        \\n        for i in range(1,len(l)):\\n            factor = l[i][0]-l[i-1][0]\\n            curr += factor*prefCost[i]\\n            curr -= factor*suffCost[i]\\n            ans=min(ans,curr)\\n        \\n        return ans\\n```\\n\\n\\n## SPACE OPTIMIZATION\\n\\n* One thing that we can notice here is that we can do away with both prefixCost and sufficCost arrays and directly calcuate suffixCost as sum - prefixCost and we can calculate prefixCost on fly.\\n\\n## CODE\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        l=[]\\n        for (i,j) in zip(nums,cost):\\n            l.append([i,j])\\n        l.sort()\\n        \\n        prefixCost = l[0][1]\\n        \\n        curr=0\\n        s = l[0][1]\\n        for i in range(1,len(l)):\\n            curr+=(l[i][0]-l[0][0])*l[i][1]\\n            s+=l[i][1]\\n        \\n        ans=curr\\n        \\n        for i in range(1,len(l)):\\n            factor = l[i][0]-l[i-1][0]\\n            curr += factor*prefixCost\\n            curr -= factor*(s-prefixCost)\\n            prefixCost += l[i][1]\\n            ans=min(ans,curr)\\n        \\n        return ans\\n```\\n\\n* Test case given is a poor one as most of the times numbers are contiguous, nums[i]-nums[i-1] will be 1. Take another proper test case and evaluate the algo. \\n\\nDisclaimer: Although, one can argue that the initial array which has both nums and cost makes up O(n) space. But this question helps us in reducing the space from O(n) to O(1) if we want running prefix and suffix sum of above requirement.",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        l=[]\\n        for (i,j) in zip(nums,cost):\\n            l.append([i,j])\\n        l.sort()\\n        \\n        prefCost=[]\\n        s=0\\n        for i in l:\\n            prefCost.append(s)\\n            s+=i[1]\\n        \\n        suffCost=[]\\n        s=0\\n        for i in l[::-1]:\\n            s+=i[1]\\n            suffCost.append(s)\\n            \\n        suffCost=suffCost[::-1]\\n        \\n        # evaluating nums -> nums[0]\\n        curr=0\\n        for i in range(1,len(l)):\\n            curr+=(l[i][0]-l[0][0])*l[i][1]\\n        \\n        ans=curr\\n        \\n        for i in range(1,len(l)):\\n            factor = l[i][0]-l[i-1][0]\\n            curr += factor*prefCost[i]\\n            curr -= factor*suffCost[i]\\n            ans=min(ans,curr)\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        l=[]\\n        for (i,j) in zip(nums,cost):\\n            l.append([i,j])\\n        l.sort()\\n        \\n        prefixCost = l[0][1]\\n        \\n        curr=0\\n        s = l[0][1]\\n        for i in range(1,len(l)):\\n            curr+=(l[i][0]-l[0][0])*l[i][1]\\n            s+=l[i][1]\\n        \\n        ans=curr\\n        \\n        for i in range(1,len(l)):\\n            factor = l[i][0]-l[i-1][0]\\n            curr += factor*prefixCost\\n            curr -= factor*(s-prefixCost)\\n            prefixCost += l[i][1]\\n            ans=min(ans,curr)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734499,
                "title": "python3-ternary-search-o-nlogn",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        def cnt(t): #function for calculating cost for Target \"t\"\\n            cur = cur_prev = cur_nxt = 0 #initialize the cost counting\\n            for i, el in enumerate(nums):\\n                cur += abs(el-t) * cost[i] #update the cost for target \"t\"\\n                cur_prev += abs(el-(t-1)) * cost[i] #update the cost for target \"t-1\"\\n                cur_nxt += abs(el-(t+1)) * cost[i] #update the cost for target \"t+1\"\\n            return cur, cur_prev, cur_nxt\\n                \\n        \\n        l, r = min(nums), max(nums) #lower and upper bound for searching\\n        ans = float(\\'inf\\')\\n        while l <= r:\\n            m = (l+r) // 2\\n            cur, cur_prev, cur_nxt = cnt(m) #call the counting function for target \"m\"\\n            if cur_prev >= cur <= cur_nxt: #if \"m\" if efficient than both \"m-1\" and \"m+1\" then cost for m is the ans\\n                return cur\\n\\t\\t\\t#update to efficient segment\\n            if cur_prev > cur_nxt:\\n                l = m+1\\n            else:\\n                r = m-1\\n        return cur\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        def cnt(t): #function for calculating cost for Target \"t\"\\n            cur = cur_prev = cur_nxt = 0 #initialize the cost counting\\n            for i, el in enumerate(nums):\\n                cur += abs(el-t) * cost[i] #update the cost for target \"t\"\\n                cur_prev += abs(el-(t-1)) * cost[i] #update the cost for target \"t-1\"\\n                cur_nxt += abs(el-(t+1)) * cost[i] #update the cost for target \"t+1\"\\n            return cur, cur_prev, cur_nxt\\n                \\n        \\n        l, r = min(nums), max(nums) #lower and upper bound for searching\\n        ans = float(\\'inf\\')\\n        while l <= r:\\n            m = (l+r) // 2\\n            cur, cur_prev, cur_nxt = cnt(m) #call the counting function for target \"m\"\\n            if cur_prev >= cur <= cur_nxt: #if \"m\" if efficient than both \"m-1\" and \"m+1\" then cost for m is the ans\\n                return cur\\n\\t\\t\\t#update to efficient segment\\n            if cur_prev > cur_nxt:\\n                l = m+1\\n            else:\\n                r = m-1\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734483,
                "title": "explained-prefix-sum-o-nlogn-c",
                "content": "First we sort the vector of pair of nums[i] and cost[i].\\nWhat advantage does it give?\\nWell by sorting according to nums[i] we dont have to individually calculate the distances and the cost to do them.\\nHow?\\nWell, assume e.g.\\n[1, 2, 3, 4] \\n[a, b, c, d]\\n\\nassume k=3 is the answer. So for this position we can say the sum of cost is as follows:\\nfrom left to right: (a) + (a+b)\\nfrom right to left: (d)\\n\\nYou see? The costs add up. So we will add up costs and multiply by the gap to travel, in this way will will get the cost to increment all the element before current element. Similarly do it for left.\\n\\nAfter saving these in an array, just add the cost for reching this element from left and from right.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long n=nums.size(), i, j, ans=LLONG_MAX;\\n        \\n        vector<pair<long long, long long>>v(n);\\n        \\n        for(i=0; i<n; i++){\\n            v[i] = {nums[i], cost[i]};\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        vector<long long> lsum(n), rsum(n);\\n        lsum[0] = 0;\\n        rsum[n-1] = 0;\\n        long long l = v[0].second, r = v[n-1].second;\\n        \\n        for(i=1; i<n; i++){\\n            lsum[i] = lsum[i-1] + (v[i].first - v[i-1].first)*l;\\n            l += v[i].second;\\n            \\n            rsum[n-i-1] = rsum[n-i] + (v[n-i].first - v[n-i-1].first)*r;\\n            r += v[n-i-1].second;          \\n        }\\n        \\n        for(i=0; i<n; i++){\\n            ans = min(lsum[i] + rsum[i], ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long n=nums.size(), i, j, ans=LLONG_MAX;\\n        \\n        vector<pair<long long, long long>>v(n);\\n        \\n        for(i=0; i<n; i++){\\n            v[i] = {nums[i], cost[i]};\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        vector<long long> lsum(n), rsum(n);\\n        lsum[0] = 0;\\n        rsum[n-1] = 0;\\n        long long l = v[0].second, r = v[n-1].second;\\n        \\n        for(i=1; i<n; i++){\\n            lsum[i] = lsum[i-1] + (v[i].first - v[i-1].first)*l;\\n            l += v[i].second;\\n            \\n            rsum[n-i-1] = rsum[n-i] + (v[n-i].first - v[n-i-1].first)*r;\\n            r += v[n-i-1].second;          \\n        }\\n        \\n        for(i=0; i<n; i++){\\n            ans = min(lsum[i] + rsum[i], ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734221,
                "title": "java-binary-search",
                "content": "```java\\nclass Solution {\\n    public long fun(int[] nums,int[] cost,int n,int k){\\n        long ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans += Math.abs(k-nums[i])*(long)(cost[i]);\\n        }\\n        return ans;\\n    }\\n    public long minCost(int[] nums, int[] cost) {\\n        int n = nums.length;\\n        int l = nums[0],r = nums[0];\\n        for(int i=0;i<n;i++){\\n            l = Math.min(l,nums[i]);\\n            r = Math.max(r,nums[i]);\\n        }\\n        long ans = Long.MAX_VALUE;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            long t1 = fun(nums,cost,n,mid);\\n            long t2 = fun(nums,cost,n,mid+1);\\n            if(t1 <= t2){\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n            ans = Math.min(ans,Math.min(t1,t2));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public long fun(int[] nums,int[] cost,int n,int k){\\n        long ans = 0;\\n        for(int i=0;i<n;i++){\\n            ans += Math.abs(k-nums[i])*(long)(cost[i]);\\n        }\\n        return ans;\\n    }\\n    public long minCost(int[] nums, int[] cost) {\\n        int n = nums.length;\\n        int l = nums[0],r = nums[0];\\n        for(int i=0;i<n;i++){\\n            l = Math.min(l,nums[i]);\\n            r = Math.max(r,nums[i]);\\n        }\\n        long ans = Long.MAX_VALUE;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            long t1 = fun(nums,cost,n,mid);\\n            long t2 = fun(nums,cost,n,mid+1);\\n            if(t1 <= t2){\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n            ans = Math.min(ans,Math.min(t1,t2));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734219,
                "title": "java-treemap-and-prefix-sum-o-nlogn",
                "content": "Ideas:\\n* Calculate the cost of reaching each target candidate, and return the minimum.\\n* Target candidates are unique numbers in `nums`.\\n* Target candidates are sorted in TreeMap.\\n* Use prefix and suffix sums to calculate the cost difference between contiguous target candidates.\\n\\n``` java\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        TreeMap<Integer, Long> numCosts = new TreeMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            numCosts.put(nums[i], numCosts.getOrDefault(nums[i], (long) 0) + cost[i]);\\n        }\\n        long preSum = 0;  // exclusive\\n        long postSum = 0;  // inclusive\\n        for (int n : numCosts.keySet()) {\\n            postSum += numCosts.get(n);\\n        }\\n        int target = numCosts.firstKey();\\n        long currCost = 0;\\n        for (int n : numCosts.keySet()) {\\n            currCost += Math.abs(n - target) * numCosts.get(n);\\n        }\\n        long minCost = currCost;\\n        while (numCosts.higherKey(target) != null) {\\n            int nextTarget = numCosts.higherKey(target);\\n            preSum += numCosts.get(target);\\n            postSum -= numCosts.get(target);\\n            currCost += Math.abs(nextTarget - target) * (preSum - postSum);\\n            minCost = Math.min(minCost, currCost);\\n            target = nextTarget;\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Prefix Sum"
                ],
                "code": "``` java\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        TreeMap<Integer, Long> numCosts = new TreeMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            numCosts.put(nums[i], numCosts.getOrDefault(nums[i], (long) 0) + cost[i]);\\n        }\\n        long preSum = 0;  // exclusive\\n        long postSum = 0;  // inclusive\\n        for (int n : numCosts.keySet()) {\\n            postSum += numCosts.get(n);\\n        }\\n        int target = numCosts.firstKey();\\n        long currCost = 0;\\n        for (int n : numCosts.keySet()) {\\n            currCost += Math.abs(n - target) * numCosts.get(n);\\n        }\\n        long minCost = currCost;\\n        while (numCosts.higherKey(target) != null) {\\n            int nextTarget = numCosts.higherKey(target);\\n            preSum += numCosts.get(target);\\n            postSum -= numCosts.get(target);\\n            currCost += Math.abs(nextTarget - target) * (preSum - postSum);\\n            minCost = Math.min(minCost, currCost);\\n            target = nextTarget;\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734109,
                "title": "python-binary-search-solution",
                "content": "```\\n    def minCost(self, nums, cost):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def getCost(x):\\n            res = 0\\n            for i in range(len(nums)):\\n                res += abs(nums[i] - x) * cost[i]\\n            return res\\n        \\n        left = min(nums)\\n        right = max(nums)\\n        while left + 1 < right:\\n            mid = left + (right - left) // 2\\n            leftCost = getCost(left)\\n            midCost = getCost(mid)\\n            rightCost = getCost(right)\\n            \\n            if leftCost <= midCost <= rightCost:\\n                right = mid\\n            elif leftCost >= midCost >= rightCost:\\n                left = mid\\n            else:\\n                if getCost(mid - 1) <= getCost(mid):\\n                    right = mid\\n                else:\\n                    left = mid\\n        return min(getCost(left), getCost(right))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minCost(self, nums, cost):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type cost: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def getCost(x):\\n            res = 0\\n            for i in range(len(nums)):\\n                res += abs(nums[i] - x) * cost[i]\\n            return res\\n        \\n        left = min(nums)\\n        right = max(nums)\\n        while left + 1 < right:\\n            mid = left + (right - left) // 2\\n            leftCost = getCost(left)\\n            midCost = getCost(mid)\\n            rightCost = getCost(right)\\n            \\n            if leftCost <= midCost <= rightCost:\\n                right = mid\\n            elif leftCost >= midCost >= rightCost:\\n                left = mid\\n            else:\\n                if getCost(mid - 1) <= getCost(mid):\\n                    right = mid\\n                else:\\n                    left = mid\\n        return min(getCost(left), getCost(right))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3719278,
                "title": "completely-linear-o-n-solution-using-std-partition-inspired-by-quickselect",
                "content": "# Intuition\\nBasically what we need is weighted linear-time Quickselect (a.k.a. `nth_element`).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nTake random pivot, partition the list around that pivot. Find in which half the answer should be (by comparing sum of costs). Divide-and-conquer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Expected time complexity: $$O(n)$$\\n- Maximum theoretical time complexity: $$O(n^2)$$ (like quicksort)\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        mt19937_64 rng(0);\\n\\n        using pii = pair<int, int>;\\n        size_t n = nums.size();\\n        vector<pii> v(n);\\n        \\n        for (size_t i = 0; i < n; ++i) {\\n            v[i] = pii(nums[i], cost[i]);\\n        }\\n\\n        size_t l = 0, r = n;\\n        uint64_t wl = 0, wr = 0;\\n        while (r - l > 1) {\\n            size_t random_index = uniform_int_distribution<>(l, r - 1)(rng);\\n            int pivot = v[random_index].first;\\n            auto it1 = partition(v.begin() + l, v.begin() + r, [pivot](pii p){ return p.first < pivot; });\\n            auto it2 = partition(it1, v.begin() + r, [pivot](pii p){ return p.first == pivot; });\\n            size_t m1 = it1 - v.begin();\\n            size_t m2 = it2 - v.begin();\\n            uint64_t pl = 0, pr = 0, pc = 0;\\n            for (size_t i = l; i < m1; ++i) {\\n                pl += v[i].second;\\n            }\\n            for (size_t i = m1; i < m2; ++i) {\\n                pc += v[i].second;\\n            }\\n            for (size_t i = m2; i < r; ++i) {\\n                pr += v[i].second;\\n            }\\n            if (pr + wr > pl + wl + pc) {\\n                wl += pc + pl;\\n                l = m2;\\n            } else if (pl + wl > pr + wr + pc) {\\n                wr += pc + pr;\\n                r = m1;\\n            } else {\\n                wl += pl;\\n                wr += pr;\\n                l = m1;\\n                r = m2;\\n                break;\\n            }\\n        }\\n\\n        int64_t result = 0;\\n        int64_t best = v[l].first;\\n\\n        for (size_t i = 0; i < l; ++i) {\\n            result += v[i].second * (best - v[i].first);\\n        }\\n        for (size_t i = l; i < n; ++i) {\\n            result += v[i].second * (v[i].first - best);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        mt19937_64 rng(0);\\n\\n        using pii = pair<int, int>;\\n        size_t n = nums.size();\\n        vector<pii> v(n);\\n        \\n        for (size_t i = 0; i < n; ++i) {\\n            v[i] = pii(nums[i], cost[i]);\\n        }\\n\\n        size_t l = 0, r = n;\\n        uint64_t wl = 0, wr = 0;\\n        while (r - l > 1) {\\n            size_t random_index = uniform_int_distribution<>(l, r - 1)(rng);\\n            int pivot = v[random_index].first;\\n            auto it1 = partition(v.begin() + l, v.begin() + r, [pivot](pii p){ return p.first < pivot; });\\n            auto it2 = partition(it1, v.begin() + r, [pivot](pii p){ return p.first == pivot; });\\n            size_t m1 = it1 - v.begin();\\n            size_t m2 = it2 - v.begin();\\n            uint64_t pl = 0, pr = 0, pc = 0;\\n            for (size_t i = l; i < m1; ++i) {\\n                pl += v[i].second;\\n            }\\n            for (size_t i = m1; i < m2; ++i) {\\n                pc += v[i].second;\\n            }\\n            for (size_t i = m2; i < r; ++i) {\\n                pr += v[i].second;\\n            }\\n            if (pr + wr > pl + wl + pc) {\\n                wl += pc + pl;\\n                l = m2;\\n            } else if (pl + wl > pr + wr + pc) {\\n                wr += pc + pr;\\n                r = m1;\\n            } else {\\n                wl += pl;\\n                wr += pr;\\n                l = m1;\\n                r = m2;\\n                break;\\n            }\\n        }\\n\\n        int64_t result = 0;\\n        int64_t best = v[l].first;\\n\\n        for (size_t i = 0; i < l; ++i) {\\n            result += v[i].second * (best - v[i].first);\\n        }\\n        for (size_t i = l; i < n; ++i) {\\n            result += v[i].second * (v[i].first - best);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693958,
                "title": "simple-c-solution-using-median",
                "content": "# Intuition\\nIn this program our main intution is to calculate the median of the array as we know that it is efficient case to make all array element equal to the median value so that cost can be minimum.As all the values will be at fair distance from the median element both largest and the smallest Value.\\n\\n\\n# Approach\\nso we first calculate the median and then find the cost of each element that each element will take to get transform to median element.\\nThe totalcost will be our answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n//Function to Calculate the totalcost to Make each element of array equal to median element.\\n\\nlong long findcost(vector<int>& nums, vector<int>& cost,int n,int ele){\\n    long long totalcost=0;\\n    for(int i=0;i<n;i++){\\n        totalcost+= 1L * abs(nums[i] - ele) * cost[i];//1L means long\\n\\n    }\\n    return totalcost;\\n}\\n\\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n       int n=nums.size();\\n       vector<pair<int,int>> answer;\\n       long long sum=0;\\n\\n//Creating another Vector of pair which stores {array element} + {cost associated} with it\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           answer.push_back({nums[i],cost[i]});\\n           sum=sum+cost[i];\\n       }\\n\\n\\n       long long total=0;\\n       sort(answer.begin(),answer.end());\\n       int i=0;\\n       long long median=0;\\n\\n//Loop to calculate the median of array.       \\n       while((total<=sum/2) && i<n)\\n       {\\n           total=total+answer[i].second;\\n           median=answer[i].first;\\n           i++;\\n        \\n        }\\n\\n        return findcost(nums,cost,n,median);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n//Function to Calculate the totalcost to Make each element of array equal to median element.\\n\\nlong long findcost(vector<int>& nums, vector<int>& cost,int n,int ele){\\n    long long totalcost=0;\\n    for(int i=0;i<n;i++){\\n        totalcost+= 1L * abs(nums[i] - ele) * cost[i];//1L means long\\n\\n    }\\n    return totalcost;\\n}\\n\\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n       int n=nums.size();\\n       vector<pair<int,int>> answer;\\n       long long sum=0;\\n\\n//Creating another Vector of pair which stores {array element} + {cost associated} with it\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           answer.push_back({nums[i],cost[i]});\\n           sum=sum+cost[i];\\n       }\\n\\n\\n       long long total=0;\\n       sort(answer.begin(),answer.end());\\n       int i=0;\\n       long long median=0;\\n\\n//Loop to calculate the median of array.       \\n       while((total<=sum/2) && i<n)\\n       {\\n           total=total+answer[i].second;\\n           median=answer[i].first;\\n           i++;\\n        \\n        }\\n\\n        return findcost(nums,cost,n,median);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684180,
                "title": "code-for-all-3-approaches-at-once",
                "content": "# Code for all 3 Approaches.\\n\\n# Code\\n```\\nclass Solution \\n{\\nprivate:\\n\\n    //WEIGHTED MEDIAN SOLUTION\\n    //-------------------------------------------------------------------------------------------//\\n    int getMedian(vector<pair<long long,long long>>& v)\\n    {\\n        long long sz = 0ll;\\n        for(auto [f,s]: v)\\n            sz += s;\\n\\n        int median = -1;\\n        long long curTotal = 0, i = 0;\\n        while(i < v.size() and curTotal < (sz+1)/2)\\n        {\\n            curTotal = curTotal + 1ll*v[i].second;\\n            median = v[i].first;\\n            i++;\\n        }\\n        return median;\\n    }\\n    long long getCost(vector<pair<long long,long long>>& v, int x)\\n    {\\n        long long res =0ll;\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            res = res + ( 1ll * abs(v[i].first - x) * v[i].second);\\n        }\\n        return res;\\n    }\\n    long long solveUsingWeightedMedian(vector<int>& nums, vector<int>& cost)\\n    {\\n        int n = nums.size();\\n\\n        vector<pair<long long,long long>> v;\\n        for(int i=0; i<n; i++)\\n        {\\n            v.push_back({nums[i], cost[i]});\\n        }\\n        sort(v.begin(), v.end());\\n\\n        int median = getMedian(v);\\n        return getCost(v, median);\\n    }\\n\\n\\n\\n\\n    //BINARY SEARCH ON CONVEX FUNCTION SOLUTION\\n    //-------------------------------------------------------------------------------------------//\\n    long long getCost(vector<int>& nums, vector<int>& cost, int convertAllTo)\\n    {\\n        long long totCost = 0l;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            totCost = totCost + (1LL*cost[i]*(abs(nums[i]-convertAllTo)));\\n        }\\n        return totCost;\\n    }\\n    // I wouldnt call it ternary search only coz, \\n    // we are not technically dividing array into 3 search fragments and discarding 2\\n    long long solveUsingBinarySearchOnConvexFunction(vector<int>& nums, vector<int>& cost)\\n    {\\n        int l = *min_element(nums.begin(), nums.end());\\n        int r = *max_element(nums.begin(), nums.end());\\n\\n        // while making bold assumptions like this,\\n        // make sure we\\'ll get right answer for corner cases,\\n        // ie when array has 0 or 1 or 2 or 3 or 4 elements.\\n        long long ans = LLONG_MAX;\\n        while(l <= r)\\n        {\\n            int mid1 = (l+r)/2;\\n            int mid2 = mid1+1;\\n            \\n            long long cost1 = getCost(nums, cost, mid1);\\n            long long cost2 = getCost(nums, cost, mid2);\\n\\n            ans = min(cost1, cost2);\\n\\n            if(cost1 > cost2)\\n                l = mid1+1;\\n            else\\n                r = mid1-1;    \\n        }\\n        return ans;\\n    }\\n\\n\\n\\n\\n    //PREFIX SUM DP SOLUTION\\n    //-------------------------------------------------------------------------------------------//\\n    long long solveUsingPrefixSumsDP(vector<int>& nums, vector<int>& cost)\\n    {\\n        int n = nums.size();\\n\\n        vector<pair<int,int>> vpi;\\n        for(int i=0; i<n; i++)\\n        {\\n            vpi.push_back({nums[i], cost[i]});\\n        }\\n        sort(vpi.begin(), vpi.end());\\n\\n        vector<long long> prefixSums(n);\\n        prefixSums[0] = vpi[0].second;\\n        for(int i=1; i<n; i++)\\n        {\\n            prefixSums[i] = prefixSums[i-1]+vpi[i].second;\\n        }\\n\\n        vector<long long> dp(n,0);\\n        for(int i=1; i<n; i++)\\n        {\\n            dp[0] = dp[0] + (1ll* vpi[i].second * abs(vpi[i].first- vpi[0].first));\\n        }\\n        for(int i=1; i<n; i++)\\n        {\\n            int gap = vpi[i].first - vpi[i-1].first;\\n            dp[i] = dp[i-1] \\n                    + (prefixSums[i-1]* gap)\\n                    - (prefixSums[n-1]- prefixSums[i-1])*gap;\\n        }\\n        //note that to calc dp[i] we only need dp[i-1]\\n        //so space complexity can be reduced to O(1)\\n        //but not doing it for readability.\\n        return *min_element(dp.begin(), dp.end());\\n    }\\n    //-------------------------------------------------------------------------------------------//\\n\\n\\n\\n\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) \\n    {\\n        int random = rand()%3;\\n        if(random == 0)\\n        {\\n            return solveUsingWeightedMedian(nums, cost);\\n        }\\n        if(random == 1)\\n        {\\n            return solveUsingBinarySearchOnConvexFunction(nums, cost);\\n        }\\n        if(random == 2)\\n        {\\n            return solveUsingPrefixSumsDP(nums, cost);\\n        }\\n        return random;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\nprivate:\\n\\n    //WEIGHTED MEDIAN SOLUTION\\n    //-------------------------------------------------------------------------------------------//\\n    int getMedian(vector<pair<long long,long long>>& v)\\n    {\\n        long long sz = 0ll;\\n        for(auto [f,s]: v)\\n            sz += s;\\n\\n        int median = -1;\\n        long long curTotal = 0, i = 0;\\n        while(i < v.size() and curTotal < (sz+1)/2)\\n        {\\n            curTotal = curTotal + 1ll*v[i].second;\\n            median = v[i].first;\\n            i++;\\n        }\\n        return median;\\n    }\\n    long long getCost(vector<pair<long long,long long>>& v, int x)\\n    {\\n        long long res =0ll;\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            res = res + ( 1ll * abs(v[i].first - x) * v[i].second);\\n        }\\n        return res;\\n    }\\n    long long solveUsingWeightedMedian(vector<int>& nums, vector<int>& cost)\\n    {\\n        int n = nums.size();\\n\\n        vector<pair<long long,long long>> v;\\n        for(int i=0; i<n; i++)\\n        {\\n            v.push_back({nums[i], cost[i]});\\n        }\\n        sort(v.begin(), v.end());\\n\\n        int median = getMedian(v);\\n        return getCost(v, median);\\n    }\\n\\n\\n\\n\\n    //BINARY SEARCH ON CONVEX FUNCTION SOLUTION\\n    //-------------------------------------------------------------------------------------------//\\n    long long getCost(vector<int>& nums, vector<int>& cost, int convertAllTo)\\n    {\\n        long long totCost = 0l;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            totCost = totCost + (1LL*cost[i]*(abs(nums[i]-convertAllTo)));\\n        }\\n        return totCost;\\n    }\\n    // I wouldnt call it ternary search only coz, \\n    // we are not technically dividing array into 3 search fragments and discarding 2\\n    long long solveUsingBinarySearchOnConvexFunction(vector<int>& nums, vector<int>& cost)\\n    {\\n        int l = *min_element(nums.begin(), nums.end());\\n        int r = *max_element(nums.begin(), nums.end());\\n\\n        // while making bold assumptions like this,\\n        // make sure we\\'ll get right answer for corner cases,\\n        // ie when array has 0 or 1 or 2 or 3 or 4 elements.\\n        long long ans = LLONG_MAX;\\n        while(l <= r)\\n        {\\n            int mid1 = (l+r)/2;\\n            int mid2 = mid1+1;\\n            \\n            long long cost1 = getCost(nums, cost, mid1);\\n            long long cost2 = getCost(nums, cost, mid2);\\n\\n            ans = min(cost1, cost2);\\n\\n            if(cost1 > cost2)\\n                l = mid1+1;\\n            else\\n                r = mid1-1;    \\n        }\\n        return ans;\\n    }\\n\\n\\n\\n\\n    //PREFIX SUM DP SOLUTION\\n    //-------------------------------------------------------------------------------------------//\\n    long long solveUsingPrefixSumsDP(vector<int>& nums, vector<int>& cost)\\n    {\\n        int n = nums.size();\\n\\n        vector<pair<int,int>> vpi;\\n        for(int i=0; i<n; i++)\\n        {\\n            vpi.push_back({nums[i], cost[i]});\\n        }\\n        sort(vpi.begin(), vpi.end());\\n\\n        vector<long long> prefixSums(n);\\n        prefixSums[0] = vpi[0].second;\\n        for(int i=1; i<n; i++)\\n        {\\n            prefixSums[i] = prefixSums[i-1]+vpi[i].second;\\n        }\\n\\n        vector<long long> dp(n,0);\\n        for(int i=1; i<n; i++)\\n        {\\n            dp[0] = dp[0] + (1ll* vpi[i].second * abs(vpi[i].first- vpi[0].first));\\n        }\\n        for(int i=1; i<n; i++)\\n        {\\n            int gap = vpi[i].first - vpi[i-1].first;\\n            dp[i] = dp[i-1] \\n                    + (prefixSums[i-1]* gap)\\n                    - (prefixSums[n-1]- prefixSums[i-1])*gap;\\n        }\\n        //note that to calc dp[i] we only need dp[i-1]\\n        //so space complexity can be reduced to O(1)\\n        //but not doing it for readability.\\n        return *min_element(dp.begin(), dp.end());\\n    }\\n    //-------------------------------------------------------------------------------------------//\\n\\n\\n\\n\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) \\n    {\\n        int random = rand()%3;\\n        if(random == 0)\\n        {\\n            return solveUsingWeightedMedian(nums, cost);\\n        }\\n        if(random == 1)\\n        {\\n            return solveUsingBinarySearchOnConvexFunction(nums, cost);\\n        }\\n        if(random == 2)\\n        {\\n            return solveUsingPrefixSumsDP(nums, cost);\\n        }\\n        return random;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669160,
                "title": "python-o-n-beat-100-using-weighted-median-and-quick-select",
                "content": "# Intuition\\nFind weighted median (refer to solution [2734183](https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/2734183/python-real-o-n-solution-using-weighted-median-and-quick-select/))\\n\\n# Approach\\nUse quick select algorithm to find median.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n# Key idea: Find weighted median (refer to solution #2734183)\\n# Approach: Use quick select algorithm to find median.\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n\\n        A = AA = list(zip(nums, cost))\\n        leftV, rightV = min(nums), max(nums)\\n        sumW, leftW = sum(cost), 0\\n\\n        while rightV != leftV:\\n            medV = (leftV + rightV) / 2\\n            tempLeftW = sum(x[1] for x in AA if x[0]<medV)\\n\\n            if leftW + tempLeftW >= sumW / 2: \\n                AA = [x for x in AA if x[0]<medV]\\n                rightV = max(AA)[0]\\n            else:\\n                AA = [x for x in AA if x[0]>=medV]\\n                leftV = min(AA)[0]\\n                leftW += tempLeftW\\n\\n        return sum(abs(v-leftV)*w for v,w in A)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Key idea: Find weighted median (refer to solution #2734183)\\n# Approach: Use quick select algorithm to find median.\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n\\n        A = AA = list(zip(nums, cost))\\n        leftV, rightV = min(nums), max(nums)\\n        sumW, leftW = sum(cost), 0\\n\\n        while rightV != leftV:\\n            medV = (leftV + rightV) / 2\\n            tempLeftW = sum(x[1] for x in AA if x[0]<medV)\\n\\n            if leftW + tempLeftW >= sumW / 2: \\n                AA = [x for x in AA if x[0]<medV]\\n                rightV = max(AA)[0]\\n            else:\\n                AA = [x for x in AA if x[0]>=medV]\\n                leftV = min(AA)[0]\\n                leftW += tempLeftW\\n\\n        return sum(abs(v-leftV)*w for v,w in A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666848,
                "title": "java-binary-search-easy-explained",
                "content": "````\\nWelcome to my solution \\n````\\n- The Simple way to describe this problem or say the solution is just pick min and maximum heights from the nums consider those nums as heights of pillar \\n- go for binary search while(l<r) where l is min of the all nums and r is the max of the all the nums \\n- now get that exact height which one gonna give the minimum cost of all of it. \\n- but wait question arise how we gonna do this \\n\\n## How? \\n- to do this just as you know we gonna divide them into mid that is mid = l+r/2 form here now we gonna check for two heights left one (mid) and right one (mid+1) okay now what?\\n- after this we will get the cost of both of them if you get left one is minimum mean our answer or min cost lies in left side just make changes accordingly into right and left \\n- at the end of the loop you will get that optimal height by which making them equal will give minium cost \\n- just return the ans\\n\\n- Code is given below just follow the code and you will understand \\n- Some photos are also attached for your help\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(nlog.k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/042ac7ce-2a15-4b88-9e82-d01a2976076d_1687374157.0514271.png)\\n![image.png](https://assets.leetcode.com/users/images/037ab33b-4074-4298-bdd3-d7899ce5225b_1687374163.8555446.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int left = Integer.MAX_VALUE;\\n        int right = Integer.MIN_VALUE;\\n\\n        for(int i=0; i<nums.length; i++){\\n            left = Math.min(left, nums[i]);\\n            right = Math.max(right, nums[i]);\\n        }\\n\\n        long ans = getCost(nums, cost, nums[0]);\\n\\n\\n        while(left<right){\\n            int mid = (left+right)/2;\\n\\n            // finding the cost of the left one \\n            long leftCost = getCost(nums, cost,mid);\\n            // finding the cost of the right one \\n            long rightCost = getCost(nums, cost, mid+1);\\n\\n            ans = Math.min(leftCost, rightCost);\\n\\n            if(leftCost>rightCost){\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n// function to get the cost for the nums[i] any element base case \\n    public static long getCost(int[] nums, int[] cost, int base){\\n        long res = 0l;\\n\\n        for(int i=0; i<nums.length; i++){\\n            // by abs difference we can get the cost\\n            res+= 1l*cost[i]*Math.abs(base-nums[i]);\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n## Thankyou for visiting my solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\nWelcome to my solution \\n```\n```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int left = Integer.MAX_VALUE;\\n        int right = Integer.MIN_VALUE;\\n\\n        for(int i=0; i<nums.length; i++){\\n            left = Math.min(left, nums[i]);\\n            right = Math.max(right, nums[i]);\\n        }\\n\\n        long ans = getCost(nums, cost, nums[0]);\\n\\n\\n        while(left<right){\\n            int mid = (left+right)/2;\\n\\n            // finding the cost of the left one \\n            long leftCost = getCost(nums, cost,mid);\\n            // finding the cost of the right one \\n            long rightCost = getCost(nums, cost, mid+1);\\n\\n            ans = Math.min(leftCost, rightCost);\\n\\n            if(leftCost>rightCost){\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n// function to get the cost for the nums[i] any element base case \\n    public static long getCost(int[] nums, int[] cost, int base){\\n        long res = 0l;\\n\\n        for(int i=0; i<nums.length; i++){\\n            // by abs difference we can get the cost\\n            res+= 1l*cost[i]*Math.abs(base-nums[i]);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666622,
                "title": "c-sorting-binary-search-computation",
                "content": "# Code\\n```\\n#include <algorithm>\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll prefixSum[100005], suffixSum[100005], minCost, totalCost=0LL;\\n        ll n= nums.size();\\n        vector<pair<int,int>> nums_cost;\\n        for(int i=0; i<n; i++)\\n        {\\n            nums_cost.push_back(make_pair(nums[i], cost[i]));\\n            totalCost+= (ll)(nums[i]-1)*cost[i];\\n        }\\n        sort(nums_cost.begin(), nums_cost.end());\\n        prefixSum[0]= nums_cost[0].second;\\n        suffixSum[n-1]= nums_cost[n-1].second;\\n        for(int i=1; i<n;i++)\\n        {\\n            prefixSum[i]= prefixSum[i-1] + nums_cost[i].second;\\n        }\\n        for(int i=n-2; i>=0;i--)\\n        {\\n            suffixSum[i]= suffixSum[i+1] + nums_cost[i].second;\\n        }\\n        minCost = totalCost;\\n        for(int i=2; i<=nums_cost[n-1].first; i++)\\n        {\\n            pair temp= {i,0};\\n           auto index= lower_bound(nums_cost.begin(), nums_cost.end(), temp)- nums_cost.begin();\\n\\n            if(index<n)\\n            totalCost = totalCost-suffixSum[index];\\n            if(index>0)\\n            totalCost= totalCost + prefixSum[index-1]; \\n\\n            minCost= min(minCost, totalCost);\\n\\n        }\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <algorithm>\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll prefixSum[100005], suffixSum[100005], minCost, totalCost=0LL;\\n        ll n= nums.size();\\n        vector<pair<int,int>> nums_cost;\\n        for(int i=0; i<n; i++)\\n        {\\n            nums_cost.push_back(make_pair(nums[i], cost[i]));\\n            totalCost+= (ll)(nums[i]-1)*cost[i];\\n        }\\n        sort(nums_cost.begin(), nums_cost.end());\\n        prefixSum[0]= nums_cost[0].second;\\n        suffixSum[n-1]= nums_cost[n-1].second;\\n        for(int i=1; i<n;i++)\\n        {\\n            prefixSum[i]= prefixSum[i-1] + nums_cost[i].second;\\n        }\\n        for(int i=n-2; i>=0;i--)\\n        {\\n            suffixSum[i]= suffixSum[i+1] + nums_cost[i].second;\\n        }\\n        minCost = totalCost;\\n        for(int i=2; i<=nums_cost[n-1].first; i++)\\n        {\\n            pair temp= {i,0};\\n           auto index= lower_bound(nums_cost.begin(), nums_cost.end(), temp)- nums_cost.begin();\\n\\n            if(index<n)\\n            totalCost = totalCost-suffixSum[index];\\n            if(index>0)\\n            totalCost= totalCost + prefixSum[index-1]; \\n\\n            minCost= min(minCost, totalCost);\\n\\n        }\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3666516,
                "title": "2448-minimum-cost-to-make-array-equal-java-solution",
                "content": "First create a 2d array of same length as nums[] and for every i from 0 to n-1, let \\n```java\\narr[i][0] = nums[i];\\narr[i][1] = cost[i];\\n```\\n\\nNow, sort arr[][] with respect to 0th index value in increasing order. Now, we will iterate in arr and will try to make each value equal to arr[i][0].\\n\\nFor every arr[i][0], we have elements on left side which are smaller than it and on right sides we have elements bigger than it. So, we will try to take advantage of prefix sum arrays to calculate the costs on left and right side in constant time. Refer the images below for better understanding.\\n\\n![image](https://assets.leetcode.com/users/images/07b4ab8b-edd8-43df-9c33-ae97162d0953_1687368139.284343.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/d0a5e4d4-13fa-4940-9984-ad9f3e96b7ce_1687368152.3661296.jpeg)\\n\\nSo, Using above mentioned way, we can calculate this value easily.\\n```java\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int n = nums.length, arr[][] = new int[n][2];\\n        for(int i = 0; i < n; ++i){\\n            arr[i][0] = nums[i];\\n            arr[i][1] = cost[i];\\n        }\\n        Arrays.sort(arr, (a,b)->a[0] - b[0]);\\n        long[] prefix1 = new long[n + 1], prefix2 = new long[n + 1];\\n        for(int i = 0; i < n; ++i){\\n            prefix1[i+1] = prefix1[i] + ((long)arr[i][0]) * ((long)arr[i][1]);\\n            prefix2[i+1] = prefix2[i] + arr[i][1];\\n        }\\n        long minCost = Long.MAX_VALUE, leftCost, rightCost;\\n        for(int i = 0; i < n; ++i){\\n            rightCost = (prefix1[n] - prefix1[i+1]) - ((long)arr[i][0]) * (prefix2[n] - prefix2[i+1]);\\n            leftCost = ((long)arr[i][0]) * (prefix2[i]) - (prefix1[i]);\\n            minCost = (long)(Math.min(minCost, rightCost + leftCost));\\n        }\\n        return minCost;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/69d134f9-5519-4942-b2c0-31b439c71765_1687370525.7233808.png)\\n",
                "solutionTags": [
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```java\\narr[i][0] = nums[i];\\narr[i][1] = cost[i];\\n```\n```java\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int n = nums.length, arr[][] = new int[n][2];\\n        for(int i = 0; i < n; ++i){\\n            arr[i][0] = nums[i];\\n            arr[i][1] = cost[i];\\n        }\\n        Arrays.sort(arr, (a,b)->a[0] - b[0]);\\n        long[] prefix1 = new long[n + 1], prefix2 = new long[n + 1];\\n        for(int i = 0; i < n; ++i){\\n            prefix1[i+1] = prefix1[i] + ((long)arr[i][0]) * ((long)arr[i][1]);\\n            prefix2[i+1] = prefix2[i] + arr[i][1];\\n        }\\n        long minCost = Long.MAX_VALUE, leftCost, rightCost;\\n        for(int i = 0; i < n; ++i){\\n            rightCost = (prefix1[n] - prefix1[i+1]) - ((long)arr[i][0]) * (prefix2[n] - prefix2[i+1]);\\n            leftCost = ((long)arr[i][0]) * (prefix2[i]) - (prefix1[i]);\\n            minCost = (long)(Math.min(minCost, rightCost + leftCost));\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666237,
                "title": "4-lines-only-without-finding-median",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        ll = sorted([[nums[i], cost[i]] for i in range(len(cost))])\\n        c = list(accumulate([ll[i][1] for i in range(len(cost))]))\\n        nc = list(accumulate([ll[i][0] * ll[i][1] for i in range(len(cost))]))\\n        return min([ll[i][0]*(2*c[i]-c[len(cost)-1]) + (nc[len(cost)-1]-2*nc[i]) for i in range(len(cost))])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        ll = sorted([[nums[i], cost[i]] for i in range(len(cost))])\\n        c = list(accumulate([ll[i][1] for i in range(len(cost))]))\\n        nc = list(accumulate([ll[i][0] * ll[i][1] for i in range(len(cost))]))\\n        return min([ll[i][0]*(2*c[i]-c[len(cost)-1]) + (nc[len(cost)-1]-2*nc[i]) for i in range(len(cost))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666197,
                "title": "easy-concise-python-explanation-without-any-median-like-hard-concept",
                "content": "# Approach\\nHere is a simple example of my Approach:\\nLet the nums[] be - `[a,b,c]` & cost[] be - `[x,y,z]`\\nlet the number which the final nums[] be like - `n`(therefore, the nums[] will be `[n,n,n]`)\\n\\nThen the `res` will be: `(n-a)x + (n-b)y + (c-n)z`\\n> here, assuming `x` is between `b` and `c`\\n\\nNow, solving this we get:\\n`n(x+y-z) + (-(ax+by) + cz)` ...(1)\\n\\nNow, we can say that `x+y...` is a cummulative sum of `cost[]`\\nand `ax+by...` is a cummulative sum of `cost[]*nums[]`\\n\\nThus we can calculate the value of this equation (1) everytime for `i`, `0 to n-1` and find the minimum of this value.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n> Time complexity: $$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        n = len(cost)\\n        ll = sorted([[nums[i], cost[i]] for i in range(n)])\\n        c_cumm_sum = list(accumulate([ll[i][1] for i in range(n)]))\\n        nc_cumm_sum = list(accumulate([ll[i][0] * ll[i][1] for i in range(n)]))\\n\\n        res = float(\\'inf\\')\\n        for i in range(n):\\n            res = min(res, ll[i][0] * (c_cumm_sum[i] - (c_cumm_sum[n-1] - c_cumm_sum[i]))\\n                         + (-(nc_cumm_sum[i]) + (nc_cumm_sum[n-1] - nc_cumm_sum[i])))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        n = len(cost)\\n        ll = sorted([[nums[i], cost[i]] for i in range(n)])\\n        c_cumm_sum = list(accumulate([ll[i][1] for i in range(n)]))\\n        nc_cumm_sum = list(accumulate([ll[i][0] * ll[i][1] for i in range(n)]))\\n\\n        res = float(\\'inf\\')\\n        for i in range(n):\\n            res = min(res, ll[i][0] * (c_cumm_sum[i] - (c_cumm_sum[n-1] - c_cumm_sum[i]))\\n                         + (-(nc_cumm_sum[i]) + (nc_cumm_sum[n-1] - nc_cumm_sum[i])))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666173,
                "title": "minimum-cost-calculation-using-binary-search-easy-to-understand-simple-solution",
                "content": "# **If you find this solution helpful, please consider upvoting it to show your support and appreciation.**\\n# Intuition\\nThe problem can be solved using binary search. We can consider the range of possible target values by finding the minimum and maximum elements in the \\'nums\\' vector. Then, we perform binary search within this range to find the minimum cost.\\n\\n# Approach\\nDefine a  findCost, that calculates the cost for a given target value by iterating through the \\'nums\\' vector, summing the absolute difference between each element and the target, multiplied by the corresponding cost value.\\n\\n\\n\\nFind the minimum and maximum elements in the \\'nums\\' vector.\\n\\nPerform binary search within the range [start, end]:\\na. Calculate the mid value.\\nb. Calculate the costs for mid (cost1) and mid+1 (cost2) using the findCost helper function.\\nc. Update \\'ans\\' with the minimum of cost1 and cost2.\\nd. Update \\'start\\' or \\'end\\' based on the comparison of cost1 and cost2.\\n\\nReturn 0 if \\'ans\\' is still INT_MAX after the binary search; otherwise, return \\'ans\\'.\\n\\n\\n# Complexity\\n- Time complexity: O(log(maxValue - minValue) * N),\\n where N is the size of the \\'nums\\' vector and maxValue - minValue is the range of possible target values.\\n\\n\\n\\n\\n\\n- Space complexity: O(1),as we are using a constant amount of extra space.\\n\\n# Code \\n# Method-1\\n```\\nclass Solution {\\nprivate:\\n  typedef long long ll;\\n\\n   ll findCost(vector<int>& nums, vector<int>& cost,int target)\\n   {\\n       ll foundCost=0;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           foundCost+=(ll)abs(nums[i]-target)*cost[i];\\n       }\\n\\n       return foundCost;\\n\\n   }\\n\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll ans=INT_MAX;\\n        int start=*min_element(nums.begin(),nums.end());\\n        int end=*max_element(nums.begin(),nums.end());\\n\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n\\n            ll cost1=findCost(nums,cost,mid);\\n            ll cost2=findCost(nums,cost,mid+1);\\n      \\n            ans=min(cost1,cost2);\\n\\n            if(cost2>cost1)\\n              end=mid-1;\\n              else\\n               start=mid+1;\\n           \\n\\n        }\\n        if(ans==INT_MAX)\\n             return 0;\\n             else\\n              return ans;\\n        \\n    }\\n};\\n```\\n# Method-2\\n```\\nclass Solution {\\nprivate:\\n  typedef long long ll;\\n\\n   ll findCost(vector<pair<int,int>>&vec,int target)\\n   {\\n       ll foundCost=0;\\n       for(int i=0;i<vec.size();i++)\\n       {\\n           foundCost+=(ll)abs(vec[i].first-target)*vec[i].second;\\n       }\\n\\n       return foundCost;\\n\\n   }\\n\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll ans=INT_MAX;\\n          \\n            vector<pair<int,int>>vec; //{nums,cost}\\n            for(int i=0;i<nums.size();i++)\\n              vec.push_back({nums[i],cost[i]});\\n\\n              sort(vec.begin(), vec.end());  \\n\\n           int start=vec[0].first;\\n           int end=vec[vec.size()-1].first;\\n\\n        /*int start=*min_element(nums.begin(),nums.end());\\n        int end=*max_element(nums.begin(),nums.end());\\n        */\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n\\n            ll cost1=findCost(vec,mid);\\n            ll cost2=findCost(vec,mid+1);\\n      \\n            ans=min(cost1,cost2);\\n\\n            if(cost2>cost1)\\n              end=mid-1;\\n              else\\n               start=mid+1;\\n           \\n\\n        }\\n        if(ans==INT_MAX)\\n             return 0;\\n             else\\n              return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n  typedef long long ll;\\n\\n   ll findCost(vector<int>& nums, vector<int>& cost,int target)\\n   {\\n       ll foundCost=0;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           foundCost+=(ll)abs(nums[i]-target)*cost[i];\\n       }\\n\\n       return foundCost;\\n\\n   }\\n\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll ans=INT_MAX;\\n        int start=*min_element(nums.begin(),nums.end());\\n        int end=*max_element(nums.begin(),nums.end());\\n\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n\\n            ll cost1=findCost(nums,cost,mid);\\n            ll cost2=findCost(nums,cost,mid+1);\\n      \\n            ans=min(cost1,cost2);\\n\\n            if(cost2>cost1)\\n              end=mid-1;\\n              else\\n               start=mid+1;\\n           \\n\\n        }\\n        if(ans==INT_MAX)\\n             return 0;\\n             else\\n              return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n  typedef long long ll;\\n\\n   ll findCost(vector<pair<int,int>>&vec,int target)\\n   {\\n       ll foundCost=0;\\n       for(int i=0;i<vec.size();i++)\\n       {\\n           foundCost+=(ll)abs(vec[i].first-target)*vec[i].second;\\n       }\\n\\n       return foundCost;\\n\\n   }\\n\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll ans=INT_MAX;\\n          \\n            vector<pair<int,int>>vec; //{nums,cost}\\n            for(int i=0;i<nums.size();i++)\\n              vec.push_back({nums[i],cost[i]});\\n\\n              sort(vec.begin(), vec.end());  \\n\\n           int start=vec[0].first;\\n           int end=vec[vec.size()-1].first;\\n\\n        /*int start=*min_element(nums.begin(),nums.end());\\n        int end=*max_element(nums.begin(),nums.end());\\n        */\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n\\n            ll cost1=findCost(vec,mid);\\n            ll cost2=findCost(vec,mid+1);\\n      \\n            ans=min(cost1,cost2);\\n\\n            if(cost2>cost1)\\n              end=mid-1;\\n              else\\n               start=mid+1;\\n           \\n\\n        }\\n        if(ans==INT_MAX)\\n             return 0;\\n             else\\n              return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666129,
                "title": "expand-the-array-in-term-of-frequency",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, vector<int>& c) {\\n        int n = c.size();\\n        vector<pair<long long int , long long int >> v(n);\\n        \\n        for(int i =0;i<n;i++)\\n        {\\n            v[i] = {a[i],c[i]};\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        long long int l = 0;\\n        \\n        \\n        for(auto i: c)\\n            l+=i;\\n        \\n        long long int m ,curr;\\n        curr=0;\\n        for(int i=0;(i<n && curr<(l+1)/2);i++)\\n        {\\n            curr+=v[i].second;\\n            m = v[i].first;\\n        }\\n        \\n        long long int res = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long int d = (long long)abs((m-a[i]));\\n            res+=d*c[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, vector<int>& c) {\\n        int n = c.size();\\n        vector<pair<long long int , long long int >> v(n);\\n        \\n        for(int i =0;i<n;i++)\\n        {\\n            v[i] = {a[i],c[i]};\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        long long int l = 0;\\n        \\n        \\n        for(auto i: c)\\n            l+=i;\\n        \\n        long long int m ,curr;\\n        curr=0;\\n        for(int i=0;(i<n && curr<(l+1)/2);i++)\\n        {\\n            curr+=v[i].second;\\n            m = v[i].first;\\n        }\\n        \\n        long long int res = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long int d = (long long)abs((m-a[i]));\\n            res+=d*c[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666101,
                "title": "c-solution-using-median-and-converging-concept",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums,vector<int>& cost,long long median){\\n         \\n         long long res=0;\\n\\n         int n=nums.size();\\n\\n         for(int i=0;i<n;i++){\\n             res+=abs(1ll*nums[i]-median)*(1ll*cost[i]);\\n         }\\n     return res;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int n=nums.size();\\n\\n        long long int tot=0,elements=0;\\n\\n        vector<pair<int,int>> vec;\\n\\n        for(int i=0;i<n;i++){\\n            vec.push_back({nums[i],cost[i]});\\n        }\\n\\n        sort(vec.begin(),vec.end());\\n\\n        for(int i=0;i<n;i++){\\n            elements+=1ll*vec[i].second;\\n        }\\n\\n        long long median;\\n        int i=0;\\n\\n        while(tot<(elements+1)/2 && i<n){\\n            tot+=(1ll*vec[i].second);\\n            median=vec[i].first;\\n            i++;\\n        }\\n\\n        return solve(nums,cost,median);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& nums,vector<int>& cost,long long median){\\n         \\n         long long res=0;\\n\\n         int n=nums.size();\\n\\n         for(int i=0;i<n;i++){\\n             res+=abs(1ll*nums[i]-median)*(1ll*cost[i]);\\n         }\\n     return res;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int n=nums.size();\\n\\n        long long int tot=0,elements=0;\\n\\n        vector<pair<int,int>> vec;\\n\\n        for(int i=0;i<n;i++){\\n            vec.push_back({nums[i],cost[i]});\\n        }\\n\\n        sort(vec.begin(),vec.end());\\n\\n        for(int i=0;i<n;i++){\\n            elements+=1ll*vec[i].second;\\n        }\\n\\n        long long median;\\n        int i=0;\\n\\n        while(tot<(elements+1)/2 && i<n){\\n            tot+=(1ll*vec[i].second);\\n            median=vec[i].first;\\n            i++;\\n        }\\n\\n        return solve(nums,cost,median);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665935,
                "title": "c-super-easy-binary-search-on-answer-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long findCost(vector<int>& nums, vector<int>& cost, int cnvrt){\\n        long long ct = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            int oprt = abs(nums[i] - cnvrt);\\n            ct += 1LL * oprt * cost[i];\\n        }\\n        return ct;\\n    }\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int l = nums[0];\\n        int r = nums[0];\\n        for(auto it : nums){\\n            l = min(l,it);\\n            r = max(r,it);\\n        }\\n        long long ans = 0;\\n        while(l <= r){\\n            int mid = l + (r - l)/2;\\n\\n            long long c1 = findCost(nums,cost,mid);\\n            long long c2 = findCost(nums,cost,mid+1);\\n\\n            ans = min(c1,c2);\\n\\n            if(c1 < c2){\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long findCost(vector<int>& nums, vector<int>& cost, int cnvrt){\\n        long long ct = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            int oprt = abs(nums[i] - cnvrt);\\n            ct += 1LL * oprt * cost[i];\\n        }\\n        return ct;\\n    }\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int l = nums[0];\\n        int r = nums[0];\\n        for(auto it : nums){\\n            l = min(l,it);\\n            r = max(r,it);\\n        }\\n        long long ans = 0;\\n        while(l <= r){\\n            int mid = l + (r - l)/2;\\n\\n            long long c1 = findCost(nums,cost,mid);\\n            long long c2 = findCost(nums,cost,mid+1);\\n\\n            ans = min(c1,c2);\\n\\n            if(c1 < c2){\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665906,
                "title": "neat-explanation-greedy-sorting-c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mincost(vector<int>& nums,vector<int>& cost,int median){\\n        ll res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res+=1L*abs(nums[i]-median)*cost[i];\\n            // adding cost to result\\n        }\\n        return res;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll sum=0;\\n        vector<pair<int,int>>v;\\n        //lets assume that imaginary array with cost array as with cost 1 for all\\n        // test case 1: nums 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 5\\n        //              cost 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n        //lets make a pair between for nums and cost vectors\\n        for(int i=0;i<nums.size();i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        // sorting the nums values in pair vector\\n        sort(v.begin(),v.end());\\n        for(auto i:v){\\n            sum+=i.second;\\n        }\\n        ll total=0,median=0;\\n        int i=0;\\n        // searching for median value in the pair vector\\n        while(total<(sum+1)/2 && i<nums.size()){\\n            total+=v[i].second;\\n            median=v[i].first;\\n            i++;\\n        }\\n        return mincost(nums,cost,median);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll mincost(vector<int>& nums,vector<int>& cost,int median){\\n        ll res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res+=1L*abs(nums[i]-median)*cost[i];\\n            // adding cost to result\\n        }\\n        return res;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll sum=0;\\n        vector<pair<int,int>>v;\\n        //lets assume that imaginary array with cost array as with cost 1 for all\\n        // test case 1: nums 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 5\\n        //              cost 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n        //lets make a pair between for nums and cost vectors\\n        for(int i=0;i<nums.size();i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        // sorting the nums values in pair vector\\n        sort(v.begin(),v.end());\\n        for(auto i:v){\\n            sum+=i.second;\\n        }\\n        ll total=0,median=0;\\n        int i=0;\\n        // searching for median value in the pair vector\\n        while(total<(sum+1)/2 && i<nums.size()){\\n            total+=v[i].second;\\n            median=v[i].first;\\n            i++;\\n        }\\n        return mincost(nums,cost,median);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665848,
                "title": "java-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:   O(log(max - min) * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        long ans = Long.MAX_VALUE;\\n        int min  = 1000001;\\n        int max = 0;\\n\\n        // find min and max value in nums\\n        for(int i : nums){\\n            min = Math.min(min,i);\\n            max = Math.max(max,i);\\n        }\\n\\n        // search B/W min and max value\\n        while(min<=max){\\n            int mid = min+(max-min)/2;\\n            long costLeft = cost(nums,cost,mid-1);\\n            long costRight = cost(nums,cost,mid+1);\\n            long costMid = cost(nums,cost,mid);\\n\\n            // update ans for minimum cost\\n            ans = Math.min(costMid,ans);\\n            if(costMid<costLeft){\\n                min = mid+1;\\n            }\\n            if(costMid<costRight){\\n                max = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n    // cost of making every element = k\\n    long cost(int [] nums, int [] cost , int k){\\n        long res = 0;\\n        for(int i=0 ; i<nums.length ; i++ ){\\n            res+=((long)Math.abs(nums[i]-k))*cost[i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        long ans = Long.MAX_VALUE;\\n        int min  = 1000001;\\n        int max = 0;\\n\\n        // find min and max value in nums\\n        for(int i : nums){\\n            min = Math.min(min,i);\\n            max = Math.max(max,i);\\n        }\\n\\n        // search B/W min and max value\\n        while(min<=max){\\n            int mid = min+(max-min)/2;\\n            long costLeft = cost(nums,cost,mid-1);\\n            long costRight = cost(nums,cost,mid+1);\\n            long costMid = cost(nums,cost,mid);\\n\\n            // update ans for minimum cost\\n            ans = Math.min(costMid,ans);\\n            if(costMid<costLeft){\\n                min = mid+1;\\n            }\\n            if(costMid<costRight){\\n                max = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n    // cost of making every element = k\\n    long cost(int [] nums, int [] cost , int k){\\n        long res = 0;\\n        for(int i=0 ; i<nums.length ; i++ ){\\n            res+=((long)Math.abs(nums[i]-k))*cost[i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665809,
                "title": "c-finding-median-faster-beats-93",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=0;\\n        long long n=nums.size();\\n        long long sum=0;\\n        vector<pair<int, int>>v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i],cost[i]});\\n            sum+=cost[i];\\n        }\\n        sort(v.begin(),v.end());\\n\\n        long long target=0;\\n        long long cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            cnt+=v[i].second;\\n            if(cnt>sum/2) \\n            {\\n                target=v[i].first;\\n                break;\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++) ans+=abs(target-nums[i])*cost[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=0;\\n        long long n=nums.size();\\n        long long sum=0;\\n        vector<pair<int, int>>v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i],cost[i]});\\n            sum+=cost[i];\\n        }\\n        sort(v.begin(),v.end());\\n\\n        long long target=0;\\n        long long cnt=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            cnt+=v[i].second;\\n            if(cnt>sum/2) \\n            {\\n                target=v[i].first;\\n                break;\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++) ans+=abs(target-nums[i])*cost[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665760,
                "title": "weighted-median",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int> &nums, vector<int> &cost)\\n{\\n    int n = nums.size();\\n    vector<pair<long long, long long>> p(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n        p[i] = {nums[i], cost[i]};\\n    }\\n\\n    sort(p.begin(), p.end());\\n    long long totalele = 0;\\n    for (auto it : cost)\\n    {\\n        totalele += it;\\n    }\\n\\n    long long currsum = 0;\\n    int i = 0;\\n    long long median;\\n    while (currsum < (totalele + 1) / 2)\\n    {\\n        currsum += p[i].second;\\n        median = p[i].first;\\n        i++;\\n    }\\n\\n    long long ans = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        ans += (1LL * abs(median - p[i].first) * p[i].second);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int> &nums, vector<int> &cost)\\n{\\n    int n = nums.size();\\n    vector<pair<long long, long long>> p(n);\\n    for (int i = 0; i < n; i++)\\n    {\\n        p[i] = {nums[i], cost[i]};\\n    }\\n\\n    sort(p.begin(), p.end());\\n    long long totalele = 0;\\n    for (auto it : cost)\\n    {\\n        totalele += it;\\n    }\\n\\n    long long currsum = 0;\\n    int i = 0;\\n    long long median;\\n    while (currsum < (totalele + 1) / 2)\\n    {\\n        currsum += p[i].second;\\n        median = p[i].first;\\n        i++;\\n    }\\n\\n    long long ans = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        ans += (1LL * abs(median - p[i].first) * p[i].second);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665505,
                "title": "easy-c-code-2-approaches-binarysearch-weighted-median",
                "content": "### LinkedIn Profile : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1) for approach 1\\nO(n) for approach 2\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n## *1st Approach(Using Binary Search):-*\\n```\\nclass Solution {\\npublic:\\n    long minOper(vector<int>& nums, vector<int>& cost, int val){\\n        long minOP = 0;\\n        for(int i=0;i<cost.size();i++)\\n            minOP += abs(nums[i] - val) * (long)cost[i];\\n        return minOP;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size(), ll = 1, ul = 1e6, mid = 0;\\n        long ans = INT_MAX;\\n        while(ll <= ul){\\n            mid = (ll + ul) >> 1;\\n            long y1 = minOper(nums,cost,mid), y2 = minOper(nums,cost,mid+1);\\n            ans = min(y1,y2);\\n            if(y1 < y2)\\n                ul = mid - 1;\\n            else\\n                ll = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n## *2nd Approach(Using Weighted Median concept):-*\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        long count = 0,minCost = 0;;\\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            count += cost[i];\\n            vec.push_back({nums[i],cost[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        long med = (count+1)/2,x;\\n        for(auto [val,freq]:vec){\\n            med -= freq;\\n            if(med <= 0){\\n                x = val;\\n                break;\\n            }\\n        }\\n        for(auto [val,freq]:vec)\\n            minCost += abs(val - x)*(long)freq;\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long minOper(vector<int>& nums, vector<int>& cost, int val){\\n        long minOP = 0;\\n        for(int i=0;i<cost.size();i++)\\n            minOP += abs(nums[i] - val) * (long)cost[i];\\n        return minOP;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size(), ll = 1, ul = 1e6, mid = 0;\\n        long ans = INT_MAX;\\n        while(ll <= ul){\\n            mid = (ll + ul) >> 1;\\n            long y1 = minOper(nums,cost,mid), y2 = minOper(nums,cost,mid+1);\\n            ans = min(y1,y2);\\n            if(y1 < y2)\\n                ul = mid - 1;\\n            else\\n                ll = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        long count = 0,minCost = 0;;\\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            count += cost[i];\\n            vec.push_back({nums[i],cost[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        long med = (count+1)/2,x;\\n        for(auto [val,freq]:vec){\\n            med -= freq;\\n            if(med <= 0){\\n                x = val;\\n                break;\\n            }\\n        }\\n        for(auto [val,freq]:vec)\\n            minCost += abs(val - x)*(long)freq;\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665460,
                "title": "simpest-c-solution-weighted-median",
                "content": "**Explanation:**\\nIf we had cost array consisting of only 1s then target element(means when all elements of nums would be equal to an element called target) would be median of all elements of nums array and answer would be cost of converting all elements into the median element. As shown in https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/. \\nBut, here in this problem we have cost >1 or weighted cost for each element. For example when nums = [1, 3, 5, 2] and cost = [2, 3, 1, 14], it is same as saying when 1 is present 2 times, 3 is present 3 times, 5 is present 1 time and 2 is present 14 times in array means nums can be represented as: nums = [1, 1, 3, 3, 3, 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2].\\nWe find the weighted median of nums by sorting the (num, weight) pair of the original arrays. We then use the weighted median (x) to calculate the minimum total cost such that all the elements of the array nums becomes equal, which is the answer to this question.\\n\\n**Complexity**\\nTime Complexity: O(NlogN)\\nSpace Complexity: O(N), for the use of arr\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n long long minCost(vector<int>& nums, vector<int>& cost) {\\n       int n = nums.size();\\n       vector<pair<int,int>>arr;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           arr.push_back({nums[i],cost[i]});\\n           sum += cost[i];\\n       }\\n       sort(arr.begin(),arr.end());\\n       long long N = (sum+1)/2;\\n       int x = -1;\\n       for(int i=0;i<n;i++){\\n           N -= arr[i].second;\\n           if(N<=0){\\n            x = arr[i].first;\\n            break;\\n           }\\n       }\\n     long long ans = 0;\\n     for(int i=0;i<n;i++){\\n      ans += (long long)abs( (long long) x*cost[i]-(long long) nums[i]*cost[i]);   \\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n long long minCost(vector<int>& nums, vector<int>& cost) {\\n       int n = nums.size();\\n       vector<pair<int,int>>arr;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           arr.push_back({nums[i],cost[i]});\\n           sum += cost[i];\\n       }\\n       sort(arr.begin(),arr.end());\\n       long long N = (sum+1)/2;\\n       int x = -1;\\n       for(int i=0;i<n;i++){\\n           N -= arr[i].second;\\n           if(N<=0){\\n            x = arr[i].first;\\n            break;\\n           }\\n       }\\n     long long ans = 0;\\n     for(int i=0;i<n;i++){\\n      ans += (long long)abs( (long long) x*cost[i]-(long long) nums[i]*cost[i]);   \\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665359,
                "title": "easy-c-solution-explained-with-example-prefix-suffix-sum-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix and Suffix Sum\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s take this example to understand \\nInput: nums = [1,3,5,2], cost = [2,3,1,14]\\n\\nSort it\\nnums : [1,2,3,5]\\ncost: [2,14,3,1]\\n\\n- Use Prefix Sum to store the following.\\n\\nprefix of index = 0 will be 0 because no element before it.\\npre[0]=0;\\n\\n3 STEPS :\\n\\n- totCost=cost[0]\\n- pre[i]=pre[i-1]+(nums[i]-nums[i-1])*totCost;\\n- totCost+=cost[i];\\n\\nLike this ...\\n\\npre[1]=pre[0]+(2-1)*2\\npre[2]=pre[1]+(3-2)*(2+14)\\npre[3]=pre[2]+(5-3)*(2+14+3)\\n\\n- Use Suffix Sum to store the following.\\n\\nsuffix of index = n-1 will be 0 because no element after it.\\nsuf[3]=0\\n\\n3 STEPS :\\n\\n- totCost=cost[n-1]\\n- suf[i]=suf[i+1]+(nums[i+1]-nums[i])*totCost;\\n- totCost+=cost[i];\\n\\nLike this ...\\n\\nsuf[2]=suf[3]+(5-3)*1\\nsuf[1]=suf[2]+(3-2)*(1+3)\\nsuf[0]=suf[1]+(2-1)*(1+3+14)\\n\\n\\nAfter computing these values,\\nfind the minimum of suf[i]+pre[i] and return as that will be your answer.\\n\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long mn=LLONG_MAX;\\n        int n=cost.size();\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i],cost[i]});\\n        }\\n        int c=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            nums[c]=it.first;\\n            cost[c]=it.second;\\n            pq.pop(); \\n            c++;\\n        }\\n        vector<long long> pre(n);\\n        pre[0]=0;\\n        long long totCost=cost[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+(nums[i]-nums[i-1])*totCost;\\n            totCost+=cost[i];\\n        }\\n        totCost=cost[n-1];\\n        vector<long long> suf(n);\\n        suf[n-1]=0;\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+(nums[i+1]-nums[i])*totCost;\\n            totCost+=cost[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            mn=min(suf[i]+pre[i],mn);\\n        }\\n        return mn;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/7bfb5681-ef85-4112-85d5-339e6d4a9f1a_1687345996.2631822.png)\\n\\n\\nPlease upvote if found helpful!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long mn=LLONG_MAX;\\n        int n=cost.size();\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push({nums[i],cost[i]});\\n        }\\n        int c=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            nums[c]=it.first;\\n            cost[c]=it.second;\\n            pq.pop(); \\n            c++;\\n        }\\n        vector<long long> pre(n);\\n        pre[0]=0;\\n        long long totCost=cost[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+(nums[i]-nums[i-1])*totCost;\\n            totCost+=cost[i];\\n        }\\n        totCost=cost[n-1];\\n        vector<long long> suf(n);\\n        suf[n-1]=0;\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=suf[i+1]+(nums[i+1]-nums[i])*totCost;\\n            totCost+=cost[i];\\n        }\\n        for(int i=0;i<n;i++){\\n            mn=min(suf[i]+pre[i],mn);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665347,
                "title": "beats-99-27-fastest-and-easiest-c-code-sorting-median",
                "content": "![Screenshot 2023-06-21 163635.png](https://assets.leetcode.com/users/images/95d6190f-bdf0-4560-8d40-e7f72f666962_1687345774.8051214.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <chrono>\\n\\n// Don\\'t know what this is or how it works, but it cuts off 20ms\\nauto init = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    cout.tie(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n\\n       vector<pair<int,int>>v;\\n       for(int i=0;i<cost.size();i++)\\n       {\\n           v.push_back({nums[i],cost[i]});\\n\\n       }\\n       sort(v.begin(),v.end());\\n\\n       long long wa=0,median=0,total=0,ans=0;\\n       for(int i=0;i<cost.size();i++)\\n       {\\n           wa=wa+v[i].second;\\n       } \\n\\n       int i=0;\\n       while(total<(wa+1)/2 && i<nums.size())  //Just finding till total is < we i.e sum/2 or median weight\\n       {\\n           total+=v[i].second;\\n           median=v[i].first;\\n           i++;\\n       }\\n\\n       for(int i=0;i<cost.size();i++)\\n       {\\n           ans=ans+(abs(nums[i]-median)*cost[i]);\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n#include <chrono>\\n\\n// Don\\'t know what this is or how it works, but it cuts off 20ms\\nauto init = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    cout.tie(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n\\n       vector<pair<int,int>>v;\\n       for(int i=0;i<cost.size();i++)\\n       {\\n           v.push_back({nums[i],cost[i]});\\n\\n       }\\n       sort(v.begin(),v.end());\\n\\n       long long wa=0,median=0,total=0,ans=0;\\n       for(int i=0;i<cost.size();i++)\\n       {\\n           wa=wa+v[i].second;\\n       } \\n\\n       int i=0;\\n       while(total<(wa+1)/2 && i<nums.size())  //Just finding till total is < we i.e sum/2 or median weight\\n       {\\n           total+=v[i].second;\\n           median=v[i].first;\\n           i++;\\n       }\\n\\n       for(int i=0;i<cost.size();i++)\\n       {\\n           ans=ans+(abs(nums[i]-median)*cost[i]);\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3665287,
                "title": "2448-minimum-cost-to-make-array-equal",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        long long ans=LLONG_MAX;\\n        vector<pair<long long,long long>> v;\\n        for(int i=0;i<nums.size();i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        vector<long long> prfx(nums.size(),0);\\n        vector<long long> pc(nums.size(),0);\\n        prfx[0]=v[0].first*v[0].second;\\n        pc[0]=v[0].second;\\n        for(int i=1;i<nums.size();i++){\\n            prfx[i]=prfx[i-1]+(v[i].first*v[i].second);\\n            pc[i]=pc[i-1]+(v[i].second);\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            long long prcw=0,prc=0;\\n            long long ncw=0,nc=0;\\n            if(i>0){\\n                prcw=prfx[i-1];\\n                prc=pc[i-1];\\n            }\\n            if(i<nums.size()-1){\\n                ncw=prfx[nums.size()-1]-prfx[i];\\n                nc=pc[nums.size()-1]-pc[i];\\n            }\\n            \\n            prc=prc*v[i].first;\\n            nc=nc*v[i].first;\\n            \\n            \\n            long long temp=(ncw-nc)+(prc-prcw);\\n            ans=min(temp,ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        long long ans=LLONG_MAX;\\n        vector<pair<long long,long long>> v;\\n        for(int i=0;i<nums.size();i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        vector<long long> prfx(nums.size(),0);\\n        vector<long long> pc(nums.size(),0);\\n        prfx[0]=v[0].first*v[0].second;\\n        pc[0]=v[0].second;\\n        for(int i=1;i<nums.size();i++){\\n            prfx[i]=prfx[i-1]+(v[i].first*v[i].second);\\n            pc[i]=pc[i-1]+(v[i].second);\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            long long prcw=0,prc=0;\\n            long long ncw=0,nc=0;\\n            if(i>0){\\n                prcw=prfx[i-1];\\n                prc=pc[i-1];\\n            }\\n            if(i<nums.size()-1){\\n                ncw=prfx[nums.size()-1]-prfx[i];\\n                nc=pc[nums.size()-1]-pc[i];\\n            }\\n            \\n            prc=prc*v[i].first;\\n            nc=nc*v[i].first;\\n            \\n            \\n            long long temp=(ncw-nc)+(prc-prcw);\\n            ans=min(temp,ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665121,
                "title": "easy-to-understand-solution-using-median",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this question we can first think about solving a simpler problem, suppose that cost of all the elements are given as 1. \\n\\nAfter solving this simpler problem we can convert the current problem to a variation of the solved problem, let us suppose the given array is [ 1, 3, 5, 2 ] and the given cost array is [ 2, 3, 1, 6 ]  (*The test case has been changed a little for easy representation*)\\n\\nLike in the smaller problem we sort the array and maintain the order of costs as well, which then gives us :\\nArray : [1, 2, 3, 5]\\nCost  : [2, 6, 3, 1]\\n\\nNow we can convert this given array into an array with all elements with cost 1, which gives us the array\\nArray : [1,1,2,2,2,2,2,2,3,3,3,5] \\n\\nFrom this array we can figure out that the number of elements in this array will be the total sum of cost array, from this we can figure out where the median lies in the original array, and then we run a function to calculate the min cost to make our array equal to the median.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach follows the intuition, where we create a vector of integer pairs, with the array element as its first member and the cost as its second member, then we sort this vector of pairs.\\n\\nNext we simply check that if the expanded array will have even elements or odd elements, in case of even elements we return the minimum cost calculated using both median elements. \\n\\n# Note\\n\\nIt is important to note that the value of cost multiplied by the difference in the array elements may exceed the integer limit, so it is crucial that we store these in long long variables instead of integers, otherwise the value of integer will overflow.\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nMaking the vector of pairs : O(n)\\nSorting the vector of pairs : O(n*log(n))\\nSearch the median element : O(n/2)\\nFor caclulating the cost : O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    unsigned long long costcalc(int target, vector<pair<int,int>> &vec)\\n    {\\n        unsigned long long res = 0, res2, res3;\\n        for(int i = 0; i<vec.size(); i++)\\n        {\\n            res2= (abs(target-vec[i].first)) ;\\n            res3 = vec[i].second;\\n            res = res+res2*res3;\\n        }\\n        return res;\\n    }\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<int,int>> vec;\\n        long long sum = 0, sum2;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            sum+=cost[i];\\n            vec.push_back(make_pair(nums[i], cost[i]));\\n        }\\n        sort(vec.begin(), vec.end());\\n        if(sum%2)\\n        {\\n            sum2 = 0;\\n            for(int i = 0; i<nums.size(); i++)\\n            {\\n                sum2+=vec[i].second;\\n                if(sum2>(sum/2))\\n                {\\n                    return costcalc(vec[i].first, vec);\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            sum2 = 0; \\n            for(int i = 0; i<nums.size(); i++)\\n            {\\n                sum2+=vec[i].second;\\n                if(sum2==sum/2)\\n                {\\n                    return min( costcalc( vec[i].first, vec ), costcalc( vec[i+1].first, vec ) );\\n                    break;\\n                }\\n                if(sum2>sum/2)\\n                {\\n                    return costcalc(vec[i].first,vec);\\n                    break;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n## Please upvote if found useful \\uD83D\\uDD25\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unsigned long long costcalc(int target, vector<pair<int,int>> &vec)\\n    {\\n        unsigned long long res = 0, res2, res3;\\n        for(int i = 0; i<vec.size(); i++)\\n        {\\n            res2= (abs(target-vec[i].first)) ;\\n            res3 = vec[i].second;\\n            res = res+res2*res3;\\n        }\\n        return res;\\n    }\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<int,int>> vec;\\n        long long sum = 0, sum2;\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            sum+=cost[i];\\n            vec.push_back(make_pair(nums[i], cost[i]));\\n        }\\n        sort(vec.begin(), vec.end());\\n        if(sum%2)\\n        {\\n            sum2 = 0;\\n            for(int i = 0; i<nums.size(); i++)\\n            {\\n                sum2+=vec[i].second;\\n                if(sum2>(sum/2))\\n                {\\n                    return costcalc(vec[i].first, vec);\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            sum2 = 0; \\n            for(int i = 0; i<nums.size(); i++)\\n            {\\n                sum2+=vec[i].second;\\n                if(sum2==sum/2)\\n                {\\n                    return min( costcalc( vec[i].first, vec ), costcalc( vec[i+1].first, vec ) );\\n                    break;\\n                }\\n                if(sum2>sum/2)\\n                {\\n                    return costcalc(vec[i].first,vec);\\n                    break;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665064,
                "title": "go-sort-prefixsum",
                "content": "# Complexity\\n- Time complexity: $$O(4n + nlog(n))$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc minCost(nums []int, cost []int) int64 {\\n\\tn := len(nums)\\n\\tarr := make([][2]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tarr[i] = [2]int{nums[i], cost[i]}\\n\\t}\\n\\n\\tsort.Slice(arr, func(i, j int) bool { return arr[i][0] < arr[j][0] })\\n\\n\\tprefixCost := make([]int64, n)\\n\\tprefixCost[0] = int64(arr[0][1])\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tprefixCost[i] = prefixCost[i-1] + int64(arr[i][1])\\n\\t}\\n\\n\\tres := int64(0)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tres += (int64(arr[i][0]) - int64(arr[0][0])) * int64(arr[i][1])\\n\\t}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tjump := int64(arr[i][0] - arr[i-1][0])\\n\\t\\tres = min64(res, res-jump*prefixCost[n-1]+2*jump*int64(prefixCost[i-1]))\\n\\t}\\n\\treturn res\\n}\\n\\nfunc min64(a, b int64) int64 {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minCost(nums []int, cost []int) int64 {\\n\\tn := len(nums)\\n\\tarr := make([][2]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tarr[i] = [2]int{nums[i], cost[i]}\\n\\t}\\n\\n\\tsort.Slice(arr, func(i, j int) bool { return arr[i][0] < arr[j][0] })\\n\\n\\tprefixCost := make([]int64, n)\\n\\tprefixCost[0] = int64(arr[0][1])\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tprefixCost[i] = prefixCost[i-1] + int64(arr[i][1])\\n\\t}\\n\\n\\tres := int64(0)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tres += (int64(arr[i][0]) - int64(arr[0][0])) * int64(arr[i][1])\\n\\t}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tjump := int64(arr[i][0] - arr[i-1][0])\\n\\t\\tres = min64(res, res-jump*prefixCost[n-1]+2*jump*int64(prefixCost[i-1]))\\n\\t}\\n\\treturn res\\n}\\n\\nfunc min64(a, b int64) int64 {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664997,
                "title": "69-iq-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, cost: Vec<i32>) -> i64 {\\n        let mut num_cost = nums.into_iter().zip(cost.into_iter()).collect::<Vec<(i32, i32)>>();\\n        num_cost.sort_by(|a, b| a.0.cmp(&b.0));\\n        let mut sum = 0;\\n        let (mut cost_left, mut cost_right) = (num_cost[0].1 as i64, 0);\\n        for i in 1..num_cost.len() {\\n            sum += (num_cost[0].0 - num_cost[i].0).abs() as i64 * num_cost[i].1 as i64;\\n            cost_right += num_cost[i].1 as i64;\\n        }\\n\\n        let mut min = sum;\\n\\n        for i in 1..num_cost.len() {\\n            let val_diff = (num_cost[i].0 - num_cost[i - 1].0).abs() as i64;\\n            sum += (cost_left as i64 - cost_right as i64) * val_diff;\\n            cost_right -= num_cost[i].1 as i64;\\n            cost_left += num_cost[i].1 as i64;\\n\\n            min = min.min(sum);\\n        }\\n        \\n        min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, cost: Vec<i32>) -> i64 {\\n        let mut num_cost = nums.into_iter().zip(cost.into_iter()).collect::<Vec<(i32, i32)>>();\\n        num_cost.sort_by(|a, b| a.0.cmp(&b.0));\\n        let mut sum = 0;\\n        let (mut cost_left, mut cost_right) = (num_cost[0].1 as i64, 0);\\n        for i in 1..num_cost.len() {\\n            sum += (num_cost[0].0 - num_cost[i].0).abs() as i64 * num_cost[i].1 as i64;\\n            cost_right += num_cost[i].1 as i64;\\n        }\\n\\n        let mut min = sum;\\n\\n        for i in 1..num_cost.len() {\\n            let val_diff = (num_cost[i].0 - num_cost[i - 1].0).abs() as i64;\\n            sum += (cost_left as i64 - cost_right as i64) * val_diff;\\n            cost_right -= num_cost[i].1 as i64;\\n            cost_left += num_cost[i].1 as i64;\\n\\n            min = min.min(sum);\\n        }\\n        \\n        min\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664932,
                "title": "rust-search",
                "content": "```\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, cost: Vec<i32>) -> i64 {\\n\\n        if nums.iter().all(|&n| n == nums[0]) {\\n            return 0;\\n        }\\n\\n        let mut ids: Vec<usize> = (0..nums.len()).collect();\\n        ids.sort_unstable_by_key(|&i| nums[i]);\\n        let mut sum = vec![0; nums.len()];\\n        sum[0] = cost[ids[0]] as u64;\\n        for i in 1..nums.len() {\\n            sum[i] = sum[i - 1] + cost[ids[i]] as u64;\\n        }\\n\\n        let target = (sum[nums.len() - 1] - 1) / 2 + 1;\\n        let mut l = 0;\\n        let mut r = nums.len();\\n        while l < r {\\n            let mid = l + (r - l) / 2;\\n            if sum[mid] < target {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        let point = nums[ids[l]];\\n        \\n        nums\\n         .into_iter()\\n         .zip(cost.into_iter())\\n         .fold(0, |acc, (num, cost)| acc + (num - point).abs() as i64 * cost as i64)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, cost: Vec<i32>) -> i64 {\\n\\n        if nums.iter().all(|&n| n == nums[0]) {\\n            return 0;\\n        }\\n\\n        let mut ids: Vec<usize> = (0..nums.len()).collect();\\n        ids.sort_unstable_by_key(|&i| nums[i]);\\n        let mut sum = vec![0; nums.len()];\\n        sum[0] = cost[ids[0]] as u64;\\n        for i in 1..nums.len() {\\n            sum[i] = sum[i - 1] + cost[ids[i]] as u64;\\n        }\\n\\n        let target = (sum[nums.len() - 1] - 1) / 2 + 1;\\n        let mut l = 0;\\n        let mut r = nums.len();\\n        while l < r {\\n            let mid = l + (r - l) / 2;\\n            if sum[mid] < target {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        let point = nums[ids[l]];\\n        \\n        nums\\n         .into_iter()\\n         .zip(cost.into_iter())\\n         .fold(0, |acc, (num, cost)| acc + (num - point).abs() as i64 * cost as i64)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664805,
                "title": "java-binary-search-solution",
                "content": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        long min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n\\n        for (int num : nums) {\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n\\n        long answer = Long.MAX_VALUE;\\n\\n        while (min < max) {\\n            long mid = (max + min) / 2;\\n\\n            long midCost = getCostSum(mid, nums, cost);\\n            long nextMidCost = getCostSum(mid + 1, nums, cost);\\n\\n            answer = Math.min(midCost, nextMidCost);\\n            \\n            if (midCost > nextMidCost) {\\n                min = mid + 1;\\n            } else {\\n                max = mid;\\n            }\\n        }\\n\\n        return answer == Long.MAX_VALUE ? 0 : answer;\\n    }\\n\\n    private long getCostSum(long required, int[] nums, int[] cost) {\\n        long sum = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            long num = nums[i];\\n            long requiredIncOrDec = Math.abs(required - num);\\n            \\n            sum += ((long) (cost[i] * requiredIncOrDec));\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        long min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n\\n        for (int num : nums) {\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n\\n        long answer = Long.MAX_VALUE;\\n\\n        while (min < max) {\\n            long mid = (max + min) / 2;\\n\\n            long midCost = getCostSum(mid, nums, cost);\\n            long nextMidCost = getCostSum(mid + 1, nums, cost);\\n\\n            answer = Math.min(midCost, nextMidCost);\\n            \\n            if (midCost > nextMidCost) {\\n                min = mid + 1;\\n            } else {\\n                max = mid;\\n            }\\n        }\\n\\n        return answer == Long.MAX_VALUE ? 0 : answer;\\n    }\\n\\n    private long getCostSum(long required, int[] nums, int[] cost) {\\n        long sum = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            long num = nums[i];\\n            long requiredIncOrDec = Math.abs(required - num);\\n            \\n            sum += ((long) (cost[i] * requiredIncOrDec));\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664793,
                "title": "binary-search",
                "content": "# Intuition\\nBinary Search approach is not intuitive at first glance but when you try to plot the graph of f(x) (f(x) returns the cost of making all elements equal to x), you\\'ll notice that f(x) is convex and sum of convex functions is also convex.\\nF(x) = f1(x) + f2(x)............. is also convex. So we can apply binary search.\\n\\n# Approach\\nWe\\'ll apply binary search in range [min(nums),max(nums)], we can decrease the search space by calculating values of f(mid) and f(mid+1) and if f(mid) < f(mid+1) then e = mid-1 else s = mid+1.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int e = *max_element(nums.begin(),nums.end()), s = *min_element(nums.begin(),nums.end());\\n        ll ans = 0;\\n        while(s<=e) {\\n            int mid = s + (e-s)/2;\\n            ll val1 = f(nums,cost,mid), val2 = f(nums,cost,mid+1);\\n            ans = min(val1,val2);\\n            if(val1 < val2) {\\n                e = mid-1;\\n            }else s = mid+1;\\n        }\\n        return ans;\\n    }\\n\\n    ll f(vector<int>& nums, vector<int>& cost, int x) {\\n        ll ans = 0;\\n        for(int i=0 ; i<nums.size() ; ++i) {\\n            ans += abs(nums[i]-x)*1ll*cost[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int e = *max_element(nums.begin(),nums.end()), s = *min_element(nums.begin(),nums.end());\\n        ll ans = 0;\\n        while(s<=e) {\\n            int mid = s + (e-s)/2;\\n            ll val1 = f(nums,cost,mid), val2 = f(nums,cost,mid+1);\\n            ans = min(val1,val2);\\n            if(val1 < val2) {\\n                e = mid-1;\\n            }else s = mid+1;\\n        }\\n        return ans;\\n    }\\n\\n    ll f(vector<int>& nums, vector<int>& cost, int x) {\\n        ll ans = 0;\\n        for(int i=0 ; i<nums.size() ; ++i) {\\n            ans += abs(nums[i]-x)*1ll*cost[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664758,
                "title": "java-binary-search-explained",
                "content": "**Idea:**\\n* Minimum cost depends on much each number is far from the central number (x) and what is the associated cost to reach x. This implies weighted value of each number where the decision to choose it as x is determined both by its value and the associated cost\\n* x will be between [m, M] where m = min(nums), M = max(nums). Use binary search to find the cost to convert every number to x\\n* The further other numbers will be from x, the further their cost of conversion will be, thus the conversion cost function (f) will be a v-shape curve, whose minima is what we are interested in\\n* if f(t) < f(t+1), then this could be x, save it and keep looking to left of t as you could be on the right arm of the v-curve\\n* else if f(t) >= f(t+1), this means you\\'re on the left arm of the v-curve, this is not the point of interest so keep looking to the right\\n* Once x is found. return the cost for converting every nums[i] to it\\n>**T/S:** O(n lg r)/O(1), where n = size(nums), r = max(nums) - min(nums)\\n```\\npublic long minCost(int[] nums, int[] cost) {\\n\\tvar left = Arrays.stream(nums).min().getAsInt();\\n\\tvar right = Arrays.stream(nums).max().getAsInt();\\n\\tvar weightedMedian = 0;\\n\\n\\twhile (left <= right) {\\n\\t\\tvar mid = left + (right - left) / 2;\\n\\t\\tvar midCost = weightedCost(nums, cost, mid);\\n\\t\\tvar nextCost = weightedCost(nums, cost, mid + 1);\\n\\n\\t\\tif (midCost < nextCost) {\\n\\t\\t\\tweightedMedian = mid;\\n\\t\\t\\tright = mid - 1;\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn weightedCost(nums, cost, weightedMedian);\\n}\\n\\nprivate long weightedCost(int[] nums, int[] cost, int mid) {y\\n\\tvar distance = 0L;\\n\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\tdistance += (long) Math.abs(nums[i] - mid) * cost[i];\\n\\n\\treturn distance;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long minCost(int[] nums, int[] cost) {\\n\\tvar left = Arrays.stream(nums).min().getAsInt();\\n\\tvar right = Arrays.stream(nums).max().getAsInt();\\n\\tvar weightedMedian = 0;\\n\\n\\twhile (left <= right) {\\n\\t\\tvar mid = left + (right - left) / 2;\\n\\t\\tvar midCost = weightedCost(nums, cost, mid);\\n\\t\\tvar nextCost = weightedCost(nums, cost, mid + 1);\\n\\n\\t\\tif (midCost < nextCost) {\\n\\t\\t\\tweightedMedian = mid;\\n\\t\\t\\tright = mid - 1;\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn weightedCost(nums, cost, weightedMedian);\\n}\\n\\nprivate long weightedCost(int[] nums, int[] cost, int mid) {y\\n\\tvar distance = 0L;\\n\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\tdistance += (long) Math.abs(nums[i] - mid) * cost[i];\\n\\n\\treturn distance;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664740,
                "title": "clear-explanation-with-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCalculate the cost of converting all elements in the array to a common base as the base is being change and take the minimum cost for all bases. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can represent the cost of converting all elements to a common base with the fuction $f(x) = \\\\sum_{i=0}^{i=len(nums) - 1} cost_i \\\\cdot |nums_i - x|$. Now, if we knew which range of bases to consider, then we can find the minimum for this function fairly easily either with calculus or more algorithmic solutions. A thing to note is that the function ```f(x)``` is linear which makes it easy to visualize but because of the existence of absolute values, the shape of the function is such that there is a minimum value within the range $[min(nums), max(nums)]$. For example, consider the function $y = |x|,  -1 \\\\le x \\\\le 1$. This function has a v-shape, where the left side has a negative gradient and the right side has a positive gradient with the minimum being in the center.  \\n\\nNow that we know the range of possible values for the base, one of which will correspond to the lowest cost, we can use Binary Search to look for that base in the range. We set up the Binary Search as normal; initialize the left and right pointers, create a while loop which iterates while the pointers have not crossed each other, and calculate the midpoint. The midpoint here is the base that we will be testing. However, note that we want to find the region which contains the minimum cost. Naturally, this means that we want to shift our region to a section which discards the section of the range which has a positive gradient. That is, we need to check ```cost(mid)``` and ```cost(mid+1)```. If ```cost(mid) > cost(mid+1)```, then the left section of range has a positive gradient and therefore the minimum won\\'t be in that range. The same logic applies to the other case as well. \\n\\n# Complexity\\n- Time complexity: $O(n \\\\cdot \\\\log(n))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        \"\"\"\\n        Returns the minimum cost to make all element of the array equal. \\n\\n        Args: \\n            nums: List[int] = array of integers to be changed\\n            cost: List[int] = cost of changing each element in nums\\n        \\n        Returns:\\n            totalCost: int = the minimum cost to make the whole array equal\\n        \"\"\"\\n\\n        # We know that the final array will have only one distinct element. \\n        # We also know that this element is already present in the array and \\n        # so we can set our search range to be between the minumum and maximum\\n        # values of nums.\\n        left, right = min(nums), max(nums)\\n\\n        # We just need to initialize a totalCost variable\\n        totalCost = 0\\n\\n        # Now we Binary Search over the current range.\\n        while left < right:\\n            # We get the midpoint. This is the value that we will\\n            # change all other elements in nums to. \\n            mid = (left + right) // 2\\n\\n            # We need to calculate two values to determine the direction\\n            # in which the totalCost is moving\\n            cost1 = self.calculateCost(mid, nums, cost)\\n            cost2 = self.calculateCost(mid+1, nums, cost)\\n\\n            # We make our totalCost to be the minimum of the costs we\\n            # see\\n            totalCost = min(cost1, cost2)\\n\\n            # If Cost1 is greater, that means that the area to the left\\n            # of mid is increasing and therefore the minimum cost won\\'t be \\n            # found here and we can adjust our search area to the right. By\\n            # the same logic, we can adjust the search area to the left if \\n            # the area to the right of mid is increasing. \\n            if cost1 > cost2:\\n                left = mid + 1 \\n            else:\\n                right = mid \\n    \\n        # Now that we have arrived at the minimum cost, we can return the\\n        # result\\n        return totalCost\\n    \\n    def calculateCost(self, value: int, nums: List[int], cost: List[int]) -> int:\\n        \"\"\"\\n        Returns the cost of changing all elements in nums\\n        to value, based on the cost. \\n\\n        Args:\\n            value: int = desired value\\n            nums: List[int] = array of integers\\n            cost: List[int] = cost of changing each element in nums\\n        \"\"\"\\n\\n        # Initialize cost to 0\\n        total = 0\\n\\n        # For each num in nums, we get the difference between num and the\\n        # desired value and multiply it by its cost to get the cost of\\n        # changing the current element to match value. \\n        for num, price in zip(nums, cost):\\n            total += (abs(num - value) * price)\\n        \\n        # Return the total cost\\n        return total \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```f(x)```\n```cost(mid)```\n```cost(mid+1)```\n```cost(mid) > cost(mid+1)```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        \"\"\"\\n        Returns the minimum cost to make all element of the array equal. \\n\\n        Args: \\n            nums: List[int] = array of integers to be changed\\n            cost: List[int] = cost of changing each element in nums\\n        \\n        Returns:\\n            totalCost: int = the minimum cost to make the whole array equal\\n        \"\"\"\\n\\n        # We know that the final array will have only one distinct element. \\n        # We also know that this element is already present in the array and \\n        # so we can set our search range to be between the minumum and maximum\\n        # values of nums.\\n        left, right = min(nums), max(nums)\\n\\n        # We just need to initialize a totalCost variable\\n        totalCost = 0\\n\\n        # Now we Binary Search over the current range.\\n        while left < right:\\n            # We get the midpoint. This is the value that we will\\n            # change all other elements in nums to. \\n            mid = (left + right) // 2\\n\\n            # We need to calculate two values to determine the direction\\n            # in which the totalCost is moving\\n            cost1 = self.calculateCost(mid, nums, cost)\\n            cost2 = self.calculateCost(mid+1, nums, cost)\\n\\n            # We make our totalCost to be the minimum of the costs we\\n            # see\\n            totalCost = min(cost1, cost2)\\n\\n            # If Cost1 is greater, that means that the area to the left\\n            # of mid is increasing and therefore the minimum cost won\\'t be \\n            # found here and we can adjust our search area to the right. By\\n            # the same logic, we can adjust the search area to the left if \\n            # the area to the right of mid is increasing. \\n            if cost1 > cost2:\\n                left = mid + 1 \\n            else:\\n                right = mid \\n    \\n        # Now that we have arrived at the minimum cost, we can return the\\n        # result\\n        return totalCost\\n    \\n    def calculateCost(self, value: int, nums: List[int], cost: List[int]) -> int:\\n        \"\"\"\\n        Returns the cost of changing all elements in nums\\n        to value, based on the cost. \\n\\n        Args:\\n            value: int = desired value\\n            nums: List[int] = array of integers\\n            cost: List[int] = cost of changing each element in nums\\n        \"\"\"\\n\\n        # Initialize cost to 0\\n        total = 0\\n\\n        # For each num in nums, we get the difference between num and the\\n        # desired value and multiply it by its cost to get the cost of\\n        # changing the current element to match value. \\n        for num, price in zip(nums, cost):\\n            total += (abs(num - value) * price)\\n        \\n        # Return the total cost\\n        return total \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664678,
                "title": "minutely-detailed-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is although pretty easy to do a O(n^2) solution by traversing the array for each index and finding the minimum cost. Hence to run it down to a O(n) solution, it was intuitive to iterate through the array from start to end only once while updating the answer according to the minimum cost each time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to make sure the array is only iterated through once, the nums is sorted so that from moving from an index to its right, a sum of all the costs from the left multiplied by the current difference is added, as the current nums is increasing. The current difference is a variable named curr in the code.\\n Similarly, the sum of costs to the right is multiplied by the current difference as all those costs will decrease if nums increases and is hence subtracted. A variable named now will be updated to prev each time through the loop as the changes are continuous and with respect to the last value.\\nFor this, a pair of vectors is sorted with the nums as the first of the pair.\\nTwo prefix sum arrays are used to have the left and right sums for an index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<long long,long long>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long ans=0;\\n        long long pfix1[n+1],pfix2[n+1];\\n        pfix1[0]=0;\\n        for(int i=0;i<n;i++){\\n            pfix1[i+1]=pfix1[i]+v[i].second;\\n        }\\n        pfix2[n]=0;\\n        for(int i=n-1;i>=0;i--){\\n            pfix2[i]=pfix2[i+1]+v[i].second;\\n        }\\n        //initial ans in order to update in next iteration.\\n        for(int i=0;i<n;i++){\\n            ans+=(v[i].first-v[0].first)*v[i].second;\\n        }\\n        long long f=v[0].first;\\n        long long prev,now; //now will be updated to prev each time.\\n        prev=ans;\\n        for(int i=1;i<n;i++){\\n            long long curr=v[i].first-f; //curr is the difference in nums each time \\n            now=prev;\\n            now+=pfix1[i]*curr;\\n            now-=pfix2[i]*curr;\\n            ans=min(ans,now);\\n            prev=now;\\n            f=v[i].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<long long,long long>> v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long ans=0;\\n        long long pfix1[n+1],pfix2[n+1];\\n        pfix1[0]=0;\\n        for(int i=0;i<n;i++){\\n            pfix1[i+1]=pfix1[i]+v[i].second;\\n        }\\n        pfix2[n]=0;\\n        for(int i=n-1;i>=0;i--){\\n            pfix2[i]=pfix2[i+1]+v[i].second;\\n        }\\n        //initial ans in order to update in next iteration.\\n        for(int i=0;i<n;i++){\\n            ans+=(v[i].first-v[0].first)*v[i].second;\\n        }\\n        long long f=v[0].first;\\n        long long prev,now; //now will be updated to prev each time.\\n        prev=ans;\\n        for(int i=1;i<n;i++){\\n            long long curr=v[i].first-f; //curr is the difference in nums each time \\n            now=prev;\\n            now+=pfix1[i]*curr;\\n            now-=pfix2[i]*curr;\\n            ans=min(ans,now);\\n            prev=now;\\n            f=v[i].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664646,
                "title": "binary-search-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThink About brute force method and how we can optimize it.\\n**Brute Force Method :-**\\nArr = [1,2,3], Cost = [2,1,3]\\n**total cost** = |1-**x**|*2 + |2-**x**|*1 + |3-**x**|*3\\nto minimize the totalcost find out the optimal value of x and x belongs to range [minimum(Arr) , maximum(Arr)].\\n\\nRun a for loop from minimum to maximum and find out the value of x.\\n\\n**Optimization using Binary Search:-**\\napply binary search between minimum and maximum and calculate the value of x.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*log(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long calcost(vector<int> arr,vector<int> cost,long long mid)\\n    {\\n       long long c = 0;\\n       for(int i = 0;i<arr.size();i++)\\n       c+=abs((long long)arr[i]-mid)*cost[i];\\n       \\n       return c;\\n    }\\n    long long minCost(vector<int>& arr, vector<int>& cost) {\\n        int n = arr.size();\\n        long long left = arr[0],right = arr[0],mid,ans = LONG_MAX;\\n        for(auto x : arr)\\n        {\\n            left = min(left,(long long)x);\\n            right = max(right,(long long)x);\\n        }\\n        while(left<=right)\\n        {\\n           mid = (left+right)/2;\\n           long long c1 = calcost(arr,cost,mid);\\n           long long c2 = calcost(arr,cost,mid+1);\\n           ans = min(ans,min(c1,c2));\\n\\n           if(c1>c2)\\n           left = mid+1;\\n           else\\n           right = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ab454e95-25db-4471-882f-76713fd5c31c_1687332539.9347105.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long calcost(vector<int> arr,vector<int> cost,long long mid)\\n    {\\n       long long c = 0;\\n       for(int i = 0;i<arr.size();i++)\\n       c+=abs((long long)arr[i]-mid)*cost[i];\\n       \\n       return c;\\n    }\\n    long long minCost(vector<int>& arr, vector<int>& cost) {\\n        int n = arr.size();\\n        long long left = arr[0],right = arr[0],mid,ans = LONG_MAX;\\n        for(auto x : arr)\\n        {\\n            left = min(left,(long long)x);\\n            right = max(right,(long long)x);\\n        }\\n        while(left<=right)\\n        {\\n           mid = (left+right)/2;\\n           long long c1 = calcost(arr,cost,mid);\\n           long long c2 = calcost(arr,cost,mid+1);\\n           ans = min(ans,min(c1,c2));\\n\\n           if(c1>c2)\\n           left = mid+1;\\n           else\\n           right = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664559,
                "title": "very-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n#define ll long long\\npublic:\\nll Cost(ll mid, vector<int>&v, vector<int>&c){\\n    ll sum = 0;\\n    for(int i = 0;i<v.size();i++){\\n         sum += abs(v[i]-mid)*c[i];\\n    }\\n    return sum;\\n}\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll ans = LONG_MAX;\\n        ll mn = *min_element(nums.begin(),nums.end());\\n        ll mx = *max_element(nums.begin(),nums.end());\\n        while(mn<=mx){\\n            ll mid = (mn+mx)/2;\\n            ll sum = Cost(mid,nums,cost);\\n            ans = min(ans,sum);\\n            ll sum1 = Cost(mid-1,nums,cost);\\n            ll sum2 = Cost(mid+1,nums,cost);\\n            if(sum <= sum1 && sum <= sum2) break;\\n            if(sum1 < sum2){\\n                ans = sum1;\\n                mx = mid-1;\\n            }\\n            else{\\n                ans = sum2;\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n#define ll long long\\npublic:\\nll Cost(ll mid, vector<int>&v, vector<int>&c){\\n    ll sum = 0;\\n    for(int i = 0;i<v.size();i++){\\n         sum += abs(v[i]-mid)*c[i];\\n    }\\n    return sum;\\n}\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll ans = LONG_MAX;\\n        ll mn = *min_element(nums.begin(),nums.end());\\n        ll mx = *max_element(nums.begin(),nums.end());\\n        while(mn<=mx){\\n            ll mid = (mn+mx)/2;\\n            ll sum = Cost(mid,nums,cost);\\n            ans = min(ans,sum);\\n            ll sum1 = Cost(mid-1,nums,cost);\\n            ll sum2 = Cost(mid+1,nums,cost);\\n            if(sum <= sum1 && sum <= sum2) break;\\n            if(sum1 < sum2){\\n                ans = sum1;\\n                mx = mid-1;\\n            }\\n            else{\\n                ans = sum2;\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664478,
                "title": "c-easy-to-understand-median-concept",
                "content": "# Intuition and Approach\\n1.Create a vector of pairs v to store each element of nums along with its corresponding cost. The pairs are created by iterating over both nums and cost simultaneously.\\n\\n2.Sort the vector v in ascending order based on the values of nums. This step ensures that elements with smaller values in nums come first in the sorted vector.\\n\\n3.Calculate the total cost x by summing up all the costs in the sorted vector v.\\n\\n4.Initialize variables total, value, and i to 0. The total variable represents the running sum of costs, value stores the current value from nums, and i is used to iterate over the elements of v.\\n\\n5.Iterate over the sorted vector v until the total cost total exceeds or equals half of x + 1 (the midpoint). At each iteration, update total by adding the cost of the current element and store the corresponding value in value. This step determines the value that will be repeated in the modified nums array.\\n\\n6.Initialize costi to 0, which will store the final minimum cost.\\n\\n7.Iterate over nums and cost arrays. Calculate the absolute difference between the current element in nums and value, and multiply it by the corresponding cost from the cost array. Add this value to costi.\\n\\n8.Return the final minimum cost costi\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\nThe time complexity of this code is determined by the sorting step, which has a complexity of O(n log n) since the sort function is used. The rest of the operations in the code have a linear time complexity, O(n), as they involve iterating over the arrays. Therefore, the overall time complexity is O(n log n) due to the sorting operation.\\n\\n- Space complexity:O(n)\\nThe space complexity of this code is O(n) because the vector v is created to store the pairs of elements from nums and cost.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long int n=nums.size();\\n        n=cost.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long int x=0;\\n        for(int i=0;i<n;i++){\\n            x=x+(long long int )v[i].second;\\n        }\\n        long long int total=0;\\n        long long int value;\\n        int i=0;\\n        while(total<(x+1)/2 && i<n){\\n            total=total+(long long int)v[i].second;\\n            value=v[i].first;\\n            i++;\\n        }\\n        long long int costi=0;\\n        for(int i=0;i<n;i++){\\n            nums[i]=abs(value-nums[i]);\\n            costi=costi+(long long int)nums[i]*(long long int)cost[i];\\n\\n        }\\n        return costi;\\n\\n\\n        \\n    }\\n};\\n\\n\\n#PLEASE UPVOTE !!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long int n=nums.size();\\n        n=cost.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long int x=0;\\n        for(int i=0;i<n;i++){\\n            x=x+(long long int )v[i].second;\\n        }\\n        long long int total=0;\\n        long long int value;\\n        int i=0;\\n        while(total<(x+1)/2 && i<n){\\n            total=total+(long long int)v[i].second;\\n            value=v[i].first;\\n            i++;\\n        }\\n        long long int costi=0;\\n        for(int i=0;i<n;i++){\\n            nums[i]=abs(value-nums[i]);\\n            costi=costi+(long long int)nums[i]*(long long int)cost[i];\\n\\n        }\\n        return costi;\\n\\n\\n        \\n    }\\n};\\n\\n\\n#PLEASE UPVOTE !!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664439,
                "title": "easy-intuitive-solution-based-on-prefix-sum-and-sorting",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first sort the nums array and this makes sure that if we are at a particular index say i, then to convert all numbers in the array with index < i to nums[i], then we must increase those numbers and all numbers in the array with index > i, then we must decrase those numbers. Let\\'s say we are at an index i, then the cost to decrease elements before i can be given by summation of (nums[i]-nums[j]) * cost[j] for all j>=0 and j<i.Similarly to increase the elements after i, the cost is given by summation of (nums[j]-nums[i]) * cost[j] for all j>i and j<n. The total cost is cost to decrease + cost to increase. \\n\\nIf we do this naively, then it will take O(n^2), but we can make use of prefix sums. We keep 2 prefix sum arrays, one is the costPrefix array and other is combinedPrefix array. costPrefix[i] stores the sum of cost till index i. combinedPrefix[i] stores the sum of (cost[i]*nums[i]). \\n\\nIf you simplify the above expressions of cost to increase then it can be given by incCost = costPrefix[i-1]*p[i].first-combinedPrefix[i-1] (USE PEN AND PAPER TO VERIFY). Similarly the simplified expression for cost to decrease is decCost = (combinedPrefix[n-1]-combinedPrefix[i])-(costPrefix[n-1]-costPrefix[i])*p[i].first.\\n\\nWe simply have to take the minimum among all costs.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)+O(n) which is approximately O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) due tt prefix arrays and pair\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<long,long>> p(n);\\n\\n        for(int i = 0;i<n;i++){\\n            p[i].first = (long long)nums[i];\\n            p[i].second =(long long) cost[i];\\n        }\\n\\n        sort(p.begin(),p.end());\\n        vector<long long> costPrefix(n);\\n        vector<long long > combinedPrefix(n);\\n\\n        costPrefix[0] = p[0].second;\\n        combinedPrefix[0] = (1LL)*(p[0].first*p[0].second);\\n\\n        for(int i = 1;i<n;i++){\\n            costPrefix[i] = costPrefix[i-1]+p[i].second;\\n            combinedPrefix[i] = (1LL)*combinedPrefix[i-1]+(1LL)*(p[i].first*p[i].second);\\n        }\\n\\n        long long ans = LONG_MAX;\\n\\n        for(int i = 0;i<n;i++){\\n            long long incCost = 0;\\n            if(i>0){\\n                incCost = costPrefix[i-1]*p[i].first-combinedPrefix[i-1];\\n            }\\n            long long decCost = 0;\\n            if(i<n){\\n                decCost = (combinedPrefix[n-1]-combinedPrefix[i])-(costPrefix[n-1]-costPrefix[i])*p[i].first;\\n            }\\n\\n            long long cost = incCost+decCost;\\n            ans = min(ans,cost);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<long,long>> p(n);\\n\\n        for(int i = 0;i<n;i++){\\n            p[i].first = (long long)nums[i];\\n            p[i].second =(long long) cost[i];\\n        }\\n\\n        sort(p.begin(),p.end());\\n        vector<long long> costPrefix(n);\\n        vector<long long > combinedPrefix(n);\\n\\n        costPrefix[0] = p[0].second;\\n        combinedPrefix[0] = (1LL)*(p[0].first*p[0].second);\\n\\n        for(int i = 1;i<n;i++){\\n            costPrefix[i] = costPrefix[i-1]+p[i].second;\\n            combinedPrefix[i] = (1LL)*combinedPrefix[i-1]+(1LL)*(p[i].first*p[i].second);\\n        }\\n\\n        long long ans = LONG_MAX;\\n\\n        for(int i = 0;i<n;i++){\\n            long long incCost = 0;\\n            if(i>0){\\n                incCost = costPrefix[i-1]*p[i].first-combinedPrefix[i-1];\\n            }\\n            long long decCost = 0;\\n            if(i<n){\\n                decCost = (combinedPrefix[n-1]-combinedPrefix[i])-(costPrefix[n-1]-costPrefix[i])*p[i].first;\\n            }\\n\\n            long long cost = incCost+decCost;\\n            ans = min(ans,cost);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664355,
                "title": "100-time-python3-solution-a-easy-math-perspective",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s say we make all the numbers equal to x. Then for each number in nums, the corresponding total cost is |a1-x| * c1, where `a1 = nums[1]` and `c1 = cost[1]`.\\n\\nAnd then:\\n> Consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on..\\n\\nSource: By user @sigmale in the discussion section.\\n\\nSo c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| will be:\\n|a1-x| + |a1-x| + |a1-x| + ... + |a1-x| + |a2-x| + ...\\n^-----------------c1-----------------^\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Traverse both array, save nums (key) and cost (value) in a hash table\\n- Sort the nums array and remove duplicates (Or use the sorted keys in the hash table)\\n- Use the sorted array, find the number where median occur, median occurs at where the prefix sum of frequencies is greater than `sum(cost) // 2`\\n- Use that number to calculate total cost, then we\\'re done!\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\ log n)$$ due to sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        freq = {}\\n        stop = sum(cost) // 2\\n        for n,c in zip(nums, cost):\\n            freq[n] = freq.get(n,0) + c\\n        \\n        keys = sorted(list(freq.keys()))\\n        s = 0\\n        for k in keys:\\n            s += freq[k]\\n            if s > stop:\\n                break\\n        \\n        result = 0\\n        for n,c in zip(nums, cost):\\n            result += abs(n - k) * c\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python []\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        freq = {}\\n        stop = sum(cost) // 2\\n        for n,c in zip(nums, cost):\\n            freq[n] = freq.get(n,0) + c\\n        \\n        keys = sorted(list(freq.keys()))\\n        s = 0\\n        for k in keys:\\n            s += freq[k]\\n            if s > stop:\\n                break\\n        \\n        result = 0\\n        for n,c in zip(nums, cost):\\n            result += abs(n - k) * c\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664350,
                "title": "c-easy-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is a bit similar to the problem for finding minimum cost to make array equal with each having the equal cost.\\nDifference here is that the array is weighted.\\n\\nWe can write array:\\nnums = [1,3,5,2] \\ncost = [2,3,1,14]\\nas:-\\nnums = [1,1,3,3,3,5,2,2,2,......14 times]\\n\\nMeans the cost represents the count of that number in array.\\n\\nSo now it became the same problem array with same and equal cost = 1. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple....\\nIf cost is equal for incrementing/decrementing the element.\\n\\nNow we have to make all elements equal.\\nso Sort the nums such that cost will be arranged in their respective way too. \\nnow From two extremes position we will meet at the median.\\nAnd we will make all element = median for minimum cost.\\nthus:- \\nCost for changing a element at index i:- **abs(nums[i]-median)*cost[i]**;\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum += v[i].second;\\n        }\\n        sum = (sum + 1)/2;\\n        long long total = 0;\\n        int i = 0;\\n        long long median;\\n        while(total<sum && i<n)\\n        {\\n            total+=v[i].second;\\n            median = v[i].first;\\n            i++;\\n        }\\n        long long ans = 0;\\n        for(i= 0;i<n;i++)\\n        {\\n            ans+=1L * abs(v[i].first-median) * v[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please UPVOTE if helped.... \\uD83D\\uDC4D\\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i],cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        long long sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum += v[i].second;\\n        }\\n        sum = (sum + 1)/2;\\n        long long total = 0;\\n        int i = 0;\\n        long long median;\\n        while(total<sum && i<n)\\n        {\\n            total+=v[i].second;\\n            median = v[i].first;\\n            i++;\\n        }\\n        long long ans = 0;\\n        for(i= 0;i<n;i++)\\n        {\\n            ans+=1L * abs(v[i].first-median) * v[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664297,
                "title": "c-sorting-median-concept-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n * log(n))\\n\\n- Space complexity:\\no(2 * n)\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll i,n=nums.size(),sum=0,tot=0,md;\\n        vector<pair<ll,ll>> v;\\n        for(i=0;i<n;i++){\\n        v.push_back({nums[i],cost[i]}); sum+=cost[i];}\\n        sort(v.begin(),v.end());\\n        md=v[n-1].first;\\n        for(i=0;i<n;i++)\\n        {\\n            tot+=v[i].second;\\n            if(tot>sum/2)\\n            {\\n                md=v[i].first;\\n                break;\\n            }\\n        }\\n        ll ans=0;\\n        for(i=0;i<n;i++)\\n        {\\n            ans+=abs(md-v[i].first)*v[i].second;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Probability and Statistics"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        ll i,n=nums.size(),sum=0,tot=0,md;\\n        vector<pair<ll,ll>> v;\\n        for(i=0;i<n;i++){\\n        v.push_back({nums[i],cost[i]}); sum+=cost[i];}\\n        sort(v.begin(),v.end());\\n        md=v[n-1].first;\\n        for(i=0;i<n;i++)\\n        {\\n            tot+=v[i].second;\\n            if(tot>sum/2)\\n            {\\n                md=v[i].first;\\n                break;\\n            }\\n        }\\n        ll ans=0;\\n        for(i=0;i<n;i++)\\n        {\\n            ans+=abs(md-v[i].first)*v[i].second;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664277,
                "title": "ruby-divide-and-conquer-t-s-o-n-log-n-o-n",
                "content": "# Intuition\\nDivide and Conquer\\n\\n# Approach\\nDivide and Conquer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```ruby\\nclass Solver\\n    attr_reader :nums, :cost, :nc\\n\\n    def initialize(nums, cost)\\n        @nums, @cost, @nc = nums, cost, nums.zip(cost)\\n    end\\n\\n    def calc(v) = nc.inject(0) {|res, (n, c)| res + (n - v).abs * c }\\n\\n    def solve\\n        l, r = nums.minmax\\n        ans = 0\\n        while l < r do\\n            mid = (l + r) / 2\\n            c = [0, 1].collect {|d| calc(mid + d) }\\n            if (ans = c.min) == c.last then\\n                l = mid + 1\\n            else\\n                r = mid\\n            end\\n        end\\n        ans\\n    end\\nend\\n\\ndef min_cost(nums, cost)\\n    Solver.new(nums, cost).solve\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass Solver\\n    attr_reader :nums, :cost, :nc\\n\\n    def initialize(nums, cost)\\n        @nums, @cost, @nc = nums, cost, nums.zip(cost)\\n    end\\n\\n    def calc(v) = nc.inject(0) {|res, (n, c)| res + (n - v).abs * c }\\n\\n    def solve\\n        l, r = nums.minmax\\n        ans = 0\\n        while l < r do\\n            mid = (l + r) / 2\\n            c = [0, 1].collect {|d| calc(mid + d) }\\n            if (ans = c.min) == c.last then\\n                l = mid + 1\\n            else\\n                r = mid\\n            end\\n        end\\n        ans\\n    end\\nend\\n\\ndef min_cost(nums, cost)\\n    Solver.new(nums, cost).solve\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664269,
                "title": "c-binary-search",
                "content": "# Intuition\\nThink thoroughly on the paper and you will get a monotonic function like it will keep on decresing to some point than after that it will increase forever.\\nWe have to find that lowest poinst. Therefore Binary Search will help us\\n\\n# Approach\\nInitialise low = 0, hi = max_element(in the array nums).\\nNow till low <= hi , take a mid and check if the solve(mid) <= solve(mid+1) then ans = solve(mid) and hi = mid-1,  else lo = mid+1;\\n\\n\\n# Complexity\\n- Time complexity: ~ O(NlogN)\\n\\n- Space complexity:\\nNo extra space is used => O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int mid, vector<int> &nums, vector<int> &cost){\\n        long long  ans = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<n; i++){\\n            ans += (long long) abs(mid - nums[i]) * cost[i];\\n        }\\n        return ans;\\n\\n    }\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        int low = 0, hi = *max_element(nums.begin(), nums.end());\\n        while(low <= hi){\\n            int mid = low + (hi - low)/2;\\n            if(solve(mid, nums, cost) <= solve(mid+1, nums, cost)){\\n                hi = mid-1;\\n                ans = solve(mid, nums, cost);\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int mid, vector<int> &nums, vector<int> &cost){\\n        long long  ans = 0;\\n        int n = nums.size();\\n        for(int i = 0; i<n; i++){\\n            ans += (long long) abs(mid - nums[i]) * cost[i];\\n        }\\n        return ans;\\n\\n    }\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        int low = 0, hi = *max_element(nums.begin(), nums.end());\\n        while(low <= hi){\\n            int mid = low + (hi - low)/2;\\n            if(solve(mid, nums, cost) <= solve(mid+1, nums, cost)){\\n                hi = mid-1;\\n                ans = solve(mid, nums, cost);\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664227,
                "title": "simple-cpp-3",
                "content": "# Intuition\\nThe intuition behind this approach is that the median represents the element that minimizes the sum of absolute differences with all other elements. By making all elements equal to the median value, we achieve the minimum total cost.\\n\\n# Approach\\nTo find the minimum total cost required to make all elements of the nums array equal, we can follow the following approach:\\n\\nCreate a vector of pairs, v, to store elements of nums along with their corresponding costs.\\nSort the vector v in ascending order based on the elements of nums.\\nCalculate the initial total cost, ans, by summing up all the costs in the sorted vector v.\\nFind the median value, median, of the sorted array nums. The median can be determined by selecting the element at index n/2 if n is odd, or the average of elements at indices n/2 - 1 and n/2 if n is even, where n is the size of nums.\\nInitialize total as 0 to store the final total cost.\\nIterate over the elements of nums and calculate the cost required to make each element equal to the median value. Add this cost to total.\\nReturn the final value of total as the minimum total cost.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<int, int>> v;\\n        for (int i = 0; i < nums.size(); i++) {\\n            v.push_back({nums[i], cost[i]});\\n        }\\n        sort(v.begin(), v.end());\\n        \\n        long long int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans =ans+ 1ll * v[i].second;\\n        }\\n        \\n        long long int median , tot = 0;\\n        int i = 0;\\n        while (tot < (ans + 1) / 2 && i < cost.size()) {\\n            tot = tot + (1ll * v[i].second);\\n            median = v[i].first;\\n            i++;\\n        }\\n        \\n        long long int total = 0;\\n        for (int j = 0; j < nums.size(); j++) {\\n            total += abs(1ll * nums[j] - median) * (1ll * cost[j]);\\n        }\\n        \\n        return total;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<int, int>> v;\\n        for (int i = 0; i < nums.size(); i++) {\\n            v.push_back({nums[i], cost[i]});\\n        }\\n        sort(v.begin(), v.end());\\n        \\n        long long int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans =ans+ 1ll * v[i].second;\\n        }\\n        \\n        long long int median , tot = 0;\\n        int i = 0;\\n        while (tot < (ans + 1) / 2 && i < cost.size()) {\\n            tot = tot + (1ll * v[i].second);\\n            median = v[i].first;\\n            i++;\\n        }\\n        \\n        long long int total = 0;\\n        for (int j = 0; j < nums.size(); j++) {\\n            total += abs(1ll * nums[j] - median) * (1ll * cost[j]);\\n        }\\n        \\n        return total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664085,
                "title": "finding-median-of-cost-easy-to-understand-c-java-python-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The goal is to make all the elements of the array nums equal while minimizing the total cost. \\n* To achieve this, we need to identify the target value that we want all elements to become. \\n* We can find this target value by sorting the elements based on their values and finding the midpoint. \\n* Once we have the target value, we calculate the cost required to make each element equal to the target value and return the total cost.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables: n as the size of the arrays nums and cost, v as a vector of pairs to store elements from nums and cost, and totalCost as the sum of all elements in the cost array.\\n2. Iterate through the elements of nums and cost simultaneously. For each index i, store the pair (nums[i], cost[i]) in the vector v and add cost[i] to totalCost.\\n3. Sort the vector v in ascending order based on the first element of each pair (the values from nums).\\n4. Calculate the midpoint mid by adding 1 to totalCost and dividing it by 2.\\n5. Initialize target as -1 and currSum as 0.\\n6. Iterate through the elements of v. For each element, add its cost to currSum. If currSum becomes greater than or equal to mid, set target as the first element (the value from nums) of the current pair and break out of the loop.\\n7. Initialize ans as 0.\\n8. Iterate through the elements of nums. For each element at index i, calculate the absolute difference between nums[i] and target, multiply it by cost[i], and add the result to ans.\\n9. Return the value of ans.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(n)$$\\n# Code\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<int, int>> v;\\n        long long totalCost = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            v.push_back({nums[i], cost[i]});\\n             totalCost += cost[i];\\n        }\\n        sort(v.begin(), v.end()); //sort according to num\\n\\n\\n        long long mid = (totalCost+1)/2;\\n        long long target = -1; \\n        long long currSum = 0; //sum of cost\\n\\n        for(int i = 0; i < n; i++){\\n            currSum += v[i].second;\\n            if(currSum >= mid){\\n                target = v[i].first; //target is from num array\\n                break;\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(int i = 0; i < n; i++){\\n            ans += abs((long long)nums[i] - (long long)target) * (long long) cost[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```java []\\npublic class Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int n = nums.length;\\n        int[][] v = new int[n][2];\\n        long totalCost = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            v[i][0] = nums[i];\\n            v[i][1] = cost[i];\\n            totalCost += cost[i];\\n        }\\n\\n        Arrays.sort(v, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        long mid = (totalCost + 1) / 2;\\n        long target = -1;\\n        long currSum = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            currSum += v[i][1];\\n            if (currSum >= mid) {\\n                target = v[i][0];\\n                break;\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans += Math.abs((long) nums[i] - (long) target) * (long) cost[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n```Python []\\nclass Solution(object):\\n    def minCost(self, nums, cost):\\n        n = len(nums)\\n        v = []\\n        totalCost = 0\\n\\n        for i in range(n):\\n            v.append((nums[i], cost[i]))\\n            totalCost += cost[i]\\n\\n        v.sort() # sort according to num\\n\\n        mid = (totalCost + 1) // 2\\n        target = -1\\n        currSum = 0 # sum of cost\\n\\n        for i in range(n):\\n            currSum += v[i][1]\\n            if currSum >= mid:\\n                target = v[i][0] # target is from num array\\n                break\\n\\n        ans = 0\\n        for i in range(n):\\n            ans += abs(nums[i] - target) * cost[i]\\n\\n        return ans\\n```\\n\\n``` JavaScript []\\nvar minCost = function(nums, cost) {\\n    const n = nums.length;\\n    const v = [];\\n    let totalCost = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        v.push([nums[i], cost[i]]);\\n        totalCost += cost[i];\\n    }\\n\\n    v.sort((a, b) => a[0] - b[0]);\\n\\n    const mid = Math.floor((totalCost + 1) / 2);\\n    let target = -1;\\n    let currSum = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        currSum += v[i][1];\\n        if (currSum >= mid) {\\n            target = v[i][0];\\n            break;\\n        }\\n    }\\n\\n    let ans = 0;\\n    for (let i = 0; i < n; i++) {\\n        ans += Math.abs(nums[i] - target) * cost[i];\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<int, int>> v;\\n        long long totalCost = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            v.push_back({nums[i], cost[i]});\\n             totalCost += cost[i];\\n        }\\n        sort(v.begin(), v.end()); //sort according to num\\n\\n\\n        long long mid = (totalCost+1)/2;\\n        long long target = -1; \\n        long long currSum = 0; //sum of cost\\n\\n        for(int i = 0; i < n; i++){\\n            currSum += v[i].second;\\n            if(currSum >= mid){\\n                target = v[i].first; //target is from num array\\n                break;\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(int i = 0; i < n; i++){\\n            ans += abs((long long)nums[i] - (long long)target) * (long long) cost[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```java []\\npublic class Solution {\\n    public long minCost(int[] nums, int[] cost) {\\n        int n = nums.length;\\n        int[][] v = new int[n][2];\\n        long totalCost = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            v[i][0] = nums[i];\\n            v[i][1] = cost[i];\\n            totalCost += cost[i];\\n        }\\n\\n        Arrays.sort(v, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        long mid = (totalCost + 1) / 2;\\n        long target = -1;\\n        long currSum = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            currSum += v[i][1];\\n            if (currSum >= mid) {\\n                target = v[i][0];\\n                break;\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans += Math.abs((long) nums[i] - (long) target) * (long) cost[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def minCost(self, nums, cost):\\n        n = len(nums)\\n        v = []\\n        totalCost = 0\\n\\n        for i in range(n):\\n            v.append((nums[i], cost[i]))\\n            totalCost += cost[i]\\n\\n        v.sort() # sort according to num\\n\\n        mid = (totalCost + 1) // 2\\n        target = -1\\n        currSum = 0 # sum of cost\\n\\n        for i in range(n):\\n            currSum += v[i][1]\\n            if currSum >= mid:\\n                target = v[i][0] # target is from num array\\n                break\\n\\n        ans = 0\\n        for i in range(n):\\n            ans += abs(nums[i] - target) * cost[i]\\n\\n        return ans\\n```\n``` JavaScript []\\nvar minCost = function(nums, cost) {\\n    const n = nums.length;\\n    const v = [];\\n    let totalCost = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        v.push([nums[i], cost[i]]);\\n        totalCost += cost[i];\\n    }\\n\\n    v.sort((a, b) => a[0] - b[0]);\\n\\n    const mid = Math.floor((totalCost + 1) / 2);\\n    let target = -1;\\n    let currSum = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        currSum += v[i][1];\\n        if (currSum >= mid) {\\n            target = v[i][0];\\n            break;\\n        }\\n    }\\n\\n    let ans = 0;\\n    for (let i = 0; i < n; i++) {\\n        ans += Math.abs(nums[i] - target) * cost[i];\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664025,
                "title": "c-simple-solution",
                "content": "# Intuition\\n**As we have to minimise the cost so we can use binary search for that.**\\n\\n# Approach\\n**As we can convert all elements of array equal to any number in range minimum and maximum number of array.\\nSo we can use binary search for this range.\\nCompare middle element to middle+1 element and by comparing them we can very the range of binary search.\\nFor more clearity refer the below code..**\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tlong long find(vector<pair<int, int>> &v, int mid)\\n\\t{\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 0; i < v.size(); i++)\\n\\t\\t{\\n\\t\\t\\tans = ans + (long long)v[i].second * (long long)(abs(v[i].first - mid));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\tlong long minCost(vector<int> &nums, vector<int> &cost)\\n\\t{\\n\\t\\tvector<pair<int, int>> v;\\n\\t\\tint n = nums.size();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tv.push_back({nums[i], cost[i]});\\n\\t\\tsort(v.begin(), v.end());\\n\\t\\tint low = v[0].first;\\n\\t\\tint high = v[n - 1].first;\\n\\t\\tlong long ans = 0;\\n\\t\\twhile (low <= high)\\n\\t\\t{\\n\\t\\t\\tint mid = (high - low) / 2 + low;\\n\\t\\t\\tlong long val1 = find(v, mid);\\n\\t\\t\\tlong long val2 = find(v, mid + 1);\\n\\t\\t\\tans = min(val1, val2);\\n\\t\\t\\tif (val1 <= val2)\\n\\t\\t\\t{\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tlong long find(vector<pair<int, int>> &v, int mid)\\n\\t{\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (int i = 0; i < v.size(); i++)\\n\\t\\t{\\n\\t\\t\\tans = ans + (long long)v[i].second * (long long)(abs(v[i].first - mid));\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\tlong long minCost(vector<int> &nums, vector<int> &cost)\\n\\t{\\n\\t\\tvector<pair<int, int>> v;\\n\\t\\tint n = nums.size();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tv.push_back({nums[i], cost[i]});\\n\\t\\tsort(v.begin(), v.end());\\n\\t\\tint low = v[0].first;\\n\\t\\tint high = v[n - 1].first;\\n\\t\\tlong long ans = 0;\\n\\t\\twhile (low <= high)\\n\\t\\t{\\n\\t\\t\\tint mid = (high - low) / 2 + low;\\n\\t\\t\\tlong long val1 = find(v, mid);\\n\\t\\t\\tlong long val2 = find(v, mid + 1);\\n\\t\\t\\tans = min(val1, val2);\\n\\t\\t\\tif (val1 <= val2)\\n\\t\\t\\t{\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664011,
                "title": "with-drawing-using-binary-search-to-find-the-local-minimum-of-an-array",
                "content": "# Intuition\\n- Given a target number `x`, we can calculate the cost `f(x)` needed to convert all numbers into `x` in `O(n)` time (loop through the array).\\n- What does `f(x)` look like? In the example 1 below, it is the combination of 4 functions, and looks the graph in red. \\n- Since `f(x)` will decrease at first and increase afterwards, we only need to find the local minimum, which can be done using binary search. \\n\\n![IMG_D84A9FD81284-1.jpeg](https://assets.leetcode.com/users/images/9ad59c46-b6ae-4a0a-9c6c-83fc89b63cb5_1687321933.0570202.jpeg)\\n\\n- Here, we try all target number `x` from 1 to 5 to search which yields the lowest cost. \\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long get_cost(vector<int>& nums, vector<int>& cost, long long tar){\\n        long long acc = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            acc += (long long)abs((long long)nums[i] - tar) * (long long)cost[i];\\n        }\\n        return acc;\\n\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        if(nums.size() == 1){\\n            return 0;\\n        }\\n        if(nums.size() == 2){\\n            return min(get_cost(nums, cost, nums[0]), get_cost(nums, cost, nums[1]));\\n        }\\n\\n        int l = *min_element(nums.begin(), nums.end());\\n        int r = *max_element(nums.begin(), nums.end());\\n        long long local_min = 0;\\n        \\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            long long cost_cur = get_cost(nums, cost, mid);\\n            long long cost_left = get_cost(nums, cost, mid - 1);\\n            long long cost_right = get_cost(nums, cost, mid + 1);\\n\\n            if(cost_cur < cost_left && cost_cur < cost_right){\\n                return cost_cur;\\n            }\\n            if(cost_cur < cost_left){\\n                local_min = cost_right;\\n                l = mid + 1;\\n            }\\n            else if(cost_cur < cost_right){\\n                local_min = cost_left;\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return local_min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long get_cost(vector<int>& nums, vector<int>& cost, long long tar){\\n        long long acc = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            acc += (long long)abs((long long)nums[i] - tar) * (long long)cost[i];\\n        }\\n        return acc;\\n\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        if(nums.size() == 1){\\n            return 0;\\n        }\\n        if(nums.size() == 2){\\n            return min(get_cost(nums, cost, nums[0]), get_cost(nums, cost, nums[1]));\\n        }\\n\\n        int l = *min_element(nums.begin(), nums.end());\\n        int r = *max_element(nums.begin(), nums.end());\\n        long long local_min = 0;\\n        \\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            long long cost_cur = get_cost(nums, cost, mid);\\n            long long cost_left = get_cost(nums, cost, mid - 1);\\n            long long cost_right = get_cost(nums, cost, mid + 1);\\n\\n            if(cost_cur < cost_left && cost_cur < cost_right){\\n                return cost_cur;\\n            }\\n            if(cost_cur < cost_left){\\n                local_min = cost_right;\\n                l = mid + 1;\\n            }\\n            else if(cost_cur < cost_right){\\n                local_min = cost_left;\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return local_min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663928,
                "title": "efficient-minimum-cost-balancing-algorithm-for-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code finds the median of an array based on costs, and then calculates the minimum cost required to balance the array around that median.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create pairs of numbers and their corresponding costs by combining the elements from the nums array and the cost array.\\n\\n2. Sort the pairs in ascending order based on the numbers.\\nCalculate the total sum of costs in the cost array.\\n\\n3. Find the median element by iterating through the sorted pairs until the cumulative cost exceeds or equals half of the total sum.\\n\\n4. Calculate the minimum cost required to balance the array:\\n- aIterate through each pair of numbers and costs.\\n- Find the absolute difference between the number and the median.\\n- Multiply the difference by the cost.\\n- Accumulate the calculated values to get the total minimum cost.\\n- Return the minimum cost.\\n\\nIn summary, the code determines the median of an array based on costs, and then calculates the minimum cost needed to make the array balanced around that median.\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minCost = function(nums, cost) {\\n    nums = nums.map((nums, i) => [nums, cost[i]])\\n    .sort(([b], [a]) => b - a);\\n\\n    let pCount = 0;\\n    const sum = cost.reduce((acc, curr) => acc + curr);\\n    const [med] = nums.find(([_, cost]) => (pCount += cost) >= sum/2);\\n\\n    return nums.reduce((acc, [num, cost]) => acc + Math.abs(num - med) * cost, 0 )\\n};\\n```\\n![Untitled.jpg](https://assets.leetcode.com/users/images/e9e5f138-7612-454f-9a3c-0f082b38fafa_1687320453.499641.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minCost = function(nums, cost) {\\n    nums = nums.map((nums, i) => [nums, cost[i]])\\n    .sort(([b], [a]) => b - a);\\n\\n    let pCount = 0;\\n    const sum = cost.reduce((acc, curr) => acc + curr);\\n    const [med] = nums.find(([_, cost]) => (pCount += cost) >= sum/2);\\n\\n    return nums.reduce((acc, [num, cost]) => acc + Math.abs(num - med) * cost, 0 )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663926,
                "title": "easy-solution-with-comments-in-code-two-solutions",
                "content": "# Intuition\\nThe thing that came to my mind while solving this problem was to reach in the middle elemet i.e median of that rray so I calculated the median an then calculated the cost of every element to reach the median because only reahing to median will give minimum cost.\\n\\n# Approach\\nInitialised a vector of pairs, stored elements of nums with its corresponding cost and then sorted it after that found total sum of cost and then found median. Then called a function find to calculate the cost from that median. There is a another solution too using trinary search which you can find on this submission link to optimise extra space we are using. Link - https://leetcode.com/problems/minimum-cost-to-make-array-equal/submissions/976034907/\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long find(vector<int>& nums, vector<int>& cost, int x) {\\n        long long res = 0;\\n        for (int i=0; i<nums.size(); ++i) res += 1L * abs(nums[i] - x) * cost[i]; //Calculating cost for every element in nums if x is the median using loop\\n        return res;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long total=0;\\n        long long sum=0;\\n        long long median;\\n        vector<pair<int,int>> v;\\n        for(int i=0; i<nums.size(); i++) {\\n            v.push_back({nums[i], cost[i]}); // make pair of{nums, cost to sort them}\\n        }\\n        sort(v.begin(),v.end()); //sorting them\\n        for(int i=0; i<cost.size(); i++) {\\n            sum += v[i].second; //Grasping totoal count/cost as we want to find the count/2 which is median\\n        }\\n        int i = 0;\\n        while(total < (sum+1)/2 && i < nums.size()) { //Simple loop until we reach median\\n            total += v[i].second;\\n            median = v[i].first;\\n            i++;\\n        }\\n        return find(nums, cost, median); //calling function with calculated median\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long find(vector<int>& nums, vector<int>& cost, int x) {\\n        long long res = 0;\\n        for (int i=0; i<nums.size(); ++i) res += 1L * abs(nums[i] - x) * cost[i]; //Calculating cost for every element in nums if x is the median using loop\\n        return res;\\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long total=0;\\n        long long sum=0;\\n        long long median;\\n        vector<pair<int,int>> v;\\n        for(int i=0; i<nums.size(); i++) {\\n            v.push_back({nums[i], cost[i]}); // make pair of{nums, cost to sort them}\\n        }\\n        sort(v.begin(),v.end()); //sorting them\\n        for(int i=0; i<cost.size(); i++) {\\n            sum += v[i].second; //Grasping totoal count/cost as we want to find the count/2 which is median\\n        }\\n        int i = 0;\\n        while(total < (sum+1)/2 && i < nums.size()) { //Simple loop until we reach median\\n            total += v[i].second;\\n            median = v[i].first;\\n            i++;\\n        }\\n        return find(nums, cost, median); //calling function with calculated median\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663815,
                "title": "c-easy-code",
                "content": "```\\nclass Solution {\\npublic:  \\n    \\n    #define ll long long \\n    long long minCost(vector<int>& nums, vector<int>& cost) \\n    {\\n        int n = nums.size();\\n        \\n        vector<pair<int,int>>a;\\n        ll sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back({nums[i], cost[i]});\\n            sum+=cost[i];\\n        }\\n        \\n        sort(a.begin(),a.end()); \\n        \\n        int median;\\n        \\n        ll total = 0;\\n        ll i=0;\\n        while(i<n and total<=sum/2)\\n        {\\n            total+=a[i].second;\\n            median = a[i].first;\\n            i++;\\n        }\\n        \\n        ll res = 0;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            res+=(abs(nums[i]-median)*(ll)cost[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    \\n    #define ll long long \\n    long long minCost(vector<int>& nums, vector<int>& cost) \\n    {\\n        int n = nums.size();\\n        \\n        vector<pair<int,int>>a;\\n        ll sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back({nums[i], cost[i]});\\n            sum+=cost[i];\\n        }\\n        \\n        sort(a.begin(),a.end()); \\n        \\n        int median;\\n        \\n        ll total = 0;\\n        ll i=0;\\n        while(i<n and total<=sum/2)\\n        {\\n            total+=a[i].second;\\n            median = a[i].first;\\n            i++;\\n        }\\n        \\n        ll res = 0;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            res+=(abs(nums[i]-median)*(ll)cost[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663800,
                "title": "c-binary-search-easy-code-for-beginner-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  the graph nature is non monotonic so you have to take to value of cost to compare which one is smaller and your mid will move to smaller direction.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach is simle make low as smallest element in nums array and high as highest element in nums array , and apply binay search.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlog(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    ll appcost(vector<int>&nums,vector<int>&cost,ll k){\\n            ll c=0;\\n            for(int i=0;i<nums.size();i++){\\n              c+=(ll)(abs(nums[i]-k)*(cost[i]));\\n            }\\n        return c;\\n    }\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n         \\n        ll l=*min_element(nums.begin(),nums.end());\\n        ll r=*max_element(nums.begin(),nums.end());\\n        ll ans=0;\\n        while(l<=r){\\n            ll mid=(l+r)/2;\\n            \\n            ll a=appcost(nums,cost,mid); // take two value to compare which side is going to be small\\n            ll b=appcost(nums,cost,mid+1);\\n            // return a;\\n            if(a>b){\\n                l=mid+1;\\n                \\n            }\\n            else if(a<=b)\\n            { \\n               r=mid-1;\\n            }\\n          \\n            ans=min(a,b);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    ll appcost(vector<int>&nums,vector<int>&cost,ll k){\\n            ll c=0;\\n            for(int i=0;i<nums.size();i++){\\n              c+=(ll)(abs(nums[i]-k)*(cost[i]));\\n            }\\n        return c;\\n    }\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n         \\n        ll l=*min_element(nums.begin(),nums.end());\\n        ll r=*max_element(nums.begin(),nums.end());\\n        ll ans=0;\\n        while(l<=r){\\n            ll mid=(l+r)/2;\\n            \\n            ll a=appcost(nums,cost,mid); // take two value to compare which side is going to be small\\n            ll b=appcost(nums,cost,mid+1);\\n            // return a;\\n            if(a>b){\\n                l=mid+1;\\n                \\n            }\\n            else if(a<=b)\\n            { \\n               r=mid-1;\\n            }\\n          \\n            ans=min(a,b);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663757,
                "title": "easily-understandable-greedy-by-finding-mid-target-element-c-sorting",
                "content": "# Intuition\\nWe will find trarget element to which we have to convert whole array.\\nFor that we can first sort pair of vector in order to nums.\\nThen we will calculate the whole cost of cost array and our target element will be element whih=ch we can reach in cost/2 value.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$ O(N * Log(N)) $$\\n\\n- Space complexity:\\n$$ O(N) $$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int \\n    // We need to find target element to which we can convert all the elements\\n    // that element can be reached in cost/2 where cost is the total sum of cost array\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<int,int>> vp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i+=1){\\n            vp.push_back({nums[i],cost[i]});\\n        }\\n        sort(vp.begin(),vp.end());\\n        ll total=0;\\n        for(auto i:vp){\\n            total += i.second;\\n        }\\n\\n        ll midCost= total/2;\\n        ll midElement=-1;\\n\\n        for(int i=0;i<n;i+=1){\\n            if(midCost - vp[i].second >=0){\\n                midCost -= vp[i].second;\\n            }else{\\n                midElement = vp[i].first;\\n                break;\\n            }\\n        }\\n\\n        ll ans=0;\\n        for(int i=0;i<n;i+=1){\\n            ll diff = abs(midElement - vp[i].first);\\n            ans += (diff*vp[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPLEASEE UPVOTE IF IT HELPED :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int \\n    // We need to find target element to which we can convert all the elements\\n    // that element can be reached in cost/2 where cost is the total sum of cost array\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        vector<pair<int,int>> vp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i+=1){\\n            vp.push_back({nums[i],cost[i]});\\n        }\\n        sort(vp.begin(),vp.end());\\n        ll total=0;\\n        for(auto i:vp){\\n            total += i.second;\\n        }\\n\\n        ll midCost= total/2;\\n        ll midElement=-1;\\n\\n        for(int i=0;i<n;i+=1){\\n            if(midCost - vp[i].second >=0){\\n                midCost -= vp[i].second;\\n            }else{\\n                midElement = vp[i].first;\\n                break;\\n            }\\n        }\\n\\n        ll ans=0;\\n        for(int i=0;i<n;i+=1){\\n            ll diff = abs(midElement - vp[i].first);\\n            ans += (diff*vp[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663747,
                "title": "explanation-code-python-javascript-java-c-o-n",
                "content": "##### \\uD83D\\uDE0A Editor\\'s message.py:\\n```py\\ndef editor_s_request(editor_s_word: str) -> str:\\n    if you.likes(solution: Object) == True:\\n        you.upvote()\\n    else\\n        you.comment(improvements: str)\\n\\n    print(\"with \" , editor_s_word, \". Enjoy the Solution :)\")\\n\\n    return \"incentive to do more:)\"\\n\\nviewer_s_response = editor_s_request(\"lots of love\")\\n```\\n\\n\\n\\n# Intuition\\nUsing binary search get the index with minimum cost in minimum time\\n\\n# Approach\\n`find_cost` function calculates the absolute difference between `l` and `x`, multiplies it by the corresponding cost (`cost[i]`), and adds it to total_cost. Finally, it returns the `total_cost` value.\\nIn Binary search loop:\\n- If the cost of `mid` is less than the cost of `mid + 1`, update `right to mid`, indicating that the minimum cost lies to the left of mid.\\n- Otherwise, if the cost of `mid` is greater than or equal to the cost of `mid + 1`, update `left to mid + 1`, indicating that the minimum cost lies to the right of mid.\\n\\nOnce the while loop terminates, \\n`left` and `right` have converged to the same value, representing the position that minimizes the total cost.\\nCall the `find_cost` function with the `left` value and return the result, which is the minimum cost.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\ncalculate_cost function is O(N)\\ninitialization of the left, right, and mid variables takes O(N) \\nbinary search loop runs in O(logN)\\ncalculate_cost function is called at most twice per iteration. Therefore, the total number of function calls is at most O(logN)\\n\\nOverall, the time complexity of the code is O(N + logN), which can be simplified to O(N) as the dominant term.\\n\\n\\n\\n- Space complexity: $$O(1)$$\\nit uses a constant amount of additional space that does not depend on the input size. It only requires a few variables to store intermediate values and does not create any data structures or arrays that grow with the input.\\n\\n\\n\\n# Code\\n\\n\\n```python []\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        \\n        def find_cost(l):\\n            total_cost = 0\\n            for i, x in enumerate(nums):\\n                total_cost += abs(l - x) * cost[i]\\n            return total_cost\\n        \\n  \\n        left = min(nums)\\n        right = max(nums) + 1\\n        mid = (left + right) // 2\\n        \\n        while left < right:\\n            if find_cost(mid) < find_cost(mid + 1):\\n                right = mid\\n            else:\\n                left = mid + 1\\n            mid = (left + right) // 2\\n        \\n        return find_cost(left)\\n```\\n```javascript []\\nfunction minCost(nums, cost) {\\n  function calculateCost(l) {\\n    let totalCost = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n      totalCost += Math.abs(l - nums[i]) * cost[i];\\n    }\\n    return totalCost;\\n  }\\n\\n  let left = Math.min(...nums);\\n  let right = Math.max(...nums) + 1;\\n  let mid = Math.floor((left + right) / 2);\\n\\n  while (left < right) {\\n    if (calculateCost(mid) < calculateCost(mid + 1)) {\\n      right = mid;\\n    } else {\\n      left = mid + 1;\\n    }\\n    mid = Math.floor((left + right) / 2);\\n  }\\n\\n  return calculateCost(left);\\n}\\n\\n```\\n```java []\\nimport java.util.List;\\n\\nclass Solution {\\n    public int minCost(List<Integer> nums, List<Integer> cost) {\\n        int left = Collections.min(nums);\\n        int right = Collections.max(nums) + 1;\\n        int mid = (left + right) / 2;\\n\\n        while (left < right) {\\n            if (calculateCost(nums, cost, mid) < calculateCost(nums, cost, mid + 1)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n            mid = (left + right) / 2;\\n        }\\n\\n        return calculateCost(nums, cost, left);\\n    }\\n\\n    private int calculateCost(List<Integer> nums, List<Integer> cost, int l) {\\n        int totalCost = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            totalCost += Math.abs(l - nums.get(i)) * cost.get(i);\\n        }\\n        return totalCost;\\n    }\\n}\\n\\n```\\n```cpp []\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nint minCost(vector<int>& nums, vector<int>& cost) {\\n  auto calculateCost = [&](int l) {\\n    int totalCost = 0;\\n    for (int i = 0; i < nums.size(); i++) {\\n      totalCost += abs(l - nums[i]) * cost[i];\\n    }\\n    return totalCost;\\n  };\\n\\n  int left = *min_element(nums.begin(), nums.end());\\n  int right = *max_element(nums.begin(), nums.end()) + 1;\\n  int mid = (left + right) / 2;\\n\\n  while (left < right) {\\n    if (calculateCost(mid) < calculateCost(mid + 1)) {\\n      right = mid;\\n    } else {\\n      left = mid + 1;\\n    }\\n    mid = (left + right) / 2;\\n  }\\n\\n  return calculateCost(left);\\n}\\n\\n```\\n\\n\\n\\n\\n```\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```py\\ndef editor_s_request(editor_s_word: str) -> str:\\n    if you.likes(solution: Object) == True:\\n        you.upvote()\\n    else\\n        you.comment(improvements: str)\\n\\n    print(\"with \" , editor_s_word, \". Enjoy the Solution :)\")\\n\\n    return \"incentive to do more:)\"\\n\\nviewer_s_response = editor_s_request(\"lots of love\")\\n```\n```python []\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        \\n        def find_cost(l):\\n            total_cost = 0\\n            for i, x in enumerate(nums):\\n                total_cost += abs(l - x) * cost[i]\\n            return total_cost\\n        \\n  \\n        left = min(nums)\\n        right = max(nums) + 1\\n        mid = (left + right) // 2\\n        \\n        while left < right:\\n            if find_cost(mid) < find_cost(mid + 1):\\n                right = mid\\n            else:\\n                left = mid + 1\\n            mid = (left + right) // 2\\n        \\n        return find_cost(left)\\n```\n```javascript []\\nfunction minCost(nums, cost) {\\n  function calculateCost(l) {\\n    let totalCost = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n      totalCost += Math.abs(l - nums[i]) * cost[i];\\n    }\\n    return totalCost;\\n  }\\n\\n  let left = Math.min(...nums);\\n  let right = Math.max(...nums) + 1;\\n  let mid = Math.floor((left + right) / 2);\\n\\n  while (left < right) {\\n    if (calculateCost(mid) < calculateCost(mid + 1)) {\\n      right = mid;\\n    } else {\\n      left = mid + 1;\\n    }\\n    mid = Math.floor((left + right) / 2);\\n  }\\n\\n  return calculateCost(left);\\n}\\n\\n```\n```java []\\nimport java.util.List;\\n\\nclass Solution {\\n    public int minCost(List<Integer> nums, List<Integer> cost) {\\n        int left = Collections.min(nums);\\n        int right = Collections.max(nums) + 1;\\n        int mid = (left + right) / 2;\\n\\n        while (left < right) {\\n            if (calculateCost(nums, cost, mid) < calculateCost(nums, cost, mid + 1)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n            mid = (left + right) / 2;\\n        }\\n\\n        return calculateCost(nums, cost, left);\\n    }\\n\\n    private int calculateCost(List<Integer> nums, List<Integer> cost, int l) {\\n        int totalCost = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            totalCost += Math.abs(l - nums.get(i)) * cost.get(i);\\n        }\\n        return totalCost;\\n    }\\n}\\n\\n```\n```cpp []\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nint minCost(vector<int>& nums, vector<int>& cost) {\\n  auto calculateCost = [&](int l) {\\n    int totalCost = 0;\\n    for (int i = 0; i < nums.size(); i++) {\\n      totalCost += abs(l - nums[i]) * cost[i];\\n    }\\n    return totalCost;\\n  };\\n\\n  int left = *min_element(nums.begin(), nums.end());\\n  int right = *max_element(nums.begin(), nums.end()) + 1;\\n  int mid = (left + right) / 2;\\n\\n  while (left < right) {\\n    if (calculateCost(mid) < calculateCost(mid + 1)) {\\n      right = mid;\\n    } else {\\n      left = mid + 1;\\n    }\\n    mid = (left + right) / 2;\\n  }\\n\\n  return calculateCost(left);\\n}\\n\\n```\n```\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3663720,
                "title": "easy-to-understand-solution-using-median",
                "content": "# Intuition\\nChanging all the elements to the median element is optimal. We can consider cost as the element\\'s frequency to calculate the median.\\n\\nfor eg - nums = [2,1,3,4] cost = [4,2,1,3]\\nTo calculate median, we can consider the array as -\\n[2,2,2,2,1,1,3,4,4,4]\\nSorting the array to calculate the median ->\\n[1,1,2,2,2,2,3,4,4,4] , hence the median is **2**\\n\\n# Complexity\\n- Time complexity : $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<int,int>> arr;\\n        for(int i=0 ; i<n ; i++) arr.push_back({nums[i],cost[i]});\\n        sort(begin(arr),end(arr)); // sort the array to calculate median\\n\\n        long long sum = accumulate(begin(cost),end(cost),0LL);\\n\\n        long long tot=0;\\n        int i = 0;\\n        int median = 0;\\n        // calculating median\\n        while(tot < (sum+1)/2 && i < n) {\\n            tot += arr[i].second;\\n            median = arr[i].first;\\n            i++;\\n        }\\n    \\n        long long ans = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            ans += 1ll*abs(arr[i].first-median)*arr[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<int,int>> arr;\\n        for(int i=0 ; i<n ; i++) arr.push_back({nums[i],cost[i]});\\n        sort(begin(arr),end(arr)); // sort the array to calculate median\\n\\n        long long sum = accumulate(begin(cost),end(cost),0LL);\\n\\n        long long tot=0;\\n        int i = 0;\\n        int median = 0;\\n        // calculating median\\n        while(tot < (sum+1)/2 && i < n) {\\n            tot += arr[i].second;\\n            median = arr[i].first;\\n            i++;\\n        }\\n    \\n        long long ans = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            ans += 1ll*abs(arr[i].first-median)*arr[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663700,
                "title": "kotlin-easy-explained",
                "content": "This got 100% in execution time and space, but only because there were no other Kotlin solutions yet...  But, one of the hints said that the optimal solution is one of the numbers in nums, and the other hint said try them all.  So, the easiest thing to do was try each number as a \"goal\" and compute the cost.\\n\\nAll was well, except one test case had all the same cost, but 100,000 of them, and the numbers in num were 1 to 100,000.  Brute force resulted in time limit exceeded.  So, I decided the best course of action is when the costs are all the same, get the average of the numbers in nums, and make that the goal, add the differences, then multiply by the cost.  One little catch was that nums.sum() gave the wrong answer, mostly likely due to overflow, so I did a loop to sum over all the numbers, then divide by nums.size.  I could have used the computation sum = nums.size * (nums.size + 1) / 2, but that would target the one special case and wouldn\\'t work in all cases where the costs are all the same.  That would definitely be faster than adding them all together and dividing by nums.size.  You can try it!\\n\\nFinally, one thing to save time, if all the numbers are the same, the differences will be 0, cost will be 0, so if that is the answer, return it, we\\'re done.\\n\\nThe two special cases, where nums are all the same, or costs are all the same, are Order N.  The rest are order N * N.  Considering that sorting is O(N log N), more complicated algorithms may not save time.  One suggestion by DudeAndCat was to do a binary search for the best solution - that could be much more efficient!\\n\\nHere is my mostly brute force solution.  Thank you for reading, and if you find it helpful, please upvote!\\n\\n```\\nfun minCost(nums: IntArray, cost: IntArray): Long {\\n        var minCost = Long.MAX_VALUE\\n        var total : Long\\n        var cost1 = cost[0]\\n        var allSame = true\\n        for (c in cost) {\\n            if (c != cost1) {\\n                allSame = false\\n                break\\n            }\\n        }\\n        if (allSame) {\\n            var sum = 0L\\n            for (x in nums) {\\n                sum += x\\n            }\\n            var average = sum / nums.size\\n            total = 0L\\n            for (x in nums) {\\n                total += Math.abs(x - average)\\n            }\\n            return total * cost1\\n        }\\n        \\n        for (goal in nums) {\\n            total = 0L\\n            for (x in 0..nums.lastIndex) {\\n                total += Math.abs(nums[x] - goal).toLong() * cost[x]\\n            }\\n            if (total < minCost) {\\n                minCost = total\\n                if (minCost == 0L) {\\n                    return 0L\\n                }\\n            }\\n        }\\n        return minCost\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun minCost(nums: IntArray, cost: IntArray): Long {\\n        var minCost = Long.MAX_VALUE\\n        var total : Long\\n        var cost1 = cost[0]\\n        var allSame = true\\n        for (c in cost) {\\n            if (c != cost1) {\\n                allSame = false\\n                break\\n            }\\n        }\\n        if (allSame) {\\n            var sum = 0L\\n            for (x in nums) {\\n                sum += x\\n            }\\n            var average = sum / nums.size\\n            total = 0L\\n            for (x in nums) {\\n                total += Math.abs(x - average)\\n            }\\n            return total * cost1\\n        }\\n        \\n        for (goal in nums) {\\n            total = 0L\\n            for (x in 0..nums.lastIndex) {\\n                total += Math.abs(nums[x] - goal).toLong() * cost[x]\\n            }\\n            if (total < minCost) {\\n                minCost = total\\n                if (minCost == 0L) {\\n                    return 0L\\n                }\\n            }\\n        }\\n        return minCost\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663697,
                "title": "c-simple-solution-using-prefix-and-sufix-sum",
                "content": "# Intuition\\nLet say I want to make the all the elements equals to `nums[i]` then I have to increment all elements smaller then `nums[i]` and decrement elements greater than `nums[i]` and let say total cost required is $$X^i$$ then minmum of $$X^i$$\\'s for all values of _i_ will be my answer.\\n\\ncan we find total cost required to make all elements equals to _i_ in costant time?\\n\\nYes we can by maintaing prefix and sufix array\\'s.\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Video Explanation \\n Watch Youtube Video to understand the intuition, approach and explanation of the problem \\n\\n[https://youtu.be/D6PLV93_1P8]() \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<int ,int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i], cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n\\n        vector<long long> preCostSum(n, 0), sufCostSum(n, 0);\\n        vector<long long> preProdSum(n, 0), sufProdSum(n , 0);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i > 0)\\n            {\\n                preCostSum[i] += preCostSum[i-1];\\n                preProdSum[i] += preProdSum[i-1];\\n            }\\n            preCostSum[i] += v[i].second;\\n            preProdSum[i] += (1LL*v[i].first * v[i].second);\\n        }\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i < n-1)\\n            {\\n                sufCostSum[i] += sufCostSum[i+1];\\n                sufProdSum[i] += sufProdSum[i+1];\\n            }\\n            sufCostSum[i] += v[i].second;\\n            sufProdSum[i] += (1LL*v[i].first * v[i].second);\\n        }\\n\\n        long long ans = 1e18;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            long long temp = v[i].first*preCostSum[i] - preProdSum[i] - v[i].first*sufCostSum[i+1] + sufProdSum[i+1];\\n            ans = min(ans, temp);\\n        }\\n        long long temp = v[n-1].first*preCostSum[n-1] - preProdSum[n-1];\\n        ans = min(ans, temp);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Suffix Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n = nums.size();\\n        vector<pair<int ,int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({nums[i], cost[i]});\\n        }\\n        sort(v.begin(),v.end());\\n\\n        vector<long long> preCostSum(n, 0), sufCostSum(n, 0);\\n        vector<long long> preProdSum(n, 0), sufProdSum(n , 0);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i > 0)\\n            {\\n                preCostSum[i] += preCostSum[i-1];\\n                preProdSum[i] += preProdSum[i-1];\\n            }\\n            preCostSum[i] += v[i].second;\\n            preProdSum[i] += (1LL*v[i].first * v[i].second);\\n        }\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i < n-1)\\n            {\\n                sufCostSum[i] += sufCostSum[i+1];\\n                sufProdSum[i] += sufProdSum[i+1];\\n            }\\n            sufCostSum[i] += v[i].second;\\n            sufProdSum[i] += (1LL*v[i].first * v[i].second);\\n        }\\n\\n        long long ans = 1e18;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            long long temp = v[i].first*preCostSum[i] - preProdSum[i] - v[i].first*sufCostSum[i+1] + sufProdSum[i+1];\\n            ans = min(ans, temp);\\n        }\\n        long long temp = v[n-1].first*preCostSum[n-1] - preProdSum[n-1];\\n        ans = min(ans, temp);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663619,
                "title": "c-solution",
                "content": "```\\nlong long getSum(int* nums, int numsSize, int* cost, int mid){\\n    long long sum = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        long long k = abs(nums[i] - mid);\\n        sum += k * cost[i];  \\n    }\\n    return sum;\\n}\\n\\nlong long minCost(int* nums, int numsSize, int* cost, int costSize) {\\n    long long lo = 1, hi=1e6;\\n    while(lo <= hi)\\n    {\\n        int mid = (lo + hi) / 2;\\n        long long sum1 = getSum(nums, numsSize, cost, mid);\\n        if(lo == hi)\\n            return sum1;\\n        long long sum3 = getSum(nums, numsSize, cost, mid + 1);\\n        long long sum2 = getSum(nums, numsSize, cost, mid - 1);\\n          \\n        if(sum2 >= sum1 && sum1 <= sum3)\\n            return sum1; \\n        if(sum2 < sum1)\\n        {\\n            hi = mid;\\n            continue; \\n        } \\n        if(sum3 < sum1)\\n        {\\n            lo = mid;\\n            continue;\\n        }\\n    } \\n    return 0;   \\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nlong long getSum(int* nums, int numsSize, int* cost, int mid){\\n    long long sum = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        long long k = abs(nums[i] - mid);\\n        sum += k * cost[i];  \\n    }\\n    return sum;\\n}\\n\\nlong long minCost(int* nums, int numsSize, int* cost, int costSize) {\\n    long long lo = 1, hi=1e6;\\n    while(lo <= hi)\\n    {\\n        int mid = (lo + hi) / 2;\\n        long long sum1 = getSum(nums, numsSize, cost, mid);\\n        if(lo == hi)\\n            return sum1;\\n        long long sum3 = getSum(nums, numsSize, cost, mid + 1);\\n        long long sum2 = getSum(nums, numsSize, cost, mid - 1);\\n          \\n        if(sum2 >= sum1 && sum1 <= sum3)\\n            return sum1; \\n        if(sum2 < sum1)\\n        {\\n            hi = mid;\\n            continue; \\n        } \\n        if(sum3 < sum1)\\n        {\\n            lo = mid;\\n            continue;\\n        }\\n    } \\n    return 0;   \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663579,
                "title": "javascript-solution-clean-and-descriptive-time-o-n-log-n-space-o-1",
                "content": "```js\\n/**\\n * Greedy\\n * Binary Search\\n * Time O(N * log(N)) | Space O(1)\\n * https://leetcode.com/problems/minimum-cost-to-make-array-equal\\n * @param {number[]} nums\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minCost = (nums, cost) => {\\n    const min = findCost(nums, cost, 1); /* Time O(N) | Space O(1) */\\n\\n    return binarySearch(nums, cost, min);/* Time O(N * log(N)) | Space O(1) */\\n}\\n\\nconst findCost = (nums, cost, x, min = 0) => {\\n    for (let i = 0; i < nums.length; i++) {/* Time O(N) */\\n        const num = Math.abs(nums[i] - x);\\n\\n        min += (num * cost[i]);\\n    }\\n\\n    return min;\\n}\\n\\nconst binarySearch = (nums, cost, min) => {\\n    let [ left, right ] = getPointers(nums);/* Time O(N) */\\n\\n    while (left < right) {/* Time O(log(N)) */\\n        const mid = ((left + right) >> 1);\\n        const [ x, y ] =      /* Time O(N) */\\n            [ findCost(nums, cost, mid), findCost(nums, cost, (mid + 1)) ];\\n\\n        min = Math.min(x, y);\\n\\n        const isGreater = (y <= x)\\n        if (isGreater) left = (mid + 1);\\n\\n        const isLess = (x < y)\\n        if (isLess) right = mid;\\n    }\\n\\n    return min;\\n}\\n\\nconst getPointers = (nums) => {\\n    let [ left, right ] = [ 1, 1000000 ];\\n\\n    for (const num of nums) {/* Time O(N) */\\n        [ left, right ] = [ Math.min(num, left), Math.max(num, right) ];\\n    }\\n\\n    return [ left, right ];\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * Greedy\\n * Binary Search\\n * Time O(N * log(N)) | Space O(1)\\n * https://leetcode.com/problems/minimum-cost-to-make-array-equal\\n * @param {number[]} nums\\n * @param {number[]} cost\\n * @return {number}\\n */\\nvar minCost = (nums, cost) => {\\n    const min = findCost(nums, cost, 1); /* Time O(N) | Space O(1) */\\n\\n    return binarySearch(nums, cost, min);/* Time O(N * log(N)) | Space O(1) */\\n}\\n\\nconst findCost = (nums, cost, x, min = 0) => {\\n    for (let i = 0; i < nums.length; i++) {/* Time O(N) */\\n        const num = Math.abs(nums[i] - x);\\n\\n        min += (num * cost[i]);\\n    }\\n\\n    return min;\\n}\\n\\nconst binarySearch = (nums, cost, min) => {\\n    let [ left, right ] = getPointers(nums);/* Time O(N) */\\n\\n    while (left < right) {/* Time O(log(N)) */\\n        const mid = ((left + right) >> 1);\\n        const [ x, y ] =      /* Time O(N) */\\n            [ findCost(nums, cost, mid), findCost(nums, cost, (mid + 1)) ];\\n\\n        min = Math.min(x, y);\\n\\n        const isGreater = (y <= x)\\n        if (isGreater) left = (mid + 1);\\n\\n        const isLess = (x < y)\\n        if (isLess) right = mid;\\n    }\\n\\n    return min;\\n}\\n\\nconst getPointers = (nums) => {\\n    let [ left, right ] = [ 1, 1000000 ];\\n\\n    for (const num of nums) {/* Time O(N) */\\n        [ left, right ] = [ Math.min(num, left), Math.max(num, right) ];\\n    }\\n\\n    return [ left, right ];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663549,
                "title": "simple-and-optimal-python3-solution-sorting-prefix-and-suffix-sum",
                "content": "# Complexity\\n- Time complexity: $$O(n \\\\cdot log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        d = Counter()  # elem to total cost\\n        for elem, cost in zip(nums, cost):\\n            d[elem] += cost\\n\\n        # initial cursor is zero\\n        # * not minimal element for simplicity\\n        prev = 0\\n        best = current = sum(elem * cost for elem, cost in d.items())\\n\\n        minus = sum(d.values())  # total cost of elements on \"right\" of cursor\\n        plus = 0  # total cost of elements on \"left\" of cursor\\n\\n        for elem, cost in sorted(d.items()):\\n            delta = elem - prev\\n            prev = elem\\n\\n            # decrease current value by total cost of elements we are \"approaching\"\\n            current -= minus * delta\\n            # increase current value by total cost of elements from which we are \"moving away\"\\n            current += plus * delta\\n\\n            # update minus and plus\\n            minus -= cost\\n            plus += cost\\n\\n            # update best\\n            best = min(best, current)            \\n        \\n        return best\\n\\n```\\n#### If you found this useful or interesting, please upvote!",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "``` python3 []\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        d = Counter()  # elem to total cost\\n        for elem, cost in zip(nums, cost):\\n            d[elem] += cost\\n\\n        # initial cursor is zero\\n        # * not minimal element for simplicity\\n        prev = 0\\n        best = current = sum(elem * cost for elem, cost in d.items())\\n\\n        minus = sum(d.values())  # total cost of elements on \"right\" of cursor\\n        plus = 0  # total cost of elements on \"left\" of cursor\\n\\n        for elem, cost in sorted(d.items()):\\n            delta = elem - prev\\n            prev = elem\\n\\n            # decrease current value by total cost of elements we are \"approaching\"\\n            current -= minus * delta\\n            # increase current value by total cost of elements from which we are \"moving away\"\\n            current += plus * delta\\n\\n            # update minus and plus\\n            minus -= cost\\n            plus += cost\\n\\n            # update best\\n            best = min(best, current)            \\n        \\n        return best\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663541,
                "title": "ruby-solution-using-binary-search-with-explanation-100-100",
                "content": "# Intuition\\nWe want to find the number we\\'re changing everything in the array to.  Moving further away from that number will cause the total cost increase, which means this essentially has a negative peak and we can use binary search.\\n\\n# Approach\\n1. Create an array combining nums and cost.  Make it a class variable so we can access it with a helper function.\\n2. Find the min and max values from nums.  (We know it would more costly if our target is outside of nums.)  Do a binary search with a helper function to find the target value that minimizes costs.\\n3. Calculate the price of changing every value to target.\\n\\nHelper function:\\n1. Initialize total cost as 0.\\n2. For each element, find the absolute difference between it and target, multiply by that items cost, and add to total.\\n3. Return total.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$.  Would be doable in $$O(1)$$ if we didn\\'t create @arr, but I find it easier to work with.\\n\\n# Code\\n```\\ndef min_cost(nums, cost)\\n    @arr = []\\n    nums.each_with_index { |num,i| @arr << [num, cost[i]] }\\n\\n    min,max = nums.min,nums.max\\n    idx = (min..max).bsearch { |n| price(n) < price(n+1) }\\n\\n    price(idx)\\nend\\n\\ndef price(n)\\n    total = 0\\n    @arr.each { |ele| total += (ele[0] - n).abs * ele[1] }\\n    total\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef min_cost(nums, cost)\\n    @arr = []\\n    nums.each_with_index { |num,i| @arr << [num, cost[i]] }\\n\\n    min,max = nums.min,nums.max\\n    idx = (min..max).bsearch { |n| price(n) < price(n+1) }\\n\\n    price(idx)\\nend\\n\\ndef price(n)\\n    total = 0\\n    @arr.each { |ele| total += (ele[0] - n).abs * ele[1] }\\n    total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3663535,
                "title": "fastest-solution-yet",
                "content": "# Intuition\\nSince it asked to perform some operation (i.e. increasse/decrease elements by 1), it would be best to use mean of all elements belonging to `cost`. So using the hints we need to perform Iterative traversal and update\\n\\n# Approach\\n1. Sort the elements.\\n2. Determine the mean of `cost`.\\n3. Create a new variable `count` and set it to `0`.\\n4. Iterater through your 2D array containing nums and cost.\\n5. Add the `cost[i]` to `count`.\\n6. If `count>= mid`, return the positive value of `(target-n)*c` from the elements in array\\n7. Repat Steps 5 and 6 till full traversal done\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$ \\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        arr = sorted(zip(nums, cost))\\n        mid = sum(cost) / 2\\n        count = 0\\n        for target, co in arr:\\n            count += co\\n            if count >= mid:\\n                return sum(abs(target - n) * c for n, c in arr)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        arr = sorted(zip(nums, cost))\\n        mid = sum(cost) / 2\\n        count = 0\\n        for target, co in arr:\\n            count += co\\n            if count >= mid:\\n                return sum(abs(target - n) * c for n, c in arr)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663519,
                "title": "python-3-binary-search-super-simple",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def calculateSum(self, nums, cost, target):\\n        result = 0\\n        for v, c in zip(nums, cost):\\n            result += abs(v - target) * c\\n        return result\\n    \\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        s, f = min(nums), max(nums)\\n        \\n        while s < f:\\n            mid = (s + f) // 2\\n            left, right = self.calculateSum(nums, cost, mid), self.calculateSum(nums, cost, mid + 1)\\n            if left < right:\\n                f = mid\\n            else:\\n                s = mid + 1\\n        \\n        return self.calculateSum(nums, cost, s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateSum(self, nums, cost, target):\\n        result = 0\\n        for v, c in zip(nums, cost):\\n            result += abs(v - target) * c\\n        return result\\n    \\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\\n        s, f = min(nums), max(nums)\\n        \\n        while s < f:\\n            mid = (s + f) // 2\\n            left, right = self.calculateSum(nums, cost, mid), self.calculateSum(nums, cost, mid + 1)\\n            if left < right:\\n                f = mid\\n            else:\\n                s = mid + 1\\n        \\n        return self.calculateSum(nums, cost, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663516,
                "title": "daily-leetcoding-challenge-june-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-cost-to-make-array-equal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Prefix Sum\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-cost-to-make-array-equal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3263084,
                "title": "sorting-prefix-sum-lower-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n=nums.size();\\n        vector<pair<int,int>> vp;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=cost[i];\\n            vp.push_back({nums[i],cost[i]});\\n        }\\n        long long  median=(sum+1)/2;\\n        sort(vp. begin(),vp.end());\\n        vector<long long>pre(n);\\n        pre[0]=vp[0].second;\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+vp[i].second;\\n        }\\n        int ind=lower_bound(pre.begin(),pre.end(),median)-pre.begin();\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=abs(vp[i].first-vp[ind].first)*1LL*vp[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        int n=nums.size();\\n        vector<pair<int,int>> vp;\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=cost[i];\\n            vp.push_back({nums[i],cost[i]});\\n        }\\n        long long  median=(sum+1)/2;\\n        sort(vp. begin(),vp.end());\\n        vector<long long>pre(n);\\n        pre[0]=vp[0].second;\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+vp[i].second;\\n        }\\n        int ind=lower_bound(pre.begin(),pre.end(),median)-pre.begin();\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=abs(vp[i].first-vp[ind].first)*1LL*vp[i].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006901,
                "title": "c-2-approaches-explained-tricky",
                "content": "2 approaches are explained below to solve this problem. 1st approach is more generic and intuitive, while 2nd approach is not easy (or rather no so generic and common). But these 2 approaches will teach how to apply binarySeach on answer in 2 different ways!\\n\\n\\uD83D\\uDC49 Explanations of both approaches is in code itself, and code is well commented :\\n\\n\\n**BRUTE FORCE:**\\n*  We can make all element equal to x, where x ranges between [1-10^6]\\n*  For each x we need to process whole array, so there is N\\n*  So the brute complexity is O(N*x). ---> TLE\\n*  From this only, I got intuition for Binary Search On Answer\\n\\n**CASE 1:**\\n*  In general, here we apply binarySearch on answer to reduce x to logx. --> TC: O(N*logx)\\n*  we can apply BS on x because [ `f(i)=\\u03A3Ci(i-a)` ]. Here f(i) defines cost to make arr equal to i, a is the array element\\n*  This f(i) graph is something like |x| type graph, and we can apply BS on all {step response}, and {modulus} type graph.\\n*  This is similar to \\'**FIND PEAK ELEMENT**\\' type problem\\n\\n```\\n\\tlong long findCost(vector<int>& nums, vector<int>& cost, int tgt){ // cost to make array equal to tgt\\n        long long cst= 0;\\n        for(int i=0; i<nums.size(); i++){\\n            long long diff= abs(1LL*nums[i]-tgt);\\n            cst+= (diff* (long long)cost[i]);\\n        }\\n        \\n        return cst;\\n    }\\n\\t\\n\\tlong long minCost(vector<int>& nums, vector<int>& cost) {\\n \\n        int low= 1; int high= 1000006;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            long long cstPrev= findCost(nums, cost, mid-1);\\n            long long cst= findCost(nums, cost, mid);\\n            long long cstNxt= findCost(nums, cost, mid+1);\\n            \\n            if(cstPrev>=cst && cst<=cstNxt){\\n                return cst;\\n            }\\n            else if(cst>cstNxt){ // we are in decreasing slope side --> go right\\n                low= mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        return 1e9;\\n\\t}\\n```\\n\\n---------------------------------------------------------------------------------------------------------------------------------------------------------------\\n**CASE 2:**\\n* We can also find cost in O(logN) time (after pre-processing) for any x. --> TC: O(x*logN)\\n* This is not easy at all and tricky.\\n\\n```\\n\\tint binarySearch(vector<int>& vec, int tgt){ // min possible index i where [0-i] will be index whose val is < x\\n        int low= 0; int high= vec.size()-1; int potCand=-1;\\n        \\n        while(low<=high){\\n            int mid= low+ (high-low)/2;\\n            \\n            if(vec[mid]<tgt){\\n                potCand= mid;\\n                low= mid+1;\\n            }\\n            else if(vec[mid]>=tgt){\\n                high= mid-1;\\n            }\\n        }\\n        return potCand;\\n    }\\n\\t\\n\\tlong long minCost(vector<int>& nums, vector<int>& cost) {\\n\\t\\t// pre-processing\\n        vector<pair<int, int>> vec;\\n        for(int i=0; i<nums.size(); i++){\\n            vec.push_back({nums[i], i});\\n        }\\n        \\n        sort(vec.begin(), vec.end());\\n        vector<int> temp(cost.size());\\n        for(int i=0; i<vec.size(); i++){\\n            nums[i]= vec[i].first;\\n            temp[i]= cost[vec[i].second]; \\n        }\\n        \\n        for(int i=0; i<temp.size(); i++){\\n            cost[i]=temp[i];\\n        }\\n        \\n        vector<long long> cumSumFront(cost.size()); long long t=0;\\n        for(int i=0; i<cost.size(); i++){\\n            t+=cost[i];\\n            cumSumFront[i]=t;\\n        }\\n        vector<long long> cumSumLast(cost.size()); t=0;\\n        for(int i=cost.size()-1; i>=0; i--){\\n            t+=cost[i];\\n            cumSumLast[i]= t;\\n        }\\n        \\n        long long finalCost= findCost(nums, cost, 1); // cost to make all arr ele equal to 1\\n        long long mini= INT_MAX;\\n        mini= min(mini, finalCost);\\n        \\n        // Calculation\\n        \\n        for(int x=2; x<=1000000; x++){\\n            // Now let say [0-i] indexed ele are < 1 --> so if we have to make all ele equal 2, then we have to add their cost\\n            // Similarly say [i\\'-size] indexed ele are >1 --> so if we have to make all ele equal 2, we have to sub their cost\\n            \\n            int i= binarySearch(nums, x); // [0-i] will be index whose val is < x\\n            if(i!=-1){ finalCost+= cumSumFront[i]; }\\n            \\n            int iBar=-1;\\n            auto it= lower_bound(nums.begin(), nums.end(), x);\\n            if(it!=nums.end()){ iBar= it-nums.begin(); }\\n            if(iBar!=-1){ finalCost-= cumSumLast[iBar]; } // [iBar-size] will be index whose val is >= x\\n            \\n            mini= min(mini, finalCost);\\n        }\\n        \\n        return mini;\\n    }\\n```\\n\\nThanks",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n\\tlong long findCost(vector<int>& nums, vector<int>& cost, int tgt){ // cost to make array equal to tgt\\n        long long cst= 0;\\n        for(int i=0; i<nums.size(); i++){\\n            long long diff= abs(1LL*nums[i]-tgt);\\n            cst+= (diff* (long long)cost[i]);\\n        }\\n        \\n        return cst;\\n    }\\n\\t\\n\\tlong long minCost(vector<int>& nums, vector<int>& cost) {\\n \\n        int low= 1; int high= 1000006;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            long long cstPrev= findCost(nums, cost, mid-1);\\n            long long cst= findCost(nums, cost, mid);\\n            long long cstNxt= findCost(nums, cost, mid+1);\\n            \\n            if(cstPrev>=cst && cst<=cstNxt){\\n                return cst;\\n            }\\n            else if(cst>cstNxt){ // we are in decreasing slope side --> go right\\n                low= mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        return 1e9;\\n\\t}\\n```\n```\\n\\tint binarySearch(vector<int>& vec, int tgt){ // min possible index i where [0-i] will be index whose val is < x\\n        int low= 0; int high= vec.size()-1; int potCand=-1;\\n        \\n        while(low<=high){\\n            int mid= low+ (high-low)/2;\\n            \\n            if(vec[mid]<tgt){\\n                potCand= mid;\\n                low= mid+1;\\n            }\\n            else if(vec[mid]>=tgt){\\n                high= mid-1;\\n            }\\n        }\\n        return potCand;\\n    }\\n\\t\\n\\tlong long minCost(vector<int>& nums, vector<int>& cost) {\\n\\t\\t// pre-processing\\n        vector<pair<int, int>> vec;\\n        for(int i=0; i<nums.size(); i++){\\n            vec.push_back({nums[i], i});\\n        }\\n        \\n        sort(vec.begin(), vec.end());\\n        vector<int> temp(cost.size());\\n        for(int i=0; i<vec.size(); i++){\\n            nums[i]= vec[i].first;\\n            temp[i]= cost[vec[i].second]; \\n        }\\n        \\n        for(int i=0; i<temp.size(); i++){\\n            cost[i]=temp[i];\\n        }\\n        \\n        vector<long long> cumSumFront(cost.size()); long long t=0;\\n        for(int i=0; i<cost.size(); i++){\\n            t+=cost[i];\\n            cumSumFront[i]=t;\\n        }\\n        vector<long long> cumSumLast(cost.size()); t=0;\\n        for(int i=cost.size()-1; i>=0; i--){\\n            t+=cost[i];\\n            cumSumLast[i]= t;\\n        }\\n        \\n        long long finalCost= findCost(nums, cost, 1); // cost to make all arr ele equal to 1\\n        long long mini= INT_MAX;\\n        mini= min(mini, finalCost);\\n        \\n        // Calculation\\n        \\n        for(int x=2; x<=1000000; x++){\\n            // Now let say [0-i] indexed ele are < 1 --> so if we have to make all ele equal 2, then we have to add their cost\\n            // Similarly say [i\\'-size] indexed ele are >1 --> so if we have to make all ele equal 2, we have to sub their cost\\n            \\n            int i= binarySearch(nums, x); // [0-i] will be index whose val is < x\\n            if(i!=-1){ finalCost+= cumSumFront[i]; }\\n            \\n            int iBar=-1;\\n            auto it= lower_bound(nums.begin(), nums.end(), x);\\n            if(it!=nums.end()){ iBar= it-nums.begin(); }\\n            if(iBar!=-1){ finalCost-= cumSumLast[iBar]; } // [iBar-size] will be index whose val is >= x\\n            \\n            mini= min(mini, finalCost);\\n        }\\n        \\n        return mini;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2992659,
                "title": "weighted-median-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans = 0, n = nums.size(), s = 0, cnt = 0, target = 0;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({nums[i], cost[i]}), s += cost[i];\\n        sort(v.begin(), v.end());\\n\\n        for(int i=0; i<n; i++) {\\n            cnt += v[i].second;\\n            if(cnt > s / 2) {target = v[i].first; break;}\\n        }\\n\\n        for(int i=0; i<n; i++) ans += abs(nums[i] - target) * cost[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans = 0, n = nums.size(), s = 0, cnt = 0, target = 0;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({nums[i], cost[i]}), s += cost[i];\\n        sort(v.begin(), v.end());\\n\\n        for(int i=0; i<n; i++) {\\n            cnt += v[i].second;\\n            if(cnt > s / 2) {target = v[i].first; break;}\\n        }\\n\\n        for(int i=0; i<n; i++) ans += abs(nums[i] - target) * cost[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912720,
                "title": "prefix-sum-sort-java-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe idea is to keep moving from the smallest num value till the greatest num value keeping the track of sum of cost for values less than current num value as well as values greater than current num value. \\n\\nFor ex\\n\\nnum = [1, 2, 6, 5]\\ncost = [2, 3, 10, 2]\\n\\nAfter we sort them based on num array\\nnum = [1, 2, 5, 6]\\ncost =[2, 3, 2, 10]\\n\\nWhile traversing linearly from value i to i+1, if the current cost is currSum,  the change in cost to go from i to i+1 = currSum - rightSum + leftSum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are three factors\\n\\na) currSum - stores the exact cost to convert all the num values to the iterator i\\n\\nb) leftSum - stores the sum of cost for values less than the iterator i\\n\\nc) rightSum -  stores the sum of cost for values greater than the iterator i.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n   public long minCost(int[] nums, int[] cost) {\\n        long rightSum = 0L;\\n        long currSum = 0L;\\n        int n = nums.length;\\n        Integer[][] arr = new Integer[n][2];\\n        for(int i=0;i<n;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=cost[i];\\n        }\\n        // Sort based on the nums array\\n        Arrays.sort(arr, (a,b)->a[0]-b[0]);\\n\\n        // Figure out the index till where we have the value equal to first num array value\\n        int p = 0;\\n        long leftSum = 0L;\\n        while(p<n && arr[0][0]==arr[p][0]){\\n            leftSum+=arr[p][1];\\n            p++;\\n        }\\n\\n        // Calculate the current cost as currSum\\n        for(int i=p;i<n;i++){\\n            rightSum+=arr[i][1];\\n            currSum+=(long)(Math.abs(arr[i][0]-arr[0][0])) * (long)arr[i][1];\\n        }\\n        long ans = currSum;\\n        // Loop linearly till the nums array greatest value\\n        for(int h=arr[0][0]+1;h<=arr[n-1][0];h++){\\n            currSum-=rightSum;\\n            currSum+=leftSum;\\n\\n            // Remove all the indexes which have same value as h \\n            while(p<n && h==arr[p][0]){\\n                rightSum-=arr[p][1];\\n                leftSum+=arr[p][1];\\n                p++;\\n            }\\n            ans=Math.min(ans, currSum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public long minCost(int[] nums, int[] cost) {\\n        long rightSum = 0L;\\n        long currSum = 0L;\\n        int n = nums.length;\\n        Integer[][] arr = new Integer[n][2];\\n        for(int i=0;i<n;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=cost[i];\\n        }\\n        // Sort based on the nums array\\n        Arrays.sort(arr, (a,b)->a[0]-b[0]);\\n\\n        // Figure out the index till where we have the value equal to first num array value\\n        int p = 0;\\n        long leftSum = 0L;\\n        while(p<n && arr[0][0]==arr[p][0]){\\n            leftSum+=arr[p][1];\\n            p++;\\n        }\\n\\n        // Calculate the current cost as currSum\\n        for(int i=p;i<n;i++){\\n            rightSum+=arr[i][1];\\n            currSum+=(long)(Math.abs(arr[i][0]-arr[0][0])) * (long)arr[i][1];\\n        }\\n        long ans = currSum;\\n        // Loop linearly till the nums array greatest value\\n        for(int h=arr[0][0]+1;h<=arr[n-1][0];h++){\\n            currSum-=rightSum;\\n            currSum+=leftSum;\\n\\n            // Remove all the indexes which have same value as h \\n            while(p<n && h==arr[p][0]){\\n                rightSum-=arr[p][1];\\n                leftSum+=arr[p][1];\\n                p++;\\n            }\\n            ans=Math.min(ans, currSum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815919,
                "title": "c-weighted-median-commented-brief-explanation",
                "content": "Convert this question from Weighted Median to Plain Ordinary Median by duplicating the element its cost number of times. \\n\\nFor example, 1 2 3 with cost = 2,2,3, can be treated as \\n1 taken 2 times = 1 1\\n2 taken 2 times = 2 2\\n3 taken 3 times = 3 3 3\\n which gives, \\n \\n 1 1 2 2 3 3 3, \\n \\n Now find the median for the new set of numbers and get your min operated element. Now, reiterate over the numbers and keep updating the number of operations by the absolute difference between the median element and the original element.\\n \\nNote creating duplicate copies in reality and storing them in array will not be space-efficient. So, get catch of map for this task. Once, you get things cleared up in map, it becomes simple math and implementation.\\n ___________________________________________________________________________________________________\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) \\n    {\\n        long long int elements = 0; //total number of elements.\\n        map<int,long long int> mp;  // element mapped to its frequency\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mp[nums[i]]+= cost[i];  //creating the map reqd.\\n            elements+=cost[i];      //counting total number of elements.\\n        }\\n        \\n        long long int tofind1, tofind2; //these variables will put keep track of the median element(s) position.\\n        if(elements%2==0)   //even\\n        {\\n            tofind1 = elements/2;       //second pos = first pos + 1\\n            tofind2 = tofind1+1;\\n        }\\n        else    //odd\\n        {\\n            tofind1 = (elements+1)/2;   //both the positions will be same.\\n            tofind2 = tofind1;\\n        }\\n        long long int median, count = 0;\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            long long int ele = it->first, freq = it->second;\\n            if(count + freq >= tofind2) //if both the positions are within the spread of this element, then median = ele.\\n            {\\n                median = ele;\\n                break;\\n            }\\n            else if(count+freq == tofind1)  //if the split is across two different elements.\\n            {\\n                it++;\\n                median = (ele + (it->first))/2;\\n                break;\\n            }\\n            else    //if none matches, then continue. \\n            {\\n                count+=freq;\\n            }\\n        }\\n        \\n        long long int opns = 0; // counts the total operations.\\n        \\n        for(auto it: mp)\\n        {\\n            long long int ele = it.first, freq = it.second;\\n            opns+=(abs(ele - median) * it.second);\\n        }\\n        \\n        return opns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) \\n    {\\n        long long int elements = 0; //total number of elements.\\n        map<int,long long int> mp;  // element mapped to its frequency\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mp[nums[i]]+= cost[i];  //creating the map reqd.\\n            elements+=cost[i];      //counting total number of elements.\\n        }\\n        \\n        long long int tofind1, tofind2; //these variables will put keep track of the median element(s) position.\\n        if(elements%2==0)   //even\\n        {\\n            tofind1 = elements/2;       //second pos = first pos + 1\\n            tofind2 = tofind1+1;\\n        }\\n        else    //odd\\n        {\\n            tofind1 = (elements+1)/2;   //both the positions will be same.\\n            tofind2 = tofind1;\\n        }\\n        long long int median, count = 0;\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            long long int ele = it->first, freq = it->second;\\n            if(count + freq >= tofind2) //if both the positions are within the spread of this element, then median = ele.\\n            {\\n                median = ele;\\n                break;\\n            }\\n            else if(count+freq == tofind1)  //if the split is across two different elements.\\n            {\\n                it++;\\n                median = (ele + (it->first))/2;\\n                break;\\n            }\\n            else    //if none matches, then continue. \\n            {\\n                count+=freq;\\n            }\\n        }\\n        \\n        long long int opns = 0; // counts the total operations.\\n        \\n        for(auto it: mp)\\n        {\\n            long long int ele = it.first, freq = it.second;\\n            opns+=(abs(ele - median) * it.second);\\n        }\\n        \\n        return opns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753293,
                "title": "c-o-nlogn-solution",
                "content": "**C++ Code:**\\n\\n```\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n       int n = nums.size();\\n       vector<pair<int,int>>arr;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           arr.push_back({nums[i],cost[i]});\\n           sum += cost[i];\\n       }\\n       sort(arr.begin(),arr.end());\\n       long long N = (sum+1)/2;\\n       int x = -1;\\n       for(int i=0;i<n;i++){\\n           N -= arr[i].second;\\n           if(N<=0){\\n            x = arr[i].first;\\n            break;\\n           }\\n       }\\n     long long ans = 0;\\n     for(int i=0;i<n;i++){\\n      ans += (long long)abs(x-nums[i])*cost[i];   \\n     }\\n     return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n       int n = nums.size();\\n       vector<pair<int,int>>arr;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           arr.push_back({nums[i],cost[i]});\\n           sum += cost[i];\\n       }\\n       sort(arr.begin(),arr.end());\\n       long long N = (sum+1)/2;\\n       int x = -1;\\n       for(int i=0;i<n;i++){\\n           N -= arr[i].second;\\n           if(N<=0){\\n            x = arr[i].first;\\n            break;\\n           }\\n       }\\n     long long ans = 0;\\n     for(int i=0;i<n;i++){\\n      ans += (long long)abs(x-nums[i])*cost[i];   \\n     }\\n     return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2746206,
                "title": "c-concept-of-weighted-median-sorting",
                "content": "```\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        //Concept of weighted median\\n        long long m, sum = 0, ans = 0;\\n        for(int i=0;i<cost.size();i++) \\n            sum+=(long long)(cost[i]);\\n        //Storing in form of pairs and sorting it so as to find the median \\n        vector<pair<int,int>> p;\\n        for(int i=0;i<nums.size();i++) \\n            p.push_back({nums[i],cost[i]});\\n        \\n        sort(p.begin(),p.end());\\n        // for(auto i:p) \\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        //Finding out the median value \\n        //Bcoz across median value, the cost can be minimised\\n        long long curr = 0, i = 0;\\n        while(curr < (sum+1)/2 && i<nums.size()) {\\n            curr += p[i].second;\\n            m = p[i].first; i++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            ans += abs((long long)(nums[i]-m))*((long long)cost[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        //Concept of weighted median\\n        long long m, sum = 0, ans = 0;\\n        for(int i=0;i<cost.size();i++) \\n            sum+=(long long)(cost[i]);\\n        //Storing in form of pairs and sorting it so as to find the median \\n        vector<pair<int,int>> p;\\n        for(int i=0;i<nums.size();i++) \\n            p.push_back({nums[i],cost[i]});\\n        \\n        sort(p.begin(),p.end());\\n        // for(auto i:p) \\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        //Finding out the median value \\n        //Bcoz across median value, the cost can be minimised\\n        long long curr = 0, i = 0;\\n        while(curr < (sum+1)/2 && i<nums.size()) {\\n            curr += p[i].second;\\n            m = p[i].first; i++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++) {\\n            ans += abs((long long)(nums[i]-m))*((long long)cost[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2742602,
                "title": "c-binary-search-faster-easy-to-understand",
                "content": "* ***Using Binary Search***\\n\\n* ***Time Complexity :- O(N * log(maxi - mini))***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // function for finding cost to make all the elements equal to val\\n\\n    long long find_cost(vector<int>& nums, vector<int>& cost, int val)\\n    {\\n        int n = nums.size();\\n\\n        long long curr_cost = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_cost += (long long) abs(nums[i] - val) * (long long) cost[i];\\n        }\\n\\n        return curr_cost;\\n    }\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int n = nums.size();\\n\\n        // apply binary search on possible ans [mini, maxi] and take minimum\\n        \\n        int low = *min_element(nums.begin(), nums.end());\\n\\n        int high = *max_element(nums.begin(), nums.end());\\n\\n        long long ans = 0;\\n\\n        while(low < high)\\n        {\\n            int mid = low + (high - low) / 2;\\n\\n            // find minimum cost for mid\\n\\n            long long ans1 = find_cost(nums, cost, mid);\\n\\n            // find minimum cost for mid + 1\\n\\n            long long ans2 = find_cost(nums, cost, mid + 1);\\n\\n            // take the minimum of ans1 and ans2\\n\\n            ans = min(ans1, ans2);\\n\\n            // move pointer\\n\\n            if(ans1 >= ans2)\\n            {\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // function for finding cost to make all the elements equal to val\\n\\n    long long find_cost(vector<int>& nums, vector<int>& cost, int val)\\n    {\\n        int n = nums.size();\\n\\n        long long curr_cost = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            curr_cost += (long long) abs(nums[i] - val) * (long long) cost[i];\\n        }\\n\\n        return curr_cost;\\n    }\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        \\n        int n = nums.size();\\n\\n        // apply binary search on possible ans [mini, maxi] and take minimum\\n        \\n        int low = *min_element(nums.begin(), nums.end());\\n\\n        int high = *max_element(nums.begin(), nums.end());\\n\\n        long long ans = 0;\\n\\n        while(low < high)\\n        {\\n            int mid = low + (high - low) / 2;\\n\\n            // find minimum cost for mid\\n\\n            long long ans1 = find_cost(nums, cost, mid);\\n\\n            // find minimum cost for mid + 1\\n\\n            long long ans2 = find_cost(nums, cost, mid + 1);\\n\\n            // take the minimum of ans1 and ans2\\n\\n            ans = min(ans1, ans2);\\n\\n            // move pointer\\n\\n            if(ans1 >= ans2)\\n            {\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740382,
                "title": "dp-sorting",
                "content": "we sort the items based on the nums in decreasing order. the first time I calculate the cost if all reach to the highest, keep at as dp[0]. then each time we go one level down, also we need to store the prefix for cost. for every level we are going down, the right side, will be deducted and left side will be added. the left side is going down , so increase the cost but right side already added to highest level, now we are going down so must be made up. hope the explanation is clear. \\n\\n```\\nclass Solution {\\npublic:\\nlong long minCost(vector<int> nums, vector<int> cost)\\n{\\n\\tint n = nums.size();\\n\\tvector<vector<long long int>> v;\\n\\tfor (int i = 0; i < n; i++)\\n\\t\\tv.push_back({ nums[i], cost[i] });\\n\\n\\n\\tsort(v.begin(), v.end());\\n\\treverse(v.begin(), v.end());\\n\\tvector<long long int> pre(n), dp(n);\\n\\tpre[0] = v[0][1];\\n\\tfor (int i = 1; i < n; i++)\\n\\t\\tpre[i] = v[i][1] + pre[i - 1];\\n\\n\\tfor (int i = 1; i < n; i++)\\n\\t\\tdp[0] += (v[0][0] - v[i][0]) * v[i][1];\\n\\n\\tfor (int i = 1; i < n; i++)\\n\\t{\\n\\t\\tint t = (v[i - 1][0] - v[i][0]);\\n\\t\\tdp[i] = dp[i - 1] - t* (pre[n - 1] - pre[i - 1]) + t * (pre[i - 1]);\\n\\t}\\n\\n\\tlong long int mini = dp[0];\\n\\tfor (auto x : dp)\\n\\t\\tmini = min(mini, x);\\n\\treturn mini;\\n\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long minCost(vector<int> nums, vector<int> cost)\\n{\\n\\tint n = nums.size();\\n\\tvector<vector<long long int>> v;\\n\\tfor (int i = 0; i < n; i++)\\n\\t\\tv.push_back({ nums[i], cost[i] });\\n\\n\\n\\tsort(v.begin(), v.end());\\n\\treverse(v.begin(), v.end());\\n\\tvector<long long int> pre(n), dp(n);\\n\\tpre[0] = v[0][1];\\n\\tfor (int i = 1; i < n; i++)\\n\\t\\tpre[i] = v[i][1] + pre[i - 1];\\n\\n\\tfor (int i = 1; i < n; i++)\\n\\t\\tdp[0] += (v[0][0] - v[i][0]) * v[i][1];\\n\\n\\tfor (int i = 1; i < n; i++)\\n\\t{\\n\\t\\tint t = (v[i - 1][0] - v[i][0]);\\n\\t\\tdp[i] = dp[i - 1] - t* (pre[n - 1] - pre[i - 1]) + t * (pre[i - 1]);\\n\\t}\\n\\n\\tlong long int mini = dp[0];\\n\\tfor (auto x : dp)\\n\\t\\tmini = min(mini, x);\\n\\treturn mini;\\n\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738592,
                "title": "dip-in-the-array-c-binary-search",
                "content": "Just like the peak in the array, this is the similiar question with some few changes.\\nThe main idea of the algo is that there is a dip in the array we when draw all the cost to make numbers from 1 to maxElement in the array, you will observe a dip, that dip is our ans. And using Binary Search we can try those numbers and we\\'ll also calculate the cost to make the next element that will help us in defining the direction for BS.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans = LONG_LONG_MAX;\\n        int n = cost.size();\\n        \\n        int low = 0, high = *max_element(nums.begin(), nums.end());\\n        \\n        while (low <= high) {\\n            long long mid = low + (high - low) / 2LL;\\n            \\n            long long curr_cost = 0, other_cost = 0;\\n            \\n            for (int i = 0; i < n; i++) {\\n                curr_cost += abs(mid - nums[i]) * cost[i]; // this is the currCost\\n                other_cost += abs(mid + 1 - nums[i]) * cost[i]; // and this is the cost which will help us to move whether left or right\\n            }\\n            \\n            ans = min(ans, curr_cost);\\n            \\n            if (curr_cost <= other_cost) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote** if you found it helpful :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans = LONG_LONG_MAX;\\n        int n = cost.size();\\n        \\n        int low = 0, high = *max_element(nums.begin(), nums.end());\\n        \\n        while (low <= high) {\\n            long long mid = low + (high - low) / 2LL;\\n            \\n            long long curr_cost = 0, other_cost = 0;\\n            \\n            for (int i = 0; i < n; i++) {\\n                curr_cost += abs(mid - nums[i]) * cost[i]; // this is the currCost\\n                other_cost += abs(mid + 1 - nums[i]) * cost[i]; // and this is the cost which will help us to move whether left or right\\n            }\\n            \\n            ans = min(ans, curr_cost);\\n            \\n            if (curr_cost <= other_cost) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1937934,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937867,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937811,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937981,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938098,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938087,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938032,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1656564,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937978,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938125,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937934,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937867,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937811,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937981,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938098,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938087,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938032,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1656564,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1937978,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938125,
                "content": [
                    {
                        "username": "Sakshi_646",
                        "content": "RIP to my june streak"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Don\\'t worry about virtual numbers. Learn how this problem is solved. Next time you will be ready to crack similar tasks. Don\\'t stop making progress"
                    },
                    {
                        "username": "sKipper97",
                        "content": "You can do better."
                    },
                    {
                        "username": "divy_kant",
                        "content": "QUESTION gave me intution that it is an DYNAMIC PROGRAMMING question , but its\\'s more of a binary search\\n"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@user5400vw](/user5400vw) no no no no no. I think doing that might work, but it\\'s not very efficient. "
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@kings_dead](/kings_dead)  yes surely i can write , while traversing over the array and sending diffrent values of array as target.\\nYou can refer my recursion code which could eaily be converted to memoization for sure.\\n\\n\\n    long long f(int ind,int target,vector<int>& \\nnums,vector<int>& cost){\\n        int n=nums.size();\\n        if(ind>=n) return 0;\\n        long long int temp=1LL*(1LL*abs(nums[ind]-target)*1LL*cost[ind]);\\n        return temp+f(ind+1,target,nums,cost);\\n    }\\n    long long minCost(vector<int>& nums,vector<int>& cost){\\n        int n=nums.size();\\n        long long int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            long long int target=nums[i];\\n            mini=min(mini,f(0,target,nums,cost));\\n        }\\n        return mini;\\n    }"
                    },
                    {
                        "username": "dash_dash",
                        "content": "how u thought of dp ??\\ncan u write the solution using dp ?"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@gunjan192002](/gunjan192002) and how to choose?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "interesting.. so it\\'s kind of like triangulation, like you try two numbers.  and you eliminate possibilities based on if you are warmer (smaller cost) or colder."
                    },
                    {
                        "username": "gunjan192002",
                        "content": "Whenever you confused regarding it will be dynamic programming or  binary search you can check the value of n here it was 10^5 so obviously either some pre-computation or stack or binary search was there and then choose one out ."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Today is Wednesday. Hard Wednesday!!!\nLet me translate into the form what I can understand.\nConsider the function\n$$\nf(x)=\\sum_i |nums[i]-x|cost[i]\n$$\nFind min(f(x)) where x is an integer, of course x must be between min(nums) and max(nums). At least, a brute force method is possible!\nOne more hint: One  can use the fact that the searching x is nearby the weighted median. "
                    },
                    {
                        "username": "echohowardlam",
                        "content": "Hint: it is not the weighted average, but the weighted median, you can find the math property by google."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "If the hints given by Leetcode are like yours, then there are no hard problems that I cannot solve!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The mean deviation is not exactly least around weighted average !"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Wow, this problem is really good. You can learn two new concepts from it. Not intuitive from my pov."
                    },
                    {
                        "username": "User-denys",
                        "content": "[@rajeshsingh505](/rajeshsingh505) hard concepts..."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "which concepts ? "
                    },
                    {
                        "username": "sigmale",
                        "content": "HINT: consider sorted sequence a1,a2,a3,...an\\nthen min value of |a1-x| + |a2-x| +....+|an-x| occurs when x is the median of the sequence.\\nci = cost for ai\\nNow we just need to minimize c1*|a1-x| + c2*|a2-x| +....+cn*|an-x| which is like a sequence with c1 a1s, c2 a2s and so on.."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani) Yes push nums[i] till cost[i] times"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@abijahkaj](/abijahkaj)  I shared my code to get help from sigmale, this code is not proper solution, it will pass only example testcases."
                    },
                    {
                        "username": "Hritik29",
                        "content": "Nice..I solved using your hint."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "[@sigmale](/sigmale) you mean i should calculate the median after multiplying nums[i]*cost[i]?\nor should i push the nums[i] in temp till cost[i] times."
                    },
                    {
                        "username": "sigmale",
                        "content": "[@Harsh_Balwani](/Harsh_Balwani)  As far as I see you have calculated median of array temp (which basically is nums), but here you will need to calculate the median of an array(or list) in which num[i] occurs cost[i] times, that should give the optimal answer"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "class Solution {\\npublic:\\n    long long int median(vector<int>&temp)\\n    {\\n     sort(temp.begin(),temp.end());\\n     long long int median=0;\\n    long long int n=temp.size();\\n        if(n%2!=0)\\n            {\\n            median=temp[((n/2))]; \\n            return median; \\n            } \\n        else\\n            {\\n            median=(temp[((n/2))]+temp[(n/2)-1])/2;\\n            return median;\\n            }   \\n    }\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n       vector<int>temp(nums.size());\\n       temp=nums;\\n       long long int x=median(temp);\\n       long long int result=0;\\n        for(long long int i=0;i<nums.size();i++)\\n        {\\n           long long int mincost=0;\\n            if(nums[i]==x){break;}\\n            else if(nums[i]>x)\\n            {\\n                mincost=mincost+((cost[i])*(nums[i]-x));\\n            }\\n            else\\n            {\\n                 mincost=mincost+((cost[i])*(x-nums[i]));\\n            }\\n            result=result+mincost;\\n        }\\n        return result;\\n    }\\n};\\nwas able to pass only example testcases, Can you help with it\\nPS- I am new to DSA and i dont know the concept of List."
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Thanks a lot man that\\'s a nice approach"
                    },
                    {
                        "username": "najwer23",
                        "content": "41/48 arghhhhhhh"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Show me the code , i think you might not be using the ceil , i was also stuck"
                    },
                    {
                        "username": "Akashsb",
                        "content": "Damn, I thought converting the array into the element with the highest frequency would work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "[@Nexes_OO7](/Nexes_OO7) did you got it right? Because I am not getting correct answer by median method for this testcase:\nnums=[735103,366367,132236,133334,808160,113001,49051,735598,686615,665317,999793,426087,587000,649989,509946,743518]\n\ncost=[724182,447415,723725,902336,600863,287644,13836,665183,448859,917248,397790,898215,790754,320604,468575,825614]\n\nmy ans=2323045568788\nactual=1907611126748\n\n\nEdit: Got my mistake lol. Thanks for the approach. btw how did you get this approach? I was making every other element to the element which has max cost. After your hint I get where my approach will fail."
                    },
                    {
                        "username": "Akashsb",
                        "content": "[@Nexes_OO7](/Nexes_OO7) Yeah, I solved it that way later on \\u270C\\uFE0F\\u270C\\uFE0F"
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "just find the median bro by taking frequency of each element as cost"
                    },
                    {
                        "username": "yingfei_hong01",
                        "content": "This is similar to finding the linear regression line"
                    },
                    {
                        "username": "hom0",
                        "content": "[@djslim](/djslim) I think you can check out [this](https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html)\\nThough they are not exactly the same, Linear regression is to minimize the square error, this problem is to minimize something different ( I\\'m not familiar with statistics so I can\\'t tell what this \"error\" is called ) but the physical meaning can still be mimicked. I wrote about this similarity here: https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3671246/c-solution-an-analogy-from-a-physics-perspective/"
                    },
                    {
                        "username": "djslim",
                        "content": "Can you link similar problems here?"
                    },
                    {
                        "username": "Vishu_1812",
                        "content": "Ah shit here we go again ......."
                    },
                    {
                        "username": "mws19901118",
                        "content": "CJ, is that you?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "LOL"
                    },
                    {
                        "username": "akashvdubey",
                        "content": "why ? Changing the elements into one of the numbers already existing in the array nums is optimal. can\\'t it be some another number that donot exist like if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": ">  if weight of all elements are same let\\'s say 1, it would be optimal to move towards average?\\n\\nNot exactly. [In such case](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/) it would be optimal to move towards *median*."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@sharingan_user](/sharingan_user) Sure.\\nSee, for $totalCost(x+1)$ we add $(costsOfNums < x) - (costsOfNums > x)$\\nAnd for the $totalCost(x-1)$ we add $(costsOfNums > x) - (costsOfNums < x)$\\nThe same value, just negative.\\nDenote $(costsOfNums < x) - (costsOfNums > x)$ as $y$ and we get:\\n$totalCost(x+1) =  totalCost(x) + y$\\n$totalCost(x-1) =  totalCost(x) - y$\\nSo, min for these two will be:\\n$min( totalCost(x-1), totalCost(x+1) ) = totalCost(x) + min(y, -y) = totalCost(x) - max(y, -y) = totalCost(x) -abs(y)$"
                    },
                    {
                        "username": "toravipatel",
                        "content": "very true [@Akash Dubey](/akashvdubey). I agree with your logic and before looking at the hint , I thought of the same solution."
                    },
                    {
                        "username": "audumbar123",
                        "content": "consider array of 2 elements give them any  random costs you will find it out"
                    },
                    {
                        "username": "sharingan_user",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) didn\\'t understood the conclusion part-\\n\\nmin(totalCost(x\\u22121),\\u2800totalCost(x),\\u2800totalCost(x+1))=totalCost(x)\\u2212\\u2223(costsOfNums>x)\\u2212(costsOfNums<x)\\u2223\\n\\ncan you elaborate this bit more?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Suppose we have a target value $x$ to which we will bring all the nums. \n\n**tl;dr: If x, being optimal, is not equal to any num, then the nums closest to its value from above and below will also be optimal.**\n\n---\n\nDenote the total cost answer for it as $totalCost(x)$\n\nConsider the total cost for $x+1$. It will add to total the sum of costs for nums ⩽ x, and subtract the sum of costs for nums > x.\nSo, $totalCost(x+1) =  totalCost(x) + (costsOfNums ⩽ x) - (costsOfNums > x)$\nNow, for the total cost of x-1. It will add to total the sum of costs for nums ⩾ x, and subtract the sum of costs for nums < x.\nSo, $totalCost(x-1) =  totalCost(x) + (costsOfNums ⩾ x) - (costsOfNums < x)$\n\nNow see, what happens if $x$ value is somewhere between nums, not equal to any. ⩽ and ⩾ turn into < and > for that case:\n$totalCost(x+1) =  totalCost(x) + (costsOfNums < x) - (costsOfNums > x)$\n$totalCost(x-1) =  totalCost(x) + (costsOfNums > x) - (costsOfNums < x)$\nConcluding:\n$min( totalCost(x-1),⠀totalCost(x),⠀totalCost(x+1) ) = totalCost(x) - |(costsOfNums > x) - (costsOfNums < x)|$\n\nIn other words, **for one of the values adjacent to $x$, the total cost will be less or equal than for $x$**. If it is less, then $x$ is not the optimal value. If it is equal to the totalCost for x, it means that (sum of costs for nums > x) == (sum of costs for nums < x), for all $x$ in that interval between the nums. That is, all $x$ in this interval, along with bounding nums on both sides will have the same totalCost. Hence these nums will also be optimal, if $x$ is."
                    }
                ]
            },
            {
                "id": 1938281,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1939011,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1937826,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1938837,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1938443,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1938422,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1938006,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1937998,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1937898,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1938712,
                "content": [
                    {
                        "username": "2020ec0044",
                        "content": "passed 40/48 testcases; stucked with TLE :)\\nRIP to my streaks."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Hint: \\n\\n\\nSort. \\n\\nMore detailed hint:\\nSort the array "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "How will it reduce the amount of operations ? Could You elaborate ?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "The hint makes this a medium, to figure it out though is pretty hard"
                    },
                    {
                        "username": "hewy96",
                        "content": "what are u talking about \\n"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "hint gives tle..."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@kylecrowley](/kylecrowley) It's a medium with the hint"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, you haven\\'t even solved the problem yet. At least solve the problem before commenting on the difficulty..."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "i have solved the problem using dp. \nAfter solving I am seeing in hint - \n\n\"Changing the elements into one of the numbers already existing in the array nums is optimal.\"\n\nhow is this intuitive ? "
                    },
                    {
                        "username": "cooscoos",
                        "content": "Because it is linear programming problem... And the optimum can be achieved at one of the corners only...(the corners are values of nums[i])"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "41/48 \\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE35"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil "
                    },
                    {
                        "username": "SG-C",
                        "content": "I tried so hard and got so far But in the end failed at test case 41 \\uD83E\\uDD72"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Use ceil"
                    },
                    {
                        "username": "dumb_me",
                        "content": "mid weekend crisis \\uD83D\\uDE2D"
                    },
                    {
                        "username": "mistyotter",
                        "content": "NO WAY. HARD AGAIN"
                    },
                    {
                        "username": "mistyotter",
                        "content": "UPD: Solved!!!! I\\'m so proud of myself"
                    },
                    {
                        "username": "thomastsoi",
                        "content": "I tried using gradient descent to solve this question numerically, then I realized the numerical errors are difficult to eliminate and the method rarely gives exact answers. "
                    },
                    {
                        "username": "CConory",
                        "content": "Using a gradient descent is more like binary search. \\nFor example, if m is the middle of min(nums) ~ max(nums);\\nlet function f is the cost of putting all the nums to equal m.\\nThus we could calculate the gradient of f\\'(m) = f(m+1)-f(m)/ (m+1 - m).\\nIf f\\'(m) is large than 0, $m$ should get less to get the more minmum cost.\\nOtherwise,  $m$ should become larger."
                    },
                    {
                        "username": "thomastsoi",
                        "content": "[@Dwaraganathan15](/Dwaraganathan15) Thanks. I simply made Wolfram Alpha do the differentiation for me:\n\nThe derivative is <img src=\"https://latex.codecogs.com/svg.image?%5Cfrac%7B%5Cmathrm%7Bd%7Df%28x%29%7D%7B%5Cmathrm%7Bd%7Dx%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dcost%5Bi%5D%5Cfrac%7Bx-nums%5Bi%5D%7D%7B%5Cleft%7Cx-nums%5Bi%5D%5Cright%7C%7D\">\n\n```\nimport numpy as np\n\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        self.nums = nums\n        self.cost = cost\n        maxNum, minNum = max(nums), min(nums)\n        k = round(self.gradient_descent(self.gradient, start=(maxNum+minNum)/2.001, learn_rate=0.005))\n        totalCost = sum([abs(nums[i]-k)*cost[i] for i in range(len(nums))])\n        return totalCost\n\n    def gradient_descent(self, gradient, start, learn_rate, n_iter=100, tolerance=1e-06) -> float:\n        vector = start\n        for _ in range(n_iter):\n            diff = -learn_rate * gradient(vector)\n            if np.all(np.abs(diff) <= tolerance):\n                break\n            vector += diff\n        return vector\n\n    def gradient(self, x) -> float:\n        return sum([self.cost[i] * (x-self.nums[i]) / abs(x-self.nums[i]) for i in range(len(self.nums))])\n```"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "The objective function to minimise includes |x| function which is not differentiable. But still, as its continuous and unimodal, gradient descent might work.\nYou can even use other non-gradient search algorithms like Bisection search, Genetic algorithm, Particle swarm optimization, Box method etc.\n\nHowever, methods like Bisection/Binary search would work within time limit as compuation time of objective function itself is O(n).\n\nCan you share your code so we could see and figure out more..?!"
                    },
                    {
                        "username": "surYeah",
                        "content": "it will give precise answer ,but u need iterate more."
                    },
                    {
                        "username": "adarshAlagade",
                        "content": "In Java , use Long.MAX_VALUE. Don\\'t use Integer.MAX_VALUE because of habit."
                    }
                ]
            },
            {
                "id": 1938341,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 1938252,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 1938116,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 1938055,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 1937948,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 1743573,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 1655404,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 2060543,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 2020174,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 2006386,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "Not just binary, but ternary search is possible here. Good opportunity to apply such a rare thing."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I was thinking the same thing !"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "Hey [@Vladimir Davidovich](/VladimirTheLeet) thanks for the tip, just wanted to know how you arrived at this conclusion, what's the intution behind it? Also, what are the things that one should consider before applying ternary search?\n\nThanks in advance!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "After spending more than two hrs i finally got to know that it\\'s not my cup of tea. "
                    },
                    {
                        "username": "AnywaySo",
                        "content": "I solved this problem by using prefix sum, and didn\\'t see where to use binary search."
                    },
                    {
                        "username": "dakuripramod",
                        "content": "so its not possible to use binary search\\n"
                    },
                    {
                        "username": "leet_alok",
                        "content": "I first thought why don\\'t we just make every element mean of the all. What\\'s hard in this but later realised the cost isn\\'t uniform."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Come on it\\'s only Wednesday, why hard"
                    },
                    {
                        "username": "Bingo_o",
                        "content": "It is Wednesday, my dude!"
                    },
                    {
                        "username": "djslim",
                        "content": "Somewhat similar to https://leetcode.com/problems/candy/description/ "
                    },
                    {
                        "username": "psionl0",
                        "content": "I\\'m not seeing it myself. In the candy problem you iterate over a single array from left to right then from right to left making the necessary adjustments to the elements as you go.\\n\\nIt sounds like a lot simpler method than what I used (if I could adapt it)."
                    },
                    {
                        "username": "72engineers",
                        "content": "so usually the weekly contest was like 1 easy, two medium, 1 hard. why there are two hard questions in this week?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "[@PandaPro](/PandaPro) cope"
                    },
                    {
                        "username": "PandaPro",
                        "content": "Every time I open discussion section in hope of some hint, or intuition, i find some unrelated to the question comment :("
                    },
                    {
                        "username": "nat1902",
                        "content": "[@godshiva](/godshiva)  Lol"
                    },
                    {
                        "username": "godshiva",
                        "content": "They knew it was my first competition and wanted to make me sad"
                    },
                    {
                        "username": "Ayushi1504",
                        "content": "The hint is useless, better delet it"
                    },
                    {
                        "username": "khushimattu",
                        "content": "Can someone tell me whats wrong w this? Did I misunderstand the question?\n```\nclass Solution {\n    public long minCost(int[] nums, int[] cost) {\n        long min=Integer.MAX_VALUE;\n        \n        for(int i=0;i<nums.length;i++){\n            min=Math.min(min,helper(nums,cost,i));\n        }\n        return (long)min;\n    }\n\n    public long helper(int[] nums,int[] cost,int i)\n    {\n        int set=nums[i];\n        long cost2=0;\n        for(int j=0;j<nums.length;j++){\n           cost2=cost2+(long)(Math.abs(nums[j]-set))*(long)cost[j];\n            \n        }\n        return cost2;\n    }\n}\n```\n"
                    },
                    {
                        "username": "kelvin_ting",
                        "content": "is struggling to understand the question is a stop sign for getting into big tech?"
                    }
                ]
            },
            {
                "id": 1964917,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1960102,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1941011,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1939850,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1939511,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1939374,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1939300,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1939151,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1939145,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1939082,
                "content": [
                    {
                        "username": "dvs1117",
                        "content": "Can anyone help me with this . Getting Integer overflow error (signed integer overflow: 368736 * 447415 cannot be represented in type \\'int\\' ). Not corrected after declaring variables as long long"
                    },
                    {
                        "username": "harry_C0der",
                        "content": "[@Venkatasurya](/suryadegala1117) also try typecasting int to long long before multiplying each variables. like : (long long) a * (long long) b."
                    },
                    {
                        "username": "Nur17",
                        "content": "40/48\\n"
                    },
                    {
                        "username": "cooscoos",
                        "content": "At the end it is  linear programming problem... So the minimum can be obtained only at one of the corners (i.e. values of $$nums[i]$$"
                    },
                    {
                        "username": "lumos_01",
                        "content": "Problem is a variation of search peak element in an unsorted array . Try to figure out how the graph between cost and element (which we have selected to make all other equal to) will look like."
                    },
                    {
                        "username": "user2308W",
                        "content": "Should weighted_avg work ? Its showing errors for me."
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@Jyotiraditya Yadav](/sigmale)                                                  when we find median of nums then when it\\'s have size even then we can not find exact median which present in the nums vector than many testcase is fail give me some hint"
                    },
                    {
                        "username": "sigmale",
                        "content": "you don\\'t need to find the exact median, in case of even length you can either choose (n/2)th element or  (n/2 +1)th element of the array, both gives the optimal answer, you can check that.( where n is the length of the array) "
                    },
                    {
                        "username": "balajibaheti1996",
                        "content": "Can someone suggest where I am doing wrong??\\n\\n39 case pass out of 49. I am using prefix and postfix approach where for each element, calculate prefix and postfix and then find solution as min(prefix+postfix) for that position\\n\\n    long long minCost(vector<int>& nums, vector<int>& cost) {\\n        long long ans=LLONG_MAX;\\n        int nums_max=0;\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums_max=max(nums_max,nums[i]);\\n            mp[nums[i]]=cost[i];\\n        }\\n        vector<long long>prefix(nums_max+2,0);\\n        vector<long long>postfix(nums_max+2,0);\\n        for(int i=0;i<=nums_max+1;i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                prefix[i]+=(long long)mp[i];\\n                postfix[i]+=(long long)mp[i];\\n            }\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=1;i<prefix.size();i++)\\n        {\\n            prefix[i]+=prefix[i-1];\\n        }\\n        for(int i=postfix.size()-2;i>=0;i--)\\n        {\\n            postfix[i]+=postfix[i+1];\\n        }\\n        for(int i=nums_max-1;i>=0;i--)\\n        {\\n            ans=min(ans, prefix[i]+postfix[i+2] );\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Not really a hard - hard one tbh. If you are familiar with prefix sum and some basic math, you can come with a very intuitive solution. \n- Big hint: your target number to which all others need to be raised/lowered is one of the numbers in nums array. you just have to find which one.\n- Just sort/group the numbers by value (mapped against cumulative cost): EG: if you have [1,2,3,2] and cost = [4,4,9,3] , you see that number 2 will have a total cost of 4+3 = 7.\nSo mapping will be [1 ->4, 2 -> 7, 3 -> 9]\n1 -> 4 (number 1 will have a cost of 4\n2 -> 7 (number 2 will have a cost of 7)\n3 -> 9 (number 3 will have a cost of 9).\n- One you have this cost,  intuitively you can think of trying to make all number equal to 1, then to 2 then 3, but this will mean you will need to traverse the whole array each time to compute the left and right cost.\n- This can be optimized by doing a prefix cost (to upgrade all number to 1, to 2, to 3) and a postfix cost (to downgrade all number to 3, to 2, to 1).\nThen simply, for each number, add the cost of rising all numbers to its left (prefix cost) and lowering all number to the right (postfix cost)."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "TLE for [180685,320064,272290,230471,102586,531725,853830,420432,624975,633261,819202,515794,214818,719892,524062,79363,745784,574385]\n\nWhereas TC passes when i debug it. I got the output as : 2040493286924\n\nAm i doing something wrong ?\n\nMy hilarious high time complexity code is here: \n\n```vector<int> nums_replica = nums;;\n        vector<long long> max_cost;\n        for(int i =0;i<nums.size();i++){\n            long long cst =0;\n            for(int j =0;j<nums.size();j++){\n                if(nums[j]>nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]-1;\n                        cst=cst + cost[j];\n                    }\n                }\n                else if(nums[j]<nums[i]){\n                    while(nums[j]!=nums[i]){\n                        nums[j]=nums[j]+1;\n                        cst=cst + cost[j];\n                    }\n                }\n            }\n            max_cost.push_back(cst);\n            cst =0;\n            nums = nums_replica;\n        }\n        sort(max_cost.begin(),max_cost.end());\n        return max_cost[0];\n```"
                    },
                    {
                        "username": "Thomas-Reinecke",
                        "content": "Time Limit Exceeded - Why?\n\nI have a very lean bit of code - just a return statement, basically. The code runs smoothly (i.e. error-free, as far as I can tell) and reasonably fast (again, as far as I can tell) if I run it locally. It is not only the leanest bit of code I can think of coming up with for the problem, it is also the fastest, and I have been trying many different things before. \n\nHowever, I stll keep getting a \"Time Limit Exceeded\" error when submitting. Runtime when running it on the two basic testcases given has been as low as 12 ms. However, on testcase 38 (sometimes 37) I get that error. Timing my solution with exactly that testcase on my local machine yields a runtime of just below 5 seconds. \n\nAny ideas anyone what I can do about it?\n\nPS: I'm new here, only started the day before yesterday.  \n\n\n"
                    },
                    {
                        "username": "0x6B0",
                        "content": "You must optimise the code so that the runtime of your algorithm doesn\\'t grow exponentially with the data set "
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Code taking 5000ms to run a test case shall be considered as very high. I am also facing TLE Exceeded error."
                    }
                ]
            },
            {
                "id": 1939068,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1939064,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1939048,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1939000,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1938996,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1938952,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1938848,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1938815,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1938796,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1938789,
                "content": [
                    {
                        "username": "SahilNikam",
                        "content": "TLE after 41 testcases :)"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "TLE :("
                    },
                    {
                        "username": "seeker_747",
                        "content": "Share your code"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Can someone please explain why we search from the range (min(nums), max(nums))? I get why this would work, but it seems more efficient to sort the array, then do a binary search and try numbers in the array as a potential cost. Since the array length is at most 10^5 and the highest possible cost is 10^6, we could have a smaller search range using the array search instead.\\n\\nBy searching from the range (min(nums, max(nums)), it seems to imply that the answer is possibly a number that didn\\'t already exist in the array, which I haven\\'t been able to see how that would be possible."
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "Nvm I figured it out, we can do the method I did. I ended up getting the code to work."
                    },
                    {
                        "username": "dipanshuSaini",
                        "content": "can some one help me out with this one int n  = nums.length;\\n        long[] frnt_hash = new long[n];\\n        long[] bkwd_hash = new long[n];\\n\\n\\n        // sorting and storing;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++)map.put(nums[i],cost[i]);\\n\\n        Arrays.sort(nums);\\n\\n        // storing prefix\\n\\n        // front\\n        long prev = 0;\\n        for(int i=0;i<n-1;i++){\\n            long deviation = nums[i+1] - nums[i];\\n            long prefix = i == 0 ? 0 : frnt_hash[i-1];\\n            prev += map.get(nums[i]);\\n            frnt_hash[i] = (prev * deviation) + prefix;\\n        }\\n\\n        // backwards\\n        long next = 0;\\n        for(int i=n-1;i>0;i--){\\n            long deviation = nums[i] - nums[i-1];\\n            long postfix = i == n-1 ? 0 : bkwd_hash[i+1];\\n            next += map.get(nums[i]);\\n            bkwd_hash[i] = (next * deviation) + postfix;\\n        }\\n\\n        // calculating min_cost\\n        long min_cost = Long.MAX_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            long temp_prev = i == 0 ? 0 : frnt_hash[i-1];\\n            long temp_next = i == n-1 ? 0 : bkwd_hash[i+1];\\n\\n            min_cost = Math.min(min_cost, temp_prev + temp_next);\\n        }\\n\\n\\n        return min_cost;\\n\\ni just cant figure it out where im wrong\\n"
                    },
                    {
                        "username": "vologirov",
                        "content": "It's driving me crazy.. Why do we distract the suffix sum? Since it's a cost shouldn't we add it up to the total cost like we did with the prefix sum?  "
                    },
                    {
                        "username": "_priyang__",
                        "content": "It is given in the editorial that \"We just need to try every nums[i] as the base\". I did not understand why there is no need to try for each number from 1 to max(nums[i]) ? I am taking about [Approach 1: Prefix Sum]. Can anyone explain this..."
                    },
                    {
                        "username": "N1qro",
                        "content": "Wow. If you look at the solution speed diagram in Python, you will see a pretty interesting constant of 1.47% on each 5-10ms. Looks impressive!"
                    },
                    {
                        "username": "mrius",
                        "content": "A tip: If you want to solve this problem with binary search, disregard the fact that the optimal value is already one of the values in nums. You can find the the optimal value in another way."
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "its literally O(N) problem , still it gave me free TLE twice just because of using global variable ? doesn\\'t make any sense."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Hope your journey from trying to solve this question with DP to happen to solve it with Binary Search went well"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "it can be solved using dp only, how binary search comes in place ? "
                    }
                ]
            },
            {
                "id": 1938686,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938679,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938598,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938595,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938582,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938530,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938437,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938396,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938367,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938360,
                "content": [
                    {
                        "username": "holydel",
                        "content": "Fuh. My first hard daily problem done. "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "One hint I can suggest is try to find the largest value in cost if there is and use that nums[i] to find cost."
                    },
                    {
                        "username": "An-Yay",
                        "content": "This looks like a dp question of using weights to me"
                    },
                    {
                        "username": "xiaol825",
                        "content": "Hard in middle of the week??? : ("
                    },
                    {
                        "username": "palak-agg",
                        "content": "The last thing I expected was a hard wednesday"
                    },
                    {
                        "username": "iontbo",
                        "content": "Can anyone explain why is Changing the elements into one of the numbers already existing in the array nums optimal? Can\\'t the minima fall someplace else, on a number not present in nums?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Looking like my 2-day streak is going to break \\uD83E\\uDD72\\uD83E\\uDD72\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB"
                    },
                    {
                        "username": "Aabshar",
                        "content": "HELP !!\ni am not getting where am i wrong\nstep1-> make a pair array arr[ ] and sort on basis of  COST\nstep2-> prefix sum of cost in Pair array arr itself\nstep3-> binary search as follows \n\nif left side elements cost is less than rightside +current index cost then\nleft should move  \n**target is value in nums that is taken to make other element equal to\n\n ` \n  int l=0;\n      int r=n-1;\n\n      long target=(long)nums[0];\n\n      while(l<=r){\n        int mid=(l+r)/2;\n        long lsum=mid>0?(long)arr[mid-1].sum:0l;\n        long rsum=(long)(arr[n-1].sum-arr[mid].sum); \n        if(rsum>=lsum){\n            l=mid+1;\n            target=arr[mid].target;\n        }\n        else{\n            r=mid-1;\n        } \n      }\n`\n"
                    },
                    {
                        "username": "smat888",
                        "content": "my streak \\uD83D\\uDC80"
                    },
                    {
                        "username": "LightYagami_45",
                        "content": "class Solution {\n    public long minCost(int[] nums, int[] cost) {\n        int n=nums.length;\n        long[] result = new long[n];\n        long[]  sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            for(int j=0;j<n;j++){\n                 result[j] =(long) Math.abs(nums[i] - nums[j]) * cost[j];\n            }\n             for (int k = 0; k < n; k++) {\n                 sum[i] += result[k];\n            }\n        }\n        long min=sum[0];\n        for(int i=1;i<n;i++){\n            if(min>sum[i]){\n                min=sum[i];\n            }\n        }\n        return min;\n\n            \n    }\n} This is my solution where 41 test cases pass but the time complexity goes high.\n \n"
                    }
                ]
            },
            {
                "id": 1938333,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938330,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938230,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938213,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938192,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938187,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938184,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938151,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938054,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1938051,
                "content": [
                    {
                        "username": "sarthak8008",
                        "content": "Why this code fails for some testcases? \\n\\nlong long minCost(vector<int>& nums, vector<int>& cost) {\\n        int mx=-1,idx=-1;\\n        int n=cost.size();\\n        for(int i=0;i<n;i++){\\n            if(mx<cost[i]){\\n                idx=i;\\n                mx=cost[i];\\n            }\\n        }\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=nums[idx]){\\n                long long d=abs(nums[idx]-nums[i]);\\n\\n                s+=(d*cost[i]);\\n            }\\n        }\\n        return s;\\n    }"
                    },
                    {
                        "username": "venompool",
                        "content": "Tip: using default minvalue as INT_MAX will give WA, instead use LLONG_MAX"
                    },
                    {
                        "username": "SACD",
                        "content": "my god I solved by my own\n\n```python\nclass Solution:\n    def minCost(self, nums: List[int], cost: List[int]) -> int:\n        l, r = min(nums), max(nums)+1 \n        @cache\n        def h(n):\n            total = 0\n            for i in range(len(nums)):\n                total += abs(nums[i] - n) * cost[i]\n            # print(n, total)\n            return total \n        while l < r:\n            m = (l + r)//2\n            if h(m) > h(m-1):\n                r = m\n            else:\n                l = m +1  \n        return h(l-1)\n```"
                    },
                    {
                        "username": "rishu_kr",
                        "content": "nice question  "
                    },
                    {
                        "username": "giriraj191",
                        "content": "I just want to know... Why Median **not Mean**? Anyone Please\\uD83E\\uDD14"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I think it\\'s 2 days early for a hard one!!"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Binary Search Solution Easy with proper Algorithm.\\n\\nApproach\\nStart the function findCost with parameters nums, cost, and x.\\nInitialize a variable sum as 0.\\nIterate over each element num in nums.\\nAdd the absolute difference between x and num multiplied by the corresponding element in cost to sum.\\nReturn the value of sum.\\nStart the function minCost with parameters nums and cost.\\nSet n as the size of nums.\\nInitialize mini as the maximum possible integer value.\\nInitialize maxi as the minimum possible integer value.\\nIterate over each element num in nums.\\nUpdate mini as the minimum of mini and num.\\nUpdate maxi as the maximum of maxi and num.\\nInitialize ans as the maximum possible long long value.\\nPerform a binary search using the variables mini and maxi as the lower and upper bounds.\\nWhile mini is less than or equal to maxi:\\nCalculate the midpoint mid as mini + (maxi - mini) / 2.\\nCompute the cost for mid using the findCost function and store it in temp.\\nUpdate ans as the minimum of ans and temp.\\nCalculate the costs for mid - 1 and mid + 1 using the findCost function and store them in l and r.\\nIf temp is less than both l and r, return ans.\\nIf temp is less than l and greater than r, update mini as mid + 1.\\nOtherwise, update maxi as mid - 1.\\nReturn ans.\\n**# Complexity\\n\\nTime complexity:\\nT.C=O(nlog(maxValue)). n times findCost function and log(maxValue) times binary search iteration.\\n\\nSpace complexity:\\nS.C=O(1) No extra space.\\n**\\n\\n---------------------------------\\nPlease Upvote If Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3664278/c-binary-search-solution-easy-with-proper-algorithm/"
                    },
                    {
                        "username": "dakuripramod",
                        "content": "Can we use binary search after sorting nums, cost ?\\n"
                    },
                    {
                        "username": "najwer23",
                        "content": "there we go :<"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The hint already gives this, but note that between two values, the overall cost expresssion can be expressed as a sum of linear expressions, which means it either contains no critical values or is entirely a critical value (flat).\\n\\nThus the minimum can be found at a value.\\n"
                    }
                ]
            },
            {
                "id": 1937990,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1937962,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1937935,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1937913,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1937905,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1937862,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1937845,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1937821,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1937816,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            },
            {
                "id": 1792069,
                "content": [
                    {
                        "username": "skyday123",
                        "content": "How about finding the centroid?"
                    },
                    {
                        "username": "zzjharry",
                        "content": "Is today really Wednesday? A HARD week...\\uD83D\\uDE2D"
                    },
                    {
                        "username": "steven520142",
                        "content": "I would say that the key point is to sort the array and use prefix sum."
                    },
                    {
                        "username": "psionl0",
                        "content": "A well written editorial makes this a medium problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Mister_CK](/Mister_CK) Correction: any problem where you COPY the editorial solution should be considered easy. The editorial usually describes the problem better than the description. I see nothing wrong with getting hints from the editorial (not the answer). Otherwise, if you haven\\'t seen that class of problem before, it could take a looooong time to find the solution. I was able to come up with a brute force solution within minutes but had no idea how to optimize the solution."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You\\'re not supposed to read the editorial before you do the problem. Or at least that is not what the difficulty is based on. Also, any problem where you read the editorial should be easy afterwards. "
                    },
                    {
                        "username": "surYeah",
                        "content": "this is similar to  finding the optimal  slope  and y-intercept of a line in linear regression :)"
                    },
                    {
                        "username": "aaryak4554",
                        "content": "can you provide the question number or link?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Would a O(n^2) be accepted?"
                    },
                    {
                        "username": "psionl0",
                        "content": "In a problem tagged as \"hard\"?"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "[@brookeraschke](/brookeraschke) Thanks man"
                    },
                    {
                        "username": "brookeraschke",
                        "content": "No, I used that approach and got TLE"
                    },
                    {
                        "username": "Ved07",
                        "content": "RIP my June Streak"
                    },
                    {
                        "username": "Bomond",
                        "content": "It is necessary that the elements in array NUMS become equal.\nChange element to \"+1\" and \"-1\".\nWhen we change elements, we need to check the COST.\nFor example: NUMS=[1,2], COST=[10,1]\nnums[1]=2-1 Change price: 1. or  nums[0]=1+1 Change price: 10.\nAnswer: 1"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "easy medium hard"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "any prerequisite for this ??\\n"
                    },
                    {
                        "username": "djslim",
                        "content": "it somewhat similar to this classic problem: https://leetcode.com/problems/candy/description/"
                    }
                ]
            }
        ]
    }
]