[
    {
        "title": "Range Product Queries of Powers",
        "question_content": "Given a positive integer n, there exists a 0-indexed array called powers, composed of the minimum number of powers of 2 that sum to n. The array is sorted in non-decreasing order, and there is only one way to form the array.\nYou are also given a 0-indexed 2D integer array queries, where queries[i] = [lefti, righti]. Each queries[i] represents a query where you have to find the product of all powers[j] with lefti <= j <= righti.\nReturn an array answers, equal in length to queries, where answers[i] is the answer to the ith query. Since the answer to the ith query may be too large, each answers[i] should be returned modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: n = 15, queries = [[0,1],[2,2],[0,3]]\nOutput: [2,4,64]\nExplanation:\nFor n = 15, powers = [1,2,4,8]. It can be shown that powers cannot be a smaller size.\nAnswer to 1st query: powers[0] * powers[1] = 1 * 2 = 2.\nAnswer to 2nd query: powers[2] = 4.\nAnswer to 3rd query: powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64.\nEach answer modulo 109 + 7 yields the same answer, so [2,4,64] is returned.\n\nExample 2:\n\nInput: n = 2, queries = [[0,0]]\nOutput: [2]\nExplanation:\nFor n = 2, powers = [2].\nThe answer to the only query is powers[0] = 2. The answer modulo 109 + 7 is the same, so [2] is returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 109\n\t1 <= queries.length <= 105\n\t0 <= starti <= endi < powers.length",
        "solutions": [
            {
                "id": 2706327,
                "title": "c-very-simple-easy-to-understand-solution",
                "content": "<b>Up Vote if you like the solution</b>\\n\\n# Approach\\nProblem statement suggwst that the power array is the array of power of 2\\'s whose sum is value n. This is same as when u represent a number in binary, and consider only power of 2 which values are 1 in binary . \\nFor example n = 5, binary = 101, \\nso n can be written as 1x2^2 + 0 x 2^1 + 1x 2^0.\\n=  2^2 + 2^0 = 4 + 1\\nSo the array here will be [1, 4]\\n\\nNow to check the ith bit if it is one or not we can simple check           (n & ( 1 << i))  != 0 \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int m = 1e9+7;\\n        vector<int> bint, ans;\\n        //create power array \\n        for(int i = 0; i < 32; ++i){\\n            if((n & (1<<i)) != 0) bint.push_back(1<<i);\\n        }\\n        for(auto q: queries){\\n            int i = q[0];\\n            long p = bint[i++];\\n            while(i <= q[1]){\\n                p = (p * bint[i++])%m;\\n            }\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int m = 1e9+7;\\n        vector<int> bint, ans;\\n        //create power array \\n        for(int i = 0; i < 32; ++i){\\n            if((n & (1<<i)) != 0) bint.push_back(1<<i);\\n        }\\n        for(auto q: queries){\\n            int i = q[0];\\n            long p = bint[i++];\\n            while(i <= q[1]){\\n                p = (p * bint[i++])%m;\\n            }\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706412,
                "title": "straight-forward-super-easy",
                "content": "*  convert n into binary string to get all powers of 2 , you can use other ways as well\\n*  then do what ques says \\n\\n```\\n    public int[] productQueries(int n, int[][] qu) {\\n        String str = Integer.toBinaryString(n); // convert n into binary string to get  minimum number of powers of  2\\n        ArrayList<Long> list = new ArrayList<>();\\n        long pow = 1;\\n        for (int i = str.length() - 1; i >= 0; i--) { // now loop on binary string\\n            if (str.charAt(i) == \\'1\\') list.add(pow); //if i\\'th bit is set add its power to our list\\n            pow = pow * 2;\\n        }\\n        long mod = (long) 1e9 + 7;\\n\\n        int ans[] = new int[qu.length];\\n\\n        for (int i = 0; i < qu.length; i++) {\\n            long mul = 1;\\n            for (int j = qu[i][0]; j <= qu[i][1]; j++) { //compute answer for each query\\n                mul = (mul * list.get(j)) % mod;\\n            }\\n\\n            ans[i] = (int) mul;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] productQueries(int n, int[][] qu) {\\n        String str = Integer.toBinaryString(n); // convert n into binary string to get  minimum number of powers of  2\\n        ArrayList<Long> list = new ArrayList<>();\\n        long pow = 1;\\n        for (int i = str.length() - 1; i >= 0; i--) { // now loop on binary string\\n            if (str.charAt(i) == \\'1\\') list.add(pow); //if i\\'th bit is set add its power to our list\\n            pow = pow * 2;\\n        }\\n        long mod = (long) 1e9 + 7;\\n\\n        int ans[] = new int[qu.length];\\n\\n        for (int i = 0; i < qu.length; i++) {\\n            long mul = 1;\\n            for (int j = qu[i][0]; j <= qu[i][1]; j++) { //compute answer for each query\\n                mul = (mul * list.get(j)) % mod;\\n            }\\n\\n            ans[i] = (int) mul;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706355,
                "title": "python-elegant-short-prefix-sum-binary-power",
                "content": "```\\nfrom itertools import accumulate\\nfrom typing import List, Generator\\n\\n\\nclass Solution:\\n    \"\"\"\\n    Time:   O(log(n) + m)\\n    Memory: O(log(n))\\n\\n    where m - length of queries\\n    \"\"\"\\n\\n    MAX_POWER = 32\\n    MOD = 10 ** 9 + 7\\n\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        cum_powers = list(accumulate(self._to_powers(n), initial=1))\\n        return [pow(2, cum_powers[r + 1] - cum_powers[l], self.MOD) for l, r in queries]\\n\\n    @classmethod\\n    def _to_powers(cls, num: int) -> Generator:\\n        return (p for p in range(cls.MAX_POWER) if num & (1 << p) != 0)\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import accumulate\\nfrom typing import List, Generator\\n\\n\\nclass Solution:\\n    \"\"\"\\n    Time:   O(log(n) + m)\\n    Memory: O(log(n))\\n\\n    where m - length of queries\\n    \"\"\"\\n\\n    MAX_POWER = 32\\n    MOD = 10 ** 9 + 7\\n\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        cum_powers = list(accumulate(self._to_powers(n), initial=1))\\n        return [pow(2, cum_powers[r + 1] - cum_powers[l], self.MOD) for l, r in queries]\\n\\n    @classmethod\\n    def _to_powers(cls, num: int) -> Generator:\\n        return (p for p in range(cls.MAX_POWER) if num & (1 << p) != 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706391,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int mod=1000000007;\\n        //generating the array based on the given n value  n%2 and n/2 evry time genrating an array of 0 and 1 indcating whether to consdier the index or not and generate the powers array according to the array generated indexes\\n        List<Integer> arr=new ArrayList<Integer>();\\n        List<Integer> powers=new ArrayList<Integer>();\\n        while(n>0){  \\n            arr.add((int)n%2);\\n            n/=2;\\n        }\\n         //System.out.print(arr);\\n        for(int i=0;i<arr.size();i++){\\n            if(arr.get(i)==1){  //considering only the arrays of value equals 1 indicating the maximum powers sum to n\\n                int t=(int)Math.pow(2,i);\\n                powers.add(t);\\n            }\\n        }\\n        int result[]=new int[queries.length];\\n        int j=0;\\n        for(int []a:queries){\\n            long res=1;\\n            for(int i=a[0];i<=a[1];i++){\\n                res=(res*powers.get(i)%mod);\\n            }\\n            result[j++]=(int)res%mod;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int mod=1000000007;\\n        //generating the array based on the given n value  n%2 and n/2 evry time genrating an array of 0 and 1 indcating whether to consdier the index or not and generate the powers array according to the array generated indexes\\n        List<Integer> arr=new ArrayList<Integer>();\\n        List<Integer> powers=new ArrayList<Integer>();\\n        while(n>0){  \\n            arr.add((int)n%2);\\n            n/=2;\\n        }\\n         //System.out.print(arr);\\n        for(int i=0;i<arr.size();i++){\\n            if(arr.get(i)==1){  //considering only the arrays of value equals 1 indicating the maximum powers sum to n\\n                int t=(int)Math.pow(2,i);\\n                powers.add(t);\\n            }\\n        }\\n        int result[]=new int[queries.length];\\n        int j=0;\\n        for(int []a:queries){\\n            long res=1;\\n            for(int i=a[0];i<=a[1];i++){\\n                res=(res*powers.get(i)%mod);\\n            }\\n            result[j++]=(int)res%mod;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706690,
                "title": "python-prefix-product",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = (10**9)+7\\n        binary = bin(n)[2:]\\n        powers = []\\n        result = []\\n        for index, val in enumerate(binary[::-1]):\\n            if val == \"1\":\\n                powers.append(2**index)\\n                \\n        for index in range(1, len(powers)):\\n            powers[index] = powers[index] * powers[index - 1]    \\n        \\n        for l,r in queries:\\n            if l == 0:\\n                result.append(powers[r]%MOD)\\n            else:\\n                result.append((powers[r]//powers[l-1])%MOD)\\n                \\n        return result\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = (10**9)+7\\n        binary = bin(n)[2:]\\n        powers = []\\n        result = []\\n        for index, val in enumerate(binary[::-1]):\\n            if val == \"1\":\\n                powers.append(2**index)\\n                \\n        for index in range(1, len(powers)):\\n            powers[index] = powers[index] * powers[index - 1]    \\n        \\n        for l,r in queries:\\n            if l == 0:\\n                result.append(powers[r]%MOD)\\n            else:\\n                result.append((powers[r]//powers[l-1])%MOD)\\n                \\n        return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706508,
                "title": "set-bits-c",
                "content": "**GENERATING  THE POWER ARRAY**\\nThe power array can be generated by inserting the power of two at the set bit of the number N.\\nAs that will sum up to become the value of N.\\nex : 11 -> 1011 \\nThe power array : 1(2^0) , 2(2^1) , 8(2^3).\\n\\n**CALCULATING**\\nOnce the power array is generated we can simply traverse on the queries list and calculate the answer in a brute force method.\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n       \\n        vector<int> pow;\\n        long long mod = 1e9+7;\\n        \\n        //if bit is set insert in the power array\\n        for(int i =0;i<32;i++)\\n        {\\n            if(n&(1<<i))\\n                pow.push_back(1<<i);\\n        }\\n        vector<int> ans;\\n        \\n        //solving for the query\\n        for(int i =0;i<q.size();i++)\\n        {\\n            long long temp=1;\\n            for(int j =q[i][0];j<=q[i][1];j++)\\n            {\\n                temp=((temp%mod)*pow[j])%mod;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**The mod part needs to be taken in consideration because it results in weird answer if not done properly. apply mod everytime you add or remove a element**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n       \\n        vector<int> pow;\\n        long long mod = 1e9+7;\\n        \\n        //if bit is set insert in the power array\\n        for(int i =0;i<32;i++)\\n        {\\n            if(n&(1<<i))\\n                pow.push_back(1<<i);\\n        }\\n        vector<int> ans;\\n        \\n        //solving for the query\\n        for(int i =0;i<q.size();i++)\\n        {\\n            long long temp=1;\\n            for(int j =q[i][0];j<=q[i][1];j++)\\n            {\\n                temp=((temp%mod)*pow[j])%mod;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706379,
                "title": "o-m",
                "content": "The size of the `pws` array is small (< 30 for any `n`).\\n\\nWe can compute queries on the fly, with the complexity O(m log n) - where *m* is the number of queries.\\n\\nOr, we can pre-compute all products (third solutoin below), and the complexity will be O(m).\\n\\n#### Inverse Modulo\\nThe prefix sum approach works for multiplication. Since we store mods and not actual products, we need to do inverse modulo multiplication instead of division.\\n\\n**C++**\\n```cpp\\nint modPow(int x, unsigned int y, unsigned int m)\\n{\\n    if (y == 0)\\n        return 1;\\n    long p = modPow(x, y / 2, m) % m;\\n    p = (p * p) % m;\\n    return y % 2 ? (p * x) % m : p;\\n}    \\nvector<int> productQueries(int n, vector<vector<int>>& qs) {\\n    vector<int> pws{1}, res;\\n    int mod = 1000000007;\\n    for (int b = 0; b < 30; ++b)\\n        if (n & (1 << b))\\n            pws.push_back((1LL << b) * pws.back() % mod);\\n    transform(begin(qs), end(qs), back_inserter(res), [&](const auto &q){ \\n        return (long long)pws[q[1] + 1] * modPow(pws[q[0]], mod - 2, mod) % mod; \\n    });\\n    return res;\\n}\\n```\\n\\n#### Add Exponents\\nA product would be some power of 2. If we store the exponents instead of the actual numbers, we can add exponents and use the prefix sum approach.\\n\\nNote that we need to use a modulo pow to compute a large exponent for the result.\\n\\n**C++**\\n```cpp\\nint modPow(int x, unsigned int y, unsigned int m)\\n{\\n    if (y == 0)\\n        return 1;\\n    long p = modPow(x, y / 2, m) % m;\\n    p = (p * p) % m;\\n    return y % 2 ? (p * x) % m : p;\\n}    \\nvector<int> productQueries(int n, vector<vector<int>>& qs) {\\n    vector<int> pws{0}, res;\\n    for (int b = 0; b < 30; ++b)\\n        if (n & (1 << b))\\n            pws.push_back(b + pws.back());\\n    transform(begin(qs), end(qs), back_inserter(res), [&](const auto &q){ \\n        return modPow(2, pws[q[1] + 1] - pws[q[0]], 1000000007); \\n    });\\n    return res;\\n}\\n```\\n\\n#### Precompute Products\\n\\n**C++**\\n```cpp\\nvector<int> productQueries(int n, vector<vector<int>>& qs) {\\n    vector<int> pws, res;\\n    long long products[29][29] = {};\\n    for (int b = 0; b < 30; ++b)\\n        if (n & (1 << b)) \\n            pws.push_back(1 << b);\\n    for (int i = 0; i < pws.size(); ++i)\\n        for (int j = i; j < pws.size(); ++j)\\n            products[i][j] = (j > i ? products[i][j - 1] : 1) * pws[j] % 1000000007;\\n    transform(begin(qs), end(qs), back_inserter(res), [&](const auto &q){ return products[q[0]][q[1]]; });\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint modPow(int x, unsigned int y, unsigned int m)\\n{\\n    if (y == 0)\\n        return 1;\\n    long p = modPow(x, y / 2, m) % m;\\n    p = (p * p) % m;\\n    return y % 2 ? (p * x) % m : p;\\n}    \\nvector<int> productQueries(int n, vector<vector<int>>& qs) {\\n    vector<int> pws{1}, res;\\n    int mod = 1000000007;\\n    for (int b = 0; b < 30; ++b)\\n        if (n & (1 << b))\\n            pws.push_back((1LL << b) * pws.back() % mod);\\n    transform(begin(qs), end(qs), back_inserter(res), [&](const auto &q){ \\n        return (long long)pws[q[1] + 1] * modPow(pws[q[0]], mod - 2, mod) % mod; \\n    });\\n    return res;\\n}\\n```\n```cpp\\nint modPow(int x, unsigned int y, unsigned int m)\\n{\\n    if (y == 0)\\n        return 1;\\n    long p = modPow(x, y / 2, m) % m;\\n    p = (p * p) % m;\\n    return y % 2 ? (p * x) % m : p;\\n}    \\nvector<int> productQueries(int n, vector<vector<int>>& qs) {\\n    vector<int> pws{0}, res;\\n    for (int b = 0; b < 30; ++b)\\n        if (n & (1 << b))\\n            pws.push_back(b + pws.back());\\n    transform(begin(qs), end(qs), back_inserter(res), [&](const auto &q){ \\n        return modPow(2, pws[q[1] + 1] - pws[q[0]], 1000000007); \\n    });\\n    return res;\\n}\\n```\n```cpp\\nvector<int> productQueries(int n, vector<vector<int>>& qs) {\\n    vector<int> pws, res;\\n    long long products[29][29] = {};\\n    for (int b = 0; b < 30; ++b)\\n        if (n & (1 << b)) \\n            pws.push_back(1 << b);\\n    for (int i = 0; i < pws.size(); ++i)\\n        for (int j = i; j < pws.size(); ++j)\\n            products[i][j] = (j > i ? products[i][j - 1] : 1) * pws[j] % 1000000007;\\n    transform(begin(qs), end(qs), back_inserter(res), [&](const auto &q){ return products[q[0]][q[1]]; });\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706776,
                "title": "c-beats-100-memory-speed",
                "content": "\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans, p;\\n\\t\\t\\n        //if bit is set, we\\'ll store corresonding value in power array\\n        for (int i = 0; i < 32; i++)\\n            if (n & (1 << i))   p.push_back(1 << i);\\n        \\n        for (int i = 0; i < q.size(); i++)\\n        {\\n            long temp = 1;\\n            for (int j = q[i][0]; j <= q[i][1] ; j++)\\n                 temp = (temp * p[j]) % 1000000007; \\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans, p;\\n\\t\\t\\n        //if bit is set, we\\'ll store corresonding value in power array\\n        for (int i = 0; i < 32; i++)\\n            if (n & (1 << i))   p.push_back(1 << i);\\n        \\n        for (int i = 0; i < q.size(); i++)\\n        {\\n            long temp = 1;\\n            for (int j = q[i][0]; j <= q[i][1] ; j++)\\n                 temp = (temp * p[j]) % 1000000007; \\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2796984,
                "title": "fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:log(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        a=bin(n)[2:]\\n        # print(a)\\n        a=a[::-1]\\n        arr=[1]\\n        p=1\\n        for i in range(len(a)):\\n            if(a[i]==\"1\"):\\n                p*=2**i\\n                arr.append(p)\\n        ans=[]\\n        print(arr)\\n        for q in queries:\\n            p=arr[q[1]+1]//arr[q[0]]\\n            ans.append(p%(10**9+7))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        a=bin(n)[2:]\\n        # print(a)\\n        a=a[::-1]\\n        arr=[1]\\n        p=1\\n        for i in range(len(a)):\\n            if(a[i]==\"1\"):\\n                p*=2**i\\n                arr.append(p)\\n        ans=[]\\n        print(arr)\\n        for q in queries:\\n            p=arr[q[1]+1]//arr[q[0]]\\n            ans.append(p%(10**9+7))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711640,
                "title": "python-3-lines-explanation-and-example-t-m-100-100",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n                                                        # Example: n = 46, queries = [[0,1],[2,2],[0,3]] \\n\\n        s = bin(n)[:1:-1]                               # <-- bin(46) = \"0b101110\" => bin(46)[:1:-1] = \"011101\"\\n\\n                                \\n        powers = [i for i, ch in                        #              \"0 1 1 1 0 1\" \\n                    enumerate(s) if ch == \\'1\\']          # <-- powers = [  1,2,3,  5]\\n\\n        return [pow(2,sum(powers[a:b+1])                #       [ [0,  1],   [2,2]  ,   [0,          3]]\\n                    )%1000000007 for a,b in queries]    # <-- [2**(1 + 2), 2** 3   , 2**(1 + 2 + 3 + 5)] = [8, 8, 2048]\\n```\\n\\n[https://leetcode.com/submissions/detail/823993518/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n                                                        # Example: n = 46, queries = [[0,1],[2,2],[0,3]] \\n\\n        s = bin(n)[:1:-1]                               # <-- bin(46) = \"0b101110\" => bin(46)[:1:-1] = \"011101\"\\n\\n                                \\n        powers = [i for i, ch in                        #              \"0 1 1 1 0 1\" \\n                    enumerate(s) if ch == \\'1\\']          # <-- powers = [  1,2,3,  5]\\n\\n        return [pow(2,sum(powers[a:b+1])                #       [ [0,  1],   [2,2]  ,   [0,          3]]\\n                    )%1000000007 for a,b in queries]    # <-- [2**(1 + 2), 2** 3   , 2**(1 + 2 + 3 + 5)] = [8, 8, 2048]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706706,
                "title": "python-fastest-100-using-precompute-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/823100010/) employs bit manipulations and precompute of products. It demonstrated **1909 ms runtime (100.00%)** and used **52.3 MB memory (40.00%)**. Time complexity is linear in queries: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        powers_mul = [1]\\n        \\n        # [1] minimum number of powers implies that all of them are unique,\\n        #     thus, the powers are encoded by the corresponding bits in the\\n        #     binary decomposition of \\'n\\';\\n        #     here, we precompute all consecutive products\\n        for i in range(30): \\n            if n & 1<<i:                \\n                powers_mul.append((1<<i) * powers_mul[-1])\\n        \\n        answers = []\\n        \\n        # [2] once we precomputed all consecutive products, querying\\n        #     is trivial, i.e., just divide the marginal products \\n        for left, right in queries:\\n            answers.append((powers_mul[right+1] // powers_mul[left]) % 1_000_000_007)\\n            \\n        return answers\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        powers_mul = [1]\\n        \\n        # [1] minimum number of powers implies that all of them are unique,\\n        #     thus, the powers are encoded by the corresponding bits in the\\n        #     binary decomposition of \\'n\\';\\n        #     here, we precompute all consecutive products\\n        for i in range(30): \\n            if n & 1<<i:                \\n                powers_mul.append((1<<i) * powers_mul[-1])\\n        \\n        answers = []\\n        \\n        # [2] once we precomputed all consecutive products, querying\\n        #     is trivial, i.e., just divide the marginal products \\n        for left, right in queries:\\n            answers.append((powers_mul[right+1] // powers_mul[left]) % 1_000_000_007)\\n            \\n        return answers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707339,
                "title": "c-bit-masking-and-brute-force-clean-code",
                "content": "### Approach 1: bit masking and brute force\\n\\nFirst we compute ```powers``` by bitmasking with ```n``` and then we just loop for each query.\\n\\n```cpp\\n    static constexpr long MOD = 1\\'000\\'000\\'007;\\n\\n    static vector<int> productQueries(int n, const vector<vector<int>>& queries) {\\n        vector<int> powers;\\n        powers.reserve(32);\\n        for (int i = 0; i < 32; ++i) {\\n            const int mask = 1 << i;\\n            if (n & mask) powers.push_back(mask);\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(size(queries));\\n        for (const vector<int>& query : queries) {\\n            const int left = query[0];\\n            const int right = query[1];\\n            // assert(0 <= left && left <= right);\\n            // assert(0 <= right && right < size(powers));\\n            long prod = 1;\\n            for (int i = left; i <= right; ++i) {\\n                prod = prod * powers[i] % MOD;\\n            }\\n            ans.push_back(prod);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nPossible optimizations that I can think of, let me know if you have more ideas:\\n  * using a segmen tree, maybe not even worth it\\n  * if we are seeing a lot of queries we could pre compute all possible combinations of ```left``` and ```right```.\\n\\n**Complexity Analysis**\\nLet $$m$$ be the size of ```queries``` then\\n  * Time complexity: $$O(m)$$, because we take only up to 32 steps per query. For small $$m$$\\'s the runtime will be dominated by the difference between ```left``` and ```right```.\\n  * Space complexity: $$O(m)$$ for the output.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```powers```\n```n```\n```cpp\\n    static constexpr long MOD = 1\\'000\\'000\\'007;\\n\\n    static vector<int> productQueries(int n, const vector<vector<int>>& queries) {\\n        vector<int> powers;\\n        powers.reserve(32);\\n        for (int i = 0; i < 32; ++i) {\\n            const int mask = 1 << i;\\n            if (n & mask) powers.push_back(mask);\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(size(queries));\\n        for (const vector<int>& query : queries) {\\n            const int left = query[0];\\n            const int right = query[1];\\n            // assert(0 <= left && left <= right);\\n            // assert(0 <= right && right < size(powers));\\n            long prod = 1;\\n            for (int i = left; i <= right; ++i) {\\n                prod = prod * powers[i] % MOD;\\n            }\\n            ans.push_back(prod);\\n        }\\n        \\n        return ans;\\n    }\\n```\n```left```\n```right```\n```queries```\n```left```\n```right```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550518,
                "title": "c-simple-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int modinv(int x){\\n        int y = 1e9+5,ans = 1,mod = 1e9+7;\\n        while(y){\\n            if(y&1){\\n                ans = (ans*1LL*x)%mod;\\n            }\\n            x = (x*1LL*x)%mod;\\n            y >>= 1;\\n        }\\n        return ans;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v,ans;\\n        int i,mod = 1e9+7;\\n        for(i = 0; i <= 31; i++){\\n            if(n&(1L<<i))v.push_back(1L<<i);\\n        }\\n        for(i = 1; i < v.size(); i++){\\n            v[i] = (v[i]*1LL*v[i-1])%mod;\\n        }\\n        for(auto &i: queries){\\n            if(i[0]==0){\\n                ans.push_back(v[i[1]]);\\n            }else{\\n                ans.push_back((v[i[1]]*1LL*modinv(v[i[0]-1]))%mod);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int modinv(int x){\\n        int y = 1e9+5,ans = 1,mod = 1e9+7;\\n        while(y){\\n            if(y&1){\\n                ans = (ans*1LL*x)%mod;\\n            }\\n            x = (x*1LL*x)%mod;\\n            y >>= 1;\\n        }\\n        return ans;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v,ans;\\n        int i,mod = 1e9+7;\\n        for(i = 0; i <= 31; i++){\\n            if(n&(1L<<i))v.push_back(1L<<i);\\n        }\\n        for(i = 1; i < v.size(); i++){\\n            v[i] = (v[i]*1LL*v[i-1])%mod;\\n        }\\n        for(auto &i: queries){\\n            if(i[0]==0){\\n                ans.push_back(v[i[1]]);\\n            }else{\\n                ans.push_back((v[i[1]]*1LL*modinv(v[i[0]-1]))%mod);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724870,
                "title": "c-easily-readable-code",
                "content": "```\\n vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>v,pows,ans;\\n        \\n        int m=1e9+7;\\n\\t\\t// taking all the bits and then we can calculate powers of 2 according to the set bits\\n\\t\\t\\n        while(n>0){\\n            v.push_back(n%2);\\n            n /= 2;\\n        }\\n        // making power array\\n\\t\\t\\n        for(int i=0;i<v.size();i++){\\n            \\n            if(v[i] == 1){\\n                pows.push_back(pow(2,i));\\n            }\\n        }\\n        \\n        for(auto i: queries){\\n            \\n            long prod=1;\\n            \\n            for(int j=i[0];j<=i[1];j++){\\n                prod = (prod*pows[j])%m; \\n            }\\n            \\n            ans.push_back(prod);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>v,pows,ans;\\n        \\n        int m=1e9+7;\\n\\t\\t// taking all the bits and then we can calculate powers of 2 according to the set bits\\n\\t\\t\\n        while(n>0){\\n            v.push_back(n%2);\\n            n /= 2;\\n        }\\n        // making power array\\n\\t\\t\\n        for(int i=0;i<v.size();i++){\\n            \\n            if(v[i] == 1){\\n                pows.push_back(pow(2,i));\\n            }\\n        }\\n        \\n        for(auto i: queries){\\n            \\n            long prod=1;\\n            \\n            for(int j=i[0];j<=i[1];j++){\\n                prod = (prod*pows[j])%m; \\n            }\\n            \\n            ans.push_back(prod);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716498,
                "title": "java-solution-using-math-log",
                "content": "* Iteratively figure out the highest power of 2 using Math.log(x) base 2 (computed as Math.log(x)/Math.log(2))\\n* Use a brute force to compute query product.\\n\\n```\\nclass Solution {\\n    private final int mod = (int) Math.pow(10,9) + 7;\\n\\n    public int[] productQueries(int n, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        List<Integer> powers = new ArrayList<>();\\n        int x = n;\\n        while (x>0) {\\n            int highestPower = (int) (Math.log(x)/Math.log(2));\\n            int pow = (int) Math.pow(2,highestPower);\\n            x = x - pow;\\n            powers.add(0,pow);\\n        }\\n        for (int j=0;j<queries.length;j++) {\\n            int start = queries[j][0];\\n            int end = queries[j][1];\\n            long r = 1;\\n            for (int i=start;i<=end;i++) {\\n                r = (r*powers.get(i))%mod;\\n            }\\n            result[j]=(int) (r%mod);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private final int mod = (int) Math.pow(10,9) + 7;\\n\\n    public int[] productQueries(int n, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        List<Integer> powers = new ArrayList<>();\\n        int x = n;\\n        while (x>0) {\\n            int highestPower = (int) (Math.log(x)/Math.log(2));\\n            int pow = (int) Math.pow(2,highestPower);\\n            x = x - pow;\\n            powers.add(0,pow);\\n        }\\n        for (int j=0;j<queries.length;j++) {\\n            int start = queries[j][0];\\n            int end = queries[j][1];\\n            long r = 1;\\n            for (int i=start;i<=end;i++) {\\n                r = (r*powers.get(i))%mod;\\n            }\\n            result[j]=(int) (r%mod);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706996,
                "title": "concise-rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn product_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut data = vec![];\\n\\n        for i in 0..32 {\\n            if n & (1 << i as i32) == 0 { continue }\\n            data.push(1 << i as i32);\\n        }\\n\\n        let mut ret = vec![];\\n        for q in queries {\\n            let mut temp = 1i64;\\n            for i in q[0] as usize..=q[1] as usize {\\n                temp = (temp * data[i] as i64) % 1_000_000_007;\\n            }\\n            ret.push(temp as i32);\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn product_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut data = vec![];\\n\\n        for i in 0..32 {\\n            if n & (1 << i as i32) == 0 { continue }\\n            data.push(1 << i as i32);\\n        }\\n\\n        let mut ret = vec![];\\n        for q in queries {\\n            let mut temp = 1i64;\\n            for i in q[0] as usize..=q[1] as usize {\\n                temp = (temp * data[i] as i64) % 1_000_000_007;\\n            }\\n            ret.push(temp as i32);\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706420,
                "title": "c-easy-to-understand-o-n",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mod=1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        vector<long long int> p;\\n        int n1=n;\\n        while(n1>0)\\n        {\\n            long long int x=log2(n1);\\n            p.push_back((pow(2,x)));\\n            n1-=pow(2,x);\\n        }\\n        sort(p.begin(),p.end());\\n       \\n        for(int i=0;i<q.size();i++)\\n        {\\n            long long pro=1;\\n            for(int j=q[i][0];j<=q[i][1];j++)\\n            {\\n                pro=(pro%mod*p[j]%mod)%mod;\\n            }\\n            ans.push_back(pro%mod);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mod=1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        vector<long long int> p;\\n        int n1=n;\\n        while(n1>0)\\n        {\\n            long long int x=log2(n1);\\n            p.push_back((pow(2,x)));\\n            n1-=pow(2,x);\\n        }\\n        sort(p.begin(),p.end());\\n       \\n        for(int i=0;i<q.size();i++)\\n        {\\n            long long pro=1;\\n            for(int j=q[i][0];j<=q[i][1];j++)\\n            {\\n                pro=(pro%mod*p[j]%mod)%mod;\\n            }\\n            ans.push_back(pro%mod);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706378,
                "title": "c-segment-tree",
                "content": "**Standard Segment Tree Pattern**\\nWe will create the segment tree of power vector.\\nIt will store the product of elements in range.\\n\\nThough the size of array is small and we don\\'t need segment tree, but I just wanted to share the approach.\\n\\n```\\ntypedef long long ll;   const int mod = 1e9 + 7;\\n\\nclass Solution {\\nprivate:\\n    vector<int> arr;\\n    vector<ll> seg;\\n    int maxN;\\n    // Function to build segment tree, storing the product of elements in range\\n    void build(int i, int low, int high) {\\n        if(low == high) {\\n            seg[i] = arr[low];\\n            return;\\n        }\\n        int mid = (low + high) / 2;\\n        build(i * 2 + 1, low, mid);\\n        build(i * 2 + 2, mid + 1, high);\\n        seg[i] = (seg[i * 2 + 1] * seg[i * 2 + 2]) % mod;\\n    }\\n    ll find(int i, int low, int high, int l, int r) {\\n        if(low >= l && high <= r) {\\n            return seg[i];\\n        }\\n        if(high < l || low > r) {\\n            return 1;\\n        }\\n        int mid = (low + high) / 2;\\n        ll left = find(i * 2 + 1, low, mid, l, r) % mod;\\n        ll right = find(i * 2 + 2, mid + 1, high, l, r) % mod;\\n        return (left * right) % mod;\\n    }\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        // Creating power array\\n        for(int i = 0; i < 31; i++) {\\n            int mask = 1 << i;\\n            if(n & mask) {\\n                arr.push_back(mask);\\n            }\\n        }\\n        // Creating segment tree\\n        maxN = arr.size();\\n        seg = vector<ll> (maxN * 4 + 10, 1);\\n        build(0, 0, maxN - 1);\\n        vector<int> ans;\\n        // Querying over segment tree to create the answer vector \\n        for(auto it : queries) {\\n            ll f = find(0, 0, maxN - 1, it[0], it[1]);\\n            ans.push_back(f % mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Segment Tree"
                ],
                "code": "```\\ntypedef long long ll;   const int mod = 1e9 + 7;\\n\\nclass Solution {\\nprivate:\\n    vector<int> arr;\\n    vector<ll> seg;\\n    int maxN;\\n    // Function to build segment tree, storing the product of elements in range\\n    void build(int i, int low, int high) {\\n        if(low == high) {\\n            seg[i] = arr[low];\\n            return;\\n        }\\n        int mid = (low + high) / 2;\\n        build(i * 2 + 1, low, mid);\\n        build(i * 2 + 2, mid + 1, high);\\n        seg[i] = (seg[i * 2 + 1] * seg[i * 2 + 2]) % mod;\\n    }\\n    ll find(int i, int low, int high, int l, int r) {\\n        if(low >= l && high <= r) {\\n            return seg[i];\\n        }\\n        if(high < l || low > r) {\\n            return 1;\\n        }\\n        int mid = (low + high) / 2;\\n        ll left = find(i * 2 + 1, low, mid, l, r) % mod;\\n        ll right = find(i * 2 + 2, mid + 1, high, l, r) % mod;\\n        return (left * right) % mod;\\n    }\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        // Creating power array\\n        for(int i = 0; i < 31; i++) {\\n            int mask = 1 << i;\\n            if(n & mask) {\\n                arr.push_back(mask);\\n            }\\n        }\\n        // Creating segment tree\\n        maxN = arr.size();\\n        seg = vector<ll> (maxN * 4 + 10, 1);\\n        build(0, 0, maxN - 1);\\n        vector<int> ans;\\n        // Querying over segment tree to create the answer vector \\n        for(auto it : queries) {\\n            ll f = find(0, 0, maxN - 1, it[0], it[1]);\\n            ans.push_back(f % mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706335,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<long long> powers;\\n    \\n        for (long long copy(n), pow(1); copy;  copy >>= 1, pow <<= 1) {\\n            if (copy & 1)    powers.push_back(pow);\\n        }\\n\\n        vector<int> res;\\n        for (auto& q : queries) {\\n            \\n            int val(1);\\n\\t\\t\\t// the size of powers will be small so we can calculate it by brute force.\\n            for (int i=q[0]; i<=q[1]; i++) {\\n                val = (val*powers[i]) % mod;\\n            }\\n            \\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9+7;\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<long long> powers;\\n    \\n        for (long long copy(n), pow(1); copy;  copy >>= 1, pow <<= 1) {\\n            if (copy & 1)    powers.push_back(pow);\\n        }\\n\\n        vector<int> res;\\n        for (auto& q : queries) {\\n            \\n            int val(1);\\n\\t\\t\\t// the size of powers will be small so we can calculate it by brute force.\\n            for (int i=q[0]; i<=q[1]; i++) {\\n                val = (val*powers[i]) % mod;\\n            }\\n            \\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303794,
                "title": "easy-bit-manipulation-for-beginners-with-comments",
                "content": "\\n\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        int size = q.size();\\n        vector<int> ans(size,0);\\n\\n        // make a power vector\\n        // for example n = 11101 then power vector must be {1,4,8,16} \\n        // that means if ith bit in n is set then that ith bit must present in power array in form of 2^i\\n        vector<int> powerr;\\n        for(int i =0; i < 32; i++){\\n            if(n & 1<<i) powerr.push_back(1<<i);\\n        } \\n        \\n        // can apply brute force now \\n\\n        for(int k = 0; k < q.size(); k++){\\n            long long prod = 1;\\n            for(int i = q[k][0] ; i <= q[k][1]; i++){\\n                prod = ((prod%mod)*powerr[i])%mod;\\n            }\\n            ans[k] = prod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// tip\\n// 2^i x 2^j = 2^(i+j)\\n// result product will be 1<<(i-1+j);\\n```\\n![image.png](https://assets.leetcode.com/users/images/44ebf2d7-8246-4ed4-b136-ed4dfb6813e6_1678967256.4179664.png)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        int size = q.size();\\n        vector<int> ans(size,0);\\n\\n        // make a power vector\\n        // for example n = 11101 then power vector must be {1,4,8,16} \\n        // that means if ith bit in n is set then that ith bit must present in power array in form of 2^i\\n        vector<int> powerr;\\n        for(int i =0; i < 32; i++){\\n            if(n & 1<<i) powerr.push_back(1<<i);\\n        } \\n        \\n        // can apply brute force now \\n\\n        for(int k = 0; k < q.size(); k++){\\n            long long prod = 1;\\n            for(int i = q[k][0] ; i <= q[k][1]; i++){\\n                prod = ((prod%mod)*powerr[i])%mod;\\n            }\\n            ans[k] = prod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// tip\\n// 2^i x 2^j = 2^(i+j)\\n// result product will be 1<<(i-1+j);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740795,
                "title": "simple-java-solution",
                "content": "```\\n//  if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public int mod=(int)1e9+7;\\n    public int[] productQueries(int n, int[][] queries) \\n    {\\n        List<Integer> ref=new ArrayList();\\n        int cnt=0;\\n        while(n>0)\\n        {\\n            int top=n%2;\\n            n=n/2;\\n            if(top==1) ref.add((int)Math.pow(2,cnt));\\n            cnt++;\\n        }\\n        int[] result=new int[queries.length];\\n        int idx=0;\\n        for(int[] i : queries)\\n        {\\n            int start=i[0];\\n            int end=i[1];\\n            long curr=1;\\n            for(int k=start;k<=end;k++) curr=(curr*ref.get(k))%mod;\\n            result[idx++]=(int)curr;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int mod=(int)1e9+7;\\n    public int[] productQueries(int n, int[][] queries) \\n    {\\n        List<Integer> ref=new ArrayList();\\n        int cnt=0;\\n        while(n>0)\\n        {\\n            int top=n%2;\\n            n=n/2;\\n            if(top==1) ref.add((int)Math.pow(2,cnt));\\n            cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2724547,
                "title": "python3-solution-prefix-sum-2-line-solution",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n, Q):\\n        A = list(accumulate([i for i in range(31) if n & (1 << i)])) + [0]\\n        return [pow(2, A[r] - A[l - 1], 10 ** 9 + 7) for l, r in Q]\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n, Q):\\n        A = list(accumulate([i for i in range(31) if n & (1 << i)])) + [0]\\n        return [pow(2, A[r] - A[l - 1], 10 ** 9 + 7) for l, r in Q]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715008,
                "title": "bit-manipulation",
                "content": "# Intuition\\nAs we are taking positive numbers so we can extract the `powers of 2` by extracting which all bits are set `1`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing bit manipulation we compute the all the set bits and push it in an array.\\nFor each querry we simply compute it as array size is only `32` max.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(q)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> p;\\n        \\n        for(int i = 0; i < 32; i++)\\n            if(n & (1 << i))\\n                p.push_back(1 << i);\\n        \\n        int q = queries.size();\\n        vector<int> res(q, 1);\\n        \\n        for(int i = 0; i < q; i++)\\n            for(int s = queries[i][0]; s <= queries[i][1]; s++)\\n                res[i] = ((long)res[i] * p[s]) % mod;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> p;\\n        \\n        for(int i = 0; i < 32; i++)\\n            if(n & (1 << i))\\n                p.push_back(1 << i);\\n        \\n        int q = queries.size();\\n        vector<int> res(q, 1);\\n        \\n        for(int i = 0; i < q; i++)\\n            for(int s = queries[i][0]; s <= queries[i][1]; s++)\\n                res[i] = ((long)res[i] * p[s]) % mod;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708870,
                "title": "c-two-solutions-easy-solution",
                "content": "**Approach 1: (Naive) \\u2705**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n         int mod = (int)1e9 + 7;\\n         vector<long long> temp;\\n         vector<long long> PowerSum;\\n        while(n > 0) \\n        {\\n            temp.push_back((int)n % 2);\\n            n /= 2;\\n        }\\n\\n        for(int i = 0; i < temp.size(); i++) \\n        {\\n            if(temp[i] == 1) \\n            {\\n                int t = (int)pow(2, i);\\n                PowerSum.push_back(t);\\n                \\n            }\\n        }\\n        int m = queries.size();\\n        \\n        vector<int> ans(m);\\n        \\n        int ind = 0;\\n\\n        for(auto row : queries) {\\n            \\n            long sum = 1;\\n            for(int i = row[0]; i <= row[1]; i++) \\n            {\\n                sum = (long)(sum * PowerSum[i] % mod);\\n            }\\n            ans[ind++] = ((int)sum % mod);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n**Approach 2: (Bit ) \\u2705**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> PowerSum;\\n        int mod = 1e9 + 7;\\n        for(int i=0;i<31;i++){\\n            if((n & (1<<i)) > 0){\\n                int t = (1 << i);\\n                PowerSum.push_back(t);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            long long x  = 1;\\n            for(int j = left;j <= right;j++){\\n                x = (x* 1LL * PowerSum[j])%mod;\\n            }\\n            ans.push_back((int)x);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n         int mod = (int)1e9 + 7;\\n         vector<long long> temp;\\n         vector<long long> PowerSum;\\n        while(n > 0) \\n        {\\n            temp.push_back((int)n % 2);\\n            n /= 2;\\n        }\\n\\n        for(int i = 0; i < temp.size(); i++) \\n        {\\n            if(temp[i] == 1) \\n            {\\n                int t = (int)pow(2, i);\\n                PowerSum.push_back(t);\\n                \\n            }\\n        }\\n        int m = queries.size();\\n        \\n        vector<int> ans(m);\\n        \\n        int ind = 0;\\n\\n        for(auto row : queries) {\\n            \\n            long sum = 1;\\n            for(int i = row[0]; i <= row[1]; i++) \\n            {\\n                sum = (long)(sum * PowerSum[i] % mod);\\n            }\\n            ans[ind++] = ((int)sum % mod);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> PowerSum;\\n        int mod = 1e9 + 7;\\n        for(int i=0;i<31;i++){\\n            if((n & (1<<i)) > 0){\\n                int t = (1 << i);\\n                PowerSum.push_back(t);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            long long x  = 1;\\n            for(int j = left;j <= right;j++){\\n                x = (x* 1LL * PowerSum[j])%mod;\\n            }\\n            ans.push_back((int)x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708379,
                "title": "java-prefix-sum-solution-power-of-2",
                "content": "```\\nclass Solution {\\n    double m = 1e9+7;\\n    public int[] productQueries(int n, int[][] queries) {\\n\\n        LinkedList<Integer> x = new LinkedList<>();\\n        int c = 0;\\n        while(n>0){\\n           if((n&1) == 1)\\n           x.add(c); // Adding power of 2 in the list , not the actual value \\n           c++;\\n           n>>=1; \\n        }\\n        \\n        int sz = x.size();\\n        for(int i=1;i<sz;i++){\\n            x.set(i,x.get(i-1)+x.get(i));\\n        }\\n        x.addFirst(0);\\n\\n        int[] res = new int[queries.length];\\n        int i=0;\\n        for(int[] q: queries){\\n\\n            int s = x.get(q[1]+1)-x.get(q[0]);\\n            res[i]= (int)(Math.pow(2,s)%m);\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    double m = 1e9+7;\\n    public int[] productQueries(int n, int[][] queries) {\\n\\n        LinkedList<Integer> x = new LinkedList<>();\\n        int c = 0;\\n        while(n>0){\\n           if((n&1) == 1)\\n           x.add(c); // Adding power of 2 in the list , not the actual value \\n           c++;\\n           n>>=1; \\n        }\\n        \\n        int sz = x.size();\\n        for(int i=1;i<sz;i++){\\n            x.set(i,x.get(i-1)+x.get(i));\\n        }\\n        x.addFirst(0);\\n\\n        int[] res = new int[queries.length];\\n        int i=0;\\n        for(int[] q: queries){\\n\\n            int s = x.get(q[1]+1)-x.get(q[0]);\\n            res[i]= (int)(Math.pow(2,s)%m);\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707177,
                "title": "java-solution",
                "content": "```\\nclass Solution {    \\n    public int[] productQueries(int n, int[][] queries) {\\n        List<Integer> list = new ArrayList<>();\\n        int sum = n;\\n        int value = 0;\\n        while (sum > 0) {\\n            value = findPreviousPower(sum);\\n            sum = sum - value;\\n            list.add(value);\\n        }\\n        Collections.reverse(list);\\n        int[] result = new int[queries.length];\\n        int index = 0;\\n        for (int[] query : queries) {\\n            int start = query[0];\\n            int end = query[1];\\n            long queryResult = 1;\\n            for (int i = start; i <= end; i++) {\\n                queryResult = (queryResult * list.get(i) % (long) (Math.pow(10, 9) + 7));\\n            }\\n            result[index] =  (int) queryResult;\\n            index++;\\n        }\\n        return result;\\n    }\\n    public int findPreviousPower(int value) {\\n        while ((value & value - 1) != 0) {\\n            value = value & value - 1;\\n        }\\n        return value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {    \\n    public int[] productQueries(int n, int[][] queries) {\\n        List<Integer> list = new ArrayList<>();\\n        int sum = n;\\n        int value = 0;\\n        while (sum > 0) {\\n            value = findPreviousPower(sum);\\n            sum = sum - value;\\n            list.add(value);\\n        }\\n        Collections.reverse(list);\\n        int[] result = new int[queries.length];\\n        int index = 0;\\n        for (int[] query : queries) {\\n            int start = query[0];\\n            int end = query[1];\\n            long queryResult = 1;\\n            for (int i = start; i <= end; i++) {\\n                queryResult = (queryResult * list.get(i) % (long) (Math.pow(10, 9) + 7));\\n            }\\n            result[index] =  (int) queryResult;\\n            index++;\\n        }\\n        return result;\\n    }\\n    public int findPreviousPower(int value) {\\n        while ((value & value - 1) != 0) {\\n            value = value & value - 1;\\n        }\\n        return value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706926,
                "title": "java-one-of-the-easiest-java-solution-with-explanation",
                "content": "Explanation - The trick of this question was to understand how to create the Power array, there are couple of thing given in question for example, like its going to be unique, which basically points us to bit manuplation.\\n\\nlets take the exmple of n = 15, binary rep of 15 = 1111\\n\\ni.e - 1x2^3 + 1x2^2 + 1x2^1 + 1x2^0\\nwhich is [8,4,2,1]\\n\\nsimilary lets take another example - n = 5, binary rep of 5 = 101\\nie [4,1]\\nand Voila, question is done.\\n\\nanother question that can comes  to your mind is about contraints and why 2 nested loop is working, my take would be to relook at constraints and come back.\\n\\n```\\nstatic long mod = (long) 1e9 + 7;\\n    public static int[] productQueries(int n, int[][] queries) {\\n        String s = Integer.toBinaryString(n);\\n        ArrayList<Long> arr = new ArrayList<>();\\n        int cur = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s.charAt(i) != \\'0\\') {\\n                arr.add(((long) Math.pow(2, cur)) % mod);\\n            }\\n            cur++;\\n        }\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            long temp = 1;\\n            for (int j = queries[i][0]; j <= queries[i][1] ; j++) {\\n                temp=(arr.get(j)*temp) % mod;\\n            }\\n            result[i] = (int) (temp%mod);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nstatic long mod = (long) 1e9 + 7;\\n    public static int[] productQueries(int n, int[][] queries) {\\n        String s = Integer.toBinaryString(n);\\n        ArrayList<Long> arr = new ArrayList<>();\\n        int cur = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s.charAt(i) != \\'0\\') {\\n                arr.add(((long) Math.pow(2, cur)) % mod);\\n            }\\n            cur++;\\n        }\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            long temp = 1;\\n            for (int j = queries[i][0]; j <= queries[i][1] ; j++) {\\n                temp=(arr.get(j)*temp) % mod;\\n            }\\n            result[i] = (int) (temp%mod);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706791,
                "title": "product-prefix-o-1-query-product-segment-tree-o-logn-query",
                "content": "# Intuition\\nThe problem is composed of two main parts:\\n1. **Q1** determine which are the minimum powers of 2 which can be used to represents the given number N\\n2. **Q2** compose an array created in increasing order of those powers\\n3. **Q3** find product of values in the given query range relative to the previously found array(step 2.)\\n\\n#### Q1\\nQ1 basically requires the binary representation of the given number N. Each bit set to one represents a positional power of two in the required array. Both solutions to Q1 have same time complexity. \\nOne can do:\\n- **Fenwick tree Bit trick** to get the largest power of two of given number(solution used in the code). This allows to get the largest bit set to one, whose smaller bits are all set to 0. This amount is then subtracted from the original value, and the rest is used to repeat the trick until 0 is attained.\\n- **Simple solution**(n>>1 & 1) to see whether the least significant bit is set to one and then set n = n>>1 until n == 0, in order to extract all bits that are set to one. \\nIf n>>1 & 1 is 1, then the corresponding power of two is 2**(number of done shifts up to now) otherwise just increase the counter without storing the current power of two.\\n\\n#### Q2\\nThe array is naturally sorted in increasing order, as the first value that is found is the smallest bit set to 1 (e.g. the maximum smallest power of two that composes the given number).\\n\\n#### Q3\\nTo answer range queries, a **product prefix array** or a **segment tree data** structure can be used. The former is more space optimized with no downside for this problem.\\nThe **product prefix array** is defined with its elements $j$ as the product  $\\\\prod_{i=0}^j nums[i]$ of all elements in the powers of 2 array up to the j-th.\\n#### Product Prefix array\\nTo obtain the answer with a **product prefix array**  for a query $$[start, end]$$, one would simple get the value at a given $ans=prod\\\\_prefix[end]/prod\\\\_prefix[start-1]$, to obtain an equivalent prefix query to one of prefix sum arrays.\\n\\n#### Product Segment tree\\nI have adapted a general purpose segment tree to fit the use case of computing the product of all numbers in any of the queries(generally they are seen for sum, min, max queries but are easily extensible).\\nThe concept is the same of the prefix sum:\\nwe want to compute a quantity over a given range, without having to recompute it for ranges that include each other.\\n\\nEach leaf node is an element of the powers array.\\nThe non-leaf nodes represent the product of the numbers in a power of two range.\\nThe only trick to note here is that to compute queries, one has to move to the neighboring node which represents a sub-range that is within the range query, if the current node represents a range larger than that required by the query. \\nTo achieve this, the code of its **mul** function, in the provided data structure considers the case in which:\\n- the sub-range that is considered by any given node exceeds with its left boundary the query range lower limit, hence we move to the node to its right\\n-  the sub-range that is considered by any given node exceeds with its right boundary the upper limit of the given query range, hence we move to the node to its left. \\n\\n# Product prefix Code (Optimal solution)\\n###\\nN is the number of found powers\\n- Time complexity:\\nO(N) to find powers\\nO(1) to answer queries \\n\\n- Space complexity:\\nO(N)\\n```\\ndef productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = 10**9 + 7\\n        k = n\\n        powers = []\\n        while k >0:\\n            val = k & (-k)\\n            powers.append(val)\\n            k -= val\\n        prodprefix = [1 for _ in range(len(powers))]\\n        prodprefix[0] = powers[0]\\n        for i in range(1,len(powers)):\\n            prodprefix[i] *= prodprefix[i-1]*powers[i]\\n        ans = []\\n        for start, end in queries:\\n            res = prodprefix[end]\\n            if start-1 >= 0:\\n                divider = prodprefix[start-1] \\n                res //= divider\\n            ans.append(res%MOD)\\n        \\n        return ans\\n```\\n# Product Segment Tree Code\\nN is the number of found powers\\n- Time complexity:\\nO(N) to find powers\\nO(log(N)) to answer queries \\n\\n- Space complexity:\\nO(2*N)\\n```python\\nclass SegmentTree:\\n\\tdef __init__(self, array):\\n\\t\\tN = len(array)\\n\\t\\tk = 1\\n\\t\\t\\n\\t\\twhile k < N:\\n\\t\\t\\tk = k << 1\\n\\t\\t\\n\\t\\ttree = [0 for _ in range(2*k)]\\n\\t\\tfor i in range(N):\\n\\t\\t\\ttree[k+i] = array[i]\\n\\t\\tself.tree = tree\\n\\t\\tself.tree_size = 2*k\\n\\t\\twhile k > 1:\\n\\t\\t\\tj = k\\n\\n\\t\\t\\twhile j < 2*k:\\n\\t\\t\\t\\ttree[j//2] = tree[j] * tree[j+1]\\n\\t\\t\\t\\tj += 2\\n\\t\\t\\tk = k//2\\n\\n\\tdef mul(self, a, b):\\n\\t\\ts = 1\\n\\t\\ta += self.tree_size//2\\n\\t\\tb += self.tree_size//2\\n\\t\\twhile a <= b:\\n\\t\\t\\tif a%2 == 1:\\n\\t\\t\\t\\ts *= self.tree[a]\\n\\t\\t\\t\\ta += 1\\n\\t\\t\\tif b%2 == 0:\\n\\t\\t\\t\\ts *= self.tree[b]\\n\\t\\t\\t\\tb -= 1\\n\\n\\t\\t\\ta = a//2\\n\\t\\t\\tb = b//2\\n\\t\\treturn s\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = 10**9 + 7\\n        k = n\\n        powers = []\\n        while k >0:\\n            val = k & (-k)\\n            powers.append(val)\\n            k -= val\\n        segtree = SegmentTree(powers)\\n        ans = []\\n        for start, end in queries:\\n            res = segtree.mul(start, end)\\n            ans.append(res%MOD)\\n        \\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Segment Tree",
                    "Prefix Sum"
                ],
                "code": "```\\ndef productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = 10**9 + 7\\n        k = n\\n        powers = []\\n        while k >0:\\n            val = k & (-k)\\n            powers.append(val)\\n            k -= val\\n        prodprefix = [1 for _ in range(len(powers))]\\n        prodprefix[0] = powers[0]\\n        for i in range(1,len(powers)):\\n            prodprefix[i] *= prodprefix[i-1]*powers[i]\\n        ans = []\\n        for start, end in queries:\\n            res = prodprefix[end]\\n            if start-1 >= 0:\\n                divider = prodprefix[start-1] \\n                res //= divider\\n            ans.append(res%MOD)\\n        \\n        return ans\\n```\n```python\\nclass SegmentTree:\\n\\tdef __init__(self, array):\\n\\t\\tN = len(array)\\n\\t\\tk = 1\\n\\t\\t\\n\\t\\twhile k < N:\\n\\t\\t\\tk = k << 1\\n\\t\\t\\n\\t\\ttree = [0 for _ in range(2*k)]\\n\\t\\tfor i in range(N):\\n\\t\\t\\ttree[k+i] = array[i]\\n\\t\\tself.tree = tree\\n\\t\\tself.tree_size = 2*k\\n\\t\\twhile k > 1:\\n\\t\\t\\tj = k\\n\\n\\t\\t\\twhile j < 2*k:\\n\\t\\t\\t\\ttree[j//2] = tree[j] * tree[j+1]\\n\\t\\t\\t\\tj += 2\\n\\t\\t\\tk = k//2\\n\\n\\tdef mul(self, a, b):\\n\\t\\ts = 1\\n\\t\\ta += self.tree_size//2\\n\\t\\tb += self.tree_size//2\\n\\t\\twhile a <= b:\\n\\t\\t\\tif a%2 == 1:\\n\\t\\t\\t\\ts *= self.tree[a]\\n\\t\\t\\t\\ta += 1\\n\\t\\t\\tif b%2 == 0:\\n\\t\\t\\t\\ts *= self.tree[b]\\n\\t\\t\\t\\tb -= 1\\n\\n\\t\\t\\ta = a//2\\n\\t\\t\\tb = b//2\\n\\t\\treturn s\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = 10**9 + 7\\n        k = n\\n        powers = []\\n        while k >0:\\n            val = k & (-k)\\n            powers.append(val)\\n            k -= val\\n        segtree = SegmentTree(powers)\\n        ans = []\\n        for start, end in queries:\\n            res = segtree.mul(start, end)\\n            ans.append(res%MOD)\\n        \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706694,
                "title": "c-segemnt-tree-code-similar-questions",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    \\n      vector<long long>seg;\\n    int n;\\n\\n    void build(int ind , int low , int high , vector<int>& nums)\\n    {\\n        if(low == high)\\n        {\\n            seg[ind] = nums[low];\\n            return;\\n        }\\n        \\n        int mid = low + (high - low)/2;\\n        \\n        build(2*ind + 1 , low , mid,nums);\\n        build(2*ind + 2 , mid + 1 , high,nums);\\n        \\n        seg[ind] = (seg[2*ind + 1]%mod * seg[2*ind + 2]%mod)%mod;\\n    }\\n  \\n    long long rangeUtil(int qlow , int qhigh , int low , int high , int pos)\\n    {\\n        if(qlow <= low && qhigh >= high){\\n            return seg[pos];\\n        }\\n        \\n        if(qlow > high || qhigh < low)\\n        {return 1;}\\n        \\n        int mid = low + (high - low)/2;\\n        return (rangeUtil(qlow,qhigh,low,mid,2*pos+1)%mod * rangeUtil(qlow,qhigh,mid+1,high,2*pos+2)%mod)%mod;\\n    }\\n    \\n    \\n    int sumRange(int left, int right) {\\n        if(n==0)return 1;\\n        return rangeUtil(left,right,0,n-1,0);\\n    }\\n    \\n    vector<int> productQueries(int nu, vector<vector<int>>& queries) {\\n       vector<int> temp = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912};\\n        \\n        vector<int>nums;\\n        int t = nu;\\n        for(int i = temp.size() - 1 ; i >= 0 && nu != 0 ; i--)\\n        {\\n            if(nu >= temp[i])\\n            {\\n                nu -= temp[i];\\n                nums.push_back(temp[i]);\\n            }\\n        }\\n        \\n        reverse(nums.begin() , nums.end());\\n        \\n         if(nums.size() > 0)\\n        {\\n             n = nums.size();\\n            seg.resize(4*n,1);\\n            build(0,0,nums.size()-1,nums);\\n        }\\n        vector<int> res;\\n        for(auto it : queries)\\n        {\\n            res.push_back(sumRange(it[0] , it[1]));\\n        }\\n            \\n        return res;\\n    }\\n};\\n```\\n\\nSimilar question -\\nRange Sum Query mutable - https://leetcode.com/problems/range-sum-query-mutable/\\nRange Sum query immutable- https://leetcode.com/problems/range-sum-query-immutable/",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    \\n      vector<long long>seg;\\n    int n;\\n\\n    void build(int ind , int low , int high , vector<int>& nums)\\n    {\\n        if(low == high)\\n        {\\n            seg[ind] = nums[low];\\n            return;\\n        }\\n        \\n        int mid = low + (high - low)/2;\\n        \\n        build(2*ind + 1 , low , mid,nums);\\n        build(2*ind + 2 , mid + 1 , high,nums);\\n        \\n        seg[ind] = (seg[2*ind + 1]%mod * seg[2*ind + 2]%mod)%mod;\\n    }\\n  \\n    long long rangeUtil(int qlow , int qhigh , int low , int high , int pos)\\n    {\\n        if(qlow <= low && qhigh >= high){\\n            return seg[pos];\\n        }\\n        \\n        if(qlow > high || qhigh < low)\\n        {return 1;}\\n        \\n        int mid = low + (high - low)/2;\\n        return (rangeUtil(qlow,qhigh,low,mid,2*pos+1)%mod * rangeUtil(qlow,qhigh,mid+1,high,2*pos+2)%mod)%mod;\\n    }\\n    \\n    \\n    int sumRange(int left, int right) {\\n        if(n==0)return 1;\\n        return rangeUtil(left,right,0,n-1,0);\\n    }\\n    \\n    vector<int> productQueries(int nu, vector<vector<int>>& queries) {\\n       vector<int> temp = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912};\\n        \\n        vector<int>nums;\\n        int t = nu;\\n        for(int i = temp.size() - 1 ; i >= 0 && nu != 0 ; i--)\\n        {\\n            if(nu >= temp[i])\\n            {\\n                nu -= temp[i];\\n                nums.push_back(temp[i]);\\n            }\\n        }\\n        \\n        reverse(nums.begin() , nums.end());\\n        \\n         if(nums.size() > 0)\\n        {\\n             n = nums.size();\\n            seg.resize(4*n,1);\\n            build(0,0,nums.size()-1,nums);\\n        }\\n        vector<int> res;\\n        for(auto it : queries)\\n        {\\n            res.push_back(sumRange(it[0] , it[1]));\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706631,
                "title": "c-tc-n-log-n",
                "content": "# Intuition\\n*** will add soom ***\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n*** will add soon ***\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O (N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long m=1e9+7;\\n    long fn(int x){\\n        if(x<=0)return 1;\\n        if(x==1){\\n            return 2;\\n        }else if(x&1){\\n            return ((fn(x>>1)%m) * (fn((x>>1) + 1)%m))%m;\\n        }else{\\n            long t=fn(x>>1)%m;\\n            return (t*t)%m;\\n        }\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        int i=0;\\n        while(n>0){\\n            if(n&1)\\n            v.push_back( (i) + ((v.size()>0) ? v.back() : 0) );\\n            i++;\\n            n>>=1;\\n        }\\n        \\n        vector<int> ans(queries.size());\\n        i=0;\\n        for(auto &q:queries){\\n            int x = v[q[1]] - ((q[0]>0)?(v[q[0]-1]):0);\\n            ans[i++] = (int)fn(x);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long m=1e9+7;\\n    long fn(int x){\\n        if(x<=0)return 1;\\n        if(x==1){\\n            return 2;\\n        }else if(x&1){\\n            return ((fn(x>>1)%m) * (fn((x>>1) + 1)%m))%m;\\n        }else{\\n            long t=fn(x>>1)%m;\\n            return (t*t)%m;\\n        }\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        int i=0;\\n        while(n>0){\\n            if(n&1)\\n            v.push_back( (i) + ((v.size()>0) ? v.back() : 0) );\\n            i++;\\n            n>>=1;\\n        }\\n        \\n        vector<int> ans(queries.size());\\n        i=0;\\n        for(auto &q:queries){\\n            int x = v[q[1]] - ((q[0]>0)?(v[q[0]-1]):0);\\n            ans[i++] = (int)fn(x);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706545,
                "title": "c-easy-solution",
                "content": "```\\n\\n\\nstring DecimalToBinary(int num)\\n{\\n    string str;\\n      while(num){\\n      if(num & 1) // 1\\n        str+=\\'1\\';\\n      else // 0\\n        str+=\\'0\\';\\n      num>>=1; // Right Shift by 1 \\n    }   \\n      return str;\\n}\\n\\nclass Solution {\\npublic:\\n    #define m 1000000009\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        string binary=DecimalToBinary(n);\\n        vector<long long> power;\\n        if(binary[0]==\\'1\\') power.push_back(1);\\n        long long p=1;\\n        for(int i=1;i<binary.length();i++)\\n        {\\n            p= ((p%1000000007) * 2)%1000000007;\\n            if(binary[i]==\\'1\\')\\n                power.push_back(p);\\n        }\\n        long long pro=1;\\n        vector<long long> res;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            pro=1;\\n            int a=q[i][0],b=q[i][1];\\n            for(int j=a;j<=b;j++)\\n            {\\n                pro=( (pro%1000000007)* (power[j]%1000000007) %1000000007 );\\n            }\\n            res.push_back(pro);\\n        }\\n        vector<int> r(res.size());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            r[i]=res[i]%1000000007;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nstring DecimalToBinary(int num)\\n{\\n    string str;\\n      while(num){\\n      if(num & 1) // 1\\n        str+=\\'1\\';\\n      else // 0\\n        str+=\\'0\\';\\n      num>>=1; // Right Shift by 1 \\n    }   \\n      return str;\\n}\\n\\nclass Solution {\\npublic:\\n    #define m 1000000009\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        string binary=DecimalToBinary(n);\\n        vector<long long> power;\\n        if(binary[0]==\\'1\\') power.push_back(1);\\n        long long p=1;\\n        for(int i=1;i<binary.length();i++)\\n        {\\n            p= ((p%1000000007) * 2)%1000000007;\\n            if(binary[i]==\\'1\\')\\n                power.push_back(p);\\n        }\\n        long long pro=1;\\n        vector<long long> res;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            pro=1;\\n            int a=q[i][0],b=q[i][1];\\n            for(int j=a;j<=b;j++)\\n            {\\n                pro=( (pro%1000000007)* (power[j]%1000000007) %1000000007 );\\n            }\\n            res.push_back(pro);\\n        }\\n        vector<int> r(res.size());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            r[i]=res[i]%1000000007;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706432,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        List<Long> powers = new ArrayList<>();\\n        for(int i=0; i<32; i++) {\\n            if((n & 1) == 1) {\\n                powers.add((long)Math.pow(2, i));\\n            }\\n            n >>= 1;\\n        }\\n        \\n        int mod = 1_000_000_007;\\n        int[] res = new int[queries.length];\\n        for(int i=0; i<res.length; i++) {\\n            int[] q = queries[i];\\n            long ans = 1;\\n            for(int j=q[0]; j<=q[1]; j++) {\\n                ans = (ans * powers.get(j)) % mod;\\n            }\\n            res[i] = (int) ans;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        List<Long> powers = new ArrayList<>();\\n        for(int i=0; i<32; i++) {\\n            if((n & 1) == 1) {\\n                powers.add((long)Math.pow(2, i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3689280,
                "title": "2438-range-product-queries-of-powers",
                "content": "```\\nclass SGTree{\\n    vector<long long>seg;\\n    public:\\n    int mod = 1e9+7;\\n    SGTree(int n){\\n        seg.resize(4*n);\\n    }\\n    void build(int ind,int low,int high,vector<int>& arr){\\n        if(low==high){\\n            seg[ind]=arr[low];\\n            return;\\n        }\\n        int mid = (low+high)>>1;\\n        build(2*ind+1,low,mid,arr);\\n        build(2*ind+2,mid+1,high,arr);\\n        seg[ind] = (seg[2*ind+1]*seg[2*ind+2])%mod;\\n    }\\n    long long query(int ind,int low,int high,int l,int r){\\n        if(low>r || high<l)\\n            return 1;\\n        if(low>=l && high<=r)\\n            return seg[ind]%mod;\\n        \\n        int mid = (low+high)>>1;\\n        long long left = query(2*ind+1,low,mid,l,r)%mod;\\n        long long right = query(2*ind+2,mid+1,high,l,r)%mod;\\n        return (left*right)%mod;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int m=n,cnt=0;\\n        while(m>0){\\n            m>>=1;\\n            cnt++;\\n        }\\n        vector<int> arr;\\n        m=n;\\n        int i=cnt;\\n        while(m>0 && i>=0){\\n            if((1<<i)<=m){\\n                arr.push_back(1<<i);\\n                m-=(1<<i);\\n            }\\n            i--;\\n        }\\n        reverse(arr.begin(),arr.end());\\n        SGTree sg = SGTree(arr.size());\\n        sg.build(0,0,arr.size()-1,arr);\\n        vector<int>ans;\\n        for(auto it:queries){\\n            ans.push_back(sg.query(0,0,arr.size()-1,it[0],it[1])%mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass SGTree{\\n    vector<long long>seg;\\n    public:\\n    int mod = 1e9+7;\\n    SGTree(int n){\\n        seg.resize(4*n);\\n    }\\n    void build(int ind,int low,int high,vector<int>& arr){\\n        if(low==high){\\n            seg[ind]=arr[low];\\n            return;\\n        }\\n        int mid = (low+high)>>1;\\n        build(2*ind+1,low,mid,arr);\\n        build(2*ind+2,mid+1,high,arr);\\n        seg[ind] = (seg[2*ind+1]*seg[2*ind+2])%mod;\\n    }\\n    long long query(int ind,int low,int high,int l,int r){\\n        if(low>r || high<l)\\n            return 1;\\n        if(low>=l && high<=r)\\n            return seg[ind]%mod;\\n        \\n        int mid = (low+high)>>1;\\n        long long left = query(2*ind+1,low,mid,l,r)%mod;\\n        long long right = query(2*ind+2,mid+1,high,l,r)%mod;\\n        return (left*right)%mod;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int m=n,cnt=0;\\n        while(m>0){\\n            m>>=1;\\n            cnt++;\\n        }\\n        vector<int> arr;\\n        m=n;\\n        int i=cnt;\\n        while(m>0 && i>=0){\\n            if((1<<i)<=m){\\n                arr.push_back(1<<i);\\n                m-=(1<<i);\\n            }\\n            i--;\\n        }\\n        reverse(arr.begin(),arr.end());\\n        SGTree sg = SGTree(arr.size());\\n        sg.build(0,0,arr.size()-1,arr);\\n        vector<int>ans;\\n        for(auto it:queries){\\n            ans.push_back(sg.query(0,0,arr.size()-1,it[0],it[1])%mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333521,
                "title": "binary-representation-prefix-sum-beats-92-c",
                "content": "# Code\\n\\n```cpp\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int modPow(int x, int y) {\\n        if (y == 0)\\n            return 1;\\n\\n        long power = modPow(x, y / 2) % MOD;\\n        power = (power * power) % MOD;\\n        return (y % 2 == 0)? power : (power * x) % MOD;\\n    }\\n    \\n    vector<int> productQueries(int n, vector<vector<int>> &queries)\\n    {\\n        vector<int> exponents;\\n        int exponent = 0;\\n\\n        while (n >= 1)\\n        {\\n            if (n % 2 == 1)\\n                exponents.push_back(exponent);\\n\\n            exponent++;\\n            n /= 2;\\n        }\\n\\n        int size = exponents.size();\\n        vector<int> prefix(size);\\n        \\n        prefix[0] = exponents[0];\\n\\n        for (int i = 1; i < size; i++)\\n            prefix[i] = prefix[i - 1] + exponents[i];\\n\\n        vector<int> answer;\\n\\n        for (auto &query: queries) {\\n            int left = query[0];\\n            int right = query[1];\\n\\n            if (left == right) {\\n                answer.push_back(modPow(2, exponents[left]));\\n                continue;\\n            }\\n\\n            if (left == 0) {\\n                answer.push_back(modPow(2, prefix[right]));\\n                continue;\\n            }\\n\\n            int exponent = prefix[right] - prefix[left - 1];\\n            answer.push_back(modPow(2, exponent));\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```cpp\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int modPow(int x, int y) {\\n        if (y == 0)\\n            return 1;\\n\\n        long power = modPow(x, y / 2) % MOD;\\n        power = (power * power) % MOD;\\n        return (y % 2 == 0)? power : (power * x) % MOD;\\n    }\\n    \\n    vector<int> productQueries(int n, vector<vector<int>> &queries)\\n    {\\n        vector<int> exponents;\\n        int exponent = 0;\\n\\n        while (n >= 1)\\n        {\\n            if (n % 2 == 1)\\n                exponents.push_back(exponent);\\n\\n            exponent++;\\n            n /= 2;\\n        }\\n\\n        int size = exponents.size();\\n        vector<int> prefix(size);\\n        \\n        prefix[0] = exponents[0];\\n\\n        for (int i = 1; i < size; i++)\\n            prefix[i] = prefix[i - 1] + exponents[i];\\n\\n        vector<int> answer;\\n\\n        for (auto &query: queries) {\\n            int left = query[0];\\n            int right = query[1];\\n\\n            if (left == right) {\\n                answer.push_back(modPow(2, exponents[left]));\\n                continue;\\n            }\\n\\n            if (left == 0) {\\n                answer.push_back(modPow(2, prefix[right]));\\n                continue;\\n            }\\n\\n            int exponent = prefix[right] - prefix[left - 1];\\n            answer.push_back(modPow(2, exponent));\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708916,
                "title": "c-long-but-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    vector<long long>v;\\n    void block(int x)\\n    {\\n        vector< long long> v1;\\n        \\n        while (x > 0) \\n        {\\n            v1.push_back(x % 2);\\n            x = x / 2;\\n        }\\n\\n        for (int i = 0; i < v1.size(); i++) \\n        {\\n            if (v1[i] == 1) \\n            {\\n                v.push_back(pow(2,i));\\n            }\\n        }\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) \\n    {\\n        block(n);\\n        vector<int>ans;\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            long long l = queries[i][0], h = queries[i][1];\\n            long long p=1;\\n            for(int j=l; j<=h; j++)\\n            {\\n                p= p*(v[j]);\\n                p = p%mod;\\n            }\\n            ans.push_back(p%mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    vector<long long>v;\\n    void block(int x)\\n    {\\n        vector< long long> v1;\\n        \\n        while (x > 0) \\n        {\\n            v1.push_back(x % 2);\\n            x = x / 2;\\n        }\\n\\n        for (int i = 0; i < v1.size(); i++) \\n        {\\n            if (v1[i] == 1) \\n            {\\n                v.push_back(pow(2,i));\\n            }\\n        }\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) \\n    {\\n        block(n);\\n        vector<int>ans;\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            long long l = queries[i][0], h = queries[i][1];\\n            long long p=1;\\n            for(int j=l; j<=h; j++)\\n            {\\n                p= p*(v[j]);\\n                p = p%mod;\\n            }\\n            ans.push_back(p%mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707613,
                "title": "bit-manipulation-python",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        positions = []\\n        position = 0\\n        while n>0:\\n            if n &1 == 1:\\n                positions.append(position)\\n            \\n            position += 1\\n            n = n >> 1\\n        \\n        powers = []\\n        for i in range(len(positions)):\\n            powers.append(2**positions[i])\\n        \\n        partial_product = [powers[0] for i in range(len(powers))]\\n        for i in range(1,len(powers)):\\n            partial_product[i] = partial_product[i-1] * powers[i]\\n        \\n        \\n        ans = []\\n        for left,right in queries:\\n            if left==0:\\n                x = partial_product[right] % (10**9 + 7)\\n                ans.append(x)\\n            else:\\n                x = (partial_product[right]//partial_product[left-1])%(10**9 + 7)\\n                ans.append(x)\\n        \\n        return ans\\n            \\n            \\n               \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        positions = []\\n        position = 0\\n        while n>0:\\n            if n &1 == 1:\\n                positions.append(position)\\n            \\n            position += 1\\n            n = n >> 1\\n        \\n        powers = []\\n        for i in range(len(positions)):\\n            powers.append(2**positions[i])\\n        \\n        partial_product = [powers[0] for i in range(len(powers))]\\n        for i in range(1,len(powers)):\\n            partial_product[i] = partial_product[i-1] * powers[i]\\n        \\n        \\n        ans = []\\n        for left,right in queries:\\n            if left==0:\\n                x = partial_product[right] % (10**9 + 7)\\n                ans.append(x)\\n            else:\\n                x = (partial_product[right]//partial_product[left-1])%(10**9 + 7)\\n                ans.append(x)\\n        \\n        return ans\\n            \\n            \\n               \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707100,
                "title": "two-easy-solution-c-brute-force-segment-tree",
                "content": "**Brute Force:**\\n```\\nclass Solution {\\n    public:\\n    const static int mod = 1e9 + 7;\\n    vector<int> temp,power,ans;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        ans.resize(queries.size());\\n        while(n)temp.push_back(n&1),n >>=1;\\n        for(int i = 0; i < temp.size(); i++)if(temp[i])power.push_back(1<<i);\\n        int i = 0;\\n        for(auto q : queries) {\\n            long sum = 1;\\n            for(int i = q[0]; i <= q[1]; i++)sum = (long)(sum * power[i] % mod);\\n            ans[i++] = (int)sum;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Segment Trees:**\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+ 7;\\n    vector<long int> seg,power;\\n    void build(int i, int low, int high) {\\n        if(low == high) {\\n            seg[i] = power[low];\\n            return;\\n        }\\n        int mid = (low + high) / 2;\\n        build(i * 2 + 1, low, mid);\\n        build(i * 2 + 2, mid + 1, high);\\n        seg[i] = (seg[i * 2 + 1] * seg[i * 2 + 2]) % mod;\\n    }\\n    \\n    long int find(int i, int low, int high, int l, int r) {\\n        if(low >= l and high <= r)return seg[i];\\n        if(high < l or low > r)return 1;\\n        int mid = (low + high) / 2;\\n        long int left = find(i * 2 + 1, low, mid, l, r) % mod;\\n        long int right = find(i * 2 + 2, mid + 1, high, l, r) % mod;\\n        return (left * right) % mod;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries,vector<int> ans = {}) {\\n        for(int i = 0;i<32;i++)if(n&(1<<i))power.push_back(1<<i);\\n        n = power.size();\\n        seg.resize(4*n+10);\\n        build(0, 0, n - 1);\\n        for(auto it : queries)ans.push_back(find(0, 0, n - 1, it[0], it[1]) % mod);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    const static int mod = 1e9 + 7;\\n    vector<int> temp,power,ans;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        ans.resize(queries.size());\\n        while(n)temp.push_back(n&1),n >>=1;\\n        for(int i = 0; i < temp.size(); i++)if(temp[i])power.push_back(1<<i);\\n        int i = 0;\\n        for(auto q : queries) {\\n            long sum = 1;\\n            for(int i = q[0]; i <= q[1]; i++)sum = (long)(sum * power[i] % mod);\\n            ans[i++] = (int)sum;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+ 7;\\n    vector<long int> seg,power;\\n    void build(int i, int low, int high) {\\n        if(low == high) {\\n            seg[i] = power[low];\\n            return;\\n        }\\n        int mid = (low + high) / 2;\\n        build(i * 2 + 1, low, mid);\\n        build(i * 2 + 2, mid + 1, high);\\n        seg[i] = (seg[i * 2 + 1] * seg[i * 2 + 2]) % mod;\\n    }\\n    \\n    long int find(int i, int low, int high, int l, int r) {\\n        if(low >= l and high <= r)return seg[i];\\n        if(high < l or low > r)return 1;\\n        int mid = (low + high) / 2;\\n        long int left = find(i * 2 + 1, low, mid, l, r) % mod;\\n        long int right = find(i * 2 + 2, mid + 1, high, l, r) % mod;\\n        return (left * right) % mod;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries,vector<int> ans = {}) {\\n        for(int i = 0;i<32;i++)if(n&(1<<i))power.push_back(1<<i);\\n        n = power.size();\\n        seg.resize(4*n+10);\\n        build(0, 0, n - 1);\\n        for(auto it : queries)ans.push_back(find(0, 0, n - 1, it[0], it[1]) % mod);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706846,
                "title": "not-so-easy-clean-python",
                "content": "```\\n\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        inp=bin(n).replace(\"0b\", \"\")        \\n        pows, result = [] , []\\n        multiple, N = 1, len(inp)\\n        for i in range(N - 1, -1, -1):                        \\n            if i < N - 1:\\n                multiple *= 2            \\n            if inp[i] == \\'1\\':\\n                pows.append(multiple)                \\n        for s, e in queries:\\n            tmp = 1\\n            for i in range(s, e + 1):\\n                tmp *= pows[i]\\n            result.append( tmp % ((10 ** 9) +7 ))              \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        inp=bin(n).replace(\"0b\", \"\")        \\n        pows, result = [] , []\\n        multiple, N = 1, len(inp)\\n        for i in range(N - 1, -1, -1):                        \\n            if i < N - 1:\\n                multiple *= 2            \\n            if inp[i] == \\'1\\':\\n                pows.append(multiple)                \\n        for s, e in queries:\\n            tmp = 1\\n            for i in range(s, e + 1):\\n                tmp *= pows[i]\\n            result.append( tmp % ((10 ** 9) +7 ))              \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706819,
                "title": "greedy-no-bit-manipulation-short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v, powers, ans;\\n        for(int i=0; i<31; i++) v.push_back(pow(2, i));\\n        \\n        for(int i=v.size()-1; i>=0; i--) {\\n            if(v[i] <= n) powers.push_back(v[i]), n -= v[i];\\n        }\\n        reverse(powers.begin(), powers.end());\\n\\n        int mod = 1e9 + 7;\\n        for(auto q : queries) {\\n            long long p = 1;\\n            for(int k=q[0]; k<=q[1]; k++) {\\n                p *= powers[k];\\n                p %= mod;\\n            }\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v, powers, ans;\\n        for(int i=0; i<31; i++) v.push_back(pow(2, i));\\n        \\n        for(int i=v.size()-1; i>=0; i--) {\\n            if(v[i] <= n) powers.push_back(v[i]), n -= v[i];\\n        }\\n        reverse(powers.begin(), powers.end());\\n\\n        int mod = 1e9 + 7;\\n        for(auto q : queries) {\\n            long long p = 1;\\n            for(int k=q[0]; k<=q[1]; k++) {\\n                p *= powers[k];\\n                p %= mod;\\n            }\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706715,
                "title": "python-solution",
                "content": "```\\n\\n```class Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        bits=[]\\n        shift=0\\n        while n>0:\\n            if n%2>0:\\n                bits.append((n%2)<<shift)\\n            shift+=1\\n            n//=2\\n            \\n        ans=[]\\n        for left,right in queries:\\n            total=1\\n            for i in range(left,right+1):\\n                total*=bits[i]\\n                \\n            ans.append(total%(10**9+7))\\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706691,
                "title": "c-accepted-easy-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        long sum=1;\\n        vector<int> power;\\n        vector<int> res;\\n        for(int i=0;i<32;i++){\\n            if((n&(1<<i))!=0)\\n                power.push_back(1<<i);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int start=queries[i][0],end=queries[i][1];\\n            sum=1;\\n            for(int j=queries[i][0];j<=queries[i][1];j++){\\n                sum=(sum*power[j])%1000000007;\\n            }\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        long sum=1;\\n        vector<int> power;\\n        vector<int> res;\\n        for(int i=0;i<32;i++){\\n            if((n&(1<<i))!=0)\\n                power.push_back(1<<i);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            int start=queries[i][0],end=queries[i][1];\\n            sum=1;\\n            for(int j=queries[i][0];j<=queries[i][1];j++){\\n                sum=(sum*power[j])%1000000007;\\n            }\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706688,
                "title": "c-segment-tree-solution",
                "content": "A bit overkill but it works and good practice to implement.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unsigned long long> tree;\\n    void buildTree(int tstart, int tend, vector<int> powers, int idx){\\n        if(tend < tstart){\\n            return;\\n        }\\n        if(tstart == tend){\\n            tree[idx] = powers[tstart];\\n        }else{\\n            int mid = (tstart + tend) /2;\\n            buildTree(tstart, mid, powers, (2*idx)+1);\\n            buildTree(mid+1, tend, powers, (2*idx)+2);\\n            tree[idx] = (tree[(2*idx)+1]  * tree[(2*idx)+2]) % 1000000007;\\n        }\\n    }\\n    \\n    int find(int qstart, int qend, int tstart, int tend, int idx){\\n        if(tstart > tend){\\n            return 1;\\n        }\\n        if(tstart > qend || tend < qstart){\\n            return 1;\\n        }\\n        if(qstart <= tstart &&  tend <=qend){\\n            return tree[idx];\\n        }\\n        int mid = (tstart + tend) /2;\\n        unsigned long long half1 = find(qstart, qend, tstart, mid, (2*idx)+1);\\n        unsigned long long half2 = find(qstart, qend, mid+1, tend, (2*idx)+2);\\n        unsigned long long ans = half1* half2 % 1000000007;\\n        return ans ;\\n    }\\n    \\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(), 0);\\n        vector<int> powers;\\n        for(int i = 31; i>=0; i--){\\n            int power = n & (1<<i);\\n            if(power >0){\\n                powers.push_back(power);\\n            }\\n        }\\n        reverse(powers.begin() , powers.end());\\n        buildTree(0, powers.size()-1, powers, 0);\\n        for(int i = 0; i < queries.size(); i++){\\n            vector<int> query = queries[i];\\n            ans[i] = find(query[0], query[1], 0, powers.size()-1, 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unsigned long long> tree;\\n    void buildTree(int tstart, int tend, vector<int> powers, int idx){\\n        if(tend < tstart){\\n            return;\\n        }\\n        if(tstart == tend){\\n            tree[idx] = powers[tstart];\\n        }else{\\n            int mid = (tstart + tend) /2;\\n            buildTree(tstart, mid, powers, (2*idx)+1);\\n            buildTree(mid+1, tend, powers, (2*idx)+2);\\n            tree[idx] = (tree[(2*idx)+1]  * tree[(2*idx)+2]) % 1000000007;\\n        }\\n    }\\n    \\n    int find(int qstart, int qend, int tstart, int tend, int idx){\\n        if(tstart > tend){\\n            return 1;\\n        }\\n        if(tstart > qend || tend < qstart){\\n            return 1;\\n        }\\n        if(qstart <= tstart &&  tend <=qend){\\n            return tree[idx];\\n        }\\n        int mid = (tstart + tend) /2;\\n        unsigned long long half1 = find(qstart, qend, tstart, mid, (2*idx)+1);\\n        unsigned long long half2 = find(qstart, qend, mid+1, tend, (2*idx)+2);\\n        unsigned long long ans = half1* half2 % 1000000007;\\n        return ans ;\\n    }\\n    \\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(), 0);\\n        vector<int> powers;\\n        for(int i = 31; i>=0; i--){\\n            int power = n & (1<<i);\\n            if(power >0){\\n                powers.push_back(power);\\n            }\\n        }\\n        reverse(powers.begin() , powers.end());\\n        buildTree(0, powers.size()-1, powers, 0);\\n        for(int i = 0; i < queries.size(); i++){\\n            vector<int> query = queries[i];\\n            ans[i] = find(query[0], query[1], 0, powers.size()-1, 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706685,
                "title": "java-using-biginteger-o-q-tc-o-log-n-sc-biginteger-prefix-multiplication",
                "content": "```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    BigInteger mod = new BigInteger((int)(1e9 + 7) + \"\");\\n\\n    public int[] productQueries(int n, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n\\n        // Building the powers array\\n        List<Integer> powers = new ArrayList<>();\\n        int twoPower = 1;\\n        for (int i = 0; i <= 30; i++) {\\n            if (((1 << i) & n) > 0) {\\n                powers.add(twoPower);\\n            }\\n            twoPower *= 2;\\n        }\\n\\n        // Storing the values as BigInteger as the value can get pretty huge\\n        BigInteger[] prefixMul = new BigInteger[powers.size()];\\n        prefixMul[0] = new BigInteger(powers.get(0) + \"\");\\n        for (int i = 1; i < powers.size(); i++) {\\n            prefixMul[i] = prefixMul[i - 1].multiply(new BigInteger(powers.get(i) + \"\"));\\n        }\\n\\n        // Calculate the range multiplication using the classic formula: prefix[right] / prefix[left - 1]\\n        int i = 0;\\n        for (int[] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            if (left == 0)\\n                ans[i++] = prefixMul[right].mod(mod).intValue();\\n            else\\n                ans[i++] = (prefixMul[right].divide(prefixMul[left - 1]).mod(mod)).intValue();\\n        }\\n        return ans;\\n    }\\n    // Time Complexity: O(q)\\n    // Space Complexity: O(log(n))\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    BigInteger mod = new BigInteger((int)(1e9 + 7) + \"\");\\n\\n    public int[] productQueries(int n, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n\\n        // Building the powers array\\n        List<Integer> powers = new ArrayList<>();\\n        int twoPower = 1;\\n        for (int i = 0; i <= 30; i++) {\\n            if (((1 << i) & n) > 0) {\\n                powers.add(twoPower);\\n            }\\n            twoPower *= 2;\\n        }\\n\\n        // Storing the values as BigInteger as the value can get pretty huge\\n        BigInteger[] prefixMul = new BigInteger[powers.size()];\\n        prefixMul[0] = new BigInteger(powers.get(0) + \"\");\\n        for (int i = 1; i < powers.size(); i++) {\\n            prefixMul[i] = prefixMul[i - 1].multiply(new BigInteger(powers.get(i) + \"\"));\\n        }\\n\\n        // Calculate the range multiplication using the classic formula: prefix[right] / prefix[left - 1]\\n        int i = 0;\\n        for (int[] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            if (left == 0)\\n                ans[i++] = prefixMul[right].mod(mod).intValue();\\n            else\\n                ans[i++] = (prefixMul[right].divide(prefixMul[left - 1]).mod(mod)).intValue();\\n        }\\n        return ans;\\n    }\\n    // Time Complexity: O(q)\\n    // Space Complexity: O(log(n))\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706678,
                "title": "prefix-power-sum-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    long power(long a, long b, int mod) {\\n        a %= mod;\\n        long res = 1;\\n        while(b) {\\n            if(b&1) {\\n                res = (res*a)%mod;\\n            }\\n            a = (a*a)%mod;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> nums;\\n        for(int i = 0; i < 32; i++) {\\n            if(n&(1<<i)) nums.push_back(i);\\n        }\\n        int sz = nums.size();\\n        vector<int> pre(sz+1, 0);\\n        for(int i = 0; i < sz; i++) {\\n            pre[i+1] = pre[i] + nums[i];\\n        }\\n        vector<int> res;\\n        for(auto q : queries) {\\n            int sum = pre[q[1]+1]-pre[q[0]];\\n            res.push_back(power(2, sum, mod));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    long power(long a, long b, int mod) {\\n        a %= mod;\\n        long res = 1;\\n        while(b) {\\n            if(b&1) {\\n                res = (res*a)%mod;\\n            }\\n            a = (a*a)%mod;\\n            b >>= 1;\\n        }\\n        return res;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> nums;\\n        for(int i = 0; i < 32; i++) {\\n            if(n&(1<<i)) nums.push_back(i);\\n        }\\n        int sz = nums.size();\\n        vector<int> pre(sz+1, 0);\\n        for(int i = 0; i < sz; i++) {\\n            pre[i+1] = pre[i] + nums[i];\\n        }\\n        vector<int> res;\\n        for(auto q : queries) {\\n            int sum = pre[q[1]+1]-pre[q[0]];\\n            res.push_back(power(2, sum, mod));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706635,
                "title": "c-easy-solution",
                "content": "```\\nvector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int mod=1e9+7;\\n        vector<int>powers;\\n        int a=1;\\n\\t\\t// \\n        while(n)\\n        {\\n            if(n&1) powers.push_back(a);\\n            a=a*2;\\n            n=n>>1;\\n        }\\n        vector<int>ans(queries.size());\\n        long long pre=1;\\n        \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            for(int j=queries[i][0];j<=queries[i][1];j++)\\n            {\\n                pre=(pre*powers[j]*1ll)%mod;\\n            }\\n            ans[i]=pre; pre=1;\\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int mod=1e9+7;\\n        vector<int>powers;\\n        int a=1;\\n\\t\\t// \\n        while(n)\\n        {\\n            if(n&1) powers.push_back(a);\\n            a=a*2;\\n            n=n>>1;\\n        }\\n        vector<int>ans(queries.size());\\n        long long pre=1;\\n        \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            for(int j=queries[i][0];j<=queries[i][1];j++)\\n            {\\n                pre=(pre*powers[j]*1ll)%mod;\\n            }\\n            ans[i]=pre; pre=1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2706629,
                "title": "easy-solution",
                "content": "class Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        powers = []\\n        a=bin(n)[2:]\\n        j=0\\n        \\n        for i in range(len(a)-1,-1,-1):\\n            if a[i]==\\'1\\':\\n                powers.append(2**j)\\n            j+=1\\n            \\n        res = []\\n        mod = (10**9) + 7\\n        new = 1\\n        \\n        for q in queries:\\n            l,r = q\\n            for i in range(l,r+1):\\n                new= new * powers[i]\\n            new = new % mod\\n            res.append(new)\\n            new = 1\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "class Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        powers = []\\n        a=bin(n)[2:]\\n        j=0\\n        \\n        for i in range(len(a)-1,-1,-1):\\n            if a[i]==\\'1\\':\\n                powers.append(2**j)\\n            j+=1\\n            \\n        res = []\\n        mod = (10**9) + 7\\n        new = 1\\n        \\n        for q in queries:\\n            l,r = q\\n            for i in range(l,r+1):\\n                new= new * powers[i]\\n            new = new % mod\\n            res.append(new)\\n            new = 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2706584,
                "title": "c-bit-manipulation-easy-to-understand",
                "content": "\\t// Since binary represtentation of number gives us any number as the sum of powers of \\'2\\' so we can use\\n\\t// sum of powers of 2 where bit is set to 1 \\n\\tvector<int> productQueries(int n, vector<vector<int>>& queries) \\n\\t{\\n        vector<long> ar;\\n        for(int i=0;i<=31;i++)\\n        {\\n            if(n & (1<<i))                                               // for checking if ith bit is set to 1 \\n                ar.push_back((1<<i));\\n        }\\n        \\n        int mod = (1e9)+7;\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            \\n            int res=1;\\n            for(int i=l;i<=r;i++)\\n                res =  (res*ar[i])%mod;\\n            \\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "\\t// Since binary represtentation of number gives us any number as the sum of powers of \\'2\\' so we can use\\n\\t// sum of powers of 2 where bit is set to 1 \\n\\tvector<int> productQueries(int n, vector<vector<int>>& queries) \\n\\t{\\n        vector<long> ar;\\n        for(int i=0;i<=31;i++)\\n        {\\n            if(n & (1<<i))                                               // for checking if ith bit is set to 1 \\n                ar.push_back((1<<i));\\n        }\\n        \\n        int mod = (1e9)+7;\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            \\n            int res=1;\\n            for(int i=l;i<=r;i++)\\n                res =  (res*ar[i])%mod;\\n            \\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2706544,
                "title": "easy-bit-manipulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> arr;\\n        \\n        for(int i = 0; i < 32; i++) {\\n            if ((n >> i) & 1) {\\n                arr.push_back(1 << i);\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        for(auto &q: queries) {\\n            int l = q[0], r = q[1];\\n            \\n            int temp = 1;\\n            for(int i = l; i <= r; i++) {\\n                temp = (temp * 1LL * arr[i]) % (int)(1e9 + 7);\\n            }\\n       \\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> arr;\\n        \\n        for(int i = 0; i < 32; i++) {\\n            if ((n >> i) & 1) {\\n                arr.push_back(1 << i);\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        for(auto &q: queries) {\\n            int l = q[0], r = q[1];\\n            \\n            int temp = 1;\\n            for(int i = l; i <= r; i++) {\\n                temp = (temp * 1LL * arr[i]) % (int)(1e9 + 7);\\n            }\\n       \\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706443,
                "title": "python-straightforward-solution",
                "content": "Simple problem.\\nDon\\'t worry the powers list, it is just from n\\'s binary representation(reversed order).\\n\\n```\\nclass Solution:\\n    def productQueries(self, n: int, queries):\\n        bn = bin(n)[2:]\\n        bn = bn[::-1]\\n        powers = []\\n        for i, v in enumerate(bn):\\n            if v == \\'1\\':\\n                powers.append(i)\\n        ans = []\\n        for l, r in queries:\\n            t = 0\\n            for i in range(l, r + 1):\\n                t += powers[i]\\n            ans.append(2 ** t % (10 ** 9 + 7))\\n        return ans",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "Simple problem.\\nDon\\'t worry the powers list, it is just from n\\'s binary representation(reversed order).\\n\\n```\\nclass Solution:\\n    def productQueries(self, n: int, queries):\\n        bn = bin(n)[2:]\\n        bn = bn[::-1]\\n        powers = []\\n        for i, v in enumerate(bn):\\n            if v == \\'1\\':\\n                powers.append(i)\\n        ans = []\\n        for l, r in queries:\\n            t = 0\\n            for i in range(l, r + 1):\\n                t += powers[i]\\n            ans.append(2 ** t % (10 ** 9 + 7))\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2706423,
                "title": "python-easy-soln",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        def min_arr(x):\\n            k = bin(x)[2:]\\n            k = k[::-1]\\n            ans = []\\n            for i in range(0, len(k)):\\n                if (k[i] == \\'1\\'):\\n                    ans.append(2**i)\\n            return ans\\n        nums = min_arr(n)\\n        prod = [1]\\n        for i in range(len(nums)):\\n            k = (prod[-1]*nums[i])\\n            prod.append(k)\\n        res = []\\n        for i in range(len(queries)):\\n            b = prod[queries[i][1]+1]\\n            a = prod[queries[i][0]]\\n            res.append((b//a))\\n            res[i] = res[i]%(10**9 + 7)\\n        return res  \\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        def min_arr(x):\\n            k = bin(x)[2:]\\n            k = k[::-1]\\n            ans = []\\n            for i in range(0, len(k)):\\n                if (k[i] == \\'1\\'):\\n                    ans.append(2**i)\\n            return ans\\n        nums = min_arr(n)\\n        prod = [1]\\n        for i in range(len(nums)):\\n            k = (prod[-1]*nums[i])\\n            prod.append(k)\\n        res = []\\n        for i in range(len(queries)):\\n            b = prod[queries[i][1]+1]\\n            a = prod[queries[i][0]]\\n            res.append((b//a))\\n            res[i] = res[i]%(10**9 + 7)\\n        return res  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706421,
                "title": "easy-short-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\nconst ll mod = 1e9 + 7;\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>&q) {\\n        vi(ll)p;\\n        for(ll i=0, N=n;N>0;++i){\\n            if((N>>i)&1){\\n                p.pb(1<<i);\\n                N^=1<<i;\\n            }\\n        }\\n        ll sz=q.size();\\n        vi(int)ans(sz, 1);\\n        for(ll i=0;i<sz;++i){\\n            for(ll j=q[i][0];j<=q[i][1];++j){\\n                ans[i]=(ans[i]*p[j])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\nconst ll mod = 1e9 + 7;\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>&q) {\\n        vi(ll)p;\\n        for(ll i=0, N=n;N>0;++i){\\n            if((N>>i)&1){\\n                p.pb(1<<i);\\n                N^=1<<i;\\n            }\\n        }\\n        ll sz=q.size();\\n        vi(int)ans(sz, 1);\\n        for(ll i=0;i<sz;++i){\\n            for(ll j=q[i][0];j<=q[i][1];++j){\\n                ans[i]=(ans[i]*p[j])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706368,
                "title": "python-commented",
                "content": "```\\n# 6209. Range Product Queries of Powers\\n# populate powers of two\\n# compute prefix products\\n# answer the query using inverse power\\n\\nclass Solution:\\n    def productQueries(self, n: int, queries):\\n        mod, pr = 10 ** 9 + 7, [1]\\n        arr = [pow(2, i, mod) for i in range(32) if n & (1 << i)]\\n\\n        for a in arr:\\n            pr.append(pr[-1] * a % mod)\\n\\n        return [pr[r + 1] * pow(pr[l], -1, mod) % mod for l, r in queries]\\n```",
                "solutionTags": [],
                "code": "```\\n# 6209. Range Product Queries of Powers\\n# populate powers of two\\n# compute prefix products\\n# answer the query using inverse power\\n\\nclass Solution:\\n    def productQueries(self, n: int, queries):\\n        mod, pr = 10 ** 9 + 7, [1]\\n        arr = [pow(2, i, mod) for i in range(32) if n & (1 << i)]\\n\\n        for a in arr:\\n            pr.append(pr[-1] * a % mod)\\n\\n        return [pr[r + 1] * pow(pr[l], -1, mod) % mod for l, r in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706338,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int temp = n;\\n        vector<int> t;\\n        int count = 0;\\n        while(temp) {\\n            if(temp & 1 > 0) {\\n                int c = pow(2, count);\\n                t.push_back(c);\\n            }\\n            temp = temp >> 1;\\n            count++;\\n        }\\n        vector<int> res;\\n        for(auto query: queries) {\\n            int start = query[0];\\n            int end = query[1];\\n            \\n            long long prod = 1;\\n            for(int i = start; i <= end; i++) {\\n                prod = ((prod % mod) * t[i]) % mod;\\n            }\\n            res.push_back(prod % mod);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int temp = n;\\n        vector<int> t;\\n        int count = 0;\\n        while(temp) {\\n            if(temp & 1 > 0) {\\n                int c = pow(2, count);\\n                t.push_back(c);\\n            }\\n            temp = temp >> 1;\\n            count++;\\n        }\\n        vector<int> res;\\n        for(auto query: queries) {\\n            int start = query[0];\\n            int end = query[1];\\n            \\n            long long prod = 1;\\n            for(int i = start; i <= end; i++) {\\n                prod = ((prod % mod) * t[i]) % mod;\\n            }\\n            res.push_back(prod % mod);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010759,
                "title": "golang-200ms-100-solution",
                "content": "# Code\\n```go\\nfunc productQueries(n int, queries [][]int) []int {\\n\\tmagic := 1\\n\\tlevel := 0\\n\\tfor n > magic {\\n\\t\\tmagic *= 2\\n\\t\\tlevel++\\n\\t}\\n\\tpowers := make([]int, 0, 13)\\n\\tfor n > 0 {\\n\\t\\tif n < magic {\\n\\t\\t\\tmagic /= 2\\n\\t\\t\\tlevel--\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tn -= magic\\n\\t\\tpowers = append(powers, level)\\n\\t}\\n\\t// reverse powers to make powers increment\\n\\tfor i := 0; i < len(powers)/2; i++ {\\n\\t\\tpowers[i], powers[len(powers)-1-i] = powers[len(powers)-1-i], powers[i]\\n\\t}\\n\\tcurrent := 0\\n\\tfor i := range powers {\\n\\t\\tcurrent += powers[i]\\n\\t\\tpowers[i] = current\\n\\t}\\n\\tresult := make([]int, 0, len(queries))\\n\\tfastResult := make([]int, 0, current+1)\\n\\tfastResultCurrent := 1\\n\\tfor i := 0; i <= current; i++ {\\n\\t\\tfastResult = append(fastResult, fastResultCurrent)\\n\\t\\tfastResultCurrent *= 2\\n\\t\\tfastResultCurrent %= 1000000007\\n\\t}\\n\\tfor _, query := range queries {\\n\\t\\tpowerOf2 := powers[query[1]]\\n\\t\\tif query[0] > 0 {\\n\\t\\t\\tpowerOf2 -= powers[query[0]-1]\\n\\t\\t}\\n\\t\\tresult = append(result, fastResult[powerOf2])\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc productQueries(n int, queries [][]int) []int {\\n\\tmagic := 1\\n\\tlevel := 0\\n\\tfor n > magic {\\n\\t\\tmagic *= 2\\n\\t\\tlevel++\\n\\t}\\n\\tpowers := make([]int, 0, 13)\\n\\tfor n > 0 {\\n\\t\\tif n < magic {\\n\\t\\t\\tmagic /= 2\\n\\t\\t\\tlevel--\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tn -= magic\\n\\t\\tpowers = append(powers, level)\\n\\t}\\n\\t// reverse powers to make powers increment\\n\\tfor i := 0; i < len(powers)/2; i++ {\\n\\t\\tpowers[i], powers[len(powers)-1-i] = powers[len(powers)-1-i], powers[i]\\n\\t}\\n\\tcurrent := 0\\n\\tfor i := range powers {\\n\\t\\tcurrent += powers[i]\\n\\t\\tpowers[i] = current\\n\\t}\\n\\tresult := make([]int, 0, len(queries))\\n\\tfastResult := make([]int, 0, current+1)\\n\\tfastResultCurrent := 1\\n\\tfor i := 0; i <= current; i++ {\\n\\t\\tfastResult = append(fastResult, fastResultCurrent)\\n\\t\\tfastResultCurrent *= 2\\n\\t\\tfastResultCurrent %= 1000000007\\n\\t}\\n\\tfor _, query := range queries {\\n\\t\\tpowerOf2 := powers[query[1]]\\n\\t\\tif query[0] > 0 {\\n\\t\\t\\tpowerOf2 -= powers[query[0]-1]\\n\\t\\t}\\n\\t\\tresult = append(result, fastResult[powerOf2])\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3869825,
                "title": "quick-intuitive-solution-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def productQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        start = int(math.log(n,2)) + 1 ## largest power of 2 we need to consider\\n        powers = []\\n        answer = []\\n        for i in reversed(range(0,start+1)): \\n            if n - 2**i >= 0: ## n - 2^i is positive, we need it to construct n\\n                n -= 2**i\\n                powers.append(2**i) ## add it to powers list\\n        powers.reverse() ## reverse the list so it is in ascending order\\n        for i in range(len(queries)): \\n            answer.append(1)\\n            for j in range(queries[i][0],queries[i][1]+1): \\n                answer[i] *= powers[j]\\n        answer = [int(x % (10**9 + 7)) for x in answer]\\n        return answer\\n                \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def productQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        start = int(math.log(n,2)) + 1 ## largest power of 2 we need to consider\\n        powers = []\\n        answer = []\\n        for i in reversed(range(0,start+1)): \\n            if n - 2**i >= 0: ## n - 2^i is positive, we need it to construct n\\n                n -= 2**i\\n                powers.append(2**i) ## add it to powers list\\n        powers.reverse() ## reverse the list so it is in ascending order\\n        for i in range(len(queries)): \\n            answer.append(1)\\n            for j in range(queries[i][0],queries[i][1]+1): \\n                answer[i] *= powers[j]\\n        answer = [int(x % (10**9 + 7)) for x in answer]\\n        return answer\\n                \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842239,
                "title": "python-modular-multiplicative-inverse-20-lines",
                "content": "# Code\\n```\\nMOD = int(1e9 + 7)\\n\\ndef modular_inverse(a, m):\\n    return pow(a, -1, m)\\n\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        binary_digits = bin(n)[2:][::-1]\\n\\n        products = [1]\\n        for i, b in enumerate(binary_digits):\\n            if b == \\'1\\':\\n                power = 1 << i\\n                products.append((products[-1] * power) % MOD)\\n\\n        outputs = []\\n        for (a, b) in queries:\\n            inv = modular_inverse(products[a], MOD)\\n            outputs.append((products[b + 1] * inv) % MOD)\\n        return outputs\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nMOD = int(1e9 + 7)\\n\\ndef modular_inverse(a, m):\\n    return pow(a, -1, m)\\n\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        binary_digits = bin(n)[2:][::-1]\\n\\n        products = [1]\\n        for i, b in enumerate(binary_digits):\\n            if b == \\'1\\':\\n                power = 1 << i\\n                products.append((products[-1] * power) % MOD)\\n\\n        outputs = []\\n        for (a, b) in queries:\\n            inv = modular_inverse(products[a], MOD)\\n            outputs.append((products[b + 1] * inv) % MOD)\\n        return outputs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810512,
                "title": "python-brute-force-is-okay-max-powers-len-is-29",
                "content": "```python\\n\"\"\"\\nSince maximum powers length is limited by number of bits of n (10**9)\\nso it\\'s 29 powers. Doing brute force here is okay. It takes 700 ms for\\nworse test case when n = 536870911 (\\'0b11111111111111111111111111111\\')\\nand queries length is 10**5.\\n\\nTC: O(N) [29N]\\nSC: O(N) [answers len]\\n\"\"\"\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers = [2**i for i in range(n.bit_length()) if n & (1 << i)]\\n\\n        answers = []\\n        for left, right in queries:\\n            v = 1\\n            for i in range(left, right + 1):\\n                v *= powers[i]\\n\\n            answers.append(v % (10**9 + 7))\\n\\n        return answers\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\"\"\"\\nSince maximum powers length is limited by number of bits of n (10**9)\\nso it\\'s 29 powers. Doing brute force here is okay. It takes 700 ms for\\nworse test case when n = 536870911 (\\'0b11111111111111111111111111111\\')\\nand queries length is 10**5.\\n\\nTC: O(N) [29N]\\nSC: O(N) [answers len]\\n\"\"\"\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers = [2**i for i in range(n.bit_length()) if n & (1 << i)]\\n\\n        answers = []\\n        for left, right in queries:\\n            v = 1\\n            for i in range(left, right + 1):\\n                v *= powers[i]\\n\\n            answers.append(v % (10**9 + 7))\\n\\n        return answers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789544,
                "title": "using-segment-tree-template-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n         vector<int> nums;\\n        int temp=n;\\n        int res=1;\\n        while(temp>0)\\n        {\\n            if(temp%2!=0)\\n            {\\n                nums.push_back(res);\\n            }\\n            res=res*2;  \\n            temp=temp/2;\\n        }\\n        int p=nums.size();\\n        vector<int> tree(4*p+1,1);\\n        buildTree(nums,tree,0,p-1,1);\\n\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int x=query(tree,0,p-1,1,queries[i][0],queries[i][1]);\\n            ans.push_back(x);\\n        }\\n       \\n        return ans;\\n    }\\n    void buildTree(vector<int>& nums,vector<int>& tree,int start,int end,int ind)\\n    {\\n        if(start==end)\\n        {\\n            tree[ind]=nums[start];\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(nums,tree,start,mid,2*ind);\\n        buildTree(nums,tree,mid+1,end,2*ind+1);\\n\\n        tree[ind]=((1LL*tree[2*ind]%mod)*(1LL*tree[2*ind+1]%mod))%mod;\\n    }\\n    int query(vector<int>& tree,int start,int end,int ind,int left,int right){\\n        if(start>right||end<left)\\n        return 1;\\n\\n        if(start>=left&&end<=right)\\n        {\\n            return tree[ind];\\n        }\\n        int mid=(start+end)/2;\\n        int ans1=query(tree,start,mid,2*1LL*ind,left,right);\\n        int ans2=query(tree,mid+1,end,2*ind+1,left,right);\\n        return ((1LL*ans1%mod)*(1LL*ans2%mod))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n         vector<int> nums;\\n        int temp=n;\\n        int res=1;\\n        while(temp>0)\\n        {\\n            if(temp%2!=0)\\n            {\\n                nums.push_back(res);\\n            }\\n            res=res*2;  \\n            temp=temp/2;\\n        }\\n        int p=nums.size();\\n        vector<int> tree(4*p+1,1);\\n        buildTree(nums,tree,0,p-1,1);\\n\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int x=query(tree,0,p-1,1,queries[i][0],queries[i][1]);\\n            ans.push_back(x);\\n        }\\n       \\n        return ans;\\n    }\\n    void buildTree(vector<int>& nums,vector<int>& tree,int start,int end,int ind)\\n    {\\n        if(start==end)\\n        {\\n            tree[ind]=nums[start];\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(nums,tree,start,mid,2*ind);\\n        buildTree(nums,tree,mid+1,end,2*ind+1);\\n\\n        tree[ind]=((1LL*tree[2*ind]%mod)*(1LL*tree[2*ind+1]%mod))%mod;\\n    }\\n    int query(vector<int>& tree,int start,int end,int ind,int left,int right){\\n        if(start>right||end<left)\\n        return 1;\\n\\n        if(start>=left&&end<=right)\\n        {\\n            return tree[ind];\\n        }\\n        int mid=(start+end)/2;\\n        int ans1=query(tree,start,mid,2*1LL*ind,left,right);\\n        int ans2=query(tree,mid+1,end,2*ind+1,left,right);\\n        return ((1LL*ans1%mod)*(1LL*ans2%mod))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688384,
                "title": "analyse-bit-representation-of-n-simple-solution-c",
                "content": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> powers;\\n        \\n        for(int i = 0; i < 32; i++) {\\n            if(n & (1 << i)) {\\n                powers.push_back(1 << i);\\n            }\\n        }\\n        int m = powers.size();\\n        vector<int> ans;\\n        for(auto &query:queries) {\\n            long long curr = 1;\\n            \\n            for(int i = query[0]; i <= query[1]; i++) curr = (curr * powers[i]) % mod;\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> powers;\\n        \\n        for(int i = 0; i < 32; i++) {\\n            if(n & (1 << i)) {\\n                powers.push_back(1 << i);\\n            }\\n        }\\n        int m = powers.size();\\n        vector<int> ans;\\n        for(auto &query:queries) {\\n            long long curr = 1;\\n            \\n            for(int i = query[0]; i <= query[1]; i++) curr = (curr * powers[i]) % mod;\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658687,
                "title": "2438-range-product-queries-of-powers-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    static long mod = (long) 1e9 + 7;\\n    public void Powers(long n,ArrayList<Long> powers){\\n        long temp =n;\\n        long start = 0;\\n        while(temp!=0){\\n            long curr = (long)Math.pow(2,start);\\n            long next = (long)Math.pow(2,start+1);\\n            if((temp-curr)%next == 0){\\n                System.out.println(curr);\\n                powers.add(curr);\\n                temp = temp - curr;\\n            }\\n            start = start + 1;   \\n        }\\n    }\\n    public int[] productQueries(int n, int[][] queries) {\\n        ArrayList<Integer> answer = new ArrayList<>();\\n        ArrayList<Long> powers = new ArrayList<>();\\n        Powers((long)n, powers);\\n        System.out.println(powers);\\n        for(int[] arr : queries){\\n            int starti = arr[0];\\n            int endi = arr[1];\\n            long pow = 1;\\n            for(int i=starti; i<=endi; i++){\\n                pow = (pow * powers.get(i)) % mod;\\n            }\\n\\n            answer.add((int)pow);\\n        }\\n        int[] ans = new int[answer.size()];\\n        int b = 0;\\n        for(int k:answer){\\n            ans[b] = k;\\n            b = b+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static long mod = (long) 1e9 + 7;\\n    public void Powers(long n,ArrayList<Long> powers){\\n        long temp =n;\\n        long start = 0;\\n        while(temp!=0){\\n            long curr = (long)Math.pow(2,start);\\n            long next = (long)Math.pow(2,start+1);\\n            if((temp-curr)%next == 0){\\n                System.out.println(curr);\\n                powers.add(curr);\\n                temp = temp - curr;\\n            }\\n            start = start + 1;   \\n        }\\n    }\\n    public int[] productQueries(int n, int[][] queries) {\\n        ArrayList<Integer> answer = new ArrayList<>();\\n        ArrayList<Long> powers = new ArrayList<>();\\n        Powers((long)n, powers);\\n        System.out.println(powers);\\n        for(int[] arr : queries){\\n            int starti = arr[0];\\n            int endi = arr[1];\\n            long pow = 1;\\n            for(int i=starti; i<=endi; i++){\\n                pow = (pow * powers.get(i)) % mod;\\n            }\\n\\n            answer.add((int)pow);\\n        }\\n        int[] ans = new int[answer.size()];\\n        int b = 0;\\n        for(int k:answer){\\n            ans[b] = k;\\n            b = b+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616073,
                "title": "low-ltncy-php-script-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $queries\\n     * @return Integer[]\\n     */\\n    function productQueries($n, $queries) {\\n        $powers = [];\\n        for ($i = 0; $i < 32; $i++) {\\n            if ($n & (1 << $i)) {\\n                $powers[] = $i;\\n            }\\n        }\\n\\n        $answers = [];\\n        for ($i = 0; $i < count($queries); $i++) {\\n            $left = $queries[$i][0];\\n            $right = $queries[$i][1];\\n            $product = 1;\\n            for ($j = $left; $j <= $right; $j++) {\\n                $product = (int)($product * pow(2, $powers[$j])) % 1000000007;\\n            }\\n            $answers[] = $product;\\n        }\\n\\n        return $answers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $queries\\n     * @return Integer[]\\n     */\\n    function productQueries($n, $queries) {\\n        $powers = [];\\n        for ($i = 0; $i < 32; $i++) {\\n            if ($n & (1 << $i)) {\\n                $powers[] = $i;\\n            }\\n        }\\n\\n        $answers = [];\\n        for ($i = 0; $i < count($queries); $i++) {\\n            $left = $queries[$i][0];\\n            $right = $queries[$i][1];\\n            $product = 1;\\n            for ($j = $left; $j <= $right; $j++) {\\n                $product = (int)($product * pow(2, $powers[$j])) % 1000000007;\\n            }\\n            $answers[] = $product;\\n        }\\n\\n        return $answers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554064,
                "title": "c-o-logn-q",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMinimum number of sum that equals n is the set bits of n. We can compute product of all such numbers and their MOD inverses using prefix products. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse prefix products and inverse modular to compute all the products. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n) + q), with log(n) at most 32 and q being the number of queries.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const long MOD = 1e9 + 7;\\n    long long powMod(long long a, long long b){\\n        long long ans = 1;\\n        while (b){\\n            if (b & 1)  \\n                ans = (ans * a) % MOD;\\n            b >>= 1;\\n            a = (a * a) % MOD;\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<long long> nums;\\n        for (int i = 0; i < 32; i++){\\n            if ((n >> i) & 1)\\n                nums.push_back(1 << i);\\n        }\\n        int sz = nums.size();\\n        vector<long long> pref(sz + 1, 1), invPref(sz + 1, 1);\\n        for (int i = 0; i < sz; i++){\\n            pref[i + 1] = (pref[i] * nums[i]) % MOD;\\n            invPref[i + 1] = powMod(pref[i + 1], MOD - 2);\\n        }\\n        \\n        int q = queries.size();\\n        vector<int> ans(q);\\n        for (int i = 0; i < q; i++){\\n            int l = queries[i][0], r = queries[i][1];\\n            ans[i] = (pref[r + 1] * invPref[l]) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const long MOD = 1e9 + 7;\\n    long long powMod(long long a, long long b){\\n        long long ans = 1;\\n        while (b){\\n            if (b & 1)  \\n                ans = (ans * a) % MOD;\\n            b >>= 1;\\n            a = (a * a) % MOD;\\n        }\\n        return ans;\\n    }\\n\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<long long> nums;\\n        for (int i = 0; i < 32; i++){\\n            if ((n >> i) & 1)\\n                nums.push_back(1 << i);\\n        }\\n        int sz = nums.size();\\n        vector<long long> pref(sz + 1, 1), invPref(sz + 1, 1);\\n        for (int i = 0; i < sz; i++){\\n            pref[i + 1] = (pref[i] * nums[i]) % MOD;\\n            invPref[i + 1] = powMod(pref[i + 1], MOD - 2);\\n        }\\n        \\n        int q = queries.size();\\n        vector<int> ans(q);\\n        for (int i = 0; i < q; i++){\\n            int l = queries[i][0], r = queries[i][1];\\n            ans[i] = (pref[r + 1] * invPref[l]) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511284,
                "title": "c-bit-manipulation-fully-explained",
                "content": "# Approach\\nFirst we need to generate the power array.How can we do this?\\nFor this we can use the bits representation of the number.\\n**For example** n=20 can be represnted as 10100 \\n10100 => 16+ 4  so power array of 20 can be written as [4,16]\\n\\nNow after finding power array how can we find the answer for each query?\\n\\n**One thing to note here is that the size of power array will be atmost 32 as n<=1e9.**\\n\\nSo for each query we can brute-force from start to end and compute the anwer.\\n\\n\\n# Complexity\\n- Time complexity:\\nFor finding the power array O(32)\\nIf query are Q then for each query we can loop atmost 32 \\nso O(Qx32)\\nSo overall Time complexity will be O(Qx32).\\n\\n- Space complexity:\\nO(32) to store the power array .Can be treated as constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n       \\n        vector<int> pow;\\n        long long mod = 1e9+7;\\n        \\n        //if bit is set insert in the power array\\n        for(int i =0;i<32;i++)\\n        {\\n            if(n&(1<<i))\\n                pow.push_back(1<<i);\\n        }\\n        vector<int> ans;\\n        \\n        //solving for the query\\n        for(int i =0;i<q.size();i++)\\n        {\\n            long long temp=1;\\n            for(int j =q[i][0];j<=q[i][1];j++)\\n            {\\n                temp=((temp%mod)*pow[j])%mod;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n       \\n        vector<int> pow;\\n        long long mod = 1e9+7;\\n        \\n        //if bit is set insert in the power array\\n        for(int i =0;i<32;i++)\\n        {\\n            if(n&(1<<i))\\n                pow.push_back(1<<i);\\n        }\\n        vector<int> ans;\\n        \\n        //solving for the query\\n        for(int i =0;i<q.size();i++)\\n        {\\n            long long temp=1;\\n            for(int j =q[i][0];j<=q[i][1];j++)\\n            {\\n                temp=((temp%mod)*pow[j])%mod;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485742,
                "title": "easy-solution-commented-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // [1, 2, 4, 8, 16, 32, 64, 128, 256]\\n    //  0  1  2  3\\n    // [1, 2, 4, 8]\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector <int> ans ;\\n        vector <int> v ;\\n        // the above vector v for storing powers of 2 that sum to n .\\n        int x = 1 ;\\n        // used string to calculate power of 2 i.e the positions where powers have contributed to the sum of n .\\n        string s ;\\n        while(n){\\n            if(n % 2 != 0) s.push_back(\\'1\\') ;\\n            else    s.push_back(\\'0\\') ; \\n            n = n / 2 ;\\n        }\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'1\\')   v.push_back(x) ;\\n            x = x * 2 ;\\n        }\\n        sort(v.begin(), v.end()) ;\\n        for(auto i : queries){\\n            int  l1 = i[0], l2 = i[1] ;\\n            // [lefti, right,] => [l1, l2]\\n            long prod = 1 ;\\n            for(int p = l1; p <= l2; p++){\\n                prod = (prod * v[p]) % 1000000007 ;\\n            }\\n                // prod = prod % 1000000007 ;\\n            ans.push_back(prod) ;\\n        }\\n            return ans  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // [1, 2, 4, 8, 16, 32, 64, 128, 256]\\n    //  0  1  2  3\\n    // [1, 2, 4, 8]\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector <int> ans ;\\n        vector <int> v ;\\n        // the above vector v for storing powers of 2 that sum to n .\\n        int x = 1 ;\\n        // used string to calculate power of 2 i.e the positions where powers have contributed to the sum of n .\\n        string s ;\\n        while(n){\\n            if(n % 2 != 0) s.push_back(\\'1\\') ;\\n            else    s.push_back(\\'0\\') ; \\n            n = n / 2 ;\\n        }\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'1\\')   v.push_back(x) ;\\n            x = x * 2 ;\\n        }\\n        sort(v.begin(), v.end()) ;\\n        for(auto i : queries){\\n            int  l1 = i[0], l2 = i[1] ;\\n            // [lefti, right,] => [l1, l2]\\n            long prod = 1 ;\\n            for(int p = l1; p <= l2; p++){\\n                prod = (prod * v[p]) % 1000000007 ;\\n            }\\n                // prod = prod % 1000000007 ;\\n            ans.push_back(prod) ;\\n        }\\n            return ans  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447004,
                "title": "java-binary-search",
                "content": "Beats 75% of other solutions.\\n```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int num= n;\\n        ArrayList<Long> powers = new ArrayList<>();\\n        int mid = 0;\\n        while(num>0){\\n            int temp = bSearch(num, mid);\\n            long sqr = (int) Math.pow(2,temp);\\n            if( num - sqr < 0){\\n                mid++;\\n                continue;\\n            }\\n            num-= Math.pow(2,temp);\\n            powers.add(0,sqr);\\n        }\\n        long mod = (long) 1e9+7;\\n        int[] res= new int[queries.length];\\n        for(int i = 0; i< queries.length ; i++){\\n            int start = queries[i][0];\\n            int end = queries[i][1];     \\n            long mul = 1;\\n            for(int j = start; j<=end; j++){\\n                mul = mul * powers.get(j) % mod;\\n            }\\n            res[i] = (int) mul;\\n        } \\n        return res;\\n    }\\n    \\n    private int bSearch(int num, int low){\\n        int mid = low + (num - low)/2;\\n        int high = num;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            int pow = (int) Math.pow(2,mid);\\n            if( pow > num && Math.pow(2,mid-1) < num){\\n                return mid-1;\\n            }\\n            if(pow == num) return mid;\\n            else if(pow < num){\\n                low = mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        return mid;\\n    }\\n}\\n```\\n\\nMy attempt failing on some test cases.  I think above solution can be improved to O(n) like in my attempt. But I am getting some errors for some reason. Could not figure it out. Putting my attempt just for an idea.\\n```\\n\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int num= n;\\n        ArrayList<Long> powers = new ArrayList<>();\\n        int mid = 0;\\n        while(num>0){\\n            int temp = bSearch(num, mid);\\n            long sqr = (int) Math.pow(2,temp);\\n            if( num - sqr < 0){\\n                mid++;\\n                continue;\\n            }\\n            num-= Math.pow(2,temp);\\n            powers.add(0,sqr);\\n        }\\n        long mod = (long) 1e9+7;\\n        long[] totals = new long[powers.size()];\\n        totals[0] = powers.get(0);\\n        for(int i = 1; i < totals.length; i++){\\n            totals[i] = totals[i-1] * powers.get(i) % mod ;\\n        }\\n            // System.out.println(powers.get(0));\\n        \\n        // for(int i : powers) System.out.println(i);\\n        \\n        int[] res= new int[queries.length];\\n        for(int i = 0; i< queries.length ; i++){\\n            int start = queries[i][0];\\n            int end = queries[i][1];          \\n            if(start == end) res[i] = (int) (powers.get(end) %mod);\\n            else if (end>start && start!=0) res[i] =  (int) totals[end] / (int) totals[start-1];\\n            else if(start == 0) res[i] = (int) totals[end];\\n        }\\n        // for(int i : res) System.out.println(i);\\n        \\n        return res;\\n    }\\n    \\n    private int bSearch(int num, int low){\\n        int mid = low + (num - low)/2;\\n        int high = num;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            int pow = (int) Math.pow(2,mid);\\n            if( pow > num && Math.pow(2,mid-1) < num){\\n                return mid-1;\\n            }\\n            if(pow == num) return mid;\\n            else if(pow < num){\\n                low = mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        return mid;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int num= n;\\n        ArrayList<Long> powers = new ArrayList<>();\\n        int mid = 0;\\n        while(num>0){\\n            int temp = bSearch(num, mid);\\n            long sqr = (int) Math.pow(2,temp);\\n            if( num - sqr < 0){\\n                mid++;\\n                continue;\\n            }\\n            num-= Math.pow(2,temp);\\n            powers.add(0,sqr);\\n        }\\n        long mod = (long) 1e9+7;\\n        int[] res= new int[queries.length];\\n        for(int i = 0; i< queries.length ; i++){\\n            int start = queries[i][0];\\n            int end = queries[i][1];     \\n            long mul = 1;\\n            for(int j = start; j<=end; j++){\\n                mul = mul * powers.get(j) % mod;\\n            }\\n            res[i] = (int) mul;\\n        } \\n        return res;\\n    }\\n    \\n    private int bSearch(int num, int low){\\n        int mid = low + (num - low)/2;\\n        int high = num;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            int pow = (int) Math.pow(2,mid);\\n            if( pow > num && Math.pow(2,mid-1) < num){\\n                return mid-1;\\n            }\\n            if(pow == num) return mid;\\n            else if(pow < num){\\n                low = mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        return mid;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int num= n;\\n        ArrayList<Long> powers = new ArrayList<>();\\n        int mid = 0;\\n        while(num>0){\\n            int temp = bSearch(num, mid);\\n            long sqr = (int) Math.pow(2,temp);\\n            if( num - sqr < 0){\\n                mid++;\\n                continue;\\n            }\\n            num-= Math.pow(2,temp);\\n            powers.add(0,sqr);\\n        }\\n        long mod = (long) 1e9+7;\\n        long[] totals = new long[powers.size()];\\n        totals[0] = powers.get(0);\\n        for(int i = 1; i < totals.length; i++){\\n            totals[i] = totals[i-1] * powers.get(i) % mod ;\\n        }\\n            // System.out.println(powers.get(0));\\n        \\n        // for(int i : powers) System.out.println(i);\\n        \\n        int[] res= new int[queries.length];\\n        for(int i = 0; i< queries.length ; i++){\\n            int start = queries[i][0];\\n            int end = queries[i][1];          \\n            if(start == end) res[i] = (int) (powers.get(end) %mod);\\n            else if (end>start && start!=0) res[i] =  (int) totals[end] / (int) totals[start-1];\\n            else if(start == 0) res[i] = (int) totals[end];\\n        }\\n        // for(int i : res) System.out.println(i);\\n        \\n        return res;\\n    }\\n    \\n    private int bSearch(int num, int low){\\n        int mid = low + (num - low)/2;\\n        int high = num;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            int pow = (int) Math.pow(2,mid);\\n            if( pow > num && Math.pow(2,mid-1) < num){\\n                return mid-1;\\n            }\\n            if(pow == num) return mid;\\n            else if(pow < num){\\n                low = mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        return mid;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433091,
                "title": "python-beats-98-runtime-100-memory-with-explanation-complexity-analysis",
                "content": "\\n# Less efficient\\n\\nThis problem can be solved relatively trivially by doing exactly what the description asks: constructing the powers array and then multuplying the relevant powers together for each query.\\n\\nConstructing the powers array is equivalent to converting the number to a binary representation: find the largest power of 2 less than or equal to n, then save it and subtract from n, and repeat until n is reduced to zero. Because of this equivalence, `len(powers) <= log2(n)`.\\n\\nWe can then iterate over queries and iterate over `[left, right]` indices of the power array for each.\\n\\nIf there are Q queries, the time complexity is `O(Q * logN)`. With the constraints provided this is actually good enough to run within time limits, but towards the bottom end (beats ~12%).\\n\\n# More efficient\\n\\nThe key insight is that with `n <= 10^9`, it follows that `log2(n) < 30`. This means that there can only be less than `30^2 = 900` unique `[left, right]` combinations across all queries. We can just precompute them in a dictionary and look them up for each query.\\n\\n**Time complexity**: `O(Q)` where `Q` is the number of queries. Note that technically this is `O(Q + logN + (logN)^2)` but the second & third terms are negligible with the constraints given.\\n**Space complexity**: `O(logN + (logN)^2)` => `O((logN)^2)`\\n\\n# Code\\n```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        p2 = 1\\n        while p2 <= n:\\n            p2 *= 2\\n        p2 = p2 // 2\\n\\n        powers = []\\n        while n > 0:\\n            powers.append(p2)\\n            n -= p2\\n            while p2 > n:\\n                p2 = p2 // 2\\n        \\n        powers.reverse()\\n\\n        cache = {}\\n        for i in range(len(powers)):\\n            m = 1\\n            for j in range(i, len(powers)):\\n                m = (m * powers[j]) % 1_000_000_007\\n                cache[(i, j)] = m\\n\\n        ans = []\\n\\n        for l, r in queries:\\n            ans.append(cache[(l, r)])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        p2 = 1\\n        while p2 <= n:\\n            p2 *= 2\\n        p2 = p2 // 2\\n\\n        powers = []\\n        while n > 0:\\n            powers.append(p2)\\n            n -= p2\\n            while p2 > n:\\n                p2 = p2 // 2\\n        \\n        powers.reverse()\\n\\n        cache = {}\\n        for i in range(len(powers)):\\n            m = 1\\n            for j in range(i, len(powers)):\\n                m = (m * powers[j]) % 1_000_000_007\\n                cache[(i, j)] = m\\n\\n        ans = []\\n\\n        for l, r in queries:\\n            ans.append(cache[(l, r)])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421227,
                "title": "c-o-n-partial-product-and-modular-multiplicative-inverse",
                "content": "1. Bit operation to find all set 1s of n\\n2. partial product \\n3. extended gcd to find modular multiplicative inverse\\n```\\nclass Solution {\\n    constexpr static int mod = 1\\'000\\'000\\'007;\\n    int inverse(int n) { // extended gcd to find modular multiplicative inverse x: n * x = 1 % mod, iff nx + mod y = 1 for some x,y\\n        int i = 1, j = 0;// i/j: how many n\\'s in a/b: eventually x will be i\\n        for(int a = n, b = mod; a > 1;) { \\n            int prevj = j;\\n            j = i - (a/b)*j;\\n            i = prevj;\\n            a = a % b;\\n            swap(a, b);\\n        }\\n        return i;\\n    }\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<long long> powers(1,1);\\n        for(; n; n &= n-1) { // find the right most set bit\\n            powers.push_back( ((n ^ (n - 1)) + 1) / 2 );\\n        }\\n        vector<array<long long,2>> partial; // pair of partial product, and its inverse, both modular \\n        for(int prod = 1, i = 0; i < powers.size(); ++i) {\\n            prod = (prod * powers[i]) % mod;\\n            partial.push_back( { prod, inverse(prod) } );\\n        }\\n        \\n        vector<int> ans;\\n        for(auto const& q : queries) \\n            ans.push_back(((partial[q[1]+1][0] * partial[q[0]][1]) % mod + mod) % mod);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    constexpr static int mod = 1\\'000\\'000\\'007;\\n    int inverse(int n) { // extended gcd to find modular multiplicative inverse x: n * x = 1 % mod, iff nx + mod y = 1 for some x,y\\n        int i = 1, j = 0;// i/j: how many n\\'s in a/b: eventually x will be i\\n        for(int a = n, b = mod; a > 1;) { \\n            int prevj = j;\\n            j = i - (a/b)*j;\\n            i = prevj;\\n            a = a % b;\\n            swap(a, b);\\n        }\\n        return i;\\n    }\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<long long> powers(1,1);\\n        for(; n; n &= n-1) { // find the right most set bit\\n            powers.push_back( ((n ^ (n - 1)) + 1) / 2 );\\n        }\\n        vector<array<long long,2>> partial; // pair of partial product, and its inverse, both modular \\n        for(int prod = 1, i = 0; i < powers.size(); ++i) {\\n            prod = (prod * powers[i]) % mod;\\n            partial.push_back( { prod, inverse(prod) } );\\n        }\\n        \\n        vector<int> ans;\\n        for(auto const& q : queries) \\n            ans.push_back(((partial[q[1]+1][0] * partial[q[0]][1]) % mod + mod) % mod);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382777,
                "title": "range-product-queries-of-powers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def productQueries(self, n, queries):\\n        power,r=[],[]\\n        k=0\\n        #b=bin(n).replace(\"0b\",\"\")\\n        for i in bin(n).replace(\"0b\",\"\")[::-1]:\\n            if i!=\\'0\\':    \\n                power.append(2**k)      \\n            k+=1\\n        for i in queries :\\n            res=1\\n            \\n            for j in range(i[0],i[1]+1):\\n                res   *=power[j]\\n            r.append(res%((10**9)+7))\\n        return r\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def productQueries(self, n, queries):\\n        power,r=[],[]\\n        k=0\\n        #b=bin(n).replace(\"0b\",\"\")\\n        for i in bin(n).replace(\"0b\",\"\")[::-1]:\\n            if i!=\\'0\\':    \\n                power.append(2**k)      \\n            k+=1\\n        for i in queries :\\n            res=1\\n            \\n            for j in range(i[0],i[1]+1):\\n                res   *=power[j]\\n            r.append(res%((10**9)+7))\\n        return r\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342845,
                "title": "simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> power;\\n        vector<int> v;\\n        int mod = 1e9+7;\\n        int i =0;\\n        while(pow(2,i)<n){\\n            i++;\\n        }\\n        for(int j = i; j>=0; j--){\\n            n-=pow(2,j);\\n            if(n<0){\\n                n+=pow(2,j);\\n            }\\n            else{\\n                power.push_back(pow(2,j));\\n            }\\n            if(n==0){\\n                break;\\n            }\\n        }\\n        reverse(power.begin(),power.end());\\n        for(int i=0; i<queries.size(); i++){\\n            long long sum = 1;\\n            for(int j=queries[i][0]; j<=queries[i][1]; j++){\\n                sum*=(power[j]%mod);\\n                sum%=mod;\\n            }\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> power;\\n        vector<int> v;\\n        int mod = 1e9+7;\\n        int i =0;\\n        while(pow(2,i)<n){\\n            i++;\\n        }\\n        for(int j = i; j>=0; j--){\\n            n-=pow(2,j);\\n            if(n<0){\\n                n+=pow(2,j);\\n            }\\n            else{\\n                power.push_back(pow(2,j));\\n            }\\n            if(n==0){\\n                break;\\n            }\\n        }\\n        reverse(power.begin(),power.end());\\n        for(int i=0; i<queries.size(); i++){\\n            long long sum = 1;\\n            for(int j=queries[i][0]; j<=queries[i][1]; j++){\\n                sum*=(power[j]%mod);\\n                sum%=mod;\\n            }\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331726,
                "title": "c-o-n-bit-manipulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> powers;\\n        while(n > 0){\\n            int rsb = (n&(-n));\\n            powers.push_back(rsb);\\n            n -= rsb;\\n        }\\n        vector<int> ans;\\n        for(auto it : queries){\\n            int l = it[0], r = it[1];\\n            long long temp = 1;\\n            for(int i = l ; i <= r ; i++){\\n                temp = (temp*powers[i])%1000000007;\\n            }\\n            ans.push_back((int)temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> powers;\\n        while(n > 0){\\n            int rsb = (n&(-n));\\n            powers.push_back(rsb);\\n            n -= rsb;\\n        }\\n        vector<int> ans;\\n        for(auto it : queries){\\n            int l = it[0], r = it[1];\\n            long long temp = 1;\\n            for(int i = l ; i <= r ; i++){\\n                temp = (temp*powers[i])%1000000007;\\n            }\\n            ans.push_back((int)temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300034,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& que) {\\n        vector<long> arr;\\n        vector<int> ans;\\n        while(n>0)\\n        {\\n            int a=(n&(-n));\\n            arr.push_back(a);\\n            n=(n&(~a));\\n        }\\n        int mod=1000000007;\\n        for(int i=0;i<que.size();i++)\\n        {\\n            int left=que[i][0],right=que[i][1],pro=1;\\n            for(int j=left;j<=right;j++)\\n            {\\n                pro=(pro*arr[j])%mod;\\n            }\\n            ans.push_back(pro);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& que) {\\n        vector<long> arr;\\n        vector<int> ans;\\n        while(n>0)\\n        {\\n            int a=(n&(-n));\\n            arr.push_back(a);\\n            n=(n&(~a));\\n        }\\n        int mod=1000000007;\\n        for(int i=0;i<que.size();i++)\\n        {\\n            int left=que[i][0],right=que[i][1],pro=1;\\n            for(int j=left;j<=right;j++)\\n            {\\n                pro=(pro*arr[j])%mod;\\n            }\\n            ans.push_back(pro);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278732,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> productQueries(int n, vector<vector<int>>& q) {\\n    vector<int> ans, p;\\n\\t\\n    for (int i = 0; i < 32; i++)\\n        if (n & (1 << i))   p.push_back(1 << i);\\n    \\n    for (int i = 0; i < q.size(); i++)\\n    {\\n        long temp = 1;\\n        for (int j = q[i][0]; j <= q[i][1] ; j++)\\n             temp = (temp * p[j]) % 1000000007; \\n        ans.push_back(temp);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<int> productQueries(int n, vector<vector<int>>& q) {\\n    vector<int> ans, p;\\n\\t\\n    for (int i = 0; i < 32; i++)\\n        if (n & (1 << i))   p.push_back(1 << i);\\n    \\n    for (int i = 0; i < q.size(); i++)\\n    {\\n        long temp = 1;\\n        for (int j = q[i][0]; j <= q[i][1] ; j++)\\n             temp = (temp * p[j]) % 1000000007; \\n        ans.push_back(temp);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270337,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate: \\n    int M = 1e9 + 7 ;\\n    int POW(long long a, long long b){\\n        int ret ;\\n        if(b == 0)\\n            return 1 ;\\n        if(b % 2 )\\n            ret = a * POW(a, b-1) % M;\\n        else\\n            ret = POW(a*a%M, b/2) % M ;\\n        \\n        return ret % M ;\\n    }\\n    \\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int i = 0 ;\\n        int val = n ;\\n        vector<int>digit ;\\n        while(val){\\n            if(val % 2)\\n                digit.push_back(i) ;\\n            val /= 2 ;\\n            i++ ;\\n        }\\n        vector<int>preSum(digit.size() + 1) ;\\n        preSum[0] = 0 ;\\n        for(int i = 1 ; i <= digit.size() ; i++){\\n            preSum[i] = preSum[i-1] + digit[i-1] ;\\n        }\\n        vector<int>ret(queries.size()) ;\\n        for(int i = 0; i < queries.size(); i++){\\n            int a = queries[i][0] ;\\n            int b = queries[i][1] ;\\n            int total = preSum[b+1] - preSum[a] ;\\n            ret[i] = POW(2, total)% M ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    int M = 1e9 + 7 ;\\n    int POW(long long a, long long b){\\n        int ret ;\\n        if(b == 0)\\n            return 1 ;\\n        if(b % 2 )\\n            ret = a * POW(a, b-1) % M;\\n        else\\n            ret = POW(a*a%M, b/2) % M ;\\n        \\n        return ret % M ;\\n    }\\n    \\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int i = 0 ;\\n        int val = n ;\\n        vector<int>digit ;\\n        while(val){\\n            if(val % 2)\\n                digit.push_back(i) ;\\n            val /= 2 ;\\n            i++ ;\\n        }\\n        vector<int>preSum(digit.size() + 1) ;\\n        preSum[0] = 0 ;\\n        for(int i = 1 ; i <= digit.size() ; i++){\\n            preSum[i] = preSum[i-1] + digit[i-1] ;\\n        }\\n        vector<int>ret(queries.size()) ;\\n        for(int i = 0; i < queries.size(); i++){\\n            int a = queries[i][0] ;\\n            int b = queries[i][1] ;\\n            int total = preSum[b+1] - preSum[a] ;\\n            ret[i] = POW(2, total)% M ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257215,
                "title": "java-solution",
                "content": "\\n```\\npublic int[] productQueries(int n, int[][] queries)\\n    {\\n         // first I create powers array\\n        char[] arr = new StringBuilder(Integer.toString(n, 2)).\\n                reverse().toString().toCharArray();\\n\\n        List<Integer> powers = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'1\\')\\n            {\\n                powers.add((int) Math.pow(2, i));\\n            }\\n        }\\n        // now I calculate the answer for each query\\n        int[] answer = new int[queries.length];\\n        int index = 0;\\n        long mod = (long) 1e9 + 7;\\n\\n        for (int[] entry : queries)\\n        {\\n            long multiplication = 1;\\n            for (int i = entry[0]; i <= entry[1]; i++)\\n            {\\n                multiplication = (multiplication * powers.get(i)) % mod;\\n            }\\n            answer[index++] = (int) multiplication;\\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] productQueries(int n, int[][] queries)\\n    {\\n         // first I create powers array\\n        char[] arr = new StringBuilder(Integer.toString(n, 2)).\\n                reverse().toString().toCharArray();\\n\\n        List<Integer> powers = new ArrayList<>();\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'1\\')\\n            {\\n                powers.add((int) Math.pow(2, i));\\n            }\\n        }\\n        // now I calculate the answer for each query\\n        int[] answer = new int[queries.length];\\n        int index = 0;\\n        long mod = (long) 1e9 + 7;\\n\\n        for (int[] entry : queries)\\n        {\\n            long multiplication = 1;\\n            for (int i = entry[0]; i <= entry[1]; i++)\\n            {\\n                multiplication = (multiplication * powers.get(i)) % mod;\\n            }\\n            answer[index++] = (int) multiplication;\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3253966,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nNo any space taken\\n![upvote.png](https://assets.leetcode.com/users/images/034d937f-ceec-4e15-910f-d093e7071884_1677891601.8521538.png)\\n\\n# Code\\n```\\nclass Solution {\\n    private final int mod = (int) Math.pow(10,9) + 7;\\n\\n    public int[] productQueries(int n, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        List<Integer> powers = new ArrayList<>();\\n        int x = n;\\n        while (x>0) {\\n            int highestPower = (int) (Math.log(x)/Math.log(2));\\n            int pow = (int) Math.pow(2,highestPower);\\n            x = x - pow;\\n            powers.add(0,pow);\\n        }\\n        for (int j=0;j<queries.length;j++) {\\n            int start = queries[j][0];\\n            int end = queries[j][1];\\n            long r = 1;\\n            for (int i=start;i<=end;i++) {\\n                r = (r*powers.get(i))%mod;\\n            }\\n            result[j]=(int) (r%mod);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final int mod = (int) Math.pow(10,9) + 7;\\n\\n    public int[] productQueries(int n, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        List<Integer> powers = new ArrayList<>();\\n        int x = n;\\n        while (x>0) {\\n            int highestPower = (int) (Math.log(x)/Math.log(2));\\n            int pow = (int) Math.pow(2,highestPower);\\n            x = x - pow;\\n            powers.add(0,pow);\\n        }\\n        for (int j=0;j<queries.length;j++) {\\n            int start = queries[j][0];\\n            int end = queries[j][1];\\n            long r = 1;\\n            for (int i=start;i<=end;i++) {\\n                r = (r*powers.get(i))%mod;\\n            }\\n            result[j]=(int) (r%mod);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232156,
                "title": "very-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<long long int>powers;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if((n & (1<<i)) > 0)\\n            {\\n                int val = pow(2,i);\\n                powers.push_back(val);\\n            }\\n        }\\n        \\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            \\n            long long int temp = 1;\\n            for(int j=left;j<=(right);j++)\\n            {\\n                temp = (temp * powers[j])%mod;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<long long int>powers;\\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            if((n & (1<<i)) > 0)\\n            {\\n                int val = pow(2,i);\\n                powers.push_back(val);\\n            }\\n        }\\n        \\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            \\n            long long int temp = 1;\\n            for(int j=left;j<=(right);j++)\\n            {\\n                temp = (temp * powers[j])%mod;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232151,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        vector<long long>v;\\n        vector<int>ans;\\n        string s=\"\";\\n        int num=n;\\n        while(num)\\n        {\\n            if(num & 1)\\n                s.push_back(\\'1\\');\\n            else\\n                s+=\\'0\\';\\n            num>>=1; \\n        } \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long val=pow(2,i);\\n                v.push_back(val);\\n            }\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int s=q[i][0];\\n            int e=q[i][1];\\n            long long int val=1;\\n            for(int j=s;j<=e;j++)\\n            {\\n                val=val*v[j];\\n                val=val%mod;\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        vector<long long>v;\\n        vector<int>ans;\\n        string s=\"\";\\n        int num=n;\\n        while(num)\\n        {\\n            if(num & 1)\\n                s.push_back(\\'1\\');\\n            else\\n                s+=\\'0\\';\\n            num>>=1; \\n        } \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                long long val=pow(2,i);\\n                v.push_back(val);\\n            }\\n        }\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int s=q[i][0];\\n            int e=q[i][1];\\n            long long int val=1;\\n            for(int j=s;j<=e;j++)\\n            {\\n                val=val*v[j];\\n                val=val%mod;\\n            }\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214269,
                "title": "segement-tree-c-bit-manupulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long>seg;\\n    int p=1e9+7;\\n    void build(int ind,int low,int high,vector<int>&a){\\n        if(low==high){\\n            seg[ind]=a[low];\\n            return;\\n        }\\n        int mid=(low+high)>>1;\\n        build(2*ind+1,low,mid,a);\\n        build(2*ind+2,mid+1,high,a);\\n        seg[ind]=((seg[2*ind+1]%p)*(seg[2*ind+2]%p))%p;\\n    }\\n    int query(int ind,int low,int high,int l,int r){\\n        if(r<low||high<l) return 1;\\n        if(l<=low&&high<=r) return seg[ind];\\n        int mid=(low+high)>>1;\\n        long long le=query(2*ind+1,low,mid,l,r);\\n        long long ri=query(2*ind+2,mid+1,high,l,r);\\n        return ((le%p)*(ri%p))%p;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans,arr;\\n        for(int i=0;i<=31;i++){\\n            if((1<<i)&n){\\n                arr.push_back(1<<i);\\n            }\\n        }\\n        int siz=arr.size();\\n        seg.resize(4*siz+1);\\n        build(0,0,siz-1,arr);\\n        for(auto it:queries){\\n            int l=it[0];\\n            int r=it[1];\\n            ans.push_back((query(0,0,siz-1,l,r))%p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long>seg;\\n    int p=1e9+7;\\n    void build(int ind,int low,int high,vector<int>&a){\\n        if(low==high){\\n            seg[ind]=a[low];\\n            return;\\n        }\\n        int mid=(low+high)>>1;\\n        build(2*ind+1,low,mid,a);\\n        build(2*ind+2,mid+1,high,a);\\n        seg[ind]=((seg[2*ind+1]%p)*(seg[2*ind+2]%p))%p;\\n    }\\n    int query(int ind,int low,int high,int l,int r){\\n        if(r<low||high<l) return 1;\\n        if(l<=low&&high<=r) return seg[ind];\\n        int mid=(low+high)>>1;\\n        long long le=query(2*ind+1,low,mid,l,r);\\n        long long ri=query(2*ind+2,mid+1,high,l,r);\\n        return ((le%p)*(ri%p))%p;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans,arr;\\n        for(int i=0;i<=31;i++){\\n            if((1<<i)&n){\\n                arr.push_back(1<<i);\\n            }\\n        }\\n        int siz=arr.size();\\n        seg.resize(4*siz+1);\\n        build(0,0,siz-1,arr);\\n        for(auto it:queries){\\n            int l=it[0];\\n            int r=it[1];\\n            ans.push_back((query(0,0,siz-1,l,r))%p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167932,
                "title": "0ms-easy-and-just-simple-implementation",
                "content": "# Intuition\\njust prequisite is the prefix sum\\n# Approach\\njust do as the question says \\n# Complexity\\n- Time complexity:\\nO(N*2)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> PowerSum;\\n        int mod = 1e9 + 7;\\n        for(int i=0;i<31;i++){\\n            if((n & (1<<i)) > 0){\\n                int t = (1 << i);\\n                PowerSum.push_back(t);\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            long long x  = 1;\\n            for(int j = left;j <= right;j++){\\n                x = (x* 1LL * PowerSum[j])%mod;\\n            }\\n            ans.push_back((int)x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> PowerSum;\\n        int mod = 1e9 + 7;\\n        for(int i=0;i<31;i++){\\n            if((n & (1<<i)) > 0){\\n                int t = (1 << i);\\n                PowerSum.push_back(t);\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            long long x  = 1;\\n            for(int j = left;j <= right;j++){\\n                x = (x* 1LL * PowerSum[j])%mod;\\n            }\\n            ans.push_back((int)x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107064,
                "title": "c-bit-manipulation-easy",
                "content": "```\\nclass Solution\\n\\n{\\npublic:\\n    const int mod = 1e9 + 7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries)\\n    {\\n        vector<int> power_of_two;\\n        for(int i=0; i<32;i++)\\n        {\\n            if(n &(1<<i))\\n            {\\n                power_of_two.push_back(1<<i);\\n            }\\n        }\\n        \\n        int q = queries.size();\\n        vector<int> res(q, 1);\\n        for(int i=0;i<q;i++)\\n        {\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            for(int j=left;j<=right;j++)\\n            {\\n                res[i] = ((long)res[i]*(long)power_of_two[j])%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n\\n{\\npublic:\\n    const int mod = 1e9 + 7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries)\\n    {\\n        vector<int> power_of_two;\\n        for(int i=0; i<32;i++)\\n        {\\n            if(n &(1<<i))\\n            {\\n                power_of_two.push_back(1<<i);\\n            }\\n        }\\n        \\n        int q = queries.size();\\n        vector<int> res(q, 1);\\n        for(int i=0;i<q;i++)\\n        {\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            for(int j=left;j<=right;j++)\\n            {\\n                res[i] = ((long)res[i]*(long)power_of_two[j])%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088412,
                "title": "java-solution-bitwise-math-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        // \\u4E8C\\u8FDB\\u5236 + \\u6570\\u5B66 + \\u524D\\u7F00\\u548C\\uFF08DP\\uFF09\\n        int MOD = (int) 1e9 + 7;\\n        int[] powers = n2Powers(n); // powers store exponent instead of result(2^exponent), since it can better compress and easy calculate for later steps\\n        int m = powers.length;\\n        int[] prefixSum = new int[m];\\n        for (int i=0; i<m; i++) prefixSum[i] = (i > 0 ? prefixSum[i-1] : 0) + powers[i];\\n        \\n        int[] calCache = new int[prefixSum[m-1] + 1]; // calCache[i] means (2^i % (1e9 + 7)) -> use dp here for reduce duplicate calculation for performance\\n        for (int i=0; i<calCache.length; i++) calCache[i] = i > 0 ? (calCache[i-1] * 2 % MOD) : 1;\\n\\n        int[] res = new int[queries.length];\\n        for (int i=0; i<res.length; i++) {\\n            int l = queries[i][0]; int r = queries[i][1];\\n            res[i] = calCache[prefixSum[r] - (l > 0 ? prefixSum[l-1] : 0)];\\n        }\\n        return res;\\n    }\\n\\n    private int[] n2Powers(int n) {\\n        int idx = 0, exponent = 0;\\n        int[] res = new int[Integer.bitCount(n)];\\n        while (n > 0) {\\n            if ((n & 1) == 1) res[idx++] = exponent;\\n            exponent++;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        // \\u4E8C\\u8FDB\\u5236 + \\u6570\\u5B66 + \\u524D\\u7F00\\u548C\\uFF08DP\\uFF09\\n        int MOD = (int) 1e9 + 7;\\n        int[] powers = n2Powers(n); // powers store exponent instead of result(2^exponent), since it can better compress and easy calculate for later steps\\n        int m = powers.length;\\n        int[] prefixSum = new int[m];\\n        for (int i=0; i<m; i++) prefixSum[i] = (i > 0 ? prefixSum[i-1] : 0) + powers[i];\\n        \\n        int[] calCache = new int[prefixSum[m-1] + 1]; // calCache[i] means (2^i % (1e9 + 7)) -> use dp here for reduce duplicate calculation for performance\\n        for (int i=0; i<calCache.length; i++) calCache[i] = i > 0 ? (calCache[i-1] * 2 % MOD) : 1;\\n\\n        int[] res = new int[queries.length];\\n        for (int i=0; i<res.length; i++) {\\n            int l = queries[i][0]; int r = queries[i][1];\\n            res[i] = calCache[prefixSum[r] - (l > 0 ? prefixSum[l-1] : 0)];\\n        }\\n        return res;\\n    }\\n\\n    private int[] n2Powers(int n) {\\n        int idx = 0, exponent = 0;\\n        int[] res = new int[Integer.bitCount(n)];\\n        while (n > 0) {\\n            if ((n & 1) == 1) res[idx++] = exponent;\\n            exponent++;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053336,
                "title": "rust-solution",
                "content": "# Intuition\\nThe n is the int 32 number. So the max length of powers length is below 32.\\nIt\\'s enough to use brute force.\\n\\n# Code\\n```\\nconst MOD:isize = 1_000_000_007;\\nimpl Solution {\\n  pub fn product_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    let mut n = n as isize;\\n    let mut powers = vec![];\\n    let mut v = 2isize.pow(32);\\n    while 0 < n {\\n      if n < v {\\n        v /= 2;\\n      } else {\\n        powers.push(v);\\n        n -= v;\\n      }\\n    }\\n    powers.sort();\\n\\n    let m = queries.len();\\n    let mut result = vec![0;m];\\n    for i in 0..m {\\n      let from = queries[i][0] as usize;\\n      let to = queries[i][1] as usize;\\n\\n      let mut v = 1;\\n      for j in from..=to {\\n        v *= powers[j];\\n        v %= MOD;\\n      }\\n      result[i] = v;\\n    }\\n    result.into_iter().map(|v| v as i32).collect::<_>()\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MOD:isize = 1_000_000_007;\\nimpl Solution {\\n  pub fn product_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    let mut n = n as isize;\\n    let mut powers = vec![];\\n    let mut v = 2isize.pow(32);\\n    while 0 < n {\\n      if n < v {\\n        v /= 2;\\n      } else {\\n        powers.push(v);\\n        n -= v;\\n      }\\n    }\\n    powers.sort();\\n\\n    let m = queries.len();\\n    let mut result = vec![0;m];\\n    for i in 0..m {\\n      let from = queries[i][0] as usize;\\n      let to = queries[i][1] as usize;\\n\\n      let mut v = 1;\\n      for j in from..=to {\\n        v *= powers[j];\\n        v %= MOD;\\n      }\\n      result[i] = v;\\n    }\\n    result.into_iter().map(|v| v as i32).collect::<_>()\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3042286,
                "title": "o-q-log-n-bitmasking-based-solution-simply-explained-clean-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- 15 bin rep = 1111\\n- 1111 has pos val 8 4 2 1\\n- So that was in the power arr too\\n- So thats the hint\\n\\n\\n# Complexity\\n- Time complexity: O(LogN) + O(Q * P)\\n- As every time we >> right shift\\n- we do N / 2\\n- So its a Log N loop\\n- Q is at max 10^5 nos of queries \\n- P is what that inner for loop takes\\n- P at max be LogN as for 15 it was 4 [8,4,2,1] size of pow arr\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) \\n- Extra took for power\\n- But it was not input or output space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        //bin rep gives it easily \\n        // all set bits val \\n        vector<int> pow;\\n        int val = n; // always dont modify inputs\\n        int ctr = 0; //count of how many bits right shifted\\n        while(val!=0){\\n            \\n            if(val & 1 != 0){\\n                //setbit\\n                pow.push_back(1<<ctr);\\n            }\\n\\n            val = val>>1;\\n            ctr++;\\n        }\\n\\n        for(auto q : queries){\\n            int l = q[0];\\n            int r = q[1];\\n            int Currans = 1;\\n\\n            for(int i=l; i<=r; i++){\\n                Currans= ((long)Currans * pow[i]%mod)%mod;\\n            }\\n            ans.push_back(Currans);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        //bin rep gives it easily \\n        // all set bits val \\n        vector<int> pow;\\n        int val = n; // always dont modify inputs\\n        int ctr = 0; //count of how many bits right shifted\\n        while(val!=0){\\n            \\n            if(val & 1 != 0){\\n                //setbit\\n                pow.push_back(1<<ctr);\\n            }\\n\\n            val = val>>1;\\n            ctr++;\\n        }\\n\\n        for(auto q : queries){\\n            int l = q[0];\\n            int r = q[1];\\n            int Currans = 1;\\n\\n            for(int i=l; i<=r; i++){\\n                Currans= ((long)Currans * pow[i]%mod)%mod;\\n            }\\n            ans.push_back(Currans);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026895,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int base = 1;\\n        int mod = static_cast<int>(1e9+7);\\n        vector<int> powers;\\n        int i = 0;\\n        while(n!=0) {\\n            if((n&1)!=0) {\\n                powers.push_back(base);\\n            }\\n\\n            base<<=1;\\n            n>>=1;\\n        }\\n        vector<int> res;\\n        for(auto& ele: queries) {\\n            long long tmp = 1;\\n            for(int i=ele[0];i<=ele[1];i++) {\\n                tmp *= powers[i];\\n                tmp %= mod;\\n            }\\n\\n            res.push_back((int)tmp);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int base = 1;\\n        int mod = static_cast<int>(1e9+7);\\n        vector<int> powers;\\n        int i = 0;\\n        while(n!=0) {\\n            if((n&1)!=0) {\\n                powers.push_back(base);\\n            }\\n\\n            base<<=1;\\n            n>>=1;\\n        }\\n        vector<int> res;\\n        for(auto& ele: queries) {\\n            long long tmp = 1;\\n            for(int i=ele[0];i<=ele[1];i++) {\\n                tmp *= powers[i];\\n                tmp %= mod;\\n            }\\n\\n            res.push_back((int)tmp);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974832,
                "title": "easy-bit-manipulation-java-code",
                "content": "```\\n public int[] productQueries(int n, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        for(int i = 0 ; i < queries.length ; i++){\\n            ans[i]=(int)makeArray(n,queries[i][0],queries[i][1]);\\n        }\\n        return ans ; \\n    }\\n    public long makeArray(int n , int i1 , int i2){\\n        long a = 1 , count = 0 , ans = 1 , mod = 1000000007; \\n        while(n>0){\\n            if((n&1)==1 && count >=i1 && count<=i2) ans=(ans*a)%mod;\\n            if((n&1)==1) count++;\\n            a*=2;\\n            n = n>>1 ; \\n        }\\n        return ans ; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] productQueries(int n, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        for(int i = 0 ; i < queries.length ; i++){\\n            ans[i]=(int)makeArray(n,queries[i][0],queries[i][1]);\\n        }\\n        return ans ; \\n    }\\n    public long makeArray(int n , int i1 , int i2){\\n        long a = 1 , count = 0 , ans = 1 , mod = 1000000007; \\n        while(n>0){\\n            if((n&1)==1 && count >=i1 && count<=i2) ans=(ans*a)%mod;\\n            if((n&1)==1) count++;\\n            a*=2;\\n            n = n>>1 ; \\n        }\\n        return ans ; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2958521,
                "title": "java-solution-using-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] q) {\\n        int mod = 1000000007;\\n        int[] bit = new int[32];\\n        int k = 0;\\n        for(int i = 0; i <32; i++){\\n            if((n & (1<<i)) != 0){\\n                bit[k] = 1<<i;\\n                k++;\\n            }\\n        }\\n        int[] ans = new int[q.length];\\n        for(int i = 0; i < q.length; i++ ){\\n            long sum = 1;\\n            int st = q[i][0];\\n            int end = q[i][1];\\n            for(int j = st; j <= end; j++){\\n                sum = sum*bit[j]%mod;\\n                sum = (int)sum%mod;\\n            }\\n            ans[i] = (int)sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] q) {\\n        int mod = 1000000007;\\n        int[] bit = new int[32];\\n        int k = 0;\\n        for(int i = 0; i <32; i++){\\n            if((n & (1<<i)) != 0){\\n                bit[k] = 1<<i;\\n                k++;\\n            }\\n        }\\n        int[] ans = new int[q.length];\\n        for(int i = 0; i < q.length; i++ ){\\n            long sum = 1;\\n            int st = q[i][0];\\n            int end = q[i][1];\\n            for(int j = st; j <= end; j++){\\n                sum = sum*bit[j]%mod;\\n                sum = (int)sum%mod;\\n            }\\n            ans[i] = (int)sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951647,
                "title": "python3-bit-manipulation-prefix-product",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        def get_powers(n):\\n            #taking an OR of 1<<32 and 0\\n            x,res=(1<<32)|0,[]\\n            # now since we need decreasing powers, start right shifting\\n            for i in range(32,-1,-1):\\n                if n==0: break\\n                x=x>>1\\n                if x<=n:\\n                    res.append(x)\\n                    n-=x\\n            return res\\n        powers = get_powers(n)[::-1]\\n        power_prods = []\\n        # for effecient querying, store prefix prods just like prefix sums\\n        for i in range(len(powers)):\\n            if i==0: power_prods.append(powers[i])\\n            else: power_prods.append(power_prods[-1]*powers[i])\\n        \\n        res,MOD = [],10**9+7\\n        for q in queries:\\n            a,b=q[0],q[1]\\n            if a==b: res.append(powers[a]%MOD)\\n            elif a==0: res.append(power_prods[b]%MOD)\\n            else: res.append((power_prods[b]//power_prods[a-1])%MOD)\\n        return (res)\\n\\n\\n            \\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        def get_powers(n):\\n            #taking an OR of 1<<32 and 0\\n            x,res=(1<<32)|0,[]\\n            # now since we need decreasing powers, start right shifting\\n            for i in range(32,-1,-1):\\n                if n==0: break\\n                x=x>>1\\n                if x<=n:\\n                    res.append(x)\\n                    n-=x\\n            return res\\n        powers = get_powers(n)[::-1]\\n        power_prods = []\\n        # for effecient querying, store prefix prods just like prefix sums\\n        for i in range(len(powers)):\\n            if i==0: power_prods.append(powers[i])\\n            else: power_prods.append(power_prods[-1]*powers[i])\\n        \\n        res,MOD = [],10**9+7\\n        for q in queries:\\n            a,b=q[0],q[1]\\n            if a==b: res.append(powers[a]%MOD)\\n            elif a==0: res.append(power_prods[b]%MOD)\\n            else: res.append((power_prods[b]//power_prods[a-1])%MOD)\\n        return (res)\\n\\n\\n            \\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907514,
                "title": "php-solution",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $queries\\n     * @return Integer[]\\n     */\\n    function productQueries($n, $queries) {\\n        $powers = [];\\n        $ret = [];\\n        $loop = true;\\n        \\n        if($n  == 2){\\n            $ret[] = $n;\\n            return $ret;\\n        }\\n        \\n        $pow = 0;\\n        $k = 0;\\n        while($loop){\\n            $num = 2 ** $k; // 2\\u306En\\u4E57\\n            $pow += $num; //  2\\u306En\\u4E57\\u3092\\u9806\\u306B\\u8DB3\\u3057\\u3066\\u3044\\u304F\\n            $powers[] = $num;\\n            $k++;\\n            if($n <= $pow){\\n                 $loop = false; //$n\\u304C2\\u306E\\u3079\\u304D\\u4E57\\u306E\\u548C\\u4EE5\\u4E0B\\u306B\\u306A\\u3063\\u305F\\u3089Loop\\u89E3\\u9664\\n            } \\n        }    \\n        \\n        //\\u6574\\u6570n\\u3068\\u540C\\u3058\\u306B\\u306A\\u308B\\u3088\\u3046\\u306B\\u914D\\u5217\\u304B\\u3089\\u5024\\u3092\\u629C\\u304D\\u51FA\\u3059\\u3002\\n        $powers = array_reverse($powers); //\\u964D\\u9806\\u306B\\u3059\\u308B\\n        $newPowers = [$powers[0]];\\n        $newPower = $powers[0]; //\\u914D\\u5217\\u306E\\u6700\\u5927\\u5024\\u3092\\u8A2D\\u5B9A\\n        $p = 1;\\n        while($n != $newPower){\\n            if($n > $newPower){  //\\u6574\\u6570\\u4EE5\\u4E0B\\u306A\\u3089\\u6B21\\u306E\\u5024\\u3092\\u52A0\\u7B97\\n                 $newPower += $powers[$p];\\n                if($n >= $newPower){\\n                    $newPowers[] = $powers[$p];// \\u6574\\u6570\\u3092\\u8D85\\u3048\\u3066\\u306A\\u3051\\u308C\\u3070\\u5024\\u3092\\u65B0\\u914D\\u5217\\u306B\\u4FDD\\u5B58\\n                }\\n                $p++;\\n            }elseif($n < $newPower){\\n             $newPower -= $powers[$p-1]; \\n            }      \\n        }\\n        $newPowers = array_reverse($newPowers); //\\u6607\\u9806\\u306B\\u3059\\u308B\\n        \\n        \\n        //\\u30AF\\u30A8\\u30EA\\u3092\\u8A08\\u7B97\\u3059\\u308B\\n        $mod = 10**9 +7;\\n        foreach($queries as $query){\\n            if ($query[0] ==$query[1]){\\n                $ret[] =  $newPowers[$query[0]];\\n            }else{\\n                $sum = 1;\\n                for($i=$query[0];$i<=$query[1];$i++){\\n                    $sum *= $newPowers[$i];\\n                    if($sum >= $mod){\\n                        $sum = $sum % $mod;\\n                    }\\n                }\\n                $ret[] = $sum;\\n            }\\n        }\\n        return $ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer[][] $queries\\n     * @return Integer[]\\n     */\\n    function productQueries($n, $queries) {\\n        $powers = [];\\n        $ret = [];\\n        $loop = true;\\n        \\n        if($n  == 2){\\n            $ret[] = $n;\\n            return $ret;\\n        }\\n        \\n        $pow = 0;\\n        $k = 0;\\n        while($loop){\\n            $num = 2 ** $k; // 2\\u306En\\u4E57\\n            $pow += $num; //  2\\u306En\\u4E57\\u3092\\u9806\\u306B\\u8DB3\\u3057\\u3066\\u3044\\u304F\\n            $powers[] = $num;\\n            $k++;\\n            if($n <= $pow){\\n                 $loop = false; //$n\\u304C2\\u306E\\u3079\\u304D\\u4E57\\u306E\\u548C\\u4EE5\\u4E0B\\u306B\\u306A\\u3063\\u305F\\u3089Loop\\u89E3\\u9664\\n            } \\n        }    \\n        \\n        //\\u6574\\u6570n\\u3068\\u540C\\u3058\\u306B\\u306A\\u308B\\u3088\\u3046\\u306B\\u914D\\u5217\\u304B\\u3089\\u5024\\u3092\\u629C\\u304D\\u51FA\\u3059\\u3002\\n        $powers = array_reverse($powers); //\\u964D\\u9806\\u306B\\u3059\\u308B\\n        $newPowers = [$powers[0]];\\n        $newPower = $powers[0]; //\\u914D\\u5217\\u306E\\u6700\\u5927\\u5024\\u3092\\u8A2D\\u5B9A\\n        $p = 1;\\n        while($n != $newPower){\\n            if($n > $newPower){  //\\u6574\\u6570\\u4EE5\\u4E0B\\u306A\\u3089\\u6B21\\u306E\\u5024\\u3092\\u52A0\\u7B97\\n                 $newPower += $powers[$p];\\n                if($n >= $newPower){\\n                    $newPowers[] = $powers[$p];// \\u6574\\u6570\\u3092\\u8D85\\u3048\\u3066\\u306A\\u3051\\u308C\\u3070\\u5024\\u3092\\u65B0\\u914D\\u5217\\u306B\\u4FDD\\u5B58\\n                }\\n                $p++;\\n            }elseif($n < $newPower){\\n             $newPower -= $powers[$p-1]; \\n            }      \\n        }\\n        $newPowers = array_reverse($newPowers); //\\u6607\\u9806\\u306B\\u3059\\u308B\\n        \\n        \\n        //\\u30AF\\u30A8\\u30EA\\u3092\\u8A08\\u7B97\\u3059\\u308B\\n        $mod = 10**9 +7;\\n        foreach($queries as $query){\\n            if ($query[0] ==$query[1]){\\n                $ret[] =  $newPowers[$query[0]];\\n            }else{\\n                $sum = 1;\\n                for($i=$query[0];$i<=$query[1];$i++){\\n                    $sum *= $newPowers[$i];\\n                    if($sum >= $mod){\\n                        $sum = $sum % $mod;\\n                    }\\n                }\\n                $ret[] = $sum;\\n            }\\n        }\\n        return $ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902696,
                "title": "c-straightforward",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ps;\\n        {\\n            int p = 1;\\n            while (n > 0) { // O(32)\\n                if (n & 1) {\\n                    ps.push_back(p);\\n                }\\n                n >>= 1;\\n                p <<= 1;\\n            }\\n        }\\n        constexpr int Base = 1\\'000\\'000\\'007;\\n        vector<int> res(queries.size());\\n        for (int i = 0; i < queries.size(); ++i) {\\n            int left = queries[i][0], right = queries[i][1];\\n            int64_t prod = 1;\\n            for (int j = left; j <= right; ++j) {\\n                prod = (prod * ps[j]) % Base;\\n            }\\n            res[i] = prod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ps;\\n        {\\n            int p = 1;\\n            while (n > 0) { // O(32)\\n                if (n & 1) {\\n                    ps.push_back(p);\\n                }\\n                n >>= 1;\\n                p <<= 1;\\n            }\\n        }\\n        constexpr int Base = 1\\'000\\'000\\'007;\\n        vector<int> res(queries.size());\\n        for (int i = 0; i < queries.size(); ++i) {\\n            int left = queries[i][0], right = queries[i][1];\\n            int64_t prod = 1;\\n            for (int j = left; j <= right; ++j) {\\n                prod = (prod * ps[j]) % Base;\\n            }\\n            res[i] = prod;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829007,
                "title": "golang-brute-force",
                "content": "```\\nfunc productQueries(n int, queries [][]int) []int {\\n    powers := getPowers(n)\\n    mod := 1000000007\\n    out := make([]int, len(queries))\\n    for i, query := range queries {\\n        if query[0] == query[1] {\\n            out[i] = powers[query[0]]\\n            out[i] %= mod\\n        } else {\\n            out[i] = 1\\n            for j := query[0]; j < query[1]+1; j++ {\\n                out[i] *= powers[j]\\n                out[i] %= mod\\n            }\\n        }\\n\\n    }\\n    \\n    return out\\n}\\n\\nfunc getPowers(n int) []int {\\n    powers := make([]int, 0)\\n    num := float64(n)\\n    for num > 0 {\\n        v := math.Floor(math.Log2(num))\\n        num -= math.Pow(2, v)\\n        powers = append(powers, int(math.Pow(2, v)))\\n    }\\n    \\n    for i := 0; i < len(powers)/2; i++ {\\n        powers[i], powers[len(powers)-1-i] = powers[len(powers)-1-i], powers[i]\\n    }\\n    \\n    return powers\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc productQueries(n int, queries [][]int) []int {\\n    powers := getPowers(n)\\n    mod := 1000000007\\n    out := make([]int, len(queries))\\n    for i, query := range queries {\\n        if query[0] == query[1] {\\n            out[i] = powers[query[0]]\\n            out[i] %= mod\\n        } else {\\n            out[i] = 1\\n            for j := query[0]; j < query[1]+1; j++ {\\n                out[i] *= powers[j]\\n                out[i] %= mod\\n            }\\n        }\\n\\n    }\\n    \\n    return out\\n}\\n\\nfunc getPowers(n int) []int {\\n    powers := make([]int, 0)\\n    num := float64(n)\\n    for num > 0 {\\n        v := math.Floor(math.Log2(num))\\n        num -= math.Pow(2, v)\\n        powers = append(powers, int(math.Pow(2, v)))\\n    }\\n    \\n    for i := 0; i < len(powers)/2; i++ {\\n        powers[i], powers[len(powers)-1-i] = powers[len(powers)-1-i], powers[i]\\n    }\\n    \\n    return powers\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2815566,
                "title": "queries-of-powers-typescript",
                "content": "Runtime: 398 ms, faster than 76.92% of TypeScript online\\nMemory Usage: 79.4 MB, less than 100.00% of TypeScript online\\n\\nfunction productQueries(n:number, queries:number[][]):number[]{\\n       let mod = 1000000007;\\n       let binaryNumber = n.toString(2);\\n       let power:number[]=[];\\n       for(let i=binaryNumber.length-1; i>=0; i--){\\n             if(binaryNumber[i]===\"1\"){\\n               power.push(Math.pow(2, (binaryNumber.length-1-i)))\\n             }\\n       }\\n      const results:number[]=[];\\n      for(let innerAray of queries.entries()){\\n           let value:number=1;\\n           let startPoint:number=innerAray[1][0];\\n           let endPoint:number=innerAray[1][1];\\n           while(startPoint<=endPoint){\\n               value = (value*power[startPoint])%mod;\\n               startPoint++;\\n           }\\n            results.push(value);\\n      } \\n      return results;\\n }",
                "solutionTags": [],
                "code": "Runtime: 398 ms, faster than 76.92% of TypeScript online\\nMemory Usage: 79.4 MB, less than 100.00% of TypeScript online\\n\\nfunction productQueries(n:number, queries:number[][]):number[]{\\n       let mod = 1000000007;\\n       let binaryNumber = n.toString(2);\\n       let power:number[]=[];\\n       for(let i=binaryNumber.length-1; i>=0; i--){\\n             if(binaryNumber[i]===\"1\"){\\n               power.push(Math.pow(2, (binaryNumber.length-1-i)))\\n             }\\n       }\\n      const results:number[]=[];\\n      for(let innerAray of queries.entries()){\\n           let value:number=1;\\n           let startPoint:number=innerAray[1][0];\\n           let endPoint:number=innerAray[1][1];\\n           while(startPoint<=endPoint){\\n               value = (value*power[startPoint])%mod;\\n               startPoint++;\\n           }\\n            results.push(value);\\n      } \\n      return results;\\n }",
                "codeTag": "Unknown"
            },
            {
                "id": 2805648,
                "title": "very-easy-solution-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final int mod = (int) Math.pow(10,9) + 7;\\n    public int[] productQueries(int n, int[][] queries) {\\n        \\n        int[] ans = new int[queries.length];\\n        int k=0;\\n        \\n        List<Integer> l = new ArrayList<>();\\n        \\n        int x = n;\\n        \\n        while(x>0)\\n        {\\n            int hp = (int) (Math.log(x)/Math.log(2));\\n            int temp = (int) Math.pow(2,hp);\\n            x = x - temp;\\n            l.add(0,temp);\\n        }\\n        \\n        for(int i=0; i<queries.length; i++)\\n        {\\n            int s = queries[i][0];\\n            int e = queries[i][1];\\n            long tempans = 1;\\n            \\n            for(int j=s; j<=e; j++)\\n            {\\n                tempans =  (tempans*l.get(j)) % mod; \\n            }\\n            ans[k++] = (int) ( tempans % mod);\\n        }\\n            \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final int mod = (int) Math.pow(10,9) + 7;\\n    public int[] productQueries(int n, int[][] queries) {\\n        \\n        int[] ans = new int[queries.length];\\n        int k=0;\\n        \\n        List<Integer> l = new ArrayList<>();\\n        \\n        int x = n;\\n        \\n        while(x>0)\\n        {\\n            int hp = (int) (Math.log(x)/Math.log(2));\\n            int temp = (int) Math.pow(2,hp);\\n            x = x - temp;\\n            l.add(0,temp);\\n        }\\n        \\n        for(int i=0; i<queries.length; i++)\\n        {\\n            int s = queries[i][0];\\n            int e = queries[i][1];\\n            long tempans = 1;\\n            \\n            for(int j=s; j<=e; j++)\\n            {\\n                tempans =  (tempans*l.get(j)) % mod; \\n            }\\n            ans[k++] = (int) ( tempans % mod);\\n        }\\n            \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795119,
                "title": "short-python-code",
                "content": "```\\n\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        self.mod = 10**9 + 7\\n        \\n        nums = [i for i in range(n.bit_length()) if (n & (1<<i)) !=0 ]\\n\\n        accu = list(accumulate(nums))\\n\\n        return [(1 << (accu[b] - (accu[a-1] if (a-1)>=0 else 0 ))) % self.mod for a, b in queries]\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        self.mod = 10**9 + 7\\n        \\n        nums = [i for i in range(n.bit_length()) if (n & (1<<i)) !=0 ]\\n\\n        accu = list(accumulate(nums))\\n\\n        return [(1 << (accu[b] - (accu[a-1] if (a-1)>=0 else 0 ))) % self.mod for a, b in queries]\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784166,
                "title": "python-beats-97-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = (10**9)+7\\n        powers, res = [], []\\n        \\n        binary_list = [int(i) for i in bin(n)[2:]] # convert n to binary\\n        \\n        for i, n in enumerate(binary_list[::-1]): # create powers list\\n            if n: \\n                powers.append(pow(2, i))\\n                \\n        for i in range(1, len(powers)): # prefix product\\n            powers[i] = powers[i] * powers[i-1]   \\n            \\n        for l, r in queries:\\n            if l == 0: \\n                res.append(powers[r] % MOD)\\n            else: \\n                res.append((powers[r] // powers[l-1]) % MOD)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = (10**9)+7\\n        powers, res = [], []\\n        \\n        binary_list = [int(i) for i in bin(n)[2:]] # convert n to binary\\n        \\n        for i, n in enumerate(binary_list[::-1]): # create powers list\\n            if n: \\n                powers.append(pow(2, i))\\n                \\n        for i in range(1, len(powers)): # prefix product\\n            powers[i] = powers[i] * powers[i-1]   \\n            \\n        for l, r in queries:\\n            if l == 0: \\n                res.append(powers[r] % MOD)\\n            else: \\n                res.append((powers[r] // powers[l-1]) % MOD)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778367,
                "title": "python-prefix-product-solution",
                "content": "# Intuition\\nFind the binary representation of the integer, then figure out the powers.\\nLeverage the prefix product technique to circumvent the duplicated multiplication inside the queries.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def productQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        binary_rep = bin(n)[2:]\\n        n = len(binary_rep) - 1\\n        powers = []\\n        for i in range(len(binary_rep)):\\n            if int(binary_rep[i]) == 1:\\n                powers.append(int(binary_rep[i])*2**(n-i))\\n        \\n        powers = powers[::-1]\\n        prefix_product = [0 for _ in range(len(powers))]\\n        prefix_product[0] = powers[0]\\n        for i in range(1, len(prefix_product)):\\n            prefix_product[i] = prefix_product[i-1] * powers[i]\\n        ans = []\\n        for query in queries:\\n            if query[1] != query[0]:\\n                if query[0] == 0:\\n                   new_ans = prefix_product[query[1]] % (10**9 + 7)\\n                   ans.append(new_ans)\\n                else:\\n                    new_ans = (prefix_product[query[1]] / prefix_product[query[0]-1]) %(10**9 + 7)\\n                    ans.append(new_ans)\\n            else:\\n                new_ans = powers[query[1]] % (10**9 + 7)\\n                ans.append(new_ans)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def productQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        binary_rep = bin(n)[2:]\\n        n = len(binary_rep) - 1\\n        powers = []\\n        for i in range(len(binary_rep)):\\n            if int(binary_rep[i]) == 1:\\n                powers.append(int(binary_rep[i])*2**(n-i))\\n        \\n        powers = powers[::-1]\\n        prefix_product = [0 for _ in range(len(powers))]\\n        prefix_product[0] = powers[0]\\n        for i in range(1, len(prefix_product)):\\n            prefix_product[i] = prefix_product[i-1] * powers[i]\\n        ans = []\\n        for query in queries:\\n            if query[1] != query[0]:\\n                if query[0] == 0:\\n                   new_ans = prefix_product[query[1]] % (10**9 + 7)\\n                   ans.append(new_ans)\\n                else:\\n                    new_ans = (prefix_product[query[1]] / prefix_product[query[0]-1]) %(10**9 + 7)\\n                    ans.append(new_ans)\\n            else:\\n                new_ans = powers[query[1]] % (10**9 + 7)\\n                ans.append(new_ans)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777283,
                "title": "complete-exlanation-points-to-remember-linear-tc",
                "content": "# Intuition\\nWe have to think How to calculate powers array.\\nSo as it is mention we have to find out minimum number of 2\\'s powers present in $$n$$ which is equal to all the set bits in binary representation of $$n$$ \\nSo we have to find out all the set bits position and they are the power we need in our powers array\\n\\nOnce we have powers array after that question is simply find suffix sum of any range\\n\\n# Approach\\nCalculate Powers array\\nStore power in Powers not 2 ^ power (helps in maintaining edge cases)\\nCalculate suffix sum of Powers\\nThen process the queries to find out how many power of 2 we needed and add it to ans array\\n\\n# Points To Remember\\n- Keep check on the overflow edge cases\\n- Store power in Powers not 2 ^ power (helps in maintaining edge cases)\\n- Make custom Power function so that u take mod at every instance and it will not overflow\\n- start and end of Queries is inclusive\\n\\n# Complexity\\n- Time complexity:\\n    n == size of powers, m == size of queries\\n    maxPower == Maximum 2\\'s power in powers which is mostly constant\\n    To create powers array --> $$O(n)$$ \\n    To create powers suffix array --> $$O(n)$$ \\n    To calculate twoPower --> $$O(maxPower)$$ \\n    To process queries array (To transverse and in each transversal we are calling twoPower function) --> $$O(m * maxPower)$$ \\n\\n    Total TC --> $$O(2n)$$ + $$O(m * maxPower)$$ --> $$O(max(n,m * maxPower))$$ \\n\\n- Space complexity:\\n    To create powers array --> $$O(n)$$ \\n    To create ans array --> $$O(m)$$     \\n\\n    Total SC --> $$O(m+n)$$  \\n\\n# Code\\n```\\nclass Solution\\n{\\n    //mod variable\\n    int m = (1e9) + 7;\\n\\n    \\n    // Computing power of two\\n    // Created Custom function as inbuilt function may be out of int range\\n    int twoPower(int power){\\n        long long curr = 1;\\n\\n        while(power > 0){\\n            curr *= 2;\\n            curr %= m;\\n            power--;\\n        }\\n\\n        return curr;\\n    }\\n    public:\\n        vector<int> productQueries(int n, vector<vector < int>> &queries)\\n        {\\n            vector<long long> powers;\\n            int cnt = 0;\\n\\n            // Loop to calculate powers array \\n            // Storing power instead of 2^power.\\n            while(n > 0){\\n\\n                // n&1 gives whether the last bit of n is 1 or not\\n                // If its one that means that particular power of two is present in powers array\\n                // Storing cnt to measure the number of bits\\n                if(n & 1){\\n                    powers.push_back(cnt);\\n                } \\n\\n                // n>>1 == n/2 (It is Left Shift Operator)\\n                n = n>>1;\\n                cnt++;\\n            }\\n\\n            // Loop to make powers as suffix sum array so that we are able to process query in linear time\\n            for(int i=1;i<powers.size();i++){\\n                powers[i] += powers[i-1];\\n                cout<<powers[i]<<\" \";\\n            }\\n\\n            vector<int> ans(queries.size(), 0);\\n\\n            // Loop to calculate final ans array\\n            for(int i=0;i<queries.size();i++){\\n                vector<int> query = queries[i];\\n\\n                // If starting of query is 0 thats mean we need power equal to the value that is present at the index equal to query[1] (end value)\\n                // Else we need power from query[0] to query[1] hence subtracting all the powers before query[0]\\n                if(query[0] == 0){\\n                    ans[i] = twoPower(powers[query[1]]);\\n                }else{\\n                    int curr = powers[query[1]] - powers[query[0]-1];\\n                    ans[i] = twoPower(curr);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\n    //mod variable\\n    int m = (1e9) + 7;\\n\\n    \\n    // Computing power of two\\n    // Created Custom function as inbuilt function may be out of int range\\n    int twoPower(int power){\\n        long long curr = 1;\\n\\n        while(power > 0){\\n            curr *= 2;\\n            curr %= m;\\n            power--;\\n        }\\n\\n        return curr;\\n    }\\n    public:\\n        vector<int> productQueries(int n, vector<vector < int>> &queries)\\n        {\\n            vector<long long> powers;\\n            int cnt = 0;\\n\\n            // Loop to calculate powers array \\n            // Storing power instead of 2^power.\\n            while(n > 0){\\n\\n                // n&1 gives whether the last bit of n is 1 or not\\n                // If its one that means that particular power of two is present in powers array\\n                // Storing cnt to measure the number of bits\\n                if(n & 1){\\n                    powers.push_back(cnt);\\n                } \\n\\n                // n>>1 == n/2 (It is Left Shift Operator)\\n                n = n>>1;\\n                cnt++;\\n            }\\n\\n            // Loop to make powers as suffix sum array so that we are able to process query in linear time\\n            for(int i=1;i<powers.size();i++){\\n                powers[i] += powers[i-1];\\n                cout<<powers[i]<<\" \";\\n            }\\n\\n            vector<int> ans(queries.size(), 0);\\n\\n            // Loop to calculate final ans array\\n            for(int i=0;i<queries.size();i++){\\n                vector<int> query = queries[i];\\n\\n                // If starting of query is 0 thats mean we need power equal to the value that is present at the index equal to query[1] (end value)\\n                // Else we need power from query[0] to query[1] hence subtracting all the powers before query[0]\\n                if(query[0] == 0){\\n                    ans[i] = twoPower(powers[query[1]]);\\n                }else{\\n                    int curr = powers[query[1]] - powers[query[0]-1];\\n                    ans[i] = twoPower(curr);\\n                }\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2763109,
                "title": "my-solutions",
                "content": "**1. Use the brute force**\\n```\\n/**\\n * Time Complexity: O(log(n) + sum_queries)\\n * Space Complexity: O(log(n))\\n * where `sum_queries` is the sum of `(queries[i][1] - queries[i][0])`\\n *                        where i is in the range [0, `queries.size()`)\\n */\\nclass Solution {\\n public:\\n  vector<int> productQueries(const int n, const vector<vector<int>> &queries) {\\n    vector<int> powers;\\n    int power = 1;\\n    for (int number = n; number > 0; ) {\\n      if ((number & 0b1) == 0b1) {\\n        powers.emplace_back(power);\\n      }\\n      number >>= 1;\\n      power <<= 1;\\n    }\\n    \\n    constexpr int mod = 1000000007;\\n    vector<int> ret(queries.size(), 1);\\n    for (size_t i = 0; i < queries.size(); ++i) {\\n      const int start = queries[i][0];\\n      const int end = queries[i][1] + 1;\\n      for (int j = start; j < end; ++j) {\\n        ret[i] = static_cast<int>((static_cast<long long>(ret[i]) * powers[j]) % mod);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the inv**\\n```\\n/**\\n * Time Complexity: O(log(n) + n_queries)\\n * Space Complexity: O(log(n))\\n * where `n_queries` is the number of the vector `queries`\\n */\\nclass Solution {\\n private:\\n  static constexpr int mod = 1000000007;\\n\\n public:\\n  vector<int> productQueries(const int n, const vector<vector<int>> &queries) {\\n    vector<int> powers({1});\\n    int power = 1;\\n    for (int number = n; number > 0; ) {\\n      if ((number & 0b1) == 0b1) {\\n        powers.emplace_back(static_cast<int>(static_cast<long long>(powers.back()) * power % mod));\\n      }\\n      number >>= 1;\\n      power <<= 1;\\n    }\\n\\n    int invs[powers.size()];\\n    for (size_t i = 0; i < powers.size(); ++i) {\\n      invs[i] = inv(powers[i]);\\n    }\\n    \\n    vector<int> ret(queries.size(), 1);\\n    for (size_t i = 0; i < queries.size(); ++i) {\\n      const int start = queries[i][0];\\n      const int end = queries[i][1] + 1;\\n      ret[i] = static_cast<int>(static_cast<long long>(powers[end]) * invs[start] % mod);\\n    }\\n    return ret;\\n  }\\n\\n private:\\n  int inv(const int n) {\\n    int ret = 1;\\n    for (int base = n, power = mod - 2; power > 0; power >>= 1) {\\n      if ((power & 0b1) == 0b1) {\\n        ret = static_cast<int>(static_cast<long long>(ret) * base % mod);\\n      }\\n      base = static_cast<int>(static_cast<long long>(base) * base % mod);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(log(n) + sum_queries)\\n * Space Complexity: O(log(n))\\n * where `sum_queries` is the sum of `(queries[i][1] - queries[i][0])`\\n *                        where i is in the range [0, `queries.size()`)\\n */\\nclass Solution {\\n public:\\n  vector<int> productQueries(const int n, const vector<vector<int>> &queries) {\\n    vector<int> powers;\\n    int power = 1;\\n    for (int number = n; number > 0; ) {\\n      if ((number & 0b1) == 0b1) {\\n        powers.emplace_back(power);\\n      }\\n      number >>= 1;\\n      power <<= 1;\\n    }\\n    \\n    constexpr int mod = 1000000007;\\n    vector<int> ret(queries.size(), 1);\\n    for (size_t i = 0; i < queries.size(); ++i) {\\n      const int start = queries[i][0];\\n      const int end = queries[i][1] + 1;\\n      for (int j = start; j < end; ++j) {\\n        ret[i] = static_cast<int>((static_cast<long long>(ret[i]) * powers[j]) % mod);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(log(n) + n_queries)\\n * Space Complexity: O(log(n))\\n * where `n_queries` is the number of the vector `queries`\\n */\\nclass Solution {\\n private:\\n  static constexpr int mod = 1000000007;\\n\\n public:\\n  vector<int> productQueries(const int n, const vector<vector<int>> &queries) {\\n    vector<int> powers({1});\\n    int power = 1;\\n    for (int number = n; number > 0; ) {\\n      if ((number & 0b1) == 0b1) {\\n        powers.emplace_back(static_cast<int>(static_cast<long long>(powers.back()) * power % mod));\\n      }\\n      number >>= 1;\\n      power <<= 1;\\n    }\\n\\n    int invs[powers.size()];\\n    for (size_t i = 0; i < powers.size(); ++i) {\\n      invs[i] = inv(powers[i]);\\n    }\\n    \\n    vector<int> ret(queries.size(), 1);\\n    for (size_t i = 0; i < queries.size(); ++i) {\\n      const int start = queries[i][0];\\n      const int end = queries[i][1] + 1;\\n      ret[i] = static_cast<int>(static_cast<long long>(powers[end]) * invs[start] % mod);\\n    }\\n    return ret;\\n  }\\n\\n private:\\n  int inv(const int n) {\\n    int ret = 1;\\n    for (int base = n, power = mod - 2; power > 0; power >>= 1) {\\n      if ((power & 0b1) == 0b1) {\\n        ret = static_cast<int>(static_cast<long long>(ret) * base % mod);\\n      }\\n      base = static_cast<int>(static_cast<long long>(base) * base % mod);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760722,
                "title": "python3-prefix-sum-simple",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        mod = 10**9+7\\n        arr = [1]\\n        cur = 0\\n        while n:\\n            if n&1: arr.append(2**cur * arr[-1])\\n            cur += 1\\n            n >>= 1\\n        res = []\\n        for i,j in queries:\\n            res.append(arr[j+1]//arr[i]%mod)\\n        return res \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        mod = 10**9+7\\n        arr = [1]\\n        cur = 0\\n        while n:\\n            if n&1: arr.append(2**cur * arr[-1])\\n            cur += 1\\n            n >>= 1\\n        res = []\\n        for i,j in queries:\\n            res.append(arr[j+1]//arr[i]%mod)\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747221,
                "title": "scala-bit-ops-to-get-powers",
                "content": "```scala\\nval modulo = 1000000007\\n\\ndef productQueries(n: Int, queries: Array[Array[Int]]): Array[Int] = {\\n  val powers = getPowers(1, n).toArray\\n  queries.collect { case Array(l, r) =>\\n    l.to(r).map(powers).foldLeft(1L)((mult, el) => (mult * el) % modulo).toInt\\n  } \\n}\\n\\ndef getPowers(mask: Int, n: Int): List[Int] = {\\n  val bit = mask & n\\n  if (mask >= modulo) List.empty\\n  else if (bit > 0) bit :: getPowers(mask << 1, n)\\n  else getPowers(mask << 1, n)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nval modulo = 1000000007\\n\\ndef productQueries(n: Int, queries: Array[Array[Int]]): Array[Int] = {\\n  val powers = getPowers(1, n).toArray\\n  queries.collect { case Array(l, r) =>\\n    l.to(r).map(powers).foldLeft(1L)((mult, el) => (mult * el) % modulo).toInt\\n  } \\n}\\n\\ndef getPowers(mask: Int, n: Int): List[Int] = {\\n  val bit = mask & n\\n  if (mask >= modulo) List.empty\\n  else if (bit > 0) bit :: getPowers(mask << 1, n)\\n  else getPowers(mask << 1, n)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2744513,
                "title": "rust-shift-bit-o-n",
                "content": "top down shift bit, from 31 to 0.\\n```\\nimpl Solution {\\n    pub fn product_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut powers = vec![];\\n        let mut v = n;\\n        let MOD = 1000000007;\\n        \\n        for i in (0..31).rev() {\\n            if (v>>i) & 1 == 1 {\\n                let hi = 1<<i;\\n                powers.push(hi);\\n                v -= hi;\\n            }\\n        }\\n        powers.reverse();\\n        // println!(\"powers {powers:?}\");\\n        let mut res = vec![];\\n        \\n        for range in queries {\\n            let (s, e) = (range[0], range[1]);\\n            let mut prd: i64 = 1;\\n            for i in s..(e+1) {\\n                prd *= powers[i as usize] as i64;\\n                prd %= MOD;\\n            }\\n            res.push(prd as i32);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn product_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut powers = vec![];\\n        let mut v = n;\\n        let MOD = 1000000007;\\n        \\n        for i in (0..31).rev() {\\n            if (v>>i) & 1 == 1 {\\n                let hi = 1<<i;\\n                powers.push(hi);\\n                v -= hi;\\n            }\\n        }\\n        powers.reverse();\\n        // println!(\"powers {powers:?}\");\\n        let mut res = vec![];\\n        \\n        for range in queries {\\n            let (s, e) = (range[0], range[1]);\\n            let mut prd: i64 = 1;\\n            for i in s..(e+1) {\\n                prd *= powers[i as usize] as i64;\\n                prd %= MOD;\\n            }\\n            res.push(prd as i32);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743946,
                "title": "ez-c-solution-beginner-friendly-528ms-faster-than-85",
                "content": "1. Find the binary representation of the number.\\n2. While finding the binary representation, only the one which gives remainder 1 will contribute to our answer.\\n3. Number with 0 will only increment the counter but will not contribute.\\n4. In the end just multiply the given queries.\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>power;int k=0;\\n        while(n>0){\\n            if(n%2)\\n                power.push_back((n%2)*pow(2,k++));\\n            else\\n                k++;\\n            n/=2;\\n        }\\n        vector<int>ans;\\n        int mod=1e9+7;\\n        for(auto i:queries){\\n            long tmp=1;\\n            for(int j=i[0];j<=i[1];j++)\\n                tmp=((tmp%mod)*(power[j]%mod))%mod;            \\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>power;int k=0;\\n        while(n>0){\\n            if(n%2)\\n                power.push_back((n%2)*pow(2,k++));\\n            else\\n                k++;\\n            n/=2;\\n        }\\n        vector<int>ans;\\n        int mod=1e9+7;\\n        for(auto i:queries){\\n            long tmp=1;\\n            for(int j=i[0];j<=i[1];j++)\\n                tmp=((tmp%mod)*(power[j]%mod))%mod;            \\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737321,
                "title": "prefix-product-constant-time-for-each-query",
                "content": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long inv(long a) {\\n        if (a == 1) {\\n            return 1;\\n        }\\n        return mod - mod / a * inv(mod % a) % mod;\\n    }\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<long> nums = {1};\\n        for (int i = 0; i < 32; i++) {\\n            int num = 1 << i;\\n            if (n & num) {\\n                nums.push_back(nums.back() * num % mod);\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for (auto &v : queries) {\\n            int left = v[0], right = v[1] + 1;\\n            res.push_back(nums[right] * inv(nums[left]) % mod); // == nums[right] / nums[left]\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long inv(long a) {\\n        if (a == 1) {\\n            return 1;\\n        }\\n        return mod - mod / a * inv(mod % a) % mod;\\n    }\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<long> nums = {1};\\n        for (int i = 0; i < 32; i++) {\\n            int num = 1 << i;\\n            if (n & num) {\\n                nums.push_back(nums.back() * num % mod);\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for (auto &v : queries) {\\n            int left = v[0], right = v[1] + 1;\\n            res.push_back(nums[right] * inv(nums[left]) % mod); // == nums[right] / nums[left]\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735593,
                "title": "my-java-simple-approach",
                "content": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int length = queries.length;\\n        final long MOD = (long)(1e9 + 7);\\n        // convert n to binary form\\n        // take the set bit and find the corresponding 2^i\\n        // now answer for the query\\n        int [] powerTracker = new int [32];\\n        List<Long> productTakingPowers = new ArrayList<>();\\n        int [] result = new int [length];\\n        fillPowerTracker(powerTracker, n);\\n        fillProductTakingPowers(productTakingPowers, powerTracker);\\n        int index = 0;\\n        for (int [] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            long product = 1;\\n            for (int i = left; i <= right; i++) {\\n                product = (product * productTakingPowers.get(i)) % MOD;\\n            }\\n            result[index++] = (int)(product % MOD);\\n        }\\n        return result;\\n    }\\n    \\n    private void fillPowerTracker(int [] powerTracker, int n) {\\n        int index = 0;\\n        while (n > 0) {\\n            powerTracker[index++] = n & 1;\\n            n >>= 1;\\n        }     \\n    }\\n    \\n    private void fillProductTakingPowers(List<Long> productTakingPowers, int [] powerTracker) {\\n        for (int i = 0; i < 32; i++) {\\n            if (powerTracker[i] == 1) {\\n                long power = (long)(Math.pow(2, i));\\n                productTakingPowers.add(power);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int length = queries.length;\\n        final long MOD = (long)(1e9 + 7);\\n        // convert n to binary form\\n        // take the set bit and find the corresponding 2^i\\n        // now answer for the query\\n        int [] powerTracker = new int [32];\\n        List<Long> productTakingPowers = new ArrayList<>();\\n        int [] result = new int [length];\\n        fillPowerTracker(powerTracker, n);\\n        fillProductTakingPowers(productTakingPowers, powerTracker);\\n        int index = 0;\\n        for (int [] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            long product = 1;\\n            for (int i = left; i <= right; i++) {\\n                product = (product * productTakingPowers.get(i)) % MOD;\\n            }\\n            result[index++] = (int)(product % MOD);\\n        }\\n        return result;\\n    }\\n    \\n    private void fillPowerTracker(int [] powerTracker, int n) {\\n        int index = 0;\\n        while (n > 0) {\\n            powerTracker[index++] = n & 1;\\n            n >>= 1;\\n        }     \\n    }\\n    \\n    private void fillProductTakingPowers(List<Long> productTakingPowers, int [] powerTracker) {\\n        for (int i = 0; i < 32; i++) {\\n            if (powerTracker[i] == 1) {\\n                long power = (long)(Math.pow(2, i));\\n                productTakingPowers.add(power);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732132,
                "title": "c-simple-but-slow-solution",
                "content": "class Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    \\n    long long power(long long x, long long y) {\\n        if(y == 0) return 1LL;\\n        else {\\n            long long ans = power(x, y/2);\\n            ans = (ans * ans)%mod;\\n            if(y%2!=0) ans = (ans * x)%mod;\\n            return ans;\\n        }\\n    }\\n    \\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        //figure out the array\\n        vector<long long> arr;\\n        while(n) {\\n            arr.push_back(1LL * power(2, log2(n)));\\n            n -= power(2, log2(n));\\n        }\\n        reverse(arr.begin(), arr.end());\\n        \\n        //subarray product\\n        for(int i=1; i<arr.size(); i++) {\\n            arr[i] *= arr[i-1];\\n            arr[i] %= mod;\\n        }\\n        \\n        //query process and modular multiplicative inverse\\n        vector<int> ans;\\n        for(vector<int> v : queries) {\\n            long long first = arr[v[1]];\\n            long long second = v[0] == 0 ? 1 : arr[v[0]-1];\\n            long long inv = power(second, mod-2);\\n            long long result = (first * inv)%mod;\\n            ans.push_back((int)result);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    \\n    long long power(long long x, long long y) {\\n        if(y == 0) return 1LL;\\n        else {\\n            long long ans = power(x, y/2);\\n            ans = (ans * ans)%mod;\\n            if(y%2!=0) ans = (ans * x)%mod;\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2728886,
                "title": "c-clear-and-concise-solution-with-explanation-brute-force",
                "content": "We will create a helper function (```genArr```) that returns array consisting of the highest power of 2 that the number is made up of\\nExample - 14 = [8, 4, 2], 29 = [16, 8, 4, 1]\\nSo we will store the powers of 2 in an array and return it\\n14 = [3, 2, 1], 29 = [4, 3, 2, 0]\\n```\\nvector<int> genArr(int n){      \\n  vector<int> ans;\\n  while(n){\\n\\tint x = int(log2(n));\\n\\tn -= pow(2, x);\\n\\tans.push_back(x);\\n  }\\n  return ans;\\n}\\nlong long mod = 1000000007;\\nvector<int> productQueries(int n, vector<vector<int>>& queries) {\\n  vector<int> v = genArr(n), ans;\\n  sort(v.begin(), v.end());\\n  for(vector<int> &p: queries){\\n\\tint l = p[0], r = p[1];\\n\\tint temp = 1;\\n\\tfor(int i = l; i <= r; i++){\\n\\t  // Taking the products of the given range in the query\\n\\t  temp = long(temp * pow(2, v[i])) % mod;\\n\\t}\\n\\tans.push_back(temp);\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```genArr```\n```\\nvector<int> genArr(int n){      \\n  vector<int> ans;\\n  while(n){\\n\\tint x = int(log2(n));\\n\\tn -= pow(2, x);\\n\\tans.push_back(x);\\n  }\\n  return ans;\\n}\\nlong long mod = 1000000007;\\nvector<int> productQueries(int n, vector<vector<int>>& queries) {\\n  vector<int> v = genArr(n), ans;\\n  sort(v.begin(), v.end());\\n  for(vector<int> &p: queries){\\n\\tint l = p[0], r = p[1];\\n\\tint temp = 1;\\n\\tfor(int i = l; i <= r; i++){\\n\\t  // Taking the products of the given range in the query\\n\\t  temp = long(temp * pow(2, v[i])) % mod;\\n\\t}\\n\\tans.push_back(temp);\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727635,
                "title": "python-greedy-solution-easy-to-come-up-and-implement",
                "content": "1. try greedy to get a max number (target) that  2 ** target  <= n, which 2 ** target is a valid number for the minimun lenght of powers array\\n2. check the remainder (n - 2 ** target), if remainder equals 0, meaning we fould all numbers for powers array, otherwise repeat above step\\n\\n\\n\\n```\\ndef productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers = []                    \\n        for i in range(n + 1):\\n            cur = pow(2, i)         \\n            if cur == n:                                \\n                powers.append(cur)\\n                break\\n            if cur > n: \\n                j = i - 1                \\n                remainder = n\\n                while remainder > 0:                                        \\n                    target = pow(2, j)\\n                    if target > remainder: \\n                        j -= 1 if j > 0 else 0\\n                        continue\\n                    remainder -= target                    \\n                    powers = [target] + powers                   \\n                    j -= 1 if j > 0 else 0                    \\n                break                  \\n        res = []        \\n        for s, e in queries:\\n            p = 1\\n            for j in range(s, e + 1):\\n                p *= powers[j]             \\n            res.append(p % (pow(10, 9) + 7))        \\n        return res    \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers = []                    \\n        for i in range(n + 1):\\n            cur = pow(2, i)         \\n            if cur == n:                                \\n                powers.append(cur)\\n                break\\n            if cur > n: \\n                j = i - 1                \\n                remainder = n\\n                while remainder > 0:                                        \\n                    target = pow(2, j)\\n                    if target > remainder: \\n                        j -= 1 if j > 0 else 0\\n                        continue\\n                    remainder -= target                    \\n                    powers = [target] + powers                   \\n                    j -= 1 if j > 0 else 0                    \\n                break                  \\n        res = []        \\n        for s, e in queries:\\n            p = 1\\n            for j in range(s, e + 1):\\n                p *= powers[j]             \\n            res.append(p % (pow(10, 9) + 7))        \\n        return res    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2726600,
                "title": "c-easy-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& a) \\n    {\\n        vector<int> res, mp;\\n        for (int i = 0; i < 32; i++)\\n            if (n & (1 << i))mp.push_back(1<<i);\\n        for(auto i:a)\\n        {\\n            long s = 1;\\n            for (int j = i[0]; j <= i[1] ; j++)\\n                 s = (s * mp[j]) % 1000000007; \\n            res.push_back(s);\\n        }\\n        return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& a) \\n    {\\n        vector<int> res, mp;\\n        for (int i = 0; i < 32; i++)\\n            if (n & (1 << i))mp.push_back(1<<i);\\n        for(auto i:a)\\n        {\\n            long s = 1;\\n            for (int j = i[0]; j <= i[1] ; j++)\\n                 s = (s * mp[j]) % 1000000007; \\n            res.push_back(s);\\n        }\\n        return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726186,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn product_queries(mut n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut powers = Vec::new();\\n        let mut p = 0;\\n\\n        while n > 0 {\\n            if n & 1 == 1 {\\n                powers.push(p);\\n            }\\n            p += 1;\\n            n >>= 1;\\n        }\\n\\n        queries\\n            .iter()\\n            .map(|pair| {\\n                powers[pair[0] as usize..=pair[1] as usize]\\n                    .iter()\\n                    .fold(1_i64, |s, p| (s << p) % 1_000_000_007) as i32\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn product_queries(mut n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut powers = Vec::new();\\n        let mut p = 0;\\n\\n        while n > 0 {\\n            if n & 1 == 1 {\\n                powers.push(p);\\n            }\\n            p += 1;\\n            n >>= 1;\\n        }\\n\\n        queries\\n            .iter()\\n            .map(|pair| {\\n                powers[pair[0] as usize..=pair[1] as usize]\\n                    .iter()\\n                    .fold(1_i64, |s, p| (s << p) % 1_000_000_007) as i32\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2725992,
                "title": "easy-segment-tree-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long> segtree;\\n    int mod = 1e9+7;\\n    void build(int node,int l, int r, vector<int> &temp) {\\n        if(l==r) {\\n            segtree[node] = temp[l];\\n            return;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        build(2*node+1,l,mid,temp);\\n        build(2*node+2,mid+1,r,temp);\\n        \\n        segtree[node] = (segtree[2*node+1]%mod * segtree[2*node+2]%mod)%mod;\\n    }\\n    \\n    long query(int node, int l, int r, int gl, int gr) {\\n        if(l>gr || r<gl) {\\n            return 1;\\n        }\\n        if(l>=gl and r<=gr) {\\n            return segtree[node];\\n        }\\n        \\n        long mid = (l+r)/2;\\n        \\n        long left = query(2*node+1,l,mid,gl,gr)%mod;\\n        long right = query(2*node+2,mid+1,r,gl,gr)%mod;\\n        \\n        return (left*right)%mod;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> temp;\\n        for(int i=0;i<32;i++) {\\n            if((n&(1<<i))) {\\n                temp.push_back(1<<i);\\n            }\\n        }\\n        int sz = temp.size();\\n        segtree.resize(4*sz);\\n        build(0,0,sz-1,temp);\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++) {\\n            int gl = queries[i][0], gr = queries[i][1];\\n            ans.push_back(query(0,0,sz-1,gl,gr)%mod);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long> segtree;\\n    int mod = 1e9+7;\\n    void build(int node,int l, int r, vector<int> &temp) {\\n        if(l==r) {\\n            segtree[node] = temp[l];\\n            return;\\n        }\\n        \\n        int mid = (l+r)/2;\\n        build(2*node+1,l,mid,temp);\\n        build(2*node+2,mid+1,r,temp);\\n        \\n        segtree[node] = (segtree[2*node+1]%mod * segtree[2*node+2]%mod)%mod;\\n    }\\n    \\n    long query(int node, int l, int r, int gl, int gr) {\\n        if(l>gr || r<gl) {\\n            return 1;\\n        }\\n        if(l>=gl and r<=gr) {\\n            return segtree[node];\\n        }\\n        \\n        long mid = (l+r)/2;\\n        \\n        long left = query(2*node+1,l,mid,gl,gr)%mod;\\n        long right = query(2*node+2,mid+1,r,gl,gr)%mod;\\n        \\n        return (left*right)%mod;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> temp;\\n        for(int i=0;i<32;i++) {\\n            if((n&(1<<i))) {\\n                temp.push_back(1<<i);\\n            }\\n        }\\n        int sz = temp.size();\\n        segtree.resize(4*sz);\\n        build(0,0,sz-1,temp);\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++) {\\n            int gl = queries[i][0], gr = queries[i][1];\\n            ans.push_back(query(0,0,sz-1,gl,gr)%mod);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725865,
                "title": "java-solution",
                "content": "we need to calulate binary form of give N \\nN = 15\\n Binary representation(15) : [1, 1, 1, 1]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       :[8, 4, 2, 1]\\nNow once we have the array, then we just need to traverse through the range take the product of it and store in ans array\\n\\n```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] qu) {\\n    \\n        ArrayList<Integer> power = new ArrayList<>();\\n        long mod = (long)1e9 + 7;\\n        \\n        //generating square of 2 of give number in binary form\\n        \\n        for(int i = 0; i < 32; i++){\\n            if((n & (1<<i)) != 0 ){\\n                power.add(1<<i);\\n            }\\n        }\\n        \\n        System.out.println(power);\\n        \\n        int len = qu.length;\\n        int ans[] = new int[len];\\n        int pointer = 0;\\n        \\n         for (int i = 0; i < qu.length; i++) {\\n             \\n            long mul = 1;\\n            for (int j = qu[i][0]; j <= qu[i][1]; j++) { \\n                mul = (mul * power.get(j)) % mod;\\n            }\\n\\n            ans[i] = (int) mul;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] qu) {\\n    \\n        ArrayList<Integer> power = new ArrayList<>();\\n        long mod = (long)1e9 + 7;\\n        \\n        //generating square of 2 of give number in binary form\\n        \\n        for(int i = 0; i < 32; i++){\\n            if((n & (1<<i)) != 0 ){\\n                power.add(1<<i);\\n            }\\n        }\\n        \\n        System.out.println(power);\\n        \\n        int len = qu.length;\\n        int ans[] = new int[len];\\n        int pointer = 0;\\n        \\n         for (int i = 0; i < qu.length; i++) {\\n             \\n            long mul = 1;\\n            for (int j = qu[i][0]; j <= qu[i][1]; j++) { \\n                mul = (mul * power.get(j)) % mod;\\n            }\\n\\n            ans[i] = (int) mul;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725381,
                "title": "c-simple-no-multiplication-simple-addition",
                "content": "```\\nclass Solution {\\n    int MOD = 1e9+7;\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> A, ans;\\n\\t\\t// Find all set bits index - store in array\\n        for (int i=0;i<32;++i) {\\n            int d = n >> i;\\n            if (d&1) A.push_back(i);\\n        }\\n\\t\\t// ith index should give value of 2 power in multiplication upto i indices - just add all i indices\\n        for (int i=1;i<A.size();++i) {\\n            A[i] += A[i-1];\\n        }\\n\\t\\tfor each query - find 2 power value based on above array\\n        for (auto &q : queries) {\\n            int f = 0, g = 1;\\n            if (q[0] > 0) f = A[q[1]] - A[q[0] - 1];\\n            else f = A[q[1]];\\n            while (f--) {\\n                g = (g*2)%MOD;\\n            }\\n            ans.push_back(g);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1e9+7;\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> A, ans;\\n\\t\\t// Find all set bits index - store in array\\n        for (int i=0;i<32;++i) {\\n            int d = n >> i;\\n            if (d&1) A.push_back(i);\\n        }\\n\\t\\t// ith index should give value of 2 power in multiplication upto i indices - just add all i indices\\n        for (int i=1;i<A.size();++i) {\\n            A[i] += A[i-1];\\n        }\\n\\t\\tfor each query - find 2 power value based on above array\\n        for (auto &q : queries) {\\n            int f = 0, g = 1;\\n            if (q[0] > 0) f = A[q[1]] - A[q[0] - 1];\\n            else f = A[q[1]];\\n            while (f--) {\\n                g = (g*2)%MOD;\\n            }\\n            ans.push_back(g);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725227,
                "title": "java-bit-manipulation",
                "content": "```\\nclass Solution {\\n    \\n    static final int mod=1_000_000_007;\\n    \\n    public int[] productQueries(int n, int[][] q) {\\n        int len=q.length;\\n        List<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<32;i++){\\n            if((n&(1<<i))!=0){\\n                int nz=(int) Math.pow(2,i);\\n                list.add(nz);\\n            }\\n        }\\n    \\n        int p=0;\\n        int[] ans=new int[len];\\n        for(int i=0;i<len;i++){\\n            long prod=1;\\n            for(int j=q[i][0];j<=q[i][1];j++){\\n                prod=(prod*list.get(j))%mod;\\n            }\\n            ans[p++]=(int)prod%mod;\\n        }\\n        \\n        return ans;\\n    }\\n               \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static final int mod=1_000_000_007;\\n    \\n    public int[] productQueries(int n, int[][] q) {\\n        int len=q.length;\\n        List<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<32;i++){\\n            if((n&(1<<i))!=0){\\n                int nz=(int) Math.pow(2,i);\\n                list.add(nz);\\n            }\\n        }\\n    \\n        int p=0;\\n        int[] ans=new int[len];\\n        for(int i=0;i<len;i++){\\n            long prod=1;\\n            for(int j=q[i][0];j<=q[i][1];j++){\\n                prod=(prod*list.get(j))%mod;\\n            }\\n            ans[p++]=(int)prod%mod;\\n        }\\n        \\n        return ans;\\n    }\\n               \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725211,
                "title": "c-simple-solution",
                "content": "* Just get the set bits of n and start adding it in array and then you can perform given operations on queries.\\n```\\nclass Solution {\\npublic:\\n    void getNum(int n,vector<int>&temp){\\n        int si=log2(n)+1,i=0;\\n        while(i<=si){\\n            if(n&(1<<i)) temp.push_back(1<<i);\\n            i++;\\n        }\\n        return;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>temp,ans;\\n        getNum(n,temp);\\n        int mod=1e9+7;\\n        for(int i=0;i<queries.size();i++){\\n            int j=queries[i][1];\\n            long long mul=1;\\n            while(j>=queries[i][0]){\\n                mul*=temp[j--];\\n                mul%=mod;\\n            }\\n            ans.push_back(mul);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void getNum(int n,vector<int>&temp){\\n        int si=log2(n)+1,i=0;\\n        while(i<=si){\\n            if(n&(1<<i)) temp.push_back(1<<i);\\n            i++;\\n        }\\n        return;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>temp,ans;\\n        getNum(n,temp);\\n        int mod=1e9+7;\\n        for(int i=0;i<queries.size();i++){\\n            int j=queries[i][1];\\n            long long mul=1;\\n            while(j>=queries[i][0]){\\n                mul*=temp[j--];\\n                mul%=mod;\\n            }\\n            ans.push_back(mul);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725157,
                "title": "solve-it-as-a-math-problem",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar productQueries = function(n, queries) {\\n    const powers = []\\n    for (let mask = 1, i = 0; i < 32; i++, mask <<= 1) {\\n        if (n & mask)   powers.push(i)\\n    }\\n    const len = powers.length\\n    const countSF = new Array(len)\\n    countSF[-1] = 0\\n    for (const [i, power] of powers.entries())\\n        countSF[i] = power + countSF[i - 1]\\n    \\n    \\n    function getCount(left, right) {\\n        return countSF[right] - countSF[left - 1]\\n    }\\n    \\n    \\n    const modMe = 10 ** 9 + 7\\n    const table = [1]\\n    function getOutcome(k) {\\n        if (k < table.length)   return table[k]\\n        for (let i = table.length; i <= k; i++) {\\n            table[i] = (table[i - 1] * 2) % modMe\\n        }\\n        \\n        return table[k]\\n    }\\n    \\n    \\n    const result = queries.map(query => {\\n        const [left, right] = query\\n        const count = getCount(left, right)\\n        const outcome = getOutcome(count)\\n        return outcome\\n    })\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar productQueries = function(n, queries) {\\n    const powers = []\\n    for (let mask = 1, i = 0; i < 32; i++, mask <<= 1) {\\n        if (n & mask)   powers.push(i)\\n    }\\n    const len = powers.length\\n    const countSF = new Array(len)\\n    countSF[-1] = 0\\n    for (const [i, power] of powers.entries())\\n        countSF[i] = power + countSF[i - 1]\\n    \\n    \\n    function getCount(left, right) {\\n        return countSF[right] - countSF[left - 1]\\n    }\\n    \\n    \\n    const modMe = 10 ** 9 + 7\\n    const table = [1]\\n    function getOutcome(k) {\\n        if (k < table.length)   return table[k]\\n        for (let i = table.length; i <= k; i++) {\\n            table[i] = (table[i - 1] * 2) % modMe\\n        }\\n        \\n        return table[k]\\n    }\\n    \\n    \\n    const result = queries.map(query => {\\n        const [left, right] = query\\n        const count = getCount(left, right)\\n        const outcome = getOutcome(count)\\n        return outcome\\n    })\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724760,
                "title": "so-fast-faster-than-90",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, q: List[List[int]]) -> List[int]:\\n    \\n    #find powers array\\n        m = int(math.log(n , 2))\\n        po = [2**m]\\n        n -= 2**m\\n        m -= 1\\n        while n > 0:\\n            if 2**m <= n:\\n                po = [2**m] + po\\n                n -= 2**m\\n            m -= 1\\n            \\n   # prefix product\\n        for i in range(1, len(po)):\\n            po[i] *= po[i-1]\\n\\n        po = [1] + po\\n        res = []\\n        for l , r in q:\\n            res.append((po[r + 1] // po[l]) % (10**9+7) )\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, q: List[List[int]]) -> List[int]:\\n    \\n    #find powers array\\n        m = int(math.log(n , 2))\\n        po = [2**m]\\n        n -= 2**m\\n        m -= 1\\n        while n > 0:\\n            if 2**m <= n:\\n                po = [2**m] + po\\n                n -= 2**m\\n            m -= 1\\n            \\n   # prefix product\\n        for i in range(1, len(po)):\\n            po[i] *= po[i-1]\\n\\n        po = [1] + po\\n        res = []\\n        for l , r in q:\\n            res.append((po[r + 1] // po[l]) % (10**9+7) )\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723571,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer} n\\n# @param {Integer[][]} queries\\n# @return {Integer[]}\\ndef product_queries(n, queries)\\n    powers = [1]\\n    exp = 1\\n    while n > 0\\n        if n % 2 == 1\\n            powers << exp * powers[-1]\\n        end\\n        exp *= 2\\n        n = n / 2\\n    end\\n\\n    queries.map {|query| powers[query[1]+1] / powers[query[0]] % 1000000007 }\\n    \\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {Integer} n\\n# @param {Integer[][]} queries\\n# @return {Integer[]}\\ndef product_queries(n, queries)\\n    powers = [1]\\n    exp = 1\\n    while n > 0\\n        if n % 2 == 1\\n            powers << exp * powers[-1]\\n        end\\n        exp *= 2\\n        n = n / 2\\n    end\\n\\n    queries.map {|query| powers[query[1]+1] / powers[query[0]] % 1000000007 }\\n    \\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2722920,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, powers;\\n        ans.reserve(size(queries));\\n        int p = 1, mod = 1e9 + 7;\\n        while (n) {\\n            if (n&1) powers.push_back(p);\\n            p <<= 1, n >>= 1;\\n        }\\n        int m = size(powers);\\n        vector<vector<long>> dp(m+1, vector<long>(m+1, 1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = i; j < m; j++)\\n                dp[i+1][j+1] = (dp[i+1][j] * powers[j]) % mod;\\n        }\\n        for (auto& q: queries)\\n            ans.push_back(dp[q[0]+1][q[1]+1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, powers;\\n        ans.reserve(size(queries));\\n        int p = 1, mod = 1e9 + 7;\\n        while (n) {\\n            if (n&1) powers.push_back(p);\\n            p <<= 1, n >>= 1;\\n        }\\n        int m = size(powers);\\n        vector<vector<long>> dp(m+1, vector<long>(m+1, 1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = i; j < m; j++)\\n                dp[i+1][j+1] = (dp[i+1][j] * powers[j]) % mod;\\n        }\\n        for (auto& q: queries)\\n            ans.push_back(dp[q[0]+1][q[1]+1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722128,
                "title": "efficient-python-prefix-sum-and-precalculated-powers",
                "content": "First we want to find the \"powers\" array. But lets not hold the numbers themsleves, but instead their log.\\nso in the n=15 example we will eventually have *powers = [0,1,2,3]*\\nNo lets find the prefix sum array of powers in the above example it is  * prefixsums = [0, 0 + 1, 0 + 1 + 2 , 0 + 1 + 2 + 3 ] = [0, 1 ,3, 6]*\\n\\nSo now for each query [l, r] we need to find is (2 ** powers[l]) * (2 ** powers[l + 1])   *.. * (2 ** powers[r]) = 2 ** (powers[l] + powers[l + 1] +powers[r] ) = \\n2 ** (prefixsums[r] - (prefixsums[l - 1]) if l > 0 else 0)) \\nIn order to find this efficiently we will keep a caclulatedPowerArray such that caclulatedPowerArray[i] = (2 ** i ) % (10 ** 9 + 7)\\nSo each time we need to find a power of 2 that we did not fine already we will extend the caclulatedPowerArray until this power.\\n\\n```\\nclass Solution(object):\\n    \\nclass Solution(object):\\n    \\n    def productQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        powers_prefix_sum, currPower, M = [], 0 ,(10**9 + 7) \\n        for currPower in xrange(32):\\n            if (1 << currPower) & n:\\n                powers_prefix_sum.append(currPower + (powers_prefix_sum[-1] if len(powers_prefix_sum) > 0 else 0))                        \\n        calculatedPowers = [1]\\n        return [get_pow(calculatedPowers, powers_prefix_sum[query[1]] - (powers_prefix_sum[query[0] - 1] if query[0] > 0 else 0), M) for query in queries]\\n            \\n                \\ndef get_pow(calculatedPowers, neededPower, M):       \\n    for _ in xrange(neededPower - len(calculatedPowers) + 1):\\n        tmp = (calculatedPowers[-1] * 2)\\n        calculatedPowers.append(tmp if tmp < M else tmp - M)\\n    return calculatedPowers[neededPower]\\n            \\n```\\n\\nTime Complexity:\\nbuilding power array and prefixes array is log(n)\\nbuilding calculatedPowers array is log(n) ** 2 (worst case we need to use all the powers for numbers such as 2 ** N - 1, and worst case there will be some query asking the whole product, so the length of the array is 1 + 2 + 3 + .. + log(n) = O(log(n) **2),  \\neach entry we append is O(1). Bcs we multiply \"smal\" number by 2, and at worst case, substract a \"small\" number from it.\\nIterating, iterating on queries is linear. \\nSo eventually we got quadratic runtime in size of input. Bcs it is log(n) ** 2 (n is a number, so log(n) is the size of input needed to represent it.)\\nBut the Quadratic hear is just a theorietical definition, basically it is \\nO((log(n) ** 2) + len(queries))\\n\\nSpace complexity:\\nAlso quadratic bcs of the building of calculatedPowers\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \\nclass Solution(object):\\n    \\n    def productQueries(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        powers_prefix_sum, currPower, M = [], 0 ,(10**9 + 7) \\n        for currPower in xrange(32):\\n            if (1 << currPower) & n:\\n                powers_prefix_sum.append(currPower + (powers_prefix_sum[-1] if len(powers_prefix_sum) > 0 else 0))                        \\n        calculatedPowers = [1]\\n        return [get_pow(calculatedPowers, powers_prefix_sum[query[1]] - (powers_prefix_sum[query[0] - 1] if query[0] > 0 else 0), M) for query in queries]\\n            \\n                \\ndef get_pow(calculatedPowers, neededPower, M):       \\n    for _ in xrange(neededPower - len(calculatedPowers) + 1):\\n        tmp = (calculatedPowers[-1] * 2)\\n        calculatedPowers.append(tmp if tmp < M else tmp - M)\\n    return calculatedPowers[neededPower]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719927,
                "title": "can-someone-explain-this",
                "content": "Can someone explain why I can use the mod number1000000007 rather (int)(10e9 + 7) \\nit will not AC the test case when I m using 10e9 + 7\\ntest case:\\n```\\n919\\n[[5,5],[4,4],[0,1],[1,5],[4,6],[6,6],[5,6],[0,3],[5,5],[5,6],[1,2],[3,5],[3,6],[5,5],[4,4],[1,1],[2,4],[4,5],[4,4],[5,6],[0,4],[3,3],[0,4],[0,5],[4,4],[5,5],[4,6],[4,5],[0,4],[6,6],[6,6],[6,6],[2,2],[0,5],[1,4],[0,3],[2,4],[5,5],[6,6],[2,2],[2,3],[5,5],[0,6],[3,3],[6,6],[4,4],[0,0],[0,2],[6,6],[6,6],[3,6],[0,4],[6,6],[2,2],[4,6]]\\n```\\n```\\n    public int[] productQueries(int n, int[][] queries) {\\n        int mod = 1000000007 ;\\n        List<Integer> powerTwo = new ArrayList<>();\\n        List<Integer> arr = new ArrayList<>();\\n        while(n > 0) {\\n            arr.add(n % 2);\\n            n/=2;\\n        }\\n        for(int i = 0; i < arr.size(); i++) {\\n            if(arr.get(i) == 1) {\\n                powerTwo.add((int)Math.pow(2, i));\\n            }\\n        }\\n        int[] res = new int[queries.length];\\n        int idx = 0;\\n        for(int[] pair : queries) {\\n            int l = pair[0], r = pair[1];\\n            long resNum = 1;\\n            if(l == r) {\\n               resNum = powerTwo.get(l);\\n            } else {\\n                for(int i = l; i <= r; i++) {\\n                   resNum = resNum * powerTwo.get(i) % mod;\\n                }\\n            }\\n            res[idx++] = (int)resNum % mod;\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n919\\n[[5,5],[4,4],[0,1],[1,5],[4,6],[6,6],[5,6],[0,3],[5,5],[5,6],[1,2],[3,5],[3,6],[5,5],[4,4],[1,1],[2,4],[4,5],[4,4],[5,6],[0,4],[3,3],[0,4],[0,5],[4,4],[5,5],[4,6],[4,5],[0,4],[6,6],[6,6],[6,6],[2,2],[0,5],[1,4],[0,3],[2,4],[5,5],[6,6],[2,2],[2,3],[5,5],[0,6],[3,3],[6,6],[4,4],[0,0],[0,2],[6,6],[6,6],[3,6],[0,4],[6,6],[2,2],[4,6]]\\n```\n```\\n    public int[] productQueries(int n, int[][] queries) {\\n        int mod = 1000000007 ;\\n        List<Integer> powerTwo = new ArrayList<>();\\n        List<Integer> arr = new ArrayList<>();\\n        while(n > 0) {\\n            arr.add(n % 2);\\n            n/=2;\\n        }\\n        for(int i = 0; i < arr.size(); i++) {\\n            if(arr.get(i) == 1) {\\n                powerTwo.add((int)Math.pow(2, i));\\n            }\\n        }\\n        int[] res = new int[queries.length];\\n        int idx = 0;\\n        for(int[] pair : queries) {\\n            int l = pair[0], r = pair[1];\\n            long resNum = 1;\\n            if(l == r) {\\n               resNum = powerTwo.get(l);\\n            } else {\\n                for(int i = l; i <= r; i++) {\\n                   resNum = resNum * powerTwo.get(i) % mod;\\n                }\\n            }\\n            res[idx++] = (int)resNum % mod;\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2719716,
                "title": "python-simple-maths",
                "content": "\\n    def productQueries(self, n, queries):\\n        new_str1, res = bin(n)[2:], []\\n        \\n        m = len(new_str1)\\n        \\n        for i in range(m):\\n            if new_str1[i] == \"1\":\\n                res.append(2**(m-i-1))\\n                \\n        res = sorted(res)\\n                \\n        prefix_product = [1]\\n        \\n        for i in res:\\n            prefix_product.append(prefix_product[-1]*i)\\n            \\n        ans = []\\n        \\n        for i,j in queries:\\n            if i == j:\\n                ans.append(prefix_product[i+1]//prefix_product[i])\\n            else:\\n                val = (prefix_product[j+1]//prefix_product[i])%(10**9+7)\\n                ans.append(val)\\n            \\n        return ans",
                "solutionTags": [],
                "code": "\\n    def productQueries(self, n, queries):\\n        new_str1, res = bin(n)[2:], []\\n        \\n        m = len(new_str1)\\n        \\n        for i in range(m):\\n            if new_str1[i] == \"1\":\\n                res.append(2**(m-i-1))\\n                \\n        res = sorted(res)\\n                \\n        prefix_product = [1]\\n        \\n        for i in res:\\n            prefix_product.append(prefix_product[-1]*i)\\n            \\n        ans = []\\n        \\n        for i,j in queries:\\n            if i == j:\\n                ans.append(prefix_product[i+1]//prefix_product[i])\\n            else:\\n                val = (prefix_product[j+1]//prefix_product[i])%(10**9+7)\\n                ans.append(val)\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2718224,
                "title": "simple-approach",
                "content": "class Solution {\\npublic:\\n    long long int sol(int n)\\n    {\\n        long long int c=0;\\n        while(n)\\n        {\\n            n=n/2;\\n            c++;\\n        }\\n        return c;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> v,v1;\\n        long long int g=sol(n);\\n        cout<<g<<\" \";\\n        for(long long int i=g-1;i>=0;i--)\\n        {\\n            if(n>=pow(2,i))\\n            {\\n                v.push_back(pow(2,i));\\n                n=n-pow(2,i);\\n            }\\n            if(n==0) break;\\n        }\\n        reverse(v.begin(),v.end());\\n        int mod=1e9+7;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int j=queries[i][0];\\n            int k=queries[i][1];\\n            long long int ans=1;\\n            while(j<=k)\\n            {\\n                ans=(ans*v[j])%mod;\\n                j++;\\n            }\\n            v1.push_back(ans);\\n        }\\n        return v1;\\n    }\\n};\\n\\n//Md Arham Kalam Ansari",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long int sol(int n)\\n    {\\n        long long int c=0;\\n        while(n)\\n        {\\n            n=n/2;\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2715814,
                "title": "python-5-line-solution-prefix-sum-in-bitwise-level",
                "content": "```\\ndef productQueries(self, n: int, qs: List[List[int]]) -> List[int]:\\n\\tpsum, mod = [0], 10**9+7\\n\\tfor i in range(n.bit_length()):\\n\\t\\t# 2**i exists when the i-th bit is 1\\n\\t\\tif n&(1<<i):\\n\\t\\t\\tpsum.append(psum[-1]+i)\\n\\treturn [(1<<(psum[j+1]-psum[i]))%mod for i, j in qs]\\n```\\n\\nTime: \\nO(1) for construct the prefix-sum\\nO(N) for answer the query\\n",
                "solutionTags": [],
                "code": "```\\ndef productQueries(self, n: int, qs: List[List[int]]) -> List[int]:\\n\\tpsum, mod = [0], 10**9+7\\n\\tfor i in range(n.bit_length()):\\n\\t\\t# 2**i exists when the i-th bit is 1\\n\\t\\tif n&(1<<i):\\n\\t\\t\\tpsum.append(psum[-1]+i)\\n\\treturn [(1<<(psum[j+1]-psum[i]))%mod for i, j in qs]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2715724,
                "title": "easy-best-solution-in-c",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans,powers;\\n        int mod= 1e9 + 7;\\n            for(int i=0;i<32;i++){\\n                if((n & (1<<i))!=0)\\n                    powers.push_back(1<<i);\\n            }\\n            for(auto it:queries){\\n                int x=it[0],y=it[1];\\n                long  pro=1;\\n                while(x<=y)\\n                    pro=(pro*powers[x++])%mod;\\n                ans.push_back(pro);\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans,powers;\\n        int mod= 1e9 + 7;\\n            for(int i=0;i<32;i++){\\n                if((n & (1<<i))!=0)\\n                    powers.push_back(1<<i);\\n            }\\n            for(auto it:queries){\\n                int x=it[0],y=it[1];\\n                long  pro=1;\\n                while(x<=y)\\n                    pro=(pro*powers[x++])%mod;\\n                ans.push_back(pro);\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714405,
                "title": "c-simple-easy-solution-using-binary-string",
                "content": "vector```<int>``` productQueries(int n, vector<vector<int>>& queries) {\\n        string s=\"\";\\n        vector```<int> ```answer;\\n        int mod=1e9+7;\\n        vector```<int>```vec;\\n              while(n>0){\\n                  if(n%2==0){\\n                      s+=\\'0\\';\\n                  }\\n                  else {\\n                      s+=\\'1\\';\\n                  }\\n                  n/=2;\\n              }\\n           for(int i=0;i<s.size();i++){\\n               if(s[i]==\\'1\\'){\\n                   vec.push_back((1<<i));\\n               }\\n           } \\n        for(int i=0;i<queries.size();i++){\\n            int x=queries[i][0];\\n            int y=queries[i][1];\\n           long ans=1;\\n            for(int j=x;j<=y;j++){\\n                ans*=vec[j];\\n                ans%=mod;\\n            }\\n            answer.push_back(ans);\\n        }\\n        return answer;\\n    }",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```<int>```\n```<int> ```\n```<int>```",
                "codeTag": "Unknown"
            },
            {
                "id": 2713411,
                "title": "simple-and-clean-solution-using-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> seg;\\n    \\n    void build(int idx,int low,int high,vector<int> arr)\\n    {\\n        if(high==low)\\n        {\\n            seg[idx]=arr[low];\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(2*idx+1,low,mid,arr);\\n        build(2*idx+2,mid+1,high,arr);\\n        seg[idx]=(seg[2*idx+1]*1ll*seg[2*idx+2])%mod;\\n        return;\\n    }\\n    int query(int idx,int low,int high,int l,int r)\\n    {\\n        // no overlap\\n        if(l>high||r<low)return 1;\\n\\n        //complete overlap\\n        if(low>=l&&high<=r)return seg[idx];\\n        \\n        //partily overlap\\n        int mid=(low+high)/2;\\n        long long left=query(2*idx+1,low,mid,l,r);\\n        long long right=query(2*idx+2,mid+1,high,l,r);\\n        return (left*1ll*right)%mod;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> arr;\\n        int i=0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                arr.push_back((1<<i));  \\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        seg.resize(arr.size()*4+1);\\n        build(0,0,arr.size()-1,arr);\\n        \\n        vector<int> ans;\\n        for(auto q: queries)\\n        {\\n            ans.push_back(query(0,0,arr.size()-1,q[0],q[1]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> seg;\\n    \\n    void build(int idx,int low,int high,vector<int> arr)\\n    {\\n        if(high==low)\\n        {\\n            seg[idx]=arr[low];\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(2*idx+1,low,mid,arr);\\n        build(2*idx+2,mid+1,high,arr);\\n        seg[idx]=(seg[2*idx+1]*1ll*seg[2*idx+2])%mod;\\n        return;\\n    }\\n    int query(int idx,int low,int high,int l,int r)\\n    {\\n        // no overlap\\n        if(l>high||r<low)return 1;\\n\\n        //complete overlap\\n        if(low>=l&&high<=r)return seg[idx];\\n        \\n        //partily overlap\\n        int mid=(low+high)/2;\\n        long long left=query(2*idx+1,low,mid,l,r);\\n        long long right=query(2*idx+2,mid+1,high,l,r);\\n        return (left*1ll*right)%mod;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> arr;\\n        int i=0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                arr.push_back((1<<i));  \\n            }\\n            i++;\\n            n>>=1;\\n        }\\n        seg.resize(arr.size()*4+1);\\n        build(0,0,arr.size()-1,arr);\\n        \\n        vector<int> ans;\\n        for(auto q: queries)\\n        {\\n            ans.push_back(query(0,0,arr.size()-1,q[0],q[1]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713284,
                "title": "java-efficient-range-prefix-multiplication-easy-solution",
                "content": "```\\n    public int[] productQueries(int n, int[][] queries) {\\n        \\n        LinkedList<Integer> bitrep = new LinkedList();\\n    \\n        while(n>0){\\n            bitrep.add(n%2);\\n            n=n/2;\\n        }\\n        \\n        LinkedList<Double> pow = new LinkedList();\\n        \\n        double prev = 1;\\n        for(int i=0;i<bitrep.size();i++){\\n            if(bitrep.get(i) == 1)\\n            {\\n                double cur = Math.pow(2.0 , i);\\n                cur = cur * prev;\\n                pow.add( cur);\\n                prev = cur;\\n            }\\n        }\\n        \\n        int[] answer = new int[queries.length];\\n        int k=0;\\n        for(int[] q: queries){\\n            \\n            double ans = pow.get(q[1]);\\n            if(q[0]-1 >=0)\\n                ans = ans / pow.get(q[0]-1);\\n            answer[k++] = (int)(ans % 1000000007);\\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] productQueries(int n, int[][] queries) {\\n        \\n        LinkedList<Integer> bitrep = new LinkedList();\\n    \\n        while(n>0){\\n            bitrep.add(n%2);\\n            n=n/2;\\n        }\\n        \\n        LinkedList<Double> pow = new LinkedList();\\n        \\n        double prev = 1;\\n        for(int i=0;i<bitrep.size();i++){\\n            if(bitrep.get(i) == 1)\\n            {\\n                double cur = Math.pow(2.0 , i);\\n                cur = cur * prev;\\n                pow.add( cur);\\n                prev = cur;\\n            }\\n        }\\n        \\n        int[] answer = new int[queries.length];\\n        int k=0;\\n        for(int[] q: queries){\\n            \\n            double ans = pow.get(q[1]);\\n            if(q[0]-1 >=0)\\n                ans = ans / pow.get(q[0]-1);\\n            answer[k++] = (int)(ans % 1000000007);\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2713171,
                "title": "simple-cpp-solution",
                "content": "Approach :-\\nIf you represent any number in bits. Then every index of one bit is going to be power of 2 that is summing up to n.\\n\\n5 = 101\\nso here power of 2 are  [0,2]  making the sum upto 5\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n       vector<int> power;\\n        \\n        for(int i=0;i<32;i++){\\n            if((n&(1<<i))!=0){\\n                power.push_back(i);\\n            }\\n        }\\n       for(auto x : queries){\\n           long pow = 1;\\n           for(int i=x[0];i<=x[1];i++){\\n               pow*=1<<power[i];\\n               pow%=1000000007;\\n           }\\n           ans.push_back(pow);\\n       } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n       vector<int> power;\\n        \\n        for(int i=0;i<32;i++){\\n            if((n&(1<<i))!=0){\\n                power.push_back(i);\\n            }\\n        }\\n       for(auto x : queries){\\n           long pow = 1;\\n           for(int i=x[0];i<=x[1];i++){\\n               pow*=1<<power[i];\\n               pow%=1000000007;\\n           }\\n           ans.push_back(pow);\\n       } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712993,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod=1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> powers;\\n        int tmp=n;\\n        int k=0;\\n        while(tmp)\\n        {\\n            if((tmp&1))\\n            {\\n                powers.push_back(1<<k);\\n            }\\n            k++;\\n            tmp>>=1;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int l=queries[i][0];\\n            int r=queries[i][1];\\n            long long ch=1;\\n            for(int j=l;j<=r;j++)\\n            {\\n                ch=((ch%mod)*(powers[j]%mod))%mod;\\n            }\\n            ans.push_back(ch);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod=1e9+7;\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> powers;\\n        int tmp=n;\\n        int k=0;\\n        while(tmp)\\n        {\\n            if((tmp&1))\\n            {\\n                powers.push_back(1<<k);\\n            }\\n            k++;\\n            tmp>>=1;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int l=queries[i][0];\\n            int r=queries[i][1];\\n            long long ch=1;\\n            for(int j=l;j<=r;j++)\\n            {\\n                ch=((ch%mod)*(powers[j]%mod))%mod;\\n            }\\n            ans.push_back(ch);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712977,
                "title": "python-solution-faster-than-100-using-prefix-array",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers, numBits, MOD, ans = [], len(bin(n)[2:]), 1000000007, []\\n        for bit in range(numBits):\\n            if n & (1 << bit):\\n                powers.append(1 << bit)\\n        powers = list(accumulate(powers, operator.mul, initial = 1))\\n        for start, end in queries:\\n            ans.append((powers[end + 1] // powers[start]) % MOD)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers, numBits, MOD, ans = [], len(bin(n)[2:]), 1000000007, []\\n        for bit in range(numBits):\\n            if n & (1 << bit):\\n                powers.append(1 << bit)\\n        powers = list(accumulate(powers, operator.mul, initial = 1))\\n        for start, end in queries:\\n            ans.append((powers[end + 1] // powers[start]) % MOD)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711517,
                "title": "easy-understanding",
                "content": "```\\nclass Solution {\\n    int MOD = 1e9+7;\\n    void  utilfunc(int n,vector<int> &prod)\\n    {\\n        int i=1;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                prod.push_back(i);\\n            }\\n            i *= 2;\\n            n >>= 1;\\n        }\\n    }\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> prod;\\n        utilfunc(n,prod);\\n        vector<int> ans;\\n        \\n        for(auto it : queries)\\n        {\\n            long mul = 1;\\n            for(int i=it[0];i<=it[1];i++)\\n            {\\n                mul = ((mul%MOD)*(prod[i]%MOD))%MOD;\\n            }\\n            ans.push_back(mul);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1e9+7;\\n    void  utilfunc(int n,vector<int> &prod)\\n    {\\n        int i=1;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                prod.push_back(i);\\n            }\\n            i *= 2;\\n            n >>= 1;\\n        }\\n    }\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> prod;\\n        utilfunc(n,prod);\\n        vector<int> ans;\\n        \\n        for(auto it : queries)\\n        {\\n            long mul = 1;\\n            for(int i=it[0];i<=it[1];i++)\\n            {\\n                mul = ((mul%MOD)*(prod[i]%MOD))%MOD;\\n            }\\n            ans.push_back(mul);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711301,
                "title": "c-brute-force-vs-prefix-product-85-time-509ms-20-space-158mb",
                "content": "Pretty basic problem, that we can split into two parts:\\n* getting the list of powers of `2`;\\n* computing and storing the queries.\\n\\nNow, for the first part we can proceed easily knowing that the sum of powers of `2` to compose a number equates to all the set bits of `n`.\\n\\nFor the second part of the problem, we will create a variable already of the correct size and fill it (to avoid reallocations).\\n\\nTo begin, let\\'s declare a few support variables:\\n* `modVal` is the value we need to use to cut down bigger values;\\n* `powers` is an array up to `29` values (the maximum we will need to cover the values in range;\\n* `pos` is the pointer we will use to write there, initially set to `0`;\\n* `val` is where we keep track of the powers as we go, with initial value of `1`;\\n* `len` is the amount of queries we will process;\\n* `res` is our usual accumulato variable, initially set with length of `len`;\\n* `tmp` is a value we will use to store our computation for each cell of `res`.\\n\\nIn order to compute `powers`, we will proceed `while` `n != 0` and:\\n* if the least significant bit is set (`n & 1`), we will:\\n\\t* write `val` into `powers`;\\n\\t* increase `pos` by `1`;\\n* right shift by `1` position (ie: divide by `2`) `n`;\\n* left shift by `1` position (ie: multiply by `2`) `n`.\\n\\nIn order to compute `res`, once we have reset `pos` to `0` (we will use now to write in `res`) and for each query `q` in `queries` we will:\\n* reset `tmp` to be `1`;\\n* query with `i` going from `q[0]` to `q[1]` (included) and:\\n\\t* muliply `tmp` by `powers[i]` and assign it back to `tmp`;\\n\\t* compute the modulo of `tmp` by `modVal` and assign it back to `tmp`;\\n* write `tmp` in `res[pos]`\\n* increase `pos` by `1`.\\n\\nFinally, we can just `return` `res`.\\n\\nThe code:\\n\\n```cpp\\nconstexpr int modVal = 1000000007;\\n\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        // support variables\\n        int powers[29], pos = 0, val = 1, len = queries.size();\\n        long long tmp;\\n        vector<int> res(len);\\n        // computing powers\\n        while (n) {\\n            if (n & 1) powers[pos++] = val;\\n            n >>= 1, val <<= 1;\\n        }\\n        // computing res\\n        pos = 0;\\n        for (auto q: queries) {\\n            tmp = 1;\\n            for (int i = q[0], lmt = q[1]; i <= lmt; i++) tmp *= powers[i], tmp %= modVal;\\n            res[pos++] = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nOther alternative storing the prefix sum of the powers\\' exponents and then recomposing them (similarly to what I did with [my power solution](https://leetcode.com/problems/powx-n/discuss/739646/)); hard to make it better, since the powers might overflow even with `uint_128` types:\\n\\n```cpp\\nconstexpr int modVal = 1000000007;\\n\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        // support variables\\n        int powers[31] = {0}, pos = 0, val = 0, len = queries.size();\\n        long long tmp, pow;\\n        vector<int> res(len);\\n        // computing powers\\n        while (n) {\\n            if (n & 1) powers[pos] = powers[pos++] + val;\\n            n >>= 1, val++;\\n        }\\n        // computing res\\n        pos = 0;\\n        for (auto q: queries) {\\n            val = powers[q[1] + 1] - powers[q[0]];\\n            tmp = 1, pow = 2;\\n            while (val) {\\n                if (val & 1) {\\n                    tmp *= pow;\\n                    tmp %= modVal;\\n                }\\n                val >>= 1, pow *= pow, pow %= modVal;\\n            }\\n            res[pos++] = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nconstexpr int modVal = 1000000007;\\n\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        // support variables\\n        int powers[29], pos = 0, val = 1, len = queries.size();\\n        long long tmp;\\n        vector<int> res(len);\\n        // computing powers\\n        while (n) {\\n            if (n & 1) powers[pos++] = val;\\n            n >>= 1, val <<= 1;\\n        }\\n        // computing res\\n        pos = 0;\\n        for (auto q: queries) {\\n            tmp = 1;\\n            for (int i = q[0], lmt = q[1]; i <= lmt; i++) tmp *= powers[i], tmp %= modVal;\\n            res[pos++] = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int modVal = 1000000007;\\n\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        // support variables\\n        int powers[31] = {0}, pos = 0, val = 0, len = queries.size();\\n        long long tmp, pow;\\n        vector<int> res(len);\\n        // computing powers\\n        while (n) {\\n            if (n & 1) powers[pos] = powers[pos++] + val;\\n            n >>= 1, val++;\\n        }\\n        // computing res\\n        pos = 0;\\n        for (auto q: queries) {\\n            val = powers[q[1] + 1] - powers[q[0]];\\n            tmp = 1, pow = 2;\\n            while (val) {\\n                if (val & 1) {\\n                    tmp *= pow;\\n                    tmp %= modVal;\\n                }\\n                val >>= 1, pow *= pow, pow %= modVal;\\n            }\\n            res[pos++] = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710811,
                "title": "prefix-product-python",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = 10 ** 9 + 7\\n        powers = []\\n        for bit in range(32):\\n            if n & (1 << bit):\\n                powers.append(1 << bit)\\n        \\n        prefProd = [1]\\n        for p in powers:\\n            prefProd.append(prefProd[-1] * p)\\n            \\n        ans = []\\n        for l, r in queries:\\n            ans.append((prefProd[r + 1] // prefProd[l]) % MOD)\\n        return ans\\n    # Time: O(m) where is the number of queries\\n    # Space: O(1) since powers and prefProd had at most length 32\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        MOD = 10 ** 9 + 7\\n        powers = []\\n        for bit in range(32):\\n            if n & (1 << bit):\\n                powers.append(1 << bit)\\n        \\n        prefProd = [1]\\n        for p in powers:\\n            prefProd.append(prefProd[-1] * p)\\n            \\n        ans = []\\n        for l, r in queries:\\n            ans.append((prefProd[r + 1] // prefProd[l]) % MOD)\\n        return ans\\n    # Time: O(m) where is the number of queries\\n    # Space: O(1) since powers and prefProd had at most length 32\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710480,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func productQueries(_ n: Int, _ queries: [[Int]]) -> [Int] {\\n       \\n        let powers = findPowers(n)\\n        var result: [Int] = []\\n        \\n        let limit = Int(pow(Double(10),Double(9))) + 7\\n        \\n        for query in queries {\\n            \\n            let start = query[0]\\n            let end = query[1]\\n            \\n            var product = 1\\n            \\n            for i in start...end {\\n                product = (product * powers[i]) % limit\\n            }\\n            \\n            result.append(product)\\n        }\\n        \\n        return result\\n        \\n    }\\n    \\n    func findPowers(_ n: Int) -> [Int] {\\n        \\n        var powers: [Int] = []\\n        \\n        \\n        var mask = 1\\n        for i in 0..<31 {\\n            \\n            if mask & n != 0 {\\n                powers.append(mask)\\n                \\n            }\\n            mask <<= 1\\n        }\\n        \\n        return powers\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func productQueries(_ n: Int, _ queries: [[Int]]) -> [Int] {\\n       \\n        let powers = findPowers(n)\\n        var result: [Int] = []\\n        \\n        let limit = Int(pow(Double(10),Double(9))) + 7\\n        \\n        for query in queries {\\n            \\n            let start = query[0]\\n            let end = query[1]\\n            \\n            var product = 1\\n            \\n            for i in start...end {\\n                product = (product * powers[i]) % limit\\n            }\\n            \\n            result.append(product)\\n        }\\n        \\n        return result\\n        \\n    }\\n    \\n    func findPowers(_ n: Int) -> [Int] {\\n        \\n        var powers: [Int] = []\\n        \\n        \\n        var mask = 1\\n        for i in 0..<31 {\\n            \\n            if mask & n != 0 {\\n                powers.append(mask)\\n                \\n            }\\n            mask <<= 1\\n        }\\n        \\n        return powers\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710457,
                "title": "python3-binary-search-and-prefix-product-sol-for-reference",
                "content": "# Intuition\\nCalculate the minimum powers of 2 required using binary search among powers of 2. Use the calcuated array to compute a prefix product.\\n\\nAlso 10(pow)9 > 2(pow)30 (hence limit powers of 2 to 30.)\\n\\n# Complexity\\n- Time complexity: max(O(Q), O(30log30))\\n- Space complexity: 30+O(Q)\\n\\n# Code\\n```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powersOf2 = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824]\\n        \\n        p = []\\n        ans = []\\n        MOD = 10**9+7\\n        \\n        while n > 0:\\n            idx = bisect_left(powersOf2, n)\\n            if idx and powersOf2[idx] != n:\\n                idx -= 1\\n            p.append(powersOf2[idx])\\n            n -= powersOf2[idx]\\n            \\n        p = p[::-1]\\n        \\n        for i in range(1, len(p)):\\n            p[i] *= p[i-1]\\n\\n        for l, r in queries:\\n            if l: \\n                ans.append((p[r]//p[l-1])%MOD)\\n            else:\\n                ans.append(p[r]%MOD)\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powersOf2 = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824]\\n        \\n        p = []\\n        ans = []\\n        MOD = 10**9+7\\n        \\n        while n > 0:\\n            idx = bisect_left(powersOf2, n)\\n            if idx and powersOf2[idx] != n:\\n                idx -= 1\\n            p.append(powersOf2[idx])\\n            n -= powersOf2[idx]\\n            \\n        p = p[::-1]\\n        \\n        for i in range(1, len(p)):\\n            p[i] *= p[i-1]\\n\\n        for l, r in queries:\\n            if l: \\n                ans.append((p[r]//p[l-1])%MOD)\\n            else:\\n                ans.append(p[r]%MOD)\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710245,
                "title": "set-bits-c",
                "content": "\\nclass Solution {\\n\\n    public:\\n    \\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>powers;\\n        \\n    int ans=1;\\n\\t\\n long int N=1e9+7;\\n    \\n\\twhile(n){\\n        \\n            if(n&1) \\n\\t\\t\\tpowers.push_back(ans);\\n            ans<<=1;\\n            n>>=1;\\n\\n        }\\n   \\n        \\n        vector<int>answ;\\n\\t\\t\\n        for(auto k:queries)\\n        {\\n            long int ans=1;\\n            for(int i=k[0];i<=k[1];++i)\\n                ans=((ans%N) * powers[i])%N;\\n            answ.push_back(ans);\\n        }\\n            \\n        return answ;\\n        }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public:\\n    \\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>powers;\\n        \\n    int ans=1;\\n\\t\\n long int N=1e9+7;\\n    \\n\\twhile(n){\\n        \\n            if(n&1) \\n\\t\\t\\tpowers.push_back(ans);\\n            ans<<=1;\\n            n>>=1;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2710075,
                "title": "rust-100",
                "content": "# Intuition\\nStep 1: turn n into an array.\\nUse bit operations is easy.\\nStep 2: compute the product.\\nNote in rust I use i64 to avoid overflow.\\n\\n# Code\\n```\\nimpl Solution {\\n    // use bit operation to split n\\n    pub fn split_n(n: i32) -> Vec<i32> {\\n        let mut vec = Vec::new();\\n        for i in 0..32 {\\n            if (n & (1 << i)) != 0 {\\n                vec.push(1 << i);\\n            }\\n        }\\n        vec\\n    }\\n\\n    pub fn product_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let m = 1_000_000_007;\\n        let powers = Self::split_n(n);\\n        let mut result = vec![];\\n        for q in queries {\\n            // math: (a * b) mod m = (a mod m)(b mod m) mod m\\n            // with a loop, accu = (accu * next mod m) mod m\\n            // use i64 to avoid overflow in accu * x\\n            let ans = powers[q[0] as usize..=q[1] as usize]\\n                .iter()\\n                .fold(1i64, |accu, x| (accu * (*x as i64 % m)) % m);\\n            result.push(ans as i32);\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    // use bit operation to split n\\n    pub fn split_n(n: i32) -> Vec<i32> {\\n        let mut vec = Vec::new();\\n        for i in 0..32 {\\n            if (n & (1 << i)) != 0 {\\n                vec.push(1 << i);\\n            }\\n        }\\n        vec\\n    }\\n\\n    pub fn product_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let m = 1_000_000_007;\\n        let powers = Self::split_n(n);\\n        let mut result = vec![];\\n        for q in queries {\\n            // math: (a * b) mod m = (a mod m)(b mod m) mod m\\n            // with a loop, accu = (accu * next mod m) mod m\\n            // use i64 to avoid overflow in accu * x\\n            let ans = powers[q[0] as usize..=q[1] as usize]\\n                .iter()\\n                .fold(1i64, |accu, x| (accu * (*x as i64 % m)) % m);\\n            result.push(ans as i32);\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709742,
                "title": "easy-understanding-but-giving-me-wrong-answer",
                "content": "Easy-Understanding but giving me Wrong answer becoz of this  (v[q[1]]/v[q[0]-1]. Please help me.\\n```\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> v,ans;\\n        \\n        long long int i =1,mod =1e9+7;\\n        \\n        while(n)\\n        {\\n            if(i>n)\\n            {\\n                i/=2;\\n                v.push_back(i) ;\\n                n-=i;\\n                i=1;\\n            }\\n            i*=2;\\n        }\\n        \\n        sort(v.begin(),v.end()) ;\\n        \\n        for(int i= 1;i<v.size();i++)\\n        {\\n            long long p= v[i-1] ;\\n            v[i]=(v[i]*p)%mod ;\\n        }\\n        \\n        \\n        \\n        for(auto q :queries)\\n        {\\n            if(q[0]==0)ans.push_back(v[q[1]]) ;\\n            else ans.push_back(v[q[1]]/v[q[0]-1]) ;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> v,ans;\\n        \\n        long long int i =1,mod =1e9+7;\\n        \\n        while(n)\\n        {\\n            if(i>n)\\n            {\\n                i/=2;\\n                v.push_back(i) ;\\n                n-=i;\\n                i=1;\\n            }\\n            i*=2;\\n        }\\n        \\n        sort(v.begin(),v.end()) ;\\n        \\n        for(int i= 1;i<v.size();i++)\\n        {\\n            long long p= v[i-1] ;\\n            v[i]=(v[i]*p)%mod ;\\n        }\\n        \\n        \\n        \\n        for(auto q :queries)\\n        {\\n            if(q[0]==0)ans.push_back(v[q[1]]) ;\\n            else ans.push_back(v[q[1]]/v[q[0]-1]) ;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709691,
                "title": "c-easy-soln-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> po;\\n        long long mod = 1e9 +7;\\n        while(n>0)\\n        {\\n            int k = log2(n);\\n            po.push_back(pow(2,k));\\n            n = n-pow(2,k);\\n        }\\n        \\n        sort(po.begin(),po.end());\\n        \\n        \\n        vector<int> sum(po.size(),0);\\n        \\n        sum[0]=po[0];\\n        \\n        int z = queries.size();\\n        \\n        // int ans =0;\\n        \\n        vector<int> ans(z,0);\\n        \\n        \\n        // for(int i=1;i<po.size();i++)\\n        // {\\n        //     sum[i] = ((sum[i-1])%mod*(po[i])%mod)%mod;\\n        // }\\n        \\n        for(int i=0;i<z;i++)\\n        {\\n            int res=1;\\n            \\n            for(int j=queries[i][0];j<=queries[i][1];j++)\\n                res = ((res%mod)*(po[j])%mod)%mod;\\n            \\n            ans[i] = res;\\n        }\\n        return ans;\\n        // return {1};\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> po;\\n        long long mod = 1e9 +7;\\n        while(n>0)\\n        {\\n            int k = log2(n);\\n            po.push_back(pow(2,k));\\n            n = n-pow(2,k);\\n        }\\n        \\n        sort(po.begin(),po.end());\\n        \\n        \\n        vector<int> sum(po.size(),0);\\n        \\n        sum[0]=po[0];\\n        \\n        int z = queries.size();\\n        \\n        // int ans =0;\\n        \\n        vector<int> ans(z,0);\\n        \\n        \\n        // for(int i=1;i<po.size();i++)\\n        // {\\n        //     sum[i] = ((sum[i-1])%mod*(po[i])%mod)%mod;\\n        // }\\n        \\n        for(int i=0;i<z;i++)\\n        {\\n            int res=1;\\n            \\n            for(int j=queries[i][0];j<=queries[i][1];j++)\\n                res = ((res%mod)*(po[j])%mod)%mod;\\n            \\n            ans[i] = res;\\n        }\\n        return ans;\\n        // return {1};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709516,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers = []\\n        res = []\\n        v = []\\n        mod = (10 ** 9) + 7\\n        while n > 0:\\n            v.append(n % 2)\\n            n = n // 2\\n            \\n        for i in range(len(v)):\\n            if v[i] == 1:\\n                powers.append(2 ** i)\\n                \\n        for start, end in queries:\\n            prod = 1\\n            for i in range(start, end + 1):\\n                prod *= powers[i]\\n                \\n            res.append(prod % mod)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers = []\\n        res = []\\n        v = []\\n        mod = (10 ** 9) + 7\\n        while n > 0:\\n            v.append(n % 2)\\n            n = n // 2\\n            \\n        for i in range(len(v)):\\n            if v[i] == 1:\\n                powers.append(2 ** i)\\n                \\n        for start, end in queries:\\n            prod = 1\\n            for i in range(start, end + 1):\\n                prod *= powers[i]\\n                \\n            res.append(prod % mod)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709365,
                "title": "python-o-n-solution",
                "content": "```\\ndef productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        mod = 10 ** 9 + 7 \\n        N = int(log2(n)) + 1\\n        pref = []\\n        \\n        curr = 1\\n        for i in range(N + 1):\\n            if n & (1 << i):\\n                curr *= (1 << i)\\n                pref.append(curr)\\n        \\n        res = []\\n        for l, r in queries:\\n            lp = 1 if l == 0 else pref[l - 1]\\n            ans = pref[r] // lp\\n            res.append(ans % mod)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        mod = 10 ** 9 + 7 \\n        N = int(log2(n)) + 1\\n        pref = []\\n        \\n        curr = 1\\n        for i in range(N + 1):\\n            if n & (1 << i):\\n                curr *= (1 << i)\\n                pref.append(curr)\\n        \\n        res = []\\n        for l, r in queries:\\n            lp = 1 if l == 0 else pref[l - 1]\\n            ans = pref[r] // lp\\n            res.append(ans % mod)\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2708977,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    string decToBinary(int n) {\\n        int binaryNum[32];\\n        int i = 0;\\n        while (n > 0) {\\n            binaryNum[i] = n % 2;\\n            n = n / 2;\\n            i++;\\n        }\\n        string ans;\\n        for(int j = i - 1; j >= 0; j--) {\\n            ans += to_string(binaryNum[j]);\\n        }\\n        return ans;\\n    }\\n    long long binaryExponentiationIterative(long long a,long long b) {\\n        long long ans = 1;\\n        while(b > 0) {\\n            if(b & 1) {\\n                ans = ans * a;\\n            }\\n            a = a * a;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        string s = decToBinary(n);\\n        reverse(s.begin(),s.end());\\n        vector<int>arr,ans;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'1\\') {\\n                int temp = binaryExponentiationIterative(2,i) % MOD;\\n                arr.push_back(temp);\\n            }\\n        }\\n        for(int i = 0; i < queries.size(); i++) {\\n            int low = queries[i][0];\\n            int high = queries[i][1];\\n            long long sum = 1;\\n            for(int j = low; j <= high; j++) {\\n                sum *= arr[j];\\n                sum %= MOD;\\n            }\\n            int val = sum % MOD;\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9 + 7;\\n    string decToBinary(int n) {\\n        int binaryNum[32];\\n        int i = 0;\\n        while (n > 0) {\\n            binaryNum[i] = n % 2;\\n            n = n / 2;\\n            i++;\\n        }\\n        string ans;\\n        for(int j = i - 1; j >= 0; j--) {\\n            ans += to_string(binaryNum[j]);\\n        }\\n        return ans;\\n    }\\n    long long binaryExponentiationIterative(long long a,long long b) {\\n        long long ans = 1;\\n        while(b > 0) {\\n            if(b & 1) {\\n                ans = ans * a;\\n            }\\n            a = a * a;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        string s = decToBinary(n);\\n        reverse(s.begin(),s.end());\\n        vector<int>arr,ans;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'1\\') {\\n                int temp = binaryExponentiationIterative(2,i) % MOD;\\n                arr.push_back(temp);\\n            }\\n        }\\n        for(int i = 0; i < queries.size(); i++) {\\n            int low = queries[i][0];\\n            int high = queries[i][1];\\n            long long sum = 1;\\n            for(int j = low; j <= high; j++) {\\n                sum *= arr[j];\\n                sum %= MOD;\\n            }\\n            int val = sum % MOD;\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708896,
                "title": "python-prefix-sum-of-powers-bit-manipulation",
                "content": "# Code\\n```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        p = 10**9 + 7\\n\\n        powers_prefix = []\\n        mask, power = 1, 0\\n        while mask <= n:\\n            if mask & n:\\n                powers_prefix.append(power)\\n\\n            mask *= 2\\n            power += 1\\n\\n        # Calculate prefix sum of powers.\\n        for i in range(1, len(powers_prefix)):\\n            powers_prefix[i] += powers_prefix[i-1]\\n\\n        ans = [1] * len(queries)\\n        for i, (l, r) in enumerate (queries):\\n            power = powers_prefix[r]\\n            if l > 0:\\n                power -= powers_prefix[l-1]\\n\\n            ans[i] = (1 << power) % p\\n\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        p = 10**9 + 7\\n\\n        powers_prefix = []\\n        mask, power = 1, 0\\n        while mask <= n:\\n            if mask & n:\\n                powers_prefix.append(power)\\n\\n            mask *= 2\\n            power += 1\\n\\n        # Calculate prefix sum of powers.\\n        for i in range(1, len(powers_prefix)):\\n            powers_prefix[i] += powers_prefix[i-1]\\n\\n        ans = [1] * len(queries)\\n        for i, (l, r) in enumerate (queries):\\n            power = powers_prefix[r]\\n            if l > 0:\\n                power -= powers_prefix[l-1]\\n\\n            ans[i] = (1 << power) % p\\n\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708813,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int len = queries.length;\\n        int mod = (int)1e9 + 7;\\n        \\n        int[] ans = new int[len];\\n        \\n        String s = Integer.toBinaryString(n);\\n        //System.out.println(s);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        int x = s.length() - 1;\\n        for(int i = s.length() - 1 ; i >= 0 ; i--){\\n            char c = s.charAt(i);\\n            \\n            if(c != \\'0\\'){\\n                list.add((int)Math.pow(2 , x - i));\\n            }\\n        }\\n        \\n        //System.out.println(list);\\n        \\n        int idx = 0;\\n        for(int[] i : queries){\\n            long val = 1;\\n            \\n            for(int j = i[0] ; j <= i[1] ; j++){\\n                val = (val % mod * list.get(j) % mod) % mod;\\n            }\\n            ans[idx] = (int)val;\\n            idx++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int len = queries.length;\\n        int mod = (int)1e9 + 7;\\n        \\n        int[] ans = new int[len];\\n        \\n        String s = Integer.toBinaryString(n);\\n        //System.out.println(s);\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        int x = s.length() - 1;\\n        for(int i = s.length() - 1 ; i >= 0 ; i--){\\n            char c = s.charAt(i);\\n            \\n            if(c != \\'0\\'){\\n                list.add((int)Math.pow(2 , x - i));\\n            }\\n        }\\n        \\n        //System.out.println(list);\\n        \\n        int idx = 0;\\n        for(int[] i : queries){\\n            long val = 1;\\n            \\n            for(int j = i[0] ; j <= i[1] ; j++){\\n                val = (val % mod * list.get(j) % mod) % mod;\\n            }\\n            ans[idx] = (int)val;\\n            idx++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708627,
                "title": "python-js-c-by-look-up-table-w-hint",
                "content": "**Hint**:\\n\\nSince range product is made up of **consecutive product of power of two**\\n\\nSo we can use **Properties of Exponents** to implement and speed up range query.\\n\\n![image](https://assets.leetcode.com/users/images/29f23a79-3728-4ddc-a61c-06a6848e24fb_1665896803.5366993.png)\\n\\nWhen it comes to base 2, that is\\n\\n(2^i)  x  (2^j) = 2^ ( i + j  )\\n\\n(2^i)  x  (2^j) x  (2^k)= 2^ ( i + j + k )\\n\\n...\\n\\nand so on\\n\\nFor example,\\n\\n2^2 x 2^5 = 2^( 2 + 5 ) = 2^7 = 128\\n\\n---\\n\\nPython:\\n\\n```\\nclass Solution:\\n    \\n    # modulo constant defined by description\\n    MOD_CONST = (10**9 + 7)\\n    \\n    # a table with power of 2, with modulo with MOD_CONST on each step, to make it a faster without repeated computation during queries\\n    powerTwoTable = [1]\\n    \\n    def preCalcPowerOfTwo(self):\\n        \\n        for i in range(500):\\n            \\n            nextTerm = (self.powerTwoTable[-1] * 2) % self.MOD_CONST\\n            self.powerTwoTable.append( nextTerm )\\n            \\n        return\\n    \\n    \\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        self.preCalcPowerOfTwo()\\n        \\n        # Base2 prefix product table, initialized with dummy 0\\n        prefixExp = [0]\\n        \\n        # Build base2 prefix sum table from bit_#0 to bit_#31\\n        # in the form of pow(2, i)\\n        for i in range(32):\\n            if n & (1<<i):\\n                prefixExp.append( prefixExp[-1] + i )\\n        \\n        \\n        \\n        # Look-up table in prefixExp with given range\\n        result = []\\n        for begin, end in queries:\\n            \\n            if end > begin:\\n                # multiple factors\\n                exponent = prefixExp[end+1] - prefixExp[begin]\\n            else:\\n                # single factor\\n                exponent = prefixExp[end+1] - prefixExp[end]\\n                \\n            rangeProduct = self.powerTwoTable[exponent]\\n    \\n            result.append( rangeProduct )\\n        \\n        \\n        return result\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar productQueries = function(n, queries) {\\n    \\n        // modulo constant defined by description\\n        const MOD_CONST = (10**9 + 7);\\n        \\n        // base2 prefix product table, initialized with dummy 0\\n        let prefixExp = [0];\\n        \\n        // Build base2 prefix sum table from bit_#0 to bit_#31\\n        // in the form of pow(2, i)\\n        for( let i = 0 ; i < 32 ; i++){\\n            if( n & (1<<i) ){ \\n                prefixExp.push( prefixExp[ prefixExp.length-1 ] + i )\\n            }\\n        }\\n        \\n        \\n        // look-up table in prefixExp with given range\\n        let result = [];\\n        let exponent = 0;\\n    \\n        for( let [begin, end] of queries ){\\n            \\n            if( end > begin ){\\n                // multiple factors\\n                exponent = prefixExp[end+1] - prefixExp[begin]\\n            }else{\\n                // single factor\\n                exponent = prefixExp[end+1] - prefixExp[end]\\n            }   \\n            \\n            let rangeProduct = ( 2**exponent ) % MOD_CONST\\n    \\n            result.push( rangeProduct )\\n        }\\n        \\n        return result\\n};\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        // My walkaround to deal with super big integer multiplcation, in order to avoid overflow in C/C++ type\\n        preCalcPowerOfTwo();\\n        \\n        // Base2 prefix product table, initialized with dummy 0 for index-accessing convenience\\n        vector<int> prefixExp = vector<int>(1,0);\\n        \\n        // Build base2 prefix sum table from bit_#0 to bit_#31\\n        // in the form of pow(2, i)\\n        for( int i = 0 ; i < 32 ; i++){\\n            if( n & (1<<i) ){ \\n                prefixExp.emplace_back( prefixExp.back() + i );\\n            }\\n        }\\n        \\n        \\n        // Look-up table in prefixExp with given range\\n        vector<int> result;\\n        int exponent = 0;\\n        \\n        for( const auto& query : queries ){\\n            \\n            int begin = query[0], end = query[1];\\n            \\n            if( end > begin ){\\n                // multiple factors\\n                exponent = prefixExp[end+1] - prefixExp[begin];\\n                \\n            }else{\\n                // single factor\\n                exponent = prefixExp[end+1] - prefixExp[end];\\n            }   \\n            \\n            int rangeProduct = powerTwoTable[exponent]; \\n    \\n            result.emplace_back( rangeProduct );\\n        }\\n        \\n        return result;\\n    }\\n    \\nprivate:\\n    // modulo constant defined by description\\n    const unsigned int MOD_CONST = (unsigned int)( pow(10, 9) ) + 7u; //1000000007; //\\n    \\n    // a table with power of 2, with modulo with MOD_CONST on each step, to make it a safe value to avoid overflow during big integer multiplication\\n    vector<int> powerTwoTable = vector<int>(500,1);\\n    \\n    void preCalcPowerOfTwo(){\\n        \\n        for( size_t i = 1 ; i < 500 ; i++){\\n            powerTwoTable[i] = (powerTwoTable[i-1] << 1) % MOD_CONST;\\n        }\\n        return;\\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # modulo constant defined by description\\n    MOD_CONST = (10**9 + 7)\\n    \\n    # a table with power of 2, with modulo with MOD_CONST on each step, to make it a faster without repeated computation during queries\\n    powerTwoTable = [1]\\n    \\n    def preCalcPowerOfTwo(self):\\n        \\n        for i in range(500):\\n            \\n            nextTerm = (self.powerTwoTable[-1] * 2) % self.MOD_CONST\\n            self.powerTwoTable.append( nextTerm )\\n            \\n        return\\n    \\n    \\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        self.preCalcPowerOfTwo()\\n        \\n        # Base2 prefix product table, initialized with dummy 0\\n        prefixExp = [0]\\n        \\n        # Build base2 prefix sum table from bit_#0 to bit_#31\\n        # in the form of pow(2, i)\\n        for i in range(32):\\n            if n & (1<<i):\\n                prefixExp.append( prefixExp[-1] + i )\\n        \\n        \\n        \\n        # Look-up table in prefixExp with given range\\n        result = []\\n        for begin, end in queries:\\n            \\n            if end > begin:\\n                # multiple factors\\n                exponent = prefixExp[end+1] - prefixExp[begin]\\n            else:\\n                # single factor\\n                exponent = prefixExp[end+1] - prefixExp[end]\\n                \\n            rangeProduct = self.powerTwoTable[exponent]\\n    \\n            result.append( rangeProduct )\\n        \\n        \\n        return result\\n```\n```\\nvar productQueries = function(n, queries) {\\n    \\n        // modulo constant defined by description\\n        const MOD_CONST = (10**9 + 7);\\n        \\n        // base2 prefix product table, initialized with dummy 0\\n        let prefixExp = [0];\\n        \\n        // Build base2 prefix sum table from bit_#0 to bit_#31\\n        // in the form of pow(2, i)\\n        for( let i = 0 ; i < 32 ; i++){\\n            if( n & (1<<i) ){ \\n                prefixExp.push( prefixExp[ prefixExp.length-1 ] + i )\\n            }\\n        }\\n        \\n        \\n        // look-up table in prefixExp with given range\\n        let result = [];\\n        let exponent = 0;\\n    \\n        for( let [begin, end] of queries ){\\n            \\n            if( end > begin ){\\n                // multiple factors\\n                exponent = prefixExp[end+1] - prefixExp[begin]\\n            }else{\\n                // single factor\\n                exponent = prefixExp[end+1] - prefixExp[end]\\n            }   \\n            \\n            let rangeProduct = ( 2**exponent ) % MOD_CONST\\n    \\n            result.push( rangeProduct )\\n        }\\n        \\n        return result\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        \\n        // My walkaround to deal with super big integer multiplcation, in order to avoid overflow in C/C++ type\\n        preCalcPowerOfTwo();\\n        \\n        // Base2 prefix product table, initialized with dummy 0 for index-accessing convenience\\n        vector<int> prefixExp = vector<int>(1,0);\\n        \\n        // Build base2 prefix sum table from bit_#0 to bit_#31\\n        // in the form of pow(2, i)\\n        for( int i = 0 ; i < 32 ; i++){\\n            if( n & (1<<i) ){ \\n                prefixExp.emplace_back( prefixExp.back() + i );\\n            }\\n        }\\n        \\n        \\n        // Look-up table in prefixExp with given range\\n        vector<int> result;\\n        int exponent = 0;\\n        \\n        for( const auto& query : queries ){\\n            \\n            int begin = query[0], end = query[1];\\n            \\n            if( end > begin ){\\n                // multiple factors\\n                exponent = prefixExp[end+1] - prefixExp[begin];\\n                \\n            }else{\\n                // single factor\\n                exponent = prefixExp[end+1] - prefixExp[end];\\n            }   \\n            \\n            int rangeProduct = powerTwoTable[exponent]; \\n    \\n            result.emplace_back( rangeProduct );\\n        }\\n        \\n        return result;\\n    }\\n    \\nprivate:\\n    // modulo constant defined by description\\n    const unsigned int MOD_CONST = (unsigned int)( pow(10, 9) ) + 7u; //1000000007; //\\n    \\n    // a table with power of 2, with modulo with MOD_CONST on each step, to make it a safe value to avoid overflow during big integer multiplication\\n    vector<int> powerTwoTable = vector<int>(500,1);\\n    \\n    void preCalcPowerOfTwo(){\\n        \\n        for( size_t i = 1 ; i < 500 ; i++){\\n            powerTwoTable[i] = (powerTwoTable[i-1] << 1) % MOD_CONST;\\n        }\\n        return;\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708536,
                "title": "c-bitwise-operation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        long long powo = pow(10,9) + 7;\\n        vector<long long> powers;\\n        long long i = 1;\\n        while(i<=n) {\\n            if (i&n) {\\n                powers.push_back(i);\\n            }\\n            i<<=1;\\n        }\\n        vector<int> output;\\n        for(vector<int> &query : queries) {\\n            long long s = query[0];\\n            long long e = query[1];\\n            long long product = 1;\\n            while(s<=e) {\\n                product = (product%powo) * (powers[s]%powo);\\n                s++;\\n            }\\n            product %= powo;\\n            output.push_back(product);\\n            \\n        }\\n        \\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        long long powo = pow(10,9) + 7;\\n        vector<long long> powers;\\n        long long i = 1;\\n        while(i<=n) {\\n            if (i&n) {\\n                powers.push_back(i);\\n            }\\n            i<<=1;\\n        }\\n        vector<int> output;\\n        for(vector<int> &query : queries) {\\n            long long s = query[0];\\n            long long e = query[1];\\n            long long product = 1;\\n            while(s<=e) {\\n                product = (product%powo) * (powers[s]%powo);\\n                s++;\\n            }\\n            product %= powo;\\n            output.push_back(product);\\n            \\n        }\\n        \\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708315,
                "title": "logic-explained",
                "content": "**PLS UPVOTE IF you like the SOLUTION:)**\\n**IDEA:-**\\nThere are two steps for solving this problem:\\n1. Creating  the power array\\nIf you look closely the power array is actually the binary representation of num\\n2. Then we get a range and multiply and add it to the vector that is to be returned\\n\\n**T.C:-** O(N*N)    **S.C:-** O(k) where k is the length of the power vector\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>powers;\\n        int x=1;\\n        while(n!=0){\\n            if((n&1)!=0){\\n                powers.push_back(x);\\n            }\\n            x=x<<1;\\n            n=n>>1;\\n        }\\n        vector<int>vec;\\n        \\n        for(int i{0};i<queries.size();++i){\\n            long long int x=1;\\n            for(int j=queries.at(i).at(0);j<=queries.at(i).at(1);++j){\\n                x=(x*powers.at(j))%((long long int)pow(10,9)+7);\\n            }\\n            x=x%((long long)pow(10,9)+7);\\n            vec.push_back(x);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>powers;\\n        int x=1;\\n        while(n!=0){\\n            if((n&1)!=0){\\n                powers.push_back(x);\\n            }\\n            x=x<<1;\\n            n=n>>1;\\n        }\\n        vector<int>vec;\\n        \\n        for(int i{0};i<queries.size();++i){\\n            long long int x=1;\\n            for(int j=queries.at(i).at(0);j<=queries.at(i).at(1);++j){\\n                x=(x*powers.at(j))%((long long int)pow(10,9)+7);\\n            }\\n            x=x%((long long)pow(10,9)+7);\\n            vec.push_back(x);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708255,
                "title": "c-easy-solution-prefix-product-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int mod = (int)(1e9+7);\\n        vector<long>power;\\n        while(n>0)\\n        {\\n            int p = log2(n);\\n            if(!p)  break;\\n            long add = (1<<p);\\n            power.push_back(add);\\n            n -= add;\\n        }\\n        if(n)   power.push_back(1);\\n        reverse(power.begin(),power.end());\\n        n = power.size();\\n        vector<long>pref(n,1);\\n        pref[0] = power[0];\\n        for(int i=1;i<n;i++)    pref[i] = ((pref[i-1]%mod)*(power[i]%mod))%mod;\\n        n = queries.size();\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int i1 = queries[i][0], i2 = queries[i][1];\\n            long val = 1;\\n            while(i1<=i2)   val = ((val%mod)*(power[i1++]%mod));\\n            ans[i] = val%mod;                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& queries) {\\n        int mod = (int)(1e9+7);\\n        vector<long>power;\\n        while(n>0)\\n        {\\n            int p = log2(n);\\n            if(!p)  break;\\n            long add = (1<<p);\\n            power.push_back(add);\\n            n -= add;\\n        }\\n        if(n)   power.push_back(1);\\n        reverse(power.begin(),power.end());\\n        n = power.size();\\n        vector<long>pref(n,1);\\n        pref[0] = power[0];\\n        for(int i=1;i<n;i++)    pref[i] = ((pref[i-1]%mod)*(power[i]%mod))%mod;\\n        n = queries.size();\\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int i1 = queries[i][0], i2 = queries[i][1];\\n            long val = 1;\\n            while(i1<=i2)   val = ((val%mod)*(power[i1++]%mod));\\n            ans[i] = val%mod;                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707896,
                "title": "elegant-recursive-style-python-solution-with-two-100",
                "content": "```\\nclass Solution:\\n    @staticmethod\\n    @cache\\n    def powerfor2(idx):\\n        if idx == 0:\\n            return 1\\n        elif idx == 1:\\n            return 2\\n        else:\\n            return (Solution.powerfor2(idx // 2) * Solution.powerfor2(idx - idx // 2)) % 1000000007\\n    \\n    @staticmethod\\n    @cache\\n    def find_less(n):\\n        if n == 1:\\n            return 0\\n        else:\\n            return 1 + Solution.find_less(n // 2)\\n        \\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:               \\n        powers = []\\n        while n != 0:\\n            powers.append(Solution.find_less(n))\\n            n -= Solution.powerfor2(powers[-1])\\n        powers.sort()\\n        \\n        prefixS = [0]\\n        for v in powers:\\n            prefixS.append(v + prefixS[-1])\\n        \\n        res = []\\n        for left, right in queries:\\n            res.append(Solution.powerfor2(prefixS[right + 1] - prefixS[left]))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    @staticmethod\\n    @cache\\n    def powerfor2(idx):\\n        if idx == 0:\\n            return 1\\n        elif idx == 1:\\n            return 2\\n        else:\\n            return (Solution.powerfor2(idx // 2) * Solution.powerfor2(idx - idx // 2)) % 1000000007\\n    \\n    @staticmethod\\n    @cache\\n    def find_less(n):\\n        if n == 1:\\n            return 0\\n        else:\\n            return 1 + Solution.find_less(n // 2)\\n        \\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:               \\n        powers = []\\n        while n != 0:\\n            powers.append(Solution.find_less(n))\\n            n -= Solution.powerfor2(powers[-1])\\n        powers.sort()\\n        \\n        prefixS = [0]\\n        for v in powers:\\n            prefixS.append(v + prefixS[-1])\\n        \\n        res = []\\n        for left, right in queries:\\n            res.append(Solution.powerfor2(prefixS[right + 1] - prefixS[left]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707861,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n)+queries.size()*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        int c=1;\\n        vector<int> v;\\n        while(n){\\n            if(n%2) v.push_back(c);\\n            n=n/2;\\n            c=(2*c);\\n        }\\n    //     n=v.size();\\n    //     long long a[100];\\n    //     for(int i=0;i<n;i++){\\n    //         if(i==0) a[i]=v[i];\\n    //         else{\\n    //             a[i]=((a[i-1])*(v[i]));//%1000000007;\\n    //         }\\n    //    }\\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();i++){\\n            long te=1;\\n            for(int j=q[i][0];j<=q[i][1];j++){\\n                te=(te*v[j])%1000000007;\\n            }\\n            res.push_back(te);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productQueries(int n, vector<vector<int>>& q) {\\n        int c=1;\\n        vector<int> v;\\n        while(n){\\n            if(n%2) v.push_back(c);\\n            n=n/2;\\n            c=(2*c);\\n        }\\n    //     n=v.size();\\n    //     long long a[100];\\n    //     for(int i=0;i<n;i++){\\n    //         if(i==0) a[i]=v[i];\\n    //         else{\\n    //             a[i]=((a[i-1])*(v[i]));//%1000000007;\\n    //         }\\n    //    }\\n\\n        vector<int> res;\\n        for(int i=0;i<q.size();i++){\\n            long te=1;\\n            for(int j=q[i][0];j<=q[i][1];j++){\\n                te=(te*v[j])%1000000007;\\n            }\\n            res.push_back(te);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707859,
                "title": "simple-5-line-python-presum",
                "content": "Here, we precompute consecutive products for binary decomposition of n.\\n\\n```python\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers_mul = [1] # presum\\n        for i in range(30): \\n            if n & 1<<i:                \\n                powers_mul.append((1<<i) * powers_mul[-1])\\n        return  [(powers_mul[right+1] // powers_mul[left]) % (10**9+7) for left, right in queries]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def productQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        powers_mul = [1] # presum\\n        for i in range(30): \\n            if n & 1<<i:                \\n                powers_mul.append((1<<i) * powers_mul[-1])\\n        return  [(powers_mul[right+1] // powers_mul[left]) % (10**9+7) for left, right in queries]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1645981,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I found testcase 2, too hard to understand like how 2 pow 0 = 2?? Can somebody explain."
                    },
                    {
                        "username": "suanow",
                        "content": "[@72engineers](/72engineers) can\\'t get the idea why do we take 2 instead of 1 (2**0)? I thought, that we have an array of power like [1, 2, 4, 8, etc] and we need to take max index, where the sum of all of the elements before are lower than \\'n\\'. So, we should take 1, then try 1+2>2 -> we stop and our list of powers should be [1]. Where am I wrong?\\n"
                    },
                    {
                        "username": "math_pi",
                        "content": "You can check for each bit, if the bit is set(1 << bit & N),  add that bit raised to the power (1 << bit) 2 to the powers array, this way sum of power array will always total up to N."
                    },
                    {
                        "username": "72engineers",
                        "content": "it says \"composed of the minimum number of powers of 2 that SUM to n\", thus, it\\'s a \"sum\"."
                    },
                    {
                        "username": "deepakjakhar684",
                        "content": "\\n\\nCan anybody explain why this code ia giving wrong answer basically the integwr was overflowing after mod also\\n\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int mod = (int)(1e9+7);\\n        if(n==1) return new int[]{1};\\n        if(n==2) return new int[]{2};\\n        List<Integer> list = new ArrayList();\\n        while(n>0){\\n            list.add((n%2)%mod);\\n            n=n/2;\\n        }\\n        List<Integer> value  = new ArrayList();\\n        for(int i =0;i<list.size();i++){\\n            if(list.get(i)==1){\\n                if(i==0){\\n                    value.add(1);\\n                }\\n                else{\\n                    value.add((int)(Math.pow(2,i)%mod));\\n                }\\n            }\\n        }\\n        int sizee[] = new int[value.size()];\\n        sizee[0]= value.get(0)%mod;\\n        for(int i =1;i<value.size();i++){\\n            sizee[i]=(sizee[i-1]*value.get(i)%mod);\\n        }\\n        int ans[] = new int[queries.length];\\n        for(int i =0;i<queries.length;i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            if(left ==0) ans[i]=sizee[right]%mod;\\n            else{\\n                ans[i] = (sizee[right]/sizee[left-1])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1646143,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "I found testcase 2, too hard to understand like how 2 pow 0 = 2?? Can somebody explain."
                    },
                    {
                        "username": "suanow",
                        "content": "[@72engineers](/72engineers) can\\'t get the idea why do we take 2 instead of 1 (2**0)? I thought, that we have an array of power like [1, 2, 4, 8, etc] and we need to take max index, where the sum of all of the elements before are lower than \\'n\\'. So, we should take 1, then try 1+2>2 -> we stop and our list of powers should be [1]. Where am I wrong?\\n"
                    },
                    {
                        "username": "math_pi",
                        "content": "You can check for each bit, if the bit is set(1 << bit & N),  add that bit raised to the power (1 << bit) 2 to the powers array, this way sum of power array will always total up to N."
                    },
                    {
                        "username": "72engineers",
                        "content": "it says \"composed of the minimum number of powers of 2 that SUM to n\", thus, it\\'s a \"sum\"."
                    },
                    {
                        "username": "deepakjakhar684",
                        "content": "\\n\\nCan anybody explain why this code ia giving wrong answer basically the integwr was overflowing after mod also\\n\\nclass Solution {\\n    public int[] productQueries(int n, int[][] queries) {\\n        int mod = (int)(1e9+7);\\n        if(n==1) return new int[]{1};\\n        if(n==2) return new int[]{2};\\n        List<Integer> list = new ArrayList();\\n        while(n>0){\\n            list.add((n%2)%mod);\\n            n=n/2;\\n        }\\n        List<Integer> value  = new ArrayList();\\n        for(int i =0;i<list.size();i++){\\n            if(list.get(i)==1){\\n                if(i==0){\\n                    value.add(1);\\n                }\\n                else{\\n                    value.add((int)(Math.pow(2,i)%mod));\\n                }\\n            }\\n        }\\n        int sizee[] = new int[value.size()];\\n        sizee[0]= value.get(0)%mod;\\n        for(int i =1;i<value.size();i++){\\n            sizee[i]=(sizee[i-1]*value.get(i)%mod);\\n        }\\n        int ans[] = new int[queries.length];\\n        for(int i =0;i<queries.length;i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            if(left ==0) ans[i]=sizee[right]%mod;\\n            else{\\n                ans[i] = (sizee[right]/sizee[left-1])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]