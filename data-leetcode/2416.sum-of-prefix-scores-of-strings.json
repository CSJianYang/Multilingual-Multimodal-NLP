[
    {
        "title": "Sum of Prefix Scores of Strings",
        "question_content": "You are given an array words of size n consisting of non-empty strings.\nWe define the score of a string word as the number of strings words[i] such that word is a prefix of words[i].\n\n\tFor example, if words = [\"a\", \"ab\", \"abc\", \"cab\"], then the score of \"ab\" is 2, since \"ab\" is a prefix of both \"ab\" and \"abc\".\n\nReturn an array answer of size n where answer[i] is the sum of scores of every non-empty prefix of words[i].\nNote that a string is considered as a prefix of itself.\n&nbsp;\nExample 1:\n\nInput: words = [\"abc\",\"ab\",\"bc\",\"b\"]\nOutput: [5,4,3,2]\nExplanation: The answer for each string is the following:\n- \"abc\" has 3 prefixes: \"a\", \"ab\", and \"abc\".\n- There are 2 strings with the prefix \"a\", 2 strings with the prefix \"ab\", and 1 string with the prefix \"abc\".\nThe total is answer[0] = 2 + 2 + 1 = 5.\n- \"ab\" has 2 prefixes: \"a\" and \"ab\".\n- There are 2 strings with the prefix \"a\", and 2 strings with the prefix \"ab\".\nThe total is answer[1] = 2 + 2 = 4.\n- \"bc\" has 2 prefixes: \"b\" and \"bc\".\n- There are 2 strings with the prefix \"b\", and 1 string with the prefix \"bc\".\nThe total is answer[2] = 2 + 1 = 3.\n- \"b\" has 1 prefix: \"b\".\n- There are 2 strings with the prefix \"b\".\nThe total is answer[3] = 2.\n\nExample 2:\n\nInput: words = [\"abcd\"]\nOutput: [4]\nExplanation:\n\"abcd\" has 4 prefixes: \"a\", \"ab\", \"abc\", and \"abcd\".\nEach prefix has a score of one, so the total is answer[0] = 1 + 1 + 1 + 1 = 4.\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length <= 1000\n\twords[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 2590081,
                "title": "c-java-python3-easy-trie-explained-with-diagram",
                "content": "\\n\\nWe construct a trie to find the number of times each node has been visited.\\n\\nIterate over `[\"abc\",\"ab\",\"bc\",\"b\"]` and the trie looks like:\\n![image](https://assets.leetcode.com/users/images/6f8b9a77-e532-400a-8a61-e14a5eec57c9_1663473172.2202284.png)\\n\\n* After constructing the `trie` we just iterate over the given array one more time and find how many times each node corresponding to each character in the `trie` has been visited\\n* Then we just need to find the sum of visited per word and append it to our answer. In the code `curr` denoted the sum per node\\n* `ch` denotes the children of the current trie node. Each trie node can have a max of 26 children since we are only considering lowercase english alphabets\\n\\n<iframe src=\"https://leetcode.com/playground/Z69Nqbky/shared\" frameBorder=\"0\" width=\"550\" height=\"580\"></iframe>\\n\\nTime complexity: O(total characters in all words)",
                "solutionTags": [],
                "code": "\\n\\nWe construct a trie to find the number of times each node has been visited.\\n\\nIterate over `[\"abc\",\"ab\",\"bc\",\"b\"]` and the trie looks like:\\n![image](https://assets.leetcode.com/users/images/6f8b9a77-e532-400a-8a61-e14a5eec57c9_1663473172.2202284.png)\\n\\n* After constructing the `trie` we just iterate over the given array one more time and find how many times each node corresponding to each character in the `trie` has been visited\\n* Then we just need to find the sum of visited per word and append it to our answer. In the code `curr` denoted the sum per node\\n* `ch` denotes the children of the current trie node. Each trie node can have a max of 26 children since we are only considering lowercase english alphabets\\n\\n<iframe src=\"https://leetcode.com/playground/Z69Nqbky/shared\" frameBorder=\"0\" width=\"550\" height=\"580\"></iframe>\\n\\nTime complexity: O(total characters in all words)",
                "codeTag": "Unknown"
            },
            {
                "id": 2590087,
                "title": "c-trie-related-problems",
                "content": "- Store each string in trie and **add 1 to each prefix of string while inserting**.\\n- Then, for each string, **we sum up the count for all its prefixes**.\\n![image](https://assets.leetcode.com/users/images/fde5fc03-7578-4e5f-91e4-570837f1057a_1663474247.6931121.png)\\n\\n\\n```cpp\\nstruct TrieNode {\\n    TrieNode *next[26] = {};\\n    int cnt = 0;\\n};\\n\\nclass Solution {\\n    TrieNode root;\\npublic:\\n    void insert(string word) {\\n        auto node = &root;\\n        for(char c : word) {\\n            if(!node->next[c - \\'a\\']) {\\n                node->next[c - \\'a\\'] = new TrieNode();\\n            } \\n            node->next[c - \\'a\\']->cnt++;\\n            node = node->next[c - \\'a\\'];   \\n        }\\n    }\\n\\n    int prefixCnt(string s) {\\n        auto node = &root;\\n        int ans = 0;\\n        for(char c : s) {\\n            ans += node->next[c - \\'a\\']->cnt;\\n            node = node->next[c - \\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        int N = words.size();\\n\\t\\t// Insert words in trie.\\n        for (int i = 0; i < N; i++) {\\n                insert(words[i]);\\n        }\\n        vector<int> ans(N, 0);\\n        for (int i = 0; i < N; i++) {\\n\\t\\t\\t// Get the count of all prefixes of given string.\\n            ans[i] = prefixCnt(words[i]); \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Trie Related Problems**\\n[1. Implement Trie (Prefix Tree) ](https://leetcode.com/problems/implement-trie-prefix-tree/)\\n[2. Palindrome Pairs ](https://leetcode.com/problems/palindrome-pairs/)\\n[3. Maximum XOR of Two Numbers in an Array ](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\n[4. Concatenated Words ](https://leetcode.com/problems/concatenated-words/)\\n[5. Search Suggestions System ](https://leetcode.com/problems/search-suggestions-system/)\\n",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```cpp\\nstruct TrieNode {\\n    TrieNode *next[26] = {};\\n    int cnt = 0;\\n};\\n\\nclass Solution {\\n    TrieNode root;\\npublic:\\n    void insert(string word) {\\n        auto node = &root;\\n        for(char c : word) {\\n            if(!node->next[c - \\'a\\']) {\\n                node->next[c - \\'a\\'] = new TrieNode();\\n            } \\n            node->next[c - \\'a\\']->cnt++;\\n            node = node->next[c - \\'a\\'];   \\n        }\\n    }\\n\\n    int prefixCnt(string s) {\\n        auto node = &root;\\n        int ans = 0;\\n        for(char c : s) {\\n            ans += node->next[c - \\'a\\']->cnt;\\n            node = node->next[c - \\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        int N = words.size();\\n\\t\\t// Insert words in trie.\\n        for (int i = 0; i < N; i++) {\\n                insert(words[i]);\\n        }\\n        vector<int> ans(N, 0);\\n        for (int i = 0; i < N; i++) {\\n\\t\\t\\t// Get the count of all prefixes of given string.\\n            ans[i] = prefixCnt(words[i]); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590146,
                "title": "python-explanation-with-pictures-2-solutions",
                "content": "### Solution 1. Counter of prefix\\n\\nUse counter `C` to collect every prefix of every word. \\nThen sum up `C[pre]` for every prefix `pre` of word `word`, this is the score of `word`.\\n\\n**python**\\n\\n```\\nclass Solution:\\n    def sumPrefixScores(self, W: List[str]) -> List[int]:\\n        C = collections.defaultdict(int)\\n        for w in W:\\n            for i in range(len(w)):\\n                C[w[:i + 1]] += 1\\n                \\n        ans = []\\n        for w in W:\\n            curr = 0\\n            for i in range(len(w)):\\n                curr += C[w[:i + 1]]\\n            ans.append(curr)\\n            \\n        return ans\\n```\\n\\n<br>\\n<br>\\n\\n### Solution 2. Trie\\n\\nTake a look at how we build `trie`.\\n\\n![image](https://assets.leetcode.com/users/images/11a6d46a-44cd-4d8f-94a7-cd1ca5b14d1f_1663473701.177221.png)\\n\\nInsert `abc`.\\n\\n![image](https://assets.leetcode.com/users/images/05a58711-9c01-4edc-9071-2963879350ee_1663473704.8254855.png)\\n\\nInsert `ab`.\\n\\n![image](https://assets.leetcode.com/users/images/090d6123-0dd7-4f6e-b7b7-d96af187bf78_1663473707.7719986.png)\\n\\nInsert `b`.\\n\\n![image](https://assets.leetcode.com/users/images/3cda1658-6224-4212-b8f8-f3f4b254287b_1663473710.8782887.png)\\n\\nInsert `bc`.\\n\\n![image](https://assets.leetcode.com/users/images/d6e7474b-081a-4f40-8577-b9dfc735397c_1663473713.8538272.png)\\n\\nCount the score of `ab`.\\n\\n![image](https://assets.leetcode.com/users/images/9d5e4a25-a9f1-4d44-b0b8-543534c7a0e0_1663473716.9975448.png)\\n\\n**python**\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.cnt = 0\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.trie = Node()\\n    def insert(self, word):\\n        node = self.trie\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = Node()\\n            node = node.children[ch]\\n            node.cnt += 1\\n    def count(self, word):\\n        node = self.trie\\n        ans = 0\\n        for ch in word:\\n            ans += node.children[ch].cnt\\n            node = node.children[ch]\\n        return ans\\n\\nclass Solution:\\n    def sumPrefixScores(self, A: List[str]) -> List[int]:\\n        trie = Trie()\\n\\n        for a in A:\\n            trie.insert(a)\\n\\n        return [trie.count(a) for a in A]\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, W: List[str]) -> List[int]:\\n        C = collections.defaultdict(int)\\n        for w in W:\\n            for i in range(len(w)):\\n                C[w[:i + 1]] += 1\\n                \\n        ans = []\\n        for w in W:\\n            curr = 0\\n            for i in range(len(w)):\\n                curr += C[w[:i + 1]]\\n            ans.append(curr)\\n            \\n        return ans\\n```\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.cnt = 0\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.trie = Node()\\n    def insert(self, word):\\n        node = self.trie\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = Node()\\n            node = node.children[ch]\\n            node.cnt += 1\\n    def count(self, word):\\n        node = self.trie\\n        ans = 0\\n        for ch in word:\\n            ans += node.children[ch].cnt\\n            node = node.children[ch]\\n        return ans\\n\\nclass Solution:\\n    def sumPrefixScores(self, A: List[str]) -> List[int]:\\n        trie = Trie()\\n\\n        for a in A:\\n            trie.insert(a)\\n\\n        return [trie.count(a) for a in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590163,
                "title": "python3-simple-trie-o-n-k-with-line-by-line-comments",
                "content": "The idea is to use trie. When initializing the trie, instead of storing the end of the word, we are tracking the number of times this prefix has occurred.\\nOnce we have the trie, we will go through all the words one more time and count how many times its prefix has occurred to build our result.\\n\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = {} ### Initialize a hash map for trie\\n        for w in words:\\n            cur = trie ### At the begining of each word, the pointer should point to the begining of the trie\\n            for c in w:\\n                ### Go through each letter to build the trie.\\n                if c not in cur:\\n                    cur[c] = {}\\n                cur = cur[c]\\n                ### Instead of store the end of the word in the regular trie, \\n                ### we are storing the occurrences of the prefix at each letter\\n                if \\'count\\' not in cur:\\n                    cur[\\'count\\'] = 0\\n                cur[\\'count\\'] += 1\\n        res = []\\n        ### Go through each word one more time to build the result\\n        for w in words:\\n            cur = trie ### Pointer point to the begining of the trie\\n            count = 0 ### Keep track the count of the occurrences of each prefix (letter) in this word\\n            for c in w:\\n                cur = cur[c]\\n                ### At each letter, we add the count we previously stored. \\n                ### This is the number of occurrence of this prefix among all words.\\n                count += cur[\\'count\\']\\n            res.append(count)\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = {} ### Initialize a hash map for trie\\n        for w in words:\\n            cur = trie ### At the begining of each word, the pointer should point to the begining of the trie\\n            for c in w:\\n                ### Go through each letter to build the trie.\\n                if c not in cur:\\n                    cur[c] = {}\\n                cur = cur[c]\\n                ### Instead of store the end of the word in the regular trie, \\n                ### we are storing the occurrences of the prefix at each letter\\n                if \\'count\\' not in cur:\\n                    cur[\\'count\\'] = 0\\n                cur[\\'count\\'] += 1\\n        res = []\\n        ### Go through each word one more time to build the result\\n        for w in words:\\n            cur = trie ### Pointer point to the begining of the trie\\n            count = 0 ### Keep track the count of the occurrences of each prefix (letter) in this word\\n            for c in w:\\n                cur = cur[c]\\n                ### At each letter, we add the count we previously stored. \\n                ### This is the number of occurrence of this prefix among all words.\\n                count += cur[\\'count\\']\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590148,
                "title": "trie",
                "content": "\\nFirst, we add all strings into a Trie, incrementing the count for each prefix.\\n    \\nThen, for each string, we aggregate the count for all its prefixes. \\n    \\n**C++**\\n```cpp\\nstruct Trie {\\n    Trie* ch[26] = {};\\n    int cnt = 0;\\n    void insert(string &w, int i = 0) {\\n        auto n = this;\\n        for (auto c : w) {\\n            if (n->ch[c - \\'a\\'] == nullptr)\\n                n->ch[c - \\'a\\'] = new Trie();\\n            n = n->ch[c - \\'a\\'];\\n            ++n->cnt;\\n        }\\n    }\\n    int count(string &w, int i = 0) {\\n        return cnt + (i == w.size() ? 0 : ch[w[i] - \\'a\\']->count(w, i + 1));\\n    }\\n}; \\nvector<int> sumPrefixScores(vector<string>& words) {\\n    Trie t;\\n    for (auto &w : words)\\n        t.insert(w);\\n    vector<int> res;\\n    for (auto &w : words)\\n        res.push_back(t.count(w));\\n    return res;\\n}\\n// ```",
                "solutionTags": [],
                "code": "```cpp\\nstruct Trie {\\n    Trie* ch[26] = {};\\n    int cnt = 0;\\n    void insert(string &w, int i = 0) {\\n        auto n = this;\\n        for (auto c : w) {\\n            if (n->ch[c - \\'a\\'] == nullptr)\\n                n->ch[c - \\'a\\'] = new Trie();\\n            n = n->ch[c - \\'a\\'];\\n            ++n->cnt;\\n        }\\n    }\\n    int count(string &w, int i = 0) {\\n        return cnt + (i == w.size() ? 0 : ch[w[i] - \\'a\\']->count(w, i + 1));\\n    }\\n}; \\nvector<int> sumPrefixScores(vector<string>& words) {\\n    Trie t;\\n    for (auto &w : words)\\n        t.insert(w);\\n    vector<int> res;\\n    for (auto &w : words)\\n        res.push_back(t.count(w));\\n    return res;\\n}\\n// ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590036,
                "title": "trie-java",
                "content": "**Code:**\\n\\n    Node root = new Node();  // Trie root.\\n    class Node {\\n        int score = 0;\\n        Node[] child = new Node[26];\\n    }\\n    \\n    public int[] sumPrefixScores(String[] words) {\\n        for(String word : words) add(word); // make trie.\\n        \\n        int [] res = new int[words.length];\\n        for(int i=0; i<res.length; i++)\\n            res[i] = calc(words[i]);  // build scores.\\n        return res;\\n    }\\n    \\n    void add(String str){\\n        Node temp = root;\\n        for(char ch : str.toCharArray()){\\n            if(temp.child[ch-\\'a\\']==null)\\n                temp.child[ch-\\'a\\'] = new Node();\\n            temp.child[ch-\\'a\\'].score++;\\n            temp = temp.child[ch-\\'a\\'];\\n        }\\n    }\\n    \\n    int calc(String str){\\n        int ans = 0;\\n        Node temp = root;\\n        for(char ch : str.toCharArray()){\\n            ans += temp.child[ch-\\'a\\'].score;\\n            temp = temp.child[ch-\\'a\\'];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "**Code:**\\n\\n    Node root = new Node();  // Trie root.\\n    class Node {\\n        int score = 0;\\n        Node[] child = new Node[26];\\n    }\\n    \\n    public int[] sumPrefixScores(String[] words) {\\n        for(String word : words) add(word); // make trie.\\n        \\n        int [] res = new int[words.length];\\n        for(int i=0; i<res.length; i++)\\n            res[i] = calc(words[i]);  // build scores.\\n        return res;\\n    }\\n    \\n    void add(String str){\\n        Node temp = root;\\n        for(char ch : str.toCharArray()){\\n            if(temp.child[ch-\\'a\\']==null)\\n                temp.child[ch-\\'a\\'] = new Node();\\n            temp.child[ch-\\'a\\'].score++;\\n            temp = temp.child[ch-\\'a\\'];\\n        }\\n    }\\n    \\n    int calc(String str){\\n        int ans = 0;\\n        Node temp = root;\\n        for(char ch : str.toCharArray()){\\n            ans += temp.child[ch-\\'a\\'].score;\\n            temp = temp.child[ch-\\'a\\'];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2591754,
                "title": "c-detailed-explanation-w-diagram-easy-and-commented-code-simple-language",
                "content": "**IDEA:**\\n* We store each word of the words array in the trie.\\n* Every Node of the trie contains two arrays of size 26.\\n* First array denotes the characters of english alphabets i.e index 0 denotes character \\'a\\', index 1 denotes character \\'b\\'... like this.\\n* Second array number denotes how many number of times we visited here.\\n* Lastly we simply traverse each word and take out the answer.\\n* See images for better clarification.\\n___________\\n![image](https://assets.leetcode.com/users/images/771e005c-2162-4047-ba3a-35ff6299f9d5_1663486810.0475035.jpeg)\\n![image](https://assets.leetcode.com/users/images/3146ce46-1250-40c7-9c7f-e29df6a531dc_1663486839.4647455.jpeg)\\n___________\\n```\\nSee commented code :)\\n```\\n____\\n**C++**\\n```\\n// how a trie node looks like\\nstruct Node \\n{\\n    Node* links[26]; // for 26 characters\\n    int number[26] = {0}; // number array \\n    \\n    bool containsKey(char ch) // function to check if it present or not\\n    {\\n        return (links[ch - \\'a\\'] != NULL);\\n    }\\n    \\n    void put(char ch, Node* node) \\n    {\\n        links[ch - \\'a\\'] = node; // put a character\\n        number[ch - \\'a\\'] = 1; // since we are putting this character, so we visit this character first time\\n    }\\n    \\n    Node* get(char ch) // make a link to the character\\n    {\\n        return links[ch - \\'a\\'];\\n    }\\n    \\n    void increaseNum(char ch) // we increase the count of visit\\n    {\\n        number[ch - \\'a\\']++;\\n    }\\n    \\n    int getNum(char ch) // to retrive how many many number of times we visit this\\n    {\\n        return number[ch - \\'a\\'];\\n    }\\n    \\n};\\n\\nclass Trie {\\npublic:\\n    Node* root; // make root node\\n    Trie() {\\n        root = new Node(); // accquiring memory for the root node\\n        \\n    }\\n    \\n    void insert(string word) \\n    {\\n        Node* node = root; // make a dummy pointer for the root node\\n        \\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            // if on the node i m currently standing does \\n            // not contain this particular character of word[i]\\n            // so for this we have to make a new referenced node\\n            if(!node -> containsKey(word[i]))\\n            {\\n                node -> put(word[i], new Node());\\n            } \\n            else // else if already present that means we see this character again so increase nums\\n             node -> increaseNum(word[i]);\\n            \\n            // after this move to this referenced node\\n            node = node -> get(word[i]);\\n        }\\n    }\\n    \\n    // it will give me answer for each word\\n    int takeAns(string word)\\n    {\\n        int ans = 0; // to count my answer\\n        \\n        Node* node = root; // make a dummy pointer for the root node\\n        \\n        for(int i = 0; i < word.size(); i++)\\n        {\\n            if(!node -> containsKey(word[i]))  // if trie does not contain this particular character, so return answer from here\\n                return ans;\\n            else \\n                ans += node -> getNum(word[i]); // else add to answer\\n            \\n             node = node -> get(word[i]); // and move to next referenced node\\n        }\\n        \\n        return ans; // finally return answer\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        int n = words.size(); // extract size of words array\\n        \\n        Trie trie; // define object for class trie\\n        \\n        // put all strings of words array into the trie\\n        for(int i = 0; i < n; i++)\\n        {\\n            trie.insert(words[i]);\\n        }\\n        \\n        vector<int> ans(n); // vector that contains my answer\\n \\n        // extract answer for each word\\n        for(int i = 0; i < n; i++)\\n        {\\n            ans[i] = trie.takeAns(words[i]);\\n        }\\n        \\n        return ans; // finally return answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nSee commented code :)\\n```\n```\\n// how a trie node looks like\\nstruct Node \\n{\\n    Node* links[26]; // for 26 characters\\n    int number[26] = {0}; // number array \\n    \\n    bool containsKey(char ch) // function to check if it present or not\\n    {\\n        return (links[ch - \\'a\\'] != NULL);\\n    }\\n    \\n    void put(char ch, Node* node) \\n    {\\n        links[ch - \\'a\\'] = node; // put a character\\n        number[ch - \\'a\\'] = 1; // since we are putting this character, so we visit this character first time\\n    }\\n    \\n    Node* get(char ch) // make a link to the character\\n    {\\n        return links[ch - \\'a\\'];\\n    }\\n    \\n    void increaseNum(char ch) // we increase the count of visit\\n    {\\n        number[ch - \\'a\\']++;\\n    }\\n    \\n    int getNum(char ch) // to retrive how many many number of times we visit this\\n    {\\n        return number[ch - \\'a\\'];\\n    }\\n    \\n};\\n\\nclass Trie {\\npublic:\\n    Node* root; // make root node\\n    Trie() {\\n        root = new Node(); // accquiring memory for the root node\\n        \\n    }\\n    \\n    void insert(string word) \\n    {\\n        Node* node = root; // make a dummy pointer for the root node\\n        \\n        for(int i = 0; i < word.length(); i++)\\n        {\\n            // if on the node i m currently standing does \\n            // not contain this particular character of word[i]\\n            // so for this we have to make a new referenced node\\n            if(!node -> containsKey(word[i]))\\n            {\\n                node -> put(word[i], new Node());\\n            } \\n            else // else if already present that means we see this character again so increase nums\\n             node -> increaseNum(word[i]);\\n            \\n            // after this move to this referenced node\\n            node = node -> get(word[i]);\\n        }\\n    }\\n    \\n    // it will give me answer for each word\\n    int takeAns(string word)\\n    {\\n        int ans = 0; // to count my answer\\n        \\n        Node* node = root; // make a dummy pointer for the root node\\n        \\n        for(int i = 0; i < word.size(); i++)\\n        {\\n            if(!node -> containsKey(word[i]))  // if trie does not contain this particular character, so return answer from here\\n                return ans;\\n            else \\n                ans += node -> getNum(word[i]); // else add to answer\\n            \\n             node = node -> get(word[i]); // and move to next referenced node\\n        }\\n        \\n        return ans; // finally return answer\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        int n = words.size(); // extract size of words array\\n        \\n        Trie trie; // define object for class trie\\n        \\n        // put all strings of words array into the trie\\n        for(int i = 0; i < n; i++)\\n        {\\n            trie.insert(words[i]);\\n        }\\n        \\n        vector<int> ans(n); // vector that contains my answer\\n \\n        // extract answer for each word\\n        for(int i = 0; i < n; i++)\\n        {\\n            ans[i] = trie.takeAns(words[i]);\\n        }\\n        \\n        return ans; // finally return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590196,
                "title": "thought-process-explained-trie-for-beginner",
                "content": "## So First question?\\n* How I got to know that Trie will work.\\n\\t* So let\\'s thing :\\n\\t* We have 1000 words of 1000 length each. Also we have to get the value for substring also.\\n\\t\\t* Will HashMap works? No because for 1k word of 1k length, going to store all substring that would cause TLE.\\n\\t* So let\\'s think somethink else :\\n\\t\\t* We don\\'t want to generate substring of string.\\n\\t\\t* We want to get the res of [0-i-th] substring contest time.\\n\\t\\t* We also want to store the freq.\\n\\t\\t* So from above point it\\'s clear that,\\n\\t\\t\\t* If we can store frequency of each substring [0,ith] and get the value for any string in O(N) that will help here.\\n\\t\\t\\t* This point revoked my to use Trie.\\n\\t\\t\\t* So Data Structure like trie, we have first problem, What data trie will contains and how to handle it?\\n\\t\\t\\t* for that let\\'s think what data we need except basic Structure of Trie?\\n\\t\\t\\t\\t* At any i-th position in string what we want?\\n\\t\\t\\t\\t\\t* Number of times this subtring [0, ith] appeared in entire list.\\n\\t\\t\\t\\t\\t* That\\'s means number of time current node visited. Right?\\n\\t\\t\\t\\t\\t* Storing count for each node would help.\\n\\nSo from above point we come up with conclusioin to use Trie with bellow Structure.\\n```\\nclass Trie {\\n    public :\\n    unordered_map<char, Trie*> children;\\n    int cnt;\\n    Trie() {\\n        cnt = 0;\\n    }\\n    int getCnt() {\\n        return cnt;\\n    }\\n};\\n```\\n\\n## Now let\\'s implement :\\n* First insert all the string from given list into the Trie.\\n* Traverse trie and for each string, at keep sum of number of times all node visited which came in the path of string i-th\\n* This count is your answer.\\n\\n```\\nclass Solution {\\npublic:\\n    Trie *trie;\\n    void insert(string &str) {\\n        Trie * temp = trie;\\n        for(char &ch : str) {\\n            if(temp->children.count(ch) == 0) {\\n                temp->children[ch] = new Trie();\\n            }\\n            temp = temp->children[ch];\\n            temp->cnt++;\\n        }\\n    }\\n    \\n    int getCnt(string &s) {\\n        int cnt = 0;\\n        Trie *root = trie;\\n        for(char &ch : s) {\\n            cnt+=root->getCnt();\\n            root = root->children[ch];\\n        }\\n        return cnt+root->getCnt();\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        trie = new Trie();\\n        for(string &s : words) insert(s);\\n        vector<int> res;\\n        for(string &s : words) {\\n            res.push_back(getCnt(s));\\n        }\\n        return res;\\n    }\\n```\\n\\n## Time Complexity \\n* Inserting and traversing String into Trie will cause of O(N).\\n* So for N string it\\'ll be O(N*N) that would be accepted.\\n\\n## Space Complexity\\n* Space complexity will be O(alphabet_size * average key length * N).\\n\\n\\n**Please upvote if it helps.**\\n**Happy Coding**",
                "solutionTags": [],
                "code": "```\\nclass Trie {\\n    public :\\n    unordered_map<char, Trie*> children;\\n    int cnt;\\n    Trie() {\\n        cnt = 0;\\n    }\\n    int getCnt() {\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Trie *trie;\\n    void insert(string &str) {\\n        Trie * temp = trie;\\n        for(char &ch : str) {\\n            if(temp->children.count(ch) == 0) {\\n                temp->children[ch] = new Trie();\\n            }\\n            temp = temp->children[ch];\\n            temp->cnt++;\\n        }\\n    }\\n    \\n    int getCnt(string &s) {\\n        int cnt = 0;\\n        Trie *root = trie;\\n        for(char &ch : s) {\\n            cnt+=root->getCnt();\\n            root = root->children[ch];\\n        }\\n        return cnt+root->getCnt();\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        trie = new Trie();\\n        for(string &s : words) insert(s);\\n        vector<int> res;\\n        for(string &s : words) {\\n            res.push_back(getCnt(s));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590697,
                "title": "c-no-trie-nlogn-solution",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> sumPrefixScores(vector<string>& words) {\\n\\t\\t\\t\\tint n = words.size();\\n\\t\\t\\t\\tvector<pair<string, int>> words2;\\n\\t\\t\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t\\t\\twords2.push_back(make_pair(words[i], i));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsort(words2.begin(), words2.end());\\n\\n\\t\\t\\t\\tvector<int> perm(n);\\n\\t\\t\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t\\t\\tperm[i] = words2[i].second;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<int> commonPrefix(n);\\n\\n\\t\\t\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\t\\t\\tstring const& w1 = words2[i - 1].first;\\n\\t\\t\\t\\t\\tstring const& w2 = words2[i].first;\\n\\t\\t\\t\\t\\tint l = min(w1.size(), w2.size());\\n\\t\\t\\t\\t\\tint p = 0;\\n\\t\\t\\t\\t\\twhile (p < l && w1[p] == w2[p]) {\\n\\t\\t\\t\\t\\t\\t++p;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcommonPrefix[i] = p;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvector<int> ret(n);\\n\\t\\t\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t\\t\\tint prefix = words2[i].first.size();\\n\\t\\t\\t\\t\\tret[perm[i]] += prefix;\\n\\t\\t\\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n\\t\\t\\t\\t\\t\\tprefix = min(prefix, commonPrefix[j]);\\n\\t\\t\\t\\t\\t\\tif (prefix == 0) {\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tret[perm[i]] += prefix;\\n\\t\\t\\t\\t\\t\\tret[perm[j]] += prefix;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> sumPrefixScores(vector<string>& words) {\\n\\t\\t\\t\\tint n = words.size();\\n\\t\\t\\t\\tvector<pair<string, int>> words2;\\n\\t\\t\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\t\\t\\twords2.push_back(make_pair(words[i], i));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2590609,
                "title": "java-python-3-trie-build-search-prefix-w-brief-explanation-and-analysis",
                "content": "Build Trie and accumulate the frequencies of each pefix at the same time; then search each word and compute the corresponding score.\\n\\n```java\\nclass Trie {\\n    int cnt = 0;\\n    Map<Character, Trie> kids = new HashMap<>();\\n    public void add(String word) {\\n        Trie t = this;\\n        for (char c : word.toCharArray()) {\\n            if (!t.kids.containsKey(c)) {\\n                t.kids.put(c, new Trie());\\n            }\\n            t = t.kids.get(c);\\n            t.cnt += 1;\\n        }\\n    }\\n    public int search(String word) {\\n        Trie t = this;\\n        int score = 0;\\n        for (char c : word.toCharArray()) {\\n            if (t.kids.get(c) == null) {\\n                 return score;\\n            }\\n            t = t.kids.get(c);\\n            score += t.cnt;\\n        }\\n        return score;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        Trie root = new Trie();\\n        for (String word : words) {\\n            root.add(word);\\n        }\\n        int n = words.length, i = 0;\\n        int[] scores = new int[n];\\n        for (String word : words) {\\n            scores[i++] = root.search(word);\\n        }\\n        return scores;\\n    }\\n}\\n```\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.cnt = 0\\n        self.kids = {}\\n    def add(self, word: str) -> None:\\n        trie = self\\n        for c in word:\\n            if c not in trie.kids:\\n                trie.kids[c] = Trie()\\n            trie = trie.kids[c]\\n            trie.cnt += 1\\n    def search(self, word) -> int:\\n        score = 0\\n        trie = self\\n        for c in word:\\n            if c not in trie.kids:\\n                return score\\n            trie = trie.kids[c]        \\n            score += trie.cnt\\n        return score\\n    \\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        root = Trie()\\n        for w in words:\\n            root.add(w)\\n        return [root.search(w) for w in words]\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n * w)`, where `n = words.length, w =` average size of word in `words`.",
                "solutionTags": [],
                "code": "```java\\nclass Trie {\\n    int cnt = 0;\\n    Map<Character, Trie> kids = new HashMap<>();\\n    public void add(String word) {\\n        Trie t = this;\\n        for (char c : word.toCharArray()) {\\n            if (!t.kids.containsKey(c)) {\\n                t.kids.put(c, new Trie());\\n            }\\n            t = t.kids.get(c);\\n            t.cnt += 1;\\n        }\\n    }\\n    public int search(String word) {\\n        Trie t = this;\\n        int score = 0;\\n        for (char c : word.toCharArray()) {\\n            if (t.kids.get(c) == null) {\\n                 return score;\\n            }\\n            t = t.kids.get(c);\\n            score += t.cnt;\\n        }\\n        return score;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        Trie root = new Trie();\\n        for (String word : words) {\\n            root.add(word);\\n        }\\n        int n = words.length, i = 0;\\n        int[] scores = new int[n];\\n        for (String word : words) {\\n            scores[i++] = root.search(word);\\n        }\\n        return scores;\\n    }\\n}\\n```\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.cnt = 0\\n        self.kids = {}\\n    def add(self, word: str) -> None:\\n        trie = self\\n        for c in word:\\n            if c not in trie.kids:\\n                trie.kids[c] = Trie()\\n            trie = trie.kids[c]\\n            trie.cnt += 1\\n    def search(self, word) -> int:\\n        score = 0\\n        trie = self\\n        for c in word:\\n            if c not in trie.kids:\\n                return score\\n            trie = trie.kids[c]        \\n            score += trie.cnt\\n        return score\\n    \\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        root = Trie()\\n        for w in words:\\n            root.add(w)\\n        return [root.search(w) for w in words]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590511,
                "title": "don-t-trie-simple-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<long long,int> mp;\\n    long long base = 31 , pw = 1 , mod = 1011001110001111;\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n         vector<int> ans;\\n         for(string s : words) {\\n             long long hash = 0 , pw = 1;\\n             for(int j=0; j<s.size(); j++) {\\n                   mp[hash = (hash + (pw * (s[j] -\\'a\\' + 1)) % mod)%mod]++;\\n                   pw = (pw * base) % mod;\\n             }\\n         }\\n          for(string s : words) {\\n             long long hash = 0 , pw = 1;\\n             int cnt = 0;\\n             for(int j=0; j<s.size(); j++) {\\n                   cnt+=mp[hash = (hash + (pw * (s[j] -\\'a\\' + 1)) % mod)%mod];\\n                   pw = (pw * base) % mod;\\n             }\\n             ans.push_back(cnt); \\n         }\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<long long,int> mp;\\n    long long base = 31 , pw = 1 , mod = 1011001110001111;\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n         vector<int> ans;\\n         for(string s : words) {\\n             long long hash = 0 , pw = 1;\\n             for(int j=0; j<s.size(); j++) {\\n                   mp[hash = (hash + (pw * (s[j] -\\'a\\' + 1)) % mod)%mod]++;\\n                   pw = (pw * base) % mod;\\n             }\\n         }\\n          for(string s : words) {\\n             long long hash = 0 , pw = 1;\\n             int cnt = 0;\\n             for(int j=0; j<s.size(); j++) {\\n                   cnt+=mp[hash = (hash + (pw * (s[j] -\\'a\\' + 1)) % mod)%mod];\\n                   pw = (pw * base) % mod;\\n             }\\n             ans.push_back(cnt); \\n         }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590358,
                "title": "c-trie-searching",
                "content": "```\\nclass Solution {\\npublic:\\n    class Trie {\\n    public:\\n        Trie() {\\n            cnt = 0;\\n            for(int i=0;i<26;i++){\\n                this->next[i] = NULL;\\n            }\\n        }\\n        void insert(string word, Trie* root) {\\n            Trie* node = root;\\n            int i = 0;\\n            for (char ch : word) {\\n                ch -= \\'a\\';\\n                if (!node->next[ch]) { node->next[ch] = new Trie(); }\\n                node->next[ch]->cnt++;\\n                node = node->next[ch];\\n                i++;\\n            }\\n        }\\n\\n        int search(char ch, Trie* node) {\\n            return node->next[ch-\\'a\\']->cnt;\\n        }\\n\\n        Trie* next[26] = {};\\n        int cnt;\\n    };\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie t;\\n        Trie *root = new Trie();\\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            t.insert(words[i], root);\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            string cur = \"\";\\n            int c = 0;\\n            Trie *node = root;\\n            for(int j=0;j<words[i].length();j++){\\n                c += t.search(words[i][j], node);;\\n                if(node->next[words[i][j]-\\'a\\'] == NULL) break;\\n                node = node->next[words[i][j]-\\'a\\'];\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Trie {\\n    public:\\n        Trie() {\\n            cnt = 0;\\n            for(int i=0;i<26;i++){\\n                this->next[i] = NULL;\\n            }\\n        }\\n        void insert(string word, Trie* root) {\\n            Trie* node = root;\\n            int i = 0;\\n            for (char ch : word) {\\n                ch -= \\'a\\';\\n                if (!node->next[ch]) { node->next[ch] = new Trie(); }\\n                node->next[ch]->cnt++;\\n                node = node->next[ch];\\n                i++;\\n            }\\n        }\\n\\n        int search(char ch, Trie* node) {\\n            return node->next[ch-\\'a\\']->cnt;\\n        }\\n\\n        Trie* next[26] = {};\\n        int cnt;\\n    };\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie t;\\n        Trie *root = new Trie();\\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            t.insert(words[i], root);\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            string cur = \"\";\\n            int c = 0;\\n            Trie *node = root;\\n            for(int j=0;j<words[i].length();j++){\\n                c += t.search(words[i][j], node);;\\n                if(node->next[words[i][j]-\\'a\\'] == NULL) break;\\n                node = node->next[words[i][j]-\\'a\\'];\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590356,
                "title": "python-trie-solution",
                "content": "# **Explanation**\\nUse Trie to build up a tree.\\n`add` word and add `1` point to each node on the word path.\\n`socre` will sum up the point on the word path.\\n<br>\\n\\n# **Complexity**\\nTime `O(words)`\\nSpace `O(words)`\\n<br>\\n\\n\\n**Python**\\n```py\\nclass Trie(object):\\n\\n    def __init__(self):\\n        T = lambda: defaultdict(T)\\n        self.root = T()\\n\\n    def add(self, word):\\n        node = self.root\\n        for w in word:\\n            node = node[w]\\n            node[\\'#\\'] = node.get(\\'#\\', 0) + 1\\n\\n    def score(self, word):\\n        res = 0\\n        node = self.root\\n        for w in word:\\n            node = node[w]\\n            res += node.get(\\'#\\', 0)\\n        return res\\n\\nclass Solution(object):\\n    def sumPrefixScores(self, words):\\n        trie = Trie()\\n        list(map(trie.add, words))\\n        return list(map(trie.score, words))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\nclass Trie(object):\\n\\n    def __init__(self):\\n        T = lambda: defaultdict(T)\\n        self.root = T()\\n\\n    def add(self, word):\\n        node = self.root\\n        for w in word:\\n            node = node[w]\\n            node[\\'#\\'] = node.get(\\'#\\', 0) + 1\\n\\n    def score(self, word):\\n        res = 0\\n        node = self.root\\n        for w in word:\\n            node = node[w]\\n            res += node.get(\\'#\\', 0)\\n        return res\\n\\nclass Solution(object):\\n    def sumPrefixScores(self, words):\\n        trie = Trie()\\n        list(map(trie.add, words))\\n        return list(map(trie.score, words))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590701,
                "title": "concise-python-tire-implementation",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.next = {}\\n        self.score = 0\\n\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        result = []\\n        \\n        root = TrieNode()\\n        \\n        # build the trie\\n        for i, word in enumerate(words):\\n            node = root\\n            for j, c in enumerate(word):\\n                if c not in node.next:\\n                    node.next[c] = TrieNode()\\n                node.next[c].score += 1\\n                node = node.next[c]\\n        \\n        # get the scores\\n        for i, word in enumerate(words):\\n            node = root\\n            sum_score = 0\\n            for j, c in enumerate(word):\\n                sum_score += node.score\\n                node = node.next[c]\\n            sum_score += node.score\\n            result.append(sum_score)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.next = {}\\n        self.score = 0\\n\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        result = []\\n        \\n        root = TrieNode()\\n        \\n        # build the trie\\n        for i, word in enumerate(words):\\n            node = root\\n            for j, c in enumerate(word):\\n                if c not in node.next:\\n                    node.next[c] = TrieNode()\\n                node.next[c].score += 1\\n                node = node.next[c]\\n        \\n        # get the scores\\n        for i, word in enumerate(words):\\n            node = root\\n            sum_score = 0\\n            for j, c in enumerate(word):\\n                sum_score += node.score\\n                node = node.next[c]\\n            sum_score += node.score\\n            result.append(sum_score)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590488,
                "title": "string-hashing-java",
                "content": "```\\npublic int[] sumPrefixScores(String[] words) {\\n    int n = words.length, p = 31, m = (int)1e9 + 9;\\n    int[] ans = new int[n];\\n    long[] hash = new long[n], p_pow = new long[n];\\n    Arrays.fill(p_pow,1);\\n    for(int i = 0; i < 1000; i++){\\n        Map<Long,Integer> map = new HashMap<>();\\n        for(int j = 0; j < n; j++){\\n            if(words[j].length() <= i) continue;\\n            hash[j] = (hash[j] + (words[j].charAt(i) - \\'a\\' + 1) * p_pow[j]) % m;\\n            p_pow[j] = (p_pow[j] * p) % m;\\n            map.put(hash[j], map.getOrDefault(hash[j],0) + 1);\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(words[j].length() <= i) continue;\\n            ans[j] += map.get(hash[j]);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sumPrefixScores(String[] words) {\\n    int n = words.length, p = 31, m = (int)1e9 + 9;\\n    int[] ans = new int[n];\\n    long[] hash = new long[n], p_pow = new long[n];\\n    Arrays.fill(p_pow,1);\\n    for(int i = 0; i < 1000; i++){\\n        Map<Long,Integer> map = new HashMap<>();\\n        for(int j = 0; j < n; j++){\\n            if(words[j].length() <= i) continue;\\n            hash[j] = (hash[j] + (words[j].charAt(i) - \\'a\\' + 1) * p_pow[j]) % m;\\n            p_pow[j] = (p_pow[j] * p) % m;\\n            map.put(hash[j], map.getOrDefault(hash[j],0) + 1);\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(words[j].length() <= i) continue;\\n            ans[j] += map.get(hash[j]);\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590084,
                "title": "tle-disaster-both-hashmap-and-trie-giving-tle",
                "content": "1. HashMap\\n```\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        \\n\\n        int n=words.length;\\n        int ans[]=new int[n];\\n        \\n        HashMap<String,Integer> map=new HashMap<>();\\n        HashMap<Integer,HashSet<String>> sub_str=new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int j=0; j<words[i].length(); j++){\\n                sb.append(words[i].charAt(j));\\n                if(!sub_str.containsKey(i))\\n                    sub_str.put(i,new HashSet<>());\\n                sub_str.get(i).add(sb.toString());\\n                map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            int count=0;\\n            for(String str:sub_str.get(i)){\\n                Integer get=map.get(str);\\n                if(get==null) break;\\n                count+=get;\\n            }\\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n2. Trie\\n```\\nclass Solution {\\n    class Node{\\n    Node links[];\\n    boolean flag;\\n    int count;\\n    public Node(){\\n        links=new Node[26];\\n        flag=false;\\n        count=0;\\n    }\\n    boolean containsKey(char c){\\n        return links[c-\\'a\\']!=null;\\n    }\\n    Node get(char c){\\n        return links[c-\\'a\\'];\\n    }\\n    void put(char c,Node toadd){\\n        links[c-\\'a\\']=toadd;\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    boolean isEnd(){\\n        return flag;\\n    }\\n       \\n}\\nclass Trie {\\n    Node root;\\n    public Trie() {\\n        root=new Node();\\n    }\\n    \\n    public void insert(String word) {\\n        Node node=root;\\n        for(char c:word.toCharArray()){\\n            if(!node.containsKey(c)){\\n                node.put(c,new Node());\\n            }\\n            node=node.get(c); \\n            node.count++;\\n        }\\n        node.setEnd();\\n        \\n    }\\n    \\n    public boolean search(String word) {\\n        Node node=root;\\n        for(char c:word.toCharArray()){\\n            if(!node.containsKey(c)) return false;\\n            \\n            node=node.get(c);\\n        }\\n        return node.isEnd();\\n    }\\n    \\n    public int startsWith(String prefix) {\\n        Node node=root;\\n        for(char c:prefix.toCharArray()){\\n            if(!node.containsKey(c)) return 0;\\n            node=node.get(c);\\n        }\\n        return node.count;\\n    }\\n}\\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        \\n        Trie root=new Trie();\\n        int n=words.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            root.insert(words[i]);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            StringBuilder sb=new StringBuilder();\\n            int count=0;\\n            for(int j=0; j<words[i].length(); j++){\\n                sb.append(words[i].charAt(j));\\n                count+=root.startsWith(sb.toString());\\n            }\\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n3. Trie Accepted\\n```\\nclass Solution {\\n    class Node{\\n    Node links[];\\n    boolean flag;\\n    int count;\\n    public Node(){\\n        links=new Node[26];\\n        flag=false;\\n        count=0;\\n    }\\n    boolean containsKey(char c){\\n        return links[c-\\'a\\']!=null;\\n    }\\n    Node get(char c){\\n        return links[c-\\'a\\'];\\n    }\\n    void put(char c,Node toadd){\\n        links[c-\\'a\\']=toadd;\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    boolean isEnd(){\\n        return flag;\\n    }\\n       \\n}\\nclass Trie {\\n    Node root;\\n    public Trie() {\\n        root=new Node();\\n    }\\n    \\n    public void insert(String word) {\\n        Node node=root;\\n        for(char c:word.toCharArray()){\\n            if(!node.containsKey(c)){\\n                node.put(c,new Node());\\n            }\\n            node=node.get(c); \\n            node.count++;\\n        }\\n        node.setEnd();\\n        \\n    }\\n    \\n    public boolean search(String word) {\\n        Node node=root;\\n        for(char c:word.toCharArray()){\\n            if(!node.containsKey(c)) return false;\\n            \\n            node=node.get(c);\\n        }\\n        return node.isEnd();\\n    }\\n    \\n    public int startsWith(String prefix) {\\n\\n        Node node=root;\\n        int ans=node.count;\\n        for(char c:prefix.toCharArray()){\\n            node=node.get(c);\\n            ans+=node.count;\\n        }\\n        return ans;\\n    }\\n}\\n    public int[] sumPrefixScores(String[] words) {\\n        Trie root=new Trie();\\n        int n=words.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            root.insert(words[i]);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            ans[i]=root.startsWith(words[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        \\n\\n        int n=words.length;\\n        int ans[]=new int[n];\\n        \\n        HashMap<String,Integer> map=new HashMap<>();\\n        HashMap<Integer,HashSet<String>> sub_str=new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int j=0; j<words[i].length(); j++){\\n                sb.append(words[i].charAt(j));\\n                if(!sub_str.containsKey(i))\\n                    sub_str.put(i,new HashSet<>());\\n                sub_str.get(i).add(sb.toString());\\n                map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            int count=0;\\n            for(String str:sub_str.get(i)){\\n                Integer get=map.get(str);\\n                if(get==null) break;\\n                count+=get;\\n            }\\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    class Node{\\n    Node links[];\\n    boolean flag;\\n    int count;\\n    public Node(){\\n        links=new Node[26];\\n        flag=false;\\n        count=0;\\n    }\\n    boolean containsKey(char c){\\n        return links[c-\\'a\\']!=null;\\n    }\\n    Node get(char c){\\n        return links[c-\\'a\\'];\\n    }\\n    void put(char c,Node toadd){\\n        links[c-\\'a\\']=toadd;\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    boolean isEnd(){\\n        return flag;\\n    }\\n       \\n}\\nclass Trie {\\n    Node root;\\n    public Trie() {\\n        root=new Node();\\n    }\\n    \\n    public void insert(String word) {\\n        Node node=root;\\n        for(char c:word.toCharArray()){\\n            if(!node.containsKey(c)){\\n                node.put(c,new Node());\\n            }\\n            node=node.get(c); \\n            node.count++;\\n        }\\n        node.setEnd();\\n        \\n    }\\n    \\n    public boolean search(String word) {\\n        Node node=root;\\n        for(char c:word.toCharArray()){\\n            if(!node.containsKey(c)) return false;\\n            \\n            node=node.get(c);\\n        }\\n        return node.isEnd();\\n    }\\n    \\n    public int startsWith(String prefix) {\\n        Node node=root;\\n        for(char c:prefix.toCharArray()){\\n            if(!node.containsKey(c)) return 0;\\n            node=node.get(c);\\n        }\\n        return node.count;\\n    }\\n}\\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        \\n        Trie root=new Trie();\\n        int n=words.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            root.insert(words[i]);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            StringBuilder sb=new StringBuilder();\\n            int count=0;\\n            for(int j=0; j<words[i].length(); j++){\\n                sb.append(words[i].charAt(j));\\n                count+=root.startsWith(sb.toString());\\n            }\\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    class Node{\\n    Node links[];\\n    boolean flag;\\n    int count;\\n    public Node(){\\n        links=new Node[26];\\n        flag=false;\\n        count=0;\\n    }\\n    boolean containsKey(char c){\\n        return links[c-\\'a\\']!=null;\\n    }\\n    Node get(char c){\\n        return links[c-\\'a\\'];\\n    }\\n    void put(char c,Node toadd){\\n        links[c-\\'a\\']=toadd;\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n    boolean isEnd(){\\n        return flag;\\n    }\\n       \\n}\\nclass Trie {\\n    Node root;\\n    public Trie() {\\n        root=new Node();\\n    }\\n    \\n    public void insert(String word) {\\n        Node node=root;\\n        for(char c:word.toCharArray()){\\n            if(!node.containsKey(c)){\\n                node.put(c,new Node());\\n            }\\n            node=node.get(c); \\n            node.count++;\\n        }\\n        node.setEnd();\\n        \\n    }\\n    \\n    public boolean search(String word) {\\n        Node node=root;\\n        for(char c:word.toCharArray()){\\n            if(!node.containsKey(c)) return false;\\n            \\n            node=node.get(c);\\n        }\\n        return node.isEnd();\\n    }\\n    \\n    public int startsWith(String prefix) {\\n\\n        Node node=root;\\n        int ans=node.count;\\n        for(char c:prefix.toCharArray()){\\n            node=node.get(c);\\n            ans+=node.count;\\n        }\\n        return ans;\\n    }\\n}\\n    public int[] sumPrefixScores(String[] words) {\\n        Trie root=new Trie();\\n        int n=words.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0; i<n; i++){\\n            root.insert(words[i]);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            ans[i]=root.startsWith(words[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590048,
                "title": "c-explained-solution-using-trie-time-o-nm",
                "content": "**Approach -**\\n**Step 1** - Create a node class that stores characters, a pointer to its next characters \\nand count how many times this character appears in every prefix of every string of a given vector\\n**Step 2** - Create a trie class that has to member function\\ni) Push - To push the string in trie\\nii) Score - To find the score of the string :-\\nCalculate the sum of the count of every character of string in trie\\n**Step 3** - Push all strings of the given vector in trie\\n**Step 4** - Get the score of every string of vector by calling the score function of trie\\n\\n**Code**\\n```\\nclass node{\\n    public :\\n    char c;\\n    unordered_map<char,node*> m; // To store pointer to its next characters\\n    int cn =0 ;  // To store count how many times this character appears in every prefix of every string of a given vector\\n};\\n\\nclass trie{\\n    node *r;  // Root node\\n    public :\\n    trie(){\\n        r = new node;\\n        r->c = \\'\\\\0\\';\\n        r->cn = 0;\\n    }\\n    void push(string a){\\n        node *p = r;\\n        for(int i=0;i<a.size();i++){\\n            if(p->m.count(a[i])){     // If its next character is present in trie, move to that character\\n                p = p->m[a[i]];\\n                p->cn++;              // Increase count, Because it is present in prefix of current string(a)\\n            }\\n            else{\\n                node *l = new node;  // If its next character is not present in trie, create new node\\n                l->c = a[i];\\n                l->cn = 1;           // Count = 1\\n                p->m[a[i]]= l;\\n                p = l;\\n            }\\n        }\\n        return ;\\n    }\\n    int score(string a){\\n        int ans =0 ;\\n        node *p = r;\\n        for(int i=0;i<a.size();i++){    // Add all count of character by traversing trie for current string(a)\\n            p= p->m[a[i]];\\n            ans += p->cn;           \\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& a) {\\n        trie t;\\n        int n = a.size();\\n        for(int i=0;i<n;i++) t.push(a[i]);              // Push all string in trie\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++) ans[i]= t.score(a[i]);    //  Get the score of strings\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity - O(NM)**  => O(C)\\nN is the length of the given array\\nM is the length of the string (This may not be the same for all strings)\\nC is the number of characters present in the given vector\\n\\n**Upvote if you like it!**\\n",
                "solutionTags": [],
                "code": "```\\nclass node{\\n    public :\\n    char c;\\n    unordered_map<char,node*> m; // To store pointer to its next characters\\n    int cn =0 ;  // To store count how many times this character appears in every prefix of every string of a given vector\\n};\\n\\nclass trie{\\n    node *r;  // Root node\\n    public :\\n    trie(){\\n        r = new node;\\n        r->c = \\'\\\\0\\';\\n        r->cn = 0;\\n    }\\n    void push(string a){\\n        node *p = r;\\n        for(int i=0;i<a.size();i++){\\n            if(p->m.count(a[i])){     // If its next character is present in trie, move to that character\\n                p = p->m[a[i]];\\n                p->cn++;              // Increase count, Because it is present in prefix of current string(a)\\n            }\\n            else{\\n                node *l = new node;  // If its next character is not present in trie, create new node\\n                l->c = a[i];\\n                l->cn = 1;           // Count = 1\\n                p->m[a[i]]= l;\\n                p = l;\\n            }\\n        }\\n        return ;\\n    }\\n    int score(string a){\\n        int ans =0 ;\\n        node *p = r;\\n        for(int i=0;i<a.size();i++){    // Add all count of character by traversing trie for current string(a)\\n            p= p->m[a[i]];\\n            ans += p->cn;           \\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& a) {\\n        trie t;\\n        int n = a.size();\\n        for(int i=0;i<n;i++) t.push(a[i]);              // Push all string in trie\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++) ans[i]= t.score(a[i]);    //  Get the score of strings\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592736,
                "title": "trie-java-beginner-friendly",
                "content": "class Solution {\\n    \\n    private class TrieNode{\\n        TrieNode[]children;\\n        boolean isEnd;\\n        int pre_count=0;\\n        \\n        TrieNode(){\\n            children=new TrieNode[26];\\n            isEnd=false;\\n        }\\n    }\\n    \\n    private TrieNode root;\\n    \\n    private void insert_word(String s){\\n        TrieNode curr=root;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            \\n            if(curr.children[ch-\\'a\\']==null){\\n                curr.children[ch-\\'a\\']=new TrieNode();\\n            }\\n            \\n            curr=curr.children[ch-\\'a\\'];\\n            curr.pre_count++;   \\n        }\\n        \\n        curr.isEnd=true;\\n    }\\n    \\n    private int start_word_prefix(String s){\\n        \\n        TrieNode curr=root;\\n        int count=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            \\n            if(curr.children[ch-\\'a\\']==null)break;\\n            \\n            curr=curr.children[ch-\\'a\\'];\\n            count+=curr.pre_count;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public int[] sumPrefixScores(String[] words) {\\n        int n=words.length;\\n        int i=0;\\n        \\n        int[]res=new int[n];\\n        \\n        root=new TrieNode();\\n        \\n        for(String word:words)insert_word(word);\\n        \\n        for(String word:words){\\n            int count=start_word_prefix(word);\\n            res[i++]=count;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nPlz upvote if you like the solution..",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "class Solution {\\n    \\n    private class TrieNode{\\n        TrieNode[]children;\\n        boolean isEnd;\\n        int pre_count=0;\\n        \\n        TrieNode(){\\n            children=new TrieNode[26];\\n            isEnd=false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2590136,
                "title": "c-two-solution-trie-hashing",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        struct node\\n        {\\n            node *child[26] = { NULL\\n            };\\n            int count = 0;\\n        };\\n    node *root = new node();\\n    void insert(string & s)\\n    {\\n        int n = s.size();\\n        node *curr = root;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int index = s[i] - \\'a\\';\\n            if (curr->child[index] == NULL)\\n            {\\n                curr->child[index] = new node();\\n            }\\n            curr = curr->child[index];\\n            curr->count++;\\n        }\\n    }\\n    int find(node *curr, string &s)\\n    {\\n        int ans = 0;\\n        for (char &ch: s)\\n        {\\n            if (curr->child[ch - \\'a\\'] != NULL)\\n            {\\n                curr = curr->child[ch - \\'a\\'];\\n                ans += curr->count;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> sumPrefixScores(vector<string> &nums)\\n    {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            insert(nums[i]);\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < n; i++)\\n        {\\n            node *curr = root;\\n            int value = find(curr, nums[i]);\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>&nums) \\n    {\\n        int n=nums.size();\\n        unordered_map<long long,int>mp;\\n        long long mod=1e15+7;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long hash=0;\\n            for(auto &ch:nums[i])\\n            {\\n                hash=(hash*97+(ch))%mod;\\n                mp[hash]++;\\n            }\\n        }\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            long long hash=0;\\n            for(auto &ch:nums[i])\\n            {\\n                hash=(hash*97+(ch))%mod;\\n                count+=mp[hash];\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        struct node\\n        {\\n            node *child[26] = { NULL\\n            };\\n            int count = 0;\\n        };\\n    node *root = new node();\\n    void insert(string & s)\\n    {\\n        int n = s.size();\\n        node *curr = root;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int index = s[i] - \\'a\\';\\n            if (curr->child[index] == NULL)\\n            {\\n                curr->child[index] = new node();\\n            }\\n            curr = curr->child[index];\\n            curr->count++;\\n        }\\n    }\\n    int find(node *curr, string &s)\\n    {\\n        int ans = 0;\\n        for (char &ch: s)\\n        {\\n            if (curr->child[ch - \\'a\\'] != NULL)\\n            {\\n                curr = curr->child[ch - \\'a\\'];\\n                ans += curr->count;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> sumPrefixScores(vector<string> &nums)\\n    {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            insert(nums[i]);\\n        }\\n        vector<int> ans;\\n        for (int i = 0; i < n; i++)\\n        {\\n            node *curr = root;\\n            int value = find(curr, nums[i]);\\n            ans.push_back(value);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>&nums) \\n    {\\n        int n=nums.size();\\n        unordered_map<long long,int>mp;\\n        long long mod=1e15+7;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long hash=0;\\n            for(auto &ch:nums[i])\\n            {\\n                hash=(hash*97+(ch))%mod;\\n                mp[hash]++;\\n            }\\n        }\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            long long hash=0;\\n            for(auto &ch:nums[i])\\n            {\\n                hash=(hash*97+(ch))%mod;\\n                count+=mp[hash];\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564452,
                "title": "c-easy-trie",
                "content": "# Code\\n```\\nclass trie{\\n    public:\\n        int x;\\n        trie *v[26];\\n};\\nvoid maketrie(string str,trie* node){\\n    for(auto &i: str){\\n        if(node->v[i-\\'a\\'] == NULL){\\n            node->v[i-\\'a\\'] = new trie();\\n            node = node->v[i-\\'a\\'];\\n            node->x = node->x +1 ;\\n        }else{\\n            node = node->v[i-\\'a\\'];\\n            node->x = node->x +1 ;\\n        }\\n    }\\n}\\nvoid solve(string str,trie* node,int &x){\\n    trie* p = node;\\n    for(auto &i: str){\\n        p = p->v[i-\\'a\\'];\\n        x += p->x;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        trie *node = new trie();\\n        for(auto &i: words){\\n            maketrie(i,node);\\n        }\\n        int x = 0;\\n        vector<int> ans;\\n        for(auto &i: words){\\n            x = 0;\\n            solve(i,node,x);\\n            ans.push_back(x);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Trie",
                    "Counting"
                ],
                "code": "```\\nclass trie{\\n    public:\\n        int x;\\n        trie *v[26];\\n};\\nvoid maketrie(string str,trie* node){\\n    for(auto &i: str){\\n        if(node->v[i-\\'a\\'] == NULL){\\n            node->v[i-\\'a\\'] = new trie();\\n            node = node->v[i-\\'a\\'];\\n            node->x = node->x +1 ;\\n        }else{\\n            node = node->v[i-\\'a\\'];\\n            node->x = node->x +1 ;\\n        }\\n    }\\n}\\nvoid solve(string str,trie* node,int &x){\\n    trie* p = node;\\n    for(auto &i: str){\\n        p = p->v[i-\\'a\\'];\\n        x += p->x;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        trie *node = new trie();\\n        for(auto &i: words){\\n            maketrie(i,node);\\n        }\\n        int x = 0;\\n        vector<int> ans;\\n        for(auto &i: words){\\n            x = 0;\\n            solve(i,node,x);\\n            ans.push_back(x);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408898,
                "title": "c-trie-easy-to-understand-short-sweet-code",
                "content": "````\\nclass trie{//make trie class\\n    public:\\n        int cnt;\\n        trie* v[26];\\n        trie(){\\n            cnt = 0;//no of common prefix\\n            for(int i = 0; i < 26; i++){\\n                v[i] = NULL;\\n            }\\n        }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        trie *node = new trie(),*tmp;//inittilize trie root node\\n        for(auto &i: words){\\n            tmp = node;\\n            for(auto &j: i){\\n                if(tmp->v[j-\\'a\\']==NULL){//if node not found make node\\n                    tmp->v[j-\\'a\\'] = new trie();\\n                    tmp = tmp->v[j-\\'a\\'];\\n                    tmp->cnt++;\\n                }else{//if node found\\n                    tmp = tmp->v[j-\\'a\\'];\\n                    tmp->cnt++;//increment prefix count by one\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        vector<int> ans;\\n        for(auto &i: words){\\n            sum = 0;// for string i ans = 0\\n            tmp = node;\\n            for(auto &j: i){\\n                sum += (tmp->v[j-\\'a\\'])->cnt;//add no of common prefix\\n                tmp = tmp->v[j-\\'a\\'];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "````\\nclass trie{//make trie class\\n    public:\\n        int cnt;\\n        trie* v[26];\\n        trie(){\\n            cnt = 0;//no of common prefix\\n            for(int i = 0; i < 26; i++){\\n                v[i] = NULL;\\n            }\\n        }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        trie *node = new trie(),*tmp;//inittilize trie root node\\n        for(auto &i: words){\\n            tmp = node;\\n            for(auto &j: i){\\n                if(tmp->v[j-\\'a\\']==NULL){//if node not found make node\\n                    tmp->v[j-\\'a\\'] = new trie();\\n                    tmp = tmp->v[j-\\'a\\'];\\n                    tmp->cnt++;\\n                }else{//if node found\\n                    tmp = tmp->v[j-\\'a\\'];\\n                    tmp->cnt++;//increment prefix count by one\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        vector<int> ans;\\n        for(auto &i: words){\\n            sum = 0;// for string i ans = 0\\n            tmp = node;\\n            for(auto &j: i){\\n                sum += (tmp->v[j-\\'a\\'])->cnt;//add no of common prefix\\n                tmp = tmp->v[j-\\'a\\'];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659113,
                "title": "hashing-c-easy-to-understand",
                "content": "The hashing technique is simple. The algorithm states that\\n1) Assign a hash code to all prefixes of a word ( Using any hash function or Rabin Karp algorithm). Repeat this for every word in the list of words.\\n2) Alongside maintain a frequency map for the hash code, or the prefix, which maintains the number of occurrences of the prefix or the hash code.\\n3) Now the score of a word is defined as the sum of occurrences of prefixes present in the string from the map that we made earlier.\\nThat is the number of times a prefix present in \\'word\\' appeared across the entire list of words. Sum for all such prefixes in the word is its score.\\n\\nStoring the hash code in an unordered map gives TLE, so its better to calculate the hash codes again when calculating the scores of the words.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long mod= 1e9;\\n    \\n    void assignHashCode(string& s,unordered_map<long long, int>& hash_code_prefix_freq)\\n    {\\n        int n= s.size();\\n        vector<long long> p(n);\\n        long long temp= 37;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            p[i]= temp;\\n            temp= temp % mod * 37 % mod;\\n        }\\n        \\n        long long hc=0;\\n        string word=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            word.push_back(s[i]);\\n            hc+= p[i]% mod* s[i]% mod;\\n            hash_code_prefix_freq[hc]++;\\n        }\\n    }\\n    \\n    int calculateScore(string& s, unordered_map<long long, int>& hash_code_prefix_freq)\\n    {\\n        int n= s.size();\\n        int score=0;\\n        \\n        vector<long long> p(n);\\n        long long temp= 37;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            p[i]= temp;\\n            temp= temp % mod * 37 % mod;\\n        }\\n        \\n        long long hc=0;\\n        string word=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            word.push_back(s[i]);\\n            hc+= p[i]% mod* s[i]% mod;\\n            score+= hash_code_prefix_freq[hc];\\n        }\\n        \\n        return score;\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        \\n        unordered_map<long long, int> hash_code_prefix_freq;\\n        unordered_map<string, long long> hash_codes;\\n        \\n        for(auto word: words)\\n        {\\n            assignHashCode(word,hash_code_prefix_freq); // assign hash code to every prefix in the string and calculate freq\\n        }\\n        \\n        vector<int> scores;\\n        for(auto word: words)\\n        {\\n            int score= calculateScore(word,hash_code_prefix_freq); // find hash code of every prefix and sum frequencies of prefix\\n            scores.push_back(score);\\n        }\\n        \\n        return scores; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod= 1e9;\\n    \\n    void assignHashCode(string& s,unordered_map<long long, int>& hash_code_prefix_freq)\\n    {\\n        int n= s.size();\\n        vector<long long> p(n);\\n        long long temp= 37;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            p[i]= temp;\\n            temp= temp % mod * 37 % mod;\\n        }\\n        \\n        long long hc=0;\\n        string word=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            word.push_back(s[i]);\\n            hc+= p[i]% mod* s[i]% mod;\\n            hash_code_prefix_freq[hc]++;\\n        }\\n    }\\n    \\n    int calculateScore(string& s, unordered_map<long long, int>& hash_code_prefix_freq)\\n    {\\n        int n= s.size();\\n        int score=0;\\n        \\n        vector<long long> p(n);\\n        long long temp= 37;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            p[i]= temp;\\n            temp= temp % mod * 37 % mod;\\n        }\\n        \\n        long long hc=0;\\n        string word=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            word.push_back(s[i]);\\n            hc+= p[i]% mod* s[i]% mod;\\n            score+= hash_code_prefix_freq[hc];\\n        }\\n        \\n        return score;\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        \\n        unordered_map<long long, int> hash_code_prefix_freq;\\n        unordered_map<string, long long> hash_codes;\\n        \\n        for(auto word: words)\\n        {\\n            assignHashCode(word,hash_code_prefix_freq); // assign hash code to every prefix in the string and calculate freq\\n        }\\n        \\n        vector<int> scores;\\n        for(auto word: words)\\n        {\\n            int score= calculateScore(word,hash_code_prefix_freq); // find hash code of every prefix and sum frequencies of prefix\\n            scores.push_back(score);\\n        }\\n        \\n        return scores; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606291,
                "title": "c-simple-dp-solution-without-trie-beats-99-runtime-97-space",
                "content": "Firstly Sort the array of strings without losing original indices (eg: by using vector<pair<string,int>>).\\n\\nThis solution takes advantage of the fact that after sorting the strings with identical prefixes will form a consecutive segment.\\n\\nExample: \\nBefore Sorting => \"abc\"   \"bc\"    \"ab\"   \"b\"\\nAfter Sorting   => **[\"ab\"  \"abc\"]**    **[  \"b\"    \"bc\" ]**\\n\\nAs you can see for any string **S[i]** strings whose prefix matches with prefix of **S[i]** are either just before **S[i]**\\nor just after **S[i]**.\\n\\nNow I think the solution is pretty self explanotary.\\n\\n**dp[i][j]** will represent number of strings in the region **words[0, i-1]** whose **prefix[0..j]** matches with **S[0...j]**\\nThen reverse the array of strings and calculate the same to find matching strings in the region\\n**words[i+1...n-1]**.\\n\\n// Please look at the code to understand better. \\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> ans;\\n    \\n    void calPrefixScore(vector<pair<string,int>> &v)\\n    {\\n        vector<int> dp(v[0].first.size()), ndp;\\n        \\n        for(int i = 1; i < n; ++i)\\n        {\\n            auto [s, idx] = v[i];\\n            ndp = vector<int> (s.size(), 0);\\n            \\n            for(int j = 0; j < min(s.size(), dp.size()); ++j)\\n            {\\n                if(s[j] != v[i-1].first[j])break;\\n                ndp[j] = dp[j] + 1;\\n                ans[idx] += ndp[j];\\n            }\\n            dp = ndp;\\n        }\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) \\n    {\\n        n = words.size();\\n        ans.resize(n);\\n        \\n        vector<pair<string,int>> v;\\n        for(int i = 0; i < n; ++i){\\n            v.push_back({words[i], i});\\n        }\\n        \\n        auto cmp = [&](pair<string,int> &a, pair<string,int> &b){\\n            return a.first < b.first;\\n        };\\n        \\n        sort(v.begin(), v.end(), cmp);\\n        calPrefixScore(v);\\n        \\n        reverse(v.begin(), v.end());\\n        calPrefixScore(v);\\n        \\n        for(auto [s, idx] : v){\\n            ans[idx] += s.size();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> ans;\\n    \\n    void calPrefixScore(vector<pair<string,int>> &v)\\n    {\\n        vector<int> dp(v[0].first.size()), ndp;\\n        \\n        for(int i = 1; i < n; ++i)\\n        {\\n            auto [s, idx] = v[i];\\n            ndp = vector<int> (s.size(), 0);\\n            \\n            for(int j = 0; j < min(s.size(), dp.size()); ++j)\\n            {\\n                if(s[j] != v[i-1].first[j])break;\\n                ndp[j] = dp[j] + 1;\\n                ans[idx] += ndp[j];\\n            }\\n            dp = ndp;\\n        }\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) \\n    {\\n        n = words.size();\\n        ans.resize(n);\\n        \\n        vector<pair<string,int>> v;\\n        for(int i = 0; i < n; ++i){\\n            v.push_back({words[i], i});\\n        }\\n        \\n        auto cmp = [&](pair<string,int> &a, pair<string,int> &b){\\n            return a.first < b.first;\\n        };\\n        \\n        sort(v.begin(), v.end(), cmp);\\n        calPrefixScore(v);\\n        \\n        reverse(v.begin(), v.end());\\n        calPrefixScore(v);\\n        \\n        for(auto [s, idx] : v){\\n            ans[idx] += s.size();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597820,
                "title": "javascript-get-rid-of-memory-allocation-problem",
                "content": "I found that in javascript, you will face memory problem in some testcase\\nSo i\\'m posting my solution here\\n\\nyou have to know that words with different inital characters wont affect each others\\' score\\nfor example, `abcd, aaab, acab` wont affect the scores of `cbcd, bacd, bbab, ccccd`.\\nKnowing the fact, you know you only need to build a trie for same initial chacaters in order to solve the score of the groups instead of build a huge trie for all words together.\\nThis allows system to do gc between each group solving their score.\\n\\n```\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar sumPrefixScores = function(words) {\\n    const scores = {};\\n    const groups = words.reduce((groups, word) => {\\n        if (!groups[word[0]]) {\\n            groups[word[0]] = [];\\n        }\\n        groups[word[0]].push(word);\\n        return groups;\\n    }, {});\\n    \\n    for (const group of Object.values(groups)) {\\n        const root = createNode();\\n        for (let i = 0; i < group.length; i++) {\\n            const word = group[i];\\n            insert(root, word);\\n        }\\n        for (let i = 0; i < group.length; i++) {\\n            const word = group[i];\\n            scores[word] = getScore(root, word, 0);\\n        }\\n    }\\n\\t\\n    return words.map(word => scores[word]);\\n};\\n\\nconst getScore = (node, word, i) => {\\n    if (i === word.length) {\\n        return 0;\\n    }\\n    const charCode = word.charCodeAt(i) - 97;\\n    const next = node.children[charCode];\\n    const score = next.count;\\n    return score + getScore(next, word, i + 1);\\n}\\n\\nconst insert = (node, word, i = 0) => {\\n    node.count++;\\n    if (i === word.length) {\\n        return;\\n    }\\n    const charCode = word.charCodeAt(i) - 97;\\n    if (!node.children[charCode]) {\\n        node.children[charCode] = createNode();\\n    }\\n    insert(node.children[charCode], word, i+ 1);\\n}\\n\\nconst createNode = () => {\\n    return {\\n        count: 0,\\n        children: new Array(26),\\n    };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar sumPrefixScores = function(words) {\\n    const scores = {};\\n    const groups = words.reduce((groups, word) => {\\n        if (!groups[word[0]]) {\\n            groups[word[0]] = [];\\n        }\\n        groups[word[0]].push(word);\\n        return groups;\\n    }, {});\\n    \\n    for (const group of Object.values(groups)) {\\n        const root = createNode();\\n        for (let i = 0; i < group.length; i++) {\\n            const word = group[i];\\n            insert(root, word);\\n        }\\n        for (let i = 0; i < group.length; i++) {\\n            const word = group[i];\\n            scores[word] = getScore(root, word, 0);\\n        }\\n    }\\n\\t\\n    return words.map(word => scores[word]);\\n};\\n\\nconst getScore = (node, word, i) => {\\n    if (i === word.length) {\\n        return 0;\\n    }\\n    const charCode = word.charCodeAt(i) - 97;\\n    const next = node.children[charCode];\\n    const score = next.count;\\n    return score + getScore(next, word, i + 1);\\n}\\n\\nconst insert = (node, word, i = 0) => {\\n    node.count++;\\n    if (i === word.length) {\\n        return;\\n    }\\n    const charCode = word.charCodeAt(i) - 97;\\n    if (!node.children[charCode]) {\\n        node.children[charCode] = createNode();\\n    }\\n    insert(node.children[charCode], word, i+ 1);\\n}\\n\\nconst createNode = () => {\\n    return {\\n        count: 0,\\n        children: new Array(26),\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593773,
                "title": "easy-with-trie",
                "content": "```\\nclass TrieNode{\\n  constructor(){\\n    this.ch = {};\\n    this.score = 0;\\n  }\\n}\\n\\nclass Trie{\\n  constructor(){\\n    this.root = new TrieNode();\\n  }\\n  add(word){\\n    let cur = this.root;\\n    for(let c of word){\\n      if (!cur.ch.hasOwnProperty(c)){\\n        cur.ch[c] = new TrieNode();\\n      }\\n      cur = cur.ch[c];\\n      cur.score += 1;\\n    }\\n  }\\n  get_score(word){\\n    let cur = this.root;\\n    let tot = 0;\\n    for(let c of word){\\n      if (!cur.ch.hasOwnProperty(c)){\\n        break;\\n      }\\n      cur = cur.ch[c];\\n      tot += cur.score;\\n    }\\n    return tot;\\n  }\\n}\\n\\nvar sumPrefixScores = function(words) {\\n\\n  let s = words;\\n  let tree = new Trie();\\n  let ans = [];\\n  for(let w of s){\\n    tree.add(w)\\n  }\\n  for(let w of words){\\n    ans.push(tree.get_score(w));\\n  }\\n  return ans;\\n};\\n```\\n# PlEASE UPVOTE!",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\n  constructor(){\\n    this.ch = {};\\n    this.score = 0;\\n  }\\n}\\n\\nclass Trie{\\n  constructor(){\\n    this.root = new TrieNode();\\n  }\\n  add(word){\\n    let cur = this.root;\\n    for(let c of word){\\n      if (!cur.ch.hasOwnProperty(c)){\\n        cur.ch[c] = new TrieNode();\\n      }\\n      cur = cur.ch[c];\\n      cur.score += 1;\\n    }\\n  }\\n  get_score(word){\\n    let cur = this.root;\\n    let tot = 0;\\n    for(let c of word){\\n      if (!cur.ch.hasOwnProperty(c)){\\n        break;\\n      }\\n      cur = cur.ch[c];\\n      tot += cur.score;\\n    }\\n    return tot;\\n  }\\n}\\n\\nvar sumPrefixScores = function(words) {\\n\\n  let s = words;\\n  let tree = new Trie();\\n  let ans = [];\\n  for(let w of s){\\n    tree.add(w)\\n  }\\n  for(let w of words){\\n    ans.push(tree.get_score(w));\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591047,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Trie***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // structure for TrieNode\\n    \\n    struct TrieNode\\n    {\\n        TrieNode* child[26];\\n        \\n        int count;\\n        \\n        TrieNode()\\n        {\\n            count = 0;\\n            \\n            for(int i = 0; i < 26; i++)\\n            {\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n    \\n    // declare a global root\\n    \\n    TrieNode* root = new TrieNode();\\n    \\n    // function for insert\\n    \\n    void insert(string str)\\n    {\\n        int n = str.size();\\n        \\n        TrieNode* curr = root;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = str[i] - \\'a\\';\\n            \\n            // insert a new node\\n            \\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new TrieNode(); \\n            }\\n            \\n            // increment the count of prefix\\n            \\n            curr -> child[idx] -> count++;\\n            \\n            // move curr pointer\\n          \\n            curr = curr -> child[idx];\\n        }\\n    }\\n    \\n    // function for get_sum\\n    \\n    int get_sum(string str)\\n    {\\n        int n = str.size();\\n        \\n        int sum = 0;\\n        \\n        TrieNode* curr = root;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = str[i] - \\'a\\';\\n            \\n            sum += curr -> child[idx] -> count;\\n            \\n            curr = curr -> child[idx];\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        \\n        int n = words.size();\\n        \\n        // insert all the words into trie\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            insert(words[i]);\\n        }\\n        \\n        vector<int> res(n, 0);\\n        \\n        // find sum for every word\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int sum = get_sum(words[i]);\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // structure for TrieNode\\n    \\n    struct TrieNode\\n    {\\n        TrieNode* child[26];\\n        \\n        int count;\\n        \\n        TrieNode()\\n        {\\n            count = 0;\\n            \\n            for(int i = 0; i < 26; i++)\\n            {\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n    \\n    // declare a global root\\n    \\n    TrieNode* root = new TrieNode();\\n    \\n    // function for insert\\n    \\n    void insert(string str)\\n    {\\n        int n = str.size();\\n        \\n        TrieNode* curr = root;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = str[i] - \\'a\\';\\n            \\n            // insert a new node\\n            \\n            if(curr -> child[idx] == NULL)\\n            {\\n                curr -> child[idx] = new TrieNode(); \\n            }\\n            \\n            // increment the count of prefix\\n            \\n            curr -> child[idx] -> count++;\\n            \\n            // move curr pointer\\n          \\n            curr = curr -> child[idx];\\n        }\\n    }\\n    \\n    // function for get_sum\\n    \\n    int get_sum(string str)\\n    {\\n        int n = str.size();\\n        \\n        int sum = 0;\\n        \\n        TrieNode* curr = root;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = str[i] - \\'a\\';\\n            \\n            sum += curr -> child[idx] -> count;\\n            \\n            curr = curr -> child[idx];\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        \\n        int n = words.size();\\n        \\n        // insert all the words into trie\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            insert(words[i]);\\n        }\\n        \\n        vector<int> res(n, 0);\\n        \\n        // find sum for every word\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int sum = get_sum(words[i]);\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590457,
                "title": "easy-peasy-trie",
                "content": "Using normal trie implementation with a **branch** property which at any node wil tell us the total number of branches that are merged with the current path i.e, the total number of prefixes ending at the current node.\\nImplementing this and storing all the string in that trie will be a key to that answer, because after than you just have to traverse the path of your given string adding up all the branches count you see.\\n\\n```\\nclass Solution {\\n    class Node{\\n        char ch;\\n        Node[] links;\\n        boolean isEnd;\\n        int branch;\\n        Node(char ch){\\n            this.ch=ch;\\n            links=new Node[26];\\n            branch=1;\\n        }\\n    }\\n    Node root;\\n    public Solution() {\\n        this.root=new Node(\\'*\\');\\n    }\\n    \\n    public void insert(String word) {\\n        Node curr=this.root;\\n        for(int i=0;i<word.length();i++){\\n            char ch=word.charAt(i);\\n            if(curr.links[ch-\\'a\\']!=null){\\n                curr.links[ch-\\'a\\'].branch++;\\n                curr=curr.links[ch-\\'a\\'];\\n            }\\n            else{\\n                curr.links[ch-\\'a\\']=new Node(ch);\\n                curr=curr.links[ch-\\'a\\'];\\n            }\\n        }\\n        curr.isEnd=true;\\n    }\\n    \\n    public int startsWith(String prefix) {\\n        Node curr=this.root;\\n        int res=0;\\n        for(int i=0;i<prefix.length();i++){\\n            char ch=prefix.charAt(i);\\n            if(curr.links[ch-\\'a\\']!=null){\\n                res+=curr.links[ch-\\'a\\'].branch;\\n                curr=curr.links[ch-\\'a\\'];\\n            }\\n            else{\\n                return res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int[] sumPrefixScores(String[] words) {\\n        int n=words.length;\\n        int[] ans=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            insert(words[i]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i]=startsWith(words[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nBtw this is my first time solving all for questions ;)\\nThanks",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        char ch;\\n        Node[] links;\\n        boolean isEnd;\\n        int branch;\\n        Node(char ch){\\n            this.ch=ch;\\n            links=new Node[26];\\n            branch=1;\\n        }\\n    }\\n    Node root;\\n    public Solution() {\\n        this.root=new Node(\\'*\\');\\n    }\\n    \\n    public void insert(String word) {\\n        Node curr=this.root;\\n        for(int i=0;i<word.length();i++){\\n            char ch=word.charAt(i);\\n            if(curr.links[ch-\\'a\\']!=null){\\n                curr.links[ch-\\'a\\'].branch++;\\n                curr=curr.links[ch-\\'a\\'];\\n            }\\n            else{\\n                curr.links[ch-\\'a\\']=new Node(ch);\\n                curr=curr.links[ch-\\'a\\'];\\n            }\\n        }\\n        curr.isEnd=true;\\n    }\\n    \\n    public int startsWith(String prefix) {\\n        Node curr=this.root;\\n        int res=0;\\n        for(int i=0;i<prefix.length();i++){\\n            char ch=prefix.charAt(i);\\n            if(curr.links[ch-\\'a\\']!=null){\\n                res+=curr.links[ch-\\'a\\'].branch;\\n                curr=curr.links[ch-\\'a\\'];\\n            }\\n            else{\\n                return res;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int[] sumPrefixScores(String[] words) {\\n        int n=words.length;\\n        int[] ans=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            insert(words[i]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i]=startsWith(words[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590169,
                "title": "trie-count-and-fetch-c",
                "content": "# C++\\n    struct trie {\\n       trie *child[26] = {};\\n       int count=0;\\n    }; \\n    \\n    vector<int> sumPrefixScores(vector<string>& A) {\\n        trie td;\\n        \\n        //put all words\\n        for(auto w:A){\\n            //insert word in trie\\n            auto root= &td;\\n            for(auto j:w){\\n                if(!root->child[j-\\'a\\']) root->child[j-\\'a\\']= new trie();\\n                root= root->child[j-\\'a\\'];\\n                root->count++;\\n            }\\n        }\\n        \\n        vector<int> ans;  ans.reserve(A.size());\\n        \\n        for(auto w:A){\\n            auto root= &td;\\n            int n=0;\\n            for(auto j:w){\\n                root= root->child[j-\\'a\\'];\\n                //get count of prefix stored\\n                n+= root->count;\\n            }\\n            ans.push_back(n);\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "# C++\\n    struct trie {\\n       trie *child[26] = {};\\n       int count=0;\\n    }; \\n    \\n    vector<int> sumPrefixScores(vector<string>& A) {\\n        trie td;\\n        \\n        //put all words\\n        for(auto w:A){\\n            //insert word in trie\\n            auto root= &td;\\n            for(auto j:w){\\n                if(!root->child[j-\\'a\\']) root->child[j-\\'a\\']= new trie();\\n                root= root->child[j-\\'a\\'];\\n                root->count++;\\n            }\\n        }\\n        \\n        vector<int> ans;  ans.reserve(A.size());\\n        \\n        for(auto w:A){\\n            auto root= &td;\\n            int n=0;\\n            for(auto j:w){\\n                root= root->child[j-\\'a\\'];\\n                //get count of prefix stored\\n                n+= root->count;\\n            }\\n            ans.push_back(n);\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3148607,
                "title": "brain-dead-solution-in-python",
                "content": "# Intuition\\nUses the idea of tries but no tries hehe\\n\\nHonestly, just build the prefix of a word as you go.\\n\\n# Approach\\nFor each word, I create a `buffer` and build a prefix for each character of the word.\\n\\nSo I continuously build a `buffer` character at a time without doing some weird indexing calculation.\\n\\nOnce the buffer has an appended character I check if that character is in `ws`. If not, add an entry to `ws` for buffer to zero, if so just increment by one.\\n\\nSo that is the first pass.\\n\\n2nd pass,\\n\\nSame thing as the first, building the prefix for each word,\\nbut here I am checking the overall count that the current buffer appears and summing it into its respective index with the variable `counts`.\\n\\nand yeah just return counts yeet\\n\\n# Complexity\\n- Time complexity:\\nthe yung O(N * M) where N is the number of words and M is thee max size of word.\\n\\n- Space complexity:\\nO(N * M) + O(N) = O(N * M)\\n\\ngg bois\\n# Code\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n\\n\\n        ws = dict()\\n\\n        for word in words:\\n            buffer = \"\"\\n            for c in word:\\n                buffer += c\\n                if buffer not in ws:\\n                    ws[buffer] = 0\\n                ws[buffer] += 1\\n\\n        counts = [0] * len(words)\\n        for i, word in enumerate(words):\\n            buffer = \"\"\\n            for c in word:\\n                buffer += c\\n                if buffer in ws:\\n                    counts[i] += ws[buffer]\\n        return counts\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n\\n\\n        ws = dict()\\n\\n        for word in words:\\n            buffer = \"\"\\n            for c in word:\\n                buffer += c\\n                if buffer not in ws:\\n                    ws[buffer] = 0\\n                ws[buffer] += 1\\n\\n        counts = [0] * len(words)\\n        for i, word in enumerate(words):\\n            buffer = \"\"\\n            for c in word:\\n                buffer += c\\n                if buffer in ws:\\n                    counts[i] += ws[buffer]\\n        return counts\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835882,
                "title": "c-trie-search-prefixes",
                "content": "```cpp\\nclass TrieNode {\\npublic:\\n    vector<TrieNode*> child;\\n    int availablePrefix;\\n};\\n\\nconst int CHILD_COUNT = 26;\\nconst int nax = 1e7 + 9;\\nTrieNode pool[nax];\\nint cnt;\\nTrieNode *getNode() {\\n    auto t = &pool[cnt++];\\n    t->child.resize(CHILD_COUNT);\\n    for (int i = 0; i < CHILD_COUNT; ++i) {\\n        t->child[i] = nullptr;\\n    }\\n    t->availablePrefix = 0;\\n    return t;\\n}\\n\\nclass Solution {\\npublic:\\n    TrieNode *root;\\n    //this would insert all the prefixes of the current string\\n    //in to the TRIE\\n    void insert(const string &word) {\\n        auto ptr = root;\\n        for (char ch: word) {\\n            int idx = ch - \\'a\\';\\n            if (!ptr->child[idx]) {\\n                ptr->child[idx] = getNode();\\n            }\\n            ptr = ptr->child[idx];\\n            ptr->availablePrefix += 1;\\n        }\\n    }\\n    \\n    //This searches a string in TRIE and counts \\n    //all the prefixes along the path\\n    int search (const string &word) {\\n        auto ptr = root;\\n        int prefixCount = 0;\\n        for (char ch: word) {\\n            int idx = ch - \\'a\\';\\n            if (!ptr->child[idx]) {\\n                return prefixCount;\\n            }\\n            ptr = ptr->child[idx];\\n            prefixCount += ptr->availablePrefix;\\n        }\\n        return prefixCount;\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        cnt = 0;\\n        root = getNode();\\n        for (const string &s: words) {\\n            insert(s);\\n        }\\n        vector<int> result;\\n        for (const string &s: words) {\\n            result.push_back(search(s));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass TrieNode {\\npublic:\\n    vector<TrieNode*> child;\\n    int availablePrefix;\\n};\\n\\nconst int CHILD_COUNT = 26;\\nconst int nax = 1e7 + 9;\\nTrieNode pool[nax];\\nint cnt;\\nTrieNode *getNode() {\\n    auto t = &pool[cnt++];\\n    t->child.resize(CHILD_COUNT);\\n    for (int i = 0; i < CHILD_COUNT; ++i) {\\n        t->child[i] = nullptr;\\n    }\\n    t->availablePrefix = 0;\\n    return t;\\n}\\n\\nclass Solution {\\npublic:\\n    TrieNode *root;\\n    //this would insert all the prefixes of the current string\\n    //in to the TRIE\\n    void insert(const string &word) {\\n        auto ptr = root;\\n        for (char ch: word) {\\n            int idx = ch - \\'a\\';\\n            if (!ptr->child[idx]) {\\n                ptr->child[idx] = getNode();\\n            }\\n            ptr = ptr->child[idx];\\n            ptr->availablePrefix += 1;\\n        }\\n    }\\n    \\n    //This searches a string in TRIE and counts \\n    //all the prefixes along the path\\n    int search (const string &word) {\\n        auto ptr = root;\\n        int prefixCount = 0;\\n        for (char ch: word) {\\n            int idx = ch - \\'a\\';\\n            if (!ptr->child[idx]) {\\n                return prefixCount;\\n            }\\n            ptr = ptr->child[idx];\\n            prefixCount += ptr->availablePrefix;\\n        }\\n        return prefixCount;\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        cnt = 0;\\n        root = getNode();\\n        for (const string &s: words) {\\n            insert(s);\\n        }\\n        vector<int> result;\\n        for (const string &s: words) {\\n            result.push_back(search(s));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729940,
                "title": "python-trie-modular-clean-code",
                "content": "Standard Trie implmentation, which I follow to solve all the Trie problems with just slight variation in search and insert method as per problem statement. Making a habit to follow a template makes you fast and well organized and it leaves the best impression on interviewer.\\n\\nSolution inspired from: https://leetcode.com/problems/sum-of-prefix-scores-of-strings/discuss/2590701/Concise-Python-Tire-Implementation\\n\\nIntuition: While inserting words in Trie, maintain a count of all the prefixes and just sum them up while performing search for each word and each prefix. We can also add a memo dict to keep count of already explored prefixes that will help reduce time complexity but will increase space complexity. A trade-off to choose from but a must to mention during interviews.\\n\\nn = len(words)\\nm = len(max(words))\\n\\nTime Complexity:\\nInsert: O(mn) \\nSearch: O(mn), traversing all the nodes of tree\\n\\nSC: O(mn), from storing it in trie\\n\\n```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.count = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        \\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = Node()\\n\\t\\t\\t# Increment occurrence of the current prefix in Trie\\n            node.children[ch].count += 1\\n            node = node.children[ch]\\n        \\n        node.isWord = True\\n    \\n    def search(self, word) -> int :\\n        score = 0\\n        node = self.root\\n        \\n        for ch in word:\\n\\t\\t\\t# Add count for current prefix \\n            score += node.count\\n            node = node.children[ch]\\n\\t\\t\\t\\n        # Add count for current word          \\n        score += node.count\\n            \\n        return score\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        trie = Trie()\\n        \\n        # Insert word in to trie\\n        for word in words:\\n            trie.insert(word)\\n        \\n        scores =[]\\n        # Search words for all prefixes of current word\\n        for word in words:\\n            scores.append(trie.search(word))\\n        \\n        return scores\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n        self.count = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        \\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = Node()\\n\\t\\t\\t# Increment occurrence of the current prefix in Trie\\n            node.children[ch].count += 1\\n            node = node.children[ch]\\n        \\n        node.isWord = True\\n    \\n    def search(self, word) -> int :\\n        score = 0\\n        node = self.root\\n        \\n        for ch in word:\\n\\t\\t\\t# Add count for current prefix \\n            score += node.count\\n            node = node.children[ch]\\n\\t\\t\\t\\n        # Add count for current word          \\n        score += node.count\\n            \\n        return score\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        trie = Trie()\\n        \\n        # Insert word in to trie\\n        for word in words:\\n            trie.insert(word)\\n        \\n        scores =[]\\n        # Search words for all prefixes of current word\\n        for word in words:\\n            scores.append(trie.search(word))\\n        \\n        return scores\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595173,
                "title": "c-rabin-karp-algorithm-easy-implementation",
                "content": "```\\ntypedef long long  ll;\\nclass Solution {\\npublic:\\n    ll mod = 100000000007;\\n    ll dp[1005],pa[1005];\\n    void preProcess(string s){\\n        ll p = 29; // any prime no.\\n        ll pow = p;\\n\\n        dp[0] = s[0] - \\'a\\' + 1;\\n        pa[0] = 1;\\n        for(ll i = 1;i < s.length();i++){\\n            dp[i] = (dp[i-1] + (s[i] - \\'a\\' + 1) * pow) % mod;\\n            pa[i] = pow;\\n            pow *= p;\\n            pow %= mod;\\n        }\\n    }\\n \\n    ll hashQuery(ll l, ll r){\\n        ll ans = dp[r];\\n        if(l > 0)\\n            ans = (ans - dp[l - 1] + mod) % mod;\\n        return ans;\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        map<ll, int> m;\\n        int n = words.size();\\n        for(int i = 0;i < n;i++){\\n            string s = words[i];\\n            memset(dp, 0, sizeof(dp));\\n            memset(pa, 0, sizeof(pa));\\n            preProcess(s);\\n            ll sum1 = 0;\\n            \\n            for(int j = 0;j < s.length();j++){\\n                ll pref = hashQuery(0, j);\\n                m[pref]++;\\n            }\\n        }\\n        vector<int> ans(n);\\n        for(int i = 0;i < n;i++){\\n            string s = words[i];\\n            ll sum1 = 0,sum2 = 0;\\n            memset(dp, 0, sizeof(dp));\\n            memset(pa, 0, sizeof(pa));\\n            preProcess(s);\\n            for(int j = 0;j < s.length();j++){\\n                ll pref = hashQuery(0, j);\\n                sum2 += m[pref];\\n            }\\n            ans[i] = sum2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long  ll;\\nclass Solution {\\npublic:\\n    ll mod = 100000000007;\\n    ll dp[1005],pa[1005];\\n    void preProcess(string s){\\n        ll p = 29; // any prime no.\\n        ll pow = p;\\n\\n        dp[0] = s[0] - \\'a\\' + 1;\\n        pa[0] = 1;\\n        for(ll i = 1;i < s.length();i++){\\n            dp[i] = (dp[i-1] + (s[i] - \\'a\\' + 1) * pow) % mod;\\n            pa[i] = pow;\\n            pow *= p;\\n            pow %= mod;\\n        }\\n    }\\n \\n    ll hashQuery(ll l, ll r){\\n        ll ans = dp[r];\\n        if(l > 0)\\n            ans = (ans - dp[l - 1] + mod) % mod;\\n        return ans;\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        map<ll, int> m;\\n        int n = words.size();\\n        for(int i = 0;i < n;i++){\\n            string s = words[i];\\n            memset(dp, 0, sizeof(dp));\\n            memset(pa, 0, sizeof(pa));\\n            preProcess(s);\\n            ll sum1 = 0;\\n            \\n            for(int j = 0;j < s.length();j++){\\n                ll pref = hashQuery(0, j);\\n                m[pref]++;\\n            }\\n        }\\n        vector<int> ans(n);\\n        for(int i = 0;i < n;i++){\\n            string s = words[i];\\n            ll sum1 = 0,sum2 = 0;\\n            memset(dp, 0, sizeof(dp));\\n            memset(pa, 0, sizeof(pa));\\n            preProcess(s);\\n            for(int j = 0;j < s.length();j++){\\n                ll pref = hashQuery(0, j);\\n                sum2 += m[pref];\\n            }\\n            ans[i] = sum2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593918,
                "title": "beginner-friendly-trie-implementation-c-solution",
                "content": "In addition to the general implementation of Trie, Storing an extra information how many prefixes end with a specific character in each node.\\n```\\nstruct node{\\n    node* mp[26];\\n    int cnt[26];\\n    bool isPresent(char c){\\n        if(mp[c-\\'a\\']==NULL) return false;\\n        return true;\\n    }\\n    node* getKey(char c){\\n        return mp[c-\\'a\\'];\\n    }\\n    void addKey(char c,node* temp){\\n        mp[c-\\'a\\']=temp;\\n    }\\n    void increment(char c){\\n        cnt[c-\\'a\\']++;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        node *root=new node();\\n        for(auto word:words){\\n            node* temp=root;\\n            for(int i=0;i<word.size();i++){\\n                if(!temp->isPresent(word[i])){\\n                    temp->addKey(word[i],new node());\\n                }\\n                temp->increment(word[i]);\\n                temp=temp->getKey(word[i]);\\n            }\\n        }\\n        vector<int> ans(words.size());\\n        int k=0;\\n        for(auto word:words){\\n            int c=0;\\n            node* temp=root;\\n            for(int i=0;i<word.size();i++){\\n                c+=temp->cnt[word[i]-\\'a\\'];\\n                temp=temp->getKey(word[i]);\\n            }\\n            ans[k]=c;\\n            k++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct node{\\n    node* mp[26];\\n    int cnt[26];\\n    bool isPresent(char c){\\n        if(mp[c-\\'a\\']==NULL) return false;\\n        return true;\\n    }\\n    node* getKey(char c){\\n        return mp[c-\\'a\\'];\\n    }\\n    void addKey(char c,node* temp){\\n        mp[c-\\'a\\']=temp;\\n    }\\n    void increment(char c){\\n        cnt[c-\\'a\\']++;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        node *root=new node();\\n        for(auto word:words){\\n            node* temp=root;\\n            for(int i=0;i<word.size();i++){\\n                if(!temp->isPresent(word[i])){\\n                    temp->addKey(word[i],new node());\\n                }\\n                temp->increment(word[i]);\\n                temp=temp->getKey(word[i]);\\n            }\\n        }\\n        vector<int> ans(words.size());\\n        int k=0;\\n        for(auto word:words){\\n            int c=0;\\n            node* temp=root;\\n            for(int i=0;i<word.size();i++){\\n                c+=temp->cnt[word[i]-\\'a\\'];\\n                temp=temp->getKey(word[i]);\\n            }\\n            ans[k]=c;\\n            k++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591051,
                "title": "trie-java-solution",
                "content": "```\\nclass Solution {\\n\\tclass TrieNode {\\n        TrieNode[] next;\\n        int[] cnt;\\n\\n        public TrieNode() {\\n            next = new TrieNode[26];\\n            cnt = new int[26];\\n        }\\n\\n        \\n    }\\n\\n    public void insert(String word, TrieNode root) {\\n        TrieNode curr = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            int c = word.charAt(i)-\\'a\\';\\n            if (curr.next[c]==null) {\\n                curr.next[c] = new TrieNode();\\n                curr.cnt[c] = 1;\\n            } else {\\n                curr.cnt[c]++;\\n            }\\n            curr = curr.next[c];\\n        }\\n    }\\n\\n    private int getNode(String word, TrieNode root) {\\n        TrieNode curr = root;\\n        int sum = 0;\\n        for (int i = 0; i < word.length(); i++) {\\n            int c = word.charAt(i)-\\'a\\';\\n\\n            if (curr.next[c]==null) {\\n                return 0;\\n            }\\n            sum+=curr.cnt[c];\\n            curr = curr.next[c];\\n        }\\n        return sum;\\n    }\\n\\n\\n    public int[] sumPrefixScores(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for(String str: words) {\\n            insert(str, root);\\n        }\\n        int n = words.length;\\n        int[] ans = new int[n];\\n        for(int i=0; i<n; i++) {\\n            ans[i] = getNode(words[i], root);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n\\tclass TrieNode {\\n        TrieNode[] next;\\n        int[] cnt;\\n\\n        public TrieNode() {\\n            next = new TrieNode[26];\\n            cnt = new int[26];\\n        }\\n\\n        \\n    }\\n\\n    public void insert(String word, TrieNode root) {\\n        TrieNode curr = root;\\n        for (int i = 0; i < word.length(); i++) {\\n            int c = word.charAt(i)-\\'a\\';\\n            if (curr.next[c]==null) {\\n                curr.next[c] = new TrieNode();\\n                curr.cnt[c] = 1;\\n            } else {\\n                curr.cnt[c]++;\\n            }\\n            curr = curr.next[c];\\n        }\\n    }\\n\\n    private int getNode(String word, TrieNode root) {\\n        TrieNode curr = root;\\n        int sum = 0;\\n        for (int i = 0; i < word.length(); i++) {\\n            int c = word.charAt(i)-\\'a\\';\\n\\n            if (curr.next[c]==null) {\\n                return 0;\\n            }\\n            sum+=curr.cnt[c];\\n            curr = curr.next[c];\\n        }\\n        return sum;\\n    }\\n\\n\\n    public int[] sumPrefixScores(String[] words) {\\n        TrieNode root = new TrieNode();\\n        for(String str: words) {\\n            insert(str, root);\\n        }\\n        int n = words.length;\\n        int[] ans = new int[n];\\n        for(int i=0; i<n; i++) {\\n            ans[i] = getNode(words[i], root);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590890,
                "title": "c-easy-solution-trie",
                "content": "I have created `Trie` data structure with array of pointers `next` to point all alphabets and `wordCount` which will store number of words having prefix string ending at current node.\\n\\nFor example - consider array of strings `[\"abc\", \"ab\", \"b\"]`\\nTrie will be like -\\n```\\n\\t\\t\\t\\t\\t\\t\\t Root\\n\\t\\t\\t\\t\\t\\t wordCount = 0\\n\\t\\t\\t\\t\\t\\t/              \\\\\\n\\t\\t\\t\\t      \\'a\\'               \\'b\\'\\n\\t\\t    \\twordCount = 2       wordCount = 1\\n\\t\\t          /\\n\\t\\t       \\'b\\'\\n\\t\\t  wordCount = 2\\n\\t\\t\\t/\\n\\t\\t\\'c\\'\\n   wordCount = 1\\n\\n```\\n\\nThen for each word i have traversed the trie data structure and added `wordCount` for each character.\\n\\n```\\nclass trie {\\n    public:\\n    trie* next[26] = {};\\n    int wordCount;\\n    trie(){\\n        wordCount = 0;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        trie* root = new trie();\\n        int n = words.size();\\n        \\n\\t\\t// constructing trie data structure\\n        for (int i = 0; i < n; i++) {\\n            auto cur = root;\\n            for (char c : words[i]) {\\n                if (!cur -> next[c - \\'a\\'])\\n                    cur -> next[c - \\'a\\'] = new trie();\\n                cur = cur -> next[c - \\'a\\'];\\n                cur -> wordCount++;\\n            }\\n        }\\n        \\n\\t\\t// calculating ans for each word\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            auto cur = root;\\n            for (int j = 0; j < words[i].size(); j++) {\\n                cur = cur -> next[words[i][j] - \\'a\\'];\\n                ans[i] += cur -> wordCount;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nHope it helps and feel free to ask if you have any doubts :)",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t Root\\n\\t\\t\\t\\t\\t\\t wordCount = 0\\n\\t\\t\\t\\t\\t\\t/              \\\\\\n\\t\\t\\t\\t      \\'a\\'               \\'b\\'\\n\\t\\t    \\twordCount = 2       wordCount = 1\\n\\t\\t          /\\n\\t\\t       \\'b\\'\\n\\t\\t  wordCount = 2\\n\\t\\t\\t/\\n\\t\\t\\'c\\'\\n   wordCount = 1\\n\\n```\n```\\nclass trie {\\n    public:\\n    trie* next[26] = {};\\n    int wordCount;\\n    trie(){\\n        wordCount = 0;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        trie* root = new trie();\\n        int n = words.size();\\n        \\n\\t\\t// constructing trie data structure\\n        for (int i = 0; i < n; i++) {\\n            auto cur = root;\\n            for (char c : words[i]) {\\n                if (!cur -> next[c - \\'a\\'])\\n                    cur -> next[c - \\'a\\'] = new trie();\\n                cur = cur -> next[c - \\'a\\'];\\n                cur -> wordCount++;\\n            }\\n        }\\n        \\n\\t\\t// calculating ans for each word\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            auto cur = root;\\n            for (int j = 0; j < words[i].size(); j++) {\\n                cur = cur -> next[words[i][j] - \\'a\\'];\\n                ans[i] += cur -> wordCount;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590772,
                "title": "python3-simple-trie",
                "content": "```.\\nclass TrieNode:\\n        def __init__(self):\\n            self.children = {}\\n            self.word = False\\n            self.count = 1\\n            \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        trav = self.root\\n        for c in word:\\n            if c in trav.children:\\n                trav.children[c].count += 1\\n                trav = trav.children[c]\\n            else:\\n                trav.children[c] = TrieNode()\\n                trav = trav.children[c]\\n        trav.word = True\\n\\nclass Solution:\\n    \\n        \\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        trie = Trie()\\n        \\n        for word in words:\\n            trie.insert(word)\\n        \\n        ans = []\\n        for word in words:\\n            count = 0\\n            trav = trie.root\\n            for c in word:\\n                if c in trav.children:\\n                    count += trav.children[c].count\\n                    trav = trav.children[c]\\n            ans.append(count)\\n            \\n        return ans\\n \\xA0 \\xA0 ``",
                "solutionTags": [],
                "code": "```.\\nclass TrieNode:\\n        def __init__(self):\\n            self.children = {}\\n            self.word = False\\n            self.count = 1\\n            \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        trav = self.root\\n        for c in word:\\n            if c in trav.children:\\n                trav.children[c].count += 1\\n                trav = trav.children[c]\\n            else:\\n                trav.children[c] = TrieNode()\\n                trav = trav.children[c]\\n        trav.word = True\\n\\nclass Solution:\\n    \\n        \\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        trie = Trie()\\n        \\n        for word in words:\\n            trie.insert(word)\\n        \\n        ans = []\\n        for word in words:\\n            count = 0\\n            trav = trie.root\\n            for c in word:\\n                if c in trav.children:\\n                    count += trav.children[c].count\\n                    trav = trav.children[c]\\n            ans.append(count)\\n            \\n        return ans\\n \\xA0 \\xA0 ``",
                "codeTag": "Java"
            },
            {
                "id": 2590536,
                "title": "c-trie-solution",
                "content": "```cpp\\nclass Node {\\npublic:\\n    char ch;\\n    Node* children[26] = {nullptr};\\n    int prefix_cnt;\\n};\\n\\nclass Solution {\\nprivate:\\n    Node* root = new Node;\\n    int prefixCount(string &prefix) {\\n        Node* tmp = root;\\n        int cnt = 0;\\n        for (char &ch : prefix) {\\n            int index = ch - \\'a\\';\\n            if (tmp->children[index] == nullptr) break;\\n            tmp = tmp->children[index];\\n            cnt += tmp->prefix_cnt;\\n        }\\n        return cnt;\\n    }\\n    void insertWord(string &word) {\\n        Node* ptr = root;\\n        for (char &ch : word) {\\n            if (ptr->children[ch - \\'a\\'] == nullptr)\\n                ptr->children[ch - \\'a\\'] = new Node();\\n            ptr = ptr->children[ch - \\'a\\'];\\n            ptr->prefix_cnt++;\\n        }\\n    }\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> res;\\n        for (string &word : words) insertWord(word);\\n        for (string &word : words) {\\n            int r = prefixCount(word);\\n            res.push_back(r);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```cpp\\nclass Node {\\npublic:\\n    char ch;\\n    Node* children[26] = {nullptr};\\n    int prefix_cnt;\\n};\\n\\nclass Solution {\\nprivate:\\n    Node* root = new Node;\\n    int prefixCount(string &prefix) {\\n        Node* tmp = root;\\n        int cnt = 0;\\n        for (char &ch : prefix) {\\n            int index = ch - \\'a\\';\\n            if (tmp->children[index] == nullptr) break;\\n            tmp = tmp->children[index];\\n            cnt += tmp->prefix_cnt;\\n        }\\n        return cnt;\\n    }\\n    void insertWord(string &word) {\\n        Node* ptr = root;\\n        for (char &ch : word) {\\n            if (ptr->children[ch - \\'a\\'] == nullptr)\\n                ptr->children[ch - \\'a\\'] = new Node();\\n            ptr = ptr->children[ch - \\'a\\'];\\n            ptr->prefix_cnt++;\\n        }\\n    }\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> res;\\n        for (string &word : words) insertWord(word);\\n        for (string &word : words) {\\n            int r = prefixCount(word);\\n            res.push_back(r);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590495,
                "title": "java-trie-o-nm-time-easy-to-understand",
                "content": "``` java\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        if (words.length == 1) {\\n            return new int[] { words[0].length() };\\n        }\\n        \\n        Trie trie = new Trie();\\n        for (String word : words) {\\n            trie.addWord(word);\\n        }\\n        int[] ans = new int[words.length];\\n        for (int i = 0; i < words.length; i++) {\\n            ans[i] = trie.getPrefixCount(words[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(String word) {\\n        TrieNode current = root;\\n        for (char c : word.toCharArray()) {\\n            int index = c - \\'a\\';\\n            if (current.children[index] == null) {\\n                current.children[index] = new TrieNode();\\n            }\\n            current.children[index].prefixCount++;\\n            current = current.children[index];\\n        }\\n    }\\n    \\n    int getPrefixCount(String word) {\\n        int sum = 0;\\n        TrieNode current = root;\\n        for (char c : word.toCharArray()) {\\n            int index = c - \\'a\\';\\n            if (current.children[index] == null) {\\n                return sum;\\n            }\\n            current = current.children[index];\\n            sum += current.prefixCount;\\n        }\\n        return sum;\\n    }\\n}\\n\\nclass TrieNode {\\n    final static int R = 26;\\n    \\n    int prefixCount;\\n    TrieNode[] children;\\n    \\n    TrieNode() {\\n        prefixCount = 0;\\n        children = new TrieNode[R];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "``` java\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        if (words.length == 1) {\\n            return new int[] { words[0].length() };\\n        }\\n        \\n        Trie trie = new Trie();\\n        for (String word : words) {\\n            trie.addWord(word);\\n        }\\n        int[] ans = new int[words.length];\\n        for (int i = 0; i < words.length; i++) {\\n            ans[i] = trie.getPrefixCount(words[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    void addWord(String word) {\\n        TrieNode current = root;\\n        for (char c : word.toCharArray()) {\\n            int index = c - \\'a\\';\\n            if (current.children[index] == null) {\\n                current.children[index] = new TrieNode();\\n            }\\n            current.children[index].prefixCount++;\\n            current = current.children[index];\\n        }\\n    }\\n    \\n    int getPrefixCount(String word) {\\n        int sum = 0;\\n        TrieNode current = root;\\n        for (char c : word.toCharArray()) {\\n            int index = c - \\'a\\';\\n            if (current.children[index] == null) {\\n                return sum;\\n            }\\n            current = current.children[index];\\n            sum += current.prefixCount;\\n        }\\n        return sum;\\n    }\\n}\\n\\nclass TrieNode {\\n    final static int R = 26;\\n    \\n    int prefixCount;\\n    TrieNode[] children;\\n    \\n    TrieNode() {\\n        prefixCount = 0;\\n        children = new TrieNode[R];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590388,
                "title": "java-trie-solution",
                "content": "```\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        Tries trie=new Tries();\\n        \\n        \\n        \\n        for(String word:words){\\n            \\n            add(word,trie);\\n        }\\n        \\n        int[] res=new int[words.length];\\n        \\n        \\n        for(int i=0;i<words.length;i++){\\n            \\n            Tries temp=trie;\\n            res[i]=count(temp,words[i],0);\\n        }\\n        return res;\\n    }\\n    \\n    public int count(Tries temp,String word,int in){\\n        \\n        \\n        if(in==word.length()) return 0;\\n        char ch=word.charAt(in);\\n        \\n        int ans=0;\\n        if(temp.map.containsKey(ch)){\\n           // System.out.println(ch+\" -->\"+temp.count);\\n          ans+=temp.map.get(ch).count+count(temp.map.get(ch),word,in+1);  \\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public void add(String str,Tries trie){\\n        \\n        Tries temp=trie;\\n        for(int i=0;i<str.length();i++){\\n            \\n            char ch=str.charAt(i);\\n            \\n            if(!temp.map.containsKey(ch)){\\n                temp.map.put(ch,new Tries());\\n            }\\n            \\n            \\n            temp=temp.map.get(ch);\\n            temp.count+=1;\\n        }\\n    }\\n    public class Tries{\\n        \\n        HashMap<Character,Tries> map=new HashMap<>();\\n        int count=0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        Tries trie=new Tries();\\n        \\n        \\n        \\n        for(String word:words){\\n            \\n            add(word,trie);\\n        }\\n        \\n        int[] res=new int[words.length];\\n        \\n        \\n        for(int i=0;i<words.length;i++){\\n            \\n            Tries temp=trie;\\n            res[i]=count(temp,words[i],0);\\n        }\\n        return res;\\n    }\\n    \\n    public int count(Tries temp,String word,int in){\\n        \\n        \\n        if(in==word.length()) return 0;\\n        char ch=word.charAt(in);\\n        \\n        int ans=0;\\n        if(temp.map.containsKey(ch)){\\n           // System.out.println(ch+\" -->\"+temp.count);\\n          ans+=temp.map.get(ch).count+count(temp.map.get(ch),word,in+1);  \\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public void add(String str,Tries trie){\\n        \\n        Tries temp=trie;\\n        for(int i=0;i<str.length();i++){\\n            \\n            char ch=str.charAt(i);\\n            \\n            if(!temp.map.containsKey(ch)){\\n                temp.map.put(ch,new Tries());\\n            }\\n            \\n            \\n            temp=temp.map.get(ch);\\n            temp.count+=1;\\n        }\\n    }\\n    public class Tries{\\n        \\n        HashMap<Character,Tries> map=new HashMap<>();\\n        int count=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590235,
                "title": "very-simple-python-trie-code",
                "content": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = {}\\n        \\n        for word in words:\\n            t = trie\\n            for char in word:\\n                if char not in t:\\n                    t[char] = {}\\n                t = t[char]\\n                if \\'$\\' not in t:\\n                    t[\\'$\\'] = 0\\n                t[\\'$\\'] += 1\\n        \\n        ans = []\\n        \\n        for word in words:\\n            t = trie\\n            temp_ans = 0\\n            for char in word:\\n                t = t[char]\\n                temp_ans += t[\\'$\\']\\n            ans.append(temp_ans)\\n        return ans \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = {}",
                "codeTag": "Java"
            },
            {
                "id": 2590160,
                "title": "simple-solution-using-trie-tree",
                "content": "The question gives Intution of Trie tree as storing all the prefixes will cause TLE\\n\\nWith the standard implementation of trie tree we can keep a array of count that will count the frequency of that charcater\\n\\n=>> Below is the simple CPP implementation\\n\\n```\\nstruct Node{\\n    bool flag=false;\\n    int count[26] = {0};\\n    Node* links[26];\\n\\t// Increment count while getting the next node\\n    Node* get(char ch){\\n        count[ch-\\'a\\']++;\\n        return links[ch-\\'a\\'];\\n    }\\n\\t// As we need not to increment count when we are getting to build ans\\n    Node* get2(char ch){\\n        // count[ch-\\'a\\']++;\\n        return links[ch-\\'a\\'];\\n    }\\n    int getCount(char ch){\\n        return count[ch-\\'a\\'];\\n    }\\n\\t// Adding next character to trie\\n    void put(char ch,Node* temp){\\n        // count[ch-\\'a\\']++;\\n        links[ch-\\'a\\']=temp;\\n    }\\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Node *root;\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(string s){\\n        Node* temp=root;\\n        for(int i=0;i<s.size();i++){\\n            if(!temp->containsKey(s[i]))\\n                temp->put(s[i],new Node());\\n            temp=temp->get(s[i]);\\n        }\\n        temp->flag=true;\\n    }\\n    \\n    int getAns(string s) {\\n        Node* temp = root;\\n        int ans = 0;\\n        for(int i=0;i<s.size();i++) {\\n            ans += temp->getCount(s[i]);\\n            temp = temp->get2(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        int n = words.size();\\n        Trie trie;\\n        for(string s:words) trie.insert(s);\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;i++) {\\n            ans[i] = trie.getAns(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    bool flag=false;\\n    int count[26] = {0};\\n    Node* links[26];\\n\\t// Increment count while getting the next node\\n    Node* get(char ch){\\n        count[ch-\\'a\\']++;\\n        return links[ch-\\'a\\'];\\n    }\\n\\t// As we need not to increment count when we are getting to build ans\\n    Node* get2(char ch){\\n        // count[ch-\\'a\\']++;\\n        return links[ch-\\'a\\'];\\n    }\\n    int getCount(char ch){\\n        return count[ch-\\'a\\'];\\n    }\\n\\t// Adding next character to trie\\n    void put(char ch,Node* temp){\\n        // count[ch-\\'a\\']++;\\n        links[ch-\\'a\\']=temp;\\n    }\\n    bool containsKey(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Node *root;\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(string s){\\n        Node* temp=root;\\n        for(int i=0;i<s.size();i++){\\n            if(!temp->containsKey(s[i]))\\n                temp->put(s[i],new Node());\\n            temp=temp->get(s[i]);\\n        }\\n        temp->flag=true;\\n    }\\n    \\n    int getAns(string s) {\\n        Node* temp = root;\\n        int ans = 0;\\n        for(int i=0;i<s.size();i++) {\\n            ans += temp->getCount(s[i]);\\n            temp = temp->get2(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        int n = words.size();\\n        Trie trie;\\n        for(string s:words) trie.insert(s);\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;i++) {\\n            ans[i] = trie.getAns(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237205,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass node{\\n    public:\\n    node* next[26];\\n    int count;\\n    node()\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            next[i]=NULL;\\n        }\\n        count=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        // a ab abc --> 5\\n        // 1 1   1\\n        // 2 2   1\\n        // a ab     -->4\\n        vector<int>ans;\\n        node* root=new node();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            insert(root,words[i]);\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            ans.push_back(search(root,words[i]));\\n        }\\n        return ans;\\n    }\\n    int search(node* root,string &s)\\n    {\\n        node* temp=root;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(temp->next[s[i]-\\'a\\']!=NULL)\\n            {\\n                temp=temp->next[s[i]-\\'a\\'];\\n                ans+=temp->count;\\n            }\\n        }\\n        return ans;\\n    }\\n    void insert(node* root,string &s)\\n    {\\n        int c=0;\\n        node* temp=root;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(temp->next[s[i]-\\'a\\']!=NULL)\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                temp->next[s[i]-\\'a\\']=new node();\\n            }\\n            temp=temp->next[s[i]-\\'a\\'];\\n            temp->count++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass node{\\n    public:\\n    node* next[26];\\n    int count;\\n    node()\\n    {\\n        for(int i=0;i<26;i++)\\n        {\\n            next[i]=NULL;\\n        }\\n        count=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        // a ab abc --> 5\\n        // 1 1   1\\n        // 2 2   1\\n        // a ab     -->4\\n        vector<int>ans;\\n        node* root=new node();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            insert(root,words[i]);\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            ans.push_back(search(root,words[i]));\\n        }\\n        return ans;\\n    }\\n    int search(node* root,string &s)\\n    {\\n        node* temp=root;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(temp->next[s[i]-\\'a\\']!=NULL)\\n            {\\n                temp=temp->next[s[i]-\\'a\\'];\\n                ans+=temp->count;\\n            }\\n        }\\n        return ans;\\n    }\\n    void insert(node* root,string &s)\\n    {\\n        int c=0;\\n        node* temp=root;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(temp->next[s[i]-\\'a\\']!=NULL)\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                temp->next[s[i]-\\'a\\']=new node();\\n            }\\n            temp=temp->next[s[i]-\\'a\\'];\\n            temp->count++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237148,
                "title": "trie-prefix-tree-very-easy-to-understand",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass node\\n{\\n    public:\\n    int count;\\n    node* next[26];\\n\\n    node()\\n    {\\n        count = 0;\\n        for(int i=0;i<26;i++)\\n        {\\n            next[i] = NULL;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) \\n    {\\n          node* root = new node();\\n\\n          for(int i=0;i<words.size();i++)\\n          {\\n              node* temp = root;\\n              string word = words[i];\\n              for(int j=0;j<(word.length());j++)\\n              {\\n                    char ch = word[j];\\n\\n                    if(temp->next[ch-\\'a\\'] == NULL)\\n                    {\\n                        temp->next[ch - \\'a\\'] = new node();\\n                    }\\n                    temp = temp->next[ch-\\'a\\'];             \\n                    temp->count++;   \\n              }\\n          }      \\n          vector<int>ans;\\n          for(int i=0;i<words.size();i++)\\n          {\\n               string word = words[i];\\n               node* temp = root;\\n               int val = 0;\\n              \\n               for(int j=0;j<word.length();j++)\\n               {\\n                     char ch = word[j];\\n                     temp = temp->next[ch-\\'a\\'];\\n                     val = val + temp->count;         \\n               }\\n               ans.push_back(val);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Trie",
                    "Counting"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass node\\n{\\n    public:\\n    int count;\\n    node* next[26];\\n\\n    node()\\n    {\\n        count = 0;\\n        for(int i=0;i<26;i++)\\n        {\\n            next[i] = NULL;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) \\n    {\\n          node* root = new node();\\n\\n          for(int i=0;i<words.size();i++)\\n          {\\n              node* temp = root;\\n              string word = words[i];\\n              for(int j=0;j<(word.length());j++)\\n              {\\n                    char ch = word[j];\\n\\n                    if(temp->next[ch-\\'a\\'] == NULL)\\n                    {\\n                        temp->next[ch - \\'a\\'] = new node();\\n                    }\\n                    temp = temp->next[ch-\\'a\\'];             \\n                    temp->count++;   \\n              }\\n          }      \\n          vector<int>ans;\\n          for(int i=0;i<words.size();i++)\\n          {\\n               string word = words[i];\\n               node* temp = root;\\n               int val = 0;\\n              \\n               for(int j=0;j<word.length();j++)\\n               {\\n                     char ch = word[j];\\n                     temp = temp->next[ch-\\'a\\'];\\n                     val = val + temp->count;         \\n               }\\n               ans.push_back(val);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3215742,
                "title": "c-o-n-k-log-n-100-runtime-100-memory",
                "content": "# Intuition\\nSuppose $$words$$ is sorted lexicographically. It\\'s easy to see that for $$words[i]$$ and some of its prefix it\\'s true that all words with this prefix are in the contiguous subarray $$words[l..r-1],$$ $$l \\\\le i < r$$. So for a prefix $$p$$ of some word there is an interval $$[l..r)$$ that contains all words with this prefix, hence $$r - l$$ is the score of $$p$$.\\n\\n# Approach\\n- Sort $$words$$\\n- Create the list $$r := [n]$$, which last element denotes the right bound of words with considering prefix $$p$$ and $$count(r) = |p| - 1$$\\n- For $$i$$ = $$0..n-1$$ count $$ans[i]$$ and partially count the rest $$ans[j]$$, $$j > i$$:\\n  - Remove last element from $$r$$ until the right bound $$r[count(r)-1] > i$$\\n  - For $$j = count(r)-1..|words[i]|-1$$\\n    - Find the rightmost index $$k$$ such that $$words[i][0..j]$$ is the prefix of $$words[k]$$\\n    - Add $$k - i + 1$$ (score of $$words[i][0..j]$$) to $$ans[m]$$ for $$m = i..k$$\\n    - $$r[j + 1] := k + 1$$\\n- Reorder $$ans$$ to match the original order of $$words$$ \\n\\n# Complexity\\n$$n = $$`words.Length`, $$k = \\\\max_{i=0}^{n-1}$$`words[i].Length` \\n- Time complexity:\\n$$O(nk\\\\log n)$$\\n- Space complexity:\\n$$O(n + k)$$\\n\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    private struct Pair \\n    {\\n        public readonly string s;\\n        public readonly int i;\\n\\n        public Pair(string s, int i)\\n        {\\n            this.s = s;\\n            this.i = i;\\n        }\\n    }\\n\\n    public int[] SumPrefixScores(string[] words) \\n    {\\n        int n = words.Length;\\n\\n        var w = new Pair[n];\\n        for (int i = 0; i < n; ++i)\\n        {\\n            w[i] = new Pair(words[i], i);\\n        }\\n        Array.Sort(w, (a, b) => a.s.CompareTo(b.s));\\n\\n        var ans = new int[n];\\n        var r = new List<int> { n };\\n        for (int i = 0; i < n; ++i)\\n        {\\n            while (i >= r[^1])\\n                r.RemoveAt(r.Count - 1);\\n\\n            for (int j = r.Count - 1; j < w[i].s.Length; ++j)\\n            {\\n                int cnt = 0;\\n                for (int k = i; k < r[j]; ++k)\\n                {\\n                    if (w[k].s[j] == w[i].s[j])\\n                        ++cnt;\\n                    else break;\\n                }\\n                r.Add(i + cnt);\\n\\n                for (int k = i; k < i + cnt; ++k)\\n                    ans[w[k].i] += cnt;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n![image 263.png](https://assets.leetcode.com/users/images/6b44e254-5112-489f-933b-1ec77a715c69_1676992986.2214217.png)\\n",
                "solutionTags": [
                    "C#",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private struct Pair \\n    {\\n        public readonly string s;\\n        public readonly int i;\\n\\n        public Pair(string s, int i)\\n        {\\n            this.s = s;\\n            this.i = i;\\n        }\\n    }\\n\\n    public int[] SumPrefixScores(string[] words) \\n    {\\n        int n = words.Length;\\n\\n        var w = new Pair[n];\\n        for (int i = 0; i < n; ++i)\\n        {\\n            w[i] = new Pair(words[i], i);\\n        }\\n        Array.Sort(w, (a, b) => a.s.CompareTo(b.s));\\n\\n        var ans = new int[n];\\n        var r = new List<int> { n };\\n        for (int i = 0; i < n; ++i)\\n        {\\n            while (i >= r[^1])\\n                r.RemoveAt(r.Count - 1);\\n\\n            for (int j = r.Count - 1; j < w[i].s.Length; ++j)\\n            {\\n                int cnt = 0;\\n                for (int k = i; k < r[j]; ++k)\\n                {\\n                    if (w[k].s[j] == w[i].s[j])\\n                        ++cnt;\\n                    else break;\\n                }\\n                r.Add(i + cnt);\\n\\n                for (int k = i; k < i + cnt; ++k)\\n                    ans[w[k].i] += cnt;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106959,
                "title": "use-array-instead-of-vector-95-80-faster-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class Trie{\\n        public:\\n        Trie* container[26];\\n        int count=0;\\n\\n        void insert(string &s,Trie* root){\\n            Trie* temp=root;\\n            int n=s.length();\\n            for(int i=0;i<n;i++){\\n                if(temp->container[s[i]-\\'a\\']==NULL){\\n                    temp->container[s[i]-\\'a\\']=new Trie();\\n                }\\n                temp=temp->container[s[i]-\\'a\\'];temp->count++;\\n            }\\n            return;\\n        }\\n\\n        int search(string &s,Trie* root){\\n            Trie* temp=root;\\n            int n=s.length(),current=0;\\n            for(int i=0;i<n;i++){\\n                temp=temp->container[s[i]-\\'a\\'];\\n                if(temp->count==1){\\n                    return current+n-i;\\n                }\\n                current+=temp->count;\\n            }\\n            return current;\\n        }\\n    };\\n\\n    vector<int> sumPrefixScores(vector<string>& words){\\n        int n=words.size();\\n        vector<int>answer;\\n        Trie trie;\\n        Trie* root=new Trie();\\n        for(int i=0;i<n;i++){\\n            trie.insert(words[i],root);\\n        }\\n        for(int i=0;i<n;i++){\\n            answer.push_back(trie.search(words[i],root));\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Trie{\\n        public:\\n        Trie* container[26];\\n        int count=0;\\n\\n        void insert(string &s,Trie* root){\\n            Trie* temp=root;\\n            int n=s.length();\\n            for(int i=0;i<n;i++){\\n                if(temp->container[s[i]-\\'a\\']==NULL){\\n                    temp->container[s[i]-\\'a\\']=new Trie();\\n                }\\n                temp=temp->container[s[i]-\\'a\\'];temp->count++;\\n            }\\n            return;\\n        }\\n\\n        int search(string &s,Trie* root){\\n            Trie* temp=root;\\n            int n=s.length(),current=0;\\n            for(int i=0;i<n;i++){\\n                temp=temp->container[s[i]-\\'a\\'];\\n                if(temp->count==1){\\n                    return current+n-i;\\n                }\\n                current+=temp->count;\\n            }\\n            return current;\\n        }\\n    };\\n\\n    vector<int> sumPrefixScores(vector<string>& words){\\n        int n=words.size();\\n        vector<int>answer;\\n        Trie trie;\\n        Trie* root=new Trie();\\n        for(int i=0;i<n;i++){\\n            trie.insert(words[i],root);\\n        }\\n        for(int i=0;i<n;i++){\\n            answer.push_back(trie.search(words[i],root));\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823634,
                "title": "javascript-simple-trie-implementation",
                "content": "It\\'s a pretty simple and understandable solution, written in Javascript\\n\\n```\\nvar sumPrefixScores = function(words) {\\n    const n = words.length;\\n    const trie = {_count: 0};\\n    const result = [];\\n    \\n\\t// Create our own custom trie with _count property.\\n    // We are storing how many time we passed current node.\\n    for (let i = 0; i < n; i++) {\\n        const word = words[i];\\n        \\n        let node = trie;\\n        for (let j = 0; j < word.length; j++) {\\n            if (!node[word[j]]) node[word[j]] = {};\\n            node = node[word[j]];\\n            node._count = (node._count || 0) + 1;\\n        }\\n    }\\n    \\n\\t// Collect all _count values together as a result\\n    for (let i = 0; i < n; i++) {\\n        const word = words[i];\\n        let count = 0;\\n        \\n        let node = trie;\\n        for (let j = 0; j < word.length; j++) {\\n            node = node[word[j]];\\n            count += (node._count || 0);\\n        }\\n        \\n        result[i] = count;\\n    }\\n    \\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "It\\'s a pretty simple and understandable solution, written in Javascript\\n\\n```\\nvar sumPrefixScores = function(words) {\\n    const n = words.length;\\n    const trie = {_count: 0};\\n    const result = [];\\n    \\n\\t// Create our own custom trie with _count property.\\n    // We are storing how many time we passed current node.\\n    for (let i = 0; i < n; i++) {\\n        const word = words[i];\\n        \\n        let node = trie;\\n        for (let j = 0; j < word.length; j++) {\\n            if (!node[word[j]]) node[word[j]] = {};\\n            node = node[word[j]];\\n            node._count = (node._count || 0) + 1;\\n        }\\n    }\\n    \\n\\t// Collect all _count values together as a result\\n    for (let i = 0; i < n; i++) {\\n        const word = words[i];\\n        let count = 0;\\n        \\n        let node = trie;\\n        for (let j = 0; j < word.length; j++) {\\n            node = node[word[j]];\\n            count += (node._count || 0);\\n        }\\n        \\n        result[i] = count;\\n    }\\n    \\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2713072,
                "title": "c-fully-optimized-trie-99-faster-87-less-memory",
                "content": "This is based on the Trie approach but with significantly less memory usage.\\nMy original Trie was 779 ms\\t700.9 MB\\nThis one is 353 ms\\t186.5 MB\\nhttps://leetcode.com/submissions/detail/824255922/\\n\\nI don\\'t remember what this method is called. Please comment if you know the name.\\n\\nTake \"abcd\", \"abef\" for example:\\n1. \"abcd\": I will first create the \"a\" node in Trie, then put \"abcd\" into str field of the \"a\" node and stop.\\n2a. \"abef\": I see that \"a\" node exists, and the str field is not empty. Thus I need to move the \"abcd\".\\n2b. For the original \"abcd\", \"b\" node is created. I then check if b also exists in \"abef\" in the same position.\\n2c. I continue to go thru the first string until either my current index exceeds the length of either string, or if the character at the current position in both strings no longer matches.\\n2d. Finally, for \"abcd\", I create the \"c\" node, and copy \"cd\" into it.\\n2e. For \"abef\", I create the \"e\" node, and copy \"ef\" into it.\\n2f. I clean up the \"abcd\" in the \"a\" node because it has been moevd.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef struct Trie {\\n        struct Trie *data[26]{};\\n        char *str{};\\n        int vis{}, slen{};\\n    } Trie;\\n\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> ret;\\n        Trie *root = (Trie *) calloc(1, sizeof(Trie)), *tmp, *tmp2;\\n        int sum, depth;\\n\\n        for (string &x : words)\\n        {\\n            tmp = root;\\n            for (int i = 0, ilen = x.size(); i < ilen; ++i)\\n            {\\n                char y = x[i] - \\'a\\';\\n                if (!tmp->data[y])\\n                {\\n                    // If the node does not exist, create node, copy the entire substring into \"str\" field and stop\\n                    tmp->data[y] = (Trie *) calloc(1, sizeof(Trie));\\n                    tmp = tmp->data[y];\\n                    tmp->vis = 1;\\n                    tmp->slen = ilen - i;\\n                    tmp->str = (char *) calloc(1, tmp->slen + 1);\\n                    memcpy(tmp->str, x.data() + i, tmp->slen);\\n                    break;\\n                }\\n\\n                tmp = tmp->data[y];\\n                ++tmp->vis;\\n                // If the node exists and \"str\" field is empty, continue\\n                if (tmp->slen == 0) continue;\\n\\n                int j, jlen = tmp->slen;\\n                char *&ts = tmp->str;\\n                int &tslen = tmp->slen;\\n                // Find the index where the two strings are no longer the same\\n                for (j = 1; j < jlen && j + i < ilen && x[j + i] == ts[j]; ++j)\\n                {\\n                    y = ts[j] - \\'a\\';\\n                    tmp->data[y] = (Trie *) calloc(1, sizeof(Trie));\\n                    tmp = tmp->data[y];\\n                    tmp->vis = 2;\\n                }\\n\\n                // Create new nodes and copy substrings for the two strings, if applicable\\n                tmp2 = tmp;\\n                if (j < jlen)\\n                {\\n                    y = ts[j] - \\'a\\';\\n                    tmp->data[y] = (Trie *) calloc(1, sizeof(Trie));\\n                    tmp = tmp->data[y];\\n                    tmp->vis = 1;\\n                    tmp->slen = jlen - j;\\n                    tmp->str = (char *) calloc(1, tmp->slen + 1);\\n                    memcpy(tmp->str, ts + j, tmp->slen);\\n                }\\n                j += i;\\n                if (j < ilen)\\n                {\\n                    tmp = tmp2;\\n                    y = x[j] - \\'a\\';\\n                    tmp->data[y] = (Trie *) calloc(1, sizeof(Trie));\\n                    tmp = tmp->data[y];\\n                    tmp->vis = 1;\\n                    tmp->slen = ilen - j;\\n                    tmp->str = (char *) calloc(1, tmp->slen + 1);\\n                    memcpy(tmp->str, x.data() + j, tmp->slen);\\n                }\\n                free(ts);\\n                ts = NULL;\\n                tslen = 0;\\n                break;\\n            }\\n        }\\n\\n        // Tally results\\n        for (string &x : words)\\n        {\\n            tmp = root;\\n            sum = depth = 0;\\n            for (char y : x)\\n            {\\n                y -= \\'a\\';\\n                tmp = tmp->data[y];\\n                if (tmp->vis == 1)\\n                {\\n                    sum += x.size() - depth;\\n                    break;\\n                }\\n                sum += tmp->vis;\\n                ++depth;\\n            }\\n            ret.push_back(sum);\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef struct Trie {\\n        struct Trie *data[26]{};\\n        char *str{};\\n        int vis{}, slen{};\\n    } Trie;\\n\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> ret;\\n        Trie *root = (Trie *) calloc(1, sizeof(Trie)), *tmp, *tmp2;\\n        int sum, depth;\\n\\n        for (string &x : words)\\n        {\\n            tmp = root;\\n            for (int i = 0, ilen = x.size(); i < ilen; ++i)\\n            {\\n                char y = x[i] - \\'a\\';\\n                if (!tmp->data[y])\\n                {\\n                    // If the node does not exist, create node, copy the entire substring into \"str\" field and stop\\n                    tmp->data[y] = (Trie *) calloc(1, sizeof(Trie));\\n                    tmp = tmp->data[y];\\n                    tmp->vis = 1;\\n                    tmp->slen = ilen - i;\\n                    tmp->str = (char *) calloc(1, tmp->slen + 1);\\n                    memcpy(tmp->str, x.data() + i, tmp->slen);\\n                    break;\\n                }\\n\\n                tmp = tmp->data[y];\\n                ++tmp->vis;\\n                // If the node exists and \"str\" field is empty, continue\\n                if (tmp->slen == 0) continue;\\n\\n                int j, jlen = tmp->slen;\\n                char *&ts = tmp->str;\\n                int &tslen = tmp->slen;\\n                // Find the index where the two strings are no longer the same\\n                for (j = 1; j < jlen && j + i < ilen && x[j + i] == ts[j]; ++j)\\n                {\\n                    y = ts[j] - \\'a\\';\\n                    tmp->data[y] = (Trie *) calloc(1, sizeof(Trie));\\n                    tmp = tmp->data[y];\\n                    tmp->vis = 2;\\n                }\\n\\n                // Create new nodes and copy substrings for the two strings, if applicable\\n                tmp2 = tmp;\\n                if (j < jlen)\\n                {\\n                    y = ts[j] - \\'a\\';\\n                    tmp->data[y] = (Trie *) calloc(1, sizeof(Trie));\\n                    tmp = tmp->data[y];\\n                    tmp->vis = 1;\\n                    tmp->slen = jlen - j;\\n                    tmp->str = (char *) calloc(1, tmp->slen + 1);\\n                    memcpy(tmp->str, ts + j, tmp->slen);\\n                }\\n                j += i;\\n                if (j < ilen)\\n                {\\n                    tmp = tmp2;\\n                    y = x[j] - \\'a\\';\\n                    tmp->data[y] = (Trie *) calloc(1, sizeof(Trie));\\n                    tmp = tmp->data[y];\\n                    tmp->vis = 1;\\n                    tmp->slen = ilen - j;\\n                    tmp->str = (char *) calloc(1, tmp->slen + 1);\\n                    memcpy(tmp->str, x.data() + j, tmp->slen);\\n                }\\n                free(ts);\\n                ts = NULL;\\n                tslen = 0;\\n                break;\\n            }\\n        }\\n\\n        // Tally results\\n        for (string &x : words)\\n        {\\n            tmp = root;\\n            sum = depth = 0;\\n            for (char y : x)\\n            {\\n                y -= \\'a\\';\\n                tmp = tmp->data[y];\\n                if (tmp->vis == 1)\\n                {\\n                    sum += x.size() - depth;\\n                    break;\\n                }\\n                sum += tmp->vis;\\n                ++depth;\\n            }\\n            ret.push_back(sum);\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644589,
                "title": "c-easy-trie-solution",
                "content": "```\\nstruct Node {\\n    Node *child[26] = {};\\n    int score = 0;\\n};\\n\\nclass Solution {\\n    Node root;\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        for(string word : words)  add(word);\\n        int n = words.size();\\n        vector<int> result(n,0);\\n        for(int i = 0; i < n; i++)\\n            result[i] = calculate(words[i]);\\n        return result;\\n    }\\nprivate:\\n    void add(string s){\\n        Node* temp = &root;\\n        for(char c : s){\\n            if(!temp -> child[c - \\'a\\'])\\n                temp -> child[c - \\'a\\'] = new Node();\\n            temp -> child[c - \\'a\\'] -> score++;\\n            temp = temp -> child[c - \\'a\\'];\\n        }\\n    }\\n    \\n    int calculate(string s){\\n        int answer = 0;\\n        Node* temp = &root;\\n        for(char c : s){\\n            answer += temp -> child[c - \\'a\\'] -> score;\\n            temp = temp -> child[c - \\'a\\'];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node *child[26] = {};\\n    int score = 0;\\n};\\n\\nclass Solution {\\n    Node root;\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        for(string word : words)  add(word);\\n        int n = words.size();\\n        vector<int> result(n,0);\\n        for(int i = 0; i < n; i++)\\n            result[i] = calculate(words[i]);\\n        return result;\\n    }\\nprivate:\\n    void add(string s){\\n        Node* temp = &root;\\n        for(char c : s){\\n            if(!temp -> child[c - \\'a\\'])\\n                temp -> child[c - \\'a\\'] = new Node();\\n            temp -> child[c - \\'a\\'] -> score++;\\n            temp = temp -> child[c - \\'a\\'];\\n        }\\n    }\\n    \\n    int calculate(string s){\\n        int answer = 0;\\n        Node* temp = &root;\\n        for(char c : s){\\n            answer += temp -> child[c - \\'a\\'] -> score;\\n            temp = temp -> child[c - \\'a\\'];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634105,
                "title": "simple-easy-to-read-trie-solution-python3",
                "content": "```\\nclass TrieNode:\\n    \\n    def __init__(self, ch: str) -> None:\\n        self.ch = ch\\n        self.endOfWord = 0\\n        self.vstd = 0\\n        self.children = {}\\n\\n\\nclass Solution:\\n    # O(n*m) time, n --> len(words), m --> len(words[i]) \\n    # O(n*m) space,\\n    # Approach: trie, hashtable\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = TrieNode(\\'\\')\\n        ans = []        \\n        \\n        def addWord(word: str) -> None:\\n            curr = trie\\n            for c in word:\\n                if c not in curr.children:\\n                    nod = TrieNode(c)\\n                    curr.children[c] = nod\\n                curr = curr.children[c]\\n                curr.vstd +=1\\n                \\n            curr.endOfWord +=1 \\n            \\n        \\n        def calcScore(word: str) -> int:\\n            score = 0\\n            curr = trie\\n            \\n            for c in word:\\n                curr = curr.children[c]\\n                score += curr.vstd\\n            return score\\n        \\n        \\n        for word in words:\\n            addWord(word)\\n            \\n        for word in words:\\n            score = calcScore(word)\\n            ans.append(score)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    \\n    def __init__(self, ch: str) -> None:\\n        self.ch = ch\\n        self.endOfWord = 0\\n        self.vstd = 0\\n        self.children = {}\\n\\n\\nclass Solution:\\n    # O(n*m) time, n --> len(words), m --> len(words[i]) \\n    # O(n*m) space,\\n    # Approach: trie, hashtable\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = TrieNode(\\'\\')\\n        ans = []        \\n        \\n        def addWord(word: str) -> None:\\n            curr = trie\\n            for c in word:\\n                if c not in curr.children:\\n                    nod = TrieNode(c)\\n                    curr.children[c] = nod\\n                curr = curr.children[c]\\n                curr.vstd +=1\\n                \\n            curr.endOfWord +=1 \\n            \\n        \\n        def calcScore(word: str) -> int:\\n            score = 0\\n            curr = trie\\n            \\n            for c in word:\\n                curr = curr.children[c]\\n                score += curr.vstd\\n            return score\\n        \\n        \\n        for word in words:\\n            addWord(word)\\n            \\n        for word in words:\\n            score = calcScore(word)\\n            ans.append(score)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618593,
                "title": "a-few-solutions",
                "content": "**Trie Solutions:**\\n\\n* 1<sup>st</sup> pass increments the count `cnt` of each character\\'s trie node\\n* 2<sup>nd</sup> pass accumulates the count `cnt` to formulate the answer `ans`\\n\\n*Kotlin*\\n```\\nclass Node {\\n    public var cnt = 0\\n    public var kids = mutableMapOf<Char, Node>()\\n}\\nclass Solution {\\n    fun sumPrefixScores(A: Array<String>): IntArray {\\n        var root = Node()\\n        for (s in A) {\\n            var node = root\\n            for (c in s) {\\n                if (!node.kids.contains(c))\\n                    node.kids[c] = Node()\\n                node = node.kids[c]!!; ++node.cnt\\n            }\\n        }\\n        var ans = mutableListOf<Int>()\\n        for (s in A) {\\n            var cnt = 0\\n            var node = root\\n            for (c in s) {\\n                node = node.kids[c]!!\\n                cnt += node.cnt\\n            }\\n            ans.add(cnt)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Node {\\n    constructor() {\\n        this.cnt = 0;\\n        this.kids = new Map();\\n    }\\n}\\nlet sumPrefixScores = (A, root = new Node(), ans = []) => {\\n    for (let s of A) {\\n        let node = root;\\n        for (let c of s.split(\\'\\')) {\\n            if (!node.kids.has(c))\\n                node.kids.set(c, new Node());\\n            node = node.kids.get(c), ++node.cnt;\\n        }\\n    }\\n    for (let s of A) {\\n        let cnt = 0;\\n        let node = root;\\n        for (let c of s.split(\\'\\')) {\\n            node = node.kids.get(c);\\n            cnt += node.cnt;\\n        }\\n        ans.push(cnt);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Node:\\n    def __init__(self):\\n        self.cnt = 0\\n        self.kids = {}\\nclass Solution:\\n    def sumPrefixScores(self, A: List[str]) -> List[int]:\\n        root = Node()\\n        for s in A:\\n            node = root\\n            for c in s:\\n                if c not in node.kids:\\n                    node.kids[c] = Node()\\n                node = node.kids[c]\\n                node.cnt += 1\\n        ans = []\\n        for s in A:\\n            cnt = 0\\n            node = root\\n            for c in s:\\n                node = node.kids[c]\\n                cnt += node.cnt\\n            ans.append(cnt)\\n        return ans\\n```\\n\\n*C++*\\n```\\nstruct Node {\\n    int cnt;\\n    using Map = unordered_map<char, shared_ptr<Node>>;\\n    Map kids;\\n};\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    VI sumPrefixScores(VS& A, VI ans = {}) {\\n        auto root = make_shared<Node>();\\n        for (auto& s: A) {\\n            auto node = root;\\n            for (auto c: s) {\\n                if (node->kids.find(c) == node->kids.end())\\n                    node->kids[c] = make_shared<Node>();\\n                node = node->kids[c], ++node->cnt;\\n            }\\n        }\\n        for (auto& s: A) {\\n            auto cnt = 0;\\n            auto node = root;\\n            for (auto c: s) {\\n                node = node->kids[c];\\n                cnt += node->cnt;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n**Map Solutions:**\\n\\nUse a map `m` to store the count of each prefix string of each string `s` of the input array `A`.\\n\\n* Note: only the Python3 solution is AC, the other solutions result in TLE\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun sumPrefixScores(A: Array<String>): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var m = mutableMapOf<String, Int>()\\n        for (s in A)\\n            for (k in 1..s.length)\\n                m[s.substring(0, k)] = 1 + (m[s.substring(0, k)] ?: 0)\\n        for (s in A) {\\n            var cnt = 0\\n            for (k in 1..s.length)\\n                cnt += m[s.substring(0, k)]!!\\n            ans.add(cnt)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet sumPrefixScores = (A, m = new Map(), ans = []) => {\\n    for (let s of A)\\n        for (let k = 1; k <= s.length; ++k)\\n            m.set(s.substr(0, k), 1 + (m.get(s.substr(0, k)) || 0));\\n    for (let s of A) {\\n        let cnt = 0;\\n        for (let k = 1; k <= s.length; ++k)\\n            cnt += m.get(s.substr(0, k));\\n        ans.push(cnt);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def sumPrefixScores(self, A: List[str]) -> List[int]:\\n        m = Counter()\\n        for s in A:\\n            for k in range(1, len(s) + 1):\\n                m[s[:k]] += 1\\n        ans = []\\n        for s in A:\\n            cnt = 0\\n            for k in range(1, len(s) + 1):\\n                cnt += m[s[:k]]\\n            ans.append(cnt)\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<string, int>;\\n    VI sumPrefixScores(VS& A, Map m = {}, VI ans = {}) {\\n        for (auto& s: A)\\n            for (auto k{ 1 }; k <= s.size(); ++k)\\n                ++m[s.substr(0, k)];\\n        for (auto& s: A) {\\n            auto cnt = 0;\\n            for (auto k{ 1 }; k <= s.size(); ++k)\\n                cnt += m[s.substr(0, k)];\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    public var cnt = 0\\n    public var kids = mutableMapOf<Char, Node>()\\n}\\nclass Solution {\\n    fun sumPrefixScores(A: Array<String>): IntArray {\\n        var root = Node()\\n        for (s in A) {\\n            var node = root\\n            for (c in s) {\\n                if (!node.kids.contains(c))\\n                    node.kids[c] = Node()\\n                node = node.kids[c]!!; ++node.cnt\\n            }\\n        }\\n        var ans = mutableListOf<Int>()\\n        for (s in A) {\\n            var cnt = 0\\n            var node = root\\n            for (c in s) {\\n                node = node.kids[c]!!\\n                cnt += node.cnt\\n            }\\n            ans.add(cnt)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nclass Node {\\n    constructor() {\\n        this.cnt = 0;\\n        this.kids = new Map();\\n    }\\n}\\nlet sumPrefixScores = (A, root = new Node(), ans = []) => {\\n    for (let s of A) {\\n        let node = root;\\n        for (let c of s.split(\\'\\')) {\\n            if (!node.kids.has(c))\\n                node.kids.set(c, new Node());\\n            node = node.kids.get(c), ++node.cnt;\\n        }\\n    }\\n    for (let s of A) {\\n        let cnt = 0;\\n        let node = root;\\n        for (let c of s.split(\\'\\')) {\\n            node = node.kids.get(c);\\n            cnt += node.cnt;\\n        }\\n        ans.push(cnt);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Node:\\n    def __init__(self):\\n        self.cnt = 0\\n        self.kids = {}\\nclass Solution:\\n    def sumPrefixScores(self, A: List[str]) -> List[int]:\\n        root = Node()\\n        for s in A:\\n            node = root\\n            for c in s:\\n                if c not in node.kids:\\n                    node.kids[c] = Node()\\n                node = node.kids[c]\\n                node.cnt += 1\\n        ans = []\\n        for s in A:\\n            cnt = 0\\n            node = root\\n            for c in s:\\n                node = node.kids[c]\\n                cnt += node.cnt\\n            ans.append(cnt)\\n        return ans\\n```\n```\\nstruct Node {\\n    int cnt;\\n    using Map = unordered_map<char, shared_ptr<Node>>;\\n    Map kids;\\n};\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    VI sumPrefixScores(VS& A, VI ans = {}) {\\n        auto root = make_shared<Node>();\\n        for (auto& s: A) {\\n            auto node = root;\\n            for (auto c: s) {\\n                if (node->kids.find(c) == node->kids.end())\\n                    node->kids[c] = make_shared<Node>();\\n                node = node->kids[c], ++node->cnt;\\n            }\\n        }\\n        for (auto& s: A) {\\n            auto cnt = 0;\\n            auto node = root;\\n            for (auto c: s) {\\n                node = node->kids[c];\\n                cnt += node->cnt;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun sumPrefixScores(A: Array<String>): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var m = mutableMapOf<String, Int>()\\n        for (s in A)\\n            for (k in 1..s.length)\\n                m[s.substring(0, k)] = 1 + (m[s.substring(0, k)] ?: 0)\\n        for (s in A) {\\n            var cnt = 0\\n            for (k in 1..s.length)\\n                cnt += m[s.substring(0, k)]!!\\n            ans.add(cnt)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet sumPrefixScores = (A, m = new Map(), ans = []) => {\\n    for (let s of A)\\n        for (let k = 1; k <= s.length; ++k)\\n            m.set(s.substr(0, k), 1 + (m.get(s.substr(0, k)) || 0));\\n    for (let s of A) {\\n        let cnt = 0;\\n        for (let k = 1; k <= s.length; ++k)\\n            cnt += m.get(s.substr(0, k));\\n        ans.push(cnt);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def sumPrefixScores(self, A: List[str]) -> List[int]:\\n        m = Counter()\\n        for s in A:\\n            for k in range(1, len(s) + 1):\\n                m[s[:k]] += 1\\n        ans = []\\n        for s in A:\\n            cnt = 0\\n            for k in range(1, len(s) + 1):\\n                cnt += m[s[:k]]\\n            ans.append(cnt)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<string, int>;\\n    VI sumPrefixScores(VS& A, Map m = {}, VI ans = {}) {\\n        for (auto& s: A)\\n            for (auto k{ 1 }; k <= s.size(); ++k)\\n                ++m[s.substr(0, k)];\\n        for (auto& s: A) {\\n            auto cnt = 0;\\n            for (auto k{ 1 }; k <= s.size(); ++k)\\n                cnt += m[s.substr(0, k)];\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618543,
                "title": "c-clean-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    string word;\\n    class TrieNode{\\n        public:\\n        int count = 1;\\n        TrieNode* children[26] = {};\\n    };\\n    void cnt(TrieNode* root,int idx,int& ans){\\n        if(idx == word.length())return ;\\n        int i = word[idx] - \\'a\\';\\n        ans += root->children[i]->count;\\n        cnt(root->children[i],idx+1,ans);\\n    }\\n    void insert(TrieNode* root,int idx){\\n        if(idx == word.length())return;\\n        int i = word[idx] - \\'a\\';\\n        if(root->children[i] == NULL){\\n            root->children[i] = new TrieNode();\\n        }\\n        else{\\n            root->children[i]->count++;\\n        }\\n        insert(root->children[i],idx+1);\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        for(auto i:words){\\n            word = i;\\n            insert(root,0);\\n            \\n        }\\n        int n = words.size();\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++){\\n            int t = 0;\\n            word = words[i];\\n            cnt(root,0,t);\\n            ans[i] = t;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    string word;\\n    class TrieNode{\\n        public:\\n        int count = 1;\\n        TrieNode* children[26] = {}",
                "codeTag": "Java"
            },
            {
                "id": 2616070,
                "title": "java-trie-detailed-explanation-and-comments",
                "content": "Here I will explain the super detailed thought process to solve this problem. For a concise explanation, only read section **Problem Approach** and **Final Approach Implementation**.\\n\\n**Problem Approach:**\\nFor each String **S** in words, for all **S\\'s prefixes Sj** (**j denoting the length of Sj**), we essentially want to **sum up** the **number of strings in words that start with Sj**.\\n\\n**First Thought:**\\n\\n***Brute force***\\nRecord Sjn for any String S in words. Say words = [\"abc\", \"ab\", \"b\", \"bc\", \"ccc\"], we record Sjn for \"a\" (2), \"ab\" (2), \"abc\" (1), \"b\" (2), \"bc\" (1), \"c\" (1), \"cc\" (1), \"ccc\" (1). \\n\\n***Implementation***\\nFor each S, we increment each Sjn by 1. Then for each S, the answer is the sum of Sjn.\\n\\n***Issue: O(n ^ 3) TLE***\\n**Say there are 1000 strings, each with 1000 characters, and the first 3 characters of each S are distinct** (say if one String starts with \"abc\", others cannot. It\\'s possible since there are 26^3 > 1000 combinations of the first 3 characters), note that any prefix Sj for any S s.t. j >= 3 are distinct (for 2 prefixes P1 and P2 that belong to the same S, they are different, otherwise, they differ by the first 3 characters, thus P1 and P2 must also be different), resulting in the number of characters for all distinct Sj to be the magnitude of **1000 (distinct S) * ((3 + 1000) * 998 / 2) (number of characters in all Sj for S) = O(n ^ 3)** where n = 1000, resulting in TLE (usually the most you can get to pass is 10^7).\\n\\n***Solution***\\nWe notice there are many overlaps between prefixes of the same S, say S999 and S1000, the first 999 characters are the same. So instead of making each Sj separate strings, we might be able to compact the representing of Sj into something that has O(n) space / time complexity. We use Trie to achieve this.\\n\\nIf you don\\'t know Trie, here\\'s a 5-min tutorial.\\nhttps://www.youtube.com/watch?v=zIjfhVPRZCg\\n\\n**Final Approach:**\\nUse Trie, each S is a path in the Trie from the root of Trie. Think of the path for S as a linked-list of Trie nodes with head = root, where the i-th node in the list stores Sin. Say S = \"abc\" = \\'a\\'->\\'b\\'->\\'c\\' in list form, with node \\'a\\' storing S1n (number of strings that start with \"a\"), \\'b\\' storing S2n (number of strings that start with \"ab\", essentially serving the same function as creating a String \"ab\" and setting its score). Essentially each node we create (O(1)), we save time / space by refraining from recreating all characters leading up to this node / storing them separately.\\n\\nFor a complete view of the Trie, say words = [\"ab\", \"ad\"], then the node representing \"a\" would have two children representing \"ab\" and \"ad\" respectively (corresponding to \\'b\\' and \\'d\\', and at index \\'b\\' - \\'a\\' and \\'d\\' - \\'a\\' of the node\\'s children array, respectively). \"a\".sz = 2, \"ab\".sz = 1, \"ad\".sz = 1.\\n\\n**Final Approach Implementation**\\nEach node N represents the prefix Sj resulted from concatenating all characters from root to N. N.sz = Sjn.\\n***Step 1***: Compute all Sjn: For all S, for each prefix Sj, go 1 level deeper into Trie to find the node that represents Sj and increment Sj.sz by 1.\\n***Step 2*** : Summing Sjn to get answer : Compute the sum of Sj for each S by dfs on Trie (answer for S = sum of sz for all nodes in the path from root to the end of S, say S = \"abc\", then answer for S = S1n + S2n + S3n = \"a\".sz + \"ab\".sz + \"abc\".sz, which can be done by dfs in O(n^2) (number of characters in words)). \\n\\n**Final Complexity:**\\nO(# of characters in words) (step 1) + O(# of characters in words) (step 2) = O(n ^ 2) (n = 1000)\\n\\n**Conclusion:**\\nWhen to use Trie? When you want to save repeated computation / string construction for prefixes or suffixes of S. It\\'s essentially a compact representation of all prefixes for all S in words. To have a compact representation of all suffixes, simply add each S from back to front to the Trie.\\n```\\nclass Solution {\\n    public class Trie{\\n        //number of words that have prefix = the path represented by this Trie node\\n        int sz;\\n        //children array, ch[i] not null if there is a string with char(i + \\'a\\') as the next character\\n        Trie[] ch;\\n        //str is not null if the path represented by this Trie is a String in words, utilized by HashMap below\\n        String str;\\n        public Trie(){\\n            sz = 0;\\n            ch = new Trie[26];\\n            str = null;\\n        }\\n    }\\n    \\n    //computes the answers to the problem by summing sz along the path representing each String in words\\n    public void dfs(Trie node, int sum){\\n        //sum represents the sum of all sz in the path from root to node\\n        sum += node.sz;\\n        \\n        //put the answer to the string represented by node to map to save repeated computation\\n        if(node.str != null){\\n            map.put(node.str, sum);\\n        }\\n        \\n        //dfs all non-null children\\n        for(Trie child : node.ch){\\n            if(child != null){\\n                dfs(child, sum);\\n            }\\n        }\\n    }\\n    HashMap<String, Integer> map;\\n    public int[] sumPrefixScores(String[] words) {\\n        map = new HashMap<>();\\n        //root, stores no character, root[i] is not null if some string in words starts with char(i + \\'a\\'), easier to do dfs with this design (can just start at root instead of 26 potential Tries).\\n        Trie root = new Trie();\\n        \\n        //step 1: add each String to Trie iteratively\\n        for(String S : words){\\n            char[] s = S.toCharArray();\\n            Trie cur = root;\\n            for(char b : s){\\n                int ind = b - \\'a\\';\\n                \\n                //make new Trie if no previous string has b as the next character\\n                if(cur.ch[ind] == null){\\n                    cur.ch[ind] = new Trie();\\n                }\\n                cur = cur.ch[ind];\\n                ++cur.sz;\\n            }\\n            cur.str = S;\\n        }\\n        \\n\\t\\t//step 2\\n        dfs(root, 0);\\n        int[] res = new int[words.length];\\n        for(int i = 0; i < words.length; ++i){\\n            res[i] = map.get(words[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public class Trie{\\n        //number of words that have prefix = the path represented by this Trie node\\n        int sz;\\n        //children array, ch[i] not null if there is a string with char(i + \\'a\\') as the next character\\n        Trie[] ch;\\n        //str is not null if the path represented by this Trie is a String in words, utilized by HashMap below\\n        String str;\\n        public Trie(){\\n            sz = 0;\\n            ch = new Trie[26];\\n            str = null;\\n        }\\n    }\\n    \\n    //computes the answers to the problem by summing sz along the path representing each String in words\\n    public void dfs(Trie node, int sum){\\n        //sum represents the sum of all sz in the path from root to node\\n        sum += node.sz;\\n        \\n        //put the answer to the string represented by node to map to save repeated computation\\n        if(node.str != null){\\n            map.put(node.str, sum);\\n        }\\n        \\n        //dfs all non-null children\\n        for(Trie child : node.ch){\\n            if(child != null){\\n                dfs(child, sum);\\n            }\\n        }\\n    }\\n    HashMap<String, Integer> map;\\n    public int[] sumPrefixScores(String[] words) {\\n        map = new HashMap<>();\\n        //root, stores no character, root[i] is not null if some string in words starts with char(i + \\'a\\'), easier to do dfs with this design (can just start at root instead of 26 potential Tries).\\n        Trie root = new Trie();\\n        \\n        //step 1: add each String to Trie iteratively\\n        for(String S : words){\\n            char[] s = S.toCharArray();\\n            Trie cur = root;\\n            for(char b : s){\\n                int ind = b - \\'a\\';\\n                \\n                //make new Trie if no previous string has b as the next character\\n                if(cur.ch[ind] == null){\\n                    cur.ch[ind] = new Trie();\\n                }\\n                cur = cur.ch[ind];\\n                ++cur.sz;\\n            }\\n            cur.str = S;\\n        }\\n        \\n\\t\\t//step 2\\n        dfs(root, 0);\\n        int[] res = new int[words.length];\\n        for(int i = 0; i < words.length; ++i){\\n            res[i] = map.get(words[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604119,
                "title": "easy-trie-solution-c",
                "content": "```\\n\\nclass Node{\\n    public:\\n    unordered_map<char,Node*> mp;\\n    int count=0;\\n};\\n\\nvoid fill(Node* root,string &s,int ind){\\n    if(ind==s.size())return;\\n    if(root->mp.find(s[ind])==root->mp.end()){\\n        Node* newnode=new Node();\\n        root->mp[s[ind]]=newnode;\\n        root=root->mp[s[ind]];\\n    }else root=root->mp[s[ind]];\\n    root->count++;\\n    fill(root,s,ind+1);\\n}\\n\\nvoid get(Node* root,string &s,int ind,int &ans){\\n    ans+=root->count;\\n    if(ind==s.size())return;\\n    get(root->mp[s[ind]],s,ind+1,ans);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Node* root= new Node;\\n        for(int i=0;i<words.size();i++){\\n            fill(root,words[i],0);\\n        }\\n        vector<int> ans(words.size());\\n        for(int i=0;i<words.size();i++){\\n            get(root,words[i],0,ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Node{\\n    public:\\n    unordered_map<char,Node*> mp;\\n    int count=0;\\n};\\n\\nvoid fill(Node* root,string &s,int ind){\\n    if(ind==s.size())return;\\n    if(root->mp.find(s[ind])==root->mp.end()){\\n        Node* newnode=new Node();\\n        root->mp[s[ind]]=newnode;\\n        root=root->mp[s[ind]];\\n    }else root=root->mp[s[ind]];\\n    root->count++;\\n    fill(root,s,ind+1);\\n}\\n\\nvoid get(Node* root,string &s,int ind,int &ans){\\n    ans+=root->count;\\n    if(ind==s.size())return;\\n    get(root->mp[s[ind]],s,ind+1,ans);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Node* root= new Node;\\n        for(int i=0;i<words.size();i++){\\n            fill(root,words[i],0);\\n        }\\n        vector<int> ans(words.size());\\n        for(int i=0;i<words.size();i++){\\n            get(root,words[i],0,ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595198,
                "title": "c-with-2-hash-values",
                "content": "```\\n\\n\\nstruct hash_pair {\\n    template <class T1, class T2>\\n    size_t operator()(const pair<T1, T2>& p) const\\n    {\\n        auto hash1 = hash<T1>{}(p.first);\\n        auto hash2 = hash<T2>{}(p.second);\\n \\n        if (hash1 != hash2) {\\n            return hash1 ^ hash2;             \\n        }\\n         \\n        // If hash1 == hash2, their XOR is zero.\\n          return hash1;\\n    }\\n};\\n \\n\\nclass Solution {\\npublic:\\n    \\n\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        \\n       unordered_map<pair<long long, long long>, int, hash_pair> mp;\\n        vector<int> ans;\\n        \\n        \\n        for(string &s:words){\\n             int sz=s.size();\\n             string temp=\"\";\\n             \\n            const int p = 31;\\n            const int m1 = 1e9 + 9;\\n            const int m2=  1e9 + 7;\\n            long long hash_value1 = 0;\\n            long long hash_value2 = 0;\\n            long long p_pow1 = 1;  \\n            long long p_pow2 = 1;  \\n            \\n             for (char &c : s) {\\n             hash_value1 = (hash_value1 + (c - \\'a\\' + 1) * p_pow1) % m1;\\n             hash_value2 = (hash_value2 + (c - \\'a\\' + 1) * p_pow2) % m2;\\n             p_pow1 = (p_pow1 * p) % m1;\\n             p_pow2 = (p_pow2 * p) % m2;\\n                 \\n             mp[{hash_value1,hash_value2}]++;\\n           }\\n        }\\n        \\n\\n        \\n        for(string &s:words){\\n            \\n            \\n            int sz=s.size();\\n            int curr=0;\\n            const int p = 31;\\n            const int m1 = 1e9 + 9;\\n            const int m2=  1e9 + 7;\\n            long long hash_value1 = 0;\\n            long long hash_value2 = 0;\\n            long long p_pow1 = 1;  \\n            long long p_pow2 = 1;  \\n            \\n             for (char &c : s) {\\n             hash_value1 = (hash_value1 + (c - \\'a\\' + 1) * p_pow1) % m1;\\n             hash_value2 = (hash_value2 + (c - \\'a\\' + 1) * p_pow2) % m2;\\n             p_pow1 = (p_pow1 * p) % m1;\\n             p_pow2 = (p_pow2 * p) % m2;\\n                 \\n            curr += mp[{hash_value1,hash_value2}];\\n           }\\n            \\n            ans.push_back(curr);\\n\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nstruct hash_pair {\\n    template <class T1, class T2>\\n    size_t operator()(const pair<T1, T2>& p) const\\n    {\\n        auto hash1 = hash<T1>{}(p.first);\\n        auto hash2 = hash<T2>{}(p.second);\\n \\n        if (hash1 != hash2) {\\n            return hash1 ^ hash2;             \\n        }\\n         \\n        // If hash1 == hash2, their XOR is zero.\\n          return hash1;\\n    }\\n};\\n \\n\\nclass Solution {\\npublic:\\n    \\n\\n    \\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        \\n       unordered_map<pair<long long, long long>, int, hash_pair> mp;\\n        vector<int> ans;\\n        \\n        \\n        for(string &s:words){\\n             int sz=s.size();\\n             string temp=\"\";\\n             \\n            const int p = 31;\\n            const int m1 = 1e9 + 9;\\n            const int m2=  1e9 + 7;\\n            long long hash_value1 = 0;\\n            long long hash_value2 = 0;\\n            long long p_pow1 = 1;  \\n            long long p_pow2 = 1;  \\n            \\n             for (char &c : s) {\\n             hash_value1 = (hash_value1 + (c - \\'a\\' + 1) * p_pow1) % m1;\\n             hash_value2 = (hash_value2 + (c - \\'a\\' + 1) * p_pow2) % m2;\\n             p_pow1 = (p_pow1 * p) % m1;\\n             p_pow2 = (p_pow2 * p) % m2;\\n                 \\n             mp[{hash_value1,hash_value2}]++;\\n           }\\n        }\\n        \\n\\n        \\n        for(string &s:words){\\n            \\n            \\n            int sz=s.size();\\n            int curr=0;\\n            const int p = 31;\\n            const int m1 = 1e9 + 9;\\n            const int m2=  1e9 + 7;\\n            long long hash_value1 = 0;\\n            long long hash_value2 = 0;\\n            long long p_pow1 = 1;  \\n            long long p_pow2 = 1;  \\n            \\n             for (char &c : s) {\\n             hash_value1 = (hash_value1 + (c - \\'a\\' + 1) * p_pow1) % m1;\\n             hash_value2 = (hash_value2 + (c - \\'a\\' + 1) * p_pow2) % m2;\\n             p_pow1 = (p_pow1 * p) % m1;\\n             p_pow2 = (p_pow2 * p) % m2;\\n                 \\n            curr += mp[{hash_value1,hash_value2}];\\n           }\\n            \\n            ans.push_back(curr);\\n\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594412,
                "title": "python-trie-based-solution",
                "content": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:                        \\n        trie = dict()\\n        \\n        def insert(word):\\n            node = trie            \\n            for c in word:\\n                if c not in node: node[c] = dict()                    \\n                node = node[c]                \\n                if \\'count\\' not in node: node[\\'count\\'] = 0                \\n                node[\\'count\\'] += 1\\n                \\n        def collect(word):\\n            node = trie    \\n            result = 0\\n            for c in word:\\n                if c not in node: break\\n                node = node[c]                                \\n                result += node[\\'count\\']\\n                \\n            return result\\n        \\n        for w in words: insert(w) \\n            \\n        return [collect(w) for w in words]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:                        \\n        trie = dict()\\n        \\n        def insert(word):\\n            node = trie            \\n            for c in word:\\n                if c not in node: node[c] = dict()                    \\n                node = node[c]                \\n                if \\'count\\' not in node: node[\\'count\\'] = 0                \\n                node[\\'count\\'] += 1\\n                \\n        def collect(word):\\n            node = trie    \\n            result = 0\\n            for c in word:\\n                if c not in node: break\\n                node = node[c]                                \\n                result += node[\\'count\\']\\n                \\n            return result\\n        \\n        for w in words: insert(w) \\n            \\n        return [collect(w) for w in words]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593403,
                "title": "trie-c",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Trie{\\n        Trie*next[26];\\n        int freq;\\n        Trie(){\\n            freq=0;\\n            for(int i=0;i<26;i++){\\n                next[i]=NULL;\\n            }\\n        }\\n    };\\n    Trie *root;\\n    void insert(string s){\\n        int n = s.size();\\n        Trie*temp = root;\\n        for(int i=0;i<n;i++){\\n            if(temp->next[s[i]-\\'a\\']==NULL){\\n                temp->next[s[i]-\\'a\\'] = new Trie();\\n            }\\n            temp = temp->next[s[i]-\\'a\\'];\\n            temp->freq++;\\n        }\\n    }\\n    int getAns(string s){\\n        int ans = 0;\\n        int n = s.size();\\n        Trie*temp = root;\\n        for(int i=0;i<n;i++){\\n            temp = temp->next[s[i]-\\'a\\'];\\n            ans+=temp->freq;\\n        }\\n        return ans;\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        root = new Trie();\\n        for(auto it:words){\\n            insert(it);\\n        }\\n        vector<int>ans;\\n        for(auto it:words){\\n            ans.push_back(getAns(it));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Trie{\\n        Trie*next[26];\\n        int freq;\\n        Trie(){\\n            freq=0;\\n            for(int i=0;i<26;i++){\\n                next[i]=NULL;\\n            }\\n        }\\n    };\\n    Trie *root;\\n    void insert(string s){\\n        int n = s.size();\\n        Trie*temp = root;\\n        for(int i=0;i<n;i++){\\n            if(temp->next[s[i]-\\'a\\']==NULL){\\n                temp->next[s[i]-\\'a\\'] = new Trie();\\n            }\\n            temp = temp->next[s[i]-\\'a\\'];\\n            temp->freq++;\\n        }\\n    }\\n    int getAns(string s){\\n        int ans = 0;\\n        int n = s.size();\\n        Trie*temp = root;\\n        for(int i=0;i<n;i++){\\n            temp = temp->next[s[i]-\\'a\\'];\\n            ans+=temp->freq;\\n        }\\n        return ans;\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        root = new Trie();\\n        for(auto it:words){\\n            insert(it);\\n        }\\n        vector<int>ans;\\n        for(auto it:words){\\n            ans.push_back(getAns(it));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593119,
                "title": "c-trie-production-ready-quality-code",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n    Node *links[26];\\n    int prefix = 0;\\n    bool containsKey(char ch){\\n        return (links[ch-\\'a\\'] != NULL);\\n    }\\n    void put(char ch, Node* node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Node* root;\\n    Trie() {\\n        root = new Node();\\n    }\\n    \\n    void insert(string word) {\\n        int n = word.size();\\n        Node* node = root;\\n        for(int i=0;i<n;i++){\\n            if(!node->containsKey(word[i])){\\n                node->put(word[i],new Node());\\n            }\\n            \\n            node = node->get(word[i]);\\n            node->prefix++;\\n        }\\n        \\n    }\\n    int startsWith(string prefix) {\\n        int n = prefix.size();\\n        Node* node = root;\\n        int val = 0;\\n        for(int i=0;i<n;i++){\\n            if(!node->containsKey(prefix[i])){\\n                return 0;\\n            }\\n            \\n            node = node->get(prefix[i]);\\n            val += node->prefix;\\n            \\n        }\\n        return val;\\n    }\\n};\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie t;\\n        for(auto &x: words){\\n            t.insert(x);\\n        }\\n        vector<int>ans;\\n        for(auto &x: words){\\n            int cnt = t.startsWith(x);\\n            \\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node{\\n    Node *links[26];\\n    int prefix = 0;\\n    bool containsKey(char ch){\\n        return (links[ch-\\'a\\'] != NULL);\\n    }\\n    void put(char ch, Node* node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n};\\n\\nclass Trie {\\npublic:\\n    Node* root;\\n    Trie() {\\n        root = new Node();\\n    }\\n    \\n    void insert(string word) {\\n        int n = word.size();\\n        Node* node = root;\\n        for(int i=0;i<n;i++){\\n            if(!node->containsKey(word[i])){\\n                node->put(word[i],new Node());\\n            }\\n            \\n            node = node->get(word[i]);\\n            node->prefix++;\\n        }\\n        \\n    }\\n    int startsWith(string prefix) {\\n        int n = prefix.size();\\n        Node* node = root;\\n        int val = 0;\\n        for(int i=0;i<n;i++){\\n            if(!node->containsKey(prefix[i])){\\n                return 0;\\n            }\\n            \\n            node = node->get(prefix[i]);\\n            val += node->prefix;\\n            \\n        }\\n        return val;\\n    }\\n};\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie t;\\n        for(auto &x: words){\\n            t.insert(x);\\n        }\\n        vector<int>ans;\\n        for(auto &x: words){\\n            int cnt = t.startsWith(x);\\n            \\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592372,
                "title": "c-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    uint64_t MOD = 184467440737091;\\n    vector<int> sumPrefixScores(vector<string> &words)\\n    {\\n        unordered_map<uint64_t, int> mp;\\n        for (auto word : words)\\n        {\\n            uint64_t hash = 0;\\n            for (auto c : word)\\n            {\\n                hash = (131313 * hash + (c - 96)) % MOD;\\n                ++mp[hash];\\n            }\\n        }\\n        vector<int> answer;\\n        for (auto word : words)\\n        {\\n            uint64_t hash = 0;\\n            int ans = 0;\\n            for (auto c : word)\\n            {\\n                hash = (131313 * hash + (c - 96)) % MOD;\\n                ans += mp[hash];\\n            } \\n            answer.push_back(ans);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    uint64_t MOD = 184467440737091;\\n    vector<int> sumPrefixScores(vector<string> &words)\\n    {\\n        unordered_map<uint64_t, int> mp;\\n        for (auto word : words)\\n        {\\n            uint64_t hash = 0;\\n            for (auto c : word)\\n            {\\n                hash = (131313 * hash + (c - 96)) % MOD;\\n                ++mp[hash];\\n            }\\n        }\\n        vector<int> answer;\\n        for (auto word : words)\\n        {\\n            uint64_t hash = 0;\\n            int ans = 0;\\n            for (auto c : word)\\n            {\\n                hash = (131313 * hash + (c - 96)) % MOD;\\n                ans += mp[hash];\\n            } \\n            answer.push_back(ans);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592082,
                "title": "giving-tle-trie-c",
                "content": "Please help, why is this code giving TLE?\\n\\t\\n\\tclass Node {\\n\\tpublic:\\n\\t\\tchar data;\\n\\t\\tNode **children;\\n\\t\\tint count;\\n\\n\\t\\tNode(char data){\\n\\t\\t\\tthis->data = data;\\n\\t\\t\\tchildren = new Node*[26];\\n\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\tchildren[i]=NULL;\\n\\t\\t\\t}\\n\\t\\t\\tcount = 0;\\n\\t\\t}\\n\\t};\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tNode* root = new Node(\\'\\\\0\\');\\n\\n\\t\\tvoid inserthelper(Node *root, string s){\\n\\t\\t\\tif(s.size()==0){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint indx = s[0]-\\'a\\';\\n\\t\\t\\tif(root->children[indx]==NULL){\\n\\t\\t\\t\\tNode *child = new Node(s[0]);\\n\\t\\t\\t\\troot->children[indx] = child;\\n\\t\\t\\t\\tchild->count += 1;\\n\\t\\t\\t\\tinserthelper(child,s.substr(1));\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot->children[indx]->count += 1;\\n\\t\\t\\t\\tinserthelper(root->children[indx],s.substr(1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint searchhelper(Node *root, string word){\\n\\t\\t\\tif(word.size()==0){\\n\\t\\t\\t\\treturn root->count;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint idx = word[0]-\\'a\\';\\n\\t\\t\\tif(root->children[idx]==NULL){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\treturn root->count + searchhelper(root->children[idx],word.substr(1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> sumPrefixScores(vector<string>& words) {\\n\\t\\t\\tint n = words.size();\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tinserthelper(root,words[i]);\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> ans(n,0);\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tans[i] += searchhelper(root,words[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tNode* root = new Node(\\'\\\\0\\');\\n\\n\\t\\tvoid inserthelper(Node *root, string s){\\n\\t\\t\\tif(s.size()==0){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2591927,
                "title": "c-trie-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        Node *links[26];\\n        bool flag=false;\\n        int pre=0;\\n        bool contain(char ch)\\n        {\\n            return links[ch-\\'a\\']!=NULL;\\n        }\\n        void put(char ch,Node *node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node *get(char ch)\\n        {\\n           return links[ch-\\'a\\'];\\n        }\\n    };\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> ans;\\n        Node *root=new Node();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string x=words[i];\\n            Node *node=root;\\n            for(int j=0;j<x.size();j++)\\n            {\\n                if(!node->contain(x[j]))\\n                {\\n                    node->put(x[j],new Node());\\n                   \\n                }\\n                \\n                node=node->get(x[j]);\\n                 node->pre++;\\n            }\\n        }\\n        int c=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string x=words[i];\\n            c=0;\\n              Node *node=root;\\n            for(int j=0;j<x.size();j++)\\n            {\\n                node=node->get(x[j]);\\n                c+=node->pre;\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        Node *links[26];\\n        bool flag=false;\\n        int pre=0;\\n        bool contain(char ch)\\n        {\\n            return links[ch-\\'a\\']!=NULL;\\n        }\\n        void put(char ch,Node *node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        Node *get(char ch)\\n        {\\n           return links[ch-\\'a\\'];\\n        }\\n    };\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> ans;\\n        Node *root=new Node();\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string x=words[i];\\n            Node *node=root;\\n            for(int j=0;j<x.size();j++)\\n            {\\n                if(!node->contain(x[j]))\\n                {\\n                    node->put(x[j],new Node());\\n                   \\n                }\\n                \\n                node=node->get(x[j]);\\n                 node->pre++;\\n            }\\n        }\\n        int c=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string x=words[i];\\n            c=0;\\n              Node *node=root;\\n            for(int j=0;j<x.size();j++)\\n            {\\n                node=node->get(x[j]);\\n                c+=node->pre;\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591419,
                "title": "java-double-pass-trie-easy-to-understand-commented",
                "content": "**My Trie : https://leetcode.com/problems/implement-trie-prefix-tree/discuss/1916170/java-classical-Trie-(Time-Owords*letters-space-Olen_of_max_word*Const-)**\\n\\nRuntime: 230 ms, faster than 80.00% of Java online submissions for Sum of Prefix Scores of Strings.\\nMemory Usage: 216.5 MB, less than 40.00% of Java online submissions for Sum of Prefix Scores of Strings.\\n```\\nclass Trie {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public int prefixes;\\n    \\n    Node (){\\n      prefixes = 0;\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n    }\\n  }\\n  \\n  Node root;                                             //root of Trie\\n  \\n  public Trie() {         \\n    root = new Node();                                   //construct new Trie\\n  }\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) {\\n        n = n.p[id];                                     //if this letter is presented in table move to next\\n        n.prefixes++;\\n      }\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n          n.prefixes++;\\n        }\\n    }\\n  }\\n    \\n  public int collect(String w) {\\n    int sum = 0;\\n    Node n = root;                                       //node for traversal through Trie\\n      for(int i = 0; i < w.length(); i++){\\n        int id = (int)(w.charAt(i) - \\'a\\');               //fetch current letter from word and calculate index for it\\n        \\n        n = n.p[id];\\n        sum += n.prefixes;\\n      }\\n    \\n    return sum;                                        \\n  }\\n}\\n\\nclass Solution {\\n  public int[] sumPrefixScores(String[] words) {\\n    Trie trie = new Trie();\\n    for(String w : words) trie.insert(w);                                     //construct Trie\\n    int ans[] = new int[words.length], i = 0;\\n    for(String w : words) ans[i++] = trie.collect(w);                         //collect sum of prefixes\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Trie {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public int prefixes;\\n    \\n    Node (){\\n      prefixes = 0;\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n    }\\n  }\\n  \\n  Node root;                                             //root of Trie\\n  \\n  public Trie() {         \\n    root = new Node();                                   //construct new Trie\\n  }\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) {\\n        n = n.p[id];                                     //if this letter is presented in table move to next\\n        n.prefixes++;\\n      }\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n          n.prefixes++;\\n        }\\n    }\\n  }\\n    \\n  public int collect(String w) {\\n    int sum = 0;\\n    Node n = root;                                       //node for traversal through Trie\\n      for(int i = 0; i < w.length(); i++){\\n        int id = (int)(w.charAt(i) - \\'a\\');               //fetch current letter from word and calculate index for it\\n        \\n        n = n.p[id];\\n        sum += n.prefixes;\\n      }\\n    \\n    return sum;                                        \\n  }\\n}\\n\\nclass Solution {\\n  public int[] sumPrefixScores(String[] words) {\\n    Trie trie = new Trie();\\n    for(String w : words) trie.insert(w);                                     //construct Trie\\n    int ans[] = new int[words.length], i = 0;\\n    for(String w : words) ans[i++] = trie.collect(w);                         //collect sum of prefixes\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591286,
                "title": "prefix-hash-with-explanation-working-wrong-solution-no-advanced-ds-needed",
                "content": "Quite intuitive. \\nOption 1 : Calculate all prefix strings for all given strings. This will lead to TLE. Time complexity is O(n x m x m) where n is given number of strings and m being the max individual string length. Since we are adding it in hash map so the string will take a linear time to be put in hashmap, causing extra \\'m\\' in our time complexity. \\n\\nWay to avoid is to not use string.\\nYep you guessed right, we can use numbers which can be inserted in non-linear time.\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>M;\\n    vector<int> sumPrefixScores(vector<string>&A) \\n    {\\n        vector<int>ans;\\n        for(auto i:A)\\n        {\\n            string temp=\"\";\\n            for(auto j:i)\\n                temp.push_back(j),\\n                M[temp]++;\\n        }\\n        for(auto i:A)\\n        {\\n            int temp=0;\\n            string s=\"\";\\n            for(auto j:i)\\n                s.push_back(j),\\n                temp+=M[s];\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nOption 2 : Use numeric values to calculate hash for each prefix. O(n x m) time complexity as O(n x m) without high constant factor as seen in the above option 1 approach. This approach is wrong but it will pass leetcode testcases but it is possible to generate some testcases where this will fail.\\n```\\nclass Solution {\\npublic:\\n    const long long int mod=8128812800000059;\\n    unordered_map<unsigned long long int,int>M;\\n    vector<int> sumPrefixScores(vector<string>&A) \\n    {\\n        vector<int>ans;\\n        for(auto i:A)\\n        {\\n            unsigned long long int hash=0,factor=37LL;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                hash=(hash+(i[j]-\\'a\\'+31)*factor)%mod;\\n                factor=(factor*37LL)%mod;\\n                M[hash]++;\\n            }\\n        }\\n        for(auto i:A)\\n        {\\n            unsigned long long int hash=0,factor=37LL,counter=0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                hash=(hash+(i[j]-\\'a\\'+31)*factor)%mod;\\n                factor=(factor*37LL)%mod;\\n                counter+=M[hash];\\n            }\\n            ans.push_back((int)counter);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nAs @yumkam pointed out in comments that there will be testcases which will cause the above code to fail. For instance ```[\"aaafcabaaaadaa\", \"cagaaaahebeabf\"]``` will fail. Even if we try to come up with some other modulo number then also there\\'s some testcase where it\\'s gonna fail eventually.\\nSo the point is if you\\'re not able to code any logic then doing trial and error might pass testcases if they haven\\'t added those hash colliding testcases.",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int>M;\\n    vector<int> sumPrefixScores(vector<string>&A) \\n    {\\n        vector<int>ans;\\n        for(auto i:A)\\n        {\\n            string temp=\"\";\\n            for(auto j:i)\\n                temp.push_back(j),\\n                M[temp]++;\\n        }\\n        for(auto i:A)\\n        {\\n            int temp=0;\\n            string s=\"\";\\n            for(auto j:i)\\n                s.push_back(j),\\n                temp+=M[s];\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    const long long int mod=8128812800000059;\\n    unordered_map<unsigned long long int,int>M;\\n    vector<int> sumPrefixScores(vector<string>&A) \\n    {\\n        vector<int>ans;\\n        for(auto i:A)\\n        {\\n            unsigned long long int hash=0,factor=37LL;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                hash=(hash+(i[j]-\\'a\\'+31)*factor)%mod;\\n                factor=(factor*37LL)%mod;\\n                M[hash]++;\\n            }\\n        }\\n        for(auto i:A)\\n        {\\n            unsigned long long int hash=0,factor=37LL,counter=0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                hash=(hash+(i[j]-\\'a\\'+31)*factor)%mod;\\n                factor=(factor*37LL)%mod;\\n                counter+=M[hash];\\n            }\\n            ans.push_back((int)counter);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```[\"aaafcabaaaadaa\", \"cagaaaahebeabf\"]```",
                "codeTag": "Java"
            },
            {
                "id": 2590857,
                "title": "hashmap-solution-easy-understanding-o-n-n",
                "content": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        hashmap=dict()\\n        for i in words:\\n            temp=\"\"\\n            for j in range(len(i)):\\n                temp+=i[j]\\n                if temp in hashmap:\\n                    hashmap[temp]+=1\\n                else:\\n                    hashmap[temp]=1\\n        result=[]\\n\\n        for i in words:\\n            count=0\\n            temp=\"\"\\n            for j in range(len(i)):\\n                temp+=i[j]\\n                count+=hashmap[temp]\\n            result.append(count)\\n        return(result)\\n        \\n```\\n\\n\\nFirst time it throws TLE.But when i resubmitted it,It got passed.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        hashmap=dict()\\n        for i in words:\\n            temp=\"\"\\n            for j in range(len(i)):\\n                temp+=i[j]\\n                if temp in hashmap:\\n                    hashmap[temp]+=1\\n                else:\\n                    hashmap[temp]=1\\n        result=[]\\n\\n        for i in words:\\n            count=0\\n            temp=\"\"\\n            for j in range(len(i)):\\n                temp+=i[j]\\n                count+=hashmap[temp]\\n            result.append(count)\\n        return(result)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590707,
                "title": "trie-count-of-strings-at-each-trie-node",
                "content": "Whenever we add a word to TRIE , just keep on increasing cnt variable at each node. Then Simply get the value of cnt at each prefix end and sum to get our answer.\\nTime Complexity - O(N*Length )\\n```\\nclass TrieNode{\\npublic:\\n    char data;\\n    TrieNode *children[26];\\n    int cnt;\\n\\n    TrieNode(char ch)\\n    {\\n        data = ch;\\n        cnt=0;\\n        for(int i=0 ; i<26 ; i++)\\n            children[i]=NULL;\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n    TrieNode *root;\\n    Solution()\\n    {\\n        root = new TrieNode(\\'/\\');\\n    }\\n\\n    void insert(TrieNode *root , string str)\\n    {\\n        TrieNode *temp = root;\\n        for(char ch:str)\\n        {\\n            if(temp->children[ch-\\'a\\'] == NULL)\\n            {\\n                temp->children[ch-\\'a\\'] = new TrieNode(ch);\\n            }\\n            temp = temp->children[ch-\\'a\\'];\\n            temp->cnt++;\\n        }\\n    }\\n\\n    void search(TrieNode *root , string word , int &sum)\\n    {\\n        TrieNode *temp = root;\\n        for(char ch:word)\\n        {\\n            temp = temp->children[ch-\\'a\\'];\\n            sum+=temp->cnt;\\n            \\n        }\\n    }\\n\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n\\n        for(auto str:words)\\n        {\\n            insert(root,str);\\n        }\\n\\n        // after insertion \\n\\n        vector<int>res;\\n\\n        for(auto word:words)\\n        {\\n            int sum = 0;\\n            search(root,word,sum);\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    char data;\\n    TrieNode *children[26];\\n    int cnt;\\n\\n    TrieNode(char ch)\\n    {\\n        data = ch;\\n        cnt=0;\\n        for(int i=0 ; i<26 ; i++)\\n            children[i]=NULL;\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n    TrieNode *root;\\n    Solution()\\n    {\\n        root = new TrieNode(\\'/\\');\\n    }\\n\\n    void insert(TrieNode *root , string str)\\n    {\\n        TrieNode *temp = root;\\n        for(char ch:str)\\n        {\\n            if(temp->children[ch-\\'a\\'] == NULL)\\n            {\\n                temp->children[ch-\\'a\\'] = new TrieNode(ch);\\n            }\\n            temp = temp->children[ch-\\'a\\'];\\n            temp->cnt++;\\n        }\\n    }\\n\\n    void search(TrieNode *root , string word , int &sum)\\n    {\\n        TrieNode *temp = root;\\n        for(char ch:word)\\n        {\\n            temp = temp->children[ch-\\'a\\'];\\n            sum+=temp->cnt;\\n            \\n        }\\n    }\\n\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n\\n        for(auto str:words)\\n        {\\n            insert(root,str);\\n        }\\n\\n        // after insertion \\n\\n        vector<int>res;\\n\\n        for(auto word:words)\\n        {\\n            int sum = 0;\\n            search(root,word,sum);\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590687,
                "title": "python-simple-python-solution-using-dictionary",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 8638 ms, faster than 9.09% of Python3 online submissions for Sum of Prefix Scores of Strings.\\n# Memory Usage: 243.6 MB, less than 9.09% of Python3 online submissions for Sum of Prefix Scores of Strings.\\n\\n\\tclass Solution:\\n\\t\\tdef sumPrefixScores(self, words: List[str]) -> List[int]:\\n\\n\\t\\t\\td = defaultdict(int)\\n\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tfor index in range(1, len(word) + 1):\\n\\t\\t\\t\\t\\td[word[:index]] += 1 \\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\t\\tfor index in range(1, len(word) + 1):\\n\\t\\t\\t\\t\\tcurrent_sum = current_sum + d[word[:index]]\\n\\n\\t\\t\\t\\tresult.append(current_sum)\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 8638 ms, faster than 9.09% of Python3 online submissions for Sum of Prefix Scores of Strings.\\n# Memory Usage: 243.6 MB, less than 9.09% of Python3 online submissions for Sum of Prefix Scores of Strings.\\n\\n\\tclass Solution:\\n\\t\\tdef sumPrefixScores(self, words: List[str]) -> List[int]:\\n\\n\\t\\t\\td = defaultdict(int)\\n\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tfor index in range(1, len(word) + 1):\\n\\t\\t\\t\\t\\td[word[:index]] += 1 \\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\t\\tfor index in range(1, len(word) + 1):\\n\\t\\t\\t\\t\\tcurrent_sum = current_sum + d[word[:index]]\\n\\n\\t\\t\\t\\tresult.append(current_sum)\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2590626,
                "title": "java-roling-hash",
                "content": "```\\nclass Solution\\n{\\n    final int m = 1023;\\n    public int[] sumPrefixScores(String[] words)\\n    {\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        for(String S : words)\\n        {\\n            char[] s = S.toCharArray();\\n            long hash_so_far = 0L;\\n            int n = s.length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                hash_so_far = hash_so_far*m+s[i];\\n                map.put(hash_so_far,map.getOrDefault(hash_so_far,0)+1);\\n            }\\n        }\\n        int cur = 0;\\n        int[] ret = new int[words.length];\\n        for(String S : words)\\n        {\\n            char[] s = S.toCharArray();\\n            long hash_so_far = 0L;\\n            int n = s.length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                hash_so_far = hash_so_far*m+s[i];\\n                ret[cur] += map.get(hash_so_far);\\n            }\\n            cur++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution\\n{\\n    final int m = 1023;\\n    public int[] sumPrefixScores(String[] words)\\n    {\\n        HashMap<Long,Integer> map = new HashMap<>();\\n        for(String S : words)\\n        {\\n            char[] s = S.toCharArray();\\n            long hash_so_far = 0L;\\n            int n = s.length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                hash_so_far = hash_so_far*m+s[i];\\n                map.put(hash_so_far,map.getOrDefault(hash_so_far,0)+1);\\n            }\\n        }\\n        int cur = 0;\\n        int[] ret = new int[words.length];\\n        for(String S : words)\\n        {\\n            char[] s = S.toCharArray();\\n            long hash_so_far = 0L;\\n            int n = s.length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                hash_so_far = hash_so_far*m+s[i];\\n                ret[cur] += map.get(hash_so_far);\\n            }\\n            cur++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590615,
                "title": "python3-binary-search-without-trie",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        sorted_words = words.copy()\\n        sorted_words.sort()\\n        \\n        dp = defaultdict(lambda:-1)\\n        final_ans = []\\n        for word in words:\\n            n = len(word)\\n            temp_here_ans = 0\\n            for i in range(1, n+1):\\n                temp_start = word[0:i]\\n                if dp[temp_start] == -1:\\n                    ind_1 = bisect.bisect_left(sorted_words, temp_start)\\n                    temp_end = word[0:i-1] + chr(ord(word[i-1])+1)\\n                    ind_2 = bisect.bisect_left(sorted_words, temp_end)\\n                    temp_here_ans += ind_2 - ind_1\\n\\n                    dp[temp_start] = ind_2 - ind_1\\n                else:\\n                    temp_here_ans += dp[temp_start]\\n            final_ans.append(temp_here_ans)\\n        \\n        return final_ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        sorted_words = words.copy()\\n        sorted_words.sort()\\n        \\n        dp = defaultdict(lambda:-1)\\n        final_ans = []\\n        for word in words:\\n            n = len(word)\\n            temp_here_ans = 0\\n            for i in range(1, n+1):\\n                temp_start = word[0:i]\\n                if dp[temp_start] == -1:\\n                    ind_1 = bisect.bisect_left(sorted_words, temp_start)\\n                    temp_end = word[0:i-1] + chr(ord(word[i-1])+1)\\n                    ind_2 = bisect.bisect_left(sorted_words, temp_end)\\n                    temp_here_ans += ind_2 - ind_1\\n\\n                    dp[temp_start] = ind_2 - ind_1\\n                else:\\n                    temp_here_ans += dp[temp_start]\\n            final_ans.append(temp_here_ans)\\n        \\n        return final_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590603,
                "title": "simple-trie-c-brute-force",
                "content": "**TRIE PRACTICE PROBLEMS **\\n\\n[1. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)\\n[2. Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/)\\n[3. Search Suggestions System](https://leetcode.com/problems/search-suggestions-system/)\\n```\\n// trie node  \\nstruct node{\\n    int count;\\n    node* child[26];\\n    node(){\\n        for(int i=0;i<26;i++){\\n            child[i]=NULL;\\n        }\\n        count=0;\\n    }\\n};\\n\\nclass Solution{\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words){\\n        vector<int> ans;\\n        node* root=new node();\\n        \\n        //inserting words in trie \\n        for(auto s:words){\\n            int n=s.length();\\n            node* temp=root;\\n            for(int i=0;i<n;i++){\\n                if(temp->child[s[i]-\\'a\\']==NULL){\\n                    temp->child[s[i]-\\'a\\']=new node();\\n                }\\n                temp=temp->child[s[i]-\\'a\\'];\\n                \\n                //updating count of that prefix  \\n                temp->count++;\\n            }\\n        }\\n        \\n        //traversing to each words \\n        for(auto s:words){\\n            int n=s.length();\\n            int curr=0;\\n            node* temp=root;\\n            //suming up value of each prefix \\n            for(int i=0;i<n;i++){\\n                temp = temp->child[s[i]-\\'a\\'];\\n                curr += temp->count;\\n            }\\n            //updating ans to that word \\n            ans.push_back(curr);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n// trie node  \\nstruct node{\\n    int count;\\n    node* child[26];\\n    node(){\\n        for(int i=0;i<26;i++){\\n            child[i]=NULL;\\n        }\\n        count=0;\\n    }\\n};\\n\\nclass Solution{\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words){\\n        vector<int> ans;\\n        node* root=new node();\\n        \\n        //inserting words in trie \\n        for(auto s:words){\\n            int n=s.length();\\n            node* temp=root;\\n            for(int i=0;i<n;i++){\\n                if(temp->child[s[i]-\\'a\\']==NULL){\\n                    temp->child[s[i]-\\'a\\']=new node();\\n                }\\n                temp=temp->child[s[i]-\\'a\\'];\\n                \\n                //updating count of that prefix  \\n                temp->count++;\\n            }\\n        }\\n        \\n        //traversing to each words \\n        for(auto s:words){\\n            int n=s.length();\\n            int curr=0;\\n            node* temp=root;\\n            //suming up value of each prefix \\n            for(int i=0;i<n;i++){\\n                temp = temp->child[s[i]-\\'a\\'];\\n                curr += temp->count;\\n            }\\n            //updating ans to that word \\n            ans.push_back(curr);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590476,
                "title": "easy-python-solution-with-dictionary",
                "content": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        d = dict()\\n        for i in words:\\n            s=\"\"\\n            for j in range(len(i)):\\n                s+=i[j]\\n                if s in d:\\n                    d[s]+=1\\n                else:\\n                    d[s]=1\\n        l=[]\\n        for i in words:\\n            c = 0\\n            s=\"\"\\n            for j in range(len(i)):\\n                s+=i[j]\\n                c+=d[s]\\n            l.append(c)\\n        return l\\n```\\n***Please Upvote if you like this.***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        d = dict()\\n        for i in words:\\n            s=\"\"\\n            for j in range(len(i)):\\n                s+=i[j]\\n                if s in d:\\n                    d[s]+=1\\n                else:\\n                    d[s]=1\\n        l=[]\\n        for i in words:\\n            c = 0\\n            s=\"\"\\n            for j in range(len(i)):\\n                s+=i[j]\\n                c+=d[s]\\n            l.append(c)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590450,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        prefixscore= Counter()\\n        for word in words:\\n            for i in range(1, len(word)+1):\\n                prefixscore[word[:i]]+=1\\n        answer=[]\\n        for word in words:\\n            ans=0\\n            for i in range(1, len(word)+1):\\n                ans+= prefixscore[word[:i]]\\n            answer.append(ans)\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        prefixscore= Counter()\\n        for word in words:\\n            for i in range(1, len(word)+1):\\n                prefixscore[word[:i]]+=1\\n        answer=[]\\n        for word in words:\\n            ans=0\\n            for i in range(1, len(word)+1):\\n                ans+= prefixscore[word[:i]]\\n            answer.append(ans)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590329,
                "title": "c-trie-template-credits-striver",
                "content": "```\\nstruct Node {\\n  Node * links[26];\\n  int flag = 0;\\n  int cntPrefix=0;\\n\\n  bool containsKey(char ch) {\\n    return (links[ch - \\'a\\'] != NULL);\\n  }\\n  Node* get(char ch) {\\n    return links[ch - \\'a\\'];\\n  }\\n  void put(char ch, Node * node) {\\n    links[ch - \\'a\\'] = node;\\n  }\\n  void increasePrefix() {\\n    cntPrefix++;\\n  }\\n  void reducePrefix() {\\n    cntPrefix--;\\n  }\\n  int getPrefix() {\\n    return cntPrefix;\\n  }\\n};\\nclass Trie {\\n  private:\\n    Node * root;\\n\\n  public:\\n    Trie() {\\n      root = new Node();\\n    }\\n\\n  void insert(string word) {\\n    Node *node = root;\\n    for (int i = 0; i < word.length(); i++) {\\n      if (!node -> containsKey(word[i])) {\\n        node -> put(word[i], new Node());\\n      }\\n      node = node -> get(word[i]);\\n      node -> increasePrefix();\\n    }\\n  }\\n    \\n  int getAns(string word){\\n      Node* node = root;\\n      int ans = 0;\\n      for(int i=0; i<word.length(); i++){\\n            node = node->get(word[i]);\\n            ans+= node->getPrefix(); \\n      }\\n      return ans;\\n  }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie t;\\n        for(auto str: words) t.insert(str);\\n        vector<int> res;\\n        for(auto str: words){\\n            res.push_back(t.getAns(str));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n  Node * links[26];\\n  int flag = 0;\\n  int cntPrefix=0;\\n\\n  bool containsKey(char ch) {\\n    return (links[ch - \\'a\\'] != NULL);\\n  }\\n  Node* get(char ch) {\\n    return links[ch - \\'a\\'];\\n  }\\n  void put(char ch, Node * node) {\\n    links[ch - \\'a\\'] = node;\\n  }\\n  void increasePrefix() {\\n    cntPrefix++;\\n  }\\n  void reducePrefix() {\\n    cntPrefix--;\\n  }\\n  int getPrefix() {\\n    return cntPrefix;\\n  }\\n};\\nclass Trie {\\n  private:\\n    Node * root;\\n\\n  public:\\n    Trie() {\\n      root = new Node();\\n    }\\n\\n  void insert(string word) {\\n    Node *node = root;\\n    for (int i = 0; i < word.length(); i++) {\\n      if (!node -> containsKey(word[i])) {\\n        node -> put(word[i], new Node());\\n      }\\n      node = node -> get(word[i]);\\n      node -> increasePrefix();\\n    }\\n  }\\n    \\n  int getAns(string word){\\n      Node* node = root;\\n      int ans = 0;\\n      for(int i=0; i<word.length(); i++){\\n            node = node->get(word[i]);\\n            ans+= node->getPrefix(); \\n      }\\n      return ans;\\n  }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie t;\\n        for(auto str: words) t.insert(str);\\n        vector<int> res;\\n        for(auto str: words){\\n            res.push_back(t.getAns(str));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590294,
                "title": "python-ac-easy-to-understand-dict",
                "content": "First count frequency of each prefix. Needs to be done no matter which algorithm you use.\\n\\nThen for each string, add up frequencies of it\\'s prefixes.\\n**TRICK** : Process longest strings first to avoid re-compute. And memoize it. Also, constraints show only 1000 strings at most\\n\\n```\\ndef sumPrefixScores(self, words: List[str]) -> List[int]:\\n\\n    preToFreq = {}\\n    for word in words:\\n        pre = \\'\\'\\n        for c in word:\\n            pre += c\\n            if not pre in preToFreq:\\n                preToFreq[pre] = 0\\n            preToFreq[pre] += 1\\n    #print(\\'preToFreq:\\', preToFreq)\\n\\n    # Sort words in decreasing order of length to avoid re-compute of seen strings & prefixes. Imp optimisation to avoid TLE\\n    wordsCopy = sorted(words, key=len, reverse=True)\\n    stringToScore = {}\\n    for word in wordsCopy:\\n        if word not in stringToScore:\\n            score = 0\\n            pre = \\'\\'\\n            for c in word:\\n                pre += c\\n                score += preToFreq[pre]\\n                stringToScore[pre] = score\\n            stringToScore[word] = score\\n\\n    return [stringToScore[word] for word in words]\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\ndef sumPrefixScores(self, words: List[str]) -> List[int]:\\n\\n    preToFreq = {}\\n    for word in words:\\n        pre = \\'\\'\\n        for c in word:\\n            pre += c\\n            if not pre in preToFreq:\\n                preToFreq[pre] = 0\\n            preToFreq[pre] += 1\\n    #print(\\'preToFreq:\\', preToFreq)\\n\\n    # Sort words in decreasing order of length to avoid re-compute of seen strings & prefixes. Imp optimisation to avoid TLE\\n    wordsCopy = sorted(words, key=len, reverse=True)\\n    stringToScore = {}\\n    for word in wordsCopy:\\n        if word not in stringToScore:\\n            score = 0\\n            pre = \\'\\'\\n            for c in word:\\n                pre += c\\n                score += preToFreq[pre]\\n                stringToScore[pre] = score\\n            stringToScore[word] = score\\n\\n    return [stringToScore[word] for word in words]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2590271,
                "title": "a-short-easy-golang-solution-with-explanation",
                "content": "```go\\n// for example words = [A,B,C,...]\\n// when we just focus on each word, the score should be the len itself.\\n// when A,B has common prefix, they effect each other by prefix len\\n//  (let A=\"abc\", B=\"ab\", firstly score(A) == 3, when we found B, their common prefix len is 2\\n//   for A, its score should plus 2; for B, its score also plus 2)\\n\\n// \\u521D\\u59CB\\u5316\\u6BCF\\u4E2Awords[i]\\u7684score=len(words[i])\\n// (init scores[i] with len(words[i]))\\n\\n// \\u5BF9\\u4E8Ewords[i],\\u68C0\\u67E5words[j] (n>j>i), \\u8BA1\\u7B97\\u516C\\u5171\\u524D\\u7F00c, \\u5C06scores[i],scores[j] += len(c)\\n// (for each words[i], check words[j], calculate their prefixlen, plus prefixlen to both of them)\\nfunc sumPrefixScores(words []string) []int {\\n\\tscores := make([]int, len(words))\\n\\tfor i := 0; i < len(words); i++ {\\n\\t\\tfor j := i + 1; j < len(words); j++ {\\n\\t\\t\\tprefixLen := strPrefixLen(words[i], words[j])\\n\\t\\t\\tscores[i] += prefixLen\\n\\t\\t\\tscores[j] += prefixLen\\n\\t\\t}\\n\\t\\tscores[i] += len(words[i])\\n\\t}\\n\\treturn scores\\n}\\n```\\n\\n```go\\n// calcluate two string prefixlen\\n// for example: strPrefixLen(\"abk\",\"ab\") == 2\\nfunc strPrefixLen(s1, s2 string) int {\\n\\ti := 0\\n\\tN := len(s2)\\n\\tif len(s1) < len(s2) {\\n\\t\\tN = len(s1)\\n\\t}\\n\\tfor ; i < N; i++ {\\n\\t\\tif s1[i] != s2[i] {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn i\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\n// for example words = [A,B,C,...]\\n// when we just focus on each word, the score should be the len itself.\\n// when A,B has common prefix, they effect each other by prefix len\\n//  (let A=\"abc\", B=\"ab\", firstly score(A) == 3, when we found B, their common prefix len is 2\\n//   for A, its score should plus 2; for B, its score also plus 2)\\n\\n// \\u521D\\u59CB\\u5316\\u6BCF\\u4E2Awords[i]\\u7684score=len(words[i])\\n// (init scores[i] with len(words[i]))\\n\\n// \\u5BF9\\u4E8Ewords[i],\\u68C0\\u67E5words[j] (n>j>i), \\u8BA1\\u7B97\\u516C\\u5171\\u524D\\u7F00c, \\u5C06scores[i],scores[j] += len(c)\\n// (for each words[i], check words[j], calculate their prefixlen, plus prefixlen to both of them)\\nfunc sumPrefixScores(words []string) []int {\\n\\tscores := make([]int, len(words))\\n\\tfor i := 0; i < len(words); i++ {\\n\\t\\tfor j := i + 1; j < len(words); j++ {\\n\\t\\t\\tprefixLen := strPrefixLen(words[i], words[j])\\n\\t\\t\\tscores[i] += prefixLen\\n\\t\\t\\tscores[j] += prefixLen\\n\\t\\t}\\n\\t\\tscores[i] += len(words[i])\\n\\t}\\n\\treturn scores\\n}\\n```\n```go\\n// calcluate two string prefixlen\\n// for example: strPrefixLen(\"abk\",\"ab\") == 2\\nfunc strPrefixLen(s1, s2 string) int {\\n\\ti := 0\\n\\tN := len(s2)\\n\\tif len(s1) < len(s2) {\\n\\t\\tN = len(s1)\\n\\t}\\n\\tfor ; i < N; i++ {\\n\\t\\tif s1[i] != s2[i] {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn i\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590227,
                "title": "python3-easy-solution-using-list",
                "content": "```\\n1. Add every prefix of each word in a List\\n2. After every prefix, add 0 to seperate it\\n3. Make a hashmap of that list\\n4. Iterate through the list and sum up the prefix counters \\n\\tif it is not 0\\n\\totherwise add it to the result list\\n5. return the result\\n```\\n\\n\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        lst = []\\n        for i in words:\\n            r = \\'\\'\\n            for w in i:\\n                r += w\\n                lst.append(r)\\n            lst.append(0)\\n        d = Counter(lst)\\n        res = []\\n        c = 0\\n        for i in lst:\\n            if i!=0:\\n                c += d[i]\\n            else:\\n                res.append(c)\\n                c = 0\\n        return res\\n```\\n** Do Upvote** if you find it useful",
                "solutionTags": [],
                "code": "```\\n1. Add every prefix of each word in a List\\n2. After every prefix, add 0 to seperate it\\n3. Make a hashmap of that list\\n4. Iterate through the list and sum up the prefix counters \\n\\tif it is not 0\\n\\totherwise add it to the result list\\n5. return the result\\n```\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        lst = []\\n        for i in words:\\n            r = \\'\\'\\n            for w in i:\\n                r += w\\n                lst.append(r)\\n            lst.append(0)\\n        d = Counter(lst)\\n        res = []\\n        c = 0\\n        for i in lst:\\n            if i!=0:\\n                c += d[i]\\n            else:\\n                res.append(c)\\n                c = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590174,
                "title": "not-optimal-but-easy-to-understanding",
                "content": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        prefs = {}\\n        \\n        ans = []\\n        \\n        for w in words:\\n            for i in range(1, len(w)+1):\\n                if w[0:i] not in prefs:\\n                    prefs[w[0:i]] = 1\\n                else:\\n                    prefs[w[0:i]] += 1\\n                    \\n        for i, w in enumerate(words):\\n            for j in range(1, len(w)+1):\\n                if i >= len(ans):\\n                    ans.append(prefs[w[0:j]])\\n                else:\\n                    ans[i] += prefs[w[0:j]]\\n        \\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        prefs = {}\\n        \\n        ans = []\\n        \\n        for w in words:\\n            for i in range(1, len(w)+1):\\n                if w[0:i] not in prefs:\\n                    prefs[w[0:i]] = 1\\n                else:\\n                    prefs[w[0:i]] += 1\\n                    \\n        for i, w in enumerate(words):\\n            for j in range(1, len(w)+1):\\n                if i >= len(ans):\\n                    ans.append(prefs[w[0:j]])\\n                else:\\n                    ans[i] += prefs[w[0:j]]\\n        \\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590170,
                "title": "trie-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    /*\\n      Basic Trie:\\n      let take first take case and try to build some tree with that data\\n      (node,cnt)->nodeOfTree\\n      arr = [\"abc\",\"ab\",\"bc\",\"b\"]\\n      \\n      Step1 add abc:\\n      (*,0)\\n       /  \\n      (a,1)\\n      /\\n      (b,1)\\n      /\\n      (c,1)\\n      \\n      Step 2 add ab:\\n      (*,0)\\n      /\\n     (a,2)\\n     /\\n    (b,2)\\n    /\\n   (c,1)\\n      Step 3 add bc:\\n      (*,0)\\n      /    \\\\\\n     (a,2)  (b,1)\\n     /         \\\\\\n    (b,2)      (c,1)\\n    /\\n   (c,1)\\n     \\n     step 4 add b:\\n       (*,0)\\n      /    \\\\\\n     (a,2)  (b,2)\\n     /         \\\\\\n    (b,2)      (c,1)\\n    /\\n   (c,1)\\n      \\n \\n Basically what i did i insert the letters in trie and every time when in enter leeter i increase its prefix counter++ \\n Now we need to traverse the word and add its prefix count to answer and push it into the array\\n \\n Look at insert and getcount function and try to dry run it for a much better understanding\\n \\n    */\\n    \\n    class Trie{\\n         public:\\n          int count;\\n          char ch;\\n          Trie* children[26];\\n          Trie(char c){\\n              for(int i =0;i<26;i++){\\n                  children[i] = NULL;\\n              };\\n              count =0;\\n              ch = c;\\n          }\\n    };\\n    \\npublic:\\n    Trie* root = new Trie(\\'*\\');\\n    \\n    void insert(Trie* root,string word){\\n        Trie* temp = root;\\n        for(auto ch:word){\\n            if(temp->children[ch-\\'a\\']==NULL)temp->children[ch-\\'a\\'] = new Trie(ch);\\n            temp = temp->children[ch-\\'a\\'];\\n            temp->count++;\\n        }\\n    };\\n    int getCount(Trie* root,string word){\\n        Trie* temp = root;\\n        int ans = 0;\\n        for(auto ch:word){\\n            if(temp->children[ch-\\'a\\']==NULL)break;\\n            temp = temp->children[ch-\\'a\\'];\\n            ans+=temp->count;\\n        }\\n        return ans;\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        for(auto ele:words)insert(root,ele);   \\n        vector<int> ans;\\n        for(auto ele:words){\\n            ans.push_back(getCount(root,ele));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n      Basic Trie:\\n      let take first take case and try to build some tree with that data\\n      (node,cnt)->nodeOfTree\\n      arr = [\"abc\",\"ab\",\"bc\",\"b\"]\\n      \\n      Step1 add abc:\\n      (*,0)\\n       /  \\n      (a,1)\\n      /\\n      (b,1)\\n      /\\n      (c,1)\\n      \\n      Step 2 add ab:\\n      (*,0)\\n      /\\n     (a,2)\\n     /\\n    (b,2)\\n    /\\n   (c,1)\\n      Step 3 add bc:\\n      (*,0)\\n      /    \\\\\\n     (a,2)  (b,1)\\n     /         \\\\\\n    (b,2)      (c,1)\\n    /\\n   (c,1)\\n     \\n     step 4 add b:\\n       (*,0)\\n      /    \\\\\\n     (a,2)  (b,2)\\n     /         \\\\\\n    (b,2)      (c,1)\\n    /\\n   (c,1)\\n      \\n \\n Basically what i did i insert the letters in trie and every time when in enter leeter i increase its prefix counter++ \\n Now we need to traverse the word and add its prefix count to answer and push it into the array\\n \\n Look at insert and getcount function and try to dry run it for a much better understanding\\n \\n    */\\n    \\n    class Trie{\\n         public:\\n          int count;\\n          char ch;\\n          Trie* children[26];\\n          Trie(char c){\\n              for(int i =0;i<26;i++){\\n                  children[i] = NULL;\\n              };\\n              count =0;\\n              ch = c;\\n          }\\n    };\\n    \\npublic:\\n    Trie* root = new Trie(\\'*\\');\\n    \\n    void insert(Trie* root,string word){\\n        Trie* temp = root;\\n        for(auto ch:word){\\n            if(temp->children[ch-\\'a\\']==NULL)temp->children[ch-\\'a\\'] = new Trie(ch);\\n            temp = temp->children[ch-\\'a\\'];\\n            temp->count++;\\n        }\\n    };\\n    int getCount(Trie* root,string word){\\n        Trie* temp = root;\\n        int ans = 0;\\n        for(auto ch:word){\\n            if(temp->children[ch-\\'a\\']==NULL)break;\\n            temp = temp->children[ch-\\'a\\'];\\n            ans+=temp->count;\\n        }\\n        return ans;\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        for(auto ele:words)insert(root,ele);   \\n        vector<int> ans;\\n        for(auto ele:words){\\n            ans.push_back(getCount(root,ele));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590167,
                "title": "trie",
                "content": "**Reference:** https://takeuforward.org/data-structure/implement-trie-ii/\\n\\nBasically we create a Trie with node having( links[26] array and cntPrefix)\\n\\n**Time Complexity: O((length of the longest string)*(words.length())\\nCode:**\\n```\\nstruct Node {\\n  Node * links[26];\\n  int cntPrefix = 0;\\n\\n  bool containsKey(char ch) {\\n    return (links[ch - \\'a\\'] != NULL);\\n  }\\n  Node * get(char ch) {\\n    return links[ch - \\'a\\'];\\n  }\\n  void put(char ch, Node * node) {\\n    links[ch - \\'a\\'] = node;\\n  }\\n  void increasePrefix() {\\n    cntPrefix++;\\n  }\\n  int getPrefix() {\\n    return cntPrefix;\\n  }\\n};\\nclass Trie {\\n  private:\\n    Node * root;\\n\\n  public:\\n    /** Initialize your data structure here. */\\n    Trie() {\\n      root = new Node();\\n    }\\n\\n  /** Inserts a word into the trie. */\\n  void insert(string word) {\\n    Node * node = root;\\n    for (int i = 0; i < word.length(); i++) {\\n      if (!node -> containsKey(word[i])) {\\n        node -> put(word[i], new Node());\\n      }\\n      node = node -> get(word[i]);\\n      node -> increasePrefix();\\n    }\\n  }\\n\\n  int countWordsStartingWith(string & word) {\\n    int ans=0;\\n    Node * node = root;\\n    ans+=node -> getPrefix();\\n    for (int i = 0; i < word.length(); i++) {\\n      if (node -> containsKey(word[i])) {\\n        node = node -> get(word[i]);\\n           ans+=node -> getPrefix();\\n      } else {\\n        return 0;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> ans;\\n        Trie T;\\n        for(auto &word: words){\\n            T.insert(word);\\n        }\\n        for(auto &word: words){\\n            ans.push_back(T.countWordsStartingWith(word));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n  Node * links[26];\\n  int cntPrefix = 0;\\n\\n  bool containsKey(char ch) {\\n    return (links[ch - \\'a\\'] != NULL);\\n  }\\n  Node * get(char ch) {\\n    return links[ch - \\'a\\'];\\n  }\\n  void put(char ch, Node * node) {\\n    links[ch - \\'a\\'] = node;\\n  }\\n  void increasePrefix() {\\n    cntPrefix++;\\n  }\\n  int getPrefix() {\\n    return cntPrefix;\\n  }\\n};\\nclass Trie {\\n  private:\\n    Node * root;\\n\\n  public:\\n    /** Initialize your data structure here. */\\n    Trie() {\\n      root = new Node();\\n    }\\n\\n  /** Inserts a word into the trie. */\\n  void insert(string word) {\\n    Node * node = root;\\n    for (int i = 0; i < word.length(); i++) {\\n      if (!node -> containsKey(word[i])) {\\n        node -> put(word[i], new Node());\\n      }\\n      node = node -> get(word[i]);\\n      node -> increasePrefix();\\n    }\\n  }\\n\\n  int countWordsStartingWith(string & word) {\\n    int ans=0;\\n    Node * node = root;\\n    ans+=node -> getPrefix();\\n    for (int i = 0; i < word.length(); i++) {\\n      if (node -> containsKey(word[i])) {\\n        node = node -> get(word[i]);\\n           ans+=node -> getPrefix();\\n      } else {\\n        return 0;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> ans;\\n        Trie T;\\n        for(auto &word: words){\\n            T.insert(word);\\n        }\\n        for(auto &word: words){\\n            ans.push_back(T.countWordsStartingWith(word));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590128,
                "title": "javascript-trie",
                "content": "```\\nclass TrieNode {\\n    constructor() {\\n        this.children = {};\\n        this.cnt = 0;\\n    }\\n}\\n\\n\\nvar sumPrefixScores = function(words) {\\n    const root = new TrieNode();\\n    function add(w) {\\n        let cur = root;\\n       for(let i = 0; i<w.length; i++){\\n           const c = w[i];\\n           if(!cur.children[c]) {\\n               cur.children[c] = new TrieNode();\\n           }\\n           cur = cur.children[c];\\n           cur.cnt++;\\n       } \\n    }\\n    function find(w) {\\n        let total = 0;\\n        let cur = root;\\n        for(let i = 0; i<w.length; i++){\\n           const c = w[i];\\n           if(!cur.children[c]) {\\n               break;\\n           }\\n           cur = cur.children[c];\\n           total += cur.cnt;\\n       } \\n        return total;\\n    }\\n    for(const word of words) {\\n        add(word);\\n    }\\n    const ans = [];\\n    for(const word of words) {\\n        ans.push(find(word));\\n    }\\n    return ans;   \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\n    constructor() {\\n        this.children = {};\\n        this.cnt = 0;\\n    }\\n}\\n\\n\\nvar sumPrefixScores = function(words) {\\n    const root = new TrieNode();\\n    function add(w) {\\n        let cur = root;\\n       for(let i = 0; i<w.length; i++){\\n           const c = w[i];\\n           if(!cur.children[c]) {\\n               cur.children[c] = new TrieNode();\\n           }\\n           cur = cur.children[c];\\n           cur.cnt++;\\n       } \\n    }\\n    function find(w) {\\n        let total = 0;\\n        let cur = root;\\n        for(let i = 0; i<w.length; i++){\\n           const c = w[i];\\n           if(!cur.children[c]) {\\n               break;\\n           }\\n           cur = cur.children[c];\\n           total += cur.cnt;\\n       } \\n        return total;\\n    }\\n    for(const word of words) {\\n        add(word);\\n    }\\n    const ans = [];\\n    for(const word of words) {\\n        ans.push(find(word));\\n    }\\n    return ans;   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590123,
                "title": "trie-c-explained-time-and-space-complexity",
                "content": "```\\n// Space and Time Complexity : O(no.of words *  length of string) \\n// store a cnt variable and keep updating on inserting words\\n// on searching for each word add the sum of cnt of each node\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        TrieNode* ptr[26];\\n\\t\\t// on inserting nodes we update this\\n        int cnt;\\n    };\\n    \\n    TrieNode* root=NULL;\\n    \\n    // create a new node\\n    TrieNode*getNode(){\\n        TrieNode*temp=new TrieNode();\\n        for(int i=0;i<26;i++){\\n            temp->ptr[i]=NULL;\\n        }\\n        temp->cnt=0;\\n        return temp;\\n    }\\n    \\n\\t// inserting the word into the trie\\n    void insert(string word) {\\n        TrieNode*temp=root;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->ptr[word[i]-\\'a\\']){\\n                temp->ptr[word[i]-\\'a\\']=getNode();\\n            }\\n            temp=temp->ptr[word[i]-\\'a\\'];\\n            temp->cnt=(temp->cnt)+1;\\n        }\\n    }\\n    \\n\\t// searching for the word and accumulating cnt until we reach end of the word\\n    int search(string word) {\\n       int cnt=0;\\n        TrieNode*temp=root;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->ptr[word[i]-\\'a\\']){\\n                return 0;\\n            }\\n            temp=temp->ptr[word[i]-\\'a\\'];\\n            cnt+=temp->cnt;\\n        }\\n        return cnt;\\n    }\\n    \\n\\t// iterate through each word and compute the score\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        root=new TrieNode();\\n        for(string x:words){\\n            insert(x);\\n        }\\n        vector<int>ans;\\n        int n=words.size();\\n        for(int i=0;i<n;i++){\\n            string word=words[i];\\n            int cnt=0;\\n            cnt+=search(word);\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\n// Space and Time Complexity : O(no.of words *  length of string) \\n// store a cnt variable and keep updating on inserting words\\n// on searching for each word add the sum of cnt of each node\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        TrieNode* ptr[26];\\n\\t\\t// on inserting nodes we update this\\n        int cnt;\\n    };\\n    \\n    TrieNode* root=NULL;\\n    \\n    // create a new node\\n    TrieNode*getNode(){\\n        TrieNode*temp=new TrieNode();\\n        for(int i=0;i<26;i++){\\n            temp->ptr[i]=NULL;\\n        }\\n        temp->cnt=0;\\n        return temp;\\n    }\\n    \\n\\t// inserting the word into the trie\\n    void insert(string word) {\\n        TrieNode*temp=root;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->ptr[word[i]-\\'a\\']){\\n                temp->ptr[word[i]-\\'a\\']=getNode();\\n            }\\n            temp=temp->ptr[word[i]-\\'a\\'];\\n            temp->cnt=(temp->cnt)+1;\\n        }\\n    }\\n    \\n\\t// searching for the word and accumulating cnt until we reach end of the word\\n    int search(string word) {\\n       int cnt=0;\\n        TrieNode*temp=root;\\n        for(int i=0;i<word.size();i++){\\n            if(!temp->ptr[word[i]-\\'a\\']){\\n                return 0;\\n            }\\n            temp=temp->ptr[word[i]-\\'a\\'];\\n            cnt+=temp->cnt;\\n        }\\n        return cnt;\\n    }\\n    \\n\\t// iterate through each word and compute the score\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        root=new TrieNode();\\n        for(string x:words){\\n            insert(x);\\n        }\\n        vector<int>ans;\\n        int n=words.size();\\n        for(int i=0;i<n;i++){\\n            string word=words[i];\\n            int cnt=0;\\n            cnt+=search(word);\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590120,
                "title": "trie-c",
                "content": "## Solution\\n\\nIn a Trie, each node has a `count` attribute which keeps track of `number of strings which has root node to cur node as prefix`. So, If we want to find prefix score of a string we traverse the trie for that string and sum up count\\'s of all the nodes.\\n\\n### Insert\\n\\nwords = [\"abc\",\"ab\",\"bc\",\"b\"]\\n\\n![image](https://assets.leetcode.com/users/images/553e29c2-9dbf-4805-8635-747658e9e47c_1663471314.6507587.jpeg)\\n\\n### getScore\\n\\n![image](https://assets.leetcode.com/users/images/971cfd9f-a37c-44eb-9945-c87e97d383cc_1663471890.528091.jpeg)\\n\\n**answer = [5, 4, 3, 2]**\\n\\n\\n```\\nclass TrieNode {\\npublic:\\n\\tchar c;\\n\\tunordered_map<char, TrieNode*> children;\\n\\tint count;\\n\\n\\tTrieNode(char ch) { \\n        c = ch;\\n        count = 0; // no of strings that have root to this node as their prefix\\n    }\\n};\\n\\n\\nclass Trie {\\n    TrieNode* root;\\npublic:\\n    Trie() {\\n        root = new TrieNode(\\'*\\');\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for(char ch : word) {\\n            if(cur -> children.find(ch) == cur -> children.end()) {\\n                cur -> children[ch] = new TrieNode(ch);\\n            }\\n            \\n            cur = cur -> children[ch];\\n            cur -> count += 1;\\n        }\\n    }\\n\\n    int getScore(string word) {\\n        TrieNode* cur = root;\\n        int score = 0;\\n        for(char ch : word) {\\n            cur = cur -> children[ch];\\n            score += cur -> count;\\n        }\\n        return score;\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie* t = new Trie();\\n        for(string word: words) {\\n            t -> insert(word);\\n        }\\n        \\n        vector<int> answer;\\n        for(string word: words) {\\n            answer.push_back(t -> getScore(word));\\n        }\\n        \\n        return answer;\\n    }\\n};\\n\\n```\\n\\n### Time & Space\\n* `O(n * m)`, where n = length of words and m = average word length",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n\\tchar c;\\n\\tunordered_map<char, TrieNode*> children;\\n\\tint count;\\n\\n\\tTrieNode(char ch) { \\n        c = ch;\\n        count = 0; // no of strings that have root to this node as their prefix\\n    }\\n};\\n\\n\\nclass Trie {\\n    TrieNode* root;\\npublic:\\n    Trie() {\\n        root = new TrieNode(\\'*\\');\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for(char ch : word) {\\n            if(cur -> children.find(ch) == cur -> children.end()) {\\n                cur -> children[ch] = new TrieNode(ch);\\n            }\\n            \\n            cur = cur -> children[ch];\\n            cur -> count += 1;\\n        }\\n    }\\n\\n    int getScore(string word) {\\n        TrieNode* cur = root;\\n        int score = 0;\\n        for(char ch : word) {\\n            cur = cur -> children[ch];\\n            score += cur -> count;\\n        }\\n        return score;\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie* t = new Trie();\\n        for(string word: words) {\\n            t -> insert(word);\\n        }\\n        \\n        vector<int> answer;\\n        for(string word: words) {\\n            answer.push_back(t -> getScore(word));\\n        }\\n        \\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590119,
                "title": "java-clean-simple-trie",
                "content": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] child = new TrieNode[26];\\n        int count = 0;\\n    }\\n\\n    public int[] sumPrefixScores(String[] words) {\\n        TrieNode root = new TrieNode();\\n        int[] result = new int[words.length];\\n\\n        for (String item : words)\\n            addToRoot(0, item.toCharArray(), root);\\n\\n        for (int i = 0; i < words.length; i++)\\n            result[i] = getCount(0, words[i].toCharArray(), root);\\n\\n        return result;\\n    }\\n\\n    void addToRoot(int index, char[] arr, TrieNode root) {\\n        if (index == arr.length)\\n            return;\\n\\n        int word = arr[index] - \\'a\\';\\n        if (root.child[word] == null)\\n            root.child[word] = new TrieNode();\\n\\n        root.child[word].count++;\\n        addToRoot(index + 1, arr, root.child[word]);\\n    }\\n\\n    int getCount(int index, char[] arr, TrieNode root) {\\n        if (index == arr.length)\\n            return 0;\\n\\n        int word = arr[index] - \\'a\\';\\n        return root.child[word].count + getCount(index + 1, arr, root.child[word]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode {\\n        TrieNode[] child = new TrieNode[26];\\n        int count = 0;\\n    }\\n\\n    public int[] sumPrefixScores(String[] words) {\\n        TrieNode root = new TrieNode();\\n        int[] result = new int[words.length];\\n\\n        for (String item : words)\\n            addToRoot(0, item.toCharArray(), root);\\n\\n        for (int i = 0; i < words.length; i++)\\n            result[i] = getCount(0, words[i].toCharArray(), root);\\n\\n        return result;\\n    }\\n\\n    void addToRoot(int index, char[] arr, TrieNode root) {\\n        if (index == arr.length)\\n            return;\\n\\n        int word = arr[index] - \\'a\\';\\n        if (root.child[word] == null)\\n            root.child[word] = new TrieNode();\\n\\n        root.child[word].count++;\\n        addToRoot(index + 1, arr, root.child[word]);\\n    }\\n\\n    int getCount(int index, char[] arr, TrieNode root) {\\n        if (index == arr.length)\\n            return 0;\\n\\n        int word = arr[index] - \\'a\\';\\n        return root.child[word].count + getCount(index + 1, arr, root.child[word]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590108,
                "title": "python-simple-trie",
                "content": "## Intuition\\nWe can use a Trie to keep track of all the words present in the list, while optimizing search time.\\n\\n## Approach\\nWe implement a Trie class that keeps track of all prefix counts as we insert the words by increasing the count of each visited node by 1. We also implement a function that calculates the prefix score of a string by visiting all the nodes in the trie that form the word and adding their prefix counts. We keep track of past calls to `prefixScores` in case there are repeated words.\\n\\n&#8718;\\n\\n## Code\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.prefixCount = 0\\n\\nclass Trie:\\n    def __init__(self, words: List[str]):\\n        self.trie = TrieNode()\\n        for word in words:\\n            self.insert(word)\\n        self.prefixScores = {}\\n\\n    def insert(self, word: str) -> None:\\n        currentNode = self.trie\\n        for char in word:\\n            currentNode = currentNode.children[char]\\n            currentNode.prefixCount += 1\\n\\n    def prefixScore(self, word: str) -> None:\\n        if word not in self.prefixScores:\\n            self.prefixScores[word] = 0\\n            currentNode = self.trie\\n            for char in word:\\n                currentNode = currentNode.children[char]\\n                self.prefixScores[word] += currentNode.prefixCount\\n        return self.prefixScores[word]\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:        \\n        wordTrie = Trie(words)\\n        return [wordTrie.prefixScore(word) for word in words]\\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.prefixCount = 0\\n\\nclass Trie:\\n    def __init__(self, words: List[str]):\\n        self.trie = TrieNode()\\n        for word in words:\\n            self.insert(word)\\n        self.prefixScores = {}\\n\\n    def insert(self, word: str) -> None:\\n        currentNode = self.trie\\n        for char in word:\\n            currentNode = currentNode.children[char]\\n            currentNode.prefixCount += 1\\n\\n    def prefixScore(self, word: str) -> None:\\n        if word not in self.prefixScores:\\n            self.prefixScores[word] = 0\\n            currentNode = self.trie\\n            for char in word:\\n                currentNode = currentNode.children[char]\\n                self.prefixScores[word] += currentNode.prefixCount\\n        return self.prefixScores[word]\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:        \\n        wordTrie = Trie(words)\\n        return [wordTrie.prefixScore(word) for word in words]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590096,
                "title": "java-python-simple-trie-solution",
                "content": "**Prerequisite:**\\nTrie inserting and finding element [*Trie data structure*](https://www.baeldung.com/trie-java#:~:text=In%20a%20trie%2C%20every%20node,of%20the%20trie%20as%20well.)\\n\\n**Intuition:**\\n1. Build Trie with an additional int array to count of each character.\\n2. Search through the array and keep adding count to variable.\\n\\n**Complexity**\\nm = number of words, n = average character in each word\\n1. **Time** complexity: O(nm)\\n\\t1. **Inserting**: O(n) for each word\\n\\t2. **Finding**: O(n) for each word\\n2. **Space** complexity: O(nm)\\n\\n**Java**\\n```\\nclass Solution {\\n    \\n    class Trie{\\n        int cnt[]; // to store count\\n        Trie next[];\\n        Trie(){\\n            cnt = new int[26];\\n            next = new Trie[26];\\n        }\\n    }\\n    \\n\\tpublic int[] sumPrefixScores(String[] words) {\\n        Trie root = new Trie();\\n        build(words, root);\\n        return solve(words, root);\\n    }\\n\\t\\n    private void build(String words[], Trie root){\\n        for(String word: words){\\n            Trie trie = root;\\n            for(char ch: word.toCharArray()){\\n                int val = ch - \\'a\\';\\n                if(trie.next[val] == null){ // if next[val] is not present, then create one\\n                    trie.next[val] = new Trie();    \\n                }\\n                trie.cnt[val]++;\\n                trie = trie.next[val];\\n            }\\n        }\\n    }\\n    \\n    private int[] solve(String words[], Trie root){\\n        int []res = new int[words.length];\\n        for(int i=0; i<words.length; i++){\\n            int cnt = 0;\\n            Trie trie = root;\\n            for(char ch: words[i].toCharArray()){\\n                int val = ch - \\'a\\';\\n                cnt += trie.cnt[val];\\n                trie = trie.next[val];\\n            }\\n            res[i] = cnt;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    \\n    class Trie(object):\\n        \\n        class TrieNode:\\n\\n            def __init__(self, char):\\n                self.cnt = {}\\n                self.children = {}\\n\\n        def __init__(self):\\n            self.root = self.TrieNode(\"\")\\n\\n        def insert(self, word):\\n            node = self.root\\n            for char in word:\\n                if char not in node.children:\\n                    new_node = self.TrieNode(char)    \\n                    node.children[char] = new_node\\n                node.cnt[char] = node.cnt.get(char, 0) + 1\\n                node = node.children[char]\\n\\n        def find(self, word):\\n            node = self.root\\n            total = 0\\n            for char in word:\\n                total += node.cnt[char]\\n                node = node.children[char]\\n                \\n            return total\\n    \\n    def sumPrefixScores(self, words):\\n        \\n        trie = self.Trie()\\n        for word in words:\\n            trie.insert(word)\\n        \\n        res = []\\n        for word in words:\\n            total = trie.find(word)\\n            res.append(total)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Trie",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Trie{\\n        int cnt[]; // to store count\\n        Trie next[];\\n        Trie(){\\n            cnt = new int[26];\\n            next = new Trie[26];\\n        }\\n    }\\n    \\n\\tpublic int[] sumPrefixScores(String[] words) {\\n        Trie root = new Trie();\\n        build(words, root);\\n        return solve(words, root);\\n    }\\n\\t\\n    private void build(String words[], Trie root){\\n        for(String word: words){\\n            Trie trie = root;\\n            for(char ch: word.toCharArray()){\\n                int val = ch - \\'a\\';\\n                if(trie.next[val] == null){ // if next[val] is not present, then create one\\n                    trie.next[val] = new Trie();    \\n                }\\n                trie.cnt[val]++;\\n                trie = trie.next[val];\\n            }\\n        }\\n    }\\n    \\n    private int[] solve(String words[], Trie root){\\n        int []res = new int[words.length];\\n        for(int i=0; i<words.length; i++){\\n            int cnt = 0;\\n            Trie trie = root;\\n            for(char ch: words[i].toCharArray()){\\n                int val = ch - \\'a\\';\\n                cnt += trie.cnt[val];\\n                trie = trie.next[val];\\n            }\\n            res[i] = cnt;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    \\n    class Trie(object):\\n        \\n        class TrieNode:\\n\\n            def __init__(self, char):\\n                self.cnt = {}\\n                self.children = {}\\n\\n        def __init__(self):\\n            self.root = self.TrieNode(\"\")\\n\\n        def insert(self, word):\\n            node = self.root\\n            for char in word:\\n                if char not in node.children:\\n                    new_node = self.TrieNode(char)    \\n                    node.children[char] = new_node\\n                node.cnt[char] = node.cnt.get(char, 0) + 1\\n                node = node.children[char]\\n\\n        def find(self, word):\\n            node = self.root\\n            total = 0\\n            for char in word:\\n                total += node.cnt[char]\\n                node = node.children[char]\\n                \\n            return total\\n    \\n    def sumPrefixScores(self, words):\\n        \\n        trie = self.Trie()\\n        for word in words:\\n            trie.insert(word)\\n        \\n        res = []\\n        for word in words:\\n            total = trie.find(word)\\n            res.append(total)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590091,
                "title": "python-trie",
                "content": "```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.cnt = 0\\n\\nclass Trie(object):\\n    def __init__(self):\\n        self.root = Node()\\n        \\n    def insert(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = Node()\\n            cur = cur.children[c]\\n            cur.cnt += 1\\n            \\n    def getScore(self, word):\\n        res = 0\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                return -1\\n            cur = cur.children[c]\\n            res += cur.cnt\\n        return res\\n\\nclass Solution(object):\\n    def sumPrefixScores(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        t = Trie()\\n        for w in words:\\n            t.insert(w)\\n        res = []\\n        for w in words:\\n            res.append(t.getScore(w))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.cnt = 0\\n\\nclass Trie(object):\\n    def __init__(self):\\n        self.root = Node()\\n        \\n    def insert(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = Node()\\n            cur = cur.children[c]\\n            cur.cnt += 1\\n            \\n    def getScore(self, word):\\n        res = 0\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                return -1\\n            cur = cur.children[c]\\n            res += cur.cnt\\n        return res\\n\\nclass Solution(object):\\n    def sumPrefixScores(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        t = Trie()\\n        for w in words:\\n            t.insert(w)\\n        res = []\\n        for w in words:\\n            res.append(t.getScore(w))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590076,
                "title": "python-trie-memo-o-nk-time",
                "content": "Idea is simple - while building the Trie, track the count of words at each level of it. When we insert \"abc\", we increment count at \"a\" (prefix \"a\"), then at \"b\" (prefix \"ab\"), then at \"c\" (prefix \"abc\").\\n\\nAfter that we can iterate through our words and simply add all these counts for each word, while we do search for it in the Trie. We can save the result into the hashmap to exclude excessive work for duplicates.\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.wordsCount = 0\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        node = self.root\\n        for i in word:\\n            node.wordsCount += 1 \\n            if i not in node.children:\\n                node.children[i] = TrieNode()\\n            node = node.children[i]\\n        node.wordsCount += 1\\n\\n    def getPrefixScore(self, word):\\n        score = 0\\n        node = self.root\\n        for i in word:\\n            if i not in node.children:\\n                return False\\n            node = node.children[i]\\n            score += node.wordsCount\\n        return score\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n        res, memo = [], {}\\n        \\n        # Fill the trie\\n        for w in words:\\n            trie.insert(w)\\n        \\n        # Calculate score for each word and save the result\\n        for w in words:\\n            if w not in memo:\\n                memo[w] = trie.getPrefixScore(w)\\n            res.append(memo[w])\\n\\n        return res\\n```\\n\\nTime complexity: `O(kn)` to build a trie and to get the scores for all the words, where `k` - average length of the word in the array and `n` - number of words.\\nSpace complexity: `O(kn)`",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.wordsCount = 0\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        node = self.root\\n        for i in word:\\n            node.wordsCount += 1 \\n            if i not in node.children:\\n                node.children[i] = TrieNode()\\n            node = node.children[i]\\n        node.wordsCount += 1\\n\\n    def getPrefixScore(self, word):\\n        score = 0\\n        node = self.root\\n        for i in word:\\n            if i not in node.children:\\n                return False\\n            node = node.children[i]\\n            score += node.wordsCount\\n        return score\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n        res, memo = [], {}\\n        \\n        # Fill the trie\\n        for w in words:\\n            trie.insert(w)\\n        \\n        # Calculate score for each word and save the result\\n        for w in words:\\n            if w not in memo:\\n                memo[w] = trie.getPrefixScore(w)\\n            res.append(memo[w])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590043,
                "title": "c-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        int cnt;\\n        vector<TrieNode*> hash;\\n        TrieNode(){\\n            this->cnt = 0;\\n            hash.resize(26, NULL);\\n        }\\n        void put(char ch){\\n            this->hash[ch-\\'a\\'] = new TrieNode();\\n        }\\n        bool contain(char ch){\\n            return this->hash[ch-\\'a\\'] != NULL;\\n        }\\n        void incre(char ch){\\n            this->cnt +=1;\\n        }\\n        TrieNode* get(char ch){\\n            return this->hash[ch-\\'a\\'];\\n        }\\n    };\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        for(string str : words){\\n            TrieNode* curr = root;\\n            for(int i = 0; i<str.size(); i++){\\n                char ch = str[i];\\n                if(!curr->contain(ch))\\n                    curr->put(ch);\\n                curr = curr->get(ch);\\n                curr->cnt +=1;\\n            }\\n        }\\n        int n = words.size();\\n        vector<int> ans(n, 0);\\n        for(int j = 0; j<n; j++){\\n            string str = words[j];\\n            TrieNode* curr = root;\\n            for(int i = 0; i<str.size(); i++){\\n                char ch = str[i];\\n                curr = curr->get(ch);\\n                ans[j] += curr->cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        int cnt;\\n        vector<TrieNode*> hash;\\n        TrieNode(){\\n            this->cnt = 0;\\n            hash.resize(26, NULL);\\n        }\\n        void put(char ch){\\n            this->hash[ch-\\'a\\'] = new TrieNode();\\n        }\\n        bool contain(char ch){\\n            return this->hash[ch-\\'a\\'] != NULL;\\n        }\\n        void incre(char ch){\\n            this->cnt +=1;\\n        }\\n        TrieNode* get(char ch){\\n            return this->hash[ch-\\'a\\'];\\n        }\\n    };\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        TrieNode* root = new TrieNode();\\n        for(string str : words){\\n            TrieNode* curr = root;\\n            for(int i = 0; i<str.size(); i++){\\n                char ch = str[i];\\n                if(!curr->contain(ch))\\n                    curr->put(ch);\\n                curr = curr->get(ch);\\n                curr->cnt +=1;\\n            }\\n        }\\n        int n = words.size();\\n        vector<int> ans(n, 0);\\n        for(int j = 0; j<n; j++){\\n            string str = words[j];\\n            TrieNode* curr = root;\\n            for(int i = 0; i<str.size(); i++){\\n                char ch = str[i];\\n                curr = curr->get(ch);\\n                ans[j] += curr->cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072497,
                "title": "c-trie-solution-o-n-m-time",
                "content": "# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstruct trieN {\\n    unordered_map<char, struct trieN*> ptrs;\\n    int val;\\n};\\nstruct trieN* getNewTrieNode() {\\n    struct trieN* n = new trieN();\\n    n->val = 0;\\n    return n;\\n}\\nvector<int> sumPrefixScores(vector<string>& words) {\\n    vector<struct trieN*> heads(26);\\n    for(int i=0;i<26;i++) {\\n        heads[i]=getNewTrieNode();\\n    }\\n    for(int i=0;i<words.size();i++){\\n        trieN* curr = NULL;\\n        for(int j=0;j<words[i].size();j++){\\n            if(j==0) {\\n                curr=heads[words[i][j]-\\'a\\'];\\n            } else {\\n                if((curr->ptrs)[words[i][j]-\\'a\\']==NULL) {\\n                    (curr->ptrs)[words[i][j]-\\'a\\']=getNewTrieNode();\\n                }\\n                curr=(curr->ptrs)[words[i][j]-\\'a\\'];\\n            }\\n            curr->val += 1;\\n        }\\n    }\\n    vector<int> ans;\\n    for(int i=0;i<words.size();i++){\\n        trieN* curr = NULL;\\n        int res=0;\\n        for(int j=0;j<words[i].size();j++){\\n            if(j==0) {\\n                curr=heads[words[i][j]-\\'a\\'];\\n            } else {\\n                curr=(curr->ptrs)[words[i][j]-\\'a\\'];\\n            }\\n            res += (curr->val);\\n        }\\n        ans.push_back(res);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstruct trieN {\\n    unordered_map<char, struct trieN*> ptrs;\\n    int val;\\n};\\nstruct trieN* getNewTrieNode() {\\n    struct trieN* n = new trieN();\\n    n->val = 0;\\n    return n;\\n}\\nvector<int> sumPrefixScores(vector<string>& words) {\\n    vector<struct trieN*> heads(26);\\n    for(int i=0;i<26;i++) {\\n        heads[i]=getNewTrieNode();\\n    }\\n    for(int i=0;i<words.size();i++){\\n        trieN* curr = NULL;\\n        for(int j=0;j<words[i].size();j++){\\n            if(j==0) {\\n                curr=heads[words[i][j]-\\'a\\'];\\n            } else {\\n                if((curr->ptrs)[words[i][j]-\\'a\\']==NULL) {\\n                    (curr->ptrs)[words[i][j]-\\'a\\']=getNewTrieNode();\\n                }\\n                curr=(curr->ptrs)[words[i][j]-\\'a\\'];\\n            }\\n            curr->val += 1;\\n        }\\n    }\\n    vector<int> ans;\\n    for(int i=0;i<words.size();i++){\\n        trieN* curr = NULL;\\n        int res=0;\\n        for(int j=0;j<words[i].size();j++){\\n            if(j==0) {\\n                curr=heads[words[i][j]-\\'a\\'];\\n            } else {\\n                curr=(curr->ptrs)[words[i][j]-\\'a\\'];\\n            }\\n            res += (curr->val);\\n        }\\n        ans.push_back(res);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012990,
                "title": "simple-python-trie",
                "content": "# Intuition\\nThe logic is very similar to [Add and Search word](https://leetcode.com/problems/design-add-and-search-words-data-structure/). We need to build a trie and keep incrementing the frequency for each letter.\\n\\nIterate through each word individually now and compute the sum of frequencies across each letter. This is nothing but the prefix scores\\n\\n# Code\\n```\\nclass TrieNode:\\n    def __init__(self) -> None:\\n        self.children = {}\\n        self.freq = 0\\n\\nclass Trie:\\n    def __init__(self, words) -> None:\\n        self.root = TrieNode()\\n        self.words = words\\n    \\n    def buildTrie(self):\\n        for word in self.words:\\n            root = self.root\\n            for letter in word:\\n                if letter not in root.children:\\n                    root.children[letter] = TrieNode()\\n                root = root.children[letter]\\n                root.freq += 1\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie(words)\\n        trie.buildTrie()\\n\\n        prefixScores = []\\n        for word in words:\\n            root = trie.root\\n            score = 0\\n            for letter in word:\\n                score += root.children[letter].freq\\n                root = root.children[letter]\\n            prefixScores.append(score)\\n        \\n        return prefixScores\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self) -> None:\\n        self.children = {}\\n        self.freq = 0\\n\\nclass Trie:\\n    def __init__(self, words) -> None:\\n        self.root = TrieNode()\\n        self.words = words\\n    \\n    def buildTrie(self):\\n        for word in self.words:\\n            root = self.root\\n            for letter in word:\\n                if letter not in root.children:\\n                    root.children[letter] = TrieNode()\\n                root = root.children[letter]\\n                root.freq += 1\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie(words)\\n        trie.buildTrie()\\n\\n        prefixScores = []\\n        for word in words:\\n            root = trie.root\\n            score = 0\\n            for letter in word:\\n                score += root.children[letter].freq\\n                root = root.children[letter]\\n            prefixScores.append(score)\\n        \\n        return prefixScores\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001170,
                "title": "c-python-trie-solution-with-explanation",
                "content": "### Trie\\n![image](https://assets.leetcode.com/users/images/469ce741-5f96-46e4-b713-953c8be1e7d2_1693830214.1985078.png)\\n### python\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = defaultdict(Trie)\\n        self.cnt = 0\\n    \\n    def insert(self, word):\\n        cur = self\\n        for ch in word:\\n            cur = cur.childs[ch]\\n            cur.cnt += 1\\n    \\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        root = Trie()\\n        for word in words:\\n            root.insert(word)\\n        def dfs(node, i, word):\\n            if i == len(word): return node.cnt\\n            return node.cnt + dfs(node.childs[word[i]], i+1, word)\\n        ans = []\\n        for word in words:\\n            ans.append(dfs(root, 0, word))\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Trie {\\npublic:\\n    Trie *childs[26] {nullptr};\\n    int cnt = 0;\\n    Trie () {};\\n    void insert(string& word) {\\n        Trie *cur = this;\\n        for (auto& ch: word) {\\n            if (cur -> childs[ch -\\'a\\'] == nullptr) cur -> childs[ch -\\'a\\'] = new Trie();\\n            cur = cur -> childs[ch -\\'a\\'];\\n            cur -> cnt += 1;\\n        }\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie *root = new Trie();\\n        for (auto& word: words) root -> insert(word);\\n        function<int(Trie *, int, string&)> dfs = [&] (Trie *node, int i, string& word) {\\n            if (i == word.size()) return node -> cnt;\\n            return node -> cnt + dfs(node -> childs[word[i] - \\'a\\'], i+1, word);\\n        };\\n        vector<int> ans;\\n        for (auto& word: words)\\n            ans.emplace_back(dfs(root, 0, word));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Trie"
                ],
                "code": "```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = defaultdict(Trie)\\n        self.cnt = 0\\n    \\n    def insert(self, word):\\n        cur = self\\n        for ch in word:\\n            cur = cur.childs[ch]\\n            cur.cnt += 1\\n    \\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        root = Trie()\\n        for word in words:\\n            root.insert(word)\\n        def dfs(node, i, word):\\n            if i == len(word): return node.cnt\\n            return node.cnt + dfs(node.childs[word[i]], i+1, word)\\n        ans = []\\n        for word in words:\\n            ans.append(dfs(root, 0, word))\\n        return ans\\n```\n```cpp\\nclass Trie {\\npublic:\\n    Trie *childs[26] {nullptr};\\n    int cnt = 0;\\n    Trie () {};\\n    void insert(string& word) {\\n        Trie *cur = this;\\n        for (auto& ch: word) {\\n            if (cur -> childs[ch -\\'a\\'] == nullptr) cur -> childs[ch -\\'a\\'] = new Trie();\\n            cur = cur -> childs[ch -\\'a\\'];\\n            cur -> cnt += 1;\\n        }\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie *root = new Trie();\\n        for (auto& word: words) root -> insert(word);\\n        function<int(Trie *, int, string&)> dfs = [&] (Trie *node, int i, string& word) {\\n            if (i == word.size()) return node -> cnt;\\n            return node -> cnt + dfs(node -> childs[word[i] - \\'a\\'], i+1, word);\\n        };\\n        vector<int> ans;\\n        for (auto& word: words)\\n            ans.emplace_back(dfs(root, 0, word));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960538,
                "title": "trie-easy-sol-c",
                "content": "solution only for those who have basic idea of trie\\n\\n\\njust make a trie and maintain a count prefix at each node and at the time of query just count the total no of cp (count prefix)\\n\\nthoda sa detail i will give \\nhar letter pe kitne prefix bante jare wo cp me store hote ja raha hai and at the time of query bas jaha tak links hai and cp value positive hai add karte jao else return \\n\\n# Code\\n```\\nstruct Node{\\n    Node* links[26];\\n    int cp=0;\\n    int ew=0;\\n};\\nclass Trie{\\n    public:\\n    Node* root;\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(string &s){\\n        int n=s.size();\\n        Node* temp=root;\\n        for(int i=0; i<n; i++){\\n            if(temp->links[s[i]-\\'a\\']==NULL){\\n                Node* newnode=new Node();\\n                temp->links[s[i]-\\'a\\']=newnode;\\n            }\\n            temp=temp->links[s[i]-\\'a\\'];\\n            temp->cp++;\\n        }\\n        temp->ew++;\\n    }\\n    int query(string &s){\\n        int n=s.size(); \\n        Node* temp=root;\\n        int count=0;\\n        for(int i=0; i<n; i++){\\n            if(temp->links[s[i]-\\'a\\']==NULL){\\n                return count;\\n            }\\n            else{\\n                temp=temp->links[s[i]-\\'a\\'];\\n                count+=temp->cp;\\n            }\\n        }\\n        return count;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie T;\\n        for(int i=0; i<words.size(); i++){\\n            T.insert(words[i]);\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<words.size(); i++){\\n            int temp=T.query(words[i]);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* links[26];\\n    int cp=0;\\n    int ew=0;\\n};\\nclass Trie{\\n    public:\\n    Node* root;\\n    Trie(){\\n        root=new Node();\\n    }\\n    void insert(string &s){\\n        int n=s.size();\\n        Node* temp=root;\\n        for(int i=0; i<n; i++){\\n            if(temp->links[s[i]-\\'a\\']==NULL){\\n                Node* newnode=new Node();\\n                temp->links[s[i]-\\'a\\']=newnode;\\n            }\\n            temp=temp->links[s[i]-\\'a\\'];\\n            temp->cp++;\\n        }\\n        temp->ew++;\\n    }\\n    int query(string &s){\\n        int n=s.size(); \\n        Node* temp=root;\\n        int count=0;\\n        for(int i=0; i<n; i++){\\n            if(temp->links[s[i]-\\'a\\']==NULL){\\n                return count;\\n            }\\n            else{\\n                temp=temp->links[s[i]-\\'a\\'];\\n                count+=temp->cp;\\n            }\\n        }\\n        return count;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie T;\\n        for(int i=0; i<words.size(); i++){\\n            T.insert(words[i]);\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<words.size(); i++){\\n            int temp=T.query(words[i]);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898472,
                "title": "easy-solution-for-beginners-with-explanation-implementing-tries",
                "content": "**You need to have basic knowledge of trie data structure.**\\n\\n---\\n# Approach\\nAfter inserting all words run a loop on words for getting its sum.\\nFor counting sum of all prefixs of a word take `int currFreq` and loop the word while looping add all `curr.children[idx]` in `currFreq` and return `currFreq`\\n# Code\\n```\\nclass Solution {\\n    // making a trie class\\n    public class Node{\\n        Node children[] = new Node[26];\\n        int freq;\\n        Node(){\\n            for(int i = 0; i<26; i++){\\n                children[i] = null;\\n            }\\n          \\n            freq = 0;\\n        }\\n    }\\n    // initializing trie node\\n    Node root = new Node();\\n    public void insert(String word){\\n        Node curr = root;\\n        for(int i = 0; i<word.length(); i++){\\n            int idx = word.charAt(i)-\\'a\\';\\n            if(curr.children[idx] == null){\\n                curr.children[idx] = new Node();\\n            }\\n            curr.children[idx].freq++;\\n            curr = curr.children[idx];\\n        }\\n    }\\n    public int getFreq(String word){\\n        Node curr = root;\\n        int currFreq = 0;\\n        for(int i = 0; i<word.length(); i++){\\n            int idx = word.charAt(i)-\\'a\\';\\n            currFreq += curr.children[idx].freq;\\n            curr = curr.children[idx];\\n        }\\n        return currFreq;\\n    }\\n    public int[] sumPrefixScores(String[] words) {\\n        //inserting all words in trie\\n        for(int i = 0; i<words.length; i++){\\n            insert(words[i]);\\n        }\\n        int[] prefixSum = new int[words.length];\\n        // calling getFreq function and storing it at index\\n        for(int i = 0; i<words.length; i++){\\n            prefixSum[i] = getFreq(words[i]);\\n        }\\n        return prefixSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Trie",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    // making a trie class\\n    public class Node{\\n        Node children[] = new Node[26];\\n        int freq;\\n        Node(){\\n            for(int i = 0; i<26; i++){\\n                children[i] = null;\\n            }\\n          \\n            freq = 0;\\n        }\\n    }\\n    // initializing trie node\\n    Node root = new Node();\\n    public void insert(String word){\\n        Node curr = root;\\n        for(int i = 0; i<word.length(); i++){\\n            int idx = word.charAt(i)-\\'a\\';\\n            if(curr.children[idx] == null){\\n                curr.children[idx] = new Node();\\n            }\\n            curr.children[idx].freq++;\\n            curr = curr.children[idx];\\n        }\\n    }\\n    public int getFreq(String word){\\n        Node curr = root;\\n        int currFreq = 0;\\n        for(int i = 0; i<word.length(); i++){\\n            int idx = word.charAt(i)-\\'a\\';\\n            currFreq += curr.children[idx].freq;\\n            curr = curr.children[idx];\\n        }\\n        return currFreq;\\n    }\\n    public int[] sumPrefixScores(String[] words) {\\n        //inserting all words in trie\\n        for(int i = 0; i<words.length; i++){\\n            insert(words[i]);\\n        }\\n        int[] prefixSum = new int[words.length];\\n        // calling getFreq function and storing it at index\\n        for(int i = 0; i<words.length; i++){\\n            prefixSum[i] = getFreq(words[i]);\\n        }\\n        return prefixSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896109,
                "title": "efficient-js-solution-without-trie-tree-beat-100-time-and-75-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/33ac9639-565a-400f-b954-c35cb4cc70f6_1691776432.4066484.png)\\n\\nI have tried Trie Tree but that resulted in a bad allocation error, so this is my alternative solution, which is WAY better.\\n\\n# Complexity\\n- let `m = max(words[i].length)`\\n- Time complexity: $$O(nm)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```jsx\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar sumPrefixScores = function (words) {\\n  const indices = [];\\n  let n = words.length;\\n\\n  for (let i = 0; i < n; i++) indices.push(i);\\n  indices.sort((a, b) => words[a].localeCompare(words[b]));\\n\\n  let result = words.map(w => w.length)\\n\\n  for (let ri = 0; ri < n; ri++) {\\n    const rw = words[indices[ri]];\\n    let p = 0;\\n    for (let li = 0; li < ri; li++) {\\n      const lw = words[indices[li]];\\n      \\n      while (p < rw.length && rw[p] === lw[p]) p++;\\n      result[indices[ri]] += p;\\n      result[indices[li]] += p;\\n    }\\n  }\\n\\n  return result;\\n};\\n```\\n\\n# My Trie tree attempt:\\n```jsx\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar sumPrefixScores = function (words) {\\n  let trie = {\\n    value: 0,\\n    children: {},\\n  };\\n\\n  let n = words.length;\\n\\n  function addTrie(word) {\\n    let node = trie;\\n    let wn = word.length;\\n\\n    for (let i = 0; i < wn; i++) {\\n      const c = word[i];\\n      if (node.children[c]) node.children[c].value++;\\n      else\\n        node.children[c] = {\\n          value: 1,\\n          children: {},\\n        };\\n\\n      node = node.children[c];\\n    }\\n  }\\n\\n  function sumPathTrie(word) {\\n    let sum = 0;\\n\\n    let node = trie;\\n    let wn = word.length;\\n\\n    for (let i = 0; i < wn; i++) {\\n      const c = word[i];\\n\\n      sum += node.children[c].value;\\n      node = node.children[c];\\n    }\\n\\n    return sum;\\n  }\\n\\n  let result = [];\\n  for (let i = 0; i < n; i++) addTrie(words[i]);\\n  for (let i = 0; i < n; i++) result.push(sumPathTrie(words[i]));\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "String",
                    "Trie"
                ],
                "code": "```jsx\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar sumPrefixScores = function (words) {\\n  const indices = [];\\n  let n = words.length;\\n\\n  for (let i = 0; i < n; i++) indices.push(i);\\n  indices.sort((a, b) => words[a].localeCompare(words[b]));\\n\\n  let result = words.map(w => w.length)\\n\\n  for (let ri = 0; ri < n; ri++) {\\n    const rw = words[indices[ri]];\\n    let p = 0;\\n    for (let li = 0; li < ri; li++) {\\n      const lw = words[indices[li]];\\n      \\n      while (p < rw.length && rw[p] === lw[p]) p++;\\n      result[indices[ri]] += p;\\n      result[indices[li]] += p;\\n    }\\n  }\\n\\n  return result;\\n};\\n```\n```jsx\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar sumPrefixScores = function (words) {\\n  let trie = {\\n    value: 0,\\n    children: {},\\n  };\\n\\n  let n = words.length;\\n\\n  function addTrie(word) {\\n    let node = trie;\\n    let wn = word.length;\\n\\n    for (let i = 0; i < wn; i++) {\\n      const c = word[i];\\n      if (node.children[c]) node.children[c].value++;\\n      else\\n        node.children[c] = {\\n          value: 1,\\n          children: {},\\n        };\\n\\n      node = node.children[c];\\n    }\\n  }\\n\\n  function sumPathTrie(word) {\\n    let sum = 0;\\n\\n    let node = trie;\\n    let wn = word.length;\\n\\n    for (let i = 0; i < wn; i++) {\\n      const c = word[i];\\n\\n      sum += node.children[c].value;\\n      node = node.children[c];\\n    }\\n\\n    return sum;\\n  }\\n\\n  let result = [];\\n  for (let i = 0; i < n; i++) addTrie(words[i]);\\n  for (let i = 0; i < n; i++) result.push(sumPathTrie(words[i]));\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874807,
                "title": "trie-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Trie{\\n    Trie* child[26];\\n    int prefixCount ;\\n    public:\\n    Trie(){\\n        for(int i=0; i<26; i++){\\n            child[i] = nullptr;\\n        }\\n        prefixCount = 0;\\n    }\\n\\n    void insert(string& s){\\n        Trie* t = this;\\n        for(auto& c : s){\\n            int idx = c - \\'a\\';\\n            if(t->child[idx] == nullptr)\\n            t->child[idx] = new Trie;\\n            \\n            t = t->child[idx];\\n            t->prefixCount += 1;\\n        }\\n    }\\n    int countPrefix(string& s){\\n        Trie* t = this;\\n        int res = 0;\\n        for(auto& c : s){\\n            int idx = c - \\'a\\';\\n            if(t->child[idx] == nullptr)\\n            break;\\n            \\n            t = t->child[idx];\\n            res += t->prefixCount;\\n        }\\n        return res;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> res;\\n        Trie* root = new Trie();\\n        for(auto& word : words) root->insert(word);\\n\\n       for(auto& word : words){\\n           res.push_back(root->countPrefix(word));\\n       }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Trie{\\n    Trie* child[26];\\n    int prefixCount ;\\n    public:\\n    Trie(){\\n        for(int i=0; i<26; i++){\\n            child[i] = nullptr;\\n        }\\n        prefixCount = 0;\\n    }\\n\\n    void insert(string& s){\\n        Trie* t = this;\\n        for(auto& c : s){\\n            int idx = c - \\'a\\';\\n            if(t->child[idx] == nullptr)\\n            t->child[idx] = new Trie;\\n            \\n            t = t->child[idx];\\n            t->prefixCount += 1;\\n        }\\n    }\\n    int countPrefix(string& s){\\n        Trie* t = this;\\n        int res = 0;\\n        for(auto& c : s){\\n            int idx = c - \\'a\\';\\n            if(t->child[idx] == nullptr)\\n            break;\\n            \\n            t = t->child[idx];\\n            res += t->prefixCount;\\n        }\\n        return res;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> res;\\n        Trie* root = new Trie();\\n        for(auto& word : words) root->insert(word);\\n\\n       for(auto& word : words){\\n           res.push_back(root->countPrefix(word));\\n       }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869734,
                "title": "beats-93-unique-trie-solution-beginner-friendly",
                "content": "# Intuition\\n\\nThe intuition is to construct a prefix Trie where each character in the tree has a score associated with it. Each new node in the tree is initialized with score 1. If you try to add a new word to the tree, say ab, while abc is already in the tree, the scores on the nodes \"a\" and \"b\" are each increased by one. \\n\\nDo this for every word to construct the tree. Then, do a second pass where you find the word in the tree, and collect all the \"scores\" stored at each node. Thanks!! Please upvote.\\n\\n# Code\\n```\\nclass Solution {\\n    Node root;\\n    public int[] sumPrefixScores(String[] words) {\\n        root = new Node(\\'\\\\0\\');\\n\\n        for(String word: words){\\n            addWord(word);\\n        }\\n\\n        int[] ans = new int[words.length];\\n        \\n        for(int i=0; i<words.length; i++){\\n            ans[i] = getScore(words[i]);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    private int getScore(String word){\\n        Node temp = root;\\n\\n        int score = 0;\\n\\n        for(char x: word.toCharArray()){\\n             if(temp.children[x-\\'a\\']==null){\\n                break;\\n            }\\n            score+=temp.children[x-\\'a\\'].getNum();\\n            temp = temp.children[x-\\'a\\'];\\n        }\\n\\n        return score;\\n    }\\n\\n    private void addWord(String word){\\n        Node temp = root;\\n        for(char x: word.toCharArray()){\\n            if(temp.children[x-\\'a\\']==null){\\n                temp.children[x-\\'a\\'] = new Node(x);\\n            }\\n\\n            int prevnum = temp.children[x-\\'a\\'].getNum();\\n            temp.children[x-\\'a\\'].setNum(prevnum+1);\\n            temp = temp.children[x-\\'a\\'];\\n        }\\n    }\\n}\\n\\n\\nclass Node{\\n    char val;\\n    Node[] children;\\n    boolean isWord;\\n    int num;\\n\\n    public Node(char v){\\n        num = 0;\\n        val = v;\\n        children = new Node[26];\\n        isWord = false;\\n    }\\n\\n    public void setNum(int set){\\n        num = set;\\n    }\\n\\n    public int getNum(){\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    Node root;\\n    public int[] sumPrefixScores(String[] words) {\\n        root = new Node(\\'\\\\0\\');\\n\\n        for(String word: words){\\n            addWord(word);\\n        }\\n\\n        int[] ans = new int[words.length];\\n        \\n        for(int i=0; i<words.length; i++){\\n            ans[i] = getScore(words[i]);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    private int getScore(String word){\\n        Node temp = root;\\n\\n        int score = 0;\\n\\n        for(char x: word.toCharArray()){\\n             if(temp.children[x-\\'a\\']==null){\\n                break;\\n            }\\n            score+=temp.children[x-\\'a\\'].getNum();\\n            temp = temp.children[x-\\'a\\'];\\n        }\\n\\n        return score;\\n    }\\n\\n    private void addWord(String word){\\n        Node temp = root;\\n        for(char x: word.toCharArray()){\\n            if(temp.children[x-\\'a\\']==null){\\n                temp.children[x-\\'a\\'] = new Node(x);\\n            }\\n\\n            int prevnum = temp.children[x-\\'a\\'].getNum();\\n            temp.children[x-\\'a\\'].setNum(prevnum+1);\\n            temp = temp.children[x-\\'a\\'];\\n        }\\n    }\\n}\\n\\n\\nclass Node{\\n    char val;\\n    Node[] children;\\n    boolean isWord;\\n    int num;\\n\\n    public Node(char v){\\n        num = 0;\\n        val = v;\\n        children = new Node[26];\\n        isWord = false;\\n    }\\n\\n    public void setNum(int set){\\n        num = set;\\n    }\\n\\n    public int getNum(){\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857956,
                "title": "c-trie",
                "content": "# Complexity\\n\\n$1\\\\ <=\\\\ words.length\\\\ <=\\\\ n$\\n$1\\\\ <=\\\\ words[i].length\\\\ <=\\\\ m$\\n\\nTime complexity: $O(2 * n * m)$\\n\\nSpace complexity: $O(m * n * 26)$\\n\\n\\n# Code\\n```\\ntypedef struct Node Node;\\n\\nstruct Node {\\n    int count;\\n    Node* child[26];\\n};\\n\\nstatic inline void initNode(Node* node) {\\n    node->count = 0;\\n    for (int i = 0; i < 26; i++) \\n        node->child[i] = NULL;\\n}\\n\\nstatic void freeTree(Node* node) {\\n    if (node == NULL)\\n        return;\\n\\n    for (int i = 0; i < 26; i++) \\n        freeTree(node->child[i]);\\n    \\n    free(node);\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* sumPrefixScores(char ** words, int wordsSize, int* returnSize){\\n    Node* root = NULL;\\n    Node* curr = NULL;\\n    char* word = NULL;\\n    int* ret = NULL;\\n    int subAns = 0;\\n    int idx = 0;\\n    int wordSize = 0;\\n    \\n    *returnSize = wordsSize;\\n    ret = (int*) malloc(sizeof(int) * wordsSize);\\n    if (ret == NULL) {\\n        goto END;\\n    }\\n    memset(ret, 0, sizeof(int) * wordsSize);\\n\\n    root = (Node*) malloc(sizeof(Node));\\n    if (root == NULL) {\\n        goto END;\\n    }\\n    initNode(root);\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n        curr = root;\\n        word = words[i];\\n        wordSize = strlen(word);\\n\\n        for (int j = 0; j < wordSize; j++) {\\n            idx = word[j] - \\'a\\';\\n            \\n            if (curr->child[idx] == NULL) {\\n                curr->child[idx] = (Node*) malloc(sizeof(Node));\\n                if (curr->child[idx] == NULL) {\\n                    goto FREE;\\n                }\\n                initNode(curr->child[idx]);\\n            }\\n\\n            curr = curr->child[idx];\\n            curr->count += 1;\\n        }\\n    }\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n        subAns = 0;\\n        curr = root;\\n        word = words[i];\\n        wordSize = strlen(word);\\n\\n        for (int j = 0; j < wordSize; j++) {\\n            idx = word[j] - \\'a\\';\\n            curr = curr->child[idx];\\n            subAns += curr->count;\\n        }\\n\\n        ret[i] = subAns;\\n    }\\n\\nFREE:\\n    freeTree(root);\\nEND:\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\ntypedef struct Node Node;\\n\\nstruct Node {\\n    int count;\\n    Node* child[26];\\n};\\n\\nstatic inline void initNode(Node* node) {\\n    node->count = 0;\\n    for (int i = 0; i < 26; i++) \\n        node->child[i] = NULL;\\n}\\n\\nstatic void freeTree(Node* node) {\\n    if (node == NULL)\\n        return;\\n\\n    for (int i = 0; i < 26; i++) \\n        freeTree(node->child[i]);\\n    \\n    free(node);\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* sumPrefixScores(char ** words, int wordsSize, int* returnSize){\\n    Node* root = NULL;\\n    Node* curr = NULL;\\n    char* word = NULL;\\n    int* ret = NULL;\\n    int subAns = 0;\\n    int idx = 0;\\n    int wordSize = 0;\\n    \\n    *returnSize = wordsSize;\\n    ret = (int*) malloc(sizeof(int) * wordsSize);\\n    if (ret == NULL) {\\n        goto END;\\n    }\\n    memset(ret, 0, sizeof(int) * wordsSize);\\n\\n    root = (Node*) malloc(sizeof(Node));\\n    if (root == NULL) {\\n        goto END;\\n    }\\n    initNode(root);\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n        curr = root;\\n        word = words[i];\\n        wordSize = strlen(word);\\n\\n        for (int j = 0; j < wordSize; j++) {\\n            idx = word[j] - \\'a\\';\\n            \\n            if (curr->child[idx] == NULL) {\\n                curr->child[idx] = (Node*) malloc(sizeof(Node));\\n                if (curr->child[idx] == NULL) {\\n                    goto FREE;\\n                }\\n                initNode(curr->child[idx]);\\n            }\\n\\n            curr = curr->child[idx];\\n            curr->count += 1;\\n        }\\n    }\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n        subAns = 0;\\n        curr = root;\\n        word = words[i];\\n        wordSize = strlen(word);\\n\\n        for (int j = 0; j < wordSize; j++) {\\n            idx = word[j] - \\'a\\';\\n            curr = curr->child[idx];\\n            subAns += curr->count;\\n        }\\n\\n        ret[i] = subAns;\\n    }\\n\\nFREE:\\n    freeTree(root);\\nEND:\\n    return ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3857938,
                "title": "c-trie",
                "content": "# Complexity\\n\\n$1\\\\ <=\\\\ words.length\\\\ <=\\\\ n$\\n$1\\\\ <=\\\\ words[i].length\\\\ <=\\\\ m$\\n\\nTime complexity: $O(2 * n * m)$\\n\\nSpace complexity: $O(26^0 + 26^1 + 26^2 + ... + 26^{m}) = O(1 * (1 - 26^{m+1}) / (1 - 26)) = O(26^m)$\\n\\n\\n# Code\\n```\\ntypedef struct Node Node;\\n\\nstruct Node {\\n    int count;\\n    Node* child[26];\\n};\\n\\nstatic inline void initNode(Node* node) {\\n    node->count = 0;\\n    for (int i = 0; i < 26; i++) \\n        node->child[i] = NULL;\\n}\\n\\nstatic void freeTree(Node* node) {\\n    if (node == NULL)\\n        return;\\n\\n    for (int i = 0; i < 26; i++) \\n        freeTree(node->child[i]);\\n    \\n    free(node);\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* sumPrefixScores(char ** words, int wordsSize, int* returnSize){\\n    Node* root = NULL;\\n    Node* curr = NULL;\\n    char* word = NULL;\\n    int* ret = NULL;\\n    int subAns = 0;\\n    int idx = 0;\\n    int wordSize = 0;\\n    \\n    *returnSize = wordsSize;\\n    ret = (int*) malloc(sizeof(int) * wordsSize);\\n    if (ret == NULL) {\\n        goto END;\\n    }\\n    memset(ret, 0, sizeof(int) * wordsSize);\\n\\n    root = (Node*) malloc(sizeof(Node));\\n    if (root == NULL) {\\n        goto END;\\n    }\\n    initNode(root);\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n        curr = root;\\n        word = words[i];\\n        wordSize = strlen(word);\\n\\n        for (int j = 0; j < wordSize; j++) {\\n            idx = word[j] - \\'a\\';\\n            \\n            if (curr->child[idx] == NULL) {\\n                curr->child[idx] = (Node*) malloc(sizeof(Node));\\n                if (curr->child[idx] == NULL) {\\n                    goto FREE;\\n                }\\n                initNode(curr->child[idx]);\\n            }\\n\\n            curr = curr->child[idx];\\n            curr->count += 1;\\n        }\\n    }\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n        subAns = 0;\\n        curr = root;\\n        word = words[i];\\n        wordSize = strlen(word);\\n\\n        for (int j = 0; j < wordSize; j++) {\\n            idx = word[j] - \\'a\\';\\n            curr = curr->child[idx];\\n            subAns += curr->count;\\n        }\\n\\n        ret[i] = subAns;\\n    }\\n\\nFREE:\\n    freeTree(root);\\nEND:\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\ntypedef struct Node Node;\\n\\nstruct Node {\\n    int count;\\n    Node* child[26];\\n};\\n\\nstatic inline void initNode(Node* node) {\\n    node->count = 0;\\n    for (int i = 0; i < 26; i++) \\n        node->child[i] = NULL;\\n}\\n\\nstatic void freeTree(Node* node) {\\n    if (node == NULL)\\n        return;\\n\\n    for (int i = 0; i < 26; i++) \\n        freeTree(node->child[i]);\\n    \\n    free(node);\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* sumPrefixScores(char ** words, int wordsSize, int* returnSize){\\n    Node* root = NULL;\\n    Node* curr = NULL;\\n    char* word = NULL;\\n    int* ret = NULL;\\n    int subAns = 0;\\n    int idx = 0;\\n    int wordSize = 0;\\n    \\n    *returnSize = wordsSize;\\n    ret = (int*) malloc(sizeof(int) * wordsSize);\\n    if (ret == NULL) {\\n        goto END;\\n    }\\n    memset(ret, 0, sizeof(int) * wordsSize);\\n\\n    root = (Node*) malloc(sizeof(Node));\\n    if (root == NULL) {\\n        goto END;\\n    }\\n    initNode(root);\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n        curr = root;\\n        word = words[i];\\n        wordSize = strlen(word);\\n\\n        for (int j = 0; j < wordSize; j++) {\\n            idx = word[j] - \\'a\\';\\n            \\n            if (curr->child[idx] == NULL) {\\n                curr->child[idx] = (Node*) malloc(sizeof(Node));\\n                if (curr->child[idx] == NULL) {\\n                    goto FREE;\\n                }\\n                initNode(curr->child[idx]);\\n            }\\n\\n            curr = curr->child[idx];\\n            curr->count += 1;\\n        }\\n    }\\n\\n    for (int i = 0; i < wordsSize; i++) {\\n        subAns = 0;\\n        curr = root;\\n        word = words[i];\\n        wordSize = strlen(word);\\n\\n        for (int j = 0; j < wordSize; j++) {\\n            idx = word[j] - \\'a\\';\\n            curr = curr->child[idx];\\n            subAns += curr->count;\\n        }\\n\\n        ret[i] = subAns;\\n    }\\n\\nFREE:\\n    freeTree(root);\\nEND:\\n    return ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3843409,
                "title": "c-trie-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstruct Trie{\\n    Trie* childNode[26];\\n    int wordEndCnt;\\n    Trie()\\n    {\\n        for(int i=0;i<26;i++)childNode[i]=NULL;\\n        wordEndCnt=0;\\n    }\\n};\\n\\nvoid insert_key(Trie* root, string &key)\\n{\\n    Trie * currentNode=root;\\n    for(int i=0;i<key.size();i++)\\n    {\\n        if(currentNode->childNode[key[i]-\\'a\\']==NULL)\\n        {\\n            Trie* newNode=new Trie();\\n            currentNode->childNode[key[i]-\\'a\\']=newNode;\\n        }\\n        currentNode=currentNode->childNode[key[i]-\\'a\\'];\\n        currentNode->wordEndCnt++;\\n    }\\n}\\n\\n\\n\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie* root=new Trie();\\n        for(auto it:words)\\n        {\\n            insert_key(root,it);\\n        }\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            Trie* currentNode=root;\\n            string key=words[i];\\n            for(int j=0;j<key.size();j++)\\n            {\\n                currentNode=currentNode->childNode[key[j]-\\'a\\'];\\n                ans[i]+=currentNode->wordEndCnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstruct Trie{\\n    Trie* childNode[26];\\n    int wordEndCnt;\\n    Trie()\\n    {\\n        for(int i=0;i<26;i++)childNode[i]=NULL;\\n        wordEndCnt=0;\\n    }\\n};\\n\\nvoid insert_key(Trie* root, string &key)\\n{\\n    Trie * currentNode=root;\\n    for(int i=0;i<key.size();i++)\\n    {\\n        if(currentNode->childNode[key[i]-\\'a\\']==NULL)\\n        {\\n            Trie* newNode=new Trie();\\n            currentNode->childNode[key[i]-\\'a\\']=newNode;\\n        }\\n        currentNode=currentNode->childNode[key[i]-\\'a\\'];\\n        currentNode->wordEndCnt++;\\n    }\\n}\\n\\n\\n\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie* root=new Trie();\\n        for(auto it:words)\\n        {\\n            insert_key(root,it);\\n        }\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            Trie* currentNode=root;\\n            string key=words[i];\\n            for(int j=0;j<key.size();j++)\\n            {\\n                currentNode=currentNode->childNode[key[j]-\\'a\\'];\\n                ans[i]+=currentNode->wordEndCnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842220,
                "title": "python-trie",
                "content": "# Code\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.score = 0\\n        self.is_end_of_word = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node.children[char].score += 1\\n            node = node.children[char]\\n        node.is_end_of_word = True\\n\\n    def search(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                return False\\n            node = node.children[char]\\n        return node.is_end_of_word\\n\\n    def starts_with(self, prefix):\\n        node = self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return False\\n            node = node.children[char]\\n        return True\\n\\n    def score(self, word):\\n        ans = 0\\n        node = self.root\\n        for char in word:\\n            node = node.children[char]\\n            ans += node.score\\n        return ans\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n        for word in words: trie.insert(word)\\n        return [trie.score(word) for word in words]\\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.score = 0\\n        self.is_end_of_word = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node.children[char].score += 1\\n            node = node.children[char]\\n        node.is_end_of_word = True\\n\\n    def search(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                return False\\n            node = node.children[char]\\n        return node.is_end_of_word\\n\\n    def starts_with(self, prefix):\\n        node = self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return False\\n            node = node.children[char]\\n        return True\\n\\n    def score(self, word):\\n        ans = 0\\n        node = self.root\\n        for char in word:\\n            node = node.children[char]\\n            ans += node.score\\n        return ans\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n        for word in words: trie.insert(word)\\n        return [trie.score(word) for word in words]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816404,
                "title": "rust-prefix-tree",
                "content": "# Approach\\n\\nConstruct the prefix tree, then compute and cache the sizes of each subtree.\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n#[derive(Default, Debug, Clone)]\\npub struct Node {\\n    pub children: HashMap<char, Node>,\\n    pub epsilon: usize, // is it the end??\\n}\\n\\nimpl Node {\\n    pub fn push(&mut self, mut word: Vec<char>) {\\n        let c = if let Some(inner) = word.pop() {\\n            inner\\n        } else {\\n            self.epsilon += 1;\\n            return;\\n        }; // default case\\n\\n        let mut self_next = self.children.remove(&c).unwrap_or(Node::default());\\n        self_next.push(word);\\n\\n        self.children.insert(c, self_next);\\n    }\\n}\\n\\n#[derive(Default, Debug, Clone)]\\npub struct FrozenNode {\\n    pub children: HashMap<char, FrozenNode>,\\n    pub count: usize, // is it the end??\\n}\\n\\nimpl FrozenNode {\\n    pub fn from(root: Node) -> Self {\\n        let mut children = HashMap::new();\\n        let mut count = root.epsilon;\\n        for (c, root_next) in root.children.into_iter() {\\n            let self_next = Self::from(root_next);\\n            count += self_next.count;\\n            children.insert(c, self_next);\\n        }\\n        Self { children, count }\\n    }\\n\\n    pub fn count_sum(&self, mut word: Vec<char>) -> usize {\\n        let mut ret = self.count;\\n        \\n        let c = if let Some(inner) = word.pop() {\\n            inner\\n        } else { return ret; }; // default case\\n\\n        ret += self.children[&c].count_sum(word);\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    fn preproc(words: Vec<String>) -> Vec<Vec<char>> {\\n        words.into_iter()\\n            .map(|w| w.chars().rev().collect::<Vec<_>>())\\n            .collect::<Vec<_>>()\\n    }\\n\\n    pub fn sum_prefix_scores(words: Vec<String>) -> Vec<i32> {\\n        let words = Self::preproc(words);\\n\\n        let mut root = Node::default();\\n        for word in words.clone() {\\n            root.push(word);\\n        }\\n        let root = FrozenNode::from(root);\\n\\n        let mut ret = vec![];\\n        for word in words {\\n            let mut _ret = root.count_sum(word);\\n            _ret -= root.count;\\n            ret.push(_ret);\\n        }\\n\\n        ret.into_iter()\\n            .map(|e| e as i32)\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Trie"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n#[derive(Default, Debug, Clone)]\\npub struct Node {\\n    pub children: HashMap<char, Node>,\\n    pub epsilon: usize, // is it the end??\\n}\\n\\nimpl Node {\\n    pub fn push(&mut self, mut word: Vec<char>) {\\n        let c = if let Some(inner) = word.pop() {\\n            inner\\n        } else {\\n            self.epsilon += 1;\\n            return;\\n        }; // default case\\n\\n        let mut self_next = self.children.remove(&c).unwrap_or(Node::default());\\n        self_next.push(word);\\n\\n        self.children.insert(c, self_next);\\n    }\\n}\\n\\n#[derive(Default, Debug, Clone)]\\npub struct FrozenNode {\\n    pub children: HashMap<char, FrozenNode>,\\n    pub count: usize, // is it the end??\\n}\\n\\nimpl FrozenNode {\\n    pub fn from(root: Node) -> Self {\\n        let mut children = HashMap::new();\\n        let mut count = root.epsilon;\\n        for (c, root_next) in root.children.into_iter() {\\n            let self_next = Self::from(root_next);\\n            count += self_next.count;\\n            children.insert(c, self_next);\\n        }\\n        Self { children, count }\\n    }\\n\\n    pub fn count_sum(&self, mut word: Vec<char>) -> usize {\\n        let mut ret = self.count;\\n        \\n        let c = if let Some(inner) = word.pop() {\\n            inner\\n        } else { return ret; }; // default case\\n\\n        ret += self.children[&c].count_sum(word);\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    fn preproc(words: Vec<String>) -> Vec<Vec<char>> {\\n        words.into_iter()\\n            .map(|w| w.chars().rev().collect::<Vec<_>>())\\n            .collect::<Vec<_>>()\\n    }\\n\\n    pub fn sum_prefix_scores(words: Vec<String>) -> Vec<i32> {\\n        let words = Self::preproc(words);\\n\\n        let mut root = Node::default();\\n        for word in words.clone() {\\n            root.push(word);\\n        }\\n        let root = FrozenNode::from(root);\\n\\n        let mut ret = vec![];\\n        for word in words {\\n            let mut _ret = root.count_sum(word);\\n            _ret -= root.count;\\n            ret.push(_ret);\\n        }\\n\\n        ret.into_iter()\\n            .map(|e| e as i32)\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748542,
                "title": "using-prefix-trie",
                "content": "![Screenshot 2023-07-11 112424.png](https://assets.leetcode.com/users/images/724cd758-d1ea-4e94-ab48-94526997bdb3_1689054887.3779998.png)\\n\\n# Intuition\\nclassical prefix method\\n\\n# Approach\\n* build prefix trie from each word as a distinct batch of the trie\\n* node of the trie contains (child, ***leave -> index of the word***, count)\\n* again traverse the trie from top\\n* if we find leaf node, then just asign to the result[ith]\\n* finally return the result\\n\\n# Complexity\\n- Time complexity: 0(N) -> N = sum of the total length of each word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26 * 1000) -> O(26000) max\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThis solution accepted on ***Jul 11 2023***\\nMay be this solution will get ***MLE*** in future\\n\\n```python []\\nclass Node:\\n    def __init__(self):\\n        self.count = defaultdict(int) # alphabet: n\\n        self.child = defaultdict(Node) # alphabet: refer another node\\n        self.leaf = [] #[i1, i2,..] this is last char of the word\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        root = Node()\\n        for i, word in enumerate(words):\\n            cur = root\\n            for c in word:\\n                cur.count[c] += 1\\n                cur = cur.child[c]\\n            cur.leaf.append(i)\\n        \\n        res = [0] * len(words)\\n        def dfs(node, curSum):\\n            for l in node.leaf:\\n                res[l] = curSum\\n            for nei in node.child:\\n                curSum += node.count[nei]\\n                dfs(node.child[nei], curSum)\\n                curSum -= node.count[nei]\\n        dfs(root, 0)\\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Node:\\n    def __init__(self):\\n        self.count = defaultdict(int) # alphabet: n\\n        self.child = defaultdict(Node) # alphabet: refer another node\\n        self.leaf = [] #[i1, i2,..] this is last char of the word\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        root = Node()\\n        for i, word in enumerate(words):\\n            cur = root\\n            for c in word:\\n                cur.count[c] += 1\\n                cur = cur.child[c]\\n            cur.leaf.append(i)\\n        \\n        res = [0] * len(words)\\n        def dfs(node, curSum):\\n            for l in node.leaf:\\n                res[l] = curSum\\n            for nei in node.child:\\n                curSum += node.count[nei]\\n                dfs(node.child[nei], curSum)\\n                curSum -= node.count[nei]\\n        dfs(root, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742228,
                "title": "clear-solution-with-python",
                "content": "# Approach\\n- Build a trie represented with Python dict\\n- Search trie with depth-first-search passing accumulated words and scores\\n- During DFS update the result list\\n\\n# Code\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        res = []\\n        wdict = {} # reverse mapping (word -> list index)\\n        trie = {\\'cnt\\': 0}\\n        for i in range(len(words)):\\n            wdict[words[i]] = wdict.get(words[i], [])\\n            wdict[words[i]].append(i)\\n            self.addToTrie(trie, words[i])\\n            res.append(0)\\n\\n        self.dfs(trie, wdict, \\'\\', 0, res)\\n        return res\\n    \\n    def dfs(self, node: dict, wdict: dict, word: str, amount: int, res: List[int]) -> None:\\n        ids = wdict.get(word, [])\\n        for i in ids:\\n            res[i] = amount\\n        \\n        for k in node.keys():\\n            if k == \\'cnt\\':\\n                continue\\n            self.dfs(node[k], wdict, word + k, amount + node[k][\\'cnt\\'], res)\\n    \\n    def addToTrie(self, trie: dict, word: str) -> None:\\n        node = trie\\n\\n        for ch in word:\\n            nxt = node.get(ch, {\\'cnt\\': 0})\\n            node[\\'cnt\\'] += 1\\n            node[ch] = nxt\\n            node = nxt\\n\\n        node[\\'cnt\\'] += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        res = []\\n        wdict = {} # reverse mapping (word -> list index)\\n        trie = {\\'cnt\\': 0}\\n        for i in range(len(words)):\\n            wdict[words[i]] = wdict.get(words[i], [])\\n            wdict[words[i]].append(i)\\n            self.addToTrie(trie, words[i])\\n            res.append(0)\\n\\n        self.dfs(trie, wdict, \\'\\', 0, res)\\n        return res\\n    \\n    def dfs(self, node: dict, wdict: dict, word: str, amount: int, res: List[int]) -> None:\\n        ids = wdict.get(word, [])\\n        for i in ids:\\n            res[i] = amount\\n        \\n        for k in node.keys():\\n            if k == \\'cnt\\':\\n                continue\\n            self.dfs(node[k], wdict, word + k, amount + node[k][\\'cnt\\'], res)\\n    \\n    def addToTrie(self, trie: dict, word: str) -> None:\\n        node = trie\\n\\n        for ch in word:\\n            nxt = node.get(ch, {\\'cnt\\': 0})\\n            node[\\'cnt\\'] += 1\\n            node[ch] = nxt\\n            node = nxt\\n\\n        node[\\'cnt\\'] += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738120,
                "title": "c-simple-trie-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        Node* links[26];\\n        int pcnt=0;\\n        bool containskey(char ch){\\n            return (links[ch-\\'a\\']!=NULL);\\n        }\\n        Node* get(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n        void put(char ch,Node *node){\\n            links[ch-\\'a\\']=node;\\n        }\\n        void increaseprefix(){\\n            pcnt++;\\n        }\\n        int getprefix(){\\n            return pcnt;\\n        }\\n    };\\n    class Trie{\\n        private:\\n        Node* root;\\n        public:\\n        Trie(){\\n            root=new Node();\\n        }\\n        void insert(string str){\\n            Node* node=root;\\n            for(int i=0;i<str.size();i++){\\n                if(node->containskey(str[i])==false) node->put(str[i],new Node());\\n                node=node->get(str[i]);\\n                node->increaseprefix();\\n            }\\n        }\\n        int solve(string str){\\n            Node* node=root;\\n            int ans=0;\\n            for(int i=0;i<str.size();i++){\\n                node=node->get(str[i]);\\n                ans+=node->getprefix();\\n            }\\n            return ans;\\n        }\\n    };\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie trie;\\n        for(auto it:words) trie.insert(it);\\n        vector<int> ans;\\n        for(auto it:words){\\n            int temp=trie.solve(it);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        Node* links[26];\\n        int pcnt=0;\\n        bool containskey(char ch){\\n            return (links[ch-\\'a\\']!=NULL);\\n        }\\n        Node* get(char ch){\\n            return links[ch-\\'a\\'];\\n        }\\n        void put(char ch,Node *node){\\n            links[ch-\\'a\\']=node;\\n        }\\n        void increaseprefix(){\\n            pcnt++;\\n        }\\n        int getprefix(){\\n            return pcnt;\\n        }\\n    };\\n    class Trie{\\n        private:\\n        Node* root;\\n        public:\\n        Trie(){\\n            root=new Node();\\n        }\\n        void insert(string str){\\n            Node* node=root;\\n            for(int i=0;i<str.size();i++){\\n                if(node->containskey(str[i])==false) node->put(str[i],new Node());\\n                node=node->get(str[i]);\\n                node->increaseprefix();\\n            }\\n        }\\n        int solve(string str){\\n            Node* node=root;\\n            int ans=0;\\n            for(int i=0;i<str.size();i++){\\n                node=node->get(str[i]);\\n                ans+=node->getprefix();\\n            }\\n            return ans;\\n        }\\n    };\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie trie;\\n        for(auto it:words) trie.insert(it);\\n        vector<int> ans;\\n        for(auto it:words){\\n            int temp=trie.solve(it);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736130,
                "title": "ez",
                "content": "\\n\\n# Code\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child=dict()\\n    def insert(self,words):\\n        current=self.child\\n        for i in words :\\n            if i not in current:\\n                current[i]={}\\n            current=current[i]\\n            current[\"#\"]=1 if \\'#\\' not in current else current[\\'#\\']+1\\n    def search(self,words)->int:\\n        current=self.child\\n        ctr=0\\n        for i in words:\\n            current=current[i]\\n            ctr+=current[\\'#\\']\\n        return ctr\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        obj=Trie()\\n        for i in words:\\n            obj.insert(i)\\n        for i in range(len(words)):\\n            words[i]=obj.search(words[i])\\n        return words\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.child=dict()\\n    def insert(self,words):\\n        current=self.child\\n        for i in words :\\n            if i not in current:\\n                current[i]={}\\n            current=current[i]\\n            current[\"#\"]=1 if \\'#\\' not in current else current[\\'#\\']+1\\n    def search(self,words)->int:\\n        current=self.child\\n        ctr=0\\n        for i in words:\\n            current=current[i]\\n            ctr+=current[\\'#\\']\\n        return ctr\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        obj=Trie()\\n        for i in words:\\n            obj.insert(i)\\n        for i in range(len(words)):\\n            words[i]=obj.search(words[i])\\n        return words\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668528,
                "title": "easy-simple-approach-similar-to-countwordsstartingwith-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n    Node *links[26];\\n    int cp = 0;\\n    bool containskey(char ch){\\n        return links[ch-\\'a\\'] != NULL;\\n    }\\n    void put( char ch, Node* node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    void increasecnt(){\\n        cp++;\\n    }\\n    int givecount(){\\n        return cp;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n\\n    }\\n    void insert(string word){\\n        Node* node = root;\\n        for(int i =0;i<word.length();i++){\\n            if(!node->containskey(word[i])){\\n                node->put(word[i],new Node());\\n                \\n            }\\n            node = node->get(word[i]);\\n            node->increasecnt();   \\n        }\\n    }\\n    int getmax(string word){\\n        Node* node = root;\\n        int ans = 0;\\n        for(int i =0;i<word.length();i++){\\n            if(node->containskey(word[i])){\\n                node = node->get(word[i]);\\n                ans += node->givecount();\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie trie;\\n        for(auto &it:words){\\n            trie.insert(it);\\n        }\\n        vector<int>Ans(words.size(),0);\\n        int index = 0;\\n        for( auto &it:words){\\n            Ans[index] = trie.getmax(it);\\n            index++;\\n        }\\n        return Ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node *links[26];\\n    int cp = 0;\\n    bool containskey(char ch){\\n        return links[ch-\\'a\\'] != NULL;\\n    }\\n    void put( char ch, Node* node){\\n        links[ch-\\'a\\'] = node;\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    void increasecnt(){\\n        cp++;\\n    }\\n    int givecount(){\\n        return cp;\\n    }\\n};\\nclass Trie{\\nprivate:\\n    Node* root;\\npublic:\\n    Trie(){\\n        root = new Node();\\n\\n    }\\n    void insert(string word){\\n        Node* node = root;\\n        for(int i =0;i<word.length();i++){\\n            if(!node->containskey(word[i])){\\n                node->put(word[i],new Node());\\n                \\n            }\\n            node = node->get(word[i]);\\n            node->increasecnt();   \\n        }\\n    }\\n    int getmax(string word){\\n        Node* node = root;\\n        int ans = 0;\\n        for(int i =0;i<word.length();i++){\\n            if(node->containskey(word[i])){\\n                node = node->get(word[i]);\\n                ans += node->givecount();\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie trie;\\n        for(auto &it:words){\\n            trie.insert(it);\\n        }\\n        vector<int>Ans(words.size(),0);\\n        int index = 0;\\n        for( auto &it:words){\\n            Ans[index] = trie.getmax(it);\\n            index++;\\n        }\\n        return Ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640335,
                "title": "simple-c-trie-solution",
                "content": "# Intuition\\ninsert every charcter of string in trie by incrementing sw (start with ) of Node. it gives the count of every prefix\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nalmost O(n^2) complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Node{\\n  Node * links[26];\\n  int flag=0,sw=0;\\n  bool containkey(char ch){\\n    if(links[ch-97]==NULL)return false;\\n    return true;\\n  }\\n  void put(char ch,Node *node){\\n      links[ch-97]=node;\\n  }\\n  Node *get(char ch){\\n      return links[ch-97];\\n  }\\n  void inc(){\\n      sw++;\\n  }\\n  int end(){\\n      return sw;\\n  }\\n \\n};\\nclass Trie {\\npublic:\\nNode *root;\\n    Trie() {\\n        root=new Node();\\n    }\\n    \\n    void add(string s) {\\n        Node *node=root;\\n     for(int i=0;i<s.size();i++){\\n         if(!node->containkey(s[i])){\\n             node->put(s[i],new Node());\\n         }\\n         node=node->get(s[i]);\\n         node->inc();\\n        \\n\\n     }\\n      \\n    }\\n    int f(string s){\\n        Node *node=root;\\n        int c=0;\\n        for(int i=0;i<s.size();i++){\\n          node=node->get(s[i]);\\n          c+=node->end();\\n        }\\n        return c;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n       Trie trie;\\n       for(auto &it:words){\\n           trie.add(it);\\n       } \\n       vector<int>a;\\n       for(auto &it:words){\\n           int c=trie.f(it);\\n           a.push_back(c);\\n       }\\n       return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n  Node * links[26];\\n  int flag=0,sw=0;\\n  bool containkey(char ch){\\n    if(links[ch-97]==NULL)return false;\\n    return true;\\n  }\\n  void put(char ch,Node *node){\\n      links[ch-97]=node;\\n  }\\n  Node *get(char ch){\\n      return links[ch-97];\\n  }\\n  void inc(){\\n      sw++;\\n  }\\n  int end(){\\n      return sw;\\n  }\\n \\n};\\nclass Trie {\\npublic:\\nNode *root;\\n    Trie() {\\n        root=new Node();\\n    }\\n    \\n    void add(string s) {\\n        Node *node=root;\\n     for(int i=0;i<s.size();i++){\\n         if(!node->containkey(s[i])){\\n             node->put(s[i],new Node());\\n         }\\n         node=node->get(s[i]);\\n         node->inc();\\n        \\n\\n     }\\n      \\n    }\\n    int f(string s){\\n        Node *node=root;\\n        int c=0;\\n        for(int i=0;i<s.size();i++){\\n          node=node->get(s[i]);\\n          c+=node->end();\\n        }\\n        return c;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n       Trie trie;\\n       for(auto &it:words){\\n           trie.add(it);\\n       } \\n       vector<int>a;\\n       for(auto &it:words){\\n           int c=trie.f(it);\\n           a.push_back(c);\\n       }\\n       return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636903,
                "title": "java-trie-solution",
                "content": "```\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        Trie root = new Trie(\\' \\');\\n        for (String word: words)insert(root, word, 0);\\n        int[]res = new int[words.length];\\n        for (int i=0;i<words.length;i++) getScores(root, words[i], 0, i, res);\\n        return res;\\n    }\\n\\n    public void insert(Trie root, String word, int j){\\n        if (j<word.length()){\\n            char c = word.charAt(j);\\n            root.children.putIfAbsent(c, new Trie(c));\\n            root.children.get(c).score++;\\n            insert(root.children.get(c), word, j+1);\\n        }\\n    }\\n    \\n    public void getScores(Trie root, String word, int charInd, int i, int[]res){\\n        if (charInd<word.length()){\\n            char c = word.charAt(charInd);\\n            res[i]+=root.children.get(c).score;\\n            getScores(root.children.get(c), word, charInd+1, i, res);\\n        }\\n    }\\n\\n}\\n\\n\\nclass Trie{\\n    char c;\\n    int score;\\n    Map<Character, Trie>children;\\n    \\n    \\n    public Trie(char x){\\n        this.c = x;\\n        score = 0;\\n        children = new HashMap<>();\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n        Trie root = new Trie(\\' \\');\\n        for (String word: words)insert(root, word, 0);\\n        int[]res = new int[words.length];\\n        for (int i=0;i<words.length;i++) getScores(root, words[i], 0, i, res);\\n        return res;\\n    }\\n\\n    public void insert(Trie root, String word, int j){\\n        if (j<word.length()){\\n            char c = word.charAt(j);\\n            root.children.putIfAbsent(c, new Trie(c));\\n            root.children.get(c).score++;\\n            insert(root.children.get(c), word, j+1);\\n        }\\n    }\\n    \\n    public void getScores(Trie root, String word, int charInd, int i, int[]res){\\n        if (charInd<word.length()){\\n            char c = word.charAt(charInd);\\n            res[i]+=root.children.get(c).score;\\n            getScores(root.children.get(c), word, charInd+1, i, res);\\n        }\\n    }\\n\\n}\\n\\n\\nclass Trie{\\n    char c;\\n    int score;\\n    Map<Character, Trie>children;\\n    \\n    \\n    public Trie(char x){\\n        this.c = x;\\n        score = 0;\\n        children = new HashMap<>();\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558325,
                "title": "python-3-binary-ish",
                "content": "# Explanation\\nFor all pairs of words, check how many characters match from the start, that amount is the score itself. Add them up and obtain the score for all words.\\n\\n# Code\\n```code\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        # Count until how many characters two strings match\\n        # Score will be that amount\\n\\n        # Pseudo-Binary Search\\n        def findMatching(original, check, index=0, initial=True):\\n            idx = index\\n            start = 0\\n            end = len(original)\\n\\n            if initial:\\n                # snip snip (matches the size of the two words)\\n                if len(original) != len(check):\\n                    maxsize = min(len(original), len(check))\\n                    original = original[:maxsize]\\n                    check = check[:maxsize]\\n                if original == check:\\n                    return len(original)\\n                if original[0] != check[0]:\\n                    return 0\\n\\n            if len(original) == len(check) == 1:\\n                return idx + 1\\n\\n            mid = (start + end) // 2\\n\\n            if original[start:mid+1] == check[start:mid+1]:\\n                idx += mid\\n                return findMatching(original[mid:end], check[mid:end], idx, False)\\n            else:\\n                return findMatching(original[:mid], check[:mid], idx, False)\\n\\n        # All words have an initial score of 0\\n        answer = [0] * len(words)\\n        \\n        for i in range(len(words)):\\n            word = words[i]\\n            for j in range(i, len(words)):\\n                # Skips over checking itself\\n                if i == j:\\n                    answer[i] += len(word)\\n                    continue\\n\\n                match = words[j]\\n                matching = findMatching(word, match)\\n\\n                # Adds to the score for both, removing repetition\\n                answer[i] += matching\\n                answer[j] += matching\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```code\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        # Count until how many characters two strings match\\n        # Score will be that amount\\n\\n        # Pseudo-Binary Search\\n        def findMatching(original, check, index=0, initial=True):\\n            idx = index\\n            start = 0\\n            end = len(original)\\n\\n            if initial:\\n                # snip snip (matches the size of the two words)\\n                if len(original) != len(check):\\n                    maxsize = min(len(original), len(check))\\n                    original = original[:maxsize]\\n                    check = check[:maxsize]\\n                if original == check:\\n                    return len(original)\\n                if original[0] != check[0]:\\n                    return 0\\n\\n            if len(original) == len(check) == 1:\\n                return idx + 1\\n\\n            mid = (start + end) // 2\\n\\n            if original[start:mid+1] == check[start:mid+1]:\\n                idx += mid\\n                return findMatching(original[mid:end], check[mid:end], idx, False)\\n            else:\\n                return findMatching(original[:mid], check[:mid], idx, False)\\n\\n        # All words have an initial score of 0\\n        answer = [0] * len(words)\\n        \\n        for i in range(len(words)):\\n            word = words[i]\\n            for j in range(i, len(words)):\\n                # Skips over checking itself\\n                if i == j:\\n                    answer[i] += len(word)\\n                    continue\\n\\n                match = words[j]\\n                matching = findMatching(word, match)\\n\\n                # Adds to the score for both, removing repetition\\n                answer[i] += matching\\n                answer[j] += matching\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555565,
                "title": "just-tried-with-trie",
                "content": "# Intuition - \\n- Construct trie for the given words and maintain the frequency\\n  of prefixes\\n- starting processing each word and find their score\\n- score of word =  sum of frequency of that prefixes of that word\\n\\n# Time Complexity -\\n- N = number of Words & M = Average Length Of a Word\\n- Trie Construction - O(N*M)\\n- processing - O(N*M)\\n\\n\\n# Code\\n```\\nstruct Node{\\n  Node* links[26];\\n  int prefixCount = 0;\\n};\\n\\nclass Trie{\\nprivate:\\n  Node *root;\\npublic:\\n  Trie(){\\n    root = new Node();\\n  }\\n\\n  void insert(string word){\\n    Node *node = root;\\n    for(char ch : word){\\n       if(node->links[ch-\\'a\\'] == NULL) node->links[ch-\\'a\\'] = new Node();\\n       node = node->links[ch-\\'a\\'];\\n       node->prefixCount++;\\n    }\\n  }\\n\\n  int prefixScore(string word){\\n    Node *node = root;\\n    int currPrefixScore = 0;\\n    for(char ch : word){\\n      if(node->links[ch-\\'a\\'] == NULL) return currPrefixScore;\\n      node = node->links[ch-\\'a\\'];\\n      currPrefixScore += node->prefixCount;\\n    }\\n    return currPrefixScore;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n      Trie trie;\\n      for(string &word : words) trie.insert(word);\\n      vector<int> answer;\\n      for(string &word : words) answer.push_back(trie.prefixScore(word));\\n      return answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node{\\n  Node* links[26];\\n  int prefixCount = 0;\\n};\\n\\nclass Trie{\\nprivate:\\n  Node *root;\\npublic:\\n  Trie(){\\n    root = new Node();\\n  }\\n\\n  void insert(string word){\\n    Node *node = root;\\n    for(char ch : word){\\n       if(node->links[ch-\\'a\\'] == NULL) node->links[ch-\\'a\\'] = new Node();\\n       node = node->links[ch-\\'a\\'];\\n       node->prefixCount++;\\n    }\\n  }\\n\\n  int prefixScore(string word){\\n    Node *node = root;\\n    int currPrefixScore = 0;\\n    for(char ch : word){\\n      if(node->links[ch-\\'a\\'] == NULL) return currPrefixScore;\\n      node = node->links[ch-\\'a\\'];\\n      currPrefixScore += node->prefixCount;\\n    }\\n    return currPrefixScore;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n      Trie trie;\\n      for(string &word : words) trie.insert(word);\\n      vector<int> answer;\\n      for(string &word : words) answer.push_back(trie.prefixScore(word));\\n      return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517032,
                "title": "trie-c",
                "content": "\\n\\n# Code\\n```\\nstruct Node {\\n  Node * links[26];\\n  int cntPrefix = 0;\\n  void put(char ch, Node * node) {\\n    links[ch - \\'a\\'] = node;\\n  }\\n\\n};\\n\\n\\nclass Trie {\\n   \\n\\n  public:\\n   Node * root;\\n    Trie() {\\n      root = new Node();\\n    }\\n\\n  void insert(string word) {\\n    Node * node = root;\\n    for (int i = 0; i < word.length(); i++) {\\n      if (!node -> links[word[i]-\\'a\\']) {\\n        node -> put(word[i], new Node());\\n      }\\n      node = node -> links[word[i] - \\'a\\'];\\n      (node ->cntPrefix)++ ;\\n    }\\n  }\\n\\n\\n  int countWordsStartingWith(string & word)\\n   {\\n    Node * node = root;\\n    for (int i = 0; i < word.length(); i++)\\n     {\\n      if (node -> links[word[i]-\\'a\\'])\\n      {\\n        node = node -> links[word[i] - \\'a\\'];\\n      } \\n      else \\n      {\\n        return 0;\\n      }\\n    }\\n    return node ->cntPrefix;\\n  }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> ans;\\n        Trie obj;\\n        for (string s:words)\\n            obj.insert(s);\\n        for (int i=0;i<words.size();i++)\\n        {\\n            \\n            string temp=\"\";\\n            Node *node=obj.root;\\n            int sum=0;\\n            for (int j=0;j<words[i].size();j++)\\n            {\\n               sum+=node->links[words[i][j]-\\'a\\']->cntPrefix;\\n               node=node->links[words[i][j]-\\'a\\'];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Node {\\n  Node * links[26];\\n  int cntPrefix = 0;\\n  void put(char ch, Node * node) {\\n    links[ch - \\'a\\'] = node;\\n  }\\n\\n};\\n\\n\\nclass Trie {\\n   \\n\\n  public:\\n   Node * root;\\n    Trie() {\\n      root = new Node();\\n    }\\n\\n  void insert(string word) {\\n    Node * node = root;\\n    for (int i = 0; i < word.length(); i++) {\\n      if (!node -> links[word[i]-\\'a\\']) {\\n        node -> put(word[i], new Node());\\n      }\\n      node = node -> links[word[i] - \\'a\\'];\\n      (node ->cntPrefix)++ ;\\n    }\\n  }\\n\\n\\n  int countWordsStartingWith(string & word)\\n   {\\n    Node * node = root;\\n    for (int i = 0; i < word.length(); i++)\\n     {\\n      if (node -> links[word[i]-\\'a\\'])\\n      {\\n        node = node -> links[word[i] - \\'a\\'];\\n      } \\n      else \\n      {\\n        return 0;\\n      }\\n    }\\n    return node ->cntPrefix;\\n  }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        vector<int> ans;\\n        Trie obj;\\n        for (string s:words)\\n            obj.insert(s);\\n        for (int i=0;i<words.size();i++)\\n        {\\n            \\n            string temp=\"\";\\n            Node *node=obj.root;\\n            int sum=0;\\n            for (int j=0;j<words[i].size();j++)\\n            {\\n               sum+=node->links[words[i][j]-\\'a\\']->cntPrefix;\\n               node=node->links[words[i][j]-\\'a\\'];\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507371,
                "title": "trie-using-constructor-function-javascript-needs-help",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried to solve the problem using trie and using construtor function conecpt. But it\\'s getting following error: \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n\\nThough i\\'m not able to understand why is it so? It\\'s kind of similar to using normal object with count. Can anyone please help with out that why i was facing this issue? \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nfunction TrieNode(ch) {\\n    this.char = ch;\\n    this.children = new Map(); // it should point to \\n    this.count = 0;\\n}\\n\\nvar sumPrefixScores = function(words) {\\n    const count = (new Array(words.length)).fill(0);\\n    const root = new TrieNode(null);        \\n\\n    const insertIntoTrie = (word, wordIndex) => {\\n        let node = root;\\n\\n        Array.from(word).forEach(ch=> {\\n            if(!node.children.get(ch)) node.children.set(ch, new TrieNode(ch));\\n            node = node.children.get(ch);\\n            node.count++;\\n            // node.wordsIndex.push(wordIndex);\\n        });\\n    };\\n\\n    words.forEach(insertIntoTrie);\\n\\n    words.forEach((word, index)=> {\\n        let node = root;\\n        Array.from(word).forEach(ch=> {\\n            node = node.children.get(ch);\\n            count[index] += node.count;\\n        });\\n    });\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nfunction TrieNode(ch) {\\n    this.char = ch;\\n    this.children = new Map(); // it should point to \\n    this.count = 0;\\n}\\n\\nvar sumPrefixScores = function(words) {\\n    const count = (new Array(words.length)).fill(0);\\n    const root = new TrieNode(null);        \\n\\n    const insertIntoTrie = (word, wordIndex) => {\\n        let node = root;\\n\\n        Array.from(word).forEach(ch=> {\\n            if(!node.children.get(ch)) node.children.set(ch, new TrieNode(ch));\\n            node = node.children.get(ch);\\n            node.count++;\\n            // node.wordsIndex.push(wordIndex);\\n        });\\n    };\\n\\n    words.forEach(insertIntoTrie);\\n\\n    words.forEach((word, index)=> {\\n        let node = root;\\n        Array.from(word).forEach(ch=> {\\n            node = node.children.get(ch);\\n            count[index] += node.count;\\n        });\\n    });\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3507370,
                "title": "trie-using-constructor-function-javascript-needs-help",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI tried to solve the problem using trie and using construtor function conecpt. But it\\'s getting following error: \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\\n\\nThough i\\'m not able to understand why is it so? It\\'s kind of similar to using normal object with count. Can anyone please help with out that why i was facing this issue? \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nfunction TrieNode(ch) {\\n    this.char = ch;\\n    this.children = new Map(); // it should point to \\n    this.count = 0;\\n}\\n\\nvar sumPrefixScores = function(words) {\\n    const count = (new Array(words.length)).fill(0);\\n    const root = new TrieNode(null);        \\n\\n    const insertIntoTrie = (word, wordIndex) => {\\n        let node = root;\\n\\n        Array.from(word).forEach(ch=> {\\n            if(!node.children.get(ch)) node.children.set(ch, new TrieNode(ch));\\n            node = node.children.get(ch);\\n            node.count++;\\n            // node.wordsIndex.push(wordIndex);\\n        });\\n    };\\n\\n    words.forEach(insertIntoTrie);\\n\\n    words.forEach((word, index)=> {\\n        let node = root;\\n        Array.from(word).forEach(ch=> {\\n            node = node.children.get(ch);\\n            count[index] += node.count;\\n        });\\n    });\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nfunction TrieNode(ch) {\\n    this.char = ch;\\n    this.children = new Map(); // it should point to \\n    this.count = 0;\\n}\\n\\nvar sumPrefixScores = function(words) {\\n    const count = (new Array(words.length)).fill(0);\\n    const root = new TrieNode(null);        \\n\\n    const insertIntoTrie = (word, wordIndex) => {\\n        let node = root;\\n\\n        Array.from(word).forEach(ch=> {\\n            if(!node.children.get(ch)) node.children.set(ch, new TrieNode(ch));\\n            node = node.children.get(ch);\\n            node.count++;\\n            // node.wordsIndex.push(wordIndex);\\n        });\\n    };\\n\\n    words.forEach(insertIntoTrie);\\n\\n    words.forEach((word, index)=> {\\n        let node = root;\\n        Array.from(word).forEach(ch=> {\\n            node = node.children.get(ch);\\n            count[index] += node.count;\\n        });\\n    });\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481300,
                "title": "this-solution-is-also-o-n-k-but-it-s-giving-tle-can-anyone-tell-why",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nn = no of words\\nk= length of word\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n*k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(n*k)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n\\n        int n = words.length;\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        int []arr = new int[n];\\n\\n        String s = \"\";\\n\\n        for(int w = 0; w<n; w++){\\n\\n            String word = words[w];\\n\\n            for(int i=0; i<word.length(); i++){\\n\\n                s = s + word.charAt(i);\\n\\n                map.put(s, map.getOrDefault(s, 0)+1);\\n            }\\n\\n            s = \"\";\\n\\n        }\\n\\n        for(int w = 0; w<n; w++){\\n\\n            String word = words[w];\\n            int sum = 0;\\n            for(int i=0; i<word.length(); i++){\\n\\n                s = s + word.charAt(i);\\n                int val = map.get(s);\\n                sum = sum + val;\\n            }\\n\\n            arr[w] = arr[w] + sum;\\n\\n            s = \"\";\\n\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sumPrefixScores(String[] words) {\\n\\n        int n = words.length;\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        int []arr = new int[n];\\n\\n        String s = \"\";\\n\\n        for(int w = 0; w<n; w++){\\n\\n            String word = words[w];\\n\\n            for(int i=0; i<word.length(); i++){\\n\\n                s = s + word.charAt(i);\\n\\n                map.put(s, map.getOrDefault(s, 0)+1);\\n            }\\n\\n            s = \"\";\\n\\n        }\\n\\n        for(int w = 0; w<n; w++){\\n\\n            String word = words[w];\\n            int sum = 0;\\n            for(int i=0; i<word.length(); i++){\\n\\n                s = s + word.charAt(i);\\n                int val = map.get(s);\\n                sum = sum + val;\\n            }\\n\\n            arr[w] = arr[w] + sum;\\n\\n            s = \"\";\\n\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477309,
                "title": "trie-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstruct Node{\\n   Node* links[26];\\n   int cp=0;\\n   bool isConatins(char ch)\\n   {\\n    return links[ch-\\'a\\'];\\n   }\\n   void put(char ch,Node* node)\\n   {\\n      links[ch-\\'a\\']=node;\\n   }\\n   Node* get(char ch)\\n   {\\n       return links[ch-\\'a\\'];\\n   }\\n   void incCp()\\n   {\\n       cp++;\\n   }\\n   int getCp()\\n   {\\n       return cp;\\n   }\\n};\\nclass Trie{\\n    public:\\n    Node* root;\\n    Trie()\\n    {\\n      root=new Node();\\n    }\\n    void insert(string &str)\\n    {\\n        Node* node=root;\\n        for (int i=0;i<str.size();i++)\\n        {\\n            if (!node->isConatins(str[i]))\\n            {\\n                node->put(str[i],new Node());\\n            }\\n            node=node->get(str[i]);\\n            node->incCp();\\n        }\\n    }\\n    int getScore(string & str)\\n    {\\n        Node* node=root;\\n        int ans=0;\\n        for (int i=0;i<str.size();i++)\\n        {\\n            node=node->get(str[i]);\\n            ans+=node->getCp();\\n        }\\n        return ans;\\n    }\\n};\\n    vector<int> sumPrefixScores(vector<string>& words) \\n    {\\n       vector<int>ans;\\n       Trie * trie=new Trie();\\n       for (int i=0;i<words.size();i++)\\n       {\\n         trie->insert(words[i]);\\n       }\\n       for (auto & it:words)\\n       {\\n          ans.push_back(trie->getScore(it));\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstruct Node{\\n   Node* links[26];\\n   int cp=0;\\n   bool isConatins(char ch)\\n   {\\n    return links[ch-\\'a\\'];\\n   }\\n   void put(char ch,Node* node)\\n   {\\n      links[ch-\\'a\\']=node;\\n   }\\n   Node* get(char ch)\\n   {\\n       return links[ch-\\'a\\'];\\n   }\\n   void incCp()\\n   {\\n       cp++;\\n   }\\n   int getCp()\\n   {\\n       return cp;\\n   }\\n};\\nclass Trie{\\n    public:\\n    Node* root;\\n    Trie()\\n    {\\n      root=new Node();\\n    }\\n    void insert(string &str)\\n    {\\n        Node* node=root;\\n        for (int i=0;i<str.size();i++)\\n        {\\n            if (!node->isConatins(str[i]))\\n            {\\n                node->put(str[i],new Node());\\n            }\\n            node=node->get(str[i]);\\n            node->incCp();\\n        }\\n    }\\n    int getScore(string & str)\\n    {\\n        Node* node=root;\\n        int ans=0;\\n        for (int i=0;i<str.size();i++)\\n        {\\n            node=node->get(str[i]);\\n            ans+=node->getCp();\\n        }\\n        return ans;\\n    }\\n};\\n    vector<int> sumPrefixScores(vector<string>& words) \\n    {\\n       vector<int>ans;\\n       Trie * trie=new Trie();\\n       for (int i=0;i<words.size();i++)\\n       {\\n         trie->insert(words[i]);\\n       }\\n       for (auto & it:words)\\n       {\\n          ans.push_back(trie->getScore(it));\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456271,
                "title": "trie-runtime-654-ms-beats-36-84-clear-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Node  root = new Node();\\n    int sum = 0;    \\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        for(String s : words){\\n            root = put(root, s, 0);\\n        }\\n\\n        int[] res = new int[words.length];\\n        int i = 0;\\n        for(String s : words){\\n            sum = 0;\\n            dfs(root, s, 0);\\n            res[i++] = sum - root.cnt;\\n        }\\n\\n        return res;\\n    }\\n    public void dfs(Node x, String s, int i){\\n        sum += x.cnt;\\n        if(s.length() == i) return;\\n        dfs(x.next[s.charAt(i) - \\'a\\'], s, i + 1);\\n    }\\n    public Node put(Node x, String s, int i){\\n        \\n        if(x == null) x = new Node();\\n        x.cnt++;\\n        if(s.length() == i){\\n            return x;\\n        }\\n\\n        x.next[s.charAt(i) - \\'a\\'] = put(x.next[s.charAt(i) - \\'a\\'], s, i + 1);\\n\\n        return x;\\n    }\\n}\\n\\nclass Node{\\n    int cnt = 0;\\n    Node[] next = new Node[26]; \\n    public Node(){\\n\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    Node  root = new Node();\\n    int sum = 0;    \\n    public int[] sumPrefixScores(String[] words) {\\n        \\n        for(String s : words){\\n            root = put(root, s, 0);\\n        }\\n\\n        int[] res = new int[words.length];\\n        int i = 0;\\n        for(String s : words){\\n            sum = 0;\\n            dfs(root, s, 0);\\n            res[i++] = sum - root.cnt;\\n        }\\n\\n        return res;\\n    }\\n    public void dfs(Node x, String s, int i){\\n        sum += x.cnt;\\n        if(s.length() == i) return;\\n        dfs(x.next[s.charAt(i) - \\'a\\'], s, i + 1);\\n    }\\n    public Node put(Node x, String s, int i){\\n        \\n        if(x == null) x = new Node();\\n        x.cnt++;\\n        if(s.length() == i){\\n            return x;\\n        }\\n\\n        x.next[s.charAt(i) - \\'a\\'] = put(x.next[s.charAt(i) - \\'a\\'], s, i + 1);\\n\\n        return x;\\n    }\\n}\\n\\nclass Node{\\n    int cnt = 0;\\n    Node[] next = new Node[26]; \\n    public Node(){\\n\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439967,
                "title": "java-solution-using-trie-and-maintaining-count-at-each-node",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class TrieNode{\\n       Map<Character,TrieNode> children = new HashMap();\\n       int count;\\n    }\\n    TrieNode root = new TrieNode();\\n    public int[] sumPrefixScores(String[] words) {\\n       for(String word : words){\\n           TrieNode node = root;\\n           for(char ch : word.toCharArray()){\\n               TrieNode newNode = node.children.get(ch);\\n\\n               if(newNode == null){\\n                  newNode = new TrieNode();\\n                  node.children.put(ch,newNode);\\n               }\\n               newNode.count++;\\n               node = newNode;\\n           }\\n       }\\n\\n       int[] result = new int[words.length];\\n       int idx = -1;\\n       for(String word : words){\\n           idx++;\\n           TrieNode node = root;\\n           for(char ch : word.toCharArray()){\\n                TrieNode newNode = node.children.get(ch);\\n                if(newNode == null){\\n                    break;\\n                }\\n                result[idx]+= newNode.count;\\n                node = newNode;\\n           }\\n       }\\n\\n       return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode{\\n       Map<Character,TrieNode> children = new HashMap();\\n       int count;\\n    }\\n    TrieNode root = new TrieNode();\\n    public int[] sumPrefixScores(String[] words) {\\n       for(String word : words){\\n           TrieNode node = root;\\n           for(char ch : word.toCharArray()){\\n               TrieNode newNode = node.children.get(ch);\\n\\n               if(newNode == null){\\n                  newNode = new TrieNode();\\n                  node.children.put(ch,newNode);\\n               }\\n               newNode.count++;\\n               node = newNode;\\n           }\\n       }\\n\\n       int[] result = new int[words.length];\\n       int idx = -1;\\n       for(String word : words){\\n           idx++;\\n           TrieNode node = root;\\n           for(char ch : word.toCharArray()){\\n                TrieNode newNode = node.children.get(ch);\\n                if(newNode == null){\\n                    break;\\n                }\\n                result[idx]+= newNode.count;\\n                node = newNode;\\n           }\\n       }\\n\\n       return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422975,
                "title": "c-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public class Trie\\n    {\\n        public int totalCount;\\n        public Dictionary<char, Trie> children;   \\n\\n        public Trie()\\n        {\\n            totalCount = 0;\\n            children = new Dictionary<char, Trie>();\\n        }\\n    }\\n\\n    public int[] SumPrefixScores(string[] words) \\n    {\\n        var root = new Trie();\\n        var n = words.Length; \\n\\n        foreach(var word in words)\\n        {\\n            var temp = root;\\n            foreach(var ch in word)\\n            {\\n                temp.children.TryAdd(ch, new Trie());\\n                temp = temp.children[ch];\\n                temp.totalCount +=1;\\n            }\\n        }\\n\\n        var result = new int[n];\\n        for(int i = 0; i < n; ++i)\\n        {\\n            var temp = root;\\n            var count = 0;\\n    \\n            foreach(var ch in words[i])\\n            {\\n                temp.children.TryAdd(ch, new Trie());\\n                temp = temp.children[ch];\\n                count += temp.totalCount;\\n            }\\n\\n            result[i] = count;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public class Trie\\n    {\\n        public int totalCount;\\n        public Dictionary<char, Trie> children;   \\n\\n        public Trie()\\n        {\\n            totalCount = 0;\\n            children = new Dictionary<char, Trie>();\\n        }\\n    }\\n\\n    public int[] SumPrefixScores(string[] words) \\n    {\\n        var root = new Trie();\\n        var n = words.Length; \\n\\n        foreach(var word in words)\\n        {\\n            var temp = root;\\n            foreach(var ch in word)\\n            {\\n                temp.children.TryAdd(ch, new Trie());\\n                temp = temp.children[ch];\\n                temp.totalCount +=1;\\n            }\\n        }\\n\\n        var result = new int[n];\\n        for(int i = 0; i < n; ++i)\\n        {\\n            var temp = root;\\n            var count = 0;\\n    \\n            foreach(var ch in words[i])\\n            {\\n                temp.children.TryAdd(ch, new Trie());\\n                temp = temp.children[ch];\\n                count += temp.totalCount;\\n            }\\n\\n            result[i] = count;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407758,
                "title": "typescript-with-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPretty straightforward counting problem with Trie, so should be classified as medium?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreated solution with Map, but ran out of memory. Replacing Map with Object for nodes *solved* the problem, but seriously?\\n\\n> Runtime 1534 ms Beats 100% Memory 146.9 MB Beats 50%\\n\\n\\n# Code\\n```\\nclass PrefixNode {\\n  nodes: {};\\n  count: number;\\n  constructor() {\\n    this.nodes = {};\\n    this.count = 0;\\n  }\\n}\\n\\nfunction sumPrefixScores(words: string[]): number[] {\\n  const prefixes = new PrefixNode();\\n\\n  words.forEach((word) => {\\n    let current = prefixes;\\n    for (const c of word) {\\n      if (!current.nodes[c]) current.nodes[c] = new PrefixNode();\\n      current = current.nodes[c];\\n      current.count++;\\n    }\\n  });\\n\\n  const scores = [];\\n\\n  words.forEach((word) => {\\n    let score = 0;\\n    let current = prefixes;\\n    for (const c of word) {\\n      current = current.nodes[c];\\n      score += current.count;\\n    }\\n    scores.push(score);\\n  });\\n\\n  return scores;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\nclass PrefixNode {\\n  nodes: {};\\n  count: number;\\n  constructor() {\\n    this.nodes = {};\\n    this.count = 0;\\n  }\\n}\\n\\nfunction sumPrefixScores(words: string[]): number[] {\\n  const prefixes = new PrefixNode();\\n\\n  words.forEach((word) => {\\n    let current = prefixes;\\n    for (const c of word) {\\n      if (!current.nodes[c]) current.nodes[c] = new PrefixNode();\\n      current = current.nodes[c];\\n      current.count++;\\n    }\\n  });\\n\\n  const scores = [];\\n\\n  words.forEach((word) => {\\n    let score = 0;\\n    let current = prefixes;\\n    for (const c of word) {\\n      current = current.nodes[c];\\n      score += current.count;\\n    }\\n    scores.push(score);\\n  });\\n\\n  return scores;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377537,
                "title": "c-trie",
                "content": "\\n# Code\\n```\\n\\nconst int ALPHABET_SIZE = 26;\\n// Trie node \\nstruct TrieNode { \\n     struct TrieNode *children[ALPHABET_SIZE];\\n     int count = 0;\\n}; \\n\\nclass Solution {\\nprivate:\\nvoid addWord(struct TrieNode *root, string key, int vindex){\\n    struct TrieNode *pCrawl = root;\\n    for (int i = 0; i < key.length(); i++){\\n        int index = key[i] - \\'a\\';\\n        if (!pCrawl->children[index])\\n            pCrawl->children[index] = getNode();\\n        pCrawl = pCrawl->children[index];\\n        pCrawl->count++;\\n    }\\n}\\n\\nvoid getScores(vector<int>& scores, struct TrieNode *root, string key, int vindex, int sum){\\n    struct TrieNode *pCrawl = root;\\n    for (int i = 0; i < key.length(); i++){\\n        int index = key[i] - \\'a\\';\\n        pCrawl = pCrawl->children[index];\\n        sum += pCrawl->count;\\n    }\\n    scores[vindex] = sum;\\n}\\n\\nstruct TrieNode *getNode(void){\\n    struct TrieNode *pNode =  new TrieNode;\\n    pNode->count = 0;\\n    for (int i = 0; i < ALPHABET_SIZE; i++)\\n        pNode->children[i] = NULL;\\n    return pNode;\\n}\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        struct TrieNode *root = new TrieNode();\\n        vector<int> ans(words.size(), 0);\\n        for(int i = 0; i < words.size(); i++){\\n            addWord(root, words[i], i);\\n        }\\n        for(int i = 0; i < words.size(); i++){\\n            getScores(ans, root, words[i], i, 0);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nconst int ALPHABET_SIZE = 26;\\n// Trie node \\nstruct TrieNode { \\n     struct TrieNode *children[ALPHABET_SIZE];\\n     int count = 0;\\n}; \\n\\nclass Solution {\\nprivate:\\nvoid addWord(struct TrieNode *root, string key, int vindex){\\n    struct TrieNode *pCrawl = root;\\n    for (int i = 0; i < key.length(); i++){\\n        int index = key[i] - \\'a\\';\\n        if (!pCrawl->children[index])\\n            pCrawl->children[index] = getNode();\\n        pCrawl = pCrawl->children[index];\\n        pCrawl->count++;\\n    }\\n}\\n\\nvoid getScores(vector<int>& scores, struct TrieNode *root, string key, int vindex, int sum){\\n    struct TrieNode *pCrawl = root;\\n    for (int i = 0; i < key.length(); i++){\\n        int index = key[i] - \\'a\\';\\n        pCrawl = pCrawl->children[index];\\n        sum += pCrawl->count;\\n    }\\n    scores[vindex] = sum;\\n}\\n\\nstruct TrieNode *getNode(void){\\n    struct TrieNode *pNode =  new TrieNode;\\n    pNode->count = 0;\\n    for (int i = 0; i < ALPHABET_SIZE; i++)\\n        pNode->children[i] = NULL;\\n    return pNode;\\n}\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        struct TrieNode *root = new TrieNode();\\n        vector<int> ans(words.size(), 0);\\n        for(int i = 0; i < words.size(); i++){\\n            addWord(root, words[i], i);\\n        }\\n        for(int i = 0; i < words.size(); i++){\\n            getScores(ans, root, words[i], i, 0);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357833,
                "title": "c-solution-using-trie",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    struct Node\\n    {\\n        Node *links[26];\\n        int cntPrefix = 0;\\n\\n        void put(char ch, Node *newNode)\\n        {\\n            links[ch - \\'a\\'] = newNode;\\n        }\\n\\n        Node *get(char ch)\\n        {\\n            return links[ch - \\'a\\'];\\n        }\\n\\n        bool containsKey(char ch)\\n        {\\n            return links[ch - \\'a\\'] != NULL;\\n        }\\n\\n        void increasePrefix()\\n        {\\n            cntPrefix++;\\n        }\\n    };\\n\\n    class Trie\\n    {\\n        Node *root;\\n\\n    public:\\n        Trie()\\n        {\\n            root = new Node();\\n        }\\n\\n        void insert(string word)\\n        {\\n            Node *node = root;\\n\\n            for (auto i : word)\\n            {\\n                if (!node->containsKey(i))\\n                    node->put(i, new Node());\\n\\n                node = node->get(i);\\n                node->increasePrefix();\\n            }\\n        }\\n\\n        int getPrefixes(string word)\\n        {\\n            Node *node = root;\\n            int count = 0;\\n\\n            for (auto i : word)\\n            {\\n                if (!node->containsKey(i))\\n                    return 0;\\n\\n                else\\n                {\\n                    node = node->get(i);\\n                    count += node->cntPrefix;\\n                }\\n            }\\n\\n            return count;\\n        }\\n    };\\npublic:\\n\\n    vector<int> sumPrefixScores(vector<string> &words)\\n    {\\n        Trie t;\\n\\n        for (auto word : words)\\n            t.insert(word);\\n\\n        vector<int> ans;\\n        for (auto word : words)\\n            ans.push_back(t.getPrefixes(word));\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Node\\n    {\\n        Node *links[26];\\n        int cntPrefix = 0;\\n\\n        void put(char ch, Node *newNode)\\n        {\\n            links[ch - \\'a\\'] = newNode;\\n        }\\n\\n        Node *get(char ch)\\n        {\\n            return links[ch - \\'a\\'];\\n        }\\n\\n        bool containsKey(char ch)\\n        {\\n            return links[ch - \\'a\\'] != NULL;\\n        }\\n\\n        void increasePrefix()\\n        {\\n            cntPrefix++;\\n        }\\n    };\\n\\n    class Trie\\n    {\\n        Node *root;\\n\\n    public:\\n        Trie()\\n        {\\n            root = new Node();\\n        }\\n\\n        void insert(string word)\\n        {\\n            Node *node = root;\\n\\n            for (auto i : word)\\n            {\\n                if (!node->containsKey(i))\\n                    node->put(i, new Node());\\n\\n                node = node->get(i);\\n                node->increasePrefix();\\n            }\\n        }\\n\\n        int getPrefixes(string word)\\n        {\\n            Node *node = root;\\n            int count = 0;\\n\\n            for (auto i : word)\\n            {\\n                if (!node->containsKey(i))\\n                    return 0;\\n\\n                else\\n                {\\n                    node = node->get(i);\\n                    count += node->cntPrefix;\\n                }\\n            }\\n\\n            return count;\\n        }\\n    };\\npublic:\\n\\n    vector<int> sumPrefixScores(vector<string> &words)\\n    {\\n        Trie t;\\n\\n        for (auto word : words)\\n            t.insert(word);\\n\\n        vector<int> ans;\\n        for (auto word : words)\\n            ans.push_back(t.getPrefixes(word));\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333456,
                "title": "simple-trie-esque",
                "content": "build a trie, but keep track of the count for each node. \\n\\nscan the trie for each word and sum the count of each node on the path.\\n\\n# Code\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n\\n        for word in words:\\n            root = trie\\n            for character in word:\\n                root = root[character]\\n                if \\'$\\' in root:\\n                    root[\\'$\\'] += 1\\n                else:\\n                    root[\\'$\\'] = 1\\n            \\n        def score(word):\\n            score = 0\\n            root = trie\\n            for character in word:\\n                root = root[character]\\n                score += root[\\'$\\']\\n            return score\\n\\n        return [score(word) for word in words]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n\\n        for word in words:\\n            root = trie\\n            for character in word:\\n                root = root[character]\\n                if \\'$\\' in root:\\n                    root[\\'$\\'] += 1\\n                else:\\n                    root[\\'$\\'] = 1\\n            \\n        def score(word):\\n            score = 0\\n            root = trie\\n            for character in word:\\n                root = root[character]\\n                score += root[\\'$\\']\\n            return score\\n\\n        return [score(word) for word in words]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329678,
                "title": "c-solution-with-trie",
                "content": "This question can be very easily solved by implementing a trie structure in very simple way.\\n\\n```\\nstruct Trie{\\n    int count;\\n    Trie *children[26];\\n    \\n    Trie()\\n    {\\n        count = 0;\\n        for(int i = 0; i<26;i++)\\n        {\\n            children[i] = NULL;\\n        }\\n    }\\n    void add(string word)\\n    {\\n        Trie *temp = this;\\n        \\n        for(int i = 0; i<word.length(); i++)\\n        {\\n            int idx = word[i]-\\'a\\';\\n            \\n            if(temp->children[idx] == NULL)\\n            {\\n                Trie *newTrie = new Trie;\\n                newTrie->count++;\\n                temp->children[idx] = newTrie;\\n                temp = temp->children[idx];\\n            }\\n            else\\n            {\\n                temp->children[idx]->count++;\\n                temp = temp->children[idx];\\n            }\\n            \\n        }\\n    }\\n    \\n    \\n    int search(string word)\\n    {\\n        Trie *temp = this;\\n        int score = 0;\\n        \\n        for(int i = 0; i<word.length();i++)\\n        {\\n            int idx = word[i]-\\'a\\';\\n            \\n            if(temp->children[idx]!=NULL)\\n            {\\n                score = score + temp->children[idx]->count;\\n                temp = temp->children[idx];\\n            }\\n        }\\n        \\n        return score;\\n        \\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        \\n        Trie *dict = new Trie();\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            \\n            dict->add(words[i]);\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            ans.push_back(dict->search(words[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Trie{\\n    int count;\\n    Trie *children[26];\\n    \\n    Trie()\\n    {\\n        count = 0;\\n        for(int i = 0; i<26;i++)\\n        {\\n            children[i] = NULL;\\n        }\\n    }\\n    void add(string word)\\n    {\\n        Trie *temp = this;\\n        \\n        for(int i = 0; i<word.length(); i++)\\n        {\\n            int idx = word[i]-\\'a\\';\\n            \\n            if(temp->children[idx] == NULL)\\n            {\\n                Trie *newTrie = new Trie;\\n                newTrie->count++;\\n                temp->children[idx] = newTrie;\\n                temp = temp->children[idx];\\n            }\\n            else\\n            {\\n                temp->children[idx]->count++;\\n                temp = temp->children[idx];\\n            }\\n            \\n        }\\n    }\\n    \\n    \\n    int search(string word)\\n    {\\n        Trie *temp = this;\\n        int score = 0;\\n        \\n        for(int i = 0; i<word.length();i++)\\n        {\\n            int idx = word[i]-\\'a\\';\\n            \\n            if(temp->children[idx]!=NULL)\\n            {\\n                score = score + temp->children[idx]->count;\\n                temp = temp->children[idx];\\n            }\\n        }\\n        \\n        return score;\\n        \\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        \\n        Trie *dict = new Trie();\\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            \\n            dict->add(words[i]);\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(int i = 0; i<words.size(); i++)\\n        {\\n            ans.push_back(dict->search(words[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327923,
                "title": "c-99-recursion-3x-faster-no-trie-no-hashmap",
                "content": "```\\nclass Solution {\\n    public:\\n    vector<int> sumPrefixScores(vector<string> const& unsorted) {\\n        short const n = size(unsorted);\\n        vector<pair<string_view, short>> words(n); // {word, i}\\n        for(short i{}; i < n; ++i) {\\n            words[i] = {unsorted[i], i};\\n        }\\n        sort(words.begin(), end(words)); // 123\\n        vector<int> ret(n);\\n        findSamePrefix(words.begin(), end(words), ret);\\n        return ret;\\n    }\\n    \\n    private:\\n    template <class iter>\\n    void findSamePrefix(iter const from, iter const to, vector<int>& ret, short const len = 1) {\\n        if(from == to) // [from, to)\\n            return;\\n        if(len > size(from->first))\\n            return findSamePrefix(from + 1, to, ret, len); // longer words\\n        auto const pivot = // end of words with the same prefix of current len\\n            upper_bound(from, to, from->first[len-1], [len](auto const ch, auto const& word) {\\n                return size(word.first) < len || word.first[len-1] > ch;\\n            }); // search only by last char in prefix\\n        for_each(from, pivot, [&](auto const& word) { ret[word.second] += pivot - from; }); // add cnt\\n        findSamePrefix(from, pivot, ret, len + 1); // left\\n        findSamePrefix(pivot, to, ret, len); // right\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    vector<int> sumPrefixScores(vector<string> const& unsorted) {\\n        short const n = size(unsorted);\\n        vector<pair<string_view, short>> words(n); // {word, i}\\n        for(short i{}; i < n; ++i) {\\n            words[i] = {unsorted[i], i};\\n        }\\n        sort(words.begin(), end(words)); // 123\\n        vector<int> ret(n);\\n        findSamePrefix(words.begin(), end(words), ret);\\n        return ret;\\n    }\\n    \\n    private:\\n    template <class iter>\\n    void findSamePrefix(iter const from, iter const to, vector<int>& ret, short const len = 1) {\\n        if(from == to) // [from, to)\\n            return;\\n        if(len > size(from->first))\\n            return findSamePrefix(from + 1, to, ret, len); // longer words\\n        auto const pivot = // end of words with the same prefix of current len\\n            upper_bound(from, to, from->first[len-1], [len](auto const ch, auto const& word) {\\n                return size(word.first) < len || word.first[len-1] > ch;\\n            }); // search only by last char in prefix\\n        for_each(from, pivot, [&](auto const& word) { ret[word.second] += pivot - from; }); // add cnt\\n        findSamePrefix(from, pivot, ret, len + 1); // left\\n        findSamePrefix(pivot, to, ret, len); // right\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315239,
                "title": "c-no-trie-hashing-38-38-passed-tle-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string_view, int> mp;\\n        for (const auto& word : words) {\\n            string_view prefix;\\n            for (const auto& c : word) {\\n                prefix = string_view(word.data(), prefix.size() + 1);\\n                mp[prefix]++;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(words.size());\\n        for (const auto& word : words) {\\n            int temp = 0;\\n            string_view prefix;\\n            for (size_t i = 0; i < word.size(); i++) {\\n                prefix = string_view(word.data(), i + 1);\\n                temp += mp[prefix];\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string_view, int> mp;\\n        for (const auto& word : words) {\\n            string_view prefix;\\n            for (const auto& c : word) {\\n                prefix = string_view(word.data(), prefix.size() + 1);\\n                mp[prefix]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3308096,
                "title": "python-simple-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words):\\n        dict1, n = defaultdict(int), len(words)\\n\\n        for word in words:\\n            trie = dict1\\n            for i in word:\\n                if i not in trie:\\n                    trie[i] = defaultdict(int)\\n                trie = trie[i]\\n                trie[\"*\"] += 1\\n\\n        result = [0]*n\\n\\n        for i,w in enumerate(words):\\n            trie = dict1\\n            for c in w:\\n                trie = trie[c]\\n                result[i] += trie[\"*\"]\\n\\n        return result\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words):\\n        dict1, n = defaultdict(int), len(words)\\n\\n        for word in words:\\n            trie = dict1\\n            for i in word:\\n                if i not in trie:\\n                    trie[i] = defaultdict(int)\\n                trie = trie[i]\\n                trie[\"*\"] += 1\\n\\n        result = [0]*n\\n\\n        for i,w in enumerate(words):\\n            trie = dict1\\n            for c in w:\\n                trie = trie[c]\\n                result[i] += trie[\"*\"]\\n\\n        return result\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307125,
                "title": "python3-iterative-faster-than-88-28",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        tree = {}\\n        for word in words:\\n            temp = tree\\n            for c in word:\\n                if c in temp:\\n                    temp[c][1]+=1\\n                else:\\n                    temp[c] = [{}, 1]\\n                temp = temp[c][0]\\n        \\n        res = []\\n        for word in words:\\n            temp = tree\\n            curr = 0\\n            for c in word:\\n                curr+=temp[c][1]\\n                temp = temp[c][0]\\n            res.append(curr)\\n            \\n        return res\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        tree = {}\\n        for word in words:\\n            temp = tree\\n            for c in word:\\n                if c in temp:\\n                    temp[c][1]+=1\\n                else:\\n                    temp[c] = [{}, 1]\\n                temp = temp[c][0]\\n        \\n        res = []\\n        for word in words:\\n            temp = tree\\n            curr = 0\\n            for c in word:\\n                curr+=temp[c][1]\\n                temp = temp[c][0]\\n            res.append(curr)\\n            \\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306509,
                "title": "c-trie-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct node{\\n    node* link[26];\\n    int count=0;\\n    bool contain(char c){\\n        return link[c-\\'a\\']!=NULL;\\n    }\\n    void put(char c, node* Node){\\n        link[c-\\'a\\']=Node;\\n    }\\n    node* get(char c){\\n        return link[c-\\'a\\'];\\n    }\\n    void inc(){\\n        count++;\\n    }\\n};\\nclass trie{\\npublic:\\nnode* root=new node();\\n\\nvoid insert(string s){\\n node* Node=root;\\n for(int i=0;i<s.size();i++){\\n     if(!Node->contain(s[i])){\\n         Node->put(s[i],new node());\\n     }\\n     Node=Node->get(s[i]);\\n     Node->inc();\\n }\\n}\\nint get(string s){\\n     node* Node=root;\\n     int g=0;\\n for(int i=0;i<s.size();i++){\\n     if(!Node->contain(s[i])){\\n         Node->put(s[i],new node());\\n     }\\n     Node=Node->get(s[i]);\\n    g+=Node->count;\\n }\\n return g;\\n}\\n};\\nclass Solution {\\npublic:\\n\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n       trie Trie;\\n       for(auto it:words){\\n           Trie.insert(it);\\n       }\\n       vector<int>v;\\n      // sort(words.begin(),words.end());\\n       map<string,int>m;\\n       for(int i=0;i<words.size();i++){\\n          \\n           v.push_back(Trie.get(words[i]));\\n       }\\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nstruct node{\\n    node* link[26];\\n    int count=0;\\n    bool contain(char c){\\n        return link[c-\\'a\\']!=NULL;\\n    }\\n    void put(char c, node* Node){\\n        link[c-\\'a\\']=Node;\\n    }\\n    node* get(char c){\\n        return link[c-\\'a\\'];\\n    }\\n    void inc(){\\n        count++;\\n    }\\n};\\nclass trie{\\npublic:\\nnode* root=new node();\\n\\nvoid insert(string s){\\n node* Node=root;\\n for(int i=0;i<s.size();i++){\\n     if(!Node->contain(s[i])){\\n         Node->put(s[i],new node());\\n     }\\n     Node=Node->get(s[i]);\\n     Node->inc();\\n }\\n}\\nint get(string s){\\n     node* Node=root;\\n     int g=0;\\n for(int i=0;i<s.size();i++){\\n     if(!Node->contain(s[i])){\\n         Node->put(s[i],new node());\\n     }\\n     Node=Node->get(s[i]);\\n    g+=Node->count;\\n }\\n return g;\\n}\\n};\\nclass Solution {\\npublic:\\n\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n       trie Trie;\\n       for(auto it:words){\\n           Trie.insert(it);\\n       }\\n       vector<int>v;\\n      // sort(words.begin(),words.end());\\n       map<string,int>m;\\n       for(int i=0;i<words.size();i++){\\n          \\n           v.push_back(Trie.get(words[i]));\\n       }\\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274521,
                "title": "trie-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:(avg(word.length)*length of word array)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(avg(word.length)*length of word array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar sumPrefixScores = function(words) {\\n\\n    let trie=new Trie()\\n\\n    let ans=[]\\n\\n\\n    for(let c of words){\\n        trie.add(c)\\n    }\\n\\n\\n\\n    for(let i=0;i<words.length;i++){\\n        let curr=trie.root\\n        let temp=0\\n        for(let c of words[i]){\\n            if(curr.children[c]!==undefined){\\n\\n                curr=curr.children[c]\\n                temp+=curr.count\\n\\n            }\\n        }\\n        ans.push(temp)\\n    }\\n\\n    return ans\\n\\n\\n    \\n};\\n\\n\\n\\n\\n\\nclass Node{\\n    constructor(value){\\n        this.value=value\\n        this.end=false\\n        this.children={}\\n        this.count=0\\n        \\n        \\n    }\\n}\\n\\n\\nclass Trie{\\nconstructor(){\\n    this.root=new Node(null)\\n}\\n\\n\\nadd(word){\\n\\n    let curr=this.root\\n\\n    for(let c of word){\\n        if(curr.children[c]===undefined){\\n            curr.children[c]=new Node(c)\\n        }\\n       \\n        curr=curr.children[c]\\n        curr.count++\\n\\n    }\\n\\n    curr.end=true\\n   \\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar sumPrefixScores = function(words) {\\n\\n    let trie=new Trie()\\n\\n    let ans=[]\\n\\n\\n    for(let c of words){\\n        trie.add(c)\\n    }\\n\\n\\n\\n    for(let i=0;i<words.length;i++){\\n        let curr=trie.root\\n        let temp=0\\n        for(let c of words[i]){\\n            if(curr.children[c]!==undefined){\\n\\n                curr=curr.children[c]\\n                temp+=curr.count\\n\\n            }\\n        }\\n        ans.push(temp)\\n    }\\n\\n    return ans\\n\\n\\n    \\n};\\n\\n\\n\\n\\n\\nclass Node{\\n    constructor(value){\\n        this.value=value\\n        this.end=false\\n        this.children={}\\n        this.count=0\\n        \\n        \\n    }\\n}\\n\\n\\nclass Trie{\\nconstructor(){\\n    this.root=new Node(null)\\n}\\n\\n\\nadd(word){\\n\\n    let curr=this.root\\n\\n    for(let c of word){\\n        if(curr.children[c]===undefined){\\n            curr.children[c]=new Node(c)\\n        }\\n       \\n        curr=curr.children[c]\\n        curr.count++\\n\\n    }\\n\\n    curr.end=true\\n   \\n\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273334,
                "title": "java-o-n-avg-word-length-trie-simple-solution",
                "content": "# Intuition\\nTrie is the best way to maintain all the prefix of words. We could add one more property into the trie which keeps the counter at every trie node to maintain the count of each char appear while creation of trie. \\n\\n# Approach\\nCreate a trie node, in trie node add one more counter variable. which will increament whenever we visit any trie node. this signifies prefix counter of that node. \\n\\nto calculate the total prefix counter of any word, we can sum the counter of each char of word appeared into trie.  \\n\\n# Complexity\\n- Time complexity:\\nn = words.length\\nint t = Average length of word\\nO(n * t) \\nfirst we need to create the trie & then we need to retreive the trie;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nCreation of trie O( (26 ^ t) * n) , space taken by trie. \\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] sumPrefixScores(String[] words) {\\n\\n     Trie[] map = new Trie[26];\\n     \\n     for(String word : words) {\\n         Trie[] temp = map;\\n         for(int i = 0; i < word.length(); i++) {\\n             int c = word.charAt(i) - \\'a\\';\\n             \\n             if(temp[c] == null){\\n                 temp[c] = new Trie();\\n             }\\n             Trie current = temp[c];\\n             if(i == word.length() -1){\\n                 current.isEnd = true;\\n                 \\n             }\\n             current.count++;\\n             temp = current.childs;\\n         }\\n     }\\n\\n     int[] ans = new int[words.length];\\n     int aIndex = 0;\\n     for(String word : words) {\\n         Trie[] temp = map;\\n        int sum = 0;\\n         for(int i = 0; i < word.length(); i++){\\n             int c = word.charAt(i) - \\'a\\';\\n             Trie current = temp[c];\\n             sum += current.count;\\n             if(i == word.length() -1){\\n                 ans[aIndex] = sum;\\n             }\\n             temp = current.childs;\\n         }\\n         aIndex++;\\n     }\\n\\n     return ans;\\n\\n    }\\n\\n    class Trie {\\n        Trie[] childs;\\n        int count;\\n        boolean isEnd;\\n        Trie() {\\n            this.childs = new Trie[26];\\n            int count = 0;\\n            this.isEnd = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] sumPrefixScores(String[] words) {\\n\\n     Trie[] map = new Trie[26];\\n     \\n     for(String word : words) {\\n         Trie[] temp = map;\\n         for(int i = 0; i < word.length(); i++) {\\n             int c = word.charAt(i) - \\'a\\';\\n             \\n             if(temp[c] == null){\\n                 temp[c] = new Trie();\\n             }\\n             Trie current = temp[c];\\n             if(i == word.length() -1){\\n                 current.isEnd = true;\\n                 \\n             }\\n             current.count++;\\n             temp = current.childs;\\n         }\\n     }\\n\\n     int[] ans = new int[words.length];\\n     int aIndex = 0;\\n     for(String word : words) {\\n         Trie[] temp = map;\\n        int sum = 0;\\n         for(int i = 0; i < word.length(); i++){\\n             int c = word.charAt(i) - \\'a\\';\\n             Trie current = temp[c];\\n             sum += current.count;\\n             if(i == word.length() -1){\\n                 ans[aIndex] = sum;\\n             }\\n             temp = current.childs;\\n         }\\n         aIndex++;\\n     }\\n\\n     return ans;\\n\\n    }\\n\\n    class Trie {\\n        Trie[] childs;\\n        int count;\\n        boolean isEnd;\\n        Trie() {\\n            this.childs = new Trie[26];\\n            int count = 0;\\n            this.isEnd = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271558,
                "title": "easy-python-trie-beats-95-for-runtime-and-93-for-memory",
                "content": "\\n# Approach\\nBuild a trie for the entire set of words. Also add a count in the trie. This count signifies the number of words that have a prefix ending at current letter. \\nThen use the count to find the score.\\n\\n{\\'a\\': {\\'count\\': 2, \\'b\\': {\\'count\\': 2, \\'c\\': {\\'count\\': 1}}}, \\'b\\': {\\'count\\': 2, \\'c\\': {\\'count\\': 1}}}\\nExample:\\n```\\nwords = [\"abc\",\"ab\",\"bc\",\"b\"]\\ntrie -> \\na, count = 2    |   b, count = 2\\n    /                     \\\\\\nb, count = 2              c, count = 1\\n     /\\nc, count = 1\\n\\n```\\nFor the word \\'abc\\', the prefixes are \\'a\\', \\'ab\\', \\'abc\\'. So all we have to do is go down the path \\'abc\\' in the trie and add the count at every step. This will give us 5. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is total number of characters\\n\\n- Space complexity:\\nO(n)  where n is total number of characters\\n\\n# Code\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        def trieNode(c):\\n            return {\\'count\\': 1}\\n        trie = {}\\n        for word in words:\\n            currentTrie = trie\\n            for c in word:\\n                if c not in currentTrie:\\n                    currentTrie[c] = trieNode(c)\\n                else:\\n                    currentTrie[c][\\'count\\'] += 1\\n                currentTrie = currentTrie[c]\\n\\n        scores = []\\n\\n        for word in words:\\n            currentScore = 0\\n            currentTrie = trie\\n            for c in word:\\n                currentScore += currentTrie[c][\\'count\\']\\n                currentTrie = currentTrie[c]\\n            scores.append(currentScore)\\n        return scores\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nwords = [\"abc\",\"ab\",\"bc\",\"b\"]\\ntrie -> \\na, count = 2    |   b, count = 2\\n    /                     \\\\\\nb, count = 2              c, count = 1\\n     /\\nc, count = 1\\n\\n```\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        def trieNode(c):\\n            return {\\'count\\': 1}\\n        trie = {}\\n        for word in words:\\n            currentTrie = trie\\n            for c in word:\\n                if c not in currentTrie:\\n                    currentTrie[c] = trieNode(c)\\n                else:\\n                    currentTrie[c][\\'count\\'] += 1\\n                currentTrie = currentTrie[c]\\n\\n        scores = []\\n\\n        for word in words:\\n            currentScore = 0\\n            currentTrie = trie\\n            for c in word:\\n                currentScore += currentTrie[c][\\'count\\']\\n                currentTrie = currentTrie[c]\\n            scores.append(currentScore)\\n        return scores\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234160,
                "title": "easy-cpp-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass node{\\npublic:\\nnode* link[26];\\nint occ=0;\\nbool flag= false;\\nbool islink(char c){return link[c-\\'a\\']!=NULL;}\\nnode* get_link(char c){return link[c-\\'a\\'];}\\nvoid make_link(char c, node* p){link[c-\\'a\\']=p;}\\nbool isend(){return flag;}\\nvoid incr(){occ++;}\\nint num(){return occ;}\\n};\\n\\nclass Solution {\\npublic:\\nnode* root=new node();\\n\\nvoid insert(string s){\\n    node* t=root;\\n    for(int i=0; i<s.size(); i++){\\n        if(!t->islink(s[i]))t->make_link(s[i], new node());\\n        t=t->get_link(s[i]);\\n        t->incr();\\n    }\\n}\\n\\nint check(string s){\\n    node* t=root;\\n    int ans=0;\\n    for(int i=0; i<s.size(); i++){\\n        t=t->get_link(s[i]);\\n        ans+=t->occ;\\n    }\\n    return ans;\\n}\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        for(auto i: words)insert(i);\\n        vector<int> v;\\n        for(auto i: words)v.push_back(check(i));\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Trie",
                    "Counting"
                ],
                "code": "```\\nclass node{\\npublic:\\nnode* link[26];\\nint occ=0;\\nbool flag= false;\\nbool islink(char c){return link[c-\\'a\\']!=NULL;}\\nnode* get_link(char c){return link[c-\\'a\\'];}\\nvoid make_link(char c, node* p){link[c-\\'a\\']=p;}\\nbool isend(){return flag;}\\nvoid incr(){occ++;}\\nint num(){return occ;}\\n};\\n\\nclass Solution {\\npublic:\\nnode* root=new node();\\n\\nvoid insert(string s){\\n    node* t=root;\\n    for(int i=0; i<s.size(); i++){\\n        if(!t->islink(s[i]))t->make_link(s[i], new node());\\n        t=t->get_link(s[i]);\\n        t->incr();\\n    }\\n}\\n\\nint check(string s){\\n    node* t=root;\\n    int ans=0;\\n    for(int i=0; i<s.size(); i++){\\n        t=t->get_link(s[i]);\\n        ans+=t->occ;\\n    }\\n    return ans;\\n}\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        for(auto i: words)insert(i);\\n        vector<int> v;\\n        for(auto i: words)v.push_back(check(i));\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199942,
                "title": "no-fancy-algorithm-needed",
                "content": "# Intuition\\nJust count the number of times a prefix is seen in all words using a hashmap counter.\\n# Approach\\nCreate a hashmap that maps {prefix: number of times this prefix is seen in all words}. The prefix score of each word is the sum of the number of times each of that word\\'s prefixes is seen in all words (which you can query in the hashmap). \\n\\n# Complexity\\n- Time complexity:\\nO(number of letters in all words)\\n\\n- Space complexity:\\nO(number of letters in all words)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        hashmap = defaultdict(int)\\n        for word in words:\\n            prefix = \"\"\\n            for letter in word:\\n                prefix += letter\\n                hashmap[prefix] += 1\\n        res = [0]*len(words)\\n        for i in range(len(words)):\\n            word = words[i]\\n            prefix = \"\"\\n            for letter in word:\\n                prefix += letter\\n                res[i] += hashmap[prefix]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        hashmap = defaultdict(int)\\n        for word in words:\\n            prefix = \"\"\\n            for letter in word:\\n                prefix += letter\\n                hashmap[prefix] += 1\\n        res = [0]*len(words)\\n        for i in range(len(words)):\\n            word = words[i]\\n            prefix = \"\"\\n            for letter in word:\\n                prefix += letter\\n                res[i] += hashmap[prefix]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185425,
                "title": "python-simple-trie",
                "content": "```\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.t = {}\\n    \\n    def add(self, word):\\n        curr = self.t\\n        \\n        for letter in word:\\n            if letter not in curr:\\n                curr[letter] = {}\\n                curr[letter][\"count\"] = 0\\n            \\n            curr[letter][\"count\"] += 1\\n            curr = curr[letter]\\n    \\n    def count(self, word):\\n        curr = self.t\\n        ans = 0\\n        for letter in word:\\n            curr = curr[letter]\\n            ans += curr[\"count\"]\\n        \\n        return ans\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        t = Trie()\\n        ans = []\\n        \\n        for word in words:\\n            t.add(word)\\n        \\n        for word in words:\\n            ans.append(t.count(word))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.t = {}\\n    \\n    def add(self, word):\\n        curr = self.t\\n        \\n        for letter in word:\\n            if letter not in curr:\\n                curr[letter] = {}\\n                curr[letter][\"count\"] = 0\\n            \\n            curr[letter][\"count\"] += 1\\n            curr = curr[letter]\\n    \\n    def count(self, word):\\n        curr = self.t\\n        ans = 0\\n        for letter in word:\\n            curr = curr[letter]\\n            ans += curr[\"count\"]\\n        \\n        return ans\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        \\n        t = Trie()\\n        ans = []\\n        \\n        for word in words:\\n            t.add(word)\\n        \\n        for word in words:\\n            ans.append(t.count(word))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182729,
                "title": "clean-and-simple-python",
                "content": "\\n```\\nclass TrieNode:\\n    def __init__(self, val: str):\\n        self.val = val\\n        self.word_leaves = 0        \\n        self.word = False\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(val=\"root\")\\n\\n    def insert(self, word: str):\\n        cur = self.root\\n        \\n\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode(val=c)\\n\\n            cur.children[c].word_leaves += 1            \\n            cur = cur.children[c]\\n                            \\n        cur.word = True                \\n\\n    def get_score(self, word: str):        \\n\\n        score = 0\\n        cur = self.root\\n\\n        for c in word:                                   \\n            score += cur.children[c].word_leaves  \\n            cur = cur.children[c]                        \\n        \\n        return score\\n            \\n    \\n        \\n\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n\\n        for word in words:\\n            trie.insert(word)\\n        \\n        ans = []\\n        \\n\\n        for word in words:\\n            ans.append(trie.get_score(word))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self, val: str):\\n        self.val = val\\n        self.word_leaves = 0        \\n        self.word = False\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(val=\"root\")\\n\\n    def insert(self, word: str):\\n        cur = self.root\\n        \\n\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode(val=c)\\n\\n            cur.children[c].word_leaves += 1            \\n            cur = cur.children[c]\\n                            \\n        cur.word = True                \\n\\n    def get_score(self, word: str):        \\n\\n        score = 0\\n        cur = self.root\\n\\n        for c in word:                                   \\n            score += cur.children[c].word_leaves  \\n            cur = cur.children[c]                        \\n        \\n        return score\\n            \\n    \\n        \\n\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n\\n        for word in words:\\n            trie.insert(word)\\n        \\n        ans = []\\n        \\n\\n        for word in words:\\n            ans.append(trie.get_score(word))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173632,
                "title": "easy-python3-solution-using-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve the problem by building a trie and keeping the counts of each character\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst Pass: build a trie, using the input\\nSecond Pass: for all the words in the input; find the sum of counts of each character in the word.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node:\\n\\n    def __init__(self):\\n        self.count = 0 \\n        self.children = {}\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        root = Node()\\n        mydict = {}\\n        curr = root\\n        for word in words:\\n            curr = root\\n            for c in word:\\n                if c not in curr.children:\\n                    curr.children[c] = Node()\\n                curr = curr.children[c]\\n                curr.count += 1\\n            mydict[word] = curr\\n\\n        result = []\\n        for word in words:\\n            curr = root\\n            temp = 0\\n            for c in word:\\n                curr = curr.children[c]\\n                temp += curr.count \\n            result.append(temp)\\n        return result\\n\\n           \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n\\n    def __init__(self):\\n        self.count = 0 \\n        self.children = {}\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        root = Node()\\n        mydict = {}\\n        curr = root\\n        for word in words:\\n            curr = root\\n            for c in word:\\n                if c not in curr.children:\\n                    curr.children[c] = Node()\\n                curr = curr.children[c]\\n                curr.count += 1\\n            mydict[word] = curr\\n\\n        result = []\\n        for word in words:\\n            curr = root\\n            temp = 0\\n            for c in word:\\n                curr = curr.children[c]\\n                temp += curr.count \\n            result.append(temp)\\n        return result\\n\\n           \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153189,
                "title": "c-trie",
                "content": "# Code\\n```\\nclass Solution {\\n    class trieNode {\\n        public:\\n        int count = 1;\\n        trieNode *children[26];\\n    };\\n    void insert(trieNode *root, string &s) {\\n        trieNode *curr = root;\\n        for(char ch: s) {\\n            if(curr -> children[ch - \\'a\\'] == nullptr) {\\n                curr -> children[ch - \\'a\\'] = new trieNode(); \\n            } else {\\n                curr -> children[ch - \\'a\\'] -> count++;\\n            }\\n            curr = curr -> children[ch - \\'a\\'];\\n        }\\n    }\\n    int query(trieNode *root, string &s) {\\n        trieNode *curr = root;\\n        int c = 0;\\n        for(char ch: s) {\\n            if(curr -> children[ch - \\'a\\'] == nullptr) {\\n                return c;\\n            } else {\\n                c += curr -> children[ch - \\'a\\'] -> count;\\n            }\\n            curr = curr -> children[ch - \\'a\\'];\\n        }\\n        return c;\\n    }\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        int n = words.size();\\n        trieNode *root = new trieNode();\\n        for(string word: words) {\\n            insert(root, word);\\n        }\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = query(root, words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Trie",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    class trieNode {\\n        public:\\n        int count = 1;\\n        trieNode *children[26];\\n    };\\n    void insert(trieNode *root, string &s) {\\n        trieNode *curr = root;\\n        for(char ch: s) {\\n            if(curr -> children[ch - \\'a\\'] == nullptr) {\\n                curr -> children[ch - \\'a\\'] = new trieNode(); \\n            } else {\\n                curr -> children[ch - \\'a\\'] -> count++;\\n            }\\n            curr = curr -> children[ch - \\'a\\'];\\n        }\\n    }\\n    int query(trieNode *root, string &s) {\\n        trieNode *curr = root;\\n        int c = 0;\\n        for(char ch: s) {\\n            if(curr -> children[ch - \\'a\\'] == nullptr) {\\n                return c;\\n            } else {\\n                c += curr -> children[ch - \\'a\\'] -> count;\\n            }\\n            curr = curr -> children[ch - \\'a\\'];\\n        }\\n        return c;\\n    }\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        int n = words.size();\\n        trieNode *root = new trieNode();\\n        for(string word: words) {\\n            insert(root, word);\\n        }\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = query(root, words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138678,
                "title": "modified-trie",
                "content": "# Intuition\\nImplement a trie. In add word function, keep track of a acount of times that prefix has been added\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * M), N is number of words, M is the length of longest word \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * M), N is number of words, M is the length of longest word \\n\\n# Code\\n```\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = {}\\n\\n    def add(self, word):\\n        node = self.root\\n        for c in word:\\n            if c not in node:\\n                node[c] = {\"cnt\": 1}\\n            else:\\n                node[c][\"cnt\"] += 1\\n            node = node[c]\\n\\n    def count(self, word):\\n        node = self.root\\n        res = 0\\n        for c in word:\\n            if c not in node:\\n                break\\n\\n            res += node[c][\"cnt\"]\\n            node = node[c]\\n        \\n        return res\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n\\n        trie = Trie()\\n        for w in words:\\n            trie.add(w)\\n        \\n        return [trie.count(w) for w in words]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = {}\\n\\n    def add(self, word):\\n        node = self.root\\n        for c in word:\\n            if c not in node:\\n                node[c] = {\"cnt\": 1}\\n            else:\\n                node[c][\"cnt\"] += 1\\n            node = node[c]\\n\\n    def count(self, word):\\n        node = self.root\\n        res = 0\\n        for c in word:\\n            if c not in node:\\n                break\\n\\n            res += node[c][\"cnt\"]\\n            node = node[c]\\n        \\n        return res\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n\\n        trie = Trie()\\n        for w in words:\\n            trie.add(w)\\n        \\n        return [trie.count(w) for w in words]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135884,
                "title": "simple-solution-using-trie-class",
                "content": "\\n```python\\nclass TrieNode:\\n\\tdef __init__(self):\\n\\t\\tself.child = defaultdict(TrieNode)\\n\\t\\tself.score = 0\\n\\t\\tself.isWordEnd = False\\n\\nclass Trie:\\n\\tdef __init__(self):\\n\\t\\tself.root = TrieNode()\\n\\n\\tdef insert(self, word):\\n\\t\\tcurr = self.root\\n\\t\\tfor c in word:\\n\\t\\t\\tcurr.child[c].score += 1\\n\\t\\t\\tcurr = curr.child[c]\\n\\t\\tcurr.isWordEnd = True\\n\\n\\n\\tdef words(self, words):\\n\\t\\tfor word in words:\\n\\t\\t\\tself.insert(word)\\n\\n\\tdef score(self, word):\\n\\t\\tscore = 0\\n\\t\\tcurr = self.root\\n\\t\\tfor c in word:\\n\\t\\t\\tscore += curr.child[c].score\\n\\t\\t\\tcurr = curr.child[c]\\n\\t\\treturn score\\n\\n\\tdef scores(self, words):\\n\\t\\tres = [0]*len(words)\\n\\t\\tfor i, word in enumerate(words):\\n\\t\\t\\tres[i] = self.score(word)\\n\\t\\treturn res\\n\\nclass Solution:\\n\\tdef sumPrefixScores(self, words: list[str]) -> list[int]:\\n\\t\\ttrie = Trie()\\n\\t\\ttrie.words(words)\\n\\t\\treturn trie.scores(words)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```python\\nclass TrieNode:\\n\\tdef __init__(self):\\n\\t\\tself.child = defaultdict(TrieNode)\\n\\t\\tself.score = 0\\n\\t\\tself.isWordEnd = False\\n\\nclass Trie:\\n\\tdef __init__(self):\\n\\t\\tself.root = TrieNode()\\n\\n\\tdef insert(self, word):\\n\\t\\tcurr = self.root\\n\\t\\tfor c in word:\\n\\t\\t\\tcurr.child[c].score += 1\\n\\t\\t\\tcurr = curr.child[c]\\n\\t\\tcurr.isWordEnd = True\\n\\n\\n\\tdef words(self, words):\\n\\t\\tfor word in words:\\n\\t\\t\\tself.insert(word)\\n\\n\\tdef score(self, word):\\n\\t\\tscore = 0\\n\\t\\tcurr = self.root\\n\\t\\tfor c in word:\\n\\t\\t\\tscore += curr.child[c].score\\n\\t\\t\\tcurr = curr.child[c]\\n\\t\\treturn score\\n\\n\\tdef scores(self, words):\\n\\t\\tres = [0]*len(words)\\n\\t\\tfor i, word in enumerate(words):\\n\\t\\t\\tres[i] = self.score(word)\\n\\t\\treturn res\\n\\nclass Solution:\\n\\tdef sumPrefixScores(self, words: list[str]) -> list[int]:\\n\\t\\ttrie = Trie()\\n\\t\\ttrie.words(words)\\n\\t\\treturn trie.scores(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104045,
                "title": "c-using-trie",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    class Trie{\\n        public:\\n            Trie* TrieNode[26];\\n            int prefixCount = 0;\\n    };\\n    \\n    \\n    Trie* root;\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        root = new Trie();\\n        for(auto& it:words)\\n            addIntoTrie(root,it);\\n        vector<int> ans;\\n        for(auto& it:words){\\n            func(it,root,ans);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void addIntoTrie(Trie* root,string& word){\\n        Trie* tmp = root;\\n        for(auto& it:word){\\n            if(tmp->TrieNode[it-\\'a\\'] == NULL){\\n                tmp->TrieNode[it-\\'a\\'] = new Trie();\\n            }\\n            tmp=tmp->TrieNode[it-\\'a\\'];\\n            tmp->prefixCount+=1;\\n        }\\n    }\\n    \\n    \\n    void func(string& word,Trie* root,vector<int>& ans){\\n        Trie* tmp = root;\\n        int count = 0;\\n        for(auto& it:word){\\n            if(tmp->TrieNode[it-\\'a\\']){\\n                tmp = tmp->TrieNode[it-\\'a\\'];\\n                count+=tmp->prefixCount;\\n            }\\n            else\\n                break;\\n        }\\n        ans.push_back(count);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    class Trie{\\n        public:\\n            Trie* TrieNode[26];\\n            int prefixCount = 0;\\n    };\\n    \\n    \\n    Trie* root;\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        root = new Trie();\\n        for(auto& it:words)\\n            addIntoTrie(root,it);\\n        vector<int> ans;\\n        for(auto& it:words){\\n            func(it,root,ans);\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void addIntoTrie(Trie* root,string& word){\\n        Trie* tmp = root;\\n        for(auto& it:word){\\n            if(tmp->TrieNode[it-\\'a\\'] == NULL){\\n                tmp->TrieNode[it-\\'a\\'] = new Trie();\\n            }\\n            tmp=tmp->TrieNode[it-\\'a\\'];\\n            tmp->prefixCount+=1;\\n        }\\n    }\\n    \\n    \\n    void func(string& word,Trie* root,vector<int>& ans){\\n        Trie* tmp = root;\\n        int count = 0;\\n        for(auto& it:word){\\n            if(tmp->TrieNode[it-\\'a\\']){\\n                tmp = tmp->TrieNode[it-\\'a\\'];\\n                count+=tmp->prefixCount;\\n            }\\n            else\\n                break;\\n        }\\n        ans.push_back(count);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101378,
                "title": "easy-solution-for-interviews",
                "content": "# Intuition\\nSo, I know that trie solution would have worked really well but start with this approach in interviews as brute force and then if upon asked move to Trie approach.\\n\\nBelow solution is very easy and what we naturally would have done to solve the problem.\\n\\nI didn\\'t get TLE but ideally it should.Nevertheless this is suggested only in case of quick solution in interviews.\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        helper = []\\n        for i in words:\\n            for j in range(1,len(i)+1):\\n                helper.append(i[:j])\\n        res = []\\n        helper = Counter(helper)\\n        for i in words:\\n            counter = 0\\n            for j in range(1,len(i)+1):\\n                counter+=helper[i[:j]]\\n            res.append(counter)\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        helper = []\\n        for i in words:\\n            for j in range(1,len(i)+1):\\n                helper.append(i[:j])\\n        res = []\\n        helper = Counter(helper)\\n        for i in words:\\n            counter = 0\\n            for j in range(1,len(i)+1):\\n                counter+=helper[i[:j]]\\n            res.append(counter)\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078903,
                "title": "c-naive-approach-intuition-trie-clean-code",
                "content": "# 2416. Sum of Prefix Scores of Strings\\n![Screenshot 2023-01-21 024952.jpg](https://assets.leetcode.com/users/images/aa4fa325-7ad7-406b-8ae8-4bff41c83371_1674249853.980805.jpeg)\\n\\n## Naive Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial solution that comes to mind is obviously the hash table. There isn\\'t much to explain about this code as I am sure you\\'ve already tried this yourself.\\n\\n- #### Code (Naive)\\n```\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int> m;\\n        for(auto&i:words){\\n            string temp;\\n            for(auto&j:i){\\n                temp.push_back(j);\\n                m[temp]++;\\n            }\\n        }\\n        vector<int> ans;\\n        unordered_map<string,int> vis;\\n        for(auto&i:words){\\n            string temp;\\n            int t=0;\\n            if(vis[i]){\\n                ans.push_back(vis[i]);\\n                continue;\\n            }\\n            for(auto&j:i){\\n                temp.push_back(j);\\n                t+=m[temp];\\n            }\\n            vis[i]=t;\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Intuition\\nFrom the above approach, one thing is clear -- we are again and again adding the prefixes we have already visited. From this trie should come to mind. If you recall, in trie we insert a string in the datastructure one alphabet at a time (which is kind of what we need here). \\n\\n## Trie Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe only modification is that we need to give a new integer parameter `int vis` to our node, as opposed to the usual two parameters `Node* links[26]` and `bool flag`.\\n\\n`int vis` here stores the number of times a prefix is reached. We iterate over *words* twice, once to insert and then to add all the valus of *vis*.\\n\\n- #### Code (Trie)\\n```\\nstruct Node{\\n    Node* links[26];\\n    bool flag;\\n    int vis = 0;\\n    bool contains(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    void put(char ch){\\n        links[ch-\\'a\\']=new Node();\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n};\\n\\nclass Trie{\\n    private: Node* root;\\n    public:\\n    Trie(){\\n        root= new Node();\\n    }\\n    void insert(string s){\\n        Node* node=root;\\n        for(auto&i:s){\\n            if(!node->contains(i)){\\n                node->put(i);\\n            }\\n            node=node->get(i);\\n            node->vis++;\\n        }\\n        node->flag=true;\\n    }\\n    int sumWith(string s){\\n        Node* node=root;\\n        int sum=0;\\n        for(auto&i:s){\\n            node=node->get(i);\\n            sum+=node->vis;\\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie trie;\\n        for(auto&i:words){\\n            trie.insert(i);\\n        }\\n        vector<int> ans;\\n        for(auto&i:words){\\n            ans.push_back(trie.sumWith(i));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int> m;\\n        for(auto&i:words){\\n            string temp;\\n            for(auto&j:i){\\n                temp.push_back(j);\\n                m[temp]++;\\n            }\\n        }\\n        vector<int> ans;\\n        unordered_map<string,int> vis;\\n        for(auto&i:words){\\n            string temp;\\n            int t=0;\\n            if(vis[i]){\\n                ans.push_back(vis[i]);\\n                continue;\\n            }\\n            for(auto&j:i){\\n                temp.push_back(j);\\n                t+=m[temp];\\n            }\\n            vis[i]=t;\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nstruct Node{\\n    Node* links[26];\\n    bool flag;\\n    int vis = 0;\\n    bool contains(char ch){\\n        return links[ch-\\'a\\']!=NULL;\\n    }\\n    void put(char ch){\\n        links[ch-\\'a\\']=new Node();\\n    }\\n    Node* get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n};\\n\\nclass Trie{\\n    private: Node* root;\\n    public:\\n    Trie(){\\n        root= new Node();\\n    }\\n    void insert(string s){\\n        Node* node=root;\\n        for(auto&i:s){\\n            if(!node->contains(i)){\\n                node->put(i);\\n            }\\n            node=node->get(i);\\n            node->vis++;\\n        }\\n        node->flag=true;\\n    }\\n    int sumWith(string s){\\n        Node* node=root;\\n        int sum=0;\\n        for(auto&i:s){\\n            node=node->get(i);\\n            sum+=node->vis;\\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie trie;\\n        for(auto&i:words){\\n            trie.insert(i);\\n        }\\n        vector<int> ans;\\n        for(auto&i:words){\\n            ans.push_back(trie.sumWith(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066183,
                "title": "c-prefix-tree",
                "content": "\\n\\n# Code\\n```\\n#include <iostream>\\nusing namespace std;\\n\\nclass PrefixTree {\\npublic:\\n    int count = 0;\\n    unordered_map<char, PrefixTree*> map;\\n    PrefixTree() {\\n        this->count = 0;\\n    }; \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        PrefixTree* root = new PrefixTree();\\n        for(string& ele: words) {\\n            PrefixTree* cur = root;\\n            for(int i=0;i<ele.size();i++) {\\n                char c = ele[i];\\n                if(cur->map.count(c) == 0) {\\n                    cur->map[c] = new PrefixTree();\\n                }\\n                cur = cur->map[c];\\n                cur->count++;\\n            }\\n        }\\n\\n\\n        vector<int> res;\\n        for(int i=0;i<words.size();i++) {\\n            int temp = 0;\\n            PrefixTree* cur = root;\\n            for(int j=0;j<words[i].size();j++) {\\n                char c = words[i][j];\\n                cur = cur->map[c];\\n                temp += cur->count;\\n            }\\n\\n            res.push_back(temp);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\nusing namespace std;\\n\\nclass PrefixTree {\\npublic:\\n    int count = 0;\\n    unordered_map<char, PrefixTree*> map;\\n    PrefixTree() {\\n        this->count = 0;\\n    }; \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        PrefixTree* root = new PrefixTree();\\n        for(string& ele: words) {\\n            PrefixTree* cur = root;\\n            for(int i=0;i<ele.size();i++) {\\n                char c = ele[i];\\n                if(cur->map.count(c) == 0) {\\n                    cur->map[c] = new PrefixTree();\\n                }\\n                cur = cur->map[c];\\n                cur->count++;\\n            }\\n        }\\n\\n\\n        vector<int> res;\\n        for(int i=0;i<words.size();i++) {\\n            int temp = 0;\\n            PrefixTree* cur = root;\\n            for(int j=0;j<words[i].size();j++) {\\n                char c = words[i][j];\\n                cur = cur->map[c];\\n                temp += cur->count;\\n            }\\n\\n            res.push_back(temp);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3061914,
                "title": "simple-python3-trie",
                "content": "# Code\\n```\\n# Simple Trie Based solution, where we add 1 to each\\n# character node we insert, and then\\n# simply count those when querying\\nclass TrieNode:\\n    def __init__(self, count=0):\\n        self.children = {}\\n        self.count = count\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node.children[c].count += 1\\n            node = node.children[c]\\n    \\n    def query(self, word):\\n        res = 0\\n        node = self.root\\n        for c in word:\\n            res += node.children[c].count\\n            node = node.children[c]\\n        return res\\n    \\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        return [trie.query(word) for word in words]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Simple Trie Based solution, where we add 1 to each\\n# character node we insert, and then\\n# simply count those when querying\\nclass TrieNode:\\n    def __init__(self, count=0):\\n        self.children = {}\\n        self.count = count\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        node = self.root\\n        for c in word:\\n            if c not in node.children:\\n                node.children[c] = TrieNode()\\n            node.children[c].count += 1\\n            node = node.children[c]\\n    \\n    def query(self, word):\\n        res = 0\\n        node = self.root\\n        for c in word:\\n            res += node.children[c].count\\n            node = node.children[c]\\n        return res\\n    \\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(word)\\n        return [trie.query(word) for word in words]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052956,
                "title": "count-all-prefixes-in-a-hash-map",
                "content": "# Intuition\\nIterate over all the workds x prefixes and create a hashmap of all prefix counts. Then just use that to count the score\\n\\n# Approach\\niterate over all the workds x prefixes and create a hashmap of all prefix counts. Then just use that to count the score\\n\\n# Complexity\\n- Time complexity:\\nO(W x L)\\n\\nW: number of words\\nL: Max length of words\\n\\n- Space complexity:\\nO(W x L)\\n\\nW: number of words\\nL: Max length of words\\n\\n# Code\\n```\\nfunc sumPrefixScores(words []string) []int {\\n    prefixCounts := make(map[string]int)\\n\\n    for _, w := range words {\\n        for i := 1; i <= len(w); i ++ {\\n            prefixCounts[w[:i]]++\\n        }\\n    }\\n\\n    res := make([]int, len(words))\\n\\n    for i, w := range words {\\n        for j := 1; j <= len(w); j ++ {\\n            res[i] += prefixCounts[w[:j]]\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sumPrefixScores(words []string) []int {\\n    prefixCounts := make(map[string]int)\\n\\n    for _, w := range words {\\n        for i := 1; i <= len(w); i ++ {\\n            prefixCounts[w[:i]]++\\n        }\\n    }\\n\\n    res := make([]int, len(words))\\n\\n    for i, w := range words {\\n        for j := 1; j <= len(w); j ++ {\\n            res[i] += prefixCounts[w[:j]]\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3047844,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Node{\\n        Node[] root = new Node[26];\\n        int count = 0;\\n        public void insertCharacter(char ch, Node node)\\n        {\\n            root[ch-\\'a\\'] = node;\\n        }\\n        public Node getNode(char ch)\\n        {\\n            return root[ch-\\'a\\'];\\n        }\\n        public boolean containsNode(char ch){\\n            if(root[ch-\\'a\\'] != null)\\n                return true;\\n            return false;\\n        }\\n    }\\n    class Tries{\\n        Node root = new Node();\\n        public void insertWords(String[] words)\\n        {   \\n            for(String a:words)\\n                insertWord(a);\\n        }\\n        public void insertWord(String word)\\n        {\\n            Node temp = root;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                if(!temp.containsNode(word.charAt(i)))\\n                {\\n                    temp.insertCharacter(word.charAt(i), new Node());\\n                }\\n                temp = temp.getNode(word.charAt(i));\\n                temp.count++;\\n            }\\n\\n        }\\n        public int getCount(String word)\\n        {\\n            int resultCount = 0;\\n            Node temp = root;\\n            for(int i =0;i<word.length();i++)\\n            {\\n                 if(temp.containsNode(word.charAt(i)))\\n                 {\\n                     temp = temp.getNode(word.charAt(i));\\n                     resultCount += temp.count;\\n                 }\\n                 else{\\n                     return resultCount;\\n                 }\\n            }\\n            return resultCount;\\n        }\\n    }\\n    public int[] sumPrefixScores(String[] words) {\\n        Tries tries = new Tries();\\n        tries.insertWords(words);\\n        int[] result = new int[words.length];\\n        for(int i = 0;i<words.length;i++)\\n        {\\n            result[i] = tries.getCount(words[i]);;\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        Node[] root = new Node[26];\\n        int count = 0;\\n        public void insertCharacter(char ch, Node node)\\n        {\\n            root[ch-\\'a\\'] = node;\\n        }\\n        public Node getNode(char ch)\\n        {\\n            return root[ch-\\'a\\'];\\n        }\\n        public boolean containsNode(char ch){\\n            if(root[ch-\\'a\\'] != null)\\n                return true;\\n            return false;\\n        }\\n    }\\n    class Tries{\\n        Node root = new Node();\\n        public void insertWords(String[] words)\\n        {   \\n            for(String a:words)\\n                insertWord(a);\\n        }\\n        public void insertWord(String word)\\n        {\\n            Node temp = root;\\n            for(int i = 0;i<word.length();i++)\\n            {\\n                if(!temp.containsNode(word.charAt(i)))\\n                {\\n                    temp.insertCharacter(word.charAt(i), new Node());\\n                }\\n                temp = temp.getNode(word.charAt(i));\\n                temp.count++;\\n            }\\n\\n        }\\n        public int getCount(String word)\\n        {\\n            int resultCount = 0;\\n            Node temp = root;\\n            for(int i =0;i<word.length();i++)\\n            {\\n                 if(temp.containsNode(word.charAt(i)))\\n                 {\\n                     temp = temp.getNode(word.charAt(i));\\n                     resultCount += temp.count;\\n                 }\\n                 else{\\n                     return resultCount;\\n                 }\\n            }\\n            return resultCount;\\n        }\\n    }\\n    public int[] sumPrefixScores(String[] words) {\\n        Tries tries = new Tries();\\n        tries.insertWords(words);\\n        int[] result = new int[words.length];\\n        for(int i = 0;i<words.length;i++)\\n        {\\n            result[i] = tries.getCount(words[i]);;\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036705,
                "title": "beats-99-trie-solution-python",
                "content": "**Time: O(len(words) * len(word))**\\n**Space: O(len(word) * 26)**\\n```\\ndef sumPrefixScores(self, words: List[str]) -> List[int]:\\n    root = dict()\\n    for w in words:\\n        c_node = root\\n        for ch in w:\\n            if ch not in c_node: c_node[ch] = {\"#\": 0}\\n            c_node = c_node[ch]\\n            c_node[\"#\"] += 1\\n    \\n    res = []\\n    for w in words:\\n        score = 0\\n        c_node = root\\n        for ch in w:\\n            c_node = c_node[ch]\\n            score += c_node[\"#\"]\\n        res.append(score)\\n    \\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\ndef sumPrefixScores(self, words: List[str]) -> List[int]:\\n    root = dict()\\n    for w in words:\\n        c_node = root\\n        for ch in w:\\n            if ch not in c_node: c_node[ch] = {\"#\": 0}\\n            c_node = c_node[ch]\\n            c_node[\"#\"] += 1\\n    \\n    res = []\\n    for w in words:\\n        score = 0\\n        c_node = root\\n        for ch in w:\\n            c_node = c_node[ch]\\n            score += c_node[\"#\"]\\n        res.append(score)\\n    \\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3026747,
                "title": "simple-trie-solution-c",
                "content": "\\n\\n# Code\\n```\\nstruct Trie{\\n    int count;\\n    struct Trie *arr[26];\\n    Trie(){\\n        count=0;\\n        for(int i=0;i<26;i++){\\n            arr[i]=NULL;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void insert(struct Trie *root,string s){\\n        struct Trie *trav=root;\\n        for(char ch:s){\\n            if(trav->arr[ch-97]!=NULL){\\n                trav = trav->arr[ch-97];\\n            }\\n            else{\\n                trav->arr[ch-97]=new Trie();\\n                trav=trav->arr[ch-97];\\n            }\\n            trav->count++;\\n        }\\n    }\\n    void solve(struct Trie *root,string word,int &inward){\\n        struct Trie *trav = root;\\n        for(char ch:word){\\n            trav = trav->arr[ch-97];\\n            inward+=trav->count;\\n        }\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie *root = new Trie();\\n        for(string s:words){\\n            insert(root,s);\\n        }\\n        int n= words.size();\\n        vector<int> result(n,0);\\n        for(int i=0;i<n;i++){\\n            int inward=0;\\n            solve(root,words[i],inward);\\n            result[i]=inward;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Trie"
                ],
                "code": "```\\nstruct Trie{\\n    int count;\\n    struct Trie *arr[26];\\n    Trie(){\\n        count=0;\\n        for(int i=0;i<26;i++){\\n            arr[i]=NULL;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void insert(struct Trie *root,string s){\\n        struct Trie *trav=root;\\n        for(char ch:s){\\n            if(trav->arr[ch-97]!=NULL){\\n                trav = trav->arr[ch-97];\\n            }\\n            else{\\n                trav->arr[ch-97]=new Trie();\\n                trav=trav->arr[ch-97];\\n            }\\n            trav->count++;\\n        }\\n    }\\n    void solve(struct Trie *root,string word,int &inward){\\n        struct Trie *trav = root;\\n        for(char ch:word){\\n            trav = trav->arr[ch-97];\\n            inward+=trav->count;\\n        }\\n    }\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        Trie *root = new Trie();\\n        for(string s:words){\\n            insert(root,s);\\n        }\\n        int n= words.size();\\n        vector<int> result(n,0);\\n        for(int i=0;i<n;i++){\\n            int inward=0;\\n            solve(root,words[i],inward);\\n            result[i]=inward;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018435,
                "title": "created-trie-data-structure-and-storing-the-prefix-count-at-each-node-during-insertion",
                "content": "# Intuition\\nCreated a trie datastructe and added the words. At each node stored the number of words that have reached it during insertion.\\nWhen generating prefix scores, iteratively added the prefix count of the nodes.\\n\\n# Complexity\\n- Time complexity:\\nif the number of words is n and length of each word is m. Then time complexity of insertion is $$O(m*n)$$.\\nThe time complexity of generating the prefix scores is $$O(m*n)$$\\nTherefore worst case time complexity is $$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$ - for creation of Trie data structure.\\n\\n# Code\\n```\\nclass TrieNode:\\n    def __init__(self,):\\n        self.nodes = {}\\n        self.prefix_count = 0\\n        self.is_end = 0\\n\\nclass Trie:\\n    def __init__(self,):\\n        self.root = TrieNode()\\n    def add_word(self, word):\\n        curr_node = self.root\\n        curr_node.prefix_count += 1\\n        for each_char in list(word):\\n            if curr_node.nodes.get(each_char, None) == None:\\n                curr_node.nodes[each_char] = TrieNode()\\n            curr_node = curr_node.nodes[each_char]\\n            curr_node.prefix_count += 1\\n        curr_node.is_end += 1\\n\\n    def add_words(self, words):\\n        for each_word in words:\\n            self.add_word(each_word)\\n    \\n    def get_prefix_count(self, word):\\n        curr_node = self.root\\n        prefix_count = 0\\n        for each_char in list(word):\\n            curr_node = curr_node.nodes[each_char]\\n            prefix_count += curr_node.prefix_count\\n        return prefix_count\\n\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n        trie.add_words(words)\\n        prefix_scores = [trie.get_prefix_count(each_word) for each_word in words]\\n        return prefix_scores\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self,):\\n        self.nodes = {}\\n        self.prefix_count = 0\\n        self.is_end = 0\\n\\nclass Trie:\\n    def __init__(self,):\\n        self.root = TrieNode()\\n    def add_word(self, word):\\n        curr_node = self.root\\n        curr_node.prefix_count += 1\\n        for each_char in list(word):\\n            if curr_node.nodes.get(each_char, None) == None:\\n                curr_node.nodes[each_char] = TrieNode()\\n            curr_node = curr_node.nodes[each_char]\\n            curr_node.prefix_count += 1\\n        curr_node.is_end += 1\\n\\n    def add_words(self, words):\\n        for each_word in words:\\n            self.add_word(each_word)\\n    \\n    def get_prefix_count(self, word):\\n        curr_node = self.root\\n        prefix_count = 0\\n        for each_char in list(word):\\n            curr_node = curr_node.nodes[each_char]\\n            prefix_count += curr_node.prefix_count\\n        return prefix_count\\n\\n\\nclass Solution:\\n    def sumPrefixScores(self, words: List[str]) -> List[int]:\\n        trie = Trie()\\n        trie.add_words(words)\\n        prefix_scores = [trie.get_prefix_count(each_word) for each_word in words]\\n        return prefix_scores\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017111,
                "title": "c-trie",
                "content": "# Code\\n```\\n#define ALPHABETSIZE 26\\nstruct trie_node {\\n\\tint superstring_cnt;\\n\\tstruct trie_node *children[ALPHABETSIZE];\\n\\ttrie_node() {\\n\\t\\tsuperstring_cnt = 0;\\n\\t\\tfor(int i = 0; i < ALPHABETSIZE; ++i) {\\n\\t\\t\\tchildren[i] = nullptr;\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Trie {\\npublic:\\n\\ttrie_node *root;\\n\\tTrie() {\\n\\t\\troot = new trie_node();\\n\\t}\\n\\tvoid insert(string &word) {\\n\\t\\ttrie_node * cur = root;\\n\\t\\tfor(char c : word) {\\n\\t\\t\\tif(cur->children[c-\\'a\\'] == nullptr) {\\n\\t\\t\\t\\tcur->children[c-\\'a\\'] = new trie_node();\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->children[c-\\'a\\'];\\n\\t\\t\\t++cur->superstring_cnt;\\n\\t\\t}\\n\\t}\\n\\tint score(string &prefix) {\\n\\t\\ttrie_node *cur = root;\\n\\t\\tint my_score = 0;\\n\\t\\tfor(char c : prefix) {\\n\\t\\t\\tif(cur == nullptr) break;\\n\\t\\t\\tcur = cur->children[c-\\'a\\'];\\n\\t\\t\\tmy_score += ((cur != nullptr) ? cur->superstring_cnt : 0);\\n\\t\\t}\\n\\t\\treturn my_score;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\tvector<int> sumPrefixScores(vector<string> &words) {\\n\\t\\tTrie t;\\n\\t\\tint n = words.size();\\n\\n\\t\\tfor(string &w : words) {\\n\\t\\t\\tt.insert(w);\\n\\t\\t}\\n\\n\\t\\tunordered_map<string, int> prefix2cnt;\\n\\t\\tvector<int> res(n, 0);\\n\\n\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\tres[i] = t.score(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ALPHABETSIZE 26\\nstruct trie_node {\\n\\tint superstring_cnt;\\n\\tstruct trie_node *children[ALPHABETSIZE];\\n\\ttrie_node() {\\n\\t\\tsuperstring_cnt = 0;\\n\\t\\tfor(int i = 0; i < ALPHABETSIZE; ++i) {\\n\\t\\t\\tchildren[i] = nullptr;\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Trie {\\npublic:\\n\\ttrie_node *root;\\n\\tTrie() {\\n\\t\\troot = new trie_node();\\n\\t}\\n\\tvoid insert(string &word) {\\n\\t\\ttrie_node * cur = root;\\n\\t\\tfor(char c : word) {\\n\\t\\t\\tif(cur->children[c-\\'a\\'] == nullptr) {\\n\\t\\t\\t\\tcur->children[c-\\'a\\'] = new trie_node();\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->children[c-\\'a\\'];\\n\\t\\t\\t++cur->superstring_cnt;\\n\\t\\t}\\n\\t}\\n\\tint score(string &prefix) {\\n\\t\\ttrie_node *cur = root;\\n\\t\\tint my_score = 0;\\n\\t\\tfor(char c : prefix) {\\n\\t\\t\\tif(cur == nullptr) break;\\n\\t\\t\\tcur = cur->children[c-\\'a\\'];\\n\\t\\t\\tmy_score += ((cur != nullptr) ? cur->superstring_cnt : 0);\\n\\t\\t}\\n\\t\\treturn my_score;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\tvector<int> sumPrefixScores(vector<string> &words) {\\n\\t\\tTrie t;\\n\\t\\tint n = words.size();\\n\\n\\t\\tfor(string &w : words) {\\n\\t\\t\\tt.insert(w);\\n\\t\\t}\\n\\n\\t\\tunordered_map<string, int> prefix2cnt;\\n\\t\\tvector<int> res(n, 0);\\n\\n\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\tres[i] = t.score(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017110,
                "title": "c-trie",
                "content": "# Code\\n```\\n#define ALPHABETSIZE 26\\nstruct trie_node {\\n\\tint superstring_cnt;\\n\\tstruct trie_node *children[ALPHABETSIZE];\\n\\ttrie_node() {\\n\\t\\tsuperstring_cnt = 0;\\n\\t\\tfor(int i = 0; i < ALPHABETSIZE; ++i) {\\n\\t\\t\\tchildren[i] = nullptr;\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Trie {\\npublic:\\n\\ttrie_node *root;\\n\\tTrie() {\\n\\t\\troot = new trie_node();\\n\\t}\\n\\tvoid insert(string &word) {\\n\\t\\ttrie_node * cur = root;\\n\\t\\tfor(char c : word) {\\n\\t\\t\\tif(cur->children[c-\\'a\\'] == nullptr) {\\n\\t\\t\\t\\tcur->children[c-\\'a\\'] = new trie_node();\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->children[c-\\'a\\'];\\n\\t\\t\\t++cur->superstring_cnt;\\n\\t\\t}\\n\\t}\\n\\tint score(string &prefix) {\\n\\t\\ttrie_node *cur = root;\\n\\t\\tint my_score = 0;\\n\\t\\tfor(char c : prefix) {\\n\\t\\t\\tif(cur == nullptr) break;\\n\\t\\t\\tcur = cur->children[c-\\'a\\'];\\n\\t\\t\\tmy_score += ((cur != nullptr) ? cur->superstring_cnt : 0);\\n\\t\\t}\\n\\t\\treturn my_score;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\tvector<int> sumPrefixScores(vector<string> &words) {\\n\\t\\tTrie t;\\n\\t\\tint n = words.size();\\n\\n\\t\\tfor(string &w : words) {\\n\\t\\t\\tt.insert(w);\\n\\t\\t}\\n\\n\\t\\tunordered_map<string, int> prefix2cnt;\\n\\t\\tvector<int> res(n, 0);\\n\\n\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\tres[i] = t.score(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ALPHABETSIZE 26\\nstruct trie_node {\\n\\tint superstring_cnt;\\n\\tstruct trie_node *children[ALPHABETSIZE];\\n\\ttrie_node() {\\n\\t\\tsuperstring_cnt = 0;\\n\\t\\tfor(int i = 0; i < ALPHABETSIZE; ++i) {\\n\\t\\t\\tchildren[i] = nullptr;\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Trie {\\npublic:\\n\\ttrie_node *root;\\n\\tTrie() {\\n\\t\\troot = new trie_node();\\n\\t}\\n\\tvoid insert(string &word) {\\n\\t\\ttrie_node * cur = root;\\n\\t\\tfor(char c : word) {\\n\\t\\t\\tif(cur->children[c-\\'a\\'] == nullptr) {\\n\\t\\t\\t\\tcur->children[c-\\'a\\'] = new trie_node();\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->children[c-\\'a\\'];\\n\\t\\t\\t++cur->superstring_cnt;\\n\\t\\t}\\n\\t}\\n\\tint score(string &prefix) {\\n\\t\\ttrie_node *cur = root;\\n\\t\\tint my_score = 0;\\n\\t\\tfor(char c : prefix) {\\n\\t\\t\\tif(cur == nullptr) break;\\n\\t\\t\\tcur = cur->children[c-\\'a\\'];\\n\\t\\t\\tmy_score += ((cur != nullptr) ? cur->superstring_cnt : 0);\\n\\t\\t}\\n\\t\\treturn my_score;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\tvector<int> sumPrefixScores(vector<string> &words) {\\n\\t\\tTrie t;\\n\\t\\tint n = words.size();\\n\\n\\t\\tfor(string &w : words) {\\n\\t\\t\\tt.insert(w);\\n\\t\\t}\\n\\n\\t\\tunordered_map<string, int> prefix2cnt;\\n\\t\\tvector<int> res(n, 0);\\n\\n\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\tres[i] = t.score(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015862,
                "title": "swift-prefix-tree",
                "content": "# Code\\n```\\nclass Solution {\\n    func sumPrefixScores(_ words: [String]) -> [Int] {\\n\\n        let trie = PrefixTree()\\n        for word in words {\\n            trie.insert(word)\\n        }\\n\\n        var answer: [Int] = []\\n\\n        for word in words {\\n            answer.append(trie.search(word))\\n        }\\n\\n        return answer        \\n    }\\n}\\n\\nclass PrefixTreeNode {\\n    var endOfWord = false\\n    var children: [Character: PrefixTreeNode] = [:]\\n    var counter = 0\\n}\\n\\nfinal class PrefixTree {\\n    \\n    let root: PrefixTreeNode\\n    \\n    init() {\\n        self.root = PrefixTreeNode()\\n    }\\n\\n    func insert(_ word: String) {\\n        var curr = root\\n        \\n        for char in word {\\n            \\n            if !curr.children.keys.contains(char) {\\n                 curr.children[char] = PrefixTreeNode()\\n            } \\n\\n            curr.children[char]!.counter += 1\\n            curr = curr.children[char]!\\n        }\\n        curr.endOfWord = true\\n    }\\n\\n    func search(_ word: String) -> Int {\\n        \\n         var curr = root\\n         var counter = 0\\n        \\n        for char in word {\\n            counter += curr.children[char]!.counter\\n            curr = curr.children[char]!\\n        }\\n        \\n        return counter\\n    }\\n}\\n    \\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    func sumPrefixScores(_ words: [String]) -> [Int] {\\n\\n        let trie = PrefixTree()\\n        for word in words {\\n            trie.insert(word)\\n        }\\n\\n        var answer: [Int] = []\\n\\n        for word in words {\\n            answer.append(trie.search(word))\\n        }\\n\\n        return answer        \\n    }\\n}\\n\\nclass PrefixTreeNode {\\n    var endOfWord = false\\n    var children: [Character: PrefixTreeNode] = [:]\\n    var counter = 0\\n}\\n\\nfinal class PrefixTree {\\n    \\n    let root: PrefixTreeNode\\n    \\n    init() {\\n        self.root = PrefixTreeNode()\\n    }\\n\\n    func insert(_ word: String) {\\n        var curr = root\\n        \\n        for char in word {\\n            \\n            if !curr.children.keys.contains(char) {\\n                 curr.children[char] = PrefixTreeNode()\\n            } \\n\\n            curr.children[char]!.counter += 1\\n            curr = curr.children[char]!\\n        }\\n        curr.endOfWord = true\\n    }\\n\\n    func search(_ word: String) -> Int {\\n        \\n         var curr = root\\n         var counter = 0\\n        \\n        for char in word {\\n            counter += curr.children[char]!.counter\\n            curr = curr.children[char]!\\n        }\\n        \\n        return counter\\n    }\\n}\\n    \\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1931713,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "Its quite hard if Trie doesn\\'t cross your mind. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is medium simple trie "
                    },
                    {
                        "username": "noobtuber",
                        "content": "\nclass Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        unordered_map<string, int> m;\n        for(auto i: words){\n            string s = \"\";\n            for(int j=0; j<i.length(); j++){\n                s+= i[j];\n                m[s]++;\n            }\n        }\n        vector<int> ans(words.size());\n        for(int i=0; i<words.size(); i++){\n            int count = 0;\n            string s= \"\";\n            for(int j=0; j<words[i].length(); j++){\n                s+=words[i][j];\n                count+= m[s];\n            }\n            ans[i] = count;\n        }\n        return ans;\n    }\n};\n\nWhy TLE anyone ?"
                    },
                    {
                        "username": "barbatus",
                        "content": "Wondering why it\\'s hard level?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes !! hard tag most of the time gives me anxiety, but I was able to do this is 10-15 mins (which is lower than my average for mediums even), but its also the fact that I had knowledge of Trie prior to solving this, I also have done many problems with Trie... so maybe that\\'s why it wasn\\'t that hard for us ( considering you also must have done some good amount of Trie problems)."
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Java - Memory Limit Exceeded Fix :\\n\\nAs someone mentioned in JavaScript solution, This is fixed by building the trie in groups (words that share first char are in the same group)"
                    },
                    {
                        "username": "Manu2001",
                        "content": "It\\'s tc will be O(M*N) than it is giving TLE\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int>memo;\\n        string curr=\"\";\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                memo[curr]++;\\n            }\\n        }\\n        \\n//         calculation\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                ans[i]+=memo[curr];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Will there be replicated words in the input?"
                    }
                ]
            },
            {
                "id": 2037391,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "Its quite hard if Trie doesn\\'t cross your mind. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is medium simple trie "
                    },
                    {
                        "username": "noobtuber",
                        "content": "\nclass Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        unordered_map<string, int> m;\n        for(auto i: words){\n            string s = \"\";\n            for(int j=0; j<i.length(); j++){\n                s+= i[j];\n                m[s]++;\n            }\n        }\n        vector<int> ans(words.size());\n        for(int i=0; i<words.size(); i++){\n            int count = 0;\n            string s= \"\";\n            for(int j=0; j<words[i].length(); j++){\n                s+=words[i][j];\n                count+= m[s];\n            }\n            ans[i] = count;\n        }\n        return ans;\n    }\n};\n\nWhy TLE anyone ?"
                    },
                    {
                        "username": "barbatus",
                        "content": "Wondering why it\\'s hard level?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes !! hard tag most of the time gives me anxiety, but I was able to do this is 10-15 mins (which is lower than my average for mediums even), but its also the fact that I had knowledge of Trie prior to solving this, I also have done many problems with Trie... so maybe that\\'s why it wasn\\'t that hard for us ( considering you also must have done some good amount of Trie problems)."
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Java - Memory Limit Exceeded Fix :\\n\\nAs someone mentioned in JavaScript solution, This is fixed by building the trie in groups (words that share first char are in the same group)"
                    },
                    {
                        "username": "Manu2001",
                        "content": "It\\'s tc will be O(M*N) than it is giving TLE\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int>memo;\\n        string curr=\"\";\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                memo[curr]++;\\n            }\\n        }\\n        \\n//         calculation\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                ans[i]+=memo[curr];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Will there be replicated words in the input?"
                    }
                ]
            },
            {
                "id": 1953867,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "Its quite hard if Trie doesn\\'t cross your mind. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is medium simple trie "
                    },
                    {
                        "username": "noobtuber",
                        "content": "\nclass Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        unordered_map<string, int> m;\n        for(auto i: words){\n            string s = \"\";\n            for(int j=0; j<i.length(); j++){\n                s+= i[j];\n                m[s]++;\n            }\n        }\n        vector<int> ans(words.size());\n        for(int i=0; i<words.size(); i++){\n            int count = 0;\n            string s= \"\";\n            for(int j=0; j<words[i].length(); j++){\n                s+=words[i][j];\n                count+= m[s];\n            }\n            ans[i] = count;\n        }\n        return ans;\n    }\n};\n\nWhy TLE anyone ?"
                    },
                    {
                        "username": "barbatus",
                        "content": "Wondering why it\\'s hard level?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes !! hard tag most of the time gives me anxiety, but I was able to do this is 10-15 mins (which is lower than my average for mediums even), but its also the fact that I had knowledge of Trie prior to solving this, I also have done many problems with Trie... so maybe that\\'s why it wasn\\'t that hard for us ( considering you also must have done some good amount of Trie problems)."
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Java - Memory Limit Exceeded Fix :\\n\\nAs someone mentioned in JavaScript solution, This is fixed by building the trie in groups (words that share first char are in the same group)"
                    },
                    {
                        "username": "Manu2001",
                        "content": "It\\'s tc will be O(M*N) than it is giving TLE\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int>memo;\\n        string curr=\"\";\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                memo[curr]++;\\n            }\\n        }\\n        \\n//         calculation\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                ans[i]+=memo[curr];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Will there be replicated words in the input?"
                    }
                ]
            },
            {
                "id": 1814272,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "Its quite hard if Trie doesn\\'t cross your mind. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is medium simple trie "
                    },
                    {
                        "username": "noobtuber",
                        "content": "\nclass Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        unordered_map<string, int> m;\n        for(auto i: words){\n            string s = \"\";\n            for(int j=0; j<i.length(); j++){\n                s+= i[j];\n                m[s]++;\n            }\n        }\n        vector<int> ans(words.size());\n        for(int i=0; i<words.size(); i++){\n            int count = 0;\n            string s= \"\";\n            for(int j=0; j<words[i].length(); j++){\n                s+=words[i][j];\n                count+= m[s];\n            }\n            ans[i] = count;\n        }\n        return ans;\n    }\n};\n\nWhy TLE anyone ?"
                    },
                    {
                        "username": "barbatus",
                        "content": "Wondering why it\\'s hard level?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes !! hard tag most of the time gives me anxiety, but I was able to do this is 10-15 mins (which is lower than my average for mediums even), but its also the fact that I had knowledge of Trie prior to solving this, I also have done many problems with Trie... so maybe that\\'s why it wasn\\'t that hard for us ( considering you also must have done some good amount of Trie problems)."
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Java - Memory Limit Exceeded Fix :\\n\\nAs someone mentioned in JavaScript solution, This is fixed by building the trie in groups (words that share first char are in the same group)"
                    },
                    {
                        "username": "Manu2001",
                        "content": "It\\'s tc will be O(M*N) than it is giving TLE\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int>memo;\\n        string curr=\"\";\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                memo[curr]++;\\n            }\\n        }\\n        \\n//         calculation\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                ans[i]+=memo[curr];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Will there be replicated words in the input?"
                    }
                ]
            },
            {
                "id": 1737291,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "Its quite hard if Trie doesn\\'t cross your mind. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is medium simple trie "
                    },
                    {
                        "username": "noobtuber",
                        "content": "\nclass Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        unordered_map<string, int> m;\n        for(auto i: words){\n            string s = \"\";\n            for(int j=0; j<i.length(); j++){\n                s+= i[j];\n                m[s]++;\n            }\n        }\n        vector<int> ans(words.size());\n        for(int i=0; i<words.size(); i++){\n            int count = 0;\n            string s= \"\";\n            for(int j=0; j<words[i].length(); j++){\n                s+=words[i][j];\n                count+= m[s];\n            }\n            ans[i] = count;\n        }\n        return ans;\n    }\n};\n\nWhy TLE anyone ?"
                    },
                    {
                        "username": "barbatus",
                        "content": "Wondering why it\\'s hard level?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes !! hard tag most of the time gives me anxiety, but I was able to do this is 10-15 mins (which is lower than my average for mediums even), but its also the fact that I had knowledge of Trie prior to solving this, I also have done many problems with Trie... so maybe that\\'s why it wasn\\'t that hard for us ( considering you also must have done some good amount of Trie problems)."
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Java - Memory Limit Exceeded Fix :\\n\\nAs someone mentioned in JavaScript solution, This is fixed by building the trie in groups (words that share first char are in the same group)"
                    },
                    {
                        "username": "Manu2001",
                        "content": "It\\'s tc will be O(M*N) than it is giving TLE\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int>memo;\\n        string curr=\"\";\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                memo[curr]++;\\n            }\\n        }\\n        \\n//         calculation\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                ans[i]+=memo[curr];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Will there be replicated words in the input?"
                    }
                ]
            },
            {
                "id": 1707715,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "Its quite hard if Trie doesn\\'t cross your mind. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is medium simple trie "
                    },
                    {
                        "username": "noobtuber",
                        "content": "\nclass Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        unordered_map<string, int> m;\n        for(auto i: words){\n            string s = \"\";\n            for(int j=0; j<i.length(); j++){\n                s+= i[j];\n                m[s]++;\n            }\n        }\n        vector<int> ans(words.size());\n        for(int i=0; i<words.size(); i++){\n            int count = 0;\n            string s= \"\";\n            for(int j=0; j<words[i].length(); j++){\n                s+=words[i][j];\n                count+= m[s];\n            }\n            ans[i] = count;\n        }\n        return ans;\n    }\n};\n\nWhy TLE anyone ?"
                    },
                    {
                        "username": "barbatus",
                        "content": "Wondering why it\\'s hard level?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes !! hard tag most of the time gives me anxiety, but I was able to do this is 10-15 mins (which is lower than my average for mediums even), but its also the fact that I had knowledge of Trie prior to solving this, I also have done many problems with Trie... so maybe that\\'s why it wasn\\'t that hard for us ( considering you also must have done some good amount of Trie problems)."
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Java - Memory Limit Exceeded Fix :\\n\\nAs someone mentioned in JavaScript solution, This is fixed by building the trie in groups (words that share first char are in the same group)"
                    },
                    {
                        "username": "Manu2001",
                        "content": "It\\'s tc will be O(M*N) than it is giving TLE\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int>memo;\\n        string curr=\"\";\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                memo[curr]++;\\n            }\\n        }\\n        \\n//         calculation\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                ans[i]+=memo[curr];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Will there be replicated words in the input?"
                    }
                ]
            },
            {
                "id": 1686010,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "Its quite hard if Trie doesn\\'t cross your mind. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is medium simple trie "
                    },
                    {
                        "username": "noobtuber",
                        "content": "\nclass Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        unordered_map<string, int> m;\n        for(auto i: words){\n            string s = \"\";\n            for(int j=0; j<i.length(); j++){\n                s+= i[j];\n                m[s]++;\n            }\n        }\n        vector<int> ans(words.size());\n        for(int i=0; i<words.size(); i++){\n            int count = 0;\n            string s= \"\";\n            for(int j=0; j<words[i].length(); j++){\n                s+=words[i][j];\n                count+= m[s];\n            }\n            ans[i] = count;\n        }\n        return ans;\n    }\n};\n\nWhy TLE anyone ?"
                    },
                    {
                        "username": "barbatus",
                        "content": "Wondering why it\\'s hard level?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "yes !! hard tag most of the time gives me anxiety, but I was able to do this is 10-15 mins (which is lower than my average for mediums even), but its also the fact that I had knowledge of Trie prior to solving this, I also have done many problems with Trie... so maybe that\\'s why it wasn\\'t that hard for us ( considering you also must have done some good amount of Trie problems)."
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Java - Memory Limit Exceeded Fix :\\n\\nAs someone mentioned in JavaScript solution, This is fixed by building the trie in groups (words that share first char are in the same group)"
                    },
                    {
                        "username": "Manu2001",
                        "content": "It\\'s tc will be O(M*N) than it is giving TLE\\n\\nclass Solution {\\npublic:\\n    vector<int> sumPrefixScores(vector<string>& words) {\\n        unordered_map<string,int>memo;\\n        string curr=\"\";\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                memo[curr]++;\\n            }\\n        }\\n        \\n//         calculation\\n        vector<int>ans(words.size(),0);\\n        for(int i=0;i<words.size();i++){\\n            curr=\"\";\\n            for(int j=0;j<words[i].size();j++){\\n                curr.push_back(words[i][j]);\\n                ans[i]+=memo[curr];\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "MrsMeow",
                        "content": "Will there be replicated words in the input?"
                    }
                ]
            }
        ]
    }
]