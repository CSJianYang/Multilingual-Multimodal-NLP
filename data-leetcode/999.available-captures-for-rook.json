[
    {
        "title": "Available Captures for Rook",
        "question_content": "On an 8 x 8 chessboard, there is exactly one white rook 'R' and some number of white bishops 'B', black pawns 'p', and empty squares '.'.\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered attacking a pawn if the rook can capture the pawn on the rook's turn. The number of available captures for the white rook is the number of pawns that the rook is attacking.\nReturn the number of available captures for the white rook.\n&nbsp;\nExample 1:\n\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation: In this example, the rook is attacking all the pawns.\n\nExample 2:\n\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 0\nExplanation: The bishops are blocking the rook from attacking any of the pawns.\n\nExample 3:\n\nInput: board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation: The rook is attacking the pawns at positions b5, d6, and f5.\n\n&nbsp;\nConstraints:\n\n\tboard.length == 8\n\tboard[i].length == 8\n\tboard[i][j] is either 'R', '.', 'B', or 'p'\n\tThere is exactly one cell with board[i][j] == 'R'",
        "solutions": [
            {
                "id": 242932,
                "title": "java-c-python-straight-forward-solution",
                "content": "## **Explanation**\\n1. Find index of the white rook\\n2. Search in 4 direction until 8 steps or meet any piece.\\n<br>\\n\\n## **Complexity**\\nTime `O(64)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int numRookCaptures(char[][] board) {\\n        int x0 = 0, y0 = 0, res = 0;\\n        for (int i = 0; i < 8; ++i)\\n            for (int j = 0; j < 8; ++j)\\n                if (board[i][j] == \\'R\\') {\\n                    x0 = i;\\n                    y0 = j;\\n                }\\n\\n        for (int[] d : new int[][] {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}) {\\n            for (int x = x0 + d[0], y = y0 + d[1]; 0 <= x && x < 8 && 0 <= y && y < 8; x += d[0], y += d[1]) {\\n                if (board[x][y] == \\'p\\') res++;\\n                if (board[x][y] != \\'.\\') break;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int x0 = 0, y0 = 0, res = 0;\\n        for (int i = 0; i < 8; ++i)\\n            for (int j = 0; j < 8; ++j)\\n                if (board[i][j] == \\'R\\') {\\n                    x0 = i;\\n                    y0 = j;\\n                }\\n        vector<vector<int>> direction = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for (auto d : direction) {\\n            for (int x = x0 + d[0], y = y0 + d[1]; 0 <= x && x < 8 && 0 <= y && y < 8; x += d[0], y += d[1]) {\\n                if (board[x][y] == \\'p\\') res++;\\n                if (board[x][y] != \\'.\\') break;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def numRookCaptures(self, board):\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    x0, y0 = i, j\\n        res = 0\\n        for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n            x, y = x0 + i, y0 + j\\n            while 0 <= x < 8 and 0 <= y < 8:\\n                if board[x][y] == \\'p\\': res += 1\\n                if board[x][y] != \\'.\\': break\\n                x, y = x + i, y + j\\n        return res\\n```\\n\\n**Python obligatory 1-line**\\n```py\\n    def numRookCaptures(self, A):\\n        return sum(\\'\\'.join(r).replace(\\'.\\', \\'\\').count(\\'Rp\\') for r in A + zip(*A) for r in [r, r[::-1]])\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numRookCaptures(char[][] board) {\\n        int x0 = 0, y0 = 0, res = 0;\\n        for (int i = 0; i < 8; ++i)\\n            for (int j = 0; j < 8; ++j)\\n                if (board[i][j] == \\'R\\') {\\n                    x0 = i;\\n                    y0 = j;\\n                }\\n\\n        for (int[] d : new int[][] {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}) {\\n            for (int x = x0 + d[0], y = y0 + d[1]; 0 <= x && x < 8 && 0 <= y && y < 8; x += d[0], y += d[1]) {\\n                if (board[x][y] == \\'p\\') res++;\\n                if (board[x][y] != \\'.\\') break;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int x0 = 0, y0 = 0, res = 0;\\n        for (int i = 0; i < 8; ++i)\\n            for (int j = 0; j < 8; ++j)\\n                if (board[i][j] == \\'R\\') {\\n                    x0 = i;\\n                    y0 = j;\\n                }\\n        vector<vector<int>> direction = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for (auto d : direction) {\\n            for (int x = x0 + d[0], y = y0 + d[1]; 0 <= x && x < 8 && 0 <= y && y < 8; x += d[0], y += d[1]) {\\n                if (board[x][y] == \\'p\\') res++;\\n                if (board[x][y] != \\'.\\') break;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def numRookCaptures(self, board):\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    x0, y0 = i, j\\n        res = 0\\n        for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n            x, y = x0 + i, y0 + j\\n            while 0 <= x < 8 and 0 <= y < 8:\\n                if board[x][y] == \\'p\\': res += 1\\n                if board[x][y] != \\'.\\': break\\n                x, y = x + i, y + j\\n        return res\\n```\n```py\\n    def numRookCaptures(self, A):\\n        return sum(\\'\\'.join(r).replace(\\'.\\', \\'\\').count(\\'Rp\\') for r in A + zip(*A) for r in [r, r[::-1]])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242924,
                "title": "c-java-search-and-capture",
                "content": "Search for the rock. From the rock, trace empty spaces in four directions. Return 1 if we hit a pawn, zero otherwise.\\n\\nCount and return captured pawns.\\n```\\nint cap(vector<vector<char>>& b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.size() && y >= 0 && y < b[x].size() && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx, y += dy;\\n  }\\n  return 0;\\n}\\nint numRookCaptures(vector<vector<char>>& b) {\\n  for (auto i = 0; i < b.size(); ++i)\\n    for (auto j = 0; j < b[i].size(); ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n```\\nJava version:\\n```\\nint cap(char[][] b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.length && y >= 0 && y < b[x].length && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx; y += dy;\\n  }\\n  return 0;\\n}\\npublic int numRookCaptures(char[][] b) {\\n  for (int i = 0; i < b.length; ++i)\\n    for (int j = 0; j < b[i].length; ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n```\\n# Complexity Analysis\\nRuntime: O(n), where n is the total  number of cells. In the worst case, we need to check all cells to find the rock, and then check one row and one column.\\nMemory: O(1).",
                "solutionTags": [],
                "code": "```\\nint cap(vector<vector<char>>& b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.size() && y >= 0 && y < b[x].size() && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx, y += dy;\\n  }\\n  return 0;\\n}\\nint numRookCaptures(vector<vector<char>>& b) {\\n  for (auto i = 0; i < b.size(); ++i)\\n    for (auto j = 0; j < b[i].size(); ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n```\n```\\nint cap(char[][] b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.length && y >= 0 && y < b[x].length && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx; y += dy;\\n  }\\n  return 0;\\n}\\npublic int numRookCaptures(char[][] b) {\\n  for (int i = 0; i < b.length; ++i)\\n    for (int j = 0; j < b[i].length; ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427633,
                "title": "python-solution-with-good-performance",
                "content": "Here is a python solution with good performance:\\n```\\nclass Solution:\\n    def numRookCaptures(self, B: List[List[str]]) -> int:\\n        y, x = next((i, j) for j in range(8) for i in range(8) if B[i][j] == \\'R\\')\\n        row = \\'\\'.join(B[y][j] for j in range(8) if B[y][j] != \\'.\\')\\n        col = \\'\\'.join(B[i][x] for i in range(8) if B[i][x] != \\'.\\')\\n        return sum(\\'Rp\\' in s for s in (row, col)) + sum(\\'pR\\' in s for s in (row, col))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, B: List[List[str]]) -> int:\\n        y, x = next((i, j) for j in range(8) for i in range(8) if B[i][j] == \\'R\\')\\n        row = \\'\\'.join(B[y][j] for j in range(8) if B[y][j] != \\'.\\')\\n        col = \\'\\'.join(B[i][x] for i in range(8) if B[i][x] != \\'.\\')\\n        return sum(\\'Rp\\' in s for s in (row, col)) + sum(\\'pR\\' in s for s in (row, col))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243007,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int[] point = new int[2];\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    point[0] = i;\\n                    point[1] = j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        for(int[] dir : dirs) {\\n            int x = point[0] + dir[0];\\n            int y = point[1] + dir[1];\\n            while(x >= 0 && y >= 0 && x < 8 && y < 8 && board[x][y] == \\'.\\') {\\n                x += dir[0];\\n                y += dir[1];\\n            }\\n            if(x < 0 || y < 0 || x >= 8 || y >= 8) continue;\\n            if(board[x][y] == \\'p\\') count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int[] point = new int[2];\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    point[0] = i;\\n                    point[1] = j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        for(int[] dir : dirs) {\\n            int x = point[0] + dir[0];\\n            int y = point[1] + dir[1];\\n            while(x >= 0 && y >= 0 && x < 8 && y < 8 && board[x][y] == \\'.\\') {\\n                x += dir[0];\\n                y += dir[1];\\n            }\\n            if(x < 0 || y < 0 || x >= 8 || y >= 8) continue;\\n            if(board[x][y] == \\'p\\') count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845795,
                "title": "easiest-solution-c-plus-plus-dfs-simple-approach-u-must-seen-it-will-be-beneficial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust using dfs approach to find all the cases that if at any point of the 4 directions p exists or not if it exists count it and remove it and if B in any of that direction then we returns back and hence by recursion of say dfs we can get our ans \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nplease upvote if it is beneficial or helpfull it will take nothing to upvote but it is very helpful for me .........\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void solve(vector<vector<char>> &board,int sr,int sc,char ch){\\n        if(sr>=board.size() || sc>= board[0].size() || sr<0 || sc<0 || board[sr][sc]==\\'B\\')    \\n            return;\\n        if(board[sr][sc]==\\'p\\'){\\n            count++;\\n            return;\\n        }\\n        if(board[sr][sc]==\\'.\\'){\\n            if(ch==\\'u\\') solve(board,sr-1,sc,\\'u\\');\\n            if(ch==\\'d\\') solve(board,sr+1,sc,\\'d\\');\\n            if(ch==\\'l\\') solve(board,sr,sc-1,\\'l\\');\\n            if(ch==\\'r\\') solve(board,sr,sc+1,\\'r\\');\\n        }\\n        \\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==\\'R\\'){ \\n                    solve(board,i-1,j,\\'u\\');\\n                    solve(board,i+1,j,\\'d\\');\\n                    solve(board,i,j-1,\\'l\\');\\n                    solve(board,i,j+1,\\'r\\');\\n                    break;\\n                }\\n            }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nplease upvote if it is beneficial or helpfull it will take nothing to upvote but it is very helpful for me .........\\n```\n```\\nclass Solution {\\npublic:\\n    int count=0;\\n    void solve(vector<vector<char>> &board,int sr,int sc,char ch){\\n        if(sr>=board.size() || sc>= board[0].size() || sr<0 || sc<0 || board[sr][sc]==\\'B\\')    \\n            return;\\n        if(board[sr][sc]==\\'p\\'){\\n            count++;\\n            return;\\n        }\\n        if(board[sr][sc]==\\'.\\'){\\n            if(ch==\\'u\\') solve(board,sr-1,sc,\\'u\\');\\n            if(ch==\\'d\\') solve(board,sr+1,sc,\\'d\\');\\n            if(ch==\\'l\\') solve(board,sr,sc-1,\\'l\\');\\n            if(ch==\\'r\\') solve(board,sr,sc+1,\\'r\\');\\n        }\\n        \\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++){\\n                if(board[i][j]==\\'R\\'){ \\n                    solve(board,i-1,j,\\'u\\');\\n                    solve(board,i+1,j,\\'d\\');\\n                    solve(board,i,j-1,\\'l\\');\\n                    solve(board,i,j+1,\\'r\\');\\n                    break;\\n                }\\n            }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415596,
                "title": "java-easy-to-understand-solution-beats-100",
                "content": "```\\npublic int numRookCaptures(char[][] board) {\\n\\tint row = -1, col = -1;    \\n\\tint captures = 0;\\n\\tfor(int i=0; i<8; i++) {\\n\\t\\tfor(int j=0; j<8; j++) {\\n\\t\\t\\tif(board[i][j]==\\'R\\') {\\n\\t\\t\\t\\trow = i;\\n\\t\\t\\t\\tcol = j;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=col-1; i>0; i--) {\\n\\t\\tif(board[row][i]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[row][i]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=col+1; i<8; i++) {\\n\\t\\tif(board[row][i]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[row][i]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=row-1; i>0; i--) {\\n\\t\\tif(board[i][col]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[i][col]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=row+1; i<8; i++) {\\n\\t\\tif(board[i][col]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[i][col]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn captures;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numRookCaptures(char[][] board) {\\n\\tint row = -1, col = -1;    \\n\\tint captures = 0;\\n\\tfor(int i=0; i<8; i++) {\\n\\t\\tfor(int j=0; j<8; j++) {\\n\\t\\t\\tif(board[i][j]==\\'R\\') {\\n\\t\\t\\t\\trow = i;\\n\\t\\t\\t\\tcol = j;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=col-1; i>0; i--) {\\n\\t\\tif(board[row][i]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[row][i]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=col+1; i<8; i++) {\\n\\t\\tif(board[row][i]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[row][i]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=row-1; i>0; i--) {\\n\\t\\tif(board[i][col]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[i][col]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tfor(int i=row+1; i<8; i++) {\\n\\t\\tif(board[i][col]==\\'p\\') {\\n\\t\\t\\tcaptures++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse if (board[i][col]==\\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn captures;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244639,
                "title": "js-concise-and-easy-to-understand-solution",
                "content": "```\\nconst canCapture = (board, i, j) => {\\n    let captures = 0, dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    \\n    for (let dir of dirs) {\\n        let r = i + dir[0], c = j + dir[1];\\n            \\n        while (r >= 0 && r < 8 && c >= 0 && c < 8) {\\n            if (board[r][c] === \\'p\\') { captures++; }\\n            if (board[r][c] !== \\'.\\') { break; }\\n            \\n            r += dir[0];\\n            c += dir[1];\\n        }\\n    }\\n    \\n    return captures;\\n}\\n\\nconst numRookCaptures = board => {\\n    for (let i = 0; i < 8; i++) {\\n        for (let j = 0; j < 8; j++) {\\n            if (board[i][j] === \\'R\\') {\\n                return canCapture(board, i, j);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst canCapture = (board, i, j) => {\\n    let captures = 0, dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n    \\n    for (let dir of dirs) {\\n        let r = i + dir[0], c = j + dir[1];\\n            \\n        while (r >= 0 && r < 8 && c >= 0 && c < 8) {\\n            if (board[r][c] === \\'p\\') { captures++; }\\n            if (board[r][c] !== \\'.\\') { break; }\\n            \\n            r += dir[0];\\n            c += dir[1];\\n        }\\n    }\\n    \\n    return captures;\\n}\\n\\nconst numRookCaptures = board => {\\n    for (let i = 0; i < 8; i++) {\\n        for (let j = 0; j < 8; j++) {\\n            if (board[i][j] === \\'R\\') {\\n                return canCapture(board, i, j);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354637,
                "title": "python-3-not-the-shortest-but-neat-and-easy-to-understand",
                "content": "The idea is to find the Rook location and then start looking at 4 directions to find nearest piece. Check if the nearest piece is friend or foe using `isupper()`, `islower()`. \\nRuntime varies from 48 ms (14%) to 32 ms (96%) so i guess it\\'s good enough. Anyways, the most important thing is it\\'s easy to understand\\n```python\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        def check_direction(R,C,direction):\\n            if direction==\"right\":\\n                for col in range(C+1,8): # increasing col \\n                    if board[R][col].islower():return 1\\n                    if board[R][col].isupper():return 0\\n            if direction==\"left\":\\n                for col in range(C-1,-1,-1): # decreasing col \\n                    if board[R][col].islower():return 1\\n                    if board[R][col].isupper():return 0\\n            if direction==\"down\":\\n                for row in range(R+1,8): # increasing row\\n                    if board[row][C].islower():return 1\\n                    if board[row][C].isupper():return 0\\n            if direction==\"up\": \\n                for row in range(R-1,-1,-1): # decreasing col \\n                    if board[row][C].islower():return 1\\n                    if board[row][C].isupper():return 0\\n            return 0 # we reach the edge (nothing was found)\\n                    \\n        for row in range(8):\\n            for col in range(8):\\n                if board[row][col]==\"R\":\\n\\t\\t\\t\\t\\t# sum all directions up\\n                    return sum([check_direction(row,col,\"right\"),\\n                                check_direction(row,col,\"left\"),\\n                                check_direction(row,col,\"up\"),\\n                                check_direction(row,col,\"down\")])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        def check_direction(R,C,direction):\\n            if direction==\"right\":\\n                for col in range(C+1,8): # increasing col \\n                    if board[R][col].islower():return 1\\n                    if board[R][col].isupper():return 0\\n            if direction==\"left\":\\n                for col in range(C-1,-1,-1): # decreasing col \\n                    if board[R][col].islower():return 1\\n                    if board[R][col].isupper():return 0\\n            if direction==\"down\":\\n                for row in range(R+1,8): # increasing row\\n                    if board[row][C].islower():return 1\\n                    if board[row][C].isupper():return 0\\n            if direction==\"up\": \\n                for row in range(R-1,-1,-1): # decreasing col \\n                    if board[row][C].islower():return 1\\n                    if board[row][C].isupper():return 0\\n            return 0 # we reach the edge (nothing was found)\\n                    \\n        for row in range(8):\\n            for col in range(8):\\n                if board[row][col]==\"R\":\\n\\t\\t\\t\\t\\t# sum all directions up\\n                    return sum([check_direction(row,col,\"right\"),\\n                                check_direction(row,col,\"left\"),\\n                                check_direction(row,col,\"up\"),\\n                                check_direction(row,col,\"down\")])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198090,
                "title": "c-runtime-0-ms-faster-than-100-00-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int cap=0,row,col;\\n\\t\\t//Find the position of the rook\\n        for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(board[i][j]==\\'R\\'){\\n                    row=i;\\n                    col=j;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Move in upward direction to check for any possible captures\\n        int i=row,j=col;\\n        while(i>=0 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            i--;\\n        }\\n\\t\\t\\n\\t\\t//Move in downward direction to check for any possible captures\\n        i=row,j=col;\\n        while(i<=7 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            i++;\\n        }\\n\\t\\t\\n\\t\\t//Move in leftward direction to check for any possible captures\\n        i=row,j=col;\\n        while(j>=0 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            j--;\\n        }\\n\\t\\t\\n\\t\\t//Move in rightward direction to check for any possible captures\\n        i=row,j=col;\\n        while(j<=7 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }\\n            j++;\\n        }\\n        \\n        return cap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int cap=0,row,col;\\n\\t\\t//Find the position of the rook\\n        for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(board[i][j]==\\'R\\'){\\n                    row=i;\\n                    col=j;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Move in upward direction to check for any possible captures\\n        int i=row,j=col;\\n        while(i>=0 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            i--;\\n        }\\n\\t\\t\\n\\t\\t//Move in downward direction to check for any possible captures\\n        i=row,j=col;\\n        while(i<=7 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            i++;\\n        }\\n\\t\\t\\n\\t\\t//Move in leftward direction to check for any possible captures\\n        i=row,j=col;\\n        while(j>=0 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }            \\n            j--;\\n        }\\n\\t\\t\\n\\t\\t//Move in rightward direction to check for any possible captures\\n        i=row,j=col;\\n        while(j<=7 && board[i][j]!=\\'B\\'){\\n            if(board[i][j]==\\'p\\'){\\n                cap++;\\n                break;\\n            }\\n            j++;\\n        }\\n        \\n        return cap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356593,
                "title": "solution-in-python-3-beats-97-three-lines",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, b: List[List[str]]) -> int:\\n        I, J = divmod(sum(b,[]).index(\\'R\\'),8)\\n        C = \"\".join([i for i in [b[I]+[\\'B\\']+[b[i][J] for i in range(8)]][0] if i != \\'.\\'])\\n        return C.count(\\'Rp\\') + C.count(\\'pR\\')\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, b: List[List[str]]) -> int:\\n        I, J = divmod(sum(b,[]).index(\\'R\\'),8)\\n        C = \"\".join([i for i in [b[I]+[\\'B\\']+[b[i][J] for i in range(8)]][0] if i != \\'.\\'])\\n        return C.count(\\'Rp\\') + C.count(\\'pR\\')\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 244129,
                "title": "javascript-solution",
                "content": "```\\nfunction findRook(board) {\\n\\tfor (let i = 0; i < board.length; i++) {\\n\\t\\tfor (let j = 0; j < board[i].length; j++) {\\n\\t\\t\\tif (board[i][j] === \\'R\\') {\\n\\t\\t\\t\\treturn {i, j};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction checkRight(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (j === board[i].length - 1) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tj++;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkLeft(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (j === 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tj--;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkTop(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (i === 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\ti--;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkDown(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (i === board.length - 1) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\ti++;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nlet numRookCaptures = function(board) {\\n\\tlet rook = findRook(board);\\n\\tlet counter = 0;\\n\\n\\tcounter += checkRight(board, rook.i, rook.j);\\n\\tcounter += checkLeft(board, rook.i, rook.j);\\n\\tcounter += checkTop(board, rook.i, rook.j);\\n\\tcounter += checkDown(board, rook.i, rook.j);\\n\\n\\treturn counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findRook(board) {\\n\\tfor (let i = 0; i < board.length; i++) {\\n\\t\\tfor (let j = 0; j < board[i].length; j++) {\\n\\t\\t\\tif (board[i][j] === \\'R\\') {\\n\\t\\t\\t\\treturn {i, j};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction checkRight(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (j === board[i].length - 1) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tj++;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkLeft(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (j === 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tj--;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkTop(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (i === 0) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\ti--;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nfunction checkDown(board, i, j) {\\n\\tlet counter = 0;\\n\\n\\twhile (true) {\\n\\t\\tif (board[i][j] === \\'B\\') {\\n\\t\\t\\tbreak;\\n\\t\\t} else if (board[i][j] === \\'p\\') {\\n\\t\\t\\tcounter++;\\n\\t\\t\\tbreak;\\n\\t\\t} else if (i === board.length - 1) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\ti++;\\n\\t}\\n\\n\\treturn counter;\\n}\\n\\nlet numRookCaptures = function(board) {\\n\\tlet rook = findRook(board);\\n\\tlet counter = 0;\\n\\n\\tcounter += checkRight(board, rook.i, rook.j);\\n\\tcounter += checkLeft(board, rook.i, rook.j);\\n\\tcounter += checkTop(board, rook.i, rook.j);\\n\\tcounter += checkDown(board, rook.i, rook.j);\\n\\n\\treturn counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244315,
                "title": "simple-python-6-lines-and-2-lines",
                "content": "```python\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n    # find \\'R\\'\\n    for row in range(8):\\n        for col in range(8):\\n            if board[row][col] == \\'R\\':\\n\\t\\t\\t    # build two strings for the raw and the column\\n                r = \\'\\'.join(x for x in board[row] if x != \\'.\\')\\n                c = \\'\\'.join(board[i][col] for i in range(8) if board[i][col] != \\'.\\')\\n\\t\\t\\t\\t# count the number of \\'Rp\\' substring \\n                return sum(\\'Rp\\' in x for x in (r, r[::-1], c, c[::-1]))\\n```\\n\\nor, we can go even further, and skip finding part, just convert all rows and columns to string:\\n```python\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n\\tlines = [\\'\\'.join(x for x in row if x != \\'.\\') for row in itertools.chain(board, zip(*board))]\\n\\treturn sum(\\'Rp\\' in x for x in lines) + sum(\\'pR\\' in x for x in lines)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n    # find \\'R\\'\\n    for row in range(8):\\n        for col in range(8):\\n            if board[row][col] == \\'R\\':\\n\\t\\t\\t    # build two strings for the raw and the column\\n                r = \\'\\'.join(x for x in board[row] if x != \\'.\\')\\n                c = \\'\\'.join(board[i][col] for i in range(8) if board[i][col] != \\'.\\')\\n\\t\\t\\t\\t# count the number of \\'Rp\\' substring \\n                return sum(\\'Rp\\' in x for x in (r, r[::-1], c, c[::-1]))\\n```\n```python\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n\\tlines = [\\'\\'.join(x for x in row if x != \\'.\\') for row in itertools.chain(board, zip(*board))]\\n\\treturn sum(\\'Rp\\' in x for x in lines) + sum(\\'pR\\' in x for x in lines)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 955527,
                "title": "python-simple-to-understand",
                "content": "\\'\\'\\'class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        count = 0\\n\\n        for i in range(len(board)):\\n            x = \"\".join(board[i]).replace(\\'.\\', \\'\\')\\n            if \\'Rp\\' in x:\\n                count += 1\\n            if \\'pR\\' in x:\\n                count += 1\\n\\n        board = list(zip(*board))\\n\\n        for i in range(len(board)):\\n            x = \"\".join(board[i]).replace(\\'.\\', \\'\\')\\n            if \\'Rp\\' in x:\\n                count += 1\\n            if \\'pR\\' in x:\\n                count += 1  \\n\\n        return count\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        count = 0\\n\\n        for i in range(len(board)):\\n            x = \"\".join(board[i]).replace(\\'.\\', \\'\\')\\n            if \\'Rp\\' in x:\\n                count += 1\\n            if \\'pR\\' in x:\\n                count += 1\\n\\n        board = list(zip(*board))\\n\\n        for i in range(len(board)):\\n            x = \"\".join(board[i]).replace(\\'.\\', \\'\\')\\n            if \\'Rp\\' in x:\\n                count += 1\\n            if \\'pR\\' in x:\\n                count += 1  \\n\\n        return count\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 765433,
                "title": "c-very-easy-for-beginners-with-explanation",
                "content": "We will first find the location of our rook.\\nNow, we know that max number of captures a rook can make is 4 (Top +Down+ Left+ Right). Now we just have to iterate four times in these directions starting from the rook\\'s coordinates.\\n\\nThere are 3 possibilities:\\n1. We come across a pawn first: In this case, the capture in this direction increases by 1\\n2. We come across a bishop first: in this case, no capture can be done in this direction as bishop is blocking further moves\\n3. We don\\'t come across any piece: In this case, we just use our default(zero) value\\n\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int T=0,D=0,L=0,R=0;\\n        int posX,posY;\\n        for (auto i=0;i<8;i++)\\n            for (auto j=0;j<8;j++)\\n                if(board[i][j]==\\'R\\') {\\n                    posX = i;\\n                    posY = j;\\n                    break;\\n                }\\n        \\n        int x,y;  // x - to traverse rows; y - to traverse columns\\n        x=posX;\\n        y=posY;\\n        while(--x>0) {\\n            if(board[x][y]==\\'p\\') {\\n                T = 1;\\n                break;\\n            }\\n            else if(board[x][y]==\\'B\\') \\n            break;\\n            \\n        }\\n        \\n        x=posX;\\n        y=posY;\\n        while(++x<8) {\\n            if(board[x][y]==\\'p\\') {\\n                D = 1;\\n                break;\\n            }\\n            else if(board[x][y]==\\'B\\')\\n                break;\\n        }\\n        \\n        x=posX;\\n        y=posY;\\n        while(--y>0) {\\n            if(board[x][y]==\\'p\\') {\\n                L = 1;\\n                break;\\n            }\\n            else if(board[x][y]==\\'B\\')\\n                break;\\n        }\\n        \\n        x=posX;\\n        y=posY;\\n        while(++y<8) {\\n            if(board[x][y]==\\'p\\') {\\n                R = 1;\\n                break;\\n            }\\n            else if(board[x][y]==\\'B\\')\\n                break;\\n        }\\n        \\n        return (T+D+L+R);\\n                    \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int T=0,D=0,L=0,R=0;\\n        int posX,posY;\\n        for (auto i=0;i<8;i++)\\n            for (auto j=0;j<8;j++)\\n                if(board[i][j]==\\'R\\') {\\n                    posX = i;\\n                    posY = j;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 384165,
                "title": "javascript-easy-to-understand-36ms",
                "content": "- Traversal the whole chessboard to find the position of rook\\n- Check the 4 directions and counting pawns\\n\\n```js\\nconst numRookCaptures = board => {\\n  let x, y;\\n  let ret = 0;\\n  for (let i = 0; i < 8; ++i) {\\n    for (let j = 0; j < 8; ++j) {\\n      if (board[i][j] === \\'R\\') {\\n        x = i;\\n        y = j;\\n      }\\n    }\\n  }\\n  for (let i = x + 1; i < 8; ++i) {\\n    if (board[i][y] === \\'B\\') break;\\n    if (board[i][y] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = x - 1; i >= 0; --i) {\\n    if (board[i][y] === \\'B\\') break;\\n    if (board[i][y] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = y + 1; i < 8; ++i) {\\n    if (board[x][i] === \\'B\\') break;\\n    if (board[x][i] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = y - 1; i >= 0; --i) {\\n    if (board[x][i] === \\'B\\') break;\\n    if (board[x][i] === \\'p\\') { ++ret; break; }\\n  }\\n  return ret;\\n};\\n```\\n\\nActually, we can do the check for each direction through a loop. The code is like:\\n\\n```js\\nconst numRookCaptures = board => {\\n  let x, y;\\n  let ret = 0;\\n  for (let i = 0; i < 8; ++i) {\\n    for (let j = 0; j < 8; ++j) {\\n      if (board[i][j] === \\'R\\') {\\n        x = i;\\n        y = j;\\n      }\\n    }\\n  }\\n\\n  for (const [xo, yo] of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {\\n    for (let i = x + xo, j = y + yo; i < 8 && i >= 0 && j < 8 && j >= 0; i += xo, j += yo) {\\n      if (board[i][j] === \"B\") break;\\n      if (board[i][j] === \"p\") { ++ret; break; }\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst numRookCaptures = board => {\\n  let x, y;\\n  let ret = 0;\\n  for (let i = 0; i < 8; ++i) {\\n    for (let j = 0; j < 8; ++j) {\\n      if (board[i][j] === \\'R\\') {\\n        x = i;\\n        y = j;\\n      }\\n    }\\n  }\\n  for (let i = x + 1; i < 8; ++i) {\\n    if (board[i][y] === \\'B\\') break;\\n    if (board[i][y] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = x - 1; i >= 0; --i) {\\n    if (board[i][y] === \\'B\\') break;\\n    if (board[i][y] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = y + 1; i < 8; ++i) {\\n    if (board[x][i] === \\'B\\') break;\\n    if (board[x][i] === \\'p\\') { ++ret; break; }\\n  }\\n  for (let i = y - 1; i >= 0; --i) {\\n    if (board[x][i] === \\'B\\') break;\\n    if (board[x][i] === \\'p\\') { ++ret; break; }\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst numRookCaptures = board => {\\n  let x, y;\\n  let ret = 0;\\n  for (let i = 0; i < 8; ++i) {\\n    for (let j = 0; j < 8; ++j) {\\n      if (board[i][j] === \\'R\\') {\\n        x = i;\\n        y = j;\\n      }\\n    }\\n  }\\n\\n  for (const [xo, yo] of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {\\n    for (let i = x + xo, j = y + yo; i < 8 && i >= 0 && j < 8 && j >= 0; i += xo, j += yo) {\\n      if (board[i][j] === \"B\") break;\\n      if (board[i][j] === \"p\") { ++ret; break; }\\n    }\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1149526,
                "title": "java-runtime-0ms-faster-than-100-memory-less-than-97-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        //loop through the board and fin dthe position of the Rook\\n        //Once we found the position, \\n        //Go Up, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Down, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Left, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Right, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //return the sum of counts.\\n        \\n        int result = 0;\\n        //Looping the board to find the position of \\'R\\'\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    result+=goUp(board, i, j)?1:0;\\n                    result+=goDown(board, i, j)?1:0;\\n                    result+=goLeft(board, i, j)?1:0;\\n                    result+=goRight(board, i, j)?1:0;\\n                    return result;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    //Check by moving up, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goUp(char[][] board, int row, int column){\\n        for(int i= row; i>=0; i--){\\n            if(board[i][column] == \\'p\\'){\\n                return true;\\n            }else if(board[i][column] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving down, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goDown(char[][] board, int row, int column){\\n        for(int i= row; i<board.length; i++){\\n            if(board[i][column] == \\'p\\'){\\n                return true;\\n            }else if(board[i][column] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving left, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goLeft(char[][] board, int row, int column){\\n        for(int i= column; i>=0; i--){\\n            if(board[row][i] == \\'p\\'){\\n                return true;\\n            }else if(board[row][i] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving right, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goRight(char[][] board, int row, int column){\\n        for(int i= column; i<board[0].length; i++){\\n            if(board[row][i] == \\'p\\'){\\n                return true;\\n            }else if(board[row][i] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        //loop through the board and fin dthe position of the Rook\\n        //Once we found the position, \\n        //Go Up, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Down, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Left, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //Go Right, to check if there is a bishop in between Rook and pawn, if no count 1\\n        //return the sum of counts.\\n        \\n        int result = 0;\\n        //Looping the board to find the position of \\'R\\'\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    result+=goUp(board, i, j)?1:0;\\n                    result+=goDown(board, i, j)?1:0;\\n                    result+=goLeft(board, i, j)?1:0;\\n                    result+=goRight(board, i, j)?1:0;\\n                    return result;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    //Check by moving up, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goUp(char[][] board, int row, int column){\\n        for(int i= row; i>=0; i--){\\n            if(board[i][column] == \\'p\\'){\\n                return true;\\n            }else if(board[i][column] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving down, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goDown(char[][] board, int row, int column){\\n        for(int i= row; i<board.length; i++){\\n            if(board[i][column] == \\'p\\'){\\n                return true;\\n            }else if(board[i][column] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving left, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goLeft(char[][] board, int row, int column){\\n        for(int i= column; i>=0; i--){\\n            if(board[row][i] == \\'p\\'){\\n                return true;\\n            }else if(board[row][i] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    //Check by moving right, if \\'B\\' is in between \\'R\\' and \\'p\\'return false else return true\\n    public boolean goRight(char[][] board, int row, int column){\\n        for(int i= column; i<board[0].length; i++){\\n            if(board[row][i] == \\'p\\'){\\n                return true;\\n            }else if(board[row][i] == \\'B\\'){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503766,
                "title": "javascript-1-line-regex-solution",
                "content": "I took another stab at it after my last solution had an issue but still gave correct answers.\\n\\nI had other 1-line solutions but wasn\\'t happy with the regex part. So I shifted the complexity from the regex to more string/array operations. This way makes more sense to me.\\n\\n_Runtime: 60 ms, faster than 53.99% of JavaScript online submissions_\\n_Memory Usage: 33.3 MB, less than 80.17% of JavaScript online submissions_\\n\\n```javascript\\n/**\\n * @param {string[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board =>\\n  [\\n    board\\n      .map(row => row.join(\\'\\'))\\n      .join(\\'\\')\\n      .indexOf(\\'R\\'),\\n  ]\\n    .reduce(\\n      (_, rIndex) => [\\n        ...board[Math.trunc(rIndex / 8)]\\n          .join(\\'\\')\\n          .split(\\'R\\')\\n          .reduce((left, right) => [left, [...right].reverse().join(\\'\\')]),\\n        ...board\\n          .reduce((col, row) => (col += row[rIndex % 8]), \\'\\')\\n          .split(\\'R\\')\\n          .reduce((up, down) => [up, [...down].reverse().join(\\'\\')]),\\n      ],\\n      null,\\n    )\\n    .reduce((acc, curr) => acc + (/p\\\\.*$/.test(curr) ? 1 : 0), 0);\\n```\\n\\n_Runtime: 68 ms, faster than 30.67% of JavaScript online submissions_\\n_Memory Usage: 33 MB, less than 87.93% of JavaScript online submissions_\\n\\n```javascript\\n/**\\n * @param {string[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board => {\\n  const [rows, cols] = [new Array(8).fill(\\'\\'), new Array(8).fill(\\'\\')];\\n  let rookRow, rookCol;\\n  for (let i = 0; i < 8; i++)\\n    for (let j = 0; j < 8; j++) {\\n      rows[i] += board[i][j];\\n      cols[i] += board[j][i];\\n      if (\\'R\\' === board[i][j]) [rookRow, rookCol] = [i, j];\\n    }\\n  let captures = 0;\\n  /* Look left  */ if (/p\\\\.*R/.test(rows[rookRow])) captures++;\\n  /* Look right */ if (/R\\\\.*p/.test(rows[rookRow])) captures++;\\n  /* Look up    */ if (/p\\\\.*R/.test(cols[rookCol])) captures++;\\n  /* Look down  */ if (/R\\\\.*p/.test(cols[rookCol])) captures++;\\n  return captures;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board =>\\n  [\\n    board\\n      .map(row => row.join(\\'\\'))\\n      .join(\\'\\')\\n      .indexOf(\\'R\\'),\\n  ]\\n    .reduce(\\n      (_, rIndex) => [\\n        ...board[Math.trunc(rIndex / 8)]\\n          .join(\\'\\')\\n          .split(\\'R\\')\\n          .reduce((left, right) => [left, [...right].reverse().join(\\'\\')]),\\n        ...board\\n          .reduce((col, row) => (col += row[rIndex % 8]), \\'\\')\\n          .split(\\'R\\')\\n          .reduce((up, down) => [up, [...down].reverse().join(\\'\\')]),\\n      ],\\n      null,\\n    )\\n    .reduce((acc, curr) => acc + (/p\\\\.*$/.test(curr) ? 1 : 0), 0);\\n```\n```javascript\\n/**\\n * @param {string[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board => {\\n  const [rows, cols] = [new Array(8).fill(\\'\\'), new Array(8).fill(\\'\\')];\\n  let rookRow, rookCol;\\n  for (let i = 0; i < 8; i++)\\n    for (let j = 0; j < 8; j++) {\\n      rows[i] += board[i][j];\\n      cols[i] += board[j][i];\\n      if (\\'R\\' === board[i][j]) [rookRow, rookCol] = [i, j];\\n    }\\n  let captures = 0;\\n  /* Look left  */ if (/p\\\\.*R/.test(rows[rookRow])) captures++;\\n  /* Look right */ if (/R\\\\.*p/.test(rows[rookRow])) captures++;\\n  /* Look up    */ if (/p\\\\.*R/.test(cols[rookCol])) captures++;\\n  /* Look down  */ if (/R\\\\.*p/.test(cols[rookCol])) captures++;\\n  return captures;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1604440,
                "title": "very-easy-solution-c",
                "content": "**Idea :  We move in 4 direction from the current \\'R\\' row number and col number, and stop when we encounter \\'p\\' if we see \\'B\\' we can\\'t able to move \\'R\\', and also if there is no \\'p\\' and \\'B\\' in the direction in which \\'R\\' is moving , it will stop till the end of chess grid.**\\n\\n- So, we create four functions to move in the direction named as - left(),right(),up(),down();\\n- In the functions parameters are board as reference and \\'R\\' row number and col number to move up,down,left,right from that row or col.\\n\\n```\\nclass Solution {\\n    int up(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        while(row>=0){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            row--;\\n        }\\n        return ans;\\n    }\\n    \\n    int down(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        int totalRows = board.size();\\n        while(row < totalRows){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            row++;\\n        }\\n        return ans;\\n    }\\n    \\n    int right(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        int totalColumn = board[0].size();\\n        while(col < totalColumn){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            col++;\\n        }\\n        return ans;\\n    }\\n    \\n    int left(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        while(col >= 0){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            col--;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int rows = board.size();\\n        int cols = board[0].size();\\n        int ans = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int l,r,u,d;\\n                    l = left(board,i,j);\\n                    r = right(board,i,j);\\n                    u = up(board,i,j);\\n                    d = down(board,i,j);\\n                    ans = l + r + u + d;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***Upvote, if you like the solution approach.***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int up(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        while(row>=0){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            row--;\\n        }\\n        return ans;\\n    }\\n    \\n    int down(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        int totalRows = board.size();\\n        while(row < totalRows){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            row++;\\n        }\\n        return ans;\\n    }\\n    \\n    int right(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        int totalColumn = board[0].size();\\n        while(col < totalColumn){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            col++;\\n        }\\n        return ans;\\n    }\\n    \\n    int left(vector<vector<char>>& board,int row,int col){\\n        int ans = 0;\\n        while(col >= 0){\\n            if(board[row][col] == \\'p\\'){\\n                ans++;break;\\n            }\\n            else if(board[row][col] == \\'B\\') break;\\n            col--;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int rows = board.size();\\n        int cols = board[0].size();\\n        int ans = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int l,r,u,d;\\n                    l = left(board,i,j);\\n                    r = right(board,i,j);\\n                    u = up(board,i,j);\\n                    d = down(board,i,j);\\n                    ans = l + r + u + d;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601678,
                "title": "python-3-easy-to-understand-faster-than-96",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        n = 8\\n        for i in range(n):  # find rook location\\n            for j in range(n):\\n                if board[i][j] == \\'R\\':\\n                    x, y = i, j\\n                    break\\n        \\n        res = 0\\n        for i in range(x-1, -1, -1):  # check north\\n            if board[i][y] == \\'p\\':\\n                res += 1\\n                break\\n            if board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, n):  # check south\\n            if board[i][y] == \\'p\\':\\n                res += 1\\n                break\\n            if board[i][y] == \\'B\\':\\n                break\\n        \\n        for j in range(y-1, -1, -1):  # check west\\n            if board[x][j] == \\'p\\':\\n                res += 1\\n                break\\n            if board[x][j] == \\'B\\':\\n                break\\n        \\n        for j in range(y+1, n):  # check east\\n            if board[x][j] == \\'p\\':\\n                res += 1\\n                break\\n            if board[x][j] == \\'B\\':\\n                break\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        n = 8\\n        for i in range(n):  # find rook location\\n            for j in range(n):\\n                if board[i][j] == \\'R\\':\\n                    x, y = i, j\\n                    break\\n        \\n        res = 0\\n        for i in range(x-1, -1, -1):  # check north\\n            if board[i][y] == \\'p\\':\\n                res += 1\\n                break\\n            if board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, n):  # check south\\n            if board[i][y] == \\'p\\':\\n                res += 1\\n                break\\n            if board[i][y] == \\'B\\':\\n                break\\n        \\n        for j in range(y-1, -1, -1):  # check west\\n            if board[x][j] == \\'p\\':\\n                res += 1\\n                break\\n            if board[x][j] == \\'B\\':\\n                break\\n        \\n        for j in range(y+1, n):  # check east\\n            if board[x][j] == \\'p\\':\\n                res += 1\\n                break\\n            if board[x][j] == \\'B\\':\\n                break\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1112858,
                "title": "easiest-recursive-solution-97-6-time-98-2-space",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        def find(rx, ry, direction, count):\\n            if rx == 8 or ry == 8 or rx == -1 or ry == -1: return count\\n            if board[rx][ry] == \"B\": return 0\\n            if board[rx][ry] == \"p\": return count + 1\\n            if direction == \"L\": return find(rx, ry - 1, \"L\", count)\\n            elif direction == \"R\": return find(rx, ry + 1, \"R\", count)\\n            elif direction == \"U\": return find(rx - 1, ry, \"U\", count)\\n            else: return find(rx + 1, ry, \"D\", count)\\n            \\n        rookx = rooky = -1\\n        for i in range(len(board)):\\n            if \"R\" in board[i]:\\n                rookx, rooky = i, board[i].index(\"R\")\\n                break\\n                \\n        return find(rookx, rooky, \"L\", 0) + find(rookx, rooky, \"R\", 0) + find(rookx, rooky, \"U\", 0) + find(rookx, rooky, \"D\", 0)\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        def find(rx, ry, direction, count):\\n            if rx == 8 or ry == 8 or rx == -1 or ry == -1: return count\\n            if board[rx][ry] == \"B\": return 0\\n            if board[rx][ry] == \"p\": return count + 1\\n            if direction == \"L\": return find(rx, ry - 1, \"L\", count)\\n            elif direction == \"R\": return find(rx, ry + 1, \"R\", count)\\n            elif direction == \"U\": return find(rx - 1, ry, \"U\", count)\\n            else: return find(rx + 1, ry, \"D\", count)\\n            \\n        rookx = rooky = -1\\n        for i in range(len(board)):\\n            if \"R\" in board[i]:\\n                rookx, rooky = i, board[i].index(\"R\")\\n                break\\n                \\n        return find(rookx, rooky, \"L\", 0) + find(rookx, rooky, \"R\", 0) + find(rookx, rooky, \"U\", 0) + find(rookx, rooky, \"D\", 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924789,
                "title": "python3-solution-24ms-runtime-and-14mb-memory-usage",
                "content": "class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        for i in range (0,len(board)):\\n            if \\'R\\'in board[i]:\\n                col=i\\n                row=board[i].index(\\'R\\')\\n        op=0\\n        for i in range (row+1,len(board[col])):\\n            if board[col][i]==\\'B\\':\\n                break\\n            elif board[col][i]==\\'p\\':\\n                op+=1\\n                break\\n                \\n        for i in range(row-1,-1,-1):\\n            if board[col][i]==\\'B\\':\\n                break\\n            elif board[col][i]==\\'p\\':\\n                op+=1\\n                break\\n        \\n        for i in range(col,len(board)):\\n            if board[i][row]==\\'B\\':\\n                break\\n            elif board[i][row]==\\'p\\':\\n                op+=1\\n                break\\n                \\n        for i in range(col,-1,-1):\\n            if board[i][row]==\\'B\\':\\n                break\\n            elif board[i][row]==\\'p\\':\\n                op+=1\\n                break\\n        \\n        return op\\n\\t\\t\\n\\t\\t\\n\\n\\n![image](https://assets.leetcode.com/users/images/14653ef7-8eae-452b-9265-dbedfe684a5b_1604603491.4019651.png)\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        for i in range (0,len(board)):\\n            if \\'R\\'in board[i]:\\n                col=i\\n                row=board[i].index(\\'R\\')\\n        op=0\\n        for i in range (row+1,len(board[col])):\\n            if board[col][i]==\\'B\\':\\n                break\\n            elif board[col][i]==\\'p\\':\\n                op+=1\\n                break\\n                \\n        for i in range(row-1,-1,-1):\\n            if board[col][i]==\\'B\\':\\n                break\\n            elif board[col][i]==\\'p\\':\\n                op+=1\\n                break\\n        \\n        for i in range(col,len(board)):\\n            if board[i][row]==\\'B\\':\\n                break\\n            elif board[i][row]==\\'p\\':\\n                op+=1\\n                break\\n                \\n        for i in range(col,-1,-1):\\n            if board[i][row]==\\'B\\':\\n                break\\n            elif board[i][row]==\\'p\\':\\n                op+=1\\n                break\\n        \\n        return op\\n\\t\\t\\n\\t\\t\\n\\n\\n![image](https://assets.leetcode.com/users/images/14653ef7-8eae-452b-9265-dbedfe684a5b_1604603491.4019651.png)\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 301748,
                "title": "beginner-python-runtime-16ms-faster-than-98-73-of-submissions-any-suggestions",
                "content": "class Solution(object):\\n    def numRookCaptures(self, board):\\n        \\n        horizontal = []\\n        vertical = []\\n        for i in range(0,8):\\n            temp_hor = \\'\\'\\n            temp_ver = \\'\\'\\n            for j in range(0,8):\\n                if board[i][j] != \\'.\\':\\n                    temp_hor = temp_hor + board[i][j]\\n                if board[j][i] != \\'.\\':\\n                    temp_ver = temp_ver + board[j][i]\\n            horizontal.append(temp_hor)\\n            vertical.append(temp_ver)\\n        count = 0\\n        new = horizontal + vertical\\n        for i in range(0,len(new)):\\n            if \\'Rp\\' in str(new[i]):\\n                count +=1\\n            if \\'pR\\' in str(new[i]):\\n                count +=1\\n        return(count)\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numRookCaptures(self, board):\\n        \\n        horizontal = []\\n        vertical = []\\n        for i in range(0,8):\\n            temp_hor = \\'\\'\\n            temp_ver = \\'\\'\\n            for j in range(0,8):\\n                if board[i][j] != \\'.\\':\\n                    temp_hor = temp_hor + board[i][j]\\n                if board[j][i] != \\'.\\':\\n                    temp_ver = temp_ver + board[j][i]\\n            horizontal.append(temp_hor)\\n            vertical.append(temp_ver)\\n        count = 0\\n        new = horizontal + vertical\\n        for i in range(0,len(new)):\\n            if \\'Rp\\' in str(new[i]):\\n                count +=1\\n            if \\'pR\\' in str(new[i]):\\n                count +=1\\n        return(count)\\n",
                "codeTag": "Java"
            },
            {
                "id": 243241,
                "title": "detailed-explanation",
                "content": "* Define an instance variable of the class as `captureCount` to store the count of pawns captured.\\n* Create a utility function `should_break` with input parameters as the board, and a particular cell. \\n* If the cell is a bishop, return `true` indicating that you should end your search due to blockage.\\n* If the cell is an empty space, return `false` indictaing that you should not break and keep searching.\\n* If the cell contains a pawn, capture it and update the `captureCount` by 1. Also, return `true` indicating that you cannot go further, as you are allowed only one move.\\n\\n1) Search the board for the position of the rook, and store it as `row_index`, `col_index`.\\n2) Go in all the cardinal direction starting from the position of the rook and see if you should break or not by calling the function `should_break`\\n3) The capture counts would automatically be updated by the function call.\\n4) In 2 of the cardinal directions, `row_index` would remain the same, while in the other 2, `col_index` would remain the same.\\n5) Handle out of bound access by properly defining the terminating codnitions of the for loop,\\n\\n\\n```\\nclass Solution\\n{\\nprivate:\\n    int ROW = 8;\\n    int COL = 8;\\n    int captureCount = 0;\\npublic:\\n    bool should_break(vector<vector<char>>& board, int i, int j);\\n    int numRookCaptures(vector<vector<char>>& board);\\n};\\n\\n/* Function to update the pawns captured and to inform whether to go looking forward or not */\\nbool Solution :: should_break(vector<vector<char>>& board, int i, int j)\\n{\\n    // If the space is empty, keep going, no need to break\\n    if(board[i][j]==\\'.\\') return false;\\n    \\n    // If the piece is a bishop, no capture can happen further, just break\\n    if(board[i][j]==\\'B\\') return true;\\n    \\n    // If the piece is a pawn, capture it and then break\\n    if(board[i][j]==\\'p\\') captureCount++;\\n    \\n    return true;\\n}\\n\\n/* Returns the number of pawn captures possible */\\nint Solution :: numRookCaptures(vector<vector<char>>& board)\\n{\\n    // Variables to store the location of Rook\\n    int row_index;\\n    int col_index;\\n    \\n    // Traverse the board, locating the Rook\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(board[i][j] == \\'R\\')\\n            {\\n                row_index = i;\\n                col_index = j;\\n                break;\\n\\t\\t\\t}\\n\\n    /* Now we know the location of the Rook */\\n    \\n    int i,j;\\n    \\n    // Move in the up direction and capture the pawns. [In the same column]\\n    j = col_index;\\n    for(int i=row_index-1; i>=0; i--)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the down direction [In the same column]\\n    j = col_index;\\n    for(int i=row_index+1; i<ROW; i++)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the left direction [in the same row]\\n    i = row_index;\\n    for(int j=col_index-1; j>=0; j--)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the right direction [in the same row]\\n    i = row_index;\\n    for(int j=col_index+1; j<COL; j++)\\n       if(should_break(board,i,j)) break;\\n    \\n    // Return the max number of pawns captured\\n    return captureCount;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\nprivate:\\n    int ROW = 8;\\n    int COL = 8;\\n    int captureCount = 0;\\npublic:\\n    bool should_break(vector<vector<char>>& board, int i, int j);\\n    int numRookCaptures(vector<vector<char>>& board);\\n};\\n\\n/* Function to update the pawns captured and to inform whether to go looking forward or not */\\nbool Solution :: should_break(vector<vector<char>>& board, int i, int j)\\n{\\n    // If the space is empty, keep going, no need to break\\n    if(board[i][j]==\\'.\\') return false;\\n    \\n    // If the piece is a bishop, no capture can happen further, just break\\n    if(board[i][j]==\\'B\\') return true;\\n    \\n    // If the piece is a pawn, capture it and then break\\n    if(board[i][j]==\\'p\\') captureCount++;\\n    \\n    return true;\\n}\\n\\n/* Returns the number of pawn captures possible */\\nint Solution :: numRookCaptures(vector<vector<char>>& board)\\n{\\n    // Variables to store the location of Rook\\n    int row_index;\\n    int col_index;\\n    \\n    // Traverse the board, locating the Rook\\n    for(int i=0; i<ROW; i++)\\n        for(int j=0; j<COL; j++)\\n            if(board[i][j] == \\'R\\')\\n            {\\n                row_index = i;\\n                col_index = j;\\n                break;\\n\\t\\t\\t}\\n\\n    /* Now we know the location of the Rook */\\n    \\n    int i,j;\\n    \\n    // Move in the up direction and capture the pawns. [In the same column]\\n    j = col_index;\\n    for(int i=row_index-1; i>=0; i--)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the down direction [In the same column]\\n    j = col_index;\\n    for(int i=row_index+1; i<ROW; i++)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the left direction [in the same row]\\n    i = row_index;\\n    for(int j=col_index-1; j>=0; j--)\\n        if(should_break(board,i,j)) break;\\n    \\n    // Move in the right direction [in the same row]\\n    i = row_index;\\n    for(int j=col_index+1; j<COL; j++)\\n       if(should_break(board,i,j)) break;\\n    \\n    // Return the max number of pawns captured\\n    return captureCount;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449570,
                "title": "perfect-solution-with-java-beat-100-70",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n        int m = 0;\\n        int n = 0;\\n        for(int a = 0; a < board.length; a++){\\n            char[] array = board[a];\\n            for(int b = 0; b < array.length; b++){\\n                if(array[b] == \\'R\\'){\\n                    m = a;\\n                    n = b;\\n                    break;\\n                }\\n            }\\n        }\\n        int d1 = m;\\n        while(d1<7){\\n            d1++;\\n            if(board[d1][n] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[d1][n] == \\'B\\') break;\\n        }\\n        \\n        d1 = m;\\n        while(d1>0){\\n            d1--;\\n            if(board[d1][n] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[d1][n] == \\'B\\') break;\\n        }\\n        \\n        d1 = n;\\n        while(d1<7){\\n            d1++;\\n            if(board[m][d1] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[m][d1] == \\'B\\') break;\\n        }\\n        \\n        d1 = n;\\n        while(d1>0){\\n            d1--;\\n            if(board[m][d1] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[m][d1] == \\'B\\') break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n        int m = 0;\\n        int n = 0;\\n        for(int a = 0; a < board.length; a++){\\n            char[] array = board[a];\\n            for(int b = 0; b < array.length; b++){\\n                if(array[b] == \\'R\\'){\\n                    m = a;\\n                    n = b;\\n                    break;\\n                }\\n            }\\n        }\\n        int d1 = m;\\n        while(d1<7){\\n            d1++;\\n            if(board[d1][n] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[d1][n] == \\'B\\') break;\\n        }\\n        \\n        d1 = m;\\n        while(d1>0){\\n            d1--;\\n            if(board[d1][n] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[d1][n] == \\'B\\') break;\\n        }\\n        \\n        d1 = n;\\n        while(d1<7){\\n            d1++;\\n            if(board[m][d1] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[m][d1] == \\'B\\') break;\\n        }\\n        \\n        d1 = n;\\n        while(d1>0){\\n            d1--;\\n            if(board[m][d1] == \\'p\\'){\\n                count++;\\n                break;\\n            }else if(board[m][d1] == \\'B\\') break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312040,
                "title": "beginner-friendly-approach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int ans = 0, r = 0, c = 0;\\n        for (int i = 0; i < 8; i++) {\\n            for (int j = 0; j < 8; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    r = i;\\n                    c = j;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = r - 1; i >= 0; i--) {\\n            if (board[i][c] == \\'B\\') {\\n                break;\\n            }\\n            if (board[i][c] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int i = r + 1; i < 8; i++) {\\n            if (board[i][c] == \\'B\\') {\\n                break;\\n            }\\n            if (board[i][c] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int j = c - 1; j >= 0; j--) {\\n            if (board[r][j] == \\'B\\') {\\n                break;\\n            }\\n            if (board[r][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int j = c + 1; j < 8; j++) {\\n            if (board[r][j] == \\'B\\') {\\n                break;\\n            }\\n            if (board[r][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int ans = 0, r = 0, c = 0;\\n        for (int i = 0; i < 8; i++) {\\n            for (int j = 0; j < 8; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    r = i;\\n                    c = j;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = r - 1; i >= 0; i--) {\\n            if (board[i][c] == \\'B\\') {\\n                break;\\n            }\\n            if (board[i][c] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int i = r + 1; i < 8; i++) {\\n            if (board[i][c] == \\'B\\') {\\n                break;\\n            }\\n            if (board[i][c] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int j = c - 1; j >= 0; j--) {\\n            if (board[r][j] == \\'B\\') {\\n                break;\\n            }\\n            if (board[r][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        for (int j = c + 1; j < 8; j++) {\\n            if (board[r][j] == \\'B\\') {\\n                break;\\n            }\\n            if (board[r][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610599,
                "title": "faster-than-98",
                "content": "```class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        co=0\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j]==\"R\":\\n                    left=j-1\\n                    while(left>-1):\\n                        if board[i][left]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[i][left]==\"B\":\\n                            break\\n                        else:\\n                            left-=1\\n                    right=j+1\\n                    while(right<8):\\n                   \\n                        if board[i][right]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[i][right]==\"B\":\\n                            break\\n                        else:\\n                            right+=1\\n                    top=i-1\\n                    while(top>-1):\\n                        if board[top][j]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[top][j]==\"B\":\\n                            break\\n                        else:\\n                            top-=1\\n                    bot=i+1\\n                    while(bot<8):\\n                        if board[bot][j]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[bot][j]==\"B\":\\n                            break\\n                        else:\\n                            bot+=1\\n                    return co\\n        return co",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        co=0\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j]==\"R\":\\n                    left=j-1\\n                    while(left>-1):\\n                        if board[i][left]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[i][left]==\"B\":\\n                            break\\n                        else:\\n                            left-=1\\n                    right=j+1\\n                    while(right<8):\\n                   \\n                        if board[i][right]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[i][right]==\"B\":\\n                            break\\n                        else:\\n                            right+=1\\n                    top=i-1\\n                    while(top>-1):\\n                        if board[top][j]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[top][j]==\"B\":\\n                            break\\n                        else:\\n                            top-=1\\n                    bot=i+1\\n                    while(bot<8):\\n                        if board[bot][j]==\"p\":\\n                            co+=1\\n                            break\\n                        elif board[bot][j]==\"B\":\\n                            break\\n                        else:\\n                            bot+=1\\n                    return co\\n        return co",
                "codeTag": "Java"
            },
            {
                "id": 2596440,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count=0;\\n        for(int i=0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++)\\n                if(board[i][j]==\\'R\\'){\\n                    int d=j;\\n                    int u=j;\\n                    int l=i;\\n                    int r=i;\\n                    //down\\n                    while(++d<8){\\n                        if(board[i][d]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }else if(board[i][d]==\\'B\\'){\\n                            break;\\n                        }\\n                    }\\n                    //up\\n                     while(--u>=0){\\n                        if(board[i][u]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }else if(board[i][u]==\\'B\\'){\\n                            break;\\n                        }\\n                    }\\n                    //left\\n                      while(++l<8){\\n                        if(board[l][j]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }else if(board[l][j]==\\'B\\'){\\n                            break;\\n                        }\\n                    }\\n                    //right\\n                     while(--r>=0){\\n                        if(board[r][j]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }else if(board[r][j]==\\'B\\'){\\n                            break;\\n                        }\\n                    }\\n                    return count;\\n                    \\n                }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count=0;\\n        for(int i=0;i<board.length;i++)\\n            for(int j=0;j<board[0].length;j++)\\n                if(board[i][j]==\\'R\\'){\\n                    int d=j;\\n                    int u=j;\\n                    int l=i;\\n                    int r=i;\\n                    //down\\n                    while(++d<8){\\n                        if(board[i][d]==\\'p\\'){\\n                            count++;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2581037,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(vector<vector<char>>& b,int i,int j,int dx,int dy)\\n    {\\n        while(i>=0&&j>=0&&i<8&&j<8&&b[i][j]!=\\'B\\')\\n        {\\n            if(b[i][j]==\\'p\\')  //small p in question\\n                return 1;\\n            i+=dx;\\n            j+=dy;\\n        }\\n        return 0;\\n    }\\n    int numRookCaptures(vector<vector<char>>& b)\\n    {\\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                if(b[i][j]==\\'R\\')\\n                {\\n                    return count(b,i,j,1,0)+count(b,i,j,0,1)+count(b,i,j,-1,0)+count(b,i,j,0,-1);\\n                }\\n            }\\n            \\n        }\\n        return 0;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int count(vector<vector<char>>& b,int i,int j,int dx,int dy)\\n    {\\n        while(i>=0&&j>=0&&i<8&&j<8&&b[i][j]!=\\'B\\')\\n        {\\n            if(b[i][j]==\\'p\\')  //small p in question\\n                return 1;\\n            i+=dx;\\n            j+=dy;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2538911,
                "title": "java-matrix-faster-than-100-java-submissions",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ii=0,jj=0;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    ii=i;\\n                    jj=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=ii;i>=0;i--){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int i=ii;i<8;i++){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j<8;j++){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j>=0;j--){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ii=0,jj=0;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    ii=i;\\n                    jj=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=ii;i>=0;i--){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int i=ii;i<8;i++){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j<8;j++){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j>=0;j--){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048569,
                "title": "c-100-faster-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int rook_row , rook_col ;\\n        for (int i = 0 ; i < 8 ; i ++) {\\n            for (int j = 0 ; j < 8 ; j ++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rook_row = i ;\\n                    rook_col = j ;\\n                    break ;\\n                }\\n            }\\n        }  int count = 0 ;\\n        if (rook_row != 0) {\\n            for (int i = rook_row - 1 ; i >= 0 ; i --) {\\n                if (board[i][rook_col] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[i][rook_col] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_row != 7) {\\n            for (int i = rook_row + 1 ; i < 8 ; i ++) {\\n                if (board[i][rook_col] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[i][rook_col] == \\'p\\') {\\n                    count += 1 ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_col != 0) {\\n            for (int i = rook_col - 1 ; i >= 0 ; i --) {\\n                if (board[rook_row][i] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[rook_row][i] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_col != 7) {\\n            for (int i = rook_col + 1 ; i < 8 ; i ++) {\\n                if (board[rook_row][i] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[rook_row][i] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        } return count ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int rook_row , rook_col ;\\n        for (int i = 0 ; i < 8 ; i ++) {\\n            for (int j = 0 ; j < 8 ; j ++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rook_row = i ;\\n                    rook_col = j ;\\n                    break ;\\n                }\\n            }\\n        }  int count = 0 ;\\n        if (rook_row != 0) {\\n            for (int i = rook_row - 1 ; i >= 0 ; i --) {\\n                if (board[i][rook_col] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[i][rook_col] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_row != 7) {\\n            for (int i = rook_row + 1 ; i < 8 ; i ++) {\\n                if (board[i][rook_col] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[i][rook_col] == \\'p\\') {\\n                    count += 1 ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_col != 0) {\\n            for (int i = rook_col - 1 ; i >= 0 ; i --) {\\n                if (board[rook_row][i] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[rook_row][i] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        }\\n        if (rook_col != 7) {\\n            for (int i = rook_col + 1 ; i < 8 ; i ++) {\\n                if (board[rook_row][i] == \\'B\\') {\\n                    break ;\\n                }\\n                else if (board[rook_row][i] == \\'p\\') {\\n                    count ++ ;\\n                    break ;\\n                }\\n            }\\n        } return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008271,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/9dea66f6-7e45-4d86-bcab-9133e216e22c_1651684472.9326024.png)\\n\\n\\n    def numRookCaptures(self, board):\\n        \"\"\" O(NM)TS \"\"\"\\n        ans = 0\\n\\n        for s in [*board, *zip(*board)]:\\n            row = \\'\\'.join(s).replace(\\'.\\', \\'\\')\\n            ans += row.count(\\'pR\\') + row.count(\\'Rp\\')\\n\\n        return ans\\n\\n    def numRookCaptures(self, board):\\n        \"\"\" O(NM)TS \"\"\"\\n        return sum(row.count(\\'pR\\') + row.count(\\'Rp\\') for s in [*board, *zip(*board)] if (row := \\'\\'.join(s).replace(\\'.\\', \\'\\')))\\n",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/9dea66f6-7e45-4d86-bcab-9133e216e22c_1651684472.9326024.png)\\n\\n\\n    def numRookCaptures(self, board):\\n        \"\"\" O(NM)TS \"\"\"\\n        ans = 0\\n\\n        for s in [*board, *zip(*board)]:\\n            row = \\'\\'.join(s).replace(\\'.\\', \\'\\')\\n            ans += row.count(\\'pR\\') + row.count(\\'Rp\\')\\n\\n        return ans\\n\\n    def numRookCaptures(self, board):\\n        \"\"\" O(NM)TS \"\"\"\\n        return sum(row.count(\\'pR\\') + row.count(\\'Rp\\') for s in [*board, *zip(*board)] if (row := \\'\\'.join(s).replace(\\'.\\', \\'\\')))\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1726705,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "PLEASE UPVOTE!\\n```\\nint count=0,r,c;\\n//finding the position of rook and storing the row in r and column in c\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    r=i;\\n                    c=j;\\n                }\\n            }\\n        }\\n\\t\\t//checking if there is any pawn on right of rook, if any bishop break the loop\\n        for(int k=c;k<8;k++){\\n            if(board[r][k]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[r][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn on left of rook, if any bishop break the loop\\n        for(int k=c;k>=0;k--){\\n            if(board[r][k]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[r][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn below the rook, if any bishop break the loop\\n        for(int k=r;k<8;k++){\\n            if(board[k][c]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[k][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn above the  rook, if any bishop break the loop\\n        for(int k=r;k>=0;k--){\\n            if(board[k][c]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[k][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nint count=0,r,c;\\n//finding the position of rook and storing the row in r and column in c\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    r=i;\\n                    c=j;\\n                }\\n            }\\n        }\\n\\t\\t//checking if there is any pawn on right of rook, if any bishop break the loop\\n        for(int k=c;k<8;k++){\\n            if(board[r][k]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[r][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn on left of rook, if any bishop break the loop\\n        for(int k=c;k>=0;k--){\\n            if(board[r][k]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[r][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn below the rook, if any bishop break the loop\\n        for(int k=r;k<8;k++){\\n            if(board[k][c]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[k][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\t\\t//checking if there is any pawn above the  rook, if any bishop break the loop\\n        for(int k=r;k>=0;k--){\\n            if(board[k][c]==\\'p\\'){\\n                count++;\\n                break;\\n                \\n            }\\n            else if(board[k][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588673,
                "title": "python-faster-than-99-dict-hash-map-solution",
                "content": "```\\nclass Solution:        \\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rows = {}\\n        cols = {}\\n        for i, row in enumerate(board):\\n            for j, figure in enumerate(row):\\n                if figure != \\'.\\':\\n                    if j in cols:\\n                        cols[j] += figure\\n                    else:\\n                        cols[j] = figure\\n                    if i in rows:\\n                        rows[i] += figure\\n                    else:\\n                        rows[i] = figure\\n        attacked = 0\\n        for row in rows.values():\\n            if \\'pR\\' in row:\\n                attacked += 1\\n            if \\'Rp\\' in row:\\n                attacked += 1\\n        for col in cols.values():\\n            if \\'pR\\' in col:\\n                attacked += 1\\n            if \\'Rp\\' in col:\\n                attacked += 1\\n        return attacked\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:        \\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rows = {}\\n        cols = {}\\n        for i, row in enumerate(board):\\n            for j, figure in enumerate(row):\\n                if figure != \\'.\\':\\n                    if j in cols:\\n                        cols[j] += figure\\n                    else:\\n                        cols[j] = figure\\n                    if i in rows:\\n                        rows[i] += figure\\n                    else:\\n                        rows[i] = figure\\n        attacked = 0\\n        for row in rows.values():\\n            if \\'pR\\' in row:\\n                attacked += 1\\n            if \\'Rp\\' in row:\\n                attacked += 1\\n        for col in cols.values():\\n            if \\'pR\\' in col:\\n                attacked += 1\\n            if \\'Rp\\' in col:\\n                attacked += 1\\n        return attacked\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190574,
                "title": "faster-than-100-of-solutions-runtime-0ms-with-comments-and-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int ri = 0;\\n        int rj = 0;\\n        \\n        //Finding the Bishops Coordinate\\n        for(int i=0;i<8;i++) {\\n            for(int j=0 ;j<8;j++) {\\n                if(board[i][j]  == \\'R\\') {\\n                   ri = i;\\n                   rj = j;\\n                    break;\\n                }\\n            }\\n        }\\n        int numPawns = 0; //Number of Pawns found so far..\\n        \\n        //Finding Pawns in Left Side\\n        for(int i = ri; i>=0; i--) {\\n            if(board[i][rj] == \\'B\\') break;\\n            if(board[i][rj] == \\'p\\') {numPawns++; break;}\\n        }   \\n        \\n        //Finding pawns in Right Side \\n        for(int i=rj; i<8;i++) {\\n          if(board[i][rj] == \\'B\\') break;\\n          if(board[i][rj] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        //Finding Pawns in upward direction\\n        for(int j = rj; j>=0; j--) {\\n            if(board[ri][j] == \\'B\\') break;\\n            if(board[ri][j] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        //Finding Pawns in downward direction\\n        for(int j=rj;j<8;j++) {\\n            if(board[ri][j] == \\'B\\') break;\\n            if(board[ri][j] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        return numPawns;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int ri = 0;\\n        int rj = 0;\\n        \\n        //Finding the Bishops Coordinate\\n        for(int i=0;i<8;i++) {\\n            for(int j=0 ;j<8;j++) {\\n                if(board[i][j]  == \\'R\\') {\\n                   ri = i;\\n                   rj = j;\\n                    break;\\n                }\\n            }\\n        }\\n        int numPawns = 0; //Number of Pawns found so far..\\n        \\n        //Finding Pawns in Left Side\\n        for(int i = ri; i>=0; i--) {\\n            if(board[i][rj] == \\'B\\') break;\\n            if(board[i][rj] == \\'p\\') {numPawns++; break;}\\n        }   \\n        \\n        //Finding pawns in Right Side \\n        for(int i=rj; i<8;i++) {\\n          if(board[i][rj] == \\'B\\') break;\\n          if(board[i][rj] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        //Finding Pawns in upward direction\\n        for(int j = rj; j>=0; j--) {\\n            if(board[ri][j] == \\'B\\') break;\\n            if(board[ri][j] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        //Finding Pawns in downward direction\\n        for(int j=rj;j<8;j++) {\\n            if(board[ri][j] == \\'B\\') break;\\n            if(board[ri][j] == \\'p\\') {numPawns++; break;}\\n        }\\n        \\n        return numPawns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928246,
                "title": "java-solution-visualizing-steps-taken-by-rookie-hathi",
                "content": "class Solution {\\npublic int numRookCaptures(char[][] board) {\\n    \\n     /*  R-Hathi  :::-R-::: Rook\\n        B-Unth   :::-B-::: Bishops\\n        p-pyade   ::-p-::  pawns    */\\n    \\n    int i1=0,j1=0,count=0;\\n    for(int i=0;i<board.length;i++){        // finding position of Hathi\\n        for(int j=0;j<board[0].length;j++){\\n            if(board[i][j]==\\'R\\'){\\n                i1=i;j1=j;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    //Suppose H hanthi hai ::-Rookie-:: &&& A is blank space\\n\\n    //steps taken by hathi top to bottom \\n    for(int i=i1;i<board[0].length;i++){              //  Top to Bottom\\n        if(board[i][j1]==\\'B\\'){break;}   //  AAA\\n        else if(board[i][j1]==\\'p\\'){     //  AHA\\n            count++;board[i][j1]=\\'X\\';   //  AHA\\n            break;\\n        }\\n        board[i][j1]=\\'X\\';\\n    }\\n    \\n    //steps taken by hathi bottom to top\\n    for(int i=i1;i>=0;i--){               // Bottom to top\\n        if(board[i][j1]==\\'B\\'){break;}     // AHA\\n        else if(board[i][j1]==\\'p\\'){       // AHA\\n            count++;board[i][j1]=\\'X\\';     // AAA\\n            break;\\n        }\\n        board[i][j1]=\\'X\\';\\n    }\\n    \\n    //steps taken by hathi right to left\\n    for(int j=j1;j>=0;j--){               //Right to left\\n        if(board[i1][j]==\\'B\\'){break;}     // AAA\\n        else if(board[i1][j]==\\'p\\'){       // HHA\\n            count++;board[i1][j]=\\'X\\';     // AAA\\n            break;\\n        }\\n        board[i1][j]=\\'X\\';\\n    }\\n    \\n    //steps taken by hathi left to right\\n    for(int j=j1;j<board.length;j++){              //Left to right\\n        if(board[i1][j]==\\'B\\'){break;}     // AAA\\n        else if(board[i1][j]==\\'p\\'){       // AHH\\n            count++;board[i1][j]=\\'X\\';     // AAA\\n            break;\\n        }\\n        board[i1][j]=\\'X\\';\\n    } \\n    \\n    //printing path travel by hathi\\n    for(int i=0;i<board.length;i++){\\n        for(int j=0;j<board[0].length;j++){\\n            System.out.print(board[i][j]+\" \");\\n        }\\n        System.out.println();\\n    }\\n    return count;\\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic int numRookCaptures(char[][] board) {\\n    \\n     /*  R-Hathi  :::-R-::: Rook\\n        B-Unth   :::-B-::: Bishops\\n        p-pyade   ::-p-::  pawns    */\\n    \\n    int i1=0,j1=0,count=0;\\n    for(int i=0;i<board.length;i++){        // finding position of Hathi\\n        for(int j=0;j<board[0].length;j++){\\n            if(board[i][j]==\\'R\\'){\\n                i1=i;j1=j;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 639509,
                "title": "c-solution",
                "content": "```\\nint numRookCaptures(char** board, int boardSize, int* boardColSize){\\nint rook_r, rook_f;\\nint i, j;\\nint pawn_counter = 0;\\n// Find out where the rook is\\nfor (i=0; i<boardSize; i++)\\n    for (j=0; j<*boardColSize; j++)\\n        if (board[i][j]==\\'R\\') { rook_r=i; rook_f=j; break; }\\n\\nfor (i=rook_r-1; i>=0; i--)\\n    if (board[i][rook_f]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[i][rook_f]==\\'B\\') break;\\n\\nfor (i=rook_r+1; i<boardSize; i++)\\n    if (board[i][rook_f]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[i][rook_f]==\\'B\\') break;\\n    \\nfor (i=rook_f-1; i>=0; i--)\\n    if (board[rook_r][i]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[rook_r][i]==\\'B\\') break;\\n\\nfor (i=rook_f+1; i<*boardColSize; i++)\\n    if (board[rook_r][i]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[rook_r][i]==\\'B\\') break;\\n    \\nreturn pawn_counter;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint numRookCaptures(char** board, int boardSize, int* boardColSize){\\nint rook_r, rook_f;\\nint i, j;\\nint pawn_counter = 0;\\n// Find out where the rook is\\nfor (i=0; i<boardSize; i++)\\n    for (j=0; j<*boardColSize; j++)\\n        if (board[i][j]==\\'R\\') { rook_r=i; rook_f=j; break; }\\n\\nfor (i=rook_r-1; i>=0; i--)\\n    if (board[i][rook_f]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[i][rook_f]==\\'B\\') break;\\n\\nfor (i=rook_r+1; i<boardSize; i++)\\n    if (board[i][rook_f]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[i][rook_f]==\\'B\\') break;\\n    \\nfor (i=rook_f-1; i>=0; i--)\\n    if (board[rook_r][i]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[rook_r][i]==\\'B\\') break;\\n\\nfor (i=rook_f+1; i<*boardColSize; i++)\\n    if (board[rook_r][i]==\\'p\\') {\\n       pawn_counter++;\\n       break;\\n    } else if (board[rook_r][i]==\\'B\\') break;\\n    \\nreturn pawn_counter;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 602385,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nFind the `i`,`j` cell of the Rook.  Then step in each cardinal direction and increment the count `cnt` of black pawns found along the way.\\n\\n---\\n\\n*Javascript*\\n```\\nlet numRookCaptures = (A, i = -1, j = -1, cnt = 0) => {\\n    A.forEach((row, u) =>\\n        row.forEach((col, v) => {\\n            if (A[u][v] == \\'R\\')\\n                i = u,\\n                j = v;\\n    }));\\n    let ok = x => 0 <= x && x < 8;\\n    for (let d of [[-1, 0], [0, 1], [1, 0], [0, -1]]) { // clockwise directions [\\uD83D\\uDC46, \\uD83D\\uDC49, \\uD83D\\uDC47, \\uD83D\\uDC48]\\n        for (let u = i + d[0], v = j + d[1]; ok(u) && ok(v); u += d[0], v += d[1]) {\\n            if (A[u][v] == \\'p\\')\\n                ++cnt; // black pawn \\uD83C\\uDFAF\\n            if (A[u][v] != \\'.\\')\\n                break; // non-empty square\\n        }\\n    }   \\n    return cnt;\\n};\\n```\\n\\n---\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    int numRookCaptures(VVC& A, int i = -1, int j = -1, int cnt = 0) {\\n        for (auto u{ 0 }; u < 8; ++u)\\n            for (auto v{ 0 }; v < 8; ++v)\\n                if (A[u][v] == \\'R\\')\\n                    i = u, j = v;\\n        auto ok = [](auto x) { return 0 <= x && x < 8; };\\n        for (auto d: VVC{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) { // // clockwise directions {\\uD83D\\uDC46, \\uD83D\\uDC49, \\uD83D\\uDC47, \\uD83D\\uDC48}\\n            for (auto u = i + d[0], v = j + d[1]; ok(u) && ok(v); u += d[0], v += d[1]) {\\n                if (A[u][v] == \\'p\\')\\n                    ++cnt; // black pawn \\uD83C\\uDFAF\\n                if (A[u][v] != \\'.\\')\\n                    break; // non-empty square\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet numRookCaptures = (A, i = -1, j = -1, cnt = 0) => {\\n    A.forEach((row, u) =>\\n        row.forEach((col, v) => {\\n            if (A[u][v] == \\'R\\')\\n                i = u,\\n                j = v;\\n    }));\\n    let ok = x => 0 <= x && x < 8;\\n    for (let d of [[-1, 0], [0, 1], [1, 0], [0, -1]]) { // clockwise directions [\\uD83D\\uDC46, \\uD83D\\uDC49, \\uD83D\\uDC47, \\uD83D\\uDC48]\\n        for (let u = i + d[0], v = j + d[1]; ok(u) && ok(v); u += d[0], v += d[1]) {\\n            if (A[u][v] == \\'p\\')\\n                ++cnt; // black pawn \\uD83C\\uDFAF\\n            if (A[u][v] != \\'.\\')\\n                break; // non-empty square\\n        }\\n    }   \\n    return cnt;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    int numRookCaptures(VVC& A, int i = -1, int j = -1, int cnt = 0) {\\n        for (auto u{ 0 }; u < 8; ++u)\\n            for (auto v{ 0 }; v < 8; ++v)\\n                if (A[u][v] == \\'R\\')\\n                    i = u, j = v;\\n        auto ok = [](auto x) { return 0 <= x && x < 8; };\\n        for (auto d: VVC{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) { // // clockwise directions {\\uD83D\\uDC46, \\uD83D\\uDC49, \\uD83D\\uDC47, \\uD83D\\uDC48}\\n            for (auto u = i + d[0], v = j + d[1]; ok(u) && ok(v); u += d[0], v += d[1]) {\\n                if (A[u][v] == \\'p\\')\\n                    ++cnt; // black pawn \\uD83C\\uDFAF\\n                if (A[u][v] != \\'.\\')\\n                    break; // non-empty square\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551546,
                "title": "python-95-7-lines-with-detailed-explanation-very-easy-to-follow",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n\\t\\n        rR,rC,sC,sR = 0,0,\\'\\',\\'\\'     \\n\\t\\t\\n        while \\'R\\' not in board[rR]:\\n            rR += 1\\n        rC = board[rR].index(\\'R\\')\\n\\t\\t\\n        sR=\\'\\'.join(board[rR]).replace(\\'.\\',\\'\\')\\n        sC=\\'\\'.join([board[i][rC] for i in range(8)]).replace(\\'.\\',\\'\\')\\n\\t\\t\\n        return  sR.count(\\'pR\\') + sR.count(\\'Rp\\') + sC.count(\\'pR\\') + sC.count(\\'Rp\\')\\n```\\n\\n\\nok, let\\'s start ... First, we want to find the location of the rook (`rR` - rook\\'s row, `rC` - rook\\'s column). Since we know it\\'s there, we can use a while loop  like below:\\n\\n```\\n        while \\'R\\' not in board[rR]:\\n            rR += 1\\n        rC = board[rR].index(\\'R\\')\\n```\\n\\nWe start at 0,0 and check row by row if it\\'s there and once we see it, we set rC to the rook\\'s index.\\n\\nOk, now we know where rook is. The next step is to find the row and the column where rook is and convert them into strings `sR`,`sC`. There is one catch - we want to remove all \\'.\\' s. You\\'ll find out why in a moment. Also, the 8 below is because chess board is 8x8.\\n\\n```\\n        sR=\\'\\'.join(board[rR]).replace(\\'.\\',\\'\\')\\n        sC=\\'\\'.join([board[i][rC] for i in range(8)]).replace(\\'.\\',\\'\\')\\n```\\n\\nOk, so now things are really simple. Rook can take a pawn only if they are next to each other (now it makes sense why we removed \\'.\\' s?), so we need to look for either `Rp`, `pR` or `pRp`. The first two will give 1 point and the last one is worth 2 points. Conviniently, if we have \\'pRp\\' - we\\'ll find one \\'Rp\\' and  one \\'pR\\', so we just need to look for those 2 substrings and return the total count:\\n\\n```\\n        return  sR.count(\\'pR\\') + sR.count(\\'Rp\\') + sC.count(\\'pR\\') + sC.count(\\'Rp\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n\\t\\n        rR,rC,sC,sR = 0,0,\\'\\',\\'\\'     \\n\\t\\t\\n        while \\'R\\' not in board[rR]:\\n            rR += 1\\n        rC = board[rR].index(\\'R\\')\\n\\t\\t\\n        sR=\\'\\'.join(board[rR]).replace(\\'.\\',\\'\\')\\n        sC=\\'\\'.join([board[i][rC] for i in range(8)]).replace(\\'.\\',\\'\\')\\n\\t\\t\\n        return  sR.count(\\'pR\\') + sR.count(\\'Rp\\') + sC.count(\\'pR\\') + sC.count(\\'Rp\\')\\n```\n```\\n        while \\'R\\' not in board[rR]:\\n            rR += 1\\n        rC = board[rR].index(\\'R\\')\\n```\n```\\n        sR=\\'\\'.join(board[rR]).replace(\\'.\\',\\'\\')\\n        sC=\\'\\'.join([board[i][rC] for i in range(8)]).replace(\\'.\\',\\'\\')\\n```\n```\\n        return  sR.count(\\'pR\\') + sR.count(\\'Rp\\') + sC.count(\\'pR\\') + sC.count(\\'Rp\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451494,
                "title": "java-seeking-constructive-feedback",
                "content": "I\\'m looking for constructive feedback on this code. I feel that the code is very readable but it is undeniably longer than other solutions in terms of lines of code. This has a 1 ms runtime and beats only 7.45% of solutions in runtime and 100.00% of solutions in memory usage (34 MB).\\n```\\nimport java.util.*;\\nclass Solution {\\n    static char ROOK = \\'R\\';\\n    static char BISHOP = \\'B\\';\\n    static char PAWN = \\'p\\';\\n    static Map.Entry<Integer, Integer> ERROR_CODE = new AbstractMap.SimpleImmutableEntry<>(-1, -1);\\n    \\n    char[][] board;\\n    Map.Entry<Integer, Integer> rookPosition;\\n    \\n    enum MoveType {\\n        RANK,\\n        FILE;\\n    }\\n    \\n    enum MoveDirection {\\n        TOWARD_A1,\\n        AWAY_FROM_A1;\\n    }\\n    \\n    public int numRookCaptures(char[][] board) {\\n        this.board = board;\\n        this.rookPosition = getRookPosition();\\n        int numRookCaptures = 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.RANK, MoveDirection.TOWARD_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.RANK, MoveDirection.AWAY_FROM_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.FILE, MoveDirection.TOWARD_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.FILE, MoveDirection.AWAY_FROM_A1) ? 1 : 0;\\n        return numRookCaptures;\\n    }\\n    \\n    private boolean isValidPosition(Map.Entry<Integer, Integer> position) {\\n        return inRange(position.getKey()) && inRange(position.getValue());\\n    }\\n    \\n    private boolean inRange(int coordinate) {\\n        return coordinate >= 0 && coordinate <= 7;\\n    }\\n    \\n    private boolean isCapturableByTypeAndDirection(MoveType type, MoveDirection direction) {\\n        if (rookPosition != null) {\\n            Map.Entry<Integer, Integer> unitVector = getUnitVectorByTypeAndDirection(type, direction);\\n            Map.Entry<Integer, Integer> tempRookPosition = getVectorSum(rookPosition, unitVector);\\n            while (isValidPosition(tempRookPosition) && \\n                   getPieceByPosition(tempRookPosition) != BISHOP && \\n                   getPieceByPosition(tempRookPosition) != PAWN) {\\n                tempRookPosition = getVectorSum(tempRookPosition, unitVector);\\n            }\\n            return isValidPosition(tempRookPosition) && getPieceByPosition(tempRookPosition) == PAWN;\\n        }\\n        // No capture available\\n        return false;\\n    }\\n    \\n    private char getPieceByPosition(Map.Entry<Integer, Integer> position) {\\n        return board[position.getKey()][position.getValue()];\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getVectorSum(Map.Entry<Integer, Integer> v, Map.Entry<Integer, Integer> w) {\\n        return new AbstractMap.SimpleImmutableEntry<>(v.getKey() + w.getKey(), v.getValue() + w.getValue());\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getUnitVectorByTypeAndDirection(MoveType type, MoveDirection direction) {\\n        if (rookPosition != null) {\\n            if (type == MoveType.RANK) {\\n                if (direction == MoveDirection.TOWARD_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(0, -1);\\n                } else if (direction == MoveDirection.AWAY_FROM_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(0, 1);\\n                }\\n            } else if (type == MoveType.FILE) {\\n                if (direction == MoveDirection.TOWARD_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(-1, 0);\\n                } else if (direction == MoveDirection.AWAY_FROM_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(1, 0);\\n                }\\n            }\\n        }\\n        // Error code because we have exhausted all combinations of type and direction\\n        return ERROR_CODE;\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getRookPosition() {\\n        int rankIndex = 0;\\n        for (char[] rank : board) {\\n            int fileIndex = 0;\\n            for (char square : rank) {\\n                if (square == ROOK) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(rankIndex, fileIndex);\\n                }\\n                fileIndex++;\\n            }\\n            rankIndex++;\\n        }\\n        // Error code because a valid board will have exactly one rook\\n        return ERROR_CODE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    static char ROOK = \\'R\\';\\n    static char BISHOP = \\'B\\';\\n    static char PAWN = \\'p\\';\\n    static Map.Entry<Integer, Integer> ERROR_CODE = new AbstractMap.SimpleImmutableEntry<>(-1, -1);\\n    \\n    char[][] board;\\n    Map.Entry<Integer, Integer> rookPosition;\\n    \\n    enum MoveType {\\n        RANK,\\n        FILE;\\n    }\\n    \\n    enum MoveDirection {\\n        TOWARD_A1,\\n        AWAY_FROM_A1;\\n    }\\n    \\n    public int numRookCaptures(char[][] board) {\\n        this.board = board;\\n        this.rookPosition = getRookPosition();\\n        int numRookCaptures = 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.RANK, MoveDirection.TOWARD_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.RANK, MoveDirection.AWAY_FROM_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.FILE, MoveDirection.TOWARD_A1) ? 1 : 0;\\n        numRookCaptures += isCapturableByTypeAndDirection(MoveType.FILE, MoveDirection.AWAY_FROM_A1) ? 1 : 0;\\n        return numRookCaptures;\\n    }\\n    \\n    private boolean isValidPosition(Map.Entry<Integer, Integer> position) {\\n        return inRange(position.getKey()) && inRange(position.getValue());\\n    }\\n    \\n    private boolean inRange(int coordinate) {\\n        return coordinate >= 0 && coordinate <= 7;\\n    }\\n    \\n    private boolean isCapturableByTypeAndDirection(MoveType type, MoveDirection direction) {\\n        if (rookPosition != null) {\\n            Map.Entry<Integer, Integer> unitVector = getUnitVectorByTypeAndDirection(type, direction);\\n            Map.Entry<Integer, Integer> tempRookPosition = getVectorSum(rookPosition, unitVector);\\n            while (isValidPosition(tempRookPosition) && \\n                   getPieceByPosition(tempRookPosition) != BISHOP && \\n                   getPieceByPosition(tempRookPosition) != PAWN) {\\n                tempRookPosition = getVectorSum(tempRookPosition, unitVector);\\n            }\\n            return isValidPosition(tempRookPosition) && getPieceByPosition(tempRookPosition) == PAWN;\\n        }\\n        // No capture available\\n        return false;\\n    }\\n    \\n    private char getPieceByPosition(Map.Entry<Integer, Integer> position) {\\n        return board[position.getKey()][position.getValue()];\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getVectorSum(Map.Entry<Integer, Integer> v, Map.Entry<Integer, Integer> w) {\\n        return new AbstractMap.SimpleImmutableEntry<>(v.getKey() + w.getKey(), v.getValue() + w.getValue());\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getUnitVectorByTypeAndDirection(MoveType type, MoveDirection direction) {\\n        if (rookPosition != null) {\\n            if (type == MoveType.RANK) {\\n                if (direction == MoveDirection.TOWARD_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(0, -1);\\n                } else if (direction == MoveDirection.AWAY_FROM_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(0, 1);\\n                }\\n            } else if (type == MoveType.FILE) {\\n                if (direction == MoveDirection.TOWARD_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(-1, 0);\\n                } else if (direction == MoveDirection.AWAY_FROM_A1) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(1, 0);\\n                }\\n            }\\n        }\\n        // Error code because we have exhausted all combinations of type and direction\\n        return ERROR_CODE;\\n    }\\n    \\n    private Map.Entry<Integer, Integer> getRookPosition() {\\n        int rankIndex = 0;\\n        for (char[] rank : board) {\\n            int fileIndex = 0;\\n            for (char square : rank) {\\n                if (square == ROOK) {\\n                    return new AbstractMap.SimpleImmutableEntry<>(rankIndex, fileIndex);\\n                }\\n                fileIndex++;\\n            }\\n            rankIndex++;\\n        }\\n        // Error code because a valid board will have exactly one rook\\n        return ERROR_CODE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356483,
                "title": "no-brainer-simple-java-solution",
                "content": "```\\npublic int numRookCaptures(char[][] board) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    return find(board, i, j , 0, 1) +\\n                        find(board, i, j, 1, 0) +\\n                        find(board, i, j, 0, -1) +\\n                        find(board, i, j, -1, 0);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int find(char[][] board, int r, int c, int dx, int dy) {\\n        r = r + dx;\\n        c = c + dy;\\n        while (isValid(board, r, c)) {\\n            if (board[r][c] == \\'p\\') return 1;\\n            r = r + dx;\\n            c = c + dy;\\n        }\\n        return 0;\\n    }\\n    \\n    public boolean isValid(char[][] board, int r, int c) {\\n        return r >= 0 && r < board.length && c >= 0 && c < board[0].length && board[r][c] != \\'B\\';   \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int numRookCaptures(char[][] board) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    return find(board, i, j , 0, 1) +\\n                        find(board, i, j, 1, 0) +\\n                        find(board, i, j, 0, -1) +\\n                        find(board, i, j, -1, 0);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int find(char[][] board, int r, int c, int dx, int dy) {\\n        r = r + dx;\\n        c = c + dy;\\n        while (isValid(board, r, c)) {\\n            if (board[r][c] == \\'p\\') return 1;\\n            r = r + dx;\\n            c = c + dy;\\n        }\\n        return 0;\\n    }\\n    \\n    public boolean isValid(char[][] board, int r, int c) {\\n        return r >= 0 && r < board.length && c >= 0 && c < board[0].length && board[r][c] != \\'B\\';   \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 339088,
                "title": "ruby-100-100-easy-to-understand",
                "content": "```\\ndef num_rook_captures(board)\\n  @captures = 0\\n    \\n  board.length.times do |i|\\n    board[0].length.times do |j|\\n      if board[i][j] == \\'R\\'  \\n        calculate_captures(\\'up\\', board, i - 1, j)   \\n        calculate_captures(\\'down\\', board, i + 1, j)\\n        calculate_captures(\\'left\\', board, i, j - 1)\\n        calculate_captures(\\'right\\', board, i, j + 1) \\n      end\\n    end\\n  end\\n    \\n  @captures\\nend\\n\\ndef calculate_captures(type, board, i, j)\\n  if i >= 0 && i < board.length && j >= 0 && j < board[0].length\\n    coordinates = case type\\n                  when \\'up\\'\\n                    [ i - 1, j ]\\n                  when \\'down\\'\\n                    [ i + 1, j ]\\n                  when \\'left\\'\\n                    [ i, j - 1 ]\\n                  when \\'right\\'\\n                    [ i, j + 1 ]\\n                  end  \\n         \\n    if board[i][j] == \\'p\\'\\n      @captures += 1\\n      return\\n    elsif board[i][j] == \\'B\\'\\n      return\\n    else\\n      calculate_captures(type, board, *coordinates)\\n    end\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef num_rook_captures(board)\\n  @captures = 0\\n    \\n  board.length.times do |i|\\n    board[0].length.times do |j|\\n      if board[i][j] == \\'R\\'  \\n        calculate_captures(\\'up\\', board, i - 1, j)   \\n        calculate_captures(\\'down\\', board, i + 1, j)\\n        calculate_captures(\\'left\\', board, i, j - 1)\\n        calculate_captures(\\'right\\', board, i, j + 1) \\n      end\\n    end\\n  end\\n    \\n  @captures\\nend\\n\\ndef calculate_captures(type, board, i, j)\\n  if i >= 0 && i < board.length && j >= 0 && j < board[0].length\\n    coordinates = case type\\n                  when \\'up\\'\\n                    [ i - 1, j ]\\n                  when \\'down\\'\\n                    [ i + 1, j ]\\n                  when \\'left\\'\\n                    [ i, j - 1 ]\\n                  when \\'right\\'\\n                    [ i, j + 1 ]\\n                  end  \\n         \\n    if board[i][j] == \\'p\\'\\n      @captures += 1\\n      return\\n    elsif board[i][j] == \\'B\\'\\n      return\\n    else\\n      calculate_captures(type, board, *coordinates)\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 247405,
                "title": "in-search-of-an-elegant-rust-solution",
                "content": "This is an exercise in trying to get an elegant solution.\\n\\nLet\\'s start with a generic Rust solution that is easy to read but is a little repetitive:\\n\\n```\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        for x in (rook_x+1)..board[rook_y].len() {\\n            match board[rook_y][x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for x in (0..rook_x).rev() {\\n            match board[rook_y][x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for y in (rook_y+1)..board.len() {\\n            match board[y][rook_x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for y in (0..rook_y).rev() {\\n            match board[y][rook_x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        count\\n    }\\n}\\n```\\n\\nIt\\'s easy to follow and about as fast as you are going to get (0ms runtime, 2.3MB memory).\\n\\nBut the match clauses are repetitive and it\\'s easy to make a mistake on the loop bounds, so can we hide the iterators behind a nice and reusable interface and simply provide a function that handles the match?\\n\\nLet\\'s try to do the second part first, i.e. move the match to a function called `rules`:\\n\\n```\\n\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn rules(piece: char, count: &mut i32) -> bool {\\n        match piece {\\n            \\'p\\' => {*count += 1; true},\\n            \\'B\\' => true,\\n            _   => false\\n        }\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        for x in (rook_x+1)..board[rook_y].len() {\\n            let piece = board[rook_y][x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for x in (0..rook_x).rev() {\\n            let piece = board[rook_y][x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for y in (rook_y+1)..board.len() {\\n            let piece = board[y][rook_x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for y in (0..rook_y).rev() {\\n            let piece = board[y][rook_x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        count\\n    }\\n}\\n```\\n\\nWe got a whole savings of 1 line (new function is 7 lines and we save 2 lines per direction when we use it)! And the memory usage went from 2.3MB to 2.4MB. Overall not so great, but arguably a step in the right direction.\\n\\nNow an attempt to remove the `for` loop by relying on iterators more:\\n\\n```\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn rules(piece: char) -> i32 {\\n        if piece == \\'p\\' {1} else {0}\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        \\n        count +=\\n            ((rook_x+1)..board[rook_y].len())\\n                .map(|x| board[rook_y][x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count +=\\n            (0..rook_x).rev()\\n                .map(|x| board[rook_y][x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        \\n        count +=\\n            ((rook_y+1)..board.len())\\n                .map(|y| board[y][rook_x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count +=\\n            (0..rook_y).rev()\\n                .map(|y| board[y][rook_x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count\\n    }\\n}\\n```\\n\\nIt\\u2019s definitely messier looking and not any shorter. But since the last two lines repeat we can role those into the `rules` function:\\n\\n```\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(iter: I) -> i32\\n        where I: Iterator<Item = char>\\n    {\\n        iter.skip_while(|piece| *piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        \\n        count += Self::rules((\\n            (rook_x+1)..board[rook_y].len())\\n                .map(|x| board[rook_y][x]));\\n        \\n        count += Self::rules(\\n            (0..rook_x).rev()\\n                .map(|x| board[rook_y][x]));\\n        \\n        count += Self::rules(\\n            ((rook_y+1)..board.len())\\n                .map(|y| board[y][rook_x]));\\n        \\n        count += Self::rules(\\n            (0..rook_y).rev()\\n                .map(|y| board[y][rook_x]));\\n        \\n        count\\n    }\\n}\\n```\\n\\nI think this is okay-ish, maybe a little \\u201Cbetter\\u201D than the second version but maybe not. It\\u2019s still too fiddly. The initial range index is simple enough but the `map` after contains too many symbols and variables that it\\u2019s easy to get wrong if you don\\u2019t have a full test suite.\\n\\nIdeally I would like to be able to do something like:\\n\\n```\\ndirections = vec![\\n\\tboard.up_from(rook_x),\\n\\tboard.down_from(rook_x),\\n\\tboard.left_from(rook_y),\\n\\tboard.right_from(rook_y)\\n];\\ndirections.iter().map(|dir| Self::rules(dir)).sum()\\n```\\n\\nBy using traits to impl the new methods on `Vec<Vec<T>>`.\\n\\nAfter entirely too much effort I arrived at the below:\\n\\n```\\ntype BoxIter<\\'a, T> = Box<dyn Iterator<Item=&\\'a T> + \\'a>;\\n\\ntrait Board {\\n    type T;\\n    fn right_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn left_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn up_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn down_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n}\\n\\nimpl<D> Board for Vec<Vec<D>>\\nwhere D: std::fmt::Debug\\n{\\n    type T = D;\\n    fn right_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y][x+1..].iter()\\n        )\\n    }\\n    fn left_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y][..x].iter().rev()\\n        )\\n    }\\n    fn up_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[..y].iter()\\n                .map(move |row| &row[x])\\n                .rev()\\n        )\\n    }\\n    fn down_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y+1..].iter()\\n                .map(move |row| &row[x])\\n        )\\n    }\\n}\\n\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(iter: &mut I) -> i32\\n        where I: Iterator<Item = &\\'a char>\\n    {\\n        iter.skip_while(|piece| **piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if *piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        [\\n            board.up_from(rook_x, rook_y),\\n            board.down_from(rook_x, rook_y),\\n            board.left_from(rook_x, rook_y),\\n            board.right_from(rook_x, rook_y),\\n        ].iter_mut().map(|mut iter| Self::rules(iter)).sum()\\n    }\\n}\\n```\\n\\nThe issues with this (outside of it being really long and borderline monstrous looking) is that we are boxing the iterators which is causing unnecessary allocations. Ideally we would be able to use `impl Iterator` as the return type but for some reason it seems returning an impl Trait is not allowed from a trait.\\n\\nHowever, seeing how nice slices are and given we are not trying to build a library we can get rid of the trait and just do the following as our last solution:\\n\\n```\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(direction: I) -> i32\\n        where I: IntoIterator<Item = &\\'a char>\\n    {\\n        direction.into_iter().skip_while(|piece| **piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if *piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (x, y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        count +=  Self::rules(board[y][x+1..].iter());  // east\\n        count +=  Self::rules((board[y][..x].iter().rev())); // west\\n        count +=  Self::rules(board[..y].iter().map(move |row| &row[x]).rev()); // north\\n        count +=  Self::rules(board[y+1..].iter().map(move |row| &row[x]));  // south\\n        count\\n    }\\n}\\n```\\n\\nAs this is already entirely too much time spent trying to find an elegant solution for a rather simple problem I\\u2019ll stop here, though I wonder if it\\u2019s possible to go further. I tried storing the four iterators into an array and mapping `Self::rules` over them but the iterator types mismatched :-/ .\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        for x in (rook_x+1)..board[rook_y].len() {\\n            match board[rook_y][x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for x in (0..rook_x).rev() {\\n            match board[rook_y][x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for y in (rook_y+1)..board.len() {\\n            match board[y][rook_x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        for y in (0..rook_y).rev() {\\n            match board[y][rook_x] {\\n                \\'p\\' => {count += 1; break;},\\n                \\'B\\' => {break;}\\n                _   => {}\\n            }\\n        }\\n        \\n        count\\n    }\\n}\\n```\n```\\n\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn rules(piece: char, count: &mut i32) -> bool {\\n        match piece {\\n            \\'p\\' => {*count += 1; true},\\n            \\'B\\' => true,\\n            _   => false\\n        }\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        for x in (rook_x+1)..board[rook_y].len() {\\n            let piece = board[rook_y][x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for x in (0..rook_x).rev() {\\n            let piece = board[rook_y][x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for y in (rook_y+1)..board.len() {\\n            let piece = board[y][rook_x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        for y in (0..rook_y).rev() {\\n            let piece = board[y][rook_x];\\n            if Self::rules(piece, &mut count) { break };\\n        }\\n        \\n        count\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    pub fn rules(piece: char) -> i32 {\\n        if piece == \\'p\\' {1} else {0}\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        \\n        count +=\\n            ((rook_x+1)..board[rook_y].len())\\n                .map(|x| board[rook_y][x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count +=\\n            (0..rook_x).rev()\\n                .map(|x| board[rook_y][x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        \\n        count +=\\n            ((rook_y+1)..board.len())\\n                .map(|y| board[y][rook_x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count +=\\n            (0..rook_y).rev()\\n                .map(|y| board[y][rook_x])\\n                .skip_while(|piece| *piece == \\'.\\')\\n                .next().map_or(0, Self::rules);\\n        \\n        count\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(iter: I) -> i32\\n        where I: Iterator<Item = char>\\n    {\\n        iter.skip_while(|piece| *piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        \\n        count += Self::rules((\\n            (rook_x+1)..board[rook_y].len())\\n                .map(|x| board[rook_y][x]));\\n        \\n        count += Self::rules(\\n            (0..rook_x).rev()\\n                .map(|x| board[rook_y][x]));\\n        \\n        count += Self::rules(\\n            ((rook_y+1)..board.len())\\n                .map(|y| board[y][rook_x]));\\n        \\n        count += Self::rules(\\n            (0..rook_y).rev()\\n                .map(|y| board[y][rook_x]));\\n        \\n        count\\n    }\\n}\\n```\n```\\ndirections = vec![\\n\\tboard.up_from(rook_x),\\n\\tboard.down_from(rook_x),\\n\\tboard.left_from(rook_y),\\n\\tboard.right_from(rook_y)\\n];\\ndirections.iter().map(|dir| Self::rules(dir)).sum()\\n```\n```\\ntype BoxIter<\\'a, T> = Box<dyn Iterator<Item=&\\'a T> + \\'a>;\\n\\ntrait Board {\\n    type T;\\n    fn right_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn left_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn up_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n    fn down_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T>;\\n}\\n\\nimpl<D> Board for Vec<Vec<D>>\\nwhere D: std::fmt::Debug\\n{\\n    type T = D;\\n    fn right_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y][x+1..].iter()\\n        )\\n    }\\n    fn left_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y][..x].iter().rev()\\n        )\\n    }\\n    fn up_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[..y].iter()\\n                .map(move |row| &row[x])\\n                .rev()\\n        )\\n    }\\n    fn down_from<\\'a>(&\\'a self, x: usize, y: usize) -> BoxIter<\\'a, Self::T> {\\n        Box::new(\\n            self[y+1..].iter()\\n                .map(move |row| &row[x])\\n        )\\n    }\\n}\\n\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(iter: &mut I) -> i32\\n        where I: Iterator<Item = &\\'a char>\\n    {\\n        iter.skip_while(|piece| **piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if *piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (rook_x, rook_y) = Self::find_rook(&board);\\n        [\\n            board.up_from(rook_x, rook_y),\\n            board.down_from(rook_x, rook_y),\\n            board.left_from(rook_x, rook_y),\\n            board.right_from(rook_x, rook_y),\\n        ].iter_mut().map(|mut iter| Self::rules(iter)).sum()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    fn find_rook(board: &Vec<Vec<char>>) -> (usize, usize) {\\n        for (y, row) in board.iter().enumerate() {\\n            for (x, piece) in row.iter().enumerate() {\\n                if *piece == \\'R\\' { return (x, y) }\\n            }\\n        }\\n        unreachable!()\\n    }\\n    \\n    fn rules<\\'a, I>(direction: I) -> i32\\n        where I: IntoIterator<Item = &\\'a char>\\n    {\\n        direction.into_iter().skip_while(|piece| **piece == \\'.\\')\\n            .next()\\n            .map_or(0, |piece| if *piece == \\'p\\' {1} else {0})\\n    }\\n    \\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (x, y) = Self::find_rook(&board);\\n        let mut count = 0;\\n        count +=  Self::rules(board[y][x+1..].iter());  // east\\n        count +=  Self::rules((board[y][..x].iter().rev())); // west\\n        count +=  Self::rules(board[..y].iter().map(move |row| &row[x]).rev()); // north\\n        count +=  Self::rules(board[y+1..].iter().map(move |row| &row[x]));  // south\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246691,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        i, j = next((i, j) for i, row in enumerate(board)\\n                           for j, cell in enumerate(row)\\n                           if cell == \\'R\\')\\n        row = \\'\\'.join(board[i])\\n        col = \\'\\'.join(r[j] for r in board)\\n        lines = [row[:j][::-1], row[j+1:], col[:i][::-1], col[i+1:]]\\n        return sum(l.strip(\\'.\\').startswith(\\'p\\') for l in lines)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        i, j = next((i, j) for i, row in enumerate(board)\\n                           for j, cell in enumerate(row)\\n                           if cell == \\'R\\')\\n        row = \\'\\'.join(board[i])\\n        col = \\'\\'.join(r[j] for r in board)\\n        lines = [row[:j][::-1], row[j+1:], col[:i][::-1], col[i+1:]]\\n        return sum(l.strip(\\'.\\').startswith(\\'p\\') for l in lines)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245250,
                "title": "faster-than-100-less-than-100-with-python",
                "content": "Runtime: 24 ms, faster than 100.00% of Python online submissions for Available Captures for Rook.\\nMemory Usage: 10.9 MB, less than 100.00% of Python online submissions for Available Captures for Rook.\\n\\u6211\\u5C31\\u4E0D\\u89E3\\u91CA\\u4E86\\uFF0C\\u8FD9\\u513F\\u6709\\u6CA1\\u6709\\u4E2D\\u56FD\\u4EBA\\u5462\\u54C8\\u54C8\\u54C8\\n```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        result = 0\\n        index = 0\\n        for i in board:\\n            if \\'R\\' in i:\\n                row = \\'\\'.join(z for z in i if z!=\\'.\\')\\n                if \\'Rp\\' in row:\\n                    result += 1\\n                if \\'pR\\' in row:\\n                    result += 1\\n                index = i.index(\"R\")\\n                break\\n        \\n        col = \\'\\'.join(board[i][index] for i in range(8) if board[i][index] !=\\'.\\')\\n        if \\'Rp\\' in col:\\n            result += 1\\n        if \\'pR\\' in col:\\n            result += 1\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        result = 0\\n        index = 0\\n        for i in board:\\n            if \\'R\\' in i:\\n                row = \\'\\'.join(z for z in i if z!=\\'.\\')\\n                if \\'Rp\\' in row:\\n                    result += 1\\n                if \\'pR\\' in row:\\n                    result += 1\\n                index = i.index(\"R\")\\n                break\\n        \\n        col = \\'\\'.join(board[i][index] for i in range(8) if board[i][index] !=\\'.\\')\\n        if \\'Rp\\' in col:\\n            result += 1\\n        if \\'pR\\' in col:\\n            result += 1\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035930,
                "title": "constant-time-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps to solve:\\nstep 1: Find the position of **\"Rook\"**.\\nstep 2: Since the **\"Rook\"** can travel in four directions \\n        We need four loops also the size of the board is 8 * 8 , we dont have to worry about the complexity of loops.\\nstep 3: Count the **\"pawns\"** when you encounter **\\'p\\'** on the board.\\nstep 4: Make sure you break the loop when you encounter the first **\"pawn\"** / **\"Bishop\"**.\\nstep 5: Return the count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$: All the loops run for constant time. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int m = board.size(), n = board[0].size();\\n        int rx, ry;\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rx = i, ry = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int j = ry + 1 ; j < 8 ; j++) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n        for(int j = ry - 1 ; j >= 0 ; j--) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n \\n        for(int i = rx + 1 ; i < 8 ; i++) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n\\n        for(int i = rx - 1 ; i >= 0 ; i--) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n    \\n\\n        return count;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int m = board.size(), n = board[0].size();\\n        int rx, ry;\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rx = i, ry = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int j = ry + 1 ; j < 8 ; j++) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n        for(int j = ry - 1 ; j >= 0 ; j--) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n \\n        for(int i = rx + 1 ; i < 8 ; i++) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n\\n        for(int i = rx - 1 ; i >= 0 ; i--) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n    \\n\\n        return count;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954708,
                "title": "easiest-fastest-approach-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int numRookCaptures(char[][] board){\\n        int x=-1, y=-1;\\n        for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(board[i][j]==\\'R\\'){\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int s = 0;\\n        \\n        for(int i=x; i<8; i++){\\n            if(board[i][y]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[i][y]==\\'B\\') break;\\n        }\\n\\n        for(int i=x; i>=0; i--){\\n            if(board[i][y]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[i][y]==\\'B\\') break;\\n        }\\n\\n\\n        for(int j=y; j<8; j++){\\n            if(board[x][j]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[x][j]==\\'B\\') break;\\n        }\\n\\n        for(int j=y; j>=0; j--){\\n            if(board[x][j]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[x][j]==\\'B\\') break;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int numRookCaptures(char[][] board){\\n        int x=-1, y=-1;\\n        for(int i=0; i<8; i++){\\n            for(int j=0; j<8; j++){\\n                if(board[i][j]==\\'R\\'){\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int s = 0;\\n        \\n        for(int i=x; i<8; i++){\\n            if(board[i][y]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[i][y]==\\'B\\') break;\\n        }\\n\\n        for(int i=x; i>=0; i--){\\n            if(board[i][y]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[i][y]==\\'B\\') break;\\n        }\\n\\n\\n        for(int j=y; j<8; j++){\\n            if(board[x][j]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[x][j]==\\'B\\') break;\\n        }\\n\\n        for(int j=y; j>=0; j--){\\n            if(board[x][j]==\\'p\\'){\\n                s++;\\n                break;\\n            }\\n            if(board[x][j]==\\'B\\') break;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925693,
                "title": "java-easy-solution-100-beats-0ms-for-loop-usage-only-beginner-level-by-sethupathi-k",
                "content": "# Intuition\\nKPRIET coimbatore\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        int m=0,n=0;\\n   \\n        for(int i=0 ; i<=7 ; i++ ){\\n           for(int j=0 ; j<=7 ; j++ ){\\n            \\n            if(board[i][j] == \\'R\\'){\\n\\n                m = i;\\n                n = j;\\n               break;\\n            }\\n        } \\n        }\\n\\n        /*System.out.println(m);\\n        System.out.println(n);*/\\n\\n        int c =0;\\n\\n        for(int i=m ; i<=7 ; i++ ){\\n            if(board[i][n] ==\\'B\\'){\\n               break;\\n            }\\n            else if(board[i][n] == \\'p\\'){\\n               c++;\\n               break;\\n              \\n            }\\n        }\\n\\n        for(int i=m ; i>=0 ; i-- ){\\n             if(board[i][n] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[i][n] == \\'p\\'){\\n                 c++;\\n                break;\\n                 \\n            }\\n        }\\n\\n        for(int i=n ; i<=7 ; i++ ){\\n            if(board[m][i] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[m][i] == \\'p\\'){\\n               c++;\\n               break;\\n              \\n            }\\n        }\\n\\n        for(int i=n ; i>=0 ; i-- ){\\n            if(board[m][i] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[m][i] == \\'p\\'){\\n                 c++;\\n                 break;\\n                \\n            }\\n        }\\n\\n\\n\\n\\n\\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        \\n        int m=0,n=0;\\n   \\n        for(int i=0 ; i<=7 ; i++ ){\\n           for(int j=0 ; j<=7 ; j++ ){\\n            \\n            if(board[i][j] == \\'R\\'){\\n\\n                m = i;\\n                n = j;\\n               break;\\n            }\\n        } \\n        }\\n\\n        /*System.out.println(m);\\n        System.out.println(n);*/\\n\\n        int c =0;\\n\\n        for(int i=m ; i<=7 ; i++ ){\\n            if(board[i][n] ==\\'B\\'){\\n               break;\\n            }\\n            else if(board[i][n] == \\'p\\'){\\n               c++;\\n               break;\\n              \\n            }\\n        }\\n\\n        for(int i=m ; i>=0 ; i-- ){\\n             if(board[i][n] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[i][n] == \\'p\\'){\\n                 c++;\\n                break;\\n                 \\n            }\\n        }\\n\\n        for(int i=n ; i<=7 ; i++ ){\\n            if(board[m][i] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[m][i] == \\'p\\'){\\n               c++;\\n               break;\\n              \\n            }\\n        }\\n\\n        for(int i=n ; i>=0 ; i-- ){\\n            if(board[m][i] == \\'B\\'){\\n               break;\\n            }\\n            else if(board[m][i] == \\'p\\'){\\n                 c++;\\n                 break;\\n                \\n            }\\n        }\\n\\n\\n\\n\\n\\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718174,
                "title": "easy-solution-in-java-runtime-0-ms-100-beats-fully-explained",
                "content": "# Approach\\nTo find the number of available captures for the white rook, we can iterate over the chessboard and locate the position of the rook (\\'R\\'). Once we find the rook, we can check in four cardinal directions (up, down, left, right) for pawns (\\'p\\') and bishops (\\'B\\').\\n\\n1. Initialize a variable `count` to keep track of the number of available captures.\\n2. Use nested loops to iterate over each cell on the chessboard.\\n3. When the rook is found (board[i][j] == \\'R\\'), perform the following steps:\\n   - Initialize variables k and t to represent the row and column indices, respectively.\\n   - Check in the upward direction by decrementing k (k--) until reaching the top edge of the board (k >= 0).\\n     - If a bishop (\\'B\\') is encountered, break the loop as the rook is blocked in this direction.\\n     - If a pawn (\\'p\\') is encountered, increment the `count` and break the loop as the rook can capture the pawn.\\n   - Repeat the same process for the downward direction by incrementing k (k++) until reaching the bottom edge of the board (k < board.length).\\n   - Check in the leftward direction by decrementing t (t--) until reaching the left edge of the board (t >= 0).\\n     - If a bishop (\\'B\\') is encountered, break the loop.\\n     - If a pawn (\\'p\\') is encountered, increment the `count` and break the loop.\\n   - Repeat the same process for the rightward direction by incrementing t (t++) until reaching the right edge of the board (t < board[0].length).\\n   - Break the outer loop using a labeled statement (`break loop;`) to avoid unnecessary iterations once the rook is found and processed.\\n4. After the loops, return the value of `count` as the result.\\n\\nThis approach scans the board in a straightforward manner, checking each direction for pawns and bishops until an obstacle is encountered or the edge of the board is reached. The `count` variable keeps track of the number of captured pawns, which is the final result returned by the function.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n\\n        loop:\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int k = i - 1;\\n                    while(k >= 0){\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }\\n                        k--;\\n                    }\\n                    k = i + 1;\\n                    while(k < board.length) {\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }\\n                        k++;\\n                    }\\n\\n                    int t = j - 1;\\n                    while(t >= 0){\\n                        if(board[i][t] == \\'B\\') break;\\n                        if(board[i][t] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        }\\n                        t--;\\n                    }\\n                    t = j + 1;\\n                    while(t < board[0].length){\\n                        if(board[i][t] == \\'B\\') break;\\n                        if(board[i][t] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        }\\n                        t++;    \\n                    }\\n\\n                    break loop;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n\\n        loop:\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    int k = i - 1;\\n                    while(k >= 0){\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }\\n                        k--;\\n                    }\\n                    k = i + 1;\\n                    while(k < board.length) {\\n                        if(board[k][j] == \\'B\\') break;\\n                        if(board[k][j] == \\'p\\'){\\n                            count++;\\n                            break;\\n                        }\\n                        k++;\\n                    }\\n\\n                    int t = j - 1;\\n                    while(t >= 0){\\n                        if(board[i][t] == \\'B\\') break;\\n                        if(board[i][t] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        }\\n                        t--;\\n                    }\\n                    t = j + 1;\\n                    while(t < board[0].length){\\n                        if(board[i][t] == \\'B\\') break;\\n                        if(board[i][t] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        }\\n                        t++;    \\n                    }\\n\\n                    break loop;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540686,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        static vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n        int r = -1, c = -1;\\n        for (int i = 0; i < 8 && r == -1; ++i) {\\n            for (int j = 0; j < 8; ++j) {\\n                if (board[i][j] == \\'R\\') {\\n                    tie(r, c) = make_pair(i, j);\\n                    break;\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (const auto& d : directions) {\\n            int nr, nc;\\n            tie(nr, nc) = make_pair(r + d.first, c + d.second);\\n            while (0 <= nr && nr < 8 && 0 <= nc && nc < 8) {\\n                if (board[nr][nc] == \\'p\\') {\\n                    ++result;\\n                }\\n                if (board[nr][nc] != \\'.\\') {\\n                    break;\\n                }\\n                tie(nr, nc) = make_pair(nr + d.first, nc + d.second);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rook = None\\n        while rook is None:\\n            for i in range(8):\\n                for j in range(8):\\n                    if board[i][j] == \\'R\\':\\n                        rook = (i, j)\\n                        break\\n        \\n        available_captures = 0\\n        for i in range(rook[0] - 1, -1, -1):\\n            if board[i][rook[1]] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[i][rook[1]] == \\'B\\':\\n                break\\n        for i in range(rook[0] + 1, 8):\\n            if board[i][rook[1]] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[i][rook[1]] == \\'B\\':\\n                break\\n        for j in range(rook[1] - 1, -1, -1):\\n            if board[rook[0]][j] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[rook[0]][j] == \\'B\\':\\n                break\\n        for j in range(rook[1] + 1, 8):\\n            if board[rook[0]][j] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[rook[0]][j] == \\'B\\':\\n                break\\n        return available_captures\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ii=0,jj=0;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    ii=i;\\n                    jj=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=ii;i>=0;i--){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int i=ii;i<8;i++){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j<8;j++){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j>=0;j--){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        static vector<pair<int, int>> directions{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n        int r = -1, c = -1;\\n        for (int i = 0; i < 8 && r == -1; ++i) {\\n            for (int j = 0; j < 8; ++j) {\\n                if (board[i][j] == \\'R\\') {\\n                    tie(r, c) = make_pair(i, j);\\n                    break;\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (const auto& d : directions) {\\n            int nr, nc;\\n            tie(nr, nc) = make_pair(r + d.first, c + d.second);\\n            while (0 <= nr && nr < 8 && 0 <= nc && nc < 8) {\\n                if (board[nr][nc] == \\'p\\') {\\n                    ++result;\\n                }\\n                if (board[nr][nc] != \\'.\\') {\\n                    break;\\n                }\\n                tie(nr, nc) = make_pair(nr + d.first, nc + d.second);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rook = None\\n        while rook is None:\\n            for i in range(8):\\n                for j in range(8):\\n                    if board[i][j] == \\'R\\':\\n                        rook = (i, j)\\n                        break\\n        \\n        available_captures = 0\\n        for i in range(rook[0] - 1, -1, -1):\\n            if board[i][rook[1]] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[i][rook[1]] == \\'B\\':\\n                break\\n        for i in range(rook[0] + 1, 8):\\n            if board[i][rook[1]] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[i][rook[1]] == \\'B\\':\\n                break\\n        for j in range(rook[1] - 1, -1, -1):\\n            if board[rook[0]][j] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[rook[0]][j] == \\'B\\':\\n                break\\n        for j in range(rook[1] + 1, 8):\\n            if board[rook[0]][j] == \\'p\\':\\n                available_captures += 1\\n                break\\n            elif board[rook[0]][j] == \\'B\\':\\n                break\\n        return available_captures\\n```\n```Java []\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ii=0,jj=0;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    ii=i;\\n                    jj=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=ii;i>=0;i--){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int i=ii;i<8;i++){\\n            if(board[i][jj]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][jj]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j<8;j++){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        for(int j=jj;j>=0;j--){\\n            if(board[ii][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[ii][j]==\\'B\\')\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404387,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] b) {\\n        int cnt=0;\\n        for(int i=0;i<b.length;i++){\\n            for(int j=0;j<b[0].length;j++){\\n                if(b[i][j]==\\'R\\'){\\n                    //left\\n                    int l=j-1;\\n                    while(l>=0){\\n                        if(b[i][l]==\\'B\\'){\\n                            break;\\n                        }else if(b[i][l]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        l--;\\n                    }\\n                    //right\\n                   \\n                    int r=j+1;\\n                    while(r<b.length){\\n                        if(b[i][r]==\\'B\\'){\\n                            break;\\n                        }else if(b[i][r]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        r++;\\n                    }\\n                    //top\\n                    // if((i-1)>=0 && (b[i-1][j]==\\'.\\' || b[i-1][j]==\\'p\\')) cnt++;\\n                    int t=i-1;\\n                    while(t>=0){\\n                        if(b[t][j]==\\'B\\'){\\n                            break;\\n                        }else if(b[t][j]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        t--;\\n                    }\\n\\n                    //bottom\\n                    // if((i+1)<b.length && (b[i+1][j]==\\'.\\' && b[i+1][j]==\\'p\\' )) cnt++;\\n                    int u=i+1;\\n                    while(u<b.length){\\n                        if(b[u][j]==\\'B\\'){\\n                            break;\\n                        }else if(b[u][j]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                       u++;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n    }\\n     return cnt;\\n    }\\n }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] b) {\\n        int cnt=0;\\n        for(int i=0;i<b.length;i++){\\n            for(int j=0;j<b[0].length;j++){\\n                if(b[i][j]==\\'R\\'){\\n                    //left\\n                    int l=j-1;\\n                    while(l>=0){\\n                        if(b[i][l]==\\'B\\'){\\n                            break;\\n                        }else if(b[i][l]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        l--;\\n                    }\\n                    //right\\n                   \\n                    int r=j+1;\\n                    while(r<b.length){\\n                        if(b[i][r]==\\'B\\'){\\n                            break;\\n                        }else if(b[i][r]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        r++;\\n                    }\\n                    //top\\n                    // if((i-1)>=0 && (b[i-1][j]==\\'.\\' || b[i-1][j]==\\'p\\')) cnt++;\\n                    int t=i-1;\\n                    while(t>=0){\\n                        if(b[t][j]==\\'B\\'){\\n                            break;\\n                        }else if(b[t][j]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                        t--;\\n                    }\\n\\n                    //bottom\\n                    // if((i+1)<b.length && (b[i+1][j]==\\'.\\' && b[i+1][j]==\\'p\\' )) cnt++;\\n                    int u=i+1;\\n                    while(u<b.length){\\n                        if(b[u][j]==\\'B\\'){\\n                            break;\\n                        }else if(b[u][j]==\\'p\\'){\\n                            cnt++;\\n                            break;\\n                        } \\n                       u++;\\n                    }\\n                    break;\\n            }\\n        }\\n        \\n    }\\n     return cnt;\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336852,
                "title": "available-captures-for-rook-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int i, j, x, y, count=0;\\n        for(i=0 ; i<board.size() ; i++)\\n        {\\n            for(j=0 ; j<board[0].size() ; j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        for(i=x+1 ; i<board[0].size() ; i++)\\n        {\\n            if(board[i][y]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[i][y]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        for(i=x-1 ; i>=0; i--)\\n        {\\n            if(board[i][y]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[i][y]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n\\n        for(i=y+1 ; i<board.size() ; i++)\\n        {\\n            if(board[x][i]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[x][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        for(i=y-1 ; i>=0; i--)\\n        {\\n            if(board[x][i]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[x][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int i, j, x, y, count=0;\\n        for(i=0 ; i<board.size() ; i++)\\n        {\\n            for(j=0 ; j<board[0].size() ; j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        for(i=x+1 ; i<board[0].size() ; i++)\\n        {\\n            if(board[i][y]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[i][y]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        for(i=x-1 ; i>=0; i--)\\n        {\\n            if(board[i][y]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[i][y]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n\\n        for(i=y+1 ; i<board.size() ; i++)\\n        {\\n            if(board[x][i]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[x][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        for(i=y-1 ; i>=0; i--)\\n        {\\n            if(board[x][i]==\\'B\\')\\n            {\\n                break;\\n            }\\n            else if(board[x][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249884,
                "title": "rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let mut rook = (0, 0);\\n        let mut pawns = vec![];\\n        let mut bishops = vec![];\\n        let directions = [(0, -1), (0, 1), (-1, 0), (1, 0)];\\n        let mut count = 0;\\n\\n        (0..8usize).for_each(|i| {\\n            (0..8usize).for_each(|j| match board[i][j] {\\n                \\'R\\' => rook = (i, j),\\n                \\'p\\' => pawns.push((i, j)),\\n                \\'B\\' => bishops.push((i, j)),\\n                _ => (),\\n            })\\n        });\\n\\n        pawns = pawns\\n            .into_iter()\\n            .filter(|&(i, j)| rook.0 == i || rook.1 == j)\\n            .collect();\\n\\n        bishops = bishops\\n            .into_iter()\\n            .filter(|&(i, j)| rook.0 == i || rook.1 == j)\\n            .collect();\\n\\n        for (x, y) in directions {\\n            let (mut i, mut j) = rook;\\n            while (0..8).contains(&i) && (0..8).contains(&j) {\\n                i += x as usize;\\n                j += y as usize;\\n                if bishops.contains(&(i, j)) {\\n                    break;\\n                }\\n                if pawns.contains(&(i, j)) {\\n                    count += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let mut rook = (0, 0);\\n        let mut pawns = vec![];\\n        let mut bishops = vec![];\\n        let directions = [(0, -1), (0, 1), (-1, 0), (1, 0)];\\n        let mut count = 0;\\n\\n        (0..8usize).for_each(|i| {\\n            (0..8usize).for_each(|j| match board[i][j] {\\n                \\'R\\' => rook = (i, j),\\n                \\'p\\' => pawns.push((i, j)),\\n                \\'B\\' => bishops.push((i, j)),\\n                _ => (),\\n            })\\n        });\\n\\n        pawns = pawns\\n            .into_iter()\\n            .filter(|&(i, j)| rook.0 == i || rook.1 == j)\\n            .collect();\\n\\n        bishops = bishops\\n            .into_iter()\\n            .filter(|&(i, j)| rook.0 == i || rook.1 == j)\\n            .collect();\\n\\n        for (x, y) in directions {\\n            let (mut i, mut j) = rook;\\n            while (0..8).contains(&i) && (0..8).contains(&j) {\\n                i += x as usize;\\n                j += y as usize;\\n                if bishops.contains(&(i, j)) {\\n                    break;\\n                }\\n                if pawns.contains(&(i, j)) {\\n                    count += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3067558,
                "title": "javascript-solution-using-regex-not-that-fast-btw",
                "content": "\\n# Code\\n```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    var pawnCount = 0;\\n    var horizontal;\\n    var vertical = \"\";\\n    \\n    for (let i in board) {\\n        if (board[i].includes(\\'R\\')) {\\n            horizontal = board[i].join(\"\");\\n            for (let j = 0; j < 8; j++) {\\n                vertical += board[j][board[i].indexOf(\\'R\\')]\\n            }\\n        }\\n    }\\n\\n    for (let match of horizontal.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of horizontal.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    \\n    return pawnCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    var pawnCount = 0;\\n    var horizontal;\\n    var vertical = \"\";\\n    \\n    for (let i in board) {\\n        if (board[i].includes(\\'R\\')) {\\n            horizontal = board[i].join(\"\");\\n            for (let j = 0; j < 8; j++) {\\n                vertical += board[j][board[i].indexOf(\\'R\\')]\\n            }\\n        }\\n    }\\n\\n    for (let match of horizontal.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of horizontal.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(p[.]*R)\")) pawnCount++;\\n    for (let match of vertical.matchAll(\"(R[.]*p)\")) pawnCount++;\\n    \\n    return pawnCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3041614,
                "title": "beats-98-87-solutions-easy-to-understand-python-code-with-explanation-by-bolt-coding",
                "content": "# Explanation:\\nFirst we try to find the position of Rook.\\nOnce we get that we already know that Rook always attacks in straight line i.e. Rows or Columns (not diagonals). So rather than traversing through the whole list we will only traverse through the rows and columns where Rook can attack. So we right 4 different for loops to traverse through rows and columns.\\n\\n# Complexity\\n- **Time complexity**: O(n^2) : As in worst case scenario the ROOK might be at position (7, 7)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        idx = []\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    idx = [i, j]\\n                    break\\n        x, y = idx[0], idx[1]\\n        count = 0\\n        for i in range(x-1, -1, -1):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, 8):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n\\n        for i in range(y-1, -1, -1):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        \\n        for i in range(y+1, 8):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        return count\\n\\n```\\n\\n# Learning\\nTo understand problems in simpler ways, need help with projects, want to learn coding from scratch, work on resume level projects, learn data science ...................\\n\\nSubscribe to Bolt Coding Channel - https://www.youtube.com/@boltcoding",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        idx = []\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    idx = [i, j]\\n                    break\\n        x, y = idx[0], idx[1]\\n        count = 0\\n        for i in range(x-1, -1, -1):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, 8):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n\\n        for i in range(y-1, -1, -1):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        \\n        for i in range(y+1, 8):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963334,
                "title": "999-java-5-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI Suggested for you, easy way to understand read my approach **last to first**;\\nAnd I challenge you **did not understand first approach**;\\n# Approach 1\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.9 MB\\n- Beats : 80%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = -1 , ans = 0;\\n        for(;j == -1;i++)  j = new String(board[i]).indexOf(\\'R\\');\\n        for(char ch : \"lrud\".toCharArray()) ans += find(board,ch,i-1,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch == \\'l\\' && --row < 0|| ch == \\'u\\' && --col < 0) break;\\n            if(ch == \\'r\\' && ++row > 7|| ch == \\'d\\' && ++col > 7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n# Approach 2\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.9 MB\\n- Beats : 80.51%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        for(;i<8;i++){\\n            j = new String(board[i]).indexOf(\\'R\\');\\n            if(j != -1) break;\\n        }\\n        for(char ch : \"lrud\".toCharArray()) ans+=find(board,ch,i,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n# Approach 3\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.4 MB\\n- Beats : 99.75%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        out :\\n        for(;i<8;i++)  {\\n            for(int k = 0;k<8;k++) {\\n                if(board[i][k] == \\'R\\') {\\n                    j = k;\\n                    break out;\\n                }\\n            }\\n\\n        }\\n        for(char ch : \"lrud\".toCharArray()) ans+=find(board,ch,i,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n# Approach 4\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 40.1 MB\\n- Beats : 60.51%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        out :\\n        for(;i<8;i++)  {\\n            for(int k = 0;k<8;k++) {\\n                if(board[i][k] == \\'R\\') {\\n                    j = k;\\n                    break out;\\n                }\\n            }\\n\\n        }\\n        ans += find(board , \\'l\\' , i , j);\\n        ans += find(board , \\'r\\' , i , j);\\n        ans += find(board , \\'u\\' , i , j);\\n        ans += find(board , \\'d\\' , i , j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n# Approach 5\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j= 0 , ans = 0;\\n    out:while(i < 8){\\n            while(j < 8){\\n                if(board[i][j] == \\'R\\') break out;\\n                j++;\\n            }\\n            i++;\\n            j = 0;\\n        }\\n        int i1 = i , j1 = j;\\n        while(i1 >= 0) {\\n            if(board[i1][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i1][j] == \\'B\\') break;\\n            i1--;\\n        }\\n        i1 = i;\\n        while(i1 < 8) {\\n            if(board[i1][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i1][j] == \\'B\\') break;\\n            i1++;\\n        }\\n        while(j1 >= 0) {\\n            if(board[i][j1] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][j1] == \\'B\\') break;\\n            j1--;\\n        }\\n        while(j < 8) {\\n            if(board[i][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][j] == \\'B\\') break;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = -1 , ans = 0;\\n        for(;j == -1;i++)  j = new String(board[i]).indexOf(\\'R\\');\\n        for(char ch : \"lrud\".toCharArray()) ans += find(board,ch,i-1,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch == \\'l\\' && --row < 0|| ch == \\'u\\' && --col < 0) break;\\n            if(ch == \\'r\\' && ++row > 7|| ch == \\'d\\' && ++col > 7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        for(;i<8;i++){\\n            j = new String(board[i]).indexOf(\\'R\\');\\n            if(j != -1) break;\\n        }\\n        for(char ch : \"lrud\".toCharArray()) ans+=find(board,ch,i,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        out :\\n        for(;i<8;i++)  {\\n            for(int k = 0;k<8;k++) {\\n                if(board[i][k] == \\'R\\') {\\n                    j = k;\\n                    break out;\\n                }\\n            }\\n\\n        }\\n        for(char ch : \"lrud\".toCharArray()) ans+=find(board,ch,i,j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j = 0 , ans = 0;\\n        out :\\n        for(;i<8;i++)  {\\n            for(int k = 0;k<8;k++) {\\n                if(board[i][k] == \\'R\\') {\\n                    j = k;\\n                    break out;\\n                }\\n            }\\n\\n        }\\n        ans += find(board , \\'l\\' , i , j);\\n        ans += find(board , \\'r\\' , i , j);\\n        ans += find(board , \\'u\\' , i , j);\\n        ans += find(board , \\'d\\' , i , j);\\n        return ans;\\n    }\\n    public int find(char[][] b , char ch , int row , int col){\\n        while(true){\\n            if(b[row][col] == \\'p\\')return 1;\\n            if(b[row][col] == \\'B\\') break;\\n            if(ch==\\'l\\' && --col<0 || ch==\\'u\\' && --row<0) break;\\n            if(ch==\\'r\\' && ++col>7 || ch==\\'d\\' && ++row>7) break;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int i = 0 , j= 0 , ans = 0;\\n    out:while(i < 8){\\n            while(j < 8){\\n                if(board[i][j] == \\'R\\') break out;\\n                j++;\\n            }\\n            i++;\\n            j = 0;\\n        }\\n        int i1 = i , j1 = j;\\n        while(i1 >= 0) {\\n            if(board[i1][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i1][j] == \\'B\\') break;\\n            i1--;\\n        }\\n        i1 = i;\\n        while(i1 < 8) {\\n            if(board[i1][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i1][j] == \\'B\\') break;\\n            i1++;\\n        }\\n        while(j1 >= 0) {\\n            if(board[i][j1] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][j1] == \\'B\\') break;\\n            j1--;\\n        }\\n        while(j < 8) {\\n            if(board[i][j] == \\'p\\') {\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][j] == \\'B\\') break;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653423,
                "title": "c-easy-to-understand-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int cap(vector<vector<char>>& b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.size() && y >= 0 && y < b[x].size() && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx, y += dy;\\n  }\\n  return 0;\\n}\\nint numRookCaptures(vector<vector<char>>& b) {\\n  for (auto i = 0; i < b.size(); ++i)\\n    for (auto j = 0; j < b[i].size(); ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int cap(vector<vector<char>>& b, int x, int y, int dx, int dy) {\\n  while (x >= 0 && x < b.size() && y >= 0 && y < b[x].size() && b[x][y] != \\'B\\') {\\n    if (b[x][y] == \\'p\\') return 1;\\n    x += dx, y += dy;\\n  }\\n  return 0;\\n}\\nint numRookCaptures(vector<vector<char>>& b) {\\n  for (auto i = 0; i < b.size(); ++i)\\n    for (auto j = 0; j < b[i].size(); ++j)\\n      if (b[i][j] == \\'R\\') return cap(b,i,j,0,1)+cap(b,i,j,0,-1)+cap(b,i,j,1,0)+cap(b,i,j,-1,0);\\n  return 0;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492006,
                "title": "python3-dfs",
                "content": "\\n```\\nfrom typing import List\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        #move in the given direction until the edge of the board or pawn or bishop is encountered\\n        def attack(r, c, i, j):\\n            ans = 0\\n            while 0<=r<8 and 0<=c<8:\\n                if board[r][c]==\\'p\\':\\n                    ans += 1\\n                    break\\n                if board[r][c]==\\'B\\':\\n                    break\\n                r, c = r+i, c+j\\n            return ans\\n            \\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j]==\\'R\\':\\n                    #check all 4 directions\\n                    return attack(i, j, 0, 1) + attack(i, j, 0, -1) + attack(i, j, 1, 0) + attack(i, j, -1, 0)\\n        return 0",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Simulation"
                ],
                "code": "\\n```\\nfrom typing import List\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        #move in the given direction until the edge of the board or pawn or bishop is encountered\\n        def attack(r, c, i, j):\\n            ans = 0\\n            while 0<=r<8 and 0<=c<8:\\n                if board[r][c]==\\'p\\':\\n                    ans += 1\\n                    break\\n                if board[r][c]==\\'B\\':\\n                    break\\n                r, c = r+i, c+j\\n            return ans\\n            \\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j]==\\'R\\':\\n                    #check all 4 directions\\n                    return attack(i, j, 0, 1) + attack(i, j, 0, -1) + attack(i, j, 1, 0) + attack(i, j, -1, 0)\\n        return 0",
                "codeTag": "Java"
            },
            {
                "id": 2459684,
                "title": "java-simple-solution-0-seconds",
                "content": "The code is self-explanatory\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int[] rowCol = findRook(board);\\n        int countCaptures = 0;\\n        if (canCaptureUp(rowCol, board)) countCaptures++;\\n        if (canCaptureRight(rowCol, board)) countCaptures++;\\n        if (canCaptureDown(rowCol, board)) countCaptures++;\\n        if (canCaptureLeft(rowCol, board)) countCaptures++;\\n        return countCaptures;\\n    }\\n    \\n    private int[] findRook(char[][] board) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    return new int[]{i, j};\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    private boolean canCaptureUp(int[] rowCol, char[][] board) {\\n        int row = rowCol[0];\\n        int col = rowCol[1];\\n        while (cellExist(--row, col, board)) {\\n            char cell = board[row][col];\\n            if (cell == \\'p\\') {\\n                return true;\\n            } else if (cell == \\'B\\') {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean canCaptureRight(int[] rowCol, char[][] board) {\\n        int row = rowCol[0];\\n        int col = rowCol[1];\\n        while (cellExist(row, ++col, board)) {\\n            char cell = board[row][col];\\n            if (cell == \\'p\\') {\\n                return true;\\n            } else if (cell == \\'B\\') {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean canCaptureDown(int[] rowCol, char[][] board) {\\n        int row = rowCol[0];\\n        int col = rowCol[1];\\n        while (cellExist(++row, col, board)) {\\n            char cell = board[row][col];\\n            if (cell == \\'p\\') {\\n                return true;\\n            } else if (cell == \\'B\\') {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean canCaptureLeft(int[] rowCol, char[][] board) {\\n        int row = rowCol[0];\\n        int col = rowCol[1];\\n        while (cellExist(row, --col, board)) {\\n            char cell = board[row][col];\\n            if (cell == \\'p\\') {\\n                return true;\\n            } else if (cell == \\'B\\') {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean cellExist(int row, int col, char[][] array) {\\n        return (row <= array.length - 1 && row >= 0) && (col <= array[0].length - 1 && col >= 0);\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int[] rowCol = findRook(board);\\n        int countCaptures = 0;\\n        if (canCaptureUp(rowCol, board)) countCaptures++;\\n        if (canCaptureRight(rowCol, board)) countCaptures++;\\n        if (canCaptureDown(rowCol, board)) countCaptures++;\\n        if (canCaptureLeft(rowCol, board)) countCaptures++;\\n        return countCaptures;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2355406,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\nvar numRookCaptures = function(board) {\\n    let count = 0;\\n    \\n    let rowIndex;\\n    let colIndex;\\n    let flag = false;\\n    //Find the location of R in board\\n    for(let i=0; i<8; i++){\\n        for(let j=0; j<8; j++){\\n            if(board[i][j] === \"R\"){\\n                rowIndex = i;\\n                colIndex = j;\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if(flag === true)\\n            break;\\n    }\\n    \\n    //Move upwards\\n    for(let i=rowIndex; i>=0; i--){\\n        if(board[i][colIndex] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[i][colIndex] === \\'B\\')\\n            break;\\n    }\\n    //Move downwards\\n    for(let i=rowIndex; i<8; i++){\\n        if(board[i][colIndex] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[i][colIndex] === \\'B\\')\\n            break;\\n    }\\n    //Move right\\n    for(let i=colIndex; i<8; i++){\\n        if(board[rowIndex][i] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[rowIndex][i] === \\'B\\')\\n            break;\\n    }\\n    //Move left\\n    for(let i=colIndex; i>=0; i--){\\n        if(board[rowIndex][i] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[rowIndex][i] === \\'B\\')\\n            break;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nvar numRookCaptures = function(board) {\\n    let count = 0;\\n    \\n    let rowIndex;\\n    let colIndex;\\n    let flag = false;\\n    //Find the location of R in board\\n    for(let i=0; i<8; i++){\\n        for(let j=0; j<8; j++){\\n            if(board[i][j] === \"R\"){\\n                rowIndex = i;\\n                colIndex = j;\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if(flag === true)\\n            break;\\n    }\\n    \\n    //Move upwards\\n    for(let i=rowIndex; i>=0; i--){\\n        if(board[i][colIndex] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[i][colIndex] === \\'B\\')\\n            break;\\n    }\\n    //Move downwards\\n    for(let i=rowIndex; i<8; i++){\\n        if(board[i][colIndex] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[i][colIndex] === \\'B\\')\\n            break;\\n    }\\n    //Move right\\n    for(let i=colIndex; i<8; i++){\\n        if(board[rowIndex][i] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[rowIndex][i] === \\'B\\')\\n            break;\\n    }\\n    //Move left\\n    for(let i=colIndex; i>=0; i--){\\n        if(board[rowIndex][i] === \\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        else if(board[rowIndex][i] === \\'B\\')\\n            break;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326469,
                "title": "c-100-faster-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int res=0;\\n        int p=-1,q=-1;\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==\\'R\\') // storing position of R\\n                {\\n                    p=i;\\n                    q=j;\\n                    break;\\n                }\\n            }\\n            if(p>=0)\\n                break;\\n        }\\n        // traverse Up, Down, Left and Right from R\\n        for(int i=p+1;i<board.size();i++)\\n        {\\n            if(board[i][q]!=\\'.\\')\\n            {\\n                if(board[i][q]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        for(int i=p-1;i>=0;i--)\\n        {\\n            if(board[i][q]!=\\'.\\')\\n            {\\n                if(board[i][q]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        \\n        for(int j=q+1;j<board[0].size();j++)\\n        {\\n            if(board[p][j]!=\\'.\\')\\n            {\\n                if(board[p][j]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        for(int j=q-1;j>=0;j--)\\n        {\\n            if(board[p][j]!=\\'.\\')\\n            {\\n                if(board[p][j]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int res=0;\\n        int p=-1,q=-1;\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==\\'R\\') // storing position of R\\n                {\\n                    p=i;\\n                    q=j;\\n                    break;\\n                }\\n            }\\n            if(p>=0)\\n                break;\\n        }\\n        // traverse Up, Down, Left and Right from R\\n        for(int i=p+1;i<board.size();i++)\\n        {\\n            if(board[i][q]!=\\'.\\')\\n            {\\n                if(board[i][q]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        for(int i=p-1;i>=0;i--)\\n        {\\n            if(board[i][q]!=\\'.\\')\\n            {\\n                if(board[i][q]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        \\n        for(int j=q+1;j<board[0].size();j++)\\n        {\\n            if(board[p][j]!=\\'.\\')\\n            {\\n                if(board[p][j]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        for(int j=q-1;j>=0;j--)\\n        {\\n            if(board[p][j]!=\\'.\\')\\n            {\\n                if(board[p][j]==\\'p\\')\\n                    res++;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224853,
                "title": "c-0-ms-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n               \\n        int x, y;\\n        \\n        for(int i=0; i<8; i++)\\n            for(int j=0; j<8; j++)\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    x = i, y = j;\\n                    break;\\n                }\\n\\n        int res = 0;\\n        \\n        //up\\n        for(int i=x-1; i>=0; i--)\\n            if (board[i][y] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[i][y] == \\'B\\')\\n                break;\\n        \\n        //down\\n        for(int i=x+1; i < 8; i++)\\n            if (board[i][y] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[i][y] == \\'B\\')\\n                break;        \\n        \\n        //left\\n        for(int j = y-1; j >= 0; j--)\\n            if (board[x][j] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[x][j] == \\'B\\')\\n                break;  \\n        \\n        //right\\n        for(int j = y+1; j < 8; j++)\\n            if (board[x][j] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[x][j] == \\'B\\')\\n                break; \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n               \\n        int x, y;\\n        \\n        for(int i=0; i<8; i++)\\n            for(int j=0; j<8; j++)\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    x = i, y = j;\\n                    break;\\n                }\\n\\n        int res = 0;\\n        \\n        //up\\n        for(int i=x-1; i>=0; i--)\\n            if (board[i][y] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[i][y] == \\'B\\')\\n                break;\\n        \\n        //down\\n        for(int i=x+1; i < 8; i++)\\n            if (board[i][y] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[i][y] == \\'B\\')\\n                break;        \\n        \\n        //left\\n        for(int j = y-1; j >= 0; j--)\\n            if (board[x][j] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[x][j] == \\'B\\')\\n                break;  \\n        \\n        //right\\n        for(int j = y+1; j < 8; j++)\\n            if (board[x][j] == \\'p\\')\\n            {\\n                res++; break;;\\n            }\\n            else if(board[x][j] == \\'B\\')\\n                break; \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158272,
                "title": "easy-c",
                "content": "In rook\\'s way, two possible pieces-Bishop and Pawn.\\n4 directions(Up,Down,Right,Left)\\nFor every direction:\\n\\tIf Pawn +1 and break loop.\\n\\tIf bishop, break loop.\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r=0,c=0;\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[i].size();j++) {\\n                if(board[i][j]==\\'R\\'){\\n                    r=i;\\n                    c=j;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int i=r,j=c;\\n        while(i-->0) {\\n            if(board[i][c]==\\'B\\')\\n                break;\\n            if(board[i][c]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        while(j-->0) {\\n            if(board[r][j]==\\'B\\')\\n                break;\\n            if(board[r][j]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        i=r;\\n        while(i++<7) {\\n            if(board[i][c]==\\'B\\')\\n                break;\\n            if(board[i][c]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        j=c;\\n        while(j++<7) {\\n            if(board[r][j]==\\'B\\')\\n                break;\\n            if(board[r][j]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r=0,c=0;\\n        for(int i=0;i<board.size();i++) {\\n            for(int j=0;j<board[i].size();j++) {\\n                if(board[i][j]==\\'R\\'){\\n                    r=i;\\n                    c=j;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        int i=r,j=c;\\n        while(i-->0) {\\n            if(board[i][c]==\\'B\\')\\n                break;\\n            if(board[i][c]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        while(j-->0) {\\n            if(board[r][j]==\\'B\\')\\n                break;\\n            if(board[r][j]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        i=r;\\n        while(i++<7) {\\n            if(board[i][c]==\\'B\\')\\n                break;\\n            if(board[i][c]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        j=c;\\n        while(j++<7) {\\n            if(board[r][j]==\\'B\\')\\n                break;\\n            if(board[r][j]==\\'p\\') {\\n                ans++;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059535,
                "title": "javascript-solution-faster-than-97-33",
                "content": "<img src=\"https://assets.leetcode.com/users/images/f2cab14a-2511-42c0-9e8c-15d850fb283b_1653122499.248853.png\" width=\"600\"/>\\n\\n```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board => {\\n    // set checker grids\\n    const rows = new Array(8).fill(\\'\\'), cols = new Array(8).fill(\\'\\');\\n\\n    // set rook and capture travel\\n    let rook = { x: -1, y: -1 }, captures = 0;\\n\\n    for (let i = 0; i < 8; i++) {\\n        for (let j = 0; j < 8; j++) {\\n            rows[i] += board[i][j];\\n            cols[i] += board[j][i];\\n            \\n            if (board[i][j] === `R`) {\\n                rook.x = i;\\n                rook.y = j;\\n            }\\n        }\\n    }\\n\\n    // horizontal\\n    look(rows[rook.x]);\\n    // vertical\\n    look(cols[rook.y]);\\n\\n    // captures after looks\\n    return captures;\\n\\n    /**\\n     * negative: /p\\\\.*R/ - left, up\\n     * positive: /R\\\\.*p/ - right, down\\n     * ======== ======== ========\\n     */\\n    function look(value) {\\n        // negative\\n        if (/p\\\\.*R/.test(value)) {\\n            captures++;\\n        }\\n        // positive\\n        if (/R\\\\.*p/.test(value)) {\\n            captures++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nconst numRookCaptures = board => {\\n    // set checker grids\\n    const rows = new Array(8).fill(\\'\\'), cols = new Array(8).fill(\\'\\');\\n\\n    // set rook and capture travel\\n    let rook = { x: -1, y: -1 }, captures = 0;\\n\\n    for (let i = 0; i < 8; i++) {\\n        for (let j = 0; j < 8; j++) {\\n            rows[i] += board[i][j];\\n            cols[i] += board[j][i];\\n            \\n            if (board[i][j] === `R`) {\\n                rook.x = i;\\n                rook.y = j;\\n            }\\n        }\\n    }\\n\\n    // horizontal\\n    look(rows[rook.x]);\\n    // vertical\\n    look(cols[rook.y]);\\n\\n    // captures after looks\\n    return captures;\\n\\n    /**\\n     * negative: /p\\\\.*R/ - left, up\\n     * positive: /R\\\\.*p/ - right, down\\n     * ======== ======== ========\\n     */\\n    function look(value) {\\n        // negative\\n        if (/p\\\\.*R/.test(value)) {\\n            captures++;\\n        }\\n        // positive\\n        if (/R\\\\.*p/.test(value)) {\\n            captures++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841822,
                "title": "python-solution-999",
                "content": "```\\nclass Solution:\\n  def numRookCaptures(self, board: List[List[str]]) -> int:\\n    ans = 0\\n\\n    for i in range(8):\\n      for j in range(8):\\n        if board[i][j] == \\'R\\':\\n          i0 = i\\n          j0 = j\\n\\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n      i = i0 + d[0]\\n      j = j0 + d[1]\\n      while 0 <= i < 8 and 0 <= j < 8:\\n        if board[i][j] == \\'p\\':\\n          ans += 1\\n        if board[i][j] != \\'.\\':\\n          break\\n        i += d[0]\\n        j += d[1]\\n\\n    return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n  def numRookCaptures(self, board: List[List[str]]) -> int:\\n    ans = 0\\n\\n    for i in range(8):\\n      for j in range(8):\\n        if board[i][j] == \\'R\\':\\n          i0 = i\\n          j0 = j\\n\\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n      i = i0 + d[0]\\n      j = j0 + d[1]\\n      while 0 <= i < 8 and 0 <= j < 8:\\n        if board[i][j] == \\'p\\':\\n          ans += 1\\n        if board[i][j] != \\'.\\':\\n          break\\n        i += d[0]\\n        j += d[1]\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751788,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int xi=0,yj=0,check=0,count=0;\\n        \\n        // get Rook coordinates     \\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[i].length;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    xi=i;\\n                    yj=j;\\n                    check=1;\\n                    break;\\n                }\\n            }\\n            if(check==1)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Check west\\n        for(int j=yj;j>=0;j--)\\n        {\\n            char c=board[xi][j];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check east\\n        for(int j=yj;j<board[xi].length;j++)\\n        {\\n            char c=board[xi][j];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check north\\n        for(int i=xi;i>=0;i--)\\n        {\\n            char c=board[i][yj];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check South\\n        for(int i=xi;i<board.length;i++)\\n        {\\n            char c=board[i][yj];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int xi=0,yj=0,check=0,count=0;\\n        \\n        // get Rook coordinates     \\n        for(int i=0;i<board.length;i++)\\n        {\\n            for(int j=0;j<board[i].length;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    xi=i;\\n                    yj=j;\\n                    check=1;\\n                    break;\\n                }\\n            }\\n            if(check==1)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Check west\\n        for(int j=yj;j>=0;j--)\\n        {\\n            char c=board[xi][j];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check east\\n        for(int j=yj;j<board[xi].length;j++)\\n        {\\n            char c=board[xi][j];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check north\\n        for(int i=xi;i>=0;i--)\\n        {\\n            char c=board[i][yj];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n        // Check South\\n        for(int i=xi;i<board.length;i++)\\n        {\\n            char c=board[i][yj];\\n            if(c==\\'B\\')\\n            {\\n                break;\\n            }\\n            if(c==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613578,
                "title": "0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r=0,c=0,attack=0;\\n        \\n        for(r=0;r<8;r++){\\n            for(c=0;c<8;c++){\\n                if(board[r][c] == \\'R\\')  break;\\n            }\\n            if(c!=8)    break;\\n        }\\n               \\n        for(int i=r+1;i<8;i++){\\n            if(board[i][c] == \\'p\\'){\\n                attack++;\\n                break;\\n            }   \\n            else if(board[i][c] == \\'B\\') break;\\n        }\\n\\n        \\n        for(int i=c+1;i<8;i++){\\n            if(board[r][i] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[r][i] == \\'B\\') break;\\n        }\\n        \\n        for(int i=r-1;i>=0;i--){\\n            if(board[i][c] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[i][c] == \\'B\\') break;\\n        }\\n        \\n        for(int i=c-1;i>=0;i--){\\n            if(board[r][i] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[r][i] == \\'B\\') break;\\n        }\\n        \\n        return attack;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r=0,c=0,attack=0;\\n        \\n        for(r=0;r<8;r++){\\n            for(c=0;c<8;c++){\\n                if(board[r][c] == \\'R\\')  break;\\n            }\\n            if(c!=8)    break;\\n        }\\n               \\n        for(int i=r+1;i<8;i++){\\n            if(board[i][c] == \\'p\\'){\\n                attack++;\\n                break;\\n            }   \\n            else if(board[i][c] == \\'B\\') break;\\n        }\\n\\n        \\n        for(int i=c+1;i<8;i++){\\n            if(board[r][i] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[r][i] == \\'B\\') break;\\n        }\\n        \\n        for(int i=r-1;i>=0;i--){\\n            if(board[i][c] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[i][c] == \\'B\\') break;\\n        }\\n        \\n        for(int i=c-1;i>=0;i--){\\n            if(board[r][i] == \\'p\\'){\\n                attack++;\\n                break;\\n            }    \\n            else if(board[r][i] == \\'B\\') break;\\n        }\\n        \\n        return attack;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588226,
                "title": "easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int x,y;\\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        int count=0;\\n        //upward;\\n        int p=x;\\n        int q=y;\\n        while(p>=0 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            p--;\\n            \\n        }\\n        //down\\n        \\n        p=x;\\n        q=y;\\n        \\n          while(p<8 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            p++;\\n            \\n        }\\n        //right\\n        \\n        p=x;\\n        q=y;\\n        \\n        while(q<8 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            q++;\\n        }\\n        \\n        p=x;\\n        q=y;\\n        //left\\n          while(q>=0 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            q--;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int x,y;\\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    x=i;\\n                    y=j;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        int count=0;\\n        //upward;\\n        int p=x;\\n        int q=y;\\n        while(p>=0 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            p--;\\n            \\n        }\\n        //down\\n        \\n        p=x;\\n        q=y;\\n        \\n          while(p<8 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            p++;\\n            \\n        }\\n        //right\\n        \\n        p=x;\\n        q=y;\\n        \\n        while(q<8 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            q++;\\n        }\\n        \\n        p=x;\\n        q=y;\\n        //left\\n          while(q>=0 and board[p][q]!=\\'B\\')\\n        {\\n            if(board[p][q]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n            q--;\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572858,
                "title": "java-very-readable-solution",
                "content": "```\\npublic int numRookCaptures(char[][] board) \\n    {\\n        // Find the rook\\n        int rookRow = 0, rookCol = 0;\\n        for (int row = 0; row < board.length; row++)\\n            for (int col = 0; col < board[0].length; col++)\\n                if (board[row][col] == \\'R\\')\\n                {\\n                    rookRow = row;\\n                    rookCol = col;\\n                    break;\\n                }\\n        \\n        // Setup attacks and hashset of friendly pieces\\n        int attacks = 0;\\n        Set<Character> friendly = new HashSet<Character>(Arrays.asList(\\'B\\', \\'R\\'));\\n        \\n        // Find North attacks\\n        for (int row = rookRow-1; row > -1; row--)\\n        {\\n            if (friendly.contains(board[row][rookCol])) break;\\n            else if (board[row][rookCol] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find South attacks\\n        for (int row = rookRow+1; row < board.length; row++)\\n        {\\n            if (friendly.contains(board[row][rookCol])) break;\\n            else if (board[row][rookCol] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find East attacks\\n        for (int col = rookCol+1; col < board[0].length; col++)\\n        {\\n            if (friendly.contains(board[rookRow][col])) break;\\n            else if (board[rookRow][col] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find West attacks\\n        for (int col = rookCol-1; col > -1; col--)\\n        {\\n            if (friendly.contains(board[rookRow][col])) break;\\n            else if (board[rookRow][col] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        return attacks;\\n    }\\n```\\nThe general idea for my solution was to treat it like a human would play chess.\\n1) Find the rook square, since it\\'s not given\\n2) Identify friendly pieces the rook cannot pass\\n3) Find enemy pieces the rook can attack\\n\\nThe code can definitely be more modular, but is pretty straightforward as is.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numRookCaptures(char[][] board) \\n    {\\n        // Find the rook\\n        int rookRow = 0, rookCol = 0;\\n        for (int row = 0; row < board.length; row++)\\n            for (int col = 0; col < board[0].length; col++)\\n                if (board[row][col] == \\'R\\')\\n                {\\n                    rookRow = row;\\n                    rookCol = col;\\n                    break;\\n                }\\n        \\n        // Setup attacks and hashset of friendly pieces\\n        int attacks = 0;\\n        Set<Character> friendly = new HashSet<Character>(Arrays.asList(\\'B\\', \\'R\\'));\\n        \\n        // Find North attacks\\n        for (int row = rookRow-1; row > -1; row--)\\n        {\\n            if (friendly.contains(board[row][rookCol])) break;\\n            else if (board[row][rookCol] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find South attacks\\n        for (int row = rookRow+1; row < board.length; row++)\\n        {\\n            if (friendly.contains(board[row][rookCol])) break;\\n            else if (board[row][rookCol] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find East attacks\\n        for (int col = rookCol+1; col < board[0].length; col++)\\n        {\\n            if (friendly.contains(board[rookRow][col])) break;\\n            else if (board[rookRow][col] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        // Find West attacks\\n        for (int col = rookCol-1; col > -1; col--)\\n        {\\n            if (friendly.contains(board[rookRow][col])) break;\\n            else if (board[rookRow][col] != \\'.\\')\\n            {\\n                attacks++;\\n                break;\\n            }\\n        }\\n        return attacks;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1551631,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        fn calc_cap(it: impl Iterator<Item = char>, rook_pos: usize) -> i32 {\\n            let (mut res, mut num) = (0, 0);\\n            for (pos, fig) in it.enumerate() {\\n                match (fig, pos < rook_pos) {\\n                    (\\'R\\', _) => res += num,\\n                    (\\'p\\', true) => num = 1,\\n                    (\\'B\\', true) => num = 0,\\n                    (\\'p\\', false) => return res + 1,\\n                    (\\'B\\', false) => return res,\\n                    _ => (),\\n                }\\n            }\\n            res\\n        }\\n\\n        for (y, row) in board.iter().enumerate() {\\n            if let Some(x) = row.iter().position(|c| *c == \\'R\\') {\\n                let row_it = row.iter().cloned();\\n                let col_it = (0..8_usize).map(|i| board[i][x]);\\n                return calc_cap(row_it, x) + calc_cap(col_it, y);\\n            }\\n        }\\n\\n        unreachable!()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        fn calc_cap(it: impl Iterator<Item = char>, rook_pos: usize) -> i32 {\\n            let (mut res, mut num) = (0, 0);\\n            for (pos, fig) in it.enumerate() {\\n                match (fig, pos < rook_pos) {\\n                    (\\'R\\', _) => res += num,\\n                    (\\'p\\', true) => num = 1,\\n                    (\\'B\\', true) => num = 0,\\n                    (\\'p\\', false) => return res + 1,\\n                    (\\'B\\', false) => return res,\\n                    _ => (),\\n                }\\n            }\\n            res\\n        }\\n\\n        for (y, row) in board.iter().enumerate() {\\n            if let Some(x) = row.iter().position(|c| *c == \\'R\\') {\\n                let row_it = row.iter().cloned();\\n                let col_it = (0..8_usize).map(|i| board[i][x]);\\n                return calc_cap(row_it, x) + calc_cap(col_it, y);\\n            }\\n        }\\n\\n        unreachable!()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348805,
                "title": "100-efficient-c-sol",
                "content": "int numRookCaptures(vector<vector<char>>& board) {\\n        int i=0,j=0;\\n        int tempi,tempj;\\n        for(i=0;i<=board.size()-1;i++)\\n        {\\n            for(j=0;j<=board[0].size()-1;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    tempi=i;\\n                    tempj=j;\\n                   break; \\n                }\\n            }\\n        }\\n        int count=0;\\n        for(j=tempj;j<=7;j++)\\n        {\\n            if(board[tempi][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[tempi][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        i=tempi;\\n        for(j=tempj;j>=0;j--)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        j=tempj;\\n        for(i=tempi;i<=7;i++)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        j=tempj;\\n        for(i=tempi;i>=0;i--)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "int numRookCaptures(vector<vector<char>>& board) {\\n        int i=0,j=0;\\n        int tempi,tempj;\\n        for(i=0;i<=board.size()-1;i++)\\n        {\\n            for(j=0;j<=board[0].size()-1;j++)\\n            {\\n                if(board[i][j]==\\'R\\')\\n                {\\n                    tempi=i;\\n                    tempj=j;\\n                   break; \\n                }\\n            }\\n        }\\n        int count=0;\\n        for(j=tempj;j<=7;j++)\\n        {\\n            if(board[tempi][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[tempi][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        i=tempi;\\n        for(j=tempj;j>=0;j--)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        j=tempj;\\n        for(i=tempi;i<=7;i++)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        j=tempj;\\n        for(i=tempi;i>=0;i--)\\n        {\\n            if(board[i][j]==\\'p\\')\\n            {\\n                count+=1;\\n                break;\\n            }\\n            else if(board[i][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1345291,
                "title": "python-solution-97-faster",
                "content": "class Solution:\\n*     def numRookCaptures(self, b: List[List[str]]) -> int:\\n        count=[0]*4\\n        row,col=0,0\\n        for i in range(0,8):\\n            for j in range(0,8):\\n                if(b[i][j]==\\'R\\'):\\n                    row=i\\n                    col=j\\n                    break\\n        for i in range(0,8):\\n            if(i==row):\\n                for j in range(0,8):\\n                    if(j<col):\\n                        if(b[row][j]==\\'B\\'):\\n                            count[0]=0\\n                        elif(b[row][j]==\\'p\\'):\\n                            count[0]=1\\n                    else:\\n                        if(b[row][j]==\\'B\\'):\\n                            break\\n                        elif(b[row][j]==\\'p\\'):\\n                            count[1]=1\\n            else:\\n                if(i<row):\\n                    if(b[i][col]==\\'B\\'):\\n                        count[2]=0\\n                    elif(b[i][col]==\\'p\\'):\\n                        count[2]=1\\n                else:\\n                    if(b[i][col]==\\'B\\'):\\n                        break\\n                    elif(b[i][col]==\\'p\\'):\\n                        count[3]=1\\n        return sum(count)",
                "solutionTags": [],
                "code": "class Solution:\\n*     def numRookCaptures(self, b: List[List[str]]) -> int:\\n        count=[0]*4\\n        row,col=0,0\\n        for i in range(0,8):\\n            for j in range(0,8):\\n                if(b[i][j]==\\'R\\'):\\n                    row=i\\n                    col=j\\n                    break\\n        for i in range(0,8):\\n            if(i==row):\\n                for j in range(0,8):\\n                    if(j<col):\\n                        if(b[row][j]==\\'B\\'):\\n                            count[0]=0\\n                        elif(b[row][j]==\\'p\\'):\\n                            count[0]=1\\n                    else:\\n                        if(b[row][j]==\\'B\\'):\\n                            break\\n                        elif(b[row][j]==\\'p\\'):\\n                            count[1]=1\\n            else:\\n                if(i<row):\\n                    if(b[i][col]==\\'B\\'):\\n                        count[2]=0\\n                    elif(b[i][col]==\\'p\\'):\\n                        count[2]=1\\n                else:\\n                    if(b[i][col]==\\'B\\'):\\n                        break\\n                    elif(b[i][col]==\\'p\\'):\\n                        count[3]=1\\n        return sum(count)",
                "codeTag": "Java"
            },
            {
                "id": 1289087,
                "title": "easy-c-solution-0-ms-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r,c, i, j, ans = 0;\\n        //Find the position of Rook\\n        for(i = 0; i < 8; i ++){\\n            for(j = 0; j < 8; j ++){\\n                if(board[i][j] == \\'R\\'){\\n                    r = i;\\n                    c = j;\\n                    goto stop;\\n                }\\n            }\\n        }\\n        stop:\\n        // Traverse Right\\n        for(j = c; j < 8; j ++){\\n            if(board[r][j] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[r][j] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Left\\n        for(j = c; j >= 0; j --){\\n            if(board[r][j] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[r][j] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Up\\n        for(i = r; i >=0; i --){\\n            if(board[i][c] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][c] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Down\\n        for(i = r; i < 8; i ++){\\n            if(board[i][c] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][c] == \\'B\\')\\n                break; \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int r,c, i, j, ans = 0;\\n        //Find the position of Rook\\n        for(i = 0; i < 8; i ++){\\n            for(j = 0; j < 8; j ++){\\n                if(board[i][j] == \\'R\\'){\\n                    r = i;\\n                    c = j;\\n                    goto stop;\\n                }\\n            }\\n        }\\n        stop:\\n        // Traverse Right\\n        for(j = c; j < 8; j ++){\\n            if(board[r][j] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[r][j] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Left\\n        for(j = c; j >= 0; j --){\\n            if(board[r][j] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[r][j] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Up\\n        for(i = r; i >=0; i --){\\n            if(board[i][c] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][c] == \\'B\\')\\n                break;\\n        }\\n        // Traverse Down\\n        for(i = r; i < 8; i ++){\\n            if(board[i][c] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n            else if(board[i][c] == \\'B\\')\\n                break; \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198905,
                "title": "c-faster-than-100-using-only-two-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int x=-1,y=-1;\\n        vector<vector<int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    x=i,y=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<4;i++){\\n            int p=x+dir[i][0],q=y+dir[i][1];\\n            while(p>=0&&p<8&&q>=0&&q<8){\\n                \\n                if(board[p][q]==\\'p\\'){\\n                    cnt++;\\n                    break;\\n                }\\n                if(board[p][q]==\\'B\\')\\n                    break;\\n               \\n                p+=dir[i][0];\\n                q+=dir[i][1];\\n            }\\n        }\\n       \\n        return cnt;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int x=-1,y=-1;\\n        vector<vector<int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    x=i,y=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<4;i++){\\n            int p=x+dir[i][0],q=y+dir[i][1];\\n            while(p>=0&&p<8&&q>=0&&q<8){\\n                \\n                if(board[p][q]==\\'p\\'){\\n                    cnt++;\\n                    break;\\n                }\\n                if(board[p][q]==\\'B\\')\\n                    break;\\n               \\n                p+=dir[i][0];\\n                q+=dir[i][1];\\n            }\\n        }\\n       \\n        return cnt;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170119,
                "title": "java-100-0ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int total = 0;\\n        int r = 0;\\n        int c = 0;\\n        for(int i=0; i<8;++i){\\n            for(int j=0; j<8; ++j){\\n                char t = board[i][j];\\n                if(t == \\'R\\'){\\n                    r = i;\\n                    c = j;\\n                    break;\\n                }\\n            }\\n        }\\n        //south\\n        int temp = r;\\n        while(temp >= 0){\\n            if(board[temp][c] == \\'B\\'){\\n                break;\\n            }\\n            if(board[temp][c] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp--;\\n        }\\n        //north\\n        temp = r;\\n        while(temp < 8){\\n            if(board[temp][c] == \\'B\\'){\\n                break;\\n            }\\n            if(board[temp][c] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp++;\\n        }\\n        //east\\n        temp = c;\\n        while(temp < 8){\\n            if(board[r][temp] == \\'B\\'){\\n                break;\\n            }\\n            if(board[r][temp] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp++;\\n        }\\n        //west\\n        temp = c;\\n        while(temp >= 0){\\n            if(board[r][temp] == \\'B\\'){\\n                break;\\n            }\\n            if(board[r][temp] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp--;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int total = 0;\\n        int r = 0;\\n        int c = 0;\\n        for(int i=0; i<8;++i){\\n            for(int j=0; j<8; ++j){\\n                char t = board[i][j];\\n                if(t == \\'R\\'){\\n                    r = i;\\n                    c = j;\\n                    break;\\n                }\\n            }\\n        }\\n        //south\\n        int temp = r;\\n        while(temp >= 0){\\n            if(board[temp][c] == \\'B\\'){\\n                break;\\n            }\\n            if(board[temp][c] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp--;\\n        }\\n        //north\\n        temp = r;\\n        while(temp < 8){\\n            if(board[temp][c] == \\'B\\'){\\n                break;\\n            }\\n            if(board[temp][c] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp++;\\n        }\\n        //east\\n        temp = c;\\n        while(temp < 8){\\n            if(board[r][temp] == \\'B\\'){\\n                break;\\n            }\\n            if(board[r][temp] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp++;\\n        }\\n        //west\\n        temp = c;\\n        while(temp >= 0){\\n            if(board[r][temp] == \\'B\\'){\\n                break;\\n            }\\n            if(board[r][temp] == \\'p\\'){\\n                total++;\\n                break;\\n            }\\n            temp--;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143919,
                "title": "simple-solution",
                "content": "```python\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    attack = 0\\n                    for di, dj in ((0,1), (1,0), (0,-1), (-1,0)):\\n                        ci, cj = i, j\\n                        while 0 <= ci < 8 and 0 <= cj < 8:\\n                            if board[ci][cj] in (\\'p\\', \\'B\\'):\\n                                attack += board[ci][cj] == \\'p\\'\\n                                break\\n                            ci += di\\n                            cj += dj\\n                    return attack\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    attack = 0\\n                    for di, dj in ((0,1), (1,0), (0,-1), (-1,0)):\\n                        ci, cj = i, j\\n                        while 0 <= ci < 8 and 0 <= cj < 8:\\n                            if board[ci][cj] in (\\'p\\', \\'B\\'):\\n                                attack += board[ci][cj] == \\'p\\'\\n                                break\\n                            ci += di\\n                            cj += dj\\n                    return attack\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127901,
                "title": "c-recursion-without-dp-0-faster-than-100",
                "content": "This is a really noob approach from my side, suggestions are welcome on improvements.\\n\\nThought Process:\\n1. Already had the base conditions up par so basic process of recursion was completed.\\n2. Create a recursion which moves the rook up/down/left/right\\n\\n```\\nclass Solution {\\npublic:\\n    int capturePawnUp(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnUp(board, R, C, rowOfRook - 1, columnOfRook);\\n    };\\n    \\n    int capturePawnDown(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnDown(board, R, C, rowOfRook + 1, columnOfRook);\\n    };\\n    \\n    int capturePawnLeft(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnLeft(board, R, C, rowOfRook, columnOfRook - 1);\\n    };\\n    \\n    int capturePawnRight(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnRight(board, R, C, rowOfRook, columnOfRook + 1);\\n    };\\n    \\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int row = 8, column = 8;\\n        int rowOfRook = 0;\\n        int columnOfRook = 0;\\n        \\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 0; j < board.size(); j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rowOfRook = i;\\n                    columnOfRook = j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        \\n        int value = (capturePawnUp(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnDown(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnLeft(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnRight(board, row, column, rowOfRook, columnOfRook));\\n        return value;\\n    }\\n};                                                                                                                                                                                                                                                                                                                                               \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int capturePawnUp(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnUp(board, R, C, rowOfRook - 1, columnOfRook);\\n    };\\n    \\n    int capturePawnDown(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnDown(board, R, C, rowOfRook + 1, columnOfRook);\\n    };\\n    \\n    int capturePawnLeft(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnLeft(board, R, C, rowOfRook, columnOfRook - 1);\\n    };\\n    \\n    int capturePawnRight(vector<vector<char>>& board, int R, int C, int rowOfRook, int columnOfRook, int pawnCaptured = 0) {\\n            if(rowOfRook < 0 || rowOfRook == R || columnOfRook < 0 || columnOfRook == C) return pawnCaptured;\\n            if(board[rowOfRook][columnOfRook] == \\'p\\') return pawnCaptured + 1;\\n            if(board[rowOfRook][columnOfRook] == \\'B\\') return pawnCaptured;\\n            return capturePawnRight(board, R, C, rowOfRook, columnOfRook + 1);\\n    };\\n    \\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int row = 8, column = 8;\\n        int rowOfRook = 0;\\n        int columnOfRook = 0;\\n        \\n        for(int i = 0; i < board.size(); i++) {\\n            for(int j = 0; j < board.size(); j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rowOfRook = i;\\n                    columnOfRook = j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        \\n        int value = (capturePawnUp(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnDown(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnLeft(board, row, column, rowOfRook, columnOfRook) \\n\\t\\t+ capturePawnRight(board, row, column, rowOfRook, columnOfRook));\\n        return value;\\n    }\\n};                                                                                                                                                                                                                                                                                                                                               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067520,
                "title": "python-3-simple-to-understand-beats-97",
                "content": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        lst=[]\\n        st=\\'\\'\\n        st1=\\'\\'\\n        for i in range(0,8):\\n            for j in range(0,8):\\n                if board[i][j]==\\'R\\':\\n                    m=i\\n                    n=j\\n        for i in range(0,8):\\n            lst.append(board[i][n])\\n        for i in range(0,8):\\n            if lst[i]!=\\'.\\':\\n                st+=lst[i]\\n            if board[m][i]!=\\'.\\':\\n                st1+=board[m][i]\\n        return st.count(\\'Rp\\')+st.count(\\'pR\\')+st1.count(\\'Rp\\')+st1.count(\\'pR\\')\\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        lst=[]\\n        st=\\'\\'\\n        st1=\\'\\'\\n        for i in range(0,8):\\n            for j in range(0,8):\\n                if board[i][j]==\\'R\\':\\n                    m=i\\n                    n=j\\n        for i in range(0,8):\\n            lst.append(board[i][n])\\n        for i in range(0,8):\\n            if lst[i]!=\\'.\\':\\n                st+=lst[i]\\n            if board[m][i]!=\\'.\\':\\n                st1+=board[m][i]\\n        return st.count(\\'Rp\\')+st.count(\\'pR\\')+st1.count(\\'Rp\\')+st1.count(\\'pR\\')\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 956288,
                "title": "java-100-easy-to-understand",
                "content": "\\tclass Solution {\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    public int numRookCaptures(char[][] board) {\\n        int[] Rrc = new int[2]; \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    Rrc[0] = i;\\n                    Rrc[1] = j;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int[] dir : dirs){\\n            int x = dir[0] + Rrc[0];\\n            int y = dir[1] + Rrc[1];\\n            while(x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == \\'.\\'){\\n                x += dir[0];\\n                y += dir[1];\\n            }\\n            if(x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] == \\'B\\')\\n                continue;\\n            \\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[][] dirs = {{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 859534,
                "title": "0ms-faster-than-100-solution-java",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] b) {\\n        for (int i=0;i<b.length;i++){\\n            for (int j=0;j<b[0].length;j++){\\n                if (b[i][j]==\\'R\\')\\n                    return get(b,i,j,0,1)+get(b,i,j,0,-1)+get(b,i,j,1,0)+get(b,i,j,-1,0);\\n            }\\n        }\\n        return 0;\\n    }\\n    public int get(char[][] b,int i,int j,int x,int y){\\n        while (i>=0 && i<b.length && j>=0 && j<b[0].length && b[i][j]!=\\'B\\'){\\n            if (b[i][j]==\\'p\\') return 1;\\n            i+=x;\\n            j+=y;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] b) {\\n        for (int i=0;i<b.length;i++){\\n            for (int j=0;j<b[0].length;j++){\\n                if (b[i][j]==\\'R\\')\\n                    return get(b,i,j,0,1)+get(b,i,j,0,-1)+get(b,i,j,1,0)+get(b,i,j,-1,0);\\n            }\\n        }\\n        return 0;\\n    }\\n    public int get(char[][] b,int i,int j,int x,int y){\\n        while (i>=0 && i<b.length && j>=0 && j<b[0].length && b[i][j]!=\\'B\\'){\\n            if (b[i][j]==\\'p\\') return 1;\\n            i+=x;\\n            j+=y;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846263,
                "title": "go-straightforward-solution-0ms",
                "content": "https://github.com/phea/leetcode-go\\n\\n```go\\nfunc numRookCaptures(board [][]byte) int {\\n    var row, col int\\n    for i := 0; i < 8; i++ {\\n        for j := 0; j < 8; j++ {\\n            if board[i][j] == byte(\\'R\\'){\\n                row, col = i, j\\n            }\\n        }\\n    }\\n    \\n    \\n    var count int\\n    // north\\n    for i := row-1; i >= 0; i-- {\\n        if board[i][col] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[i][col] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    //south\\n    for i := row+1; i < 8; i++ {\\n        if board[i][col] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[i][col] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    // east\\n    for j := col+1; j < 8; j++ {\\n        if board[row][j] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[row][j] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    // west\\n    for j := col-1; j >= 0; j-- {\\n        if board[row][j] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[row][j] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numRookCaptures(board [][]byte) int {\\n    var row, col int\\n    for i := 0; i < 8; i++ {\\n        for j := 0; j < 8; j++ {\\n            if board[i][j] == byte(\\'R\\'){\\n                row, col = i, j\\n            }\\n        }\\n    }\\n    \\n    \\n    var count int\\n    // north\\n    for i := row-1; i >= 0; i-- {\\n        if board[i][col] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[i][col] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    //south\\n    for i := row+1; i < 8; i++ {\\n        if board[i][col] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[i][col] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    // east\\n    for j := col+1; j < 8; j++ {\\n        if board[row][j] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[row][j] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    // west\\n    for j := col-1; j >= 0; j-- {\\n        if board[row][j] == byte(\\'p\\') {\\n            count++\\n            break\\n        }\\n        \\n        if board[row][j] == byte(\\'B\\') {\\n            break\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816547,
                "title": "javascript-short-with-explain",
                "content": "To reduce loops, go only ones through all elements and capture (row, column) position of each.\\nThen testing values on each direction.\\n\\n```\\nvar numRookCaptures = function(b) {\\n    let p=[];    let R =[];    let B = [];    let res=0;\\n    for(let q=0; q<8; q++){\\n        for(let w=0; w<8; w++){\\n            if(b[q][w] == \"p\") p.push([q,w]);\\n            if(b[q][w] == \"R\") R.push(q,w);\\n            if(b[q][w] == \"B\") B.push([q,w]);\\n        }\\n    }\\n\\n    //go up\\n    if(p.some(x => x[1] == R[1] && x[0] < R[0] && !(B.some(y => y[1] == R[1] && y[0] < R[0] && y[0] > x[0]) ))) res++;\\n    //go down\\n    if(p.some(x => x[1] == R[1] && x[0] > R[0] && !(B.some(y => y[1] == R[1] && y[0] > R[0] && y[0] < x[0]) ))) res++;\\n    //go left\\n    if(p.some(x => x[0] == R[0] && x[1] < R[1] && !(B.some(y => y[0] == R[0] && y[1] < R[1] && y[1] > x[1]) ))) res++;\\n    //go right\\n    if(p.some(x => x[0] == R[0] && x[1] > R[1] && !(B.some(y => y[0] == R[0] && y[1] > R[1] && y[1] < x[1]) ))) res++;\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numRookCaptures = function(b) {\\n    let p=[];    let R =[];    let B = [];    let res=0;\\n    for(let q=0; q<8; q++){\\n        for(let w=0; w<8; w++){\\n            if(b[q][w] == \"p\") p.push([q,w]);\\n            if(b[q][w] == \"R\") R.push(q,w);\\n            if(b[q][w] == \"B\") B.push([q,w]);\\n        }\\n    }\\n\\n    //go up\\n    if(p.some(x => x[1] == R[1] && x[0] < R[0] && !(B.some(y => y[1] == R[1] && y[0] < R[0] && y[0] > x[0]) ))) res++;\\n    //go down\\n    if(p.some(x => x[1] == R[1] && x[0] > R[0] && !(B.some(y => y[1] == R[1] && y[0] > R[0] && y[0] < x[0]) ))) res++;\\n    //go left\\n    if(p.some(x => x[0] == R[0] && x[1] < R[1] && !(B.some(y => y[0] == R[0] && y[1] < R[1] && y[1] > x[1]) ))) res++;\\n    //go right\\n    if(p.some(x => x[0] == R[0] && x[1] > R[1] && !(B.some(y => y[0] == R[0] && y[1] > R[1] && y[1] < x[1]) ))) res++;\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 804547,
                "title": "python-2-liner-w-explanation",
                "content": "**1.** Create (join) a string for each row and column(zip rows) without periods (\".\").\\n**2.** Iterate the resulting strings, skipping empty strings.\\n**3.** Add a capture if \"Rp\" is in the string and add a capture if \"pR\" is in the string.\\n* *This could be one line but the readability would suffer (more).*\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        l = [\\'\\'.join([c for c in r if c != \\'.\\']) for r in board + list(zip(*board))]\\n        return sum([1 if t in x else 0 for t in (\\'Rp\\', \\'pR\\') for x in l if x])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        l = [\\'\\'.join([c for c in r if c != \\'.\\']) for r in board + list(zip(*board))]\\n        return sum([1 if t in x else 0 for t in (\\'Rp\\', \\'pR\\') for x in l if x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803068,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        row, col = 0, 0\\n        num = 0\\n        \\n        for i in range(8) :\\n            for j in range(8) :\\n                if board[i][j] == \\'R\\' :\\n                    row, col = i, j\\n                    break\\n        \\n        for i, j in [(0,-1),(0,1),(1,0),(-1,0)] :\\n            \\n            ci, cj = row+i, col+j\\n            \\n            while 0<=ci<8 and 0<=cj<8 :\\n                \\n                if board[ci][cj] == \\'p\\' :\\n                    num += 1\\n                if board[ci][cj] != \\'.\\' :\\n                    break\\n                \\n                ci += i\\n                cj += j\\n                \\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        \\n        row, col = 0, 0\\n        num = 0\\n        \\n        for i in range(8) :\\n            for j in range(8) :\\n                if board[i][j] == \\'R\\' :\\n                    row, col = i, j\\n                    break\\n        \\n        for i, j in [(0,-1),(0,1),(1,0),(-1,0)] :\\n            \\n            ci, cj = row+i, col+j\\n            \\n            while 0<=ci<8 and 0<=cj<8 :\\n                \\n                if board[ci][cj] == \\'p\\' :\\n                    num += 1\\n                if board[ci][cj] != \\'.\\' :\\n                    break\\n                \\n                ci += i\\n                cj += j\\n                \\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761475,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int row, col;\\n        int count = 0;\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==\\'R\\'){\\n                    row = i;\\n                    col = j;\\n                }\\n            }\\n        }\\n        int i=row-1, j=col;\\n        while(i>=0 && board[i][j]==\\'.\\') i--;\\n        if(i>=0 && board[i][j]==\\'p\\') count++;\\n\\t\\t\\n        i=row+1, j=col;\\n        while(i<board.size() && board[i][j]==\\'.\\') i++;\\n        if(i<board.size() && board[i][j]==\\'p\\') count++;\\n        \\n        i=row, j=col-1;\\n        while(j>=0 && board[i][j]==\\'.\\') j--;\\n        if(j>=0 && board[i][j]==\\'p\\') count++;\\n\\t\\t\\n        i=row, j=col+1;\\n        while(j<board[0].size() && board[i][j]==\\'.\\') j++;\\n        if(j<board[0].size() && board[i][j]==\\'p\\') count++;\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int row, col;\\n        int count = 0;\\n        for(int i=0; i<board.size(); i++){\\n            for(int j=0; j<board[0].size(); j++){\\n                if(board[i][j]==\\'R\\'){\\n                    row = i;\\n                    col = j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 760745,
                "title": "goto-solution",
                "content": "```\\nint numRookCaptures(vector<vector<char>>& b) \\n{\\n\\tauto r_i{0}, r_j{0};\\n\\n\\tfor(; r_i < 8; ++r_i)\\n\\t\\tfor(r_j = 0; r_j < 8; ++r_j)\\n\\t\\t\\tif(b[r_i][r_j] == \\'R\\') goto rook_found;\\n\\n\\trook_found:\\n\\n\\tint out{0};\\n\\n\\tfor(auto j{r_j+1}; j < 8; ++j)\\n\\t   if(b[r_i][j] != \\'.\\') \\n\\t   {\\n\\t\\t   out += (b[r_i][j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto j{r_j-1}; j >= 0; --j)\\n\\t   if(b[r_i][j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[r_i][j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto i{r_i+1}; i < 8; ++i)\\n\\t   if(b[i][r_j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[i][r_j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto i{r_i-1}; i >= 0; --i)\\n\\t   if(b[i][r_j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[i][r_j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numRookCaptures(vector<vector<char>>& b) \\n{\\n\\tauto r_i{0}, r_j{0};\\n\\n\\tfor(; r_i < 8; ++r_i)\\n\\t\\tfor(r_j = 0; r_j < 8; ++r_j)\\n\\t\\t\\tif(b[r_i][r_j] == \\'R\\') goto rook_found;\\n\\n\\trook_found:\\n\\n\\tint out{0};\\n\\n\\tfor(auto j{r_j+1}; j < 8; ++j)\\n\\t   if(b[r_i][j] != \\'.\\') \\n\\t   {\\n\\t\\t   out += (b[r_i][j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto j{r_j-1}; j >= 0; --j)\\n\\t   if(b[r_i][j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[r_i][j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto i{r_i+1}; i < 8; ++i)\\n\\t   if(b[i][r_j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[i][r_j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\tfor(auto i{r_i-1}; i >= 0; --i)\\n\\t   if(b[i][r_j] != \\'.\\')\\n\\t   {\\n\\t\\t   out += (b[i][r_j] == \\'p\\');\\n\\t\\t   break;\\n\\t   }\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751047,
                "title": "java-dfs-solution-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    int count;\\n    public int numRookCaptures(char[][] board) {\\n     for(int i=0;i<board.length;i++)\\n         for(int j=0;j<board[i].length;j++)\\n         {\\n             if(board[i][j]==\\'R\\')\\n             { \\n               dfs(board,i-1,j,\\'u\\');\\n               dfs(board,i+1,j,\\'d\\');\\n               dfs(board,i,j-1,\\'l\\');\\n               dfs(board,i,j+1,\\'r\\');\\n                 break;\\n            }\\n         }\\n        return count;\\n    }\\n    public void dfs(char[][] board,int i,int j,char c)\\n    {\\n        if(i<0 || i>=board.length || j<0 || j>=board[i].length || board[i][j]==\\'B\\')\\n            return;\\n        if(board[i][j]==\\'p\\')\\n        {\\n            count+=1;\\n            return;\\n        }\\n        if(board[i][j]==\\'.\\')\\n        {\\n            if(c==\\'u\\')\\n              dfs(board,i-1,j,\\'u\\');\\n            else if(c==\\'d\\')\\n                 dfs(board,i+1,j,\\'d\\');\\n            else if(c==\\'l\\')\\n                 dfs(board,i,j-1,\\'l\\');\\n            else if(c==\\'r\\')\\n                 dfs(board,i,j+1,\\'r\\');\\n                \\n        }\\n      \\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int numRookCaptures(char[][] board) {\\n     for(int i=0;i<board.length;i++)\\n         for(int j=0;j<board[i].length;j++)\\n         {\\n             if(board[i][j]==\\'R\\')\\n             { \\n               dfs(board,i-1,j,\\'u\\');\\n               dfs(board,i+1,j,\\'d\\');\\n               dfs(board,i,j-1,\\'l\\');\\n               dfs(board,i,j+1,\\'r\\');\\n                 break;\\n            }\\n         }\\n        return count;\\n    }\\n    public void dfs(char[][] board,int i,int j,char c)\\n    {\\n        if(i<0 || i>=board.length || j<0 || j>=board[i].length || board[i][j]==\\'B\\')\\n            return;\\n        if(board[i][j]==\\'p\\')\\n        {\\n            count+=1;\\n            return;\\n        }\\n        if(board[i][j]==\\'.\\')\\n        {\\n            if(c==\\'u\\')\\n              dfs(board,i-1,j,\\'u\\');\\n            else if(c==\\'d\\')\\n                 dfs(board,i+1,j,\\'d\\');\\n            else if(c==\\'l\\')\\n                 dfs(board,i,j-1,\\'l\\');\\n            else if(c==\\'r\\')\\n                 dfs(board,i,j+1,\\'r\\');\\n                \\n        }\\n      \\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748899,
                "title": "java-solution-easy-readable-with-comments",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ans = 0;\\n\\n\\t\\tfor (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board[0].length; j++) {\\n\\t\\t\\t\\tif (board[i][j] == \\'R\\') {\\n\\n\\t\\t\\t\\t\\tans = inRow(i, j, board) + inCol(i, j, board);\\n\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n    \\n    public int inRow(int row, int col, char[][] board) {\\n\\n\\t\\tint c = 0;\\n\\n\\t\\t// leftwards\\n\\t\\tfor (int i = col-1; i >= 0; i--)\\n\\t\\t\\tif (board[row][i] != \\'.\\') {\\n\\t\\t\\t\\tif (board[row][i] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n                \\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t// rightwards\\n\\t\\tfor (int i = col+1; i < board[0].length; i++)\\n\\t\\t\\tif (board[row][i] != \\'.\\') {\\n\\t\\t\\t\\tif (board[row][i] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n                \\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\treturn c;\\n\\t}\\n\\t\\n\\tpublic int inCol(int row, int col, char[][] board) {\\n\\n\\t\\tint c = 0;\\n\\n\\t\\t// upwards\\n\\t\\tfor (int i = row-1; i >= 0; i--)\\n\\t\\t\\tif (board[i][col] != \\'.\\') {\\n\\t\\t\\t\\tif (board[i][col] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t// downwards\\n\\t\\tfor (int i = row+1; i < board.length; i++)\\n\\t\\t\\tif (board[i][col] != \\'.\\') {\\n\\t\\t\\t\\tif (board[i][col] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\treturn c;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ans = 0;\\n\\n\\t\\tfor (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board[0].length; j++) {\\n\\t\\t\\t\\tif (board[i][j] == \\'R\\') {\\n\\n\\t\\t\\t\\t\\tans = inRow(i, j, board) + inCol(i, j, board);\\n\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n    \\n    public int inRow(int row, int col, char[][] board) {\\n\\n\\t\\tint c = 0;\\n\\n\\t\\t// leftwards\\n\\t\\tfor (int i = col-1; i >= 0; i--)\\n\\t\\t\\tif (board[row][i] != \\'.\\') {\\n\\t\\t\\t\\tif (board[row][i] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n                \\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t// rightwards\\n\\t\\tfor (int i = col+1; i < board[0].length; i++)\\n\\t\\t\\tif (board[row][i] != \\'.\\') {\\n\\t\\t\\t\\tif (board[row][i] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n                \\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\treturn c;\\n\\t}\\n\\t\\n\\tpublic int inCol(int row, int col, char[][] board) {\\n\\n\\t\\tint c = 0;\\n\\n\\t\\t// upwards\\n\\t\\tfor (int i = row-1; i >= 0; i--)\\n\\t\\t\\tif (board[i][col] != \\'.\\') {\\n\\t\\t\\t\\tif (board[i][col] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t// downwards\\n\\t\\tfor (int i = row+1; i < board.length; i++)\\n\\t\\t\\tif (board[i][col] != \\'.\\') {\\n\\t\\t\\t\\tif (board[i][col] != \\'B\\')\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\treturn c;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735806,
                "title": "100-faster-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& b) {\\n        int i,j,flag=0,cnt=0,r,c;\\n        \\n        for(i=0;i<8;i++)\\n        {\\n            for(j=0;j<8;j++)\\n            {\\n                if(b[i][j]==\\'R\\'){r=i;c=j;flag=1;break;}\\n                //cout<<i<<\" \"<<j<<\" \"<<b[i][j]<<endl;\\n            }\\n            if(flag==1)break;\\n        }\\n        //cout<<i<<\" \"<<j<<endl;\\n        \\n        while(i<8)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            i++;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        i=r;\\n        while(i>=0)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            i--;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        i=r;\\n        while(j<8)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            j++;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        j=c;\\n        while(j>=0)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            j--;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\nauto speedup=[](){\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& b) {\\n        int i,j,flag=0,cnt=0,r,c;\\n        \\n        for(i=0;i<8;i++)\\n        {\\n            for(j=0;j<8;j++)\\n            {\\n                if(b[i][j]==\\'R\\'){r=i;c=j;flag=1;break;}\\n                //cout<<i<<\" \"<<j<<\" \"<<b[i][j]<<endl;\\n            }\\n            if(flag==1)break;\\n        }\\n        //cout<<i<<\" \"<<j<<endl;\\n        \\n        while(i<8)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            i++;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        i=r;\\n        while(i>=0)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            i--;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        i=r;\\n        while(j<8)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            j++;\\n        }\\n        //cout<<i<<\" \"<<j<<\" \"<<cnt<<endl;\\n        j=c;\\n        while(j>=0)\\n        {\\n            if(b[i][j]==\\'B\\')break;\\n            else if(b[i][j]==\\'p\\'){cnt++;break;}\\n            j--;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\nauto speedup=[](){\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 729999,
                "title": "simple-easy-solution-by-python-3",
                "content": "1. Find position of the rook.\\n2. If you find the first pawn in each direction from the rook, increase the count.\\n\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        R = next((i, j) for i in range(8) for j in range(8) if board[i][j] == \\'R\\')\\n        count = 0\\n        count += next((board[i][R[1]] == \\'p\\' for i in range(R[0] - 1, -1, -1) if board[i][R[1]] != \\'.\\'), 0)\\n        count += next((board[R[0]][j] == \\'p\\' for j in range(R[1] - 1, -1, -1) if board[R[0]][j] != \\'.\\'), 0)\\n        count += next((board[i][R[1]] == \\'p\\' for i in range(R[0] + 1, 8) if board[i][R[1]] != \\'.\\'), 0)\\n        count += next((board[R[0]][j] == \\'p\\' for j in range(R[1] + 1, 8) if board[R[0]][j] != \\'.\\'), 0)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        R = next((i, j) for i in range(8) for j in range(8) if board[i][j] == \\'R\\')\\n        count = 0\\n        count += next((board[i][R[1]] == \\'p\\' for i in range(R[0] - 1, -1, -1) if board[i][R[1]] != \\'.\\'), 0)\\n        count += next((board[R[0]][j] == \\'p\\' for j in range(R[1] - 1, -1, -1) if board[R[0]][j] != \\'.\\'), 0)\\n        count += next((board[i][R[1]] == \\'p\\' for i in range(R[0] + 1, 8) if board[i][R[1]] != \\'.\\'), 0)\\n        count += next((board[R[0]][j] == \\'p\\' for j in range(R[1] + 1, 8) if board[R[0]][j] != \\'.\\'), 0)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710396,
                "title": "javascript-short-regex-solution",
                "content": "```\\nvar numRookCaptures = function(board) {\\n    let captures = 0;\\n    let rookRow = board.filter(row => row.includes(\"R\")).flat();\\n    let rookCol = board.map(row => row[rookRow.indexOf(\"R\")]);\\n    rookRow.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g) ? captures += rookRow.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g).length : null;\\n    rookCol.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g) ? captures += rookCol.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g).length : null;\\n    return captures;\\n};\\n```\\n\\nCreate arrays for the row and column that the rook resides in. Use Regex lookhead/lookbehind to see if a clear shot exists between the rook and the pawn (ie. no bishop in between). If there is a match, increase the captures count by 1 (ie. how long the match array is). Return the captures amount.",
                "solutionTags": [],
                "code": "```\\nvar numRookCaptures = function(board) {\\n    let captures = 0;\\n    let rookRow = board.filter(row => row.includes(\"R\")).flat();\\n    let rookCol = board.map(row => row[rookRow.indexOf(\"R\")]);\\n    rookRow.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g) ? captures += rookRow.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g).length : null;\\n    rookCol.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g) ? captures += rookCol.join(\"\").match(/p(?=\\\\.*R)|(?<=R\\\\.*)p/g).length : null;\\n    return captures;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 710387,
                "title": "python-solution-can-be-used-also-for-queen-and-bishop-easily",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rook = ()\\n        dim = 8\\n        # Find rook position\\n        for i in range(dim):\\n            if rook != ():\\n                break\\n            for j in range(dim):\\n                if board[i][j] == \\'R\\':\\n                    rook = (i,j)\\n                    break\\n        # Func to step in direction defined by tuple\\n        def godir(rpos, step):\\n            while 0 <= rpos[0] < dim and 0 <= rpos[1] < dim:\\n                cell = board[rpos[0]][rpos[1]]\\n                if cell == \"p\":\\n                    return 1\\n                if cell == \"B\":\\n                    return 0\\n                rpos = (rpos[0]+step[0], rpos[1]+step[1])\\n            return 0\\n        # directions for rook, you can adapt for queen and bishop\\n        steps = (\\n            (0,1),\\n            (0,-1),\\n            (1,0),\\n            (-1,0)\\n        )\\n        took = 0\\n        for step in steps:\\n            took += godir(rook, step)\\n        return took\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        rook = ()\\n        dim = 8\\n        # Find rook position\\n        for i in range(dim):\\n            if rook != ():\\n                break\\n            for j in range(dim):\\n                if board[i][j] == \\'R\\':\\n                    rook = (i,j)\\n                    break\\n        # Func to step in direction defined by tuple\\n        def godir(rpos, step):\\n            while 0 <= rpos[0] < dim and 0 <= rpos[1] < dim:\\n                cell = board[rpos[0]][rpos[1]]\\n                if cell == \"p\":\\n                    return 1\\n                if cell == \"B\":\\n                    return 0\\n                rpos = (rpos[0]+step[0], rpos[1]+step[1])\\n            return 0\\n        # directions for rook, you can adapt for queen and bishop\\n        steps = (\\n            (0,1),\\n            (0,-1),\\n            (1,0),\\n            (-1,0)\\n        )\\n        took = 0\\n        for step in steps:\\n            took += godir(rook, step)\\n        return took\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 707563,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int col=0;\\n        int row=0;\\n        int count=0;\\n        \\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                \\n                if(board[i][j]==\\'R\\')\\n                {\\n                  col=j;\\n                  row=i;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n            \\n            \\n        }\\n        \\n        \\n        for(int i=row;i>=0;i--)\\n        {\\n            \\n            if(board[i][col]==\\'B\\')\\n                break;\\n            \\n            else if(board[i][col]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n                \\n                \\n            }\\n        }\\n        \\n        \\n          for(int i=row;i<8;i++)\\n        {\\n            \\n            if(board[i][col]==\\'B\\')\\n                break;\\n            \\n            else if(board[i][col]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        \\n        }\\n        \\n        \\n        \\n        \\n        for(int i=col;i>=0;i--)\\n        {\\n            \\n            if(board[row][i]==\\'B\\')\\n                break;\\n            \\n            else if(board[row][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        \\n        }\\n        \\n        \\n        \\n          \\n        for(int i=col;i<8;i++)\\n        {\\n            \\n            if(board[row][i]==\\'B\\')\\n                break;\\n            \\n            else if(board[row][i]==\\'p\\')\\n            {\\n                count++;\\n                break;\\n            }\\n        \\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        return count;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        \\n        int col=0;\\n        int row=0;\\n        int count=0;\\n        \\n        for(int i=0;i<8;i++)\\n        {\\n            for(int j=0;j<8;j++)\\n            {\\n                \\n                if(board[i][j]==\\'R\\')\\n                {\\n                  col=j;\\n                  row=i;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 706052,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        def findrow(board):\\n            for i in range(8):\\n                if \\'R\\' in board[i]:\\n                    row=board[i]\\n                    break\\n            return row\\n        def findpos(row):\\n            for i in range(8):\\n                if row[i] == \\'R\\':\\n                    val=i\\n            return val\\n        def findans(row,val):\\n            ans=0\\n            for i in range(val-1,0,-1):\\n                if row[i]==\\'p\\':\\n                    ans=1\\n                    break\\n                elif row[i]!=\\'.\\':\\n                    break\\n            for i in range(val+1,8):\\n                if  row[i]==\\'p\\':\\n                    ans+=1\\n                    break\\n                elif row[i]!=\\'.\\':\\n                    break\\n            return ans\\n        def findcol(board,val):\\n            count=0\\n            for i in zip(*board):\\n                if count==val:\\n                    col=i\\n                    break\\n                count+=1\\n            return col\\n        row=findrow(board)\\n        pos=findpos(row)\\n        ans=findans(row,pos)\\n        col=findcol(board,pos)\\n        pos=findpos(col)\\n        ans+=findans(col,pos)\\n        return ans\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        def findrow(board):\\n            for i in range(8):\\n                if \\'R\\' in board[i]:\\n                    row=board[i]\\n                    break\\n            return row\\n        def findpos(row):\\n            for i in range(8):\\n                if row[i] == \\'R\\':\\n                    val=i\\n            return val\\n        def findans(row,val):\\n            ans=0\\n            for i in range(val-1,0,-1):\\n                if row[i]==\\'p\\':\\n                    ans=1\\n                    break\\n                elif row[i]!=\\'.\\':\\n                    break\\n            for i in range(val+1,8):\\n                if  row[i]==\\'p\\':\\n                    ans+=1\\n                    break\\n                elif row[i]!=\\'.\\':\\n                    break\\n            return ans\\n        def findcol(board,val):\\n            count=0\\n            for i in zip(*board):\\n                if count==val:\\n                    col=i\\n                    break\\n                count+=1\\n            return col\\n        row=findrow(board)\\n        pos=findpos(row)\\n        ans=findans(row,pos)\\n        col=findcol(board,pos)\\n        pos=findpos(col)\\n        ans+=findans(col,pos)\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 693377,
                "title": "python-beats-98-in-20ms",
                "content": "``` class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        p1,p2,p3,p4=0,0,0,0\\n        for i in board:\\n            if \"R\" in i:\\n                x=i.index(\"R\")\\n                y=i\\n                break\\n        if \"R\" in y and \"p\" in y:\\n            c=\"\".join(i for i in y if i != \\'.\\')\\n            p2=c.count(\"pR\")\\n            p3=c.count(\"Rp\")\\n        s=\\'\\'\\n        for i in range(8):\\n            if board[i][x]==\"p\" or board[i][x]==\"B\" or board[i][x]==\"R\":\\n                s=s+board[i][x]\\n        p1=s.count(\"pR\")\\n        p4=s.count(\"Rp\")\\n        return p1+p2+p3+p4\\n",
                "solutionTags": [],
                "code": "``` class Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        p1,p2,p3,p4=0,0,0,0\\n        for i in board:\\n            if \"R\" in i:\\n                x=i.index(\"R\")\\n                y=i\\n                break\\n        if \"R\" in y and \"p\" in y:\\n            c=\"\".join(i for i in y if i != \\'.\\')\\n            p2=c.count(\"pR\")\\n            p3=c.count(\"Rp\")\\n        s=\\'\\'\\n        for i in range(8):\\n            if board[i][x]==\"p\" or board[i][x]==\"B\" or board[i][x]==\"R\":\\n                s=s+board[i][x]\\n        p1=s.count(\"pR\")\\n        p4=s.count(\"Rp\")\\n        return p1+p2+p3+p4\\n",
                "codeTag": "Java"
            },
            {
                "id": 680754,
                "title": "javascript-solution",
                "content": "```\\nvar numRookCaptures = function(board) {\\n    for (let row = 0; row < 8; row++) {\\n        for (let col = 0; col < 8; col++) {\\n            if (board[row][col] === \\'R\\') {\\n                return countPawns(row, col);\\n            }\\n        }\\n    }\\n    \\n    function countPawns(x, y) {\\n        let count = 0;\\n        const dirs = [-1, 0, 1, 0, -1];\\n        \\n        for (let i = 0; i < dirs.length - 1; i++) {\\n            const dirX = dirs[i];\\n            const dirY = dirs[i + 1];\\n            count += findPawn(x + dirX, y + dirY, dirX, dirY);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    function findPawn(x, y, dirX, dirY) {\\n        if (isValid(x, y)) {\\n            if (board[x][y] == \\'p\\') return 1;\\n            x += dirX;\\n            y += dirY;\\n            return findPawn(x, y, dirX, dirY);\\n        }\\n        return 0;\\n    }\\n    \\n    function isValid(x, y) {\\n        return x >= 0 && y >= 0 && x < 8 && y < 8 && board[x][y] != \\'B\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numRookCaptures = function(board) {\\n    for (let row = 0; row < 8; row++) {\\n        for (let col = 0; col < 8; col++) {\\n            if (board[row][col] === \\'R\\') {\\n                return countPawns(row, col);\\n            }\\n        }\\n    }\\n    \\n    function countPawns(x, y) {\\n        let count = 0;\\n        const dirs = [-1, 0, 1, 0, -1];\\n        \\n        for (let i = 0; i < dirs.length - 1; i++) {\\n            const dirX = dirs[i];\\n            const dirY = dirs[i + 1];\\n            count += findPawn(x + dirX, y + dirY, dirX, dirY);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    function findPawn(x, y, dirX, dirY) {\\n        if (isValid(x, y)) {\\n            if (board[x][y] == \\'p\\') return 1;\\n            x += dirX;\\n            y += dirY;\\n            return findPawn(x, y, dirX, dirY);\\n        }\\n        return 0;\\n    }\\n    \\n    function isValid(x, y) {\\n        return x >= 0 && y >= 0 && x < 8 && y < 8 && board[x][y] != \\'B\\';\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632989,
                "title": "python-soln",
                "content": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        \\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    sr, sc = i, j\\n\\n                    \\n        for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n            for k in range(1,8):\\n                x = sr + k*i\\n                y = sc + k*j\\n                if not (0 <= x < 8 and 0 <= y < 8):\\n                    break\\n                if board[x][y] == \\'p\\':\\n                    count += 1\\n                    break\\n                elif board[x][y] == \\'B\\':\\n                    break\\n        \\n        return count\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        \\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \\'R\\':\\n                    sr, sc = i, j\\n\\n                    \\n        for i, j in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\\n            for k in range(1,8):\\n                x = sr + k*i\\n                y = sc + k*j\\n                if not (0 <= x < 8 and 0 <= y < 8):\\n                    break\\n                if board[x][y] == \\'p\\':\\n                    count += 1\\n                    break\\n                elif board[x][y] == \\'B\\':\\n                    break\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619441,
                "title": "python-1-line-o1-video",
                "content": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        return sum([s.count(\\'Rp\\') + s.count(\\'pR\\') for s in [\\'\\'.join(row).replace(\\'.\\', \\'\\') for row in (board + zip(*board)) if \\'R\\' in row]])\\n```\\n\\nvideo: youtube.com/watch?v=o3XmjXZnaUs",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        return sum([s.count(\\'Rp\\') + s.count(\\'pR\\') for s in [\\'\\'.join(row).replace(\\'.\\', \\'\\') for row in (board + zip(*board)) if \\'R\\' in row]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609445,
                "title": "python-solution-converting-to-string",
                "content": "Find the \\'R\\' and convert corresponding cardinals to string and look for \\'pR\\' or \\'Rp\\' in string\\n```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        for r in range(8):\\n            for c in range(8):\\n                if \\'R\\' == board[r][c]:\\n                    row, col = r, c\\n        estwst = \"\".join(i for i in board[row] if i!=\\'.\\')\\n        nrtst =  \"\".join(i for i in list(zip(*board))[col] if i!=\\'.\\')\\n        cnt = 0\\n        for strng in [estwst,nrtst]:\\n            if \\'pR\\' in strng:\\n                cnt += 1\\n            if \\'Rp\\' in strng :\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        for r in range(8):\\n            for c in range(8):\\n                if \\'R\\' == board[r][c]:\\n                    row, col = r, c\\n        estwst = \"\".join(i for i in board[row] if i!=\\'.\\')\\n        nrtst =  \"\".join(i for i in list(zip(*board))[col] if i!=\\'.\\')\\n        cnt = 0\\n        for strng in [estwst,nrtst]:\\n            if \\'pR\\' in strng:\\n                cnt += 1\\n            if \\'Rp\\' in strng :\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 569472,
                "title": "if-if-if-javascript-solution-44ms",
                "content": "```\\n22 / 22 test cases passed.\\nStatus: Accepted\\nRuntime: 44 ms\\nMemory Usage: 33.9 MB\\n\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n  let rook, u = 1, d = 1, l = 1, r = 1, count = 0;\\n  board.forEach((el, i) => el.forEach((el1,i1) => {\\n    if (el1 === \\'R\\') rook = [i,i1];\\n  }));\\n  \\n  for (let i = 1; u || d || l || r; i++) {\\n    if (u && rook[0] - i >= 0) {\\n      if (board[rook[0] - i][rook[1]] === \\'p\\') {\\n        count ++; \\n        u = 0;\\n      }\\n      if (board[rook[0] - i][rook[1]] === \\'B\\' || rook[0] - i === 0) u = 0;\\n    }\\n    if (d && rook[0] + i <= 7) {\\n      if (board[rook[0] + i][rook[1]] === \\'p\\') {\\n        count ++; \\n        d = 0;\\n      }\\n      if (board[rook[0] + i][rook[1]] === \\'B\\' || rook[0] + i === 7) d = 0;\\n    }\\n    if (l && rook[1] - i >= 0) {\\n      if (board[rook[0]][rook[1] - i] === \\'p\\') {\\n        count ++; \\n        l = 0;\\n      }\\n      if (board[rook[0]][rook[1] - i] === \\'B\\' || rook[1] - i === 0) l = 0;\\n    }\\n    if (r && rook[1] + i <= 7) {\\n      if (board[rook[0]][rook[1] + i] === \\'p\\') {\\n        count ++; \\n        r = 0;\\n      }\\n      if (board[rook[0]][rook[1] + i] === \\'B\\' || rook[1] + i === 7) r = 0;\\n    }\\n  }\\n    \\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n22 / 22 test cases passed.\\nStatus: Accepted\\nRuntime: 44 ms\\nMemory Usage: 33.9 MB\\n\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n  let rook, u = 1, d = 1, l = 1, r = 1, count = 0;\\n  board.forEach((el, i) => el.forEach((el1,i1) => {\\n    if (el1 === \\'R\\') rook = [i,i1];\\n  }));\\n  \\n  for (let i = 1; u || d || l || r; i++) {\\n    if (u && rook[0] - i >= 0) {\\n      if (board[rook[0] - i][rook[1]] === \\'p\\') {\\n        count ++; \\n        u = 0;\\n      }\\n      if (board[rook[0] - i][rook[1]] === \\'B\\' || rook[0] - i === 0) u = 0;\\n    }\\n    if (d && rook[0] + i <= 7) {\\n      if (board[rook[0] + i][rook[1]] === \\'p\\') {\\n        count ++; \\n        d = 0;\\n      }\\n      if (board[rook[0] + i][rook[1]] === \\'B\\' || rook[0] + i === 7) d = 0;\\n    }\\n    if (l && rook[1] - i >= 0) {\\n      if (board[rook[0]][rook[1] - i] === \\'p\\') {\\n        count ++; \\n        l = 0;\\n      }\\n      if (board[rook[0]][rook[1] - i] === \\'B\\' || rook[1] - i === 0) l = 0;\\n    }\\n    if (r && rook[1] + i <= 7) {\\n      if (board[rook[0]][rook[1] + i] === \\'p\\') {\\n        count ++; \\n        r = 0;\\n      }\\n      if (board[rook[0]][rook[1] + i] === \\'B\\' || rook[1] + i === 7) r = 0;\\n    }\\n  }\\n    \\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561250,
                "title": "simple-python-solution",
                "content": "Pretty straight forward problem. Just mimic the movement of the rook. Initially the rook is at (x0, y0). After moving k steps he will arrive at (x0 +k* dx, y0 + k* dy)\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        row=len(board)\\n        col=len(board[0])\\n        for i in range(row):\\n            for j in range(col):\\n                if board[i][j]==\\'R\\':\\n                    (rook_x,rook_y) = (i,j)\\n        \\n        \\n        count = 0 \\n        for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n            k = 0\\n            while True:\\n                x = rook_x + k*dx\\n                y = rook_y + k*dy\\n                if x<0 or x>row-1 or y<0 or y>col-1:\\n                    break\\n                if board[x][y] == \\'B\\': \\n                    break\\n                if board[x][y] == \\'p\\':\\n                    count+=1\\n                    break\\n                k+=1\\n                \\n        return count\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        row=len(board)\\n        col=len(board[0])\\n        for i in range(row):\\n            for j in range(col):\\n                if board[i][j]==\\'R\\':\\n                    (rook_x,rook_y) = (i,j)\\n        \\n        \\n        count = 0 \\n        for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n            k = 0\\n            while True:\\n                x = rook_x + k*dx\\n                y = rook_y + k*dy\\n                if x<0 or x>row-1 or y<0 or y>col-1:\\n                    break\\n                if board[x][y] == \\'B\\': \\n                    break\\n                if board[x][y] == \\'p\\':\\n                    count+=1\\n                    break\\n                k+=1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557877,
                "title": "java-solution-faster-than-100-poor-space-complexity",
                "content": "I first locate the coordinates of the Rook and then check cells ot its North,South,East and West by manipulating the array indices.\\n\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int r=0,c=0;\\n        boolean flag=true;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    flag=false;\\n                    r=i;\\n                    c=j;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                break;\\n        }\\n        \\n        int count=0;\\n        for(int i=c+1;i<8;i++){\\n            if(board[r][i]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        \\n        for(int i=c-1;i>=0;i--){\\n            if(board[r][i]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        \\n        for(int i=r+1;i<8;i++){\\n            if(board[i][c]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            if(board[i][c]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int r=0,c=0;\\n        boolean flag=true;\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    flag=false;\\n                    r=i;\\n                    c=j;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                break;\\n        }\\n        \\n        int count=0;\\n        for(int i=c+1;i<8;i++){\\n            if(board[r][i]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        \\n        for(int i=c-1;i>=0;i--){\\n            if(board[r][i]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        \\n        for(int i=r+1;i<8;i++){\\n            if(board[i][c]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            if(board[i][c]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            else if(board[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557227,
                "title": "c-solutions",
                "content": "**Version 1**\\nLeant how to explore all the four directions within one loop from https://leetcode.com/problems/available-captures-for-rook/discuss/242932/JavaC%2B%2BPython-Straight-Forward-Solution\\n```\\n    public int NumRookCaptures(char[][] board) {\\n        \\n        int rookI = 0, rookJ = 0, res = 0;\\n        \\n        //find the Rook\\n        for(int i = 0; i < board.Length; i++)\\n        {\\n            for(int j = 0; j < board[0].Length; j++)\\n            {\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    rookI = i;\\n                    rookJ = j;\\n                }\\n            }\\n        }\\n        \\n        int[,] dir = new int[,] { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n        for(int d = 0; d < dir.GetLength(0); d++)\\n        {\\n            for(int i = rookI + dir[d, 0], j = rookJ + dir[d, 1]; i >= 0 && i < 8 && j >= 0 && j < 8; i += dir[d, 0], j += dir[d, 1])\\n            {\\n                if(board[i][j] == \\'p\\')\\n                {\\n                    res++;\\n                    break;\\n                }\\n                else if(board[i][j] == \\'B\\')\\n                    break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n**Version 2**\\n```\\n    public int NumRookCaptures(char[][] board) {\\n        \\n        int m = board.Length, n = board[0].Length, res = 0;\\n        int rookI = 0, rookJ = 0;\\n        \\n        //find the Rook\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    rookI = i;\\n                    rookJ = j;\\n                }\\n            }\\n        }\\n        \\n        //left\\n        for(int j1 = rookJ -1; j1 >= 0; j1--)\\n        {\\n            if(board[rookI][j1] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board [rookI][j1] == \\'B\\')\\n                break;                \\n        }\\n          \\n        //right\\n        for(int j2 = rookJ + 1; j2 < n; j2++)\\n        {\\n            if(board[rookI][j2] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board [rookI][j2] == \\'B\\')\\n                break;                \\n        }\\n        \\n        //up\\n        for(int i1 = rookI - 1; i1 >= 0; i1--)\\n        {\\n            if(board[i1][rookJ] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board[i1][rookJ] == \\'B\\')\\n                break;\\n        }\\n        \\n        //down\\n        for(int i2 = rookI + 1; i2 < m; i2++)\\n        {\\n            if(board[i2][rookJ] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board[i2][rookJ] == \\'B\\')\\n                break;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int NumRookCaptures(char[][] board) {\\n        \\n        int rookI = 0, rookJ = 0, res = 0;\\n        \\n        //find the Rook\\n        for(int i = 0; i < board.Length; i++)\\n        {\\n            for(int j = 0; j < board[0].Length; j++)\\n            {\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    rookI = i;\\n                    rookJ = j;\\n                }\\n            }\\n        }\\n        \\n        int[,] dir = new int[,] { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n        for(int d = 0; d < dir.GetLength(0); d++)\\n        {\\n            for(int i = rookI + dir[d, 0], j = rookJ + dir[d, 1]; i >= 0 && i < 8 && j >= 0 && j < 8; i += dir[d, 0], j += dir[d, 1])\\n            {\\n                if(board[i][j] == \\'p\\')\\n                {\\n                    res++;\\n                    break;\\n                }\\n                else if(board[i][j] == \\'B\\')\\n                    break;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\n    public int NumRookCaptures(char[][] board) {\\n        \\n        int m = board.Length, n = board[0].Length, res = 0;\\n        int rookI = 0, rookJ = 0;\\n        \\n        //find the Rook\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(board[i][j] == \\'R\\')\\n                {\\n                    rookI = i;\\n                    rookJ = j;\\n                }\\n            }\\n        }\\n        \\n        //left\\n        for(int j1 = rookJ -1; j1 >= 0; j1--)\\n        {\\n            if(board[rookI][j1] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board [rookI][j1] == \\'B\\')\\n                break;                \\n        }\\n          \\n        //right\\n        for(int j2 = rookJ + 1; j2 < n; j2++)\\n        {\\n            if(board[rookI][j2] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board [rookI][j2] == \\'B\\')\\n                break;                \\n        }\\n        \\n        //up\\n        for(int i1 = rookI - 1; i1 >= 0; i1--)\\n        {\\n            if(board[i1][rookJ] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board[i1][rookJ] == \\'B\\')\\n                break;\\n        }\\n        \\n        //down\\n        for(int i2 = rookI + 1; i2 < m; i2++)\\n        {\\n            if(board[i2][rookJ] == \\'p\\')\\n            {\\n                res++;\\n                break;\\n            }\\n            else if(board[i2][rookJ] == \\'B\\')\\n                break;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549637,
                "title": "javascript-using-math-random",
                "content": "Just for fun \\uD83D\\uDE04\\n\\n```js\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nfunction numRookCaptures(board) {\\n  const size = 8;\\n  const total = size ** 2;\\n  let n = 0;\\n  while (board[(n / size) | 0][n % size] !== \\'R\\') {\\n    n = (Math.random() * total) | 0;\\n  }\\n  const x = n % size;\\n  const y = (n / size) | 0;\\n  const delta = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n  return delta.reduce((sum, [dx, dy]) => sum + count(x + dx, y + dy, dx, dy), 0);\\n  function count(x, y, dx, dy) {\\n    if (x < 0 || x >= size || y < 0 || y >= size) {\\n      return 0;\\n    }\\n    switch (board[y][x]) {\\n      case \\'B\\':\\n        return 0;\\n      case \\'p\\':\\n        return 1;\\n      default:\\n        return count(x + dx, y + dy, dx, dy);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nfunction numRookCaptures(board) {\\n  const size = 8;\\n  const total = size ** 2;\\n  let n = 0;\\n  while (board[(n / size) | 0][n % size] !== \\'R\\') {\\n    n = (Math.random() * total) | 0;\\n  }\\n  const x = n % size;\\n  const y = (n / size) | 0;\\n  const delta = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n  return delta.reduce((sum, [dx, dy]) => sum + count(x + dx, y + dy, dx, dy), 0);\\n  function count(x, y, dx, dy) {\\n    if (x < 0 || x >= size || y < 0 || y >= size) {\\n      return 0;\\n    }\\n    switch (board[y][x]) {\\n      case \\'B\\':\\n        return 0;\\n      case \\'p\\':\\n        return 1;\\n      default:\\n        return count(x + dx, y + dy, dx, dy);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515327,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int res = 0;\\n        //four directions\\n        for(int i = 0; i < board.size(); ++i)\\n            for(int j = 0; j < board[0].size(); ++j)\\n                if(board[i][j] == \\'R\\') for(int dir = 1; dir <= 4; ++dir) dfs(board,i,j,res,dir);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, int& res, int dir){\\n        if(i < 0||i >= board.size()||j < 0||j >= board[0].size()||board[i][j]==\\'B\\') return;\\n        if(board[i][j] == \\'p\\') res++;\\n        else dfs(board,i + ((dir % 2) ? dir - 2 : 0),j + (!(dir % 2) ? dir - 3 : 0), res, dir);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int res = 0;\\n        //four directions\\n        for(int i = 0; i < board.size(); ++i)\\n            for(int j = 0; j < board[0].size(); ++j)\\n                if(board[i][j] == \\'R\\') for(int dir = 1; dir <= 4; ++dir) dfs(board,i,j,res,dir);\\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j, int& res, int dir){\\n        if(i < 0||i >= board.size()||j < 0||j >= board[0].size()||board[i][j]==\\'B\\') return;\\n        if(board[i][j] == \\'p\\') res++;\\n        else dfs(board,i + ((dir % 2) ? dir - 2 : 0),j + (!(dir % 2) ? dir - 3 : 0), res, dir);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500938,
                "title": "python3-not-pretty-but-straight-forward",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    count = 0;\\n                    l, r = j - 1, j + 1\\n                    while l >= 0:\\n                        if board[i][l] in \\'pB\\':\\n                            count += board[i][l] == \\'p\\'\\n                            break\\n                        l -= 1\\n                    while r < len(board[0]):\\n                        if board[i][r] in \\'pB\\':\\n                            count += board[i][r] == \\'p\\'\\n                            break\\n                        r += 1\\n                    u, d = i - 1, i + 1\\n                    while u >= 0:\\n                        if board[u][j] in \\'pB\\':\\n                            count += board[u][j] == \\'p\\'\\n                            break\\n                        u -= 1\\n                    while d < len(board):\\n                        if board[d][j] in \\'pB\\':\\n                            count += board[d][j] == \\'p\\'\\n                            break\\n                        d += 1\\n                    return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    count = 0;\\n                    l, r = j - 1, j + 1\\n                    while l >= 0:\\n                        if board[i][l] in \\'pB\\':\\n                            count += board[i][l] == \\'p\\'\\n                            break\\n                        l -= 1\\n                    while r < len(board[0]):\\n                        if board[i][r] in \\'pB\\':\\n                            count += board[i][r] == \\'p\\'\\n                            break\\n                        r += 1\\n                    u, d = i - 1, i + 1\\n                    while u >= 0:\\n                        if board[u][j] in \\'pB\\':\\n                            count += board[u][j] == \\'p\\'\\n                            break\\n                        u -= 1\\n                    while d < len(board):\\n                        if board[d][j] in \\'pB\\':\\n                            count += board[d][j] == \\'p\\'\\n                            break\\n                        d += 1\\n                    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474867,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        length = len(board) - 1\\n        count = 0 \\n        position = [0, 0]\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if board[i][j] == \\'R\\':\\n                    position = [i, j]\\n        \\n        up = position[0] - 1\\n        down = position[0] + 1\\n        left = position[1] - 1\\n        right = position[1] + 1\\n        \\n        while up >= 0:\\n            if board[up][position[1]] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[up][position[1]] == \\'B\\':\\n                break\\n            up -= 1\\n        \\n        while left >= 0:\\n            if board[position[0]][left] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[position[0]][left] == \\'B\\':\\n                break\\n            left -= 1\\n            \\n        while down <= length:\\n            if board[down][position[1]] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[down][position[1]] == \\'B\\':\\n                break\\n            down += 1\\n            \\n        while right <= length:\\n            \\n            if board[position[0]][right] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[position[0]][right] == \\'B\\':\\n                break\\n            right += 1\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        length = len(board) - 1\\n        count = 0 \\n        position = [0, 0]\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if board[i][j] == \\'R\\':\\n                    position = [i, j]\\n        \\n        up = position[0] - 1\\n        down = position[0] + 1\\n        left = position[1] - 1\\n        right = position[1] + 1\\n        \\n        while up >= 0:\\n            if board[up][position[1]] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[up][position[1]] == \\'B\\':\\n                break\\n            up -= 1\\n        \\n        while left >= 0:\\n            if board[position[0]][left] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[position[0]][left] == \\'B\\':\\n                break\\n            left -= 1\\n            \\n        while down <= length:\\n            if board[down][position[1]] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[down][position[1]] == \\'B\\':\\n                break\\n            down += 1\\n            \\n        while right <= length:\\n            \\n            if board[position[0]][right] == \\'p\\':\\n                count += 1\\n                break\\n            elif board[position[0]][right] == \\'B\\':\\n                break\\n            right += 1\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473599,
                "title": "swift-dfs-8ms",
                "content": "```\\nclass Solution {\\n    func rookPosition(_ board: inout [[Character]]) -> (x: Int, y: Int) {\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count {\\n                if board[i][j] == \"R\" {\\n                    return (i, j)\\n                }\\n            }\\n        }\\n        fatalError()\\n    }\\n    \\n    func numRookCaptures(_ board: [[Character]]) -> Int {\\n        var board = board\\n        let position = rookPosition(&board)\\n        \\n        var answer = 0\\n        func dfs(_ x: Int, _ y: Int, _ dx: Int, _ dy: Int) {\\n            guard x >= 0 && x < board.count && y >= 0 && y < board[0].count else  {\\n                return\\n            }\\n            let current = board[x][y]\\n            \\n            guard current != \"p\" else {\\n                answer += 1\\n                return\\n            }\\n            guard current == \".\" || current == \"R\" else {\\n                return\\n            }\\n            \\n            dfs(x + dx, y + dy, dx, dy)\\n        }\\n        \\n        dfs(position.x, position.y, -1, 0)\\n        dfs(position.x, position.y, 1, 0)\\n        dfs(position.x, position.y, 0, 1)\\n        dfs(position.x, position.y, 0, -1)\\n        \\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func rookPosition(_ board: inout [[Character]]) -> (x: Int, y: Int) {\\n        for i in 0..<board.count {\\n            for j in 0..<board[0].count {\\n                if board[i][j] == \"R\" {\\n                    return (i, j)\\n                }\\n            }\\n        }\\n        fatalError()\\n    }\\n    \\n    func numRookCaptures(_ board: [[Character]]) -> Int {\\n        var board = board\\n        let position = rookPosition(&board)\\n        \\n        var answer = 0\\n        func dfs(_ x: Int, _ y: Int, _ dx: Int, _ dy: Int) {\\n            guard x >= 0 && x < board.count && y >= 0 && y < board[0].count else  {\\n                return\\n            }\\n            let current = board[x][y]\\n            \\n            guard current != \"p\" else {\\n                answer += 1\\n                return\\n            }\\n            guard current == \".\" || current == \"R\" else {\\n                return\\n            }\\n            \\n            dfs(x + dx, y + dy, dx, dy)\\n        }\\n        \\n        dfs(position.x, position.y, -1, 0)\\n        dfs(position.x, position.y, 1, 0)\\n        dfs(position.x, position.y, 0, 1)\\n        dfs(position.x, position.y, 0, -1)\\n        \\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471995,
                "title": "simple-python-solution",
                "content": "100% Space and 75% time Python solution!\\n\\nSteps:\\n1. Locate \\'R\\'(Rook)\\n2. Isolate the row and the column where the Rook is present\\n3. You need to see if there\\'s a pawn with any amount of empty space from the Rook ( So I simply removed all the dots and checked for \\'pR\\' or \\'Rp\\')\\n\\nNote that the maximum answer of this question is 4!\\n\\n```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        Ri,Rj=0,0\\n        for i in board:\\n            for j in i:\\n                if j==\\'R\\':\\n                    Ri = board.index(i)\\n                    Rj = i.index(j)\\n                    Rrow = \\'\\'.join(i).replace(\\'.\\', \\'\\')\\n                    Rcol = \\'\\'.join([x[Rj] for x in board]).replace(\\'.\\', \\'\\')\\n                    break\\n        return Rrow.count(\\'Rp\\')+Rrow.count(\\'pR\\')+Rcol.count(\\'pR\\')+Rcol.count(\\'Rp\\')\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        Ri,Rj=0,0\\n        for i in board:\\n            for j in i:\\n                if j==\\'R\\':\\n                    Ri = board.index(i)\\n                    Rj = i.index(j)\\n                    Rrow = \\'\\'.join(i).replace(\\'.\\', \\'\\')\\n                    Rcol = \\'\\'.join([x[Rj] for x in board]).replace(\\'.\\', \\'\\')\\n                    break\\n        return Rrow.count(\\'Rp\\')+Rrow.count(\\'pR\\')+Rcol.count(\\'pR\\')+Rcol.count(\\'Rp\\')\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 458423,
                "title": "c-extremely-readable-functional-solution",
                "content": "```csharp\\n//Not required, Could work with a char array for less code, but stronger types are nicer\\nenum Square { Rook, Blank, Bishop, Pawn }\\ndelegate (int, int) CoordinateTransform((int x, int y) coord); //function signature required for succinct array generation\\n\\npublic int NumRookCaptures(char[][] board) {\\n\\t//Board is guaranteed to be 8x8\\n\\tbool IsOnBoard((int x, int y) i) => i.x >= 0 && i.x <8 && i.y >= 0 && i.y < 8;\\n\\tSquare FromChar(char c)\\n\\t{\\n\\t\\tswitch(c){\\n\\t\\t\\tcase \\'R\\': return Square.Rook;\\n\\t\\t\\tcase \\'.\\': return Square.Blank;\\n\\t\\t\\tcase \\'B\\': return Square.Bishop;\\n\\t\\t\\tcase \\'p\\': return Square.Pawn;\\n\\t\\t\\tdefault: throw new InvalidOperationException(c.ToString());\\n\\t\\t}\\n\\t}\\n\\tchar GetSquareChar((int x, int y) coord) => board[coord.y][coord.x];\\n\\n\\tSquare GetSquareValue((int x, int y) coord) => FromChar(GetSquareChar(coord));\\n\\tbool Is((int x, int y) coord, Square type) => GetSquareValue(coord) == type;\\n\\n\\t(int x, int y) Up((int x, int y) coord) => (coord.x, coord.y - 1);\\n\\t(int x, int y) Down((int x, int y) coord) => (coord.x, coord.y + 1);\\n\\t(int x, int y) Left((int x, int y) coord) => (coord.x - 1, coord.y);\\n\\t(int x, int y) Right((int x, int y) coord) => (coord.x + 1, coord.y);\\n\\n\\tbool IsBlankSquare((int x, int y) coord) => Is(coord, Square.Blank);\\n\\tbool IsBlank((int x, int y) coord) => IsOnBoard(coord) && IsBlankSquare(coord);\\n\\n\\t(int, int) GetNextNonBlank((int, int) start, CoordinateTransform next)\\n\\t{\\n\\t\\tvar current = next(start);\\n\\t\\twhile(IsBlank(current))\\n\\t\\t{\\n\\t\\t\\tcurrent = next(current);\\n\\t\\t}\\n\\t\\treturn current;\\n\\t}\\n\\n\\tvar locations = from i in Enumerable.Range(0, 8) from j in Enumerable.Range(0, 8) select (i, j);\\n\\n\\tvar rookLocation = locations.First(x => Is(x, Square.Rook));\\n\\n\\t(int, int) GetNextNonBlankFromRook(CoordinateTransform next) => GetNextNonBlank(rookLocation, next);\\n\\n\\tbool IsPawn((int x, int y) coord) => Is(coord, Square.Pawn);\\n\\tvar transforms = new CoordinateTransform[] { Up, Down, Left, Right};\\n\\treturn transforms.Select(GetNextNonBlankFromRook).Where(IsOnBoard).Where(IsPawn).Count();  \\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\n//Not required, Could work with a char array for less code, but stronger types are nicer\\nenum Square { Rook, Blank, Bishop, Pawn }\\ndelegate (int, int) CoordinateTransform((int x, int y) coord); //function signature required for succinct array generation\\n\\npublic int NumRookCaptures(char[][] board) {\\n\\t//Board is guaranteed to be 8x8\\n\\tbool IsOnBoard((int x, int y) i) => i.x >= 0 && i.x <8 && i.y >= 0 && i.y < 8;\\n\\tSquare FromChar(char c)\\n\\t{\\n\\t\\tswitch(c){\\n\\t\\t\\tcase \\'R\\': return Square.Rook;\\n\\t\\t\\tcase \\'.\\': return Square.Blank;\\n\\t\\t\\tcase \\'B\\': return Square.Bishop;\\n\\t\\t\\tcase \\'p\\': return Square.Pawn;\\n\\t\\t\\tdefault: throw new InvalidOperationException(c.ToString());\\n\\t\\t}\\n\\t}\\n\\tchar GetSquareChar((int x, int y) coord) => board[coord.y][coord.x];\\n\\n\\tSquare GetSquareValue((int x, int y) coord) => FromChar(GetSquareChar(coord));\\n\\tbool Is((int x, int y) coord, Square type) => GetSquareValue(coord) == type;\\n\\n\\t(int x, int y) Up((int x, int y) coord) => (coord.x, coord.y - 1);\\n\\t(int x, int y) Down((int x, int y) coord) => (coord.x, coord.y + 1);\\n\\t(int x, int y) Left((int x, int y) coord) => (coord.x - 1, coord.y);\\n\\t(int x, int y) Right((int x, int y) coord) => (coord.x + 1, coord.y);\\n\\n\\tbool IsBlankSquare((int x, int y) coord) => Is(coord, Square.Blank);\\n\\tbool IsBlank((int x, int y) coord) => IsOnBoard(coord) && IsBlankSquare(coord);\\n\\n\\t(int, int) GetNextNonBlank((int, int) start, CoordinateTransform next)\\n\\t{\\n\\t\\tvar current = next(start);\\n\\t\\twhile(IsBlank(current))\\n\\t\\t{\\n\\t\\t\\tcurrent = next(current);\\n\\t\\t}\\n\\t\\treturn current;\\n\\t}\\n\\n\\tvar locations = from i in Enumerable.Range(0, 8) from j in Enumerable.Range(0, 8) select (i, j);\\n\\n\\tvar rookLocation = locations.First(x => Is(x, Square.Rook));\\n\\n\\t(int, int) GetNextNonBlankFromRook(CoordinateTransform next) => GetNextNonBlank(rookLocation, next);\\n\\n\\tbool IsPawn((int x, int y) coord) => Is(coord, Square.Pawn);\\n\\tvar transforms = new CoordinateTransform[] { Up, Down, Left, Right};\\n\\treturn transforms.Select(GetNextNonBlankFromRook).Where(IsOnBoard).Where(IsPawn).Count();  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442578,
                "title": "python3-easy-solution-using-string-manipulation-of-row-and-column",
                "content": "```\\nclass Solution:\\n\\tdef numRookCaptures(self, board: List[List[str]]) -> int:\\n\\t\\trow = \"\"\\n\\t\\tfor i in range(8):\\n\\t\\t\\tif \"R\" in board[i]:\\n\\t\\t\\t\\tk = board[i].index(\"R\")\\n\\t\\t\\t\\trow = \"\".join(board[i])\\n\\t\\t\\t\\tbreak\\n\\t\\tcol = \"\"\\n\\t\\tfor j in range(8):\\n\\t\\t\\tcol += board[j][k]\\n\\n\\t\\trow = row.replace(\".\",\"\")\\n\\t\\tcol = col.replace(\".\",\"\")\\n\\n\\t\\treturn self.checkR(row) + self.checkR(col)\\n\\n\\tdef checkR(self,st) -> int:\\n\\t\\tcount = 0\\n\\t\\tif len(st) >= 2:\\n\\t\\t\\tif st.find(\"R\") == 0:\\n\\t\\t\\t\\tif st[1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\telif st.find(\"R\") == len(st) - 1:\\n\\t\\t\\t\\tif st[-2] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif st[st.find(\"R\") - 1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tif st[st.find(\"R\") + 1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef numRookCaptures(self, board: List[List[str]]) -> int:\\n\\t\\trow = \"\"\\n\\t\\tfor i in range(8):\\n\\t\\t\\tif \"R\" in board[i]:\\n\\t\\t\\t\\tk = board[i].index(\"R\")\\n\\t\\t\\t\\trow = \"\".join(board[i])\\n\\t\\t\\t\\tbreak\\n\\t\\tcol = \"\"\\n\\t\\tfor j in range(8):\\n\\t\\t\\tcol += board[j][k]\\n\\n\\t\\trow = row.replace(\".\",\"\")\\n\\t\\tcol = col.replace(\".\",\"\")\\n\\n\\t\\treturn self.checkR(row) + self.checkR(col)\\n\\n\\tdef checkR(self,st) -> int:\\n\\t\\tcount = 0\\n\\t\\tif len(st) >= 2:\\n\\t\\t\\tif st.find(\"R\") == 0:\\n\\t\\t\\t\\tif st[1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\telif st.find(\"R\") == len(st) - 1:\\n\\t\\t\\t\\tif st[-2] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tif st[st.find(\"R\") - 1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tif st[st.find(\"R\") + 1] == \"p\":\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409550,
                "title": "python-3-concise-solution-95-69",
                "content": "Summary of algo:\\n1) locate the rook;\\n2) move from the rook in four cardinal directions to find pawn if no bishop is in the way.\\n\\nThe solution is very straighforward. This implementation can be imporoved further for efficiency, but fast and concise enough to reflect the underlying idea. \\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        #locate the rook (m,n)\\n        for m, n in product(range(8), range(8)):\\n            if board[m][n] == \"R\": break \\n        \\n        def check(di, dj):\\n            \"\"\"Return True if found pawn from (m, n) along given direction\"\"\"\\n            i, j = m, n\\n            while 0 <= i < 8 and 0 <= j < 8:\\n                if board[i][j] not in (\"p\", \"B\"):\\n                    i += di\\n                    j += dj\\n                else: return board[i][j] == \"p\"\\n            return False\\n        \\n        ans = 0\\n        for direction in ((1,0), (0,1), (-1,0), (0,-1)):\\n            ans += check(*direction)\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        #locate the rook (m,n)\\n        for m, n in product(range(8), range(8)):\\n            if board[m][n] == \"R\": break \\n        \\n        def check(di, dj):\\n            \"\"\"Return True if found pawn from (m, n) along given direction\"\"\"\\n            i, j = m, n\\n            while 0 <= i < 8 and 0 <= j < 8:\\n                if board[i][j] not in (\"p\", \"B\"):\\n                    i += di\\n                    j += dj\\n                else: return board[i][j] == \"p\"\\n            return False\\n        \\n        ans = 0\\n        for direction in ((1,0), (0,1), (-1,0), (0,-1)):\\n            ans += check(*direction)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 400782,
                "title": "java-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int[][] moves = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n    public int numRookCaptures(char[][] board) {\\n        if (board.length==0 || board[0].length==0) return 0;\\n        int rookX=0;\\n        int rookY=0;\\n        for(int i=0; i<board.length; i++) {\\n            for(int j=0; j<board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rookX = i;\\n                    rookY = j;\\n                }    \\n            }\\n        }\\n        \\n        int count=0;\\n        for (int i=0; i<4; i++) {\\n            int[] move = moves[i];\\n            int x = rookX;\\n            int y = rookY;\\n            while(rookCanMove(board, x + move[0], y + move[1])) {\\n                x += move[0];\\n                y += move[1];\\n                if (board[x][y] == \\'p\\') {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean rookCanMove(char[][] board, int x, int y) {\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\\n        if (board[x][y] == \\'B\\') return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] moves = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};\\n    public int numRookCaptures(char[][] board) {\\n        if (board.length==0 || board[0].length==0) return 0;\\n        int rookX=0;\\n        int rookY=0;\\n        for(int i=0; i<board.length; i++) {\\n            for(int j=0; j<board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rookX = i;\\n                    rookY = j;\\n                }    \\n            }\\n        }\\n        \\n        int count=0;\\n        for (int i=0; i<4; i++) {\\n            int[] move = moves[i];\\n            int x = rookX;\\n            int y = rookY;\\n            while(rookCanMove(board, x + move[0], y + move[1])) {\\n                x += move[0];\\n                y += move[1];\\n                if (board[x][y] == \\'p\\') {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean rookCanMove(char[][] board, int x, int y) {\\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return false;\\n        if (board[x][y] == \\'B\\') return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398665,
                "title": "swift",
                "content": "```\\nfunc numRookCaptures(_ board: [[Character]]) -> Int {\\n\\tvar result = 0\\n\\tvar (row, column) = (0, 0)\\n\\tfor i in 0..<board.count {\\n\\t\\tfor j in 0..<board.count {\\n\\t\\t\\tif board[i][j] == \"R\" {\\n\\t\\t\\t\\trow = i\\n\\t\\t\\t\\tcolumn = j\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// on right\\n\\tfor column in stride(from: column + 1, to: board.count, by: 1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on left\\n\\tfor column in stride(from: column - 1, through: 0, by: -1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on bottom\\n\\tfor row in stride(from: row + 1, to: board.count, by: 1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on top\\n\\tfor row in stride(from: row - 1, through: 0, by: -1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc numRookCaptures(_ board: [[Character]]) -> Int {\\n\\tvar result = 0\\n\\tvar (row, column) = (0, 0)\\n\\tfor i in 0..<board.count {\\n\\t\\tfor j in 0..<board.count {\\n\\t\\t\\tif board[i][j] == \"R\" {\\n\\t\\t\\t\\trow = i\\n\\t\\t\\t\\tcolumn = j\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// on right\\n\\tfor column in stride(from: column + 1, to: board.count, by: 1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on left\\n\\tfor column in stride(from: column - 1, through: 0, by: -1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on bottom\\n\\tfor row in stride(from: row + 1, to: board.count, by: 1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\t// on top\\n\\tfor row in stride(from: row - 1, through: 0, by: -1) {\\n\\t\\tguard board[row][column].isLetter else { continue }\\n\\t\\tresult += board[row][column].isLowercase ? 1 : 0\\n\\t\\tbreak\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 379640,
                "title": "simon-s-note-python3",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        res=0\\n        n_row=len(board)\\n        n_col=len(board[0])\\n        dirs=[[0,1],[0,-1],[-1,0],[1,0]]\\n        for i in range(n_row):\\n            for j in range(n_col):\\n                if board[i][j]==\"R\":\\n                    for dir in dirs:\\n                        cur_r=i\\n                        cur_c=j\\n                        while 0<=cur_r<n_row and 0<=cur_c<n_col:\\n                            if board[cur_r][cur_c]==\\'B\\':\\n                                break\\n                            if board[cur_r][cur_c]==\"p\":\\n                                res+=1\\n                                break\\n                            cur_r+=dir[0]\\n                            cur_c+=dir[1]\\n                    return res\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        res=0\\n        n_row=len(board)\\n        n_col=len(board[0])\\n        dirs=[[0,1],[0,-1],[-1,0],[1,0]]\\n        for i in range(n_row):\\n            for j in range(n_col):\\n                if board[i][j]==\"R\":\\n                    for dir in dirs:\\n                        cur_r=i\\n                        cur_c=j\\n                        while 0<=cur_r<n_row and 0<=cur_c<n_col:\\n                            if board[cur_r][cur_c]==\\'B\\':\\n                                break\\n                            if board[cur_r][cur_c]==\"p\":\\n                                res+=1\\n                                break\\n                            cur_r+=dir[0]\\n                            cur_c+=dir[1]\\n                    return res\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374355,
                "title": "javascript-solution-not-pretty-but-works",
                "content": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    let rookI = 0;\\n    let rookJ = 0;\\n    let ans = 0;\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if (board[i][j] == \\'R\\') {\\n                rookI = i;\\n                rookJ = j;\\n            }    \\n        }\\n    }\\n    \\n    for(let i = rookI - 1; i >= 0; i--) {\\n        if(board[i][rookJ] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[i][rookJ] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookI + 1; i < board.length; i++) {\\n        if(board[i][rookJ] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[i][rookJ] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookJ - 1; i >= 0; i--) {\\n        if(board[rookI][i] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[rookI][i] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookJ + 1; i < board.length; i++) {\\n        if(board[rookI][i] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[rookI][i] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    return ans;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    let rookI = 0;\\n    let rookJ = 0;\\n    let ans = 0;\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if (board[i][j] == \\'R\\') {\\n                rookI = i;\\n                rookJ = j;\\n            }    \\n        }\\n    }\\n    \\n    for(let i = rookI - 1; i >= 0; i--) {\\n        if(board[i][rookJ] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[i][rookJ] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookI + 1; i < board.length; i++) {\\n        if(board[i][rookJ] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[i][rookJ] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookJ - 1; i >= 0; i--) {\\n        if(board[rookI][i] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[rookI][i] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    for(let i = rookJ + 1; i < board.length; i++) {\\n        if(board[rookI][i] == \\'p\\') {\\n            ans++;\\n            break;\\n        }\\n        \\n        if (board[rookI][i] == \\'B\\') {\\n            break;\\n        }\\n    }\\n    \\n    return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 346332,
                "title": "javascript-4-line-solution-with-explanation",
                "content": "```js\\n/**\\n * explanation:\\n * line1: find position of \"R\",  \"i\" == col, \"j\" == row\\n * line2: get the col and the row of \"R\" as t1 and t2\\n * line3: get the part before \"R\" and reverse it, get the part after \"R\", now the 4 cases are same\\n * line4: remove the \".\" and get the first element, if it\\'s \"p\", means this case count\\n */\\nvar numRookCaptures = function (board) {\\n  let j, i = board.findIndex(r => (j = r.findIndex((c, j) => c == \"R\")) != -1);\\n  let t1 = board.map(r => r[j]), t2 = board[i];\\n  let res = [t1.slice(0, i).reverse(), t1.slice(i + 1), t2.slice(0, j).reverse(), t2.slice(j + 1)];\\n  return res.filter(r => r.filter(c => c != \".\")[0] == \"p\").length;\\n};\\n\\n",
                "solutionTags": [],
                "code": "```js\\n/**\\n * explanation:\\n * line1: find position of \"R\",  \"i\" == col, \"j\" == row\\n * line2: get the col and the row of \"R\" as t1 and t2\\n * line3: get the part before \"R\" and reverse it, get the part after \"R\", now the 4 cases are same\\n * line4: remove the \".\" and get the first element, if it\\'s \"p\", means this case count\\n */\\nvar numRookCaptures = function (board) {\\n  let j, i = board.findIndex(r => (j = r.findIndex((c, j) => c == \"R\")) != -1);\\n  let t1 = board.map(r => r[j]), t2 = board[i];\\n  let res = [t1.slice(0, i).reverse(), t1.slice(i + 1), t2.slice(0, j).reverse(), t2.slice(j + 1)];\\n  return res.filter(r => r.filter(c => c != \".\")[0] == \"p\").length;\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 293042,
                "title": "simple-java-100",
                "content": "```\\nclass Solution {\\n    \\n    public int numRookCaptures(char[][] board) {\\n        int i = 0;\\n        int R_v = -1;\\n        int R_h = -1;\\n        while(i < 64) {\\n            int v = i % 8;\\n            int h = i / 8;\\n            if (board[h][v] == \\'R\\') {\\n                R_v = v;\\n                R_h = h;\\n                break;\\n            }\\n            i++;\\n        }\\n        if (R_v < 0 || R_h < 0) return 0;\\n        return search(board, R_h, R_v, 0, 1) + search(board, R_h, R_v, 1, 0) + search(board, R_h, R_v, 0, -1) + search(board, R_h, R_v, -1, 0);\\n    }\\n    private int search(char[][] board,int h,int v,int step_h,int step_v) {\\n        while (h < 8 && h >= 0 && v < 8 && v >= 0) {\\n            if (board[h][v] == \\'R\\' || board[h][v] == \\'.\\') {\\n                h += step_h;\\n                v += step_v;\\n                continue;\\n            }\\n            if (board[h][v] == \\'B\\') return 0;\\n            if (board[h][v] == \\'p\\') return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int numRookCaptures(char[][] board) {\\n        int i = 0;\\n        int R_v = -1;\\n        int R_h = -1;\\n        while(i < 64) {\\n            int v = i % 8;\\n            int h = i / 8;\\n            if (board[h][v] == \\'R\\') {\\n                R_v = v;\\n                R_h = h;\\n                break;\\n            }\\n            i++;\\n        }\\n        if (R_v < 0 || R_h < 0) return 0;\\n        return search(board, R_h, R_v, 0, 1) + search(board, R_h, R_v, 1, 0) + search(board, R_h, R_v, 0, -1) + search(board, R_h, R_v, -1, 0);\\n    }\\n    private int search(char[][] board,int h,int v,int step_h,int step_v) {\\n        while (h < 8 && h >= 0 && v < 8 && v >= 0) {\\n            if (board[h][v] == \\'R\\' || board[h][v] == \\'.\\') {\\n                h += step_h;\\n                v += step_v;\\n                continue;\\n            }\\n            if (board[h][v] == \\'B\\') return 0;\\n            if (board[h][v] == \\'p\\') return 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291825,
                "title": "c-simple",
                "content": "\\n\\nint numRookCaptures(char** board, int boardSize, int* boardColSize){\\n    int i, j, flag = 0, rookX, rookY, score = 0;\\n    \\n    for(i = 0; i < 8; i++){\\n        for(j = 0; j < 8; j++){\\n            if(board[i][j] == \\'R\\'){\\n                rookX = i;\\n                rookY = j;\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(flag == 1)\\n            break;\\n    }\\n    \\n    for(i = rookX; i < 8; i++){\\n        if(board[rookX][i] == \\'B\\')\\n            break;\\n        else if(board[rookX][i] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }  \\n    for(i = rookX; i >= 0; i--){\\n        if(board[rookX][i] == \\'B\\')\\n            break;\\n        else if(board[rookX][i] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    \\n    for(i = rookY; i < 8; i++){\\n        if(board[i][rookY] == \\'B\\')\\n            break;\\n        else if(board[i][rookY] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    for(i = rookY; i > 0; i--){\\n        if(board[i][rookY] == \\'B\\')\\n            break;\\n        else if(board[i][rookY] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    \\n    return score;\\n}",
                "solutionTags": [],
                "code": "\\n\\nint numRookCaptures(char** board, int boardSize, int* boardColSize){\\n    int i, j, flag = 0, rookX, rookY, score = 0;\\n    \\n    for(i = 0; i < 8; i++){\\n        for(j = 0; j < 8; j++){\\n            if(board[i][j] == \\'R\\'){\\n                rookX = i;\\n                rookY = j;\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if(flag == 1)\\n            break;\\n    }\\n    \\n    for(i = rookX; i < 8; i++){\\n        if(board[rookX][i] == \\'B\\')\\n            break;\\n        else if(board[rookX][i] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }  \\n    for(i = rookX; i >= 0; i--){\\n        if(board[rookX][i] == \\'B\\')\\n            break;\\n        else if(board[rookX][i] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    \\n    for(i = rookY; i < 8; i++){\\n        if(board[i][rookY] == \\'B\\')\\n            break;\\n        else if(board[i][rookY] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    for(i = rookY; i > 0; i--){\\n        if(board[i][rookY] == \\'B\\')\\n            break;\\n        else if(board[i][rookY] == \\'p\\'){\\n            score++;\\n            break;\\n        }\\n    }\\n    \\n    return score;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 288901,
                "title": "java-solution-100-faster-100-memory-efficient",
                "content": "0ms and ~33 of memory\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ans =0;\\n        int rookI = 0;\\n        int rookJ = 0;\\n        \\n        //find the coordinate of the Rook\\n        for(int i=0; i< board.length; i++){\\n            for(int j=0; j< board[i].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    rookI = i;\\n                    rookJ = j;\\n                } \\n            }\\n        }\\n\\n        int tempR= rookJ;\\n        int tempL = rookJ;\\n        //check Right from position of Rook til end of board(->)\\n        while((tempR < board[rookI].length) && tempR<7){\\n            tempR++;\\n            if(board[rookI][tempR] == \\'B\\'){\\n                break;\\n            }\\n            if(board[rookI][tempR] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n        }\\n        //check Left from position of Rook til end of board(<-)\\n        while(tempL < (board[rookI].length ) && tempL >0){\\n            tempL--;\\n            if(board[rookI][tempL] == \\'B\\')\\n                break;\\n            if(board[rookI][tempL] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n        }\\n        \\n        int tempUp = rookI;\\n        int tempDown = rookI;\\n        //check UP from position of Rook til top of Board\\n        while(tempUp < (board.length) && tempUp>0){\\n            tempUp--;\\n            if(board[tempUp][rookJ] == \\'B\\')\\n                break;\\n            if(board[tempUp][rookJ] == \\'p\\'){\\n                ans++; break;\\n            }\\n        }\\n        //check Down, from position of Rook til bottom of board\\n        while(tempDown < (board.length ) && tempDown <7){\\n            tempDown++;\\n            if(board[tempDown][rookJ] == \\'B\\')\\n                break;\\n            if(board[tempDown][rookJ] == \\'p\\'){\\n                ans++; break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int ans =0;\\n        int rookI = 0;\\n        int rookJ = 0;\\n        \\n        //find the coordinate of the Rook\\n        for(int i=0; i< board.length; i++){\\n            for(int j=0; j< board[i].length; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    rookI = i;\\n                    rookJ = j;\\n                } \\n            }\\n        }\\n\\n        int tempR= rookJ;\\n        int tempL = rookJ;\\n        //check Right from position of Rook til end of board(->)\\n        while((tempR < board[rookI].length) && tempR<7){\\n            tempR++;\\n            if(board[rookI][tempR] == \\'B\\'){\\n                break;\\n            }\\n            if(board[rookI][tempR] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n        }\\n        //check Left from position of Rook til end of board(<-)\\n        while(tempL < (board[rookI].length ) && tempL >0){\\n            tempL--;\\n            if(board[rookI][tempL] == \\'B\\')\\n                break;\\n            if(board[rookI][tempL] == \\'p\\'){\\n                ans++;\\n                break;\\n            }\\n        }\\n        \\n        int tempUp = rookI;\\n        int tempDown = rookI;\\n        //check UP from position of Rook til top of Board\\n        while(tempUp < (board.length) && tempUp>0){\\n            tempUp--;\\n            if(board[tempUp][rookJ] == \\'B\\')\\n                break;\\n            if(board[tempUp][rookJ] == \\'p\\'){\\n                ans++; break;\\n            }\\n        }\\n        //check Down, from position of Rook til bottom of board\\n        while(tempDown < (board.length ) && tempDown <7){\\n            tempDown++;\\n            if(board[tempDown][rookJ] == \\'B\\')\\n                break;\\n            if(board[tempDown][rookJ] == \\'p\\'){\\n                ans++; break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286158,
                "title": "compact-python-solution",
                "content": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def get_r_index(self, board):\\n        for i, row in enumerate(board):\\n            for j, val in enumerate(row):\\n                if val == \\'R\\':\\n                    return i, j\\n\\n    def check(self, coords, board):\\n        for i, j in coords:\\n            if board[i][j] == \\'p\\':\\n                return 1\\n            if board[i][j] != \\'.\\':\\n                return 0\\n        return 0\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        ri, rj = self.get_r_index(board)\\n        products = [\\n            product([ri], range(rj - 1, -1, -1)),\\n            product([ri], range(rj + 1, len(board))),\\n            product(range(ri - 1, -1, -1), [rj]),\\n            product(range(ri + 1, len(board[0])), [rj])\\n        ]\\n        return sum(self.check(p, board) for p in products)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def get_r_index(self, board):\\n        for i, row in enumerate(board):\\n            for j, val in enumerate(row):\\n                if val == \\'R\\':\\n                    return i, j\\n\\n    def check(self, coords, board):\\n        for i, j in coords:\\n            if board[i][j] == \\'p\\':\\n                return 1\\n            if board[i][j] != \\'.\\':\\n                return 0\\n        return 0\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        ri, rj = self.get_r_index(board)\\n        products = [\\n            product([ri], range(rj - 1, -1, -1)),\\n            product([ri], range(rj + 1, len(board))),\\n            product(range(ri - 1, -1, -1), [rj]),\\n            product(range(ri + 1, len(board[0])), [rj])\\n        ]\\n        return sum(self.check(p, board) for p in products)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283048,
                "title": "java-solution-faster-than-100-and-less-than-100",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n        int[][] oper = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    for (int k = 0; k < 4; k++) {\\n                        int a = i + oper[k][0];\\n                        int b = j + oper[k][1];\\n                        while (0 <= a && a < 8 && 0 <= b && b < 8) {\\n                            if (board[a][b] == \\'B\\') {\\n                                break;\\n                            }\\n                            if (board[a][b] == \\'p\\') {\\n                                count++;\\n                                break;\\n                            }\\n                            a += oper[k][0];\\n                            b += oper[k][1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int count = 0;\\n        int[][] oper = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    for (int k = 0; k < 4; k++) {\\n                        int a = i + oper[k][0];\\n                        int b = j + oper[k][1];\\n                        while (0 <= a && a < 8 && 0 <= b && b < 8) {\\n                            if (board[a][b] == \\'B\\') {\\n                                break;\\n                            }\\n                            if (board[a][b] == \\'p\\') {\\n                                count++;\\n                                break;\\n                            }\\n                            a += oper[k][0];\\n                            b += oper[k][1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266989,
                "title": "javascript-faster-than-97-53-less-memory-than-100",
                "content": "```\\nvar numRookCaptures = function(board) {\\n    \\n    //Find rook\\n    let x = 0, y = 0, pawns = 0;\\n    for (y = 0; y < 8; y++)  {\\n        if(board[y].indexOf(\\'R\\') >= 0) {\\n            x = board[y].indexOf(\\'R\\');\\n            break;\\n        }\\n    }\\n    \\n    //Horizontal moves\\n    [-1, 1].forEach(incr => {\\n        let i = x;\\n        while(board[y][i] && board[y][i] !== \\'B\\') {\\n            if(board[y][i] === \\'p\\') {\\n                pawns++;\\n                break;\\n            }\\n            i += incr;\\n        }\\n    });\\n    \\n    //Vertical moves\\n    [-1, 1].forEach(incr => {\\n        let i = y;\\n        while((board[i] || 0)[x] && (board[i] || 0)[x] !== \\'B\\') {\\n            if(board[i][x] === \\'p\\') {\\n                pawns++;\\n                break;\\n            }\\n            i += incr;\\n        }\\n    });\\n    \\n    return pawns;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numRookCaptures = function(board) {\\n    \\n    //Find rook\\n    let x = 0, y = 0, pawns = 0;\\n    for (y = 0; y < 8; y++)  {\\n        if(board[y].indexOf(\\'R\\') >= 0) {\\n            x = board[y].indexOf(\\'R\\');\\n            break;\\n        }\\n    }\\n    \\n    //Horizontal moves\\n    [-1, 1].forEach(incr => {\\n        let i = x;\\n        while(board[y][i] && board[y][i] !== \\'B\\') {\\n            if(board[y][i] === \\'p\\') {\\n                pawns++;\\n                break;\\n            }\\n            i += incr;\\n        }\\n    });\\n    \\n    //Vertical moves\\n    [-1, 1].forEach(incr => {\\n        let i = y;\\n        while((board[i] || 0)[x] && (board[i] || 0)[x] !== \\'B\\') {\\n            if(board[i][x] === \\'p\\') {\\n                pawns++;\\n                break;\\n            }\\n            i += incr;\\n        }\\n    });\\n    \\n    return pawns;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 263479,
                "title": "simple-java-solution-beats-100",
                "content": "```\\npublic int numRookCaptures(char[][] board) {\\n        int numberOfSteps = 0;\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    numberOfSteps+=goUp(board,i,j)?1:0;\\n                    numberOfSteps+=godown(board,i,j)?1:0;\\n                    numberOfSteps+=goLeft(board,i,j)?1:0;\\n                    numberOfSteps+=goRight(board,i,j)?1:0;\\n                    break;\\n                }\\n            }\\n        }\\n        return numberOfSteps;\\n    }\\n\\n    private boolean goUp(char[][]board, int i,int j){\\n        for(;i>=0;i--){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean godown(char[][]board, int i,int j){\\n        for(;i<board.length;i++){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean goLeft(char[][]board, int i,int j){\\n        for(;j>=0;j--){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean goRight(char[][]board, int i,int j){\\n        for(;j<board[i].length;j++){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numRookCaptures(char[][] board) {\\n        int numberOfSteps = 0;\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    numberOfSteps+=goUp(board,i,j)?1:0;\\n                    numberOfSteps+=godown(board,i,j)?1:0;\\n                    numberOfSteps+=goLeft(board,i,j)?1:0;\\n                    numberOfSteps+=goRight(board,i,j)?1:0;\\n                    break;\\n                }\\n            }\\n        }\\n        return numberOfSteps;\\n    }\\n\\n    private boolean goUp(char[][]board, int i,int j){\\n        for(;i>=0;i--){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean godown(char[][]board, int i,int j){\\n        for(;i<board.length;i++){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean goLeft(char[][]board, int i,int j){\\n        for(;j>=0;j--){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean goRight(char[][]board, int i,int j){\\n        for(;j<board[i].length;j++){\\n            if(board[i][j]==\\'B\\'){\\n                return false;\\n            }\\n            if(board[i][j]==\\'p\\'){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 254026,
                "title": "c-solution-100-faster-in-speed-and-100-less-in-memory",
                "content": "int row = 0;\\n        int col = 0;\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < 8 ; i ++){\\n            \\n            for(int j = 0; j < 8;j++){\\n                \\n                if(board[i][j] == \\'R\\'){\\n                    \\n                   \\n                    row = i;\\n                    col = j;\\n                    break;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        for(int i = col; i< 8;i++){\\n            \\n            if(board[row][i] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[row][i] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n         for(int i = col; i>=0;i--){\\n            \\n            if(board[row][i] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[row][i] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n         for(int i = row; i< 8;i++){\\n            \\n            if(board[i][col] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[i][col] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n         for(int i = row; i >= 0;i--){\\n            \\n            if(board[i][col] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[i][col] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n",
                "solutionTags": [],
                "code": "int row = 0;\\n        int col = 0;\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < 8 ; i ++){\\n            \\n            for(int j = 0; j < 8;j++){\\n                \\n                if(board[i][j] == \\'R\\'){\\n                    \\n                   \\n                    row = i;\\n                    col = j;\\n                    break;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        for(int i = col; i< 8;i++){\\n            \\n            if(board[row][i] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[row][i] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n         for(int i = col; i>=0;i--){\\n            \\n            if(board[row][i] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[row][i] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n         for(int i = row; i< 8;i++){\\n            \\n            if(board[i][col] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[i][col] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n         for(int i = row; i >= 0;i--){\\n            \\n            if(board[i][col] == \\'p\\'){\\n                \\n                result += 1;\\n                break;\\n            }\\n            else  if(board[i][col] == \\'B\\'){\\n                \\n               break;\\n            }\\n            \\n        }\\n        \\n        \\n        \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 251796,
                "title": "c-faster-than-100-smaller-than-100",
                "content": "For each direction among up, down, left, right, move the current position one step forward each time and see the if it bump into a paw (\\'p\\') or a Bishop \\'(B)\\'.\\ni.e.\\n```\\nfor each direction\\n    initialize current position (x,y) to be (xR, yR)\\n    while (current position (x,y) does not reach the bound)\\n\\t    if (board[x][y]==\\'B\\')\\n\\t\\t    break; /*search on current direction ends.*/\\n\\t    else if (board[x][y]==\\'p\\')\\n\\t\\t\\tbreak; /*search on current direction ends.*/\\n\\t\\t\\t++count;\\n\\t\\tend if\\n\\t\\tupdate (x, y) //move one step forward on the current direction\\n\\tend while\\nend for\\n```\\n use directions[4][2]=[(-1,0), (1,0), (0, 1), (0, -1)]  to represent 4 directions: up, down, left, right.  Since the bound coordinates (when no Bishop or paw is met during the search and we search right to the bound of the board on that direction) varies with the direction:\\n \\n use **int bound_dimension** and **int bound_value** to record the how to measure if we reach the bound.\\n here I used bound_dimension =0 to represent that we measure if we reach the bound by current row coordinate, 1 for column coordinate:\\n ![image](https://assets.leetcode.com/users/lilytennant/image_1552124840.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int Rrow, Rcolumn, answer=0;\\n        for (int row=0; row<8; row++) {\\n            for (int column=0; column<8; column++) {\\n                if (board[row][column]==\\'R\\') {\\n                    Rrow=row;\\n                    Rcolumn=column;\\n                }\\n            }\\n        }\\n        int directions[4][2]={-1,0,1,0,0,-1,0,1};\\n        for (int choice=0; choice<4; choice++) {\\n            int current_coordinates[2]={Rrow, Rcolumn};\\n            int bound_dimension, bound_value;\\n            bound_dimension=(directions[choice][0]==0)?1:0;\\n            bound_value=(directions[choice][bound_dimension]==-1)?-1:8;\\n            while (current_coordinates[bound_dimension]!=bound_value) {\\n                char current_value=board[current_coordinates[0]][current_coordinates[1]];\\n                if (current_value==\\'p\\') {\\n                    ++answer;\\n                    break;\\n                } else if (current_value==\\'B\\') {\\n                    break;\\n                }\\n                current_coordinates[bound_dimension]+=directions[choice][bound_dimension];\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\nHowever, I think it can be improved if just use enum **directions {up, down, left, right}** to represent these directions, I used 2-dimensional array because I thought I can update the coordinates but add **(directionX, directionY)** on both dimension in the beginning. But turns out there\\'s no need and doing so complicates the logic a little bit, so the solution could have been faster.",
                "solutionTags": [],
                "code": "```\\nfor each direction\\n    initialize current position (x,y) to be (xR, yR)\\n    while (current position (x,y) does not reach the bound)\\n\\t    if (board[x][y]==\\'B\\')\\n\\t\\t    break; /*search on current direction ends.*/\\n\\t    else if (board[x][y]==\\'p\\')\\n\\t\\t\\tbreak; /*search on current direction ends.*/\\n\\t\\t\\t++count;\\n\\t\\tend if\\n\\t\\tupdate (x, y) //move one step forward on the current direction\\n\\tend while\\nend for\\n```\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int Rrow, Rcolumn, answer=0;\\n        for (int row=0; row<8; row++) {\\n            for (int column=0; column<8; column++) {\\n                if (board[row][column]==\\'R\\') {\\n                    Rrow=row;\\n                    Rcolumn=column;\\n                }\\n            }\\n        }\\n        int directions[4][2]={-1,0,1,0,0,-1,0,1};\\n        for (int choice=0; choice<4; choice++) {\\n            int current_coordinates[2]={Rrow, Rcolumn};\\n            int bound_dimension, bound_value;\\n            bound_dimension=(directions[choice][0]==0)?1:0;\\n            bound_value=(directions[choice][bound_dimension]==-1)?-1:8;\\n            while (current_coordinates[bound_dimension]!=bound_value) {\\n                char current_value=board[current_coordinates[0]][current_coordinates[1]];\\n                if (current_value==\\'p\\') {\\n                    ++answer;\\n                    break;\\n                } else if (current_value==\\'B\\') {\\n                    break;\\n                }\\n                current_coordinates[bound_dimension]+=directions[choice][bound_dimension];\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251102,
                "title": "c-solution",
                "content": "```C\\nint numRookCaptures(char **board, int boardRowSize, int boardColSize) {\\n    int result = 0;\\n    for (int i = 0; i < boardRowSize; ++i) {\\n        for (int j = 0; j < boardColSize; ++j) {\\n            if (board[i][j] == \\'R\\') {\\n                for (int left = j; left > 0; --left) {\\n                    if (board[i][left] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[i][left] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int right = j; right < boardColSize; ++right) {\\n                    if (board[i][right] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[i][right] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int up = j; up > 0; --up) {\\n                    if (board[up][j] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[up][j] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int down = j; down < boardRowSize; ++down) {\\n                    if (board[down][j] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[down][j] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n\\n                break;\\n            }\\n        }\\n\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C\\nint numRookCaptures(char **board, int boardRowSize, int boardColSize) {\\n    int result = 0;\\n    for (int i = 0; i < boardRowSize; ++i) {\\n        for (int j = 0; j < boardColSize; ++j) {\\n            if (board[i][j] == \\'R\\') {\\n                for (int left = j; left > 0; --left) {\\n                    if (board[i][left] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[i][left] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int right = j; right < boardColSize; ++right) {\\n                    if (board[i][right] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[i][right] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int up = j; up > 0; --up) {\\n                    if (board[up][j] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[up][j] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n                for (int down = j; down < boardRowSize; ++down) {\\n                    if (board[down][j] == \\'p\\') {\\n                        result++;\\n                        break;\\n                    }\\n                    if (board[down][j] == \\'B\\') {\\n                        break;\\n                    }\\n                }\\n\\n                break;\\n            }\\n        }\\n\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250030,
                "title": "simple-c",
                "content": "```\\nint numRookCaptures(char** board, int boardRowSize, int *boardColSizes) {\\n    \\n    int count = 0;\\n    for (int i = 0; i < boardRowSize; i++) {\\n        for (int j = 0; j < sizeof(boardColSizes); j++) {\\n            if (board[i][j] == \\'R\\') {\\n                if (i+1 < 8) {\\n                    for (int k = i+1; k < 8; k++) {\\n                        if (board[k][j] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[k][j] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (i-1 >= 0) {\\n                    for (int k = i-1; k >= 0; k--) {\\n                        if (board[k][j] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[k][j] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }  \\n                }\\n                \\n                if (j+1 < 8) {\\n                    for (int k = j+1; k < 8; k++) {\\n                        if (board[i][k] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[i][k] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n                if (j-1 >= 0) {\\n                    for (int k = j-1; k >= 0; k--) {\\n                        if (board[i][k] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[i][k] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numRookCaptures(char** board, int boardRowSize, int *boardColSizes) {\\n    \\n    int count = 0;\\n    for (int i = 0; i < boardRowSize; i++) {\\n        for (int j = 0; j < sizeof(boardColSizes); j++) {\\n            if (board[i][j] == \\'R\\') {\\n                if (i+1 < 8) {\\n                    for (int k = i+1; k < 8; k++) {\\n                        if (board[k][j] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[k][j] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (i-1 >= 0) {\\n                    for (int k = i-1; k >= 0; k--) {\\n                        if (board[k][j] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[k][j] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }  \\n                }\\n                \\n                if (j+1 < 8) {\\n                    for (int k = j+1; k < 8; k++) {\\n                        if (board[i][k] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[i][k] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n                if (j-1 >= 0) {\\n                    for (int k = j-1; k >= 0; k--) {\\n                        if (board[i][k] == \\'p\\') {\\n                            count++;\\n                            break;\\n                        } \\n                        else if (board[i][k] == \\'.\\') {\\n                            continue;\\n                        } \\n                        else {\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250004,
                "title": "java-100-with-3ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        for (int i=0;i<8;i++){\\n            for (int j=0;j<8;j++){\\n                if( board[i][j] == \\'R\\' ){\\n                    return getKill(i,j,\"white\",board);\\n                }\\n                else if(board[i][j]==\\'r\\'){\\n                    return getKill(i,j,\"black\",board);\\n                }\\n\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int getKill(int row, int col, String color,char[][] brd){\\n        char oppB =\\'B\\';\\n        char oppP = \\'P\\';\\n        int count = 0;\\n        if(color.equals(\"white\")){\\n            oppB = \\'b\\';\\n            oppP = \\'p\\';\\n            System.out.println(\"WHITE\");\\n        }\\n        for (int i = row+1; i<8;i++){\\n            System.out.println(\"row incre \");\\n            if (brd[i][col]==oppB || brd[i][col]==oppP){\\n                count++;\\n                break;\\n            }\\n            else if (brd[i][col]!=\\'.\\'){\\n                break;\\n            }\\n        }\\n        for (int i = row-1; i>=0;i--){\\n            System.out.println(\"row dec \");\\n            if (brd[i][col]==oppB || brd[i][col]==oppP){\\n                count++;\\n                break;\\n            }\\n            else if (brd[i][col]!=\\'.\\'){\\n                break;\\n            }\\n        }\\n        \\n        for (int i = col-1; i>=0;i--){\\n            System.out.println(\"col dec \");\\n            if (brd[row][i]==oppB || brd[row][i]==oppP){\\n                count++;\\n                break;\\n            }\\n            else if (brd[row][i]!=\\'.\\'){\\n                break;\\n            }\\n        }\\n        \\n        for (int i = col+1; i<8;i++){\\n            System.out.println(\"col incre \");\\n            if (brd[row][i]==oppB || brd[row][i]==oppP){\\n                count++;\\n                break;\\n            }\\n            else if (brd[row][i]!=\\'.\\'){\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numRookCaptures(char[][] board) {\\n        for (int i=0;i<8;i++){\\n            for (int j=0;j<8;j++){\\n                if( board[i][j] == \\'R\\' ){\\n                    return getKill(i,j,\"white\",board);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 248464,
                "title": "python-solution-faster-than-100",
                "content": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n                \\n        rook_i = 0\\n        rook_j = 0\\n        pawns = 0\\n        \\n        #find the position of rook on the board\\n        for i in range(0, len(board)):\\n            for j in range(0, len(board[i])):\\n                if board[i][j] == \"R\":\\n                    rook_i = i\\n                    rook_j = j\\n        \\n        for x,y in [(1,0), (0,1), (-1,0), (0,-1)]:\\n            pawns += self.boardTraverse(board, rook_i, rook_j, x, y)\\n        \\n        return pawns\\n    \\n    def boardTraverse(self, board, row, col, x, y):\\n        if not 0 <= row < 8 or not 0 <= col < 8 or board[row][col] == \\'B\\':\\n            return 0\\n        elif board[row][col] == \\'p\\':\\n            return 1\\n        else:\\n            return self.boardTraverse(board, row+x, col+y, x, y)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n                \\n        rook_i = 0\\n        rook_j = 0\\n        pawns = 0\\n        \\n        #find the position of rook on the board\\n        for i in range(0, len(board)):\\n            for j in range(0, len(board[i])):\\n                if board[i][j] == \"R\":\\n                    rook_i = i\\n                    rook_j = j\\n        \\n        for x,y in [(1,0), (0,1), (-1,0), (0,-1)]:\\n            pawns += self.boardTraverse(board, rook_i, rook_j, x, y)\\n        \\n        return pawns\\n    \\n    def boardTraverse(self, board, row, col, x, y):\\n        if not 0 <= row < 8 or not 0 <= col < 8 or board[row][col] == \\'B\\':\\n            return 0\\n        elif board[row][col] == \\'p\\':\\n            return 1\\n        else:\\n            return self.boardTraverse(board, row+x, col+y, x, y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244458,
                "title": "js-javascript-w-comments-52ms-100-time-and-space",
                "content": "1. Get the row and column arrays relative to the Rook\\n2. Track the Rook position respective to the row and column arrays \\n3. Search the cardinal directions on each side of the Rook and cache the relevant Pawn and Bishop positions\\n4.  If a bishop is not present east or north of the rook, set its position off the board (rather than breaking the search loops)\\n5.  Count capturable pawns from the cache and return the total\\n\\n```\\nconst numRookCaptures = function(board) {\\n  let results = 0, loc = {leftP: null, leftB: null, rightP: null, rightB: null, upP: null, upB: null, downP: null, downB: null};\\n  const getRookRow = b => b ? b.filter( row => row.indexOf(\\'R\\') !== -1 ).pop() : null;\\n  const getRookColumn = b => b.reduce( (acc, row, i) => { acc.push(row[getRookRow(b).indexOf(\\'R\\')]); return acc; }, []);\\n  \\n  // 1.\\n  const row = getRookRow(board), col = getRookColumn(board);\\n  \\n  // 2.\\n  const rowRPos = row.indexOf(\\'R\\'), colRPos = col.indexOf(\\'R\\');\\n \\n  // 3.\\n  for (let i = 0; i < rowRPos; i++ ) {\\n    if (row[i] === \\'p\\') loc.leftP = i;\\n    if (row[i] === \\'B\\') loc.leftB = i;\\n  }\\n  for (let i = row.length - 1; i > rowRPos; i-- ) {\\n    if (row[i] === \\'p\\') loc.rightP = i;\\n    if (row[i] === \\'B\\') loc.rightB = i;\\n  }\\n  for (let i = 0; i < colRPos; i++ ) {\\n    if (col[i] === \\'p\\') loc.upP = i;\\n    if (col[i] === \\'B\\') loc.upB = i;\\n  }\\n  for (let i = col.length - 1; i > colRPos; i-- ) {\\n    if (col[i] === \\'p\\') loc.downP = i;\\n    if (col[i] === \\'B\\') loc.downB = i;\\n  }\\n  \\n  // 4.\\n  if (!loc.rightB) loc.rightB = row.length + 1;\\n  if (!loc.downB) loc.downB = row.length + 1;\\n \\n // 5.\\n  if (loc.leftP && loc.leftP > loc.leftB) results++;\\n  if (loc.rightP && loc.rightP < loc.rightB) results++;\\n  if (loc.upP && loc.upP > loc.upB) results++;\\n  if (loc.downP && loc.downP < loc.downB) results++;\\n  return results;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numRookCaptures = function(board) {\\n  let results = 0, loc = {leftP: null, leftB: null, rightP: null, rightB: null, upP: null, upB: null, downP: null, downB: null};\\n  const getRookRow = b => b ? b.filter( row => row.indexOf(\\'R\\') !== -1 ).pop() : null;\\n  const getRookColumn = b => b.reduce( (acc, row, i) => { acc.push(row[getRookRow(b).indexOf(\\'R\\')]); return acc; }, []);\\n  \\n  // 1.\\n  const row = getRookRow(board), col = getRookColumn(board);\\n  \\n  // 2.\\n  const rowRPos = row.indexOf(\\'R\\'), colRPos = col.indexOf(\\'R\\');\\n \\n  // 3.\\n  for (let i = 0; i < rowRPos; i++ ) {\\n    if (row[i] === \\'p\\') loc.leftP = i;\\n    if (row[i] === \\'B\\') loc.leftB = i;\\n  }\\n  for (let i = row.length - 1; i > rowRPos; i-- ) {\\n    if (row[i] === \\'p\\') loc.rightP = i;\\n    if (row[i] === \\'B\\') loc.rightB = i;\\n  }\\n  for (let i = 0; i < colRPos; i++ ) {\\n    if (col[i] === \\'p\\') loc.upP = i;\\n    if (col[i] === \\'B\\') loc.upB = i;\\n  }\\n  for (let i = col.length - 1; i > colRPos; i-- ) {\\n    if (col[i] === \\'p\\') loc.downP = i;\\n    if (col[i] === \\'B\\') loc.downB = i;\\n  }\\n  \\n  // 4.\\n  if (!loc.rightB) loc.rightB = row.length + 1;\\n  if (!loc.downB) loc.downB = row.length + 1;\\n \\n // 5.\\n  if (loc.leftP && loc.leftP > loc.leftB) results++;\\n  if (loc.rightP && loc.rightP < loc.rightB) results++;\\n  if (loc.upP && loc.upP > loc.upB) results++;\\n  if (loc.downP && loc.downP < loc.downB) results++;\\n  return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244293,
                "title": "js-solution",
                "content": "```\\n\\n```/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    let R = null\\n \\n    board.forEach((lst,i)=>(lst.forEach((rook, j)=> {(rook == \\'R\\' ? R = {x: j,y: i} : 0)})));\\n    \\n    let row = board[R.y].toString().replace(/\\\\,|\\\\./g, \"\");\\n    let col = board.map((lst)=>lst[R.x]).toString().replace(/\\\\,|\\\\./g, \"\");\\n    \\n\\n    let r = row.indexOf(\"R\"), c = col.indexOf(\"R\"), count = 0;\\n    \\n    for (let i=r-1; i<=r+1;i++){\\n        if (r != -1 && row[i] == \\'p\\'){\\n            count++;\\n        }\\n    }\\n    \\n    for (let i=c-1; i<=c+1;i++){\\n        if (c != -1 && col[i] == \\'p\\'){\\n            count++;\\n        }\\n    }\\n    \\n    console.log(R, row, col)\\n    \\n    return count\\n    \\n   \\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244133,
                "title": "java-solution-1ms",
                "content": "Pseudocode:\\n```\\nFind Rook\\nSearch left from rooks position:\\n\\tif bishop, break\\n\\tif pawn, counter++ and break\\nDo the same with right, up, and down from rooks position\\nreturn counter\\n```\\nSolution:\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int x = -1, y = -1;\\n        for(int i = 0; i < 8; i++) {\\n            for(int j = 0; j < 8; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n            if(x != -1) break;\\n        }\\n        \\n        // board[x][y] is the rook\\n        // search above, if bishop is hit, break, if pawn is hit, increase counter and break\\n        int counter = 0;\\n        for(int i = x; i >= 0; i--) {\\n            if(board[i][y] == \\'B\\') break;\\n            if(board[i][y] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        //search below\\n        for(int i = x; i < 8; i++) {\\n            if(board[i][y] == \\'B\\') break;\\n            if(board[i][y] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        // search left\\n        for(int i = y; i >= 0; i--) {\\n            if(board[x][i] == \\'B\\') break;\\n            if(board[x][i] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        // search right\\n        for(int i = y; i < 8; i++) {\\n            if(board[x][i] == \\'B\\') break;\\n            if(board[x][i] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nFind Rook\\nSearch left from rooks position:\\n\\tif bishop, break\\n\\tif pawn, counter++ and break\\nDo the same with right, up, and down from rooks position\\nreturn counter\\n```\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int x = -1, y = -1;\\n        for(int i = 0; i < 8; i++) {\\n            for(int j = 0; j < 8; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    x = i;\\n                    y = j;\\n                    break;\\n                }\\n            }\\n            if(x != -1) break;\\n        }\\n        \\n        // board[x][y] is the rook\\n        // search above, if bishop is hit, break, if pawn is hit, increase counter and break\\n        int counter = 0;\\n        for(int i = x; i >= 0; i--) {\\n            if(board[i][y] == \\'B\\') break;\\n            if(board[i][y] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        //search below\\n        for(int i = x; i < 8; i++) {\\n            if(board[i][y] == \\'B\\') break;\\n            if(board[i][y] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        // search left\\n        for(int i = y; i >= 0; i--) {\\n            if(board[x][i] == \\'B\\') break;\\n            if(board[x][i] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        // search right\\n        for(int i = y; i < 8; i++) {\\n            if(board[x][i] == \\'B\\') break;\\n            if(board[x][i] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243636,
                "title": "simple-java-recursive-flood-fill-algorithm-1ms",
                "content": "\\'\\'\\'\\nclass Solution {\\n    \\n    public int numRookCaptures(char[][] board, int row, int col, char direction){\\n        if(row >= 8 || col >= 8 || row < 0 || col < 0) return 0;\\n        \\n        if(board[row][col] != \\'.\\' && board[row][col] != \\'R\\'){\\n            if(board[row][col] == \\'p\\')\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(direction == \\'u\\'){\\n            return (numRookCaptures(board,row-1,col,direction));\\n        }\\n        else if(direction ==\\'d\\'){\\n            return (numRookCaptures(board,row+1,col,direction));\\n        }\\n        else if(direction == \\'l\\'){\\n            return (numRookCaptures(board,row,col-1,direction));\\n        }\\n        \\n        return (numRookCaptures(board,row,col+1,direction));\\n    }\\n    \\n    public int numRookCaptures(char[][] board) {\\n        \\n        int row = -1,col = -1;\\n        \\n        for(int i = 0; i < 8 ; i++){\\n            for(int j = 0; j < 8 ; j++){\\n                if(board[i][j] == \\'R\\'){\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return numRookCaptures(board,row,col,\\'u\\')+numRookCaptures(board,row,col,\\'l\\')+numRookCaptures(board,row,col,\\'r\\')+numRookCaptures(board,row,col,\\'d\\');\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int numRookCaptures(char[][] board, int row, int col, char direction){\\n        if(row >= 8 || col >= 8 || row < 0 || col < 0) return 0;\\n        \\n        if(board[row][col] != \\'.\\' && board[row][col] != \\'R\\'){\\n            if(board[row][col] == \\'p\\')\\n                return 1;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 243345,
                "title": "simple-ac-python-solution-16-ms-beats-100",
                "content": "Uncomment the commented lines for clarity / understanding testcases\\n\\n```\\n\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def findWhiteRook(board):\\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    if board[i][j] == \\'R\\':\\n                        return (i,j)\\n            return -1\\n        rr, rc = findWhiteRook(board)\\n        kills = 0\\n        # print(\"White Rook at \", rr, rc)\\n\\t\\t\\n\\t\\t# west\\n        for ic in range(rc-1,-1,-1):\\n            if board[rr][ic] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(rr,ic))\\n                kills += 1\\n                break\\n            elif board[rr][ic] == \\'B\\' or board[rr][ic] == \\'P\\':\\n                break\\n        \\n\\t\\t# east\\n        for ic in range(rc+1,len(board[0])):\\n            if board[rr][ic] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(rr,ic))\\n                kills += 1\\n                break\\n            elif board[rr][ic] == \\'B\\' or board[rr][ic] == \\'P\\':\\n                break\\n        \\n\\t\\t# south\\n        for ir in range(rr+1,len(board)):\\n            if board[ir][rc] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(ir,rc))\\n                kills += 1\\n                break\\n            elif board[ir][rc] == \\'B\\' or board[ir][rc] == \\'P\\':\\n                break\\n        \\n        # north\\n        for ir in range(rr-1,-1,-1):\\n            if board[ir][rc] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(ir,rc))\\n                kills += 1\\n                break\\n            elif board[ir][rc] == \\'B\\' or board[ir][rc] == \\'P\\':\\n                break\\n        return kills\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        def findWhiteRook(board):\\n            for i in range(len(board)):\\n                for j in range(len(board[0])):\\n                    if board[i][j] == \\'R\\':\\n                        return (i,j)\\n            return -1\\n        rr, rc = findWhiteRook(board)\\n        kills = 0\\n        # print(\"White Rook at \", rr, rc)\\n\\t\\t\\n\\t\\t# west\\n        for ic in range(rc-1,-1,-1):\\n            if board[rr][ic] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(rr,ic))\\n                kills += 1\\n                break\\n            elif board[rr][ic] == \\'B\\' or board[rr][ic] == \\'P\\':\\n                break\\n        \\n\\t\\t# east\\n        for ic in range(rc+1,len(board[0])):\\n            if board[rr][ic] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(rr,ic))\\n                kills += 1\\n                break\\n            elif board[rr][ic] == \\'B\\' or board[rr][ic] == \\'P\\':\\n                break\\n        \\n\\t\\t# south\\n        for ir in range(rr+1,len(board)):\\n            if board[ir][rc] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(ir,rc))\\n                kills += 1\\n                break\\n            elif board[ir][rc] == \\'B\\' or board[ir][rc] == \\'P\\':\\n                break\\n        \\n        # north\\n        for ir in range(rr-1,-1,-1):\\n            if board[ir][rc] == \\'p\\':\\n                # print(\"Can kill pawn at {},{}\".format(ir,rc))\\n                kills += 1\\n                break\\n            elif board[ir][rc] == \\'B\\' or board[ir][rc] == \\'P\\':\\n                break\\n        return kills\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 243184,
                "title": "simple-dfs-python",
                "content": "Basically it\\'s a DFS problem.\\nThere are 3 conditions: \\n1. When meet the bishops, we need to stop and can\\'t go further\\n2.  When meet the pawn, count ++ and then stop;\\n3.  Else we just go straight with the same direction! \\n\\n\\n```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(row, col, d):\\n            if row < 0 or row >= 8 or col < 0 or col >= 8:\\n                return \\n            if board[row][col] == \"p\":\\n                self.count += 1\\n                return \\n            if board[row][col] == \"B\":\\n                return\\n           \\n            dfs(row + d[0], col + d[1], d)\\n\\n            \\n        self.count = 0\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \"R\":\\n                    dfs(i, j, (1, 0))\\n                    dfs(i, j,  (-1, 0))\\n                    dfs(i, j,  (0, 1))\\n                    dfs(i, j,  (0, -1))\\n        \\n        return self.count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRookCaptures(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def dfs(row, col, d):\\n            if row < 0 or row >= 8 or col < 0 or col >= 8:\\n                return \\n            if board[row][col] == \"p\":\\n                self.count += 1\\n                return \\n            if board[row][col] == \"B\":\\n                return\\n           \\n            dfs(row + d[0], col + d[1], d)\\n\\n            \\n        self.count = 0\\n        for i in range(8):\\n            for j in range(8):\\n                if board[i][j] == \"R\":\\n                    dfs(i, j, (1, 0))\\n                    dfs(i, j,  (-1, 0))\\n                    dfs(i, j,  (0, 1))\\n                    dfs(i, j,  (0, -1))\\n        \\n        return self.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242989,
                "title": "python-easy-if-else-solution",
                "content": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        p1, p2 = -1, -1\\n        count = 0\\n        for i in range(0, 8):\\n            for j in range(0, 8):\\n                if board[i][j] == \\'R\\':\\n                    p1 = i\\n                    p2 = j\\n        # print(p1, p2)\\n        for i in range(p2, 0, -1):\\n            if board[p1][i] == \\'p\\':\\n                count += 1\\n                break\\n            if board[p1][i] == \\'B\\':\\n                break\\n            \\n        for i in range(p2, 8):\\n            if board[p1][i] == \\'p\\':\\n                count += 1\\n                break\\n            if board[p1][i] == \\'B\\':\\n                break\\n        \\n        for j in range(p1, 0, -1):\\n            if board[j][p2] == \\'p\\':\\n                count += 1\\n                break\\n            if board[j][p2] == \\'B\\':\\n                break\\n             \\n        for j in range(p1, 8):\\n            if board[j][p2] == \\'p\\':\\n                count += 1\\n                break\\n            if board[j][p2] == \\'B\\':\\n                break\\n        return count\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef numRookCaptures(self, board: List[List[str]]) -> int:\\n        p1, p2 = -1, -1\\n        count = 0\\n        for i in range(0, 8):\\n            for j in range(0, 8):\\n                if board[i][j] == \\'R\\':\\n                    p1 = i\\n                    p2 = j\\n        # print(p1, p2)\\n        for i in range(p2, 0, -1):\\n            if board[p1][i] == \\'p\\':\\n                count += 1\\n                break\\n            if board[p1][i] == \\'B\\':\\n                break\\n            \\n        for i in range(p2, 8):\\n            if board[p1][i] == \\'p\\':\\n                count += 1\\n                break\\n            if board[p1][i] == \\'B\\':\\n                break\\n        \\n        for j in range(p1, 0, -1):\\n            if board[j][p2] == \\'p\\':\\n                count += 1\\n                break\\n            if board[j][p2] == \\'B\\':\\n                break\\n             \\n        for j in range(p1, 8):\\n            if board[j][p2] == \\'p\\':\\n                count += 1\\n                break\\n            if board[j][p2] == \\'B\\':\\n                break\\n        return count\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242906,
                "title": "my-straightfoward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n\\t\\tint x = 0, y = 0, res = 0;\\n\\t\\tfor (int i = 0; i < 8; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 8; ++j) {\\n\\t\\t\\t\\tif (board[i][j] == \\'R\\') {\\n\\t\\t\\t\\t\\tx = i; y = j; break;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int j = y; j >= 0; --j) {\\n\\t\\t\\tif (board[x][j] == \\'B\\') break;\\n\\t\\t\\tif (board[x][j] == \\'p\\') {++res; break;} \\n\\t\\t}\\n\\t\\tfor (int j = y; j < 8; ++j) {\\n\\t\\t\\tif (board[x][j] == \\'B\\') break;\\n\\t\\t\\tif (board[x][j] == \\'p\\') {++res; break;}  \\n\\t\\t}\\n\\t\\tfor (int i = x; i >= 0; --i) {\\n\\t\\t\\tif (board[i][y] == \\'B\\') break;\\n\\t\\t\\tif (board[i][y] == \\'p\\') {++res; break;} \\n\\t\\t}\\n\\t\\tfor (int i = x; i < 8; ++i) {\\n\\t\\t\\tif (board[i][y] == \\'B\\') break;\\n\\t\\t\\tif (board[i][y] == \\'p\\') {++res; break;} \\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n\\t\\tint x = 0, y = 0, res = 0;\\n\\t\\tfor (int i = 0; i < 8; ++i) {\\n\\t\\t\\tfor (int j = 0; j < 8; ++j) {\\n\\t\\t\\t\\tif (board[i][j] == \\'R\\') {\\n\\t\\t\\t\\t\\tx = i; y = j; break;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4107493,
                "title": "recursive-solution-beats-90-memory-75-runtime",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind Rook and then go to to every direction until:\\n- Surpased a border of the board\\n- Found a white bishop\\n- Found a black pawn (then sum one to count)\\n\\n# Code\\n```\\nclass Solution:\\n    def dfs(self, board, d, current) -> int:\\n        piece = board[current[0]][current[1]]\\n        if(piece == \\'B\\'):\\n            return 0\\n        elif(piece == \\'p\\'):\\n            return 1\\n\\n        if d == \\'r\\':\\n            if(current[0] + 1 < len(board)):\\n                return self.dfs(board, d, (current[0]+1, current[1]))\\n        if d == \\'l\\':\\n            if(current[0] - 1 >= 0):\\n                return self.dfs(board, d, (current[0]-1, current[1]))\\n        if d == \\'u\\':\\n            if(current[1] - 1 >= 0):\\n                return self.dfs(board, d, (current[0], current[1]-1))\\n        if d == \\'d\\':\\n            if(current[1] + 1 < len(board)):\\n                return self.dfs(board, d, (current[0], current[1]+1))\\n        \\n        return 0\\n\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        # find rook\\n        n = len(board)\\n\\n        rook = ()\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \\'R\\'):\\n                    rook = (i,j)\\n                    break\\n\\n        count = 0\\n\\n        # up\\n        count += self.dfs(board, \\'u\\', rook)\\n        count += self.dfs(board, \\'d\\', rook)\\n        count += self.dfs(board, \\'l\\', rook)\\n        count += self.dfs(board, \\'r\\', rook)\\n\\n        return count\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, board, d, current) -> int:\\n        piece = board[current[0]][current[1]]\\n        if(piece == \\'B\\'):\\n            return 0\\n        elif(piece == \\'p\\'):\\n            return 1\\n\\n        if d == \\'r\\':\\n            if(current[0] + 1 < len(board)):\\n                return self.dfs(board, d, (current[0]+1, current[1]))\\n        if d == \\'l\\':\\n            if(current[0] - 1 >= 0):\\n                return self.dfs(board, d, (current[0]-1, current[1]))\\n        if d == \\'u\\':\\n            if(current[1] - 1 >= 0):\\n                return self.dfs(board, d, (current[0], current[1]-1))\\n        if d == \\'d\\':\\n            if(current[1] + 1 < len(board)):\\n                return self.dfs(board, d, (current[0], current[1]+1))\\n        \\n        return 0\\n\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        # find rook\\n        n = len(board)\\n\\n        rook = ()\\n        for i in range(len(board)):\\n            for j in range(len(board[i])):\\n                if(board[i][j] == \\'R\\'):\\n                    rook = (i,j)\\n                    break\\n\\n        count = 0\\n\\n        # up\\n        count += self.dfs(board, \\'u\\', rook)\\n        count += self.dfs(board, \\'d\\', rook)\\n        count += self.dfs(board, \\'l\\', rook)\\n        count += self.dfs(board, \\'r\\', rook)\\n\\n        return count\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091387,
                "title": "fast-solution",
                "content": "# Code\\n```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    const getPos = () => {\\n        for(let i = 0; i < 8; i++) {\\n            for(let j = 0; j < 8; j++) {\\n                if(board[i][j] == \\'R\\') return [i, j]\\n            }\\n        }\\n    }\\n\\n    let [row, col] = getPos()\\n    let i = 0\\n    let capture = 0\\n\\n    while(row + i < 8) {\\n        if(board[row + i][col] == \\'B\\') {break}\\n        if(board[row + i][col] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(row - i >= 0) {\\n        if(board[row - i][col] == \\'B\\') {break}\\n        if(board[row - i][col] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(col - i >= 0) {\\n        if(board[row][col - i] == \\'B\\') {break}\\n        if(board[row][col - i] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(col + i < 8) {\\n        if(board[row][col + i] == \\'B\\') {break}\\n        if(board[row][col + i] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    return capture\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n */\\nvar numRookCaptures = function(board) {\\n    const getPos = () => {\\n        for(let i = 0; i < 8; i++) {\\n            for(let j = 0; j < 8; j++) {\\n                if(board[i][j] == \\'R\\') return [i, j]\\n            }\\n        }\\n    }\\n\\n    let [row, col] = getPos()\\n    let i = 0\\n    let capture = 0\\n\\n    while(row + i < 8) {\\n        if(board[row + i][col] == \\'B\\') {break}\\n        if(board[row + i][col] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(row - i >= 0) {\\n        if(board[row - i][col] == \\'B\\') {break}\\n        if(board[row - i][col] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(col - i >= 0) {\\n        if(board[row][col - i] == \\'B\\') {break}\\n        if(board[row][col - i] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    i = 0\\n    while(col + i < 8) {\\n        if(board[row][col + i] == \\'B\\') {break}\\n        if(board[row][col + i] == \\'p\\') {capture++; break;}\\n        i++\\n    }\\n\\n    return capture\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049402,
                "title": "c-kotlin-easy-to-understand-solution-beats-runtime-100-100-memory-91-57",
                "content": "# C#\\n![image.png](https://assets.leetcode.com/users/images/eb992053-9f8b-4858-a61c-a97f39d90b28_1694813891.915836.png)\\n\\n\\n# Kotlin\\n![image.png](https://assets.leetcode.com/users/images/2d300fc0-a507-49d5-8918-e50b95d13303_1694813888.6574936.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```C# []\\npublic class Solution {\\n    public int NumRookCaptures(char[][] board) {\\n        int i;\\n        int j = 0;\\n        bool foodRook = false;\\n        for (i = 0; i < 8; i++)\\n        {\\n            for (j = 0; j < 8; j++)\\n            {\\n                if (board[i][j] == \\'R\\')\\n                {\\n                    foodRook = true;\\n                    break;\\n                }\\n            }\\n\\n            if (foodRook)\\n            {\\n                break;\\n            }\\n        }\\n\\n        int counter = 0;\\n        int ii = i - 1;\\n        while (ii >= 0)\\n        {\\n            if (board[ii][j] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[ii][j] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            ii--;\\n        }\\n\\n        ii = i + 1;\\n        while (ii < 8)\\n        {\\n            if (board[ii][j] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[ii][j] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            ii++;\\n        }\\n\\n        int jj = j - 1;\\n        while (jj >= 0)\\n        {\\n            if (board[i][jj] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[i][jj] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            jj--;\\n        }\\n\\n        jj = j + 1;\\n        while (jj < 8)\\n        {\\n            if (board[i][jj] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[i][jj] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            jj++;\\n        }\\n\\n\\n        return counter;\\n    }\\n}\\n```\\n```Kotlin []\\nclass Solution {\\n    fun numRookCaptures(board: Array<CharArray>): Int {\\n        var rookRow = 0\\n        var rookColumn = 0\\n        var foundRook = false\\n        for (i in 0..<8) {\\n            for (j in 0..<8) {\\n                if (board[i][j] == \\'R\\') {\\n                    rookColumn = j\\n                    rookRow = i\\n                    foundRook = true\\n                }\\n            }\\n\\n            if (foundRook) {\\n                break\\n            }\\n        }\\n\\n        var counter = 0\\n        var row = rookRow - 1\\n        while (row >= 0) {\\n            if (board[row][rookColumn] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[row][rookColumn] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            row--;\\n        }\\n\\n        row = rookRow + 1\\n        while (row < 8){\\n            if (board[row][rookColumn] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[row][rookColumn] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            row++;\\n        }\\n\\n        var column = rookColumn - 1\\n        while (column >= 0) {\\n            if (board[rookRow][column] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[rookRow][column] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            column--;\\n        }\\n\\n        column = rookColumn + 1\\n        while (column < 8){\\n            if (board[rookRow][column] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[rookRow][column] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            column++;\\n        }\\n\\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Kotlin",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```C# []\\npublic class Solution {\\n    public int NumRookCaptures(char[][] board) {\\n        int i;\\n        int j = 0;\\n        bool foodRook = false;\\n        for (i = 0; i < 8; i++)\\n        {\\n            for (j = 0; j < 8; j++)\\n            {\\n                if (board[i][j] == \\'R\\')\\n                {\\n                    foodRook = true;\\n                    break;\\n                }\\n            }\\n\\n            if (foodRook)\\n            {\\n                break;\\n            }\\n        }\\n\\n        int counter = 0;\\n        int ii = i - 1;\\n        while (ii >= 0)\\n        {\\n            if (board[ii][j] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[ii][j] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            ii--;\\n        }\\n\\n        ii = i + 1;\\n        while (ii < 8)\\n        {\\n            if (board[ii][j] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[ii][j] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            ii++;\\n        }\\n\\n        int jj = j - 1;\\n        while (jj >= 0)\\n        {\\n            if (board[i][jj] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[i][jj] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            jj--;\\n        }\\n\\n        jj = j + 1;\\n        while (jj < 8)\\n        {\\n            if (board[i][jj] == \\'B\\')\\n            {\\n                break;\\n            }\\n\\n            if (board[i][jj] == \\'p\\')\\n            {\\n                counter++;\\n                break;\\n            }\\n\\n            jj++;\\n        }\\n\\n\\n        return counter;\\n    }\\n}\\n```\n```Kotlin []\\nclass Solution {\\n    fun numRookCaptures(board: Array<CharArray>): Int {\\n        var rookRow = 0\\n        var rookColumn = 0\\n        var foundRook = false\\n        for (i in 0..<8) {\\n            for (j in 0..<8) {\\n                if (board[i][j] == \\'R\\') {\\n                    rookColumn = j\\n                    rookRow = i\\n                    foundRook = true\\n                }\\n            }\\n\\n            if (foundRook) {\\n                break\\n            }\\n        }\\n\\n        var counter = 0\\n        var row = rookRow - 1\\n        while (row >= 0) {\\n            if (board[row][rookColumn] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[row][rookColumn] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            row--;\\n        }\\n\\n        row = rookRow + 1\\n        while (row < 8){\\n            if (board[row][rookColumn] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[row][rookColumn] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            row++;\\n        }\\n\\n        var column = rookColumn - 1\\n        while (column >= 0) {\\n            if (board[rookRow][column] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[rookRow][column] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            column--;\\n        }\\n\\n        column = rookColumn + 1\\n        while (column < 8){\\n            if (board[rookRow][column] == \\'B\\') {\\n                break\\n            }\\n\\n            if (board[rookRow][column] == \\'p\\') {\\n                counter++;\\n                break;\\n            }\\n\\n            column++;\\n        }\\n\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044925,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int m = board.size(), n = board[0].size();\\n        int rx, ry;\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rx = i, ry = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int j = ry + 1 ; j < 8 ; j++) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n        for(int j = ry - 1 ; j >= 0 ; j--) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n \\n        for(int i = rx + 1 ; i < 8 ; i++) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n\\n        for(int i = rx - 1 ; i >= 0 ; i--) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n    \\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        int m = board.size(), n = board[0].size();\\n        int rx, ry;\\n        for(int i = 0 ; i < 8 ; i++) {\\n            for(int j = 0 ; j < 8 ; j++) {\\n                if(board[i][j] == \\'R\\') {\\n                    rx = i, ry = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int j = ry + 1 ; j < 8 ; j++) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n        for(int j = ry - 1 ; j >= 0 ; j--) {\\n            if(board[rx][j] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[rx][j] == \\'B\\')\\n                break;\\n        }\\n \\n        for(int i = rx + 1 ; i < 8 ; i++) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n\\n        for(int i = rx - 1 ; i >= 0 ; i--) {\\n            if(board[i][ry] == \\'p\\') {\\n                count++;\\n                break;\\n            }\\n            else if(board[i][ry] == \\'B\\')\\n                break;\\n        }\\n    \\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029133,
                "title": "beginner-s-approach-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere in this appraoch we first find the rook.After finding the rook\\nwe move upward,downward,left and right.If find a bishop we break,if we find a pawn we increase the count then break.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int & count,int i,int j,vector<vector<char>> board){\\n        //up\\n        for(int k=i;k>=0;k--){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            //found the bishop break\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //down\\n        for(int k=i;k<board.size();k++){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        //right\\n        for(int k=j;k<board[i].size();k++){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //left\\n        for(int k=j;k>=0;k--){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        //counting the number of pawns\\n        int count=0;\\n\\n        //Finding the location of rook\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    solve(count,i,j,board);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int & count,int i,int j,vector<vector<char>> board){\\n        //up\\n        for(int k=i;k>=0;k--){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            //found the bishop break\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //down\\n        for(int k=i;k<board.size();k++){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        //right\\n        for(int k=j;k<board[i].size();k++){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //left\\n        for(int k=j;k>=0;k--){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        //counting the number of pawns\\n        int count=0;\\n\\n        //Finding the location of rook\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    solve(count,i,j,board);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029132,
                "title": "beginner-s-approach-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere in this appraoch we first find the rook.After finding the rook\\nwe move upward,downward,left and right.If find a bishop we break,if we find a pawn we increase the count then break.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int & count,int i,int j,vector<vector<char>> board){\\n        //up\\n        for(int k=i;k>=0;k--){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            //found the bishop break\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //down\\n        for(int k=i;k<board.size();k++){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        //right\\n        for(int k=j;k<board[i].size();k++){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //left\\n        for(int k=j;k>=0;k--){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        //counting the number of pawns\\n        int count=0;\\n\\n        //Finding the location of rook\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    solve(count,i,j,board);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int & count,int i,int j,vector<vector<char>> board){\\n        //up\\n        for(int k=i;k>=0;k--){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            //found the bishop break\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //down\\n        for(int k=i;k<board.size();k++){\\n            if(board[k][j]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[k][j]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        //right\\n        for(int k=j;k<board[i].size();k++){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n\\n        //left\\n        for(int k=j;k>=0;k--){\\n            if(board[i][k]==\\'p\\'){\\n                count++;\\n                break;\\n            }\\n            if(board[i][k]==\\'B\\'){\\n                break;\\n            }\\n        }\\n    }\\n    int numRookCaptures(vector<vector<char>>& board) {\\n        //counting the number of pawns\\n        int count=0;\\n\\n        //Finding the location of rook\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                if(board[i][j]==\\'R\\'){\\n                    solve(count,i,j,board);\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026393,
                "title": "0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int result = 0;\\n        int[] rockIndex = new int[2];\\n        // the rock can have max 4 capture or min zero cap\\n        int nothDis = 9, southDis = 9, eastDis = 9, westDis = 9;\\n        boolean[] dir = new boolean[4];\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rockIndex[0] = i;\\n                    rockIndex[1] = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //System.out.println(Arrays.toString(rockIndex));\\n\\n        // first horisontal\\n\\n        // west\\n        for (int i = 0; i < rockIndex[1]; i++) {\\n            if (board[rockIndex[0]][i] == \\'p\\') {\\n                westDis = rockIndex[1] - i;\\n                dir[0] = true;\\n            }\\n            if (board[rockIndex[0]][i] == \\'B\\' && westDis > rockIndex[1] - i) {\\n                dir[0] = false;\\n            }\\n        }\\n\\n        // east\\n        for (int i = 7; i > rockIndex[1]; i--) {\\n            if (board[rockIndex[0]][i] == \\'p\\') {\\n                eastDis = i - rockIndex[1];\\n                dir[1] = true;\\n            }\\n            if (board[rockIndex[0]][i] == \\'B\\' && eastDis > i - rockIndex[1]) {\\n                dir[1] = false;\\n            }\\n        }\\n\\n        // vertical\\n\\n        // north\\n        for (int i = 0; i < rockIndex[0]; i++) {\\n            if (board[i][rockIndex[1]] == \\'p\\') {\\n                nothDis = rockIndex[0] - i;\\n                dir[2] = true;\\n            }\\n            if (board[i][rockIndex[1]] == \\'B\\' && nothDis > rockIndex[0] - i) {\\n                dir[2] = false;\\n            }\\n        }\\n\\n        // south\\n        for (int i = 7; i > rockIndex[0]; i--) {\\n            if (board[i][rockIndex[1]] == \\'p\\') {\\n                southDis = i - rockIndex[0];\\n                dir[3] = true;\\n            }\\n            if (board[i][rockIndex[1]] == \\'B\\' && southDis > i - rockIndex[0]) {\\n                dir[3] = false;\\n            }\\n        }\\n\\n        //System.out.println(Arrays.toString(dir));\\n\\n        for (boolean b : dir) {\\n            if (b) {\\n                result++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        int result = 0;\\n        int[] rockIndex = new int[2];\\n        // the rock can have max 4 capture or min zero cap\\n        int nothDis = 9, southDis = 9, eastDis = 9, westDis = 9;\\n        boolean[] dir = new boolean[4];\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[i].length; j++) {\\n                if (board[i][j] == \\'R\\') {\\n                    rockIndex[0] = i;\\n                    rockIndex[1] = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //System.out.println(Arrays.toString(rockIndex));\\n\\n        // first horisontal\\n\\n        // west\\n        for (int i = 0; i < rockIndex[1]; i++) {\\n            if (board[rockIndex[0]][i] == \\'p\\') {\\n                westDis = rockIndex[1] - i;\\n                dir[0] = true;\\n            }\\n            if (board[rockIndex[0]][i] == \\'B\\' && westDis > rockIndex[1] - i) {\\n                dir[0] = false;\\n            }\\n        }\\n\\n        // east\\n        for (int i = 7; i > rockIndex[1]; i--) {\\n            if (board[rockIndex[0]][i] == \\'p\\') {\\n                eastDis = i - rockIndex[1];\\n                dir[1] = true;\\n            }\\n            if (board[rockIndex[0]][i] == \\'B\\' && eastDis > i - rockIndex[1]) {\\n                dir[1] = false;\\n            }\\n        }\\n\\n        // vertical\\n\\n        // north\\n        for (int i = 0; i < rockIndex[0]; i++) {\\n            if (board[i][rockIndex[1]] == \\'p\\') {\\n                nothDis = rockIndex[0] - i;\\n                dir[2] = true;\\n            }\\n            if (board[i][rockIndex[1]] == \\'B\\' && nothDis > rockIndex[0] - i) {\\n                dir[2] = false;\\n            }\\n        }\\n\\n        // south\\n        for (int i = 7; i > rockIndex[0]; i--) {\\n            if (board[i][rockIndex[1]] == \\'p\\') {\\n                southDis = i - rockIndex[0];\\n                dir[3] = true;\\n            }\\n            if (board[i][rockIndex[1]] == \\'B\\' && southDis > i - rockIndex[0]) {\\n                dir[3] = false;\\n            }\\n        }\\n\\n        //System.out.println(Arrays.toString(dir));\\n\\n        for (boolean b : dir) {\\n            if (b) {\\n                result++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024827,
                "title": "easy-to-understand-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public static int numRookCaptures(char[][] board) {\\n\\t\\t int ans = 0;\\n\\t\\t for (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board.length; j++) {\\n\\t\\t\\t\\tchar val = board[i][j];\\n\\t\\t\\t\\tif(val==\\'R\\') {\\n\\t\\t\\t\\t\\tans = check(board,i,j);\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;   \\n\\t    }\\n\\n\\tpublic static int check(char[][] arr, int ii, int jj) {\\n\\t\\tint count = 0;\\n\\t\\t// bottom\\n\\t\\tint i1 = ii;\\n\\t\\tint j1 = jj;\\n\\t\\twhile(arr.length-1>i1) {\\n\\t\\t\\tif(arr[i1+1][j1]==\\'P\\' || arr[i1+1][j1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i1+1][j1]==\\'B\\' || arr[i1+1][j1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// top\\n\\t\\tint i3 = ii;\\n\\t\\tint j3 = jj;\\n\\t\\twhile(0<i3) {\\n\\t\\t\\tif(arr[i3-1][j3]==\\'P\\' || arr[i3-1][j3]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i3-1][j3]==\\'B\\' || arr[i3-1][j3]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\ti3--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// left\\n\\t\\tint i2 = ii;\\n\\t\\tint j2 = jj;\\n\\t\\twhile(0<j2) {\\n\\t\\t\\tif(arr[i2][j2-1]==\\'P\\' || arr[i2][j2-1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i2][j2-1]==\\'B\\' || arr[i2][j2-1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tj2--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// right\\n\\t\\tint i4 = ii;\\n\\t\\tint j4 = jj;\\n\\t\\twhile(arr.length-1>j4) {\\n\\t\\t\\tif(arr[i4][j4+1]==\\'P\\' || arr[i4][j4+1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i4][j4+1]==\\'B\\' || arr[i4][j4+1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tj4++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static int numRookCaptures(char[][] board) {\\n\\t\\t int ans = 0;\\n\\t\\t for (int i = 0; i < board.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < board.length; j++) {\\n\\t\\t\\t\\tchar val = board[i][j];\\n\\t\\t\\t\\tif(val==\\'R\\') {\\n\\t\\t\\t\\t\\tans = check(board,i,j);\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;   \\n\\t    }\\n\\n\\tpublic static int check(char[][] arr, int ii, int jj) {\\n\\t\\tint count = 0;\\n\\t\\t// bottom\\n\\t\\tint i1 = ii;\\n\\t\\tint j1 = jj;\\n\\t\\twhile(arr.length-1>i1) {\\n\\t\\t\\tif(arr[i1+1][j1]==\\'P\\' || arr[i1+1][j1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i1+1][j1]==\\'B\\' || arr[i1+1][j1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// top\\n\\t\\tint i3 = ii;\\n\\t\\tint j3 = jj;\\n\\t\\twhile(0<i3) {\\n\\t\\t\\tif(arr[i3-1][j3]==\\'P\\' || arr[i3-1][j3]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i3-1][j3]==\\'B\\' || arr[i3-1][j3]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\ti3--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// left\\n\\t\\tint i2 = ii;\\n\\t\\tint j2 = jj;\\n\\t\\twhile(0<j2) {\\n\\t\\t\\tif(arr[i2][j2-1]==\\'P\\' || arr[i2][j2-1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i2][j2-1]==\\'B\\' || arr[i2][j2-1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tj2--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// right\\n\\t\\tint i4 = ii;\\n\\t\\tint j4 = jj;\\n\\t\\twhile(arr.length-1>j4) {\\n\\t\\t\\tif(arr[i4][j4+1]==\\'P\\' || arr[i4][j4+1]==\\'p\\') {\\n\\t\\t\\t\\tcount+=1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else if(arr[i4][j4+1]==\\'B\\' || arr[i4][j4+1]==\\'b\\') {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tj4++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014788,
                "title": "easy-simple-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        b=[]\\n        for i in board:\\n            if \"R\" in i:\\n                a=i\\n                k=i.index(\\'R\\')\\n        for i in board:\\n            b.append(i[k])\\n        x=a.index(\\'R\\')\\n        y=a.index(\\'R\\')\\n        l=b.index(\\'R\\')\\n        m=b.index(\\'R\\')\\n        c=0\\n        while x<len(a):\\n            if a[x]==\"p\":\\n                c+=1\\n                break\\n            if  a[x]==\"B\":\\n                break\\n            x+=1\\n        while y>=0:\\n            if a[y]==\"p\":\\n                c+=1\\n                break\\n            if  a[y]==\"B\":\\n                break\\n            y-=1\\n        while l<len(b):\\n            if b[l]==\"p\":\\n                c+=1\\n                break\\n            if  b[l]==\"B\":\\n                break\\n            l+=1\\n        while m>=0:\\n            if b[m]==\"p\":\\n                c+=1\\n                break\\n            if  b[m]==\"B\":\\n                break\\n            m-=1\\n        return c\\n        \\n      \\n      \\n        \\n       \\n\\n        \\n\\n       \\n\\n                   \\n        \\n               \\n        \\n         \\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        b=[]\\n        for i in board:\\n            if \"R\" in i:\\n                a=i\\n                k=i.index(\\'R\\')\\n        for i in board:\\n            b.append(i[k])\\n        x=a.index(\\'R\\')\\n        y=a.index(\\'R\\')\\n        l=b.index(\\'R\\')\\n        m=b.index(\\'R\\')\\n        c=0\\n        while x<len(a):\\n            if a[x]==\"p\":\\n                c+=1\\n                break\\n            if  a[x]==\"B\":\\n                break\\n            x+=1\\n        while y>=0:\\n            if a[y]==\"p\":\\n                c+=1\\n                break\\n            if  a[y]==\"B\":\\n                break\\n            y-=1\\n        while l<len(b):\\n            if b[l]==\"p\":\\n                c+=1\\n                break\\n            if  b[l]==\"B\":\\n                break\\n            l+=1\\n        while m>=0:\\n            if b[m]==\"p\":\\n                c+=1\\n                break\\n            if  b[m]==\"B\":\\n                break\\n            m-=1\\n        return c\\n        \\n      \\n      \\n        \\n       \\n\\n        \\n\\n       \\n\\n                   \\n        \\n               \\n        \\n         \\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005696,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    private const char Pawn = \\'p\\';\\n\\n    public int NumRookCaptures(char[][] board)\\n    {\\n        var (x, y) = findRook(board);\\n        var count = 0;\\n\\n        for (var i = x - 1; i >= 0; i--)\\n        {\\n            if (board[i][y] == \\'.\\') continue;\\n\\n            count += board[i][y] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = x + 1; i < board.Length; i++)\\n        {\\n            if (board[i][y] == \\'.\\') continue;\\n            \\n            count += board[i][y] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = y - 1; i >= 0; i--)\\n        {\\n            if (board[x][i] == \\'.\\') continue;\\n            \\n            count += board[x][i] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = y + 1; i < board[0].Length; i++)\\n        {\\n            if (board[x][i] == \\'.\\') continue;\\n            \\n            count += board[x][i] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        return count;\\n    }\\n\\n    private static (int x, int y) findRook(char[][] board)\\n    {\\n        const char rook = \\'R\\';\\n\\n        for (var i = 0; i < board.Length; i++)\\n        {\\n            for (var j = 0; j < board[0].Length; j++)\\n            {\\n                if (board[i][j] == rook)\\n                {\\n                    return (i, j);\\n                }\\n            }\\n        }\\n\\n        return (0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private const char Pawn = \\'p\\';\\n\\n    public int NumRookCaptures(char[][] board)\\n    {\\n        var (x, y) = findRook(board);\\n        var count = 0;\\n\\n        for (var i = x - 1; i >= 0; i--)\\n        {\\n            if (board[i][y] == \\'.\\') continue;\\n\\n            count += board[i][y] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = x + 1; i < board.Length; i++)\\n        {\\n            if (board[i][y] == \\'.\\') continue;\\n            \\n            count += board[i][y] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = y - 1; i >= 0; i--)\\n        {\\n            if (board[x][i] == \\'.\\') continue;\\n            \\n            count += board[x][i] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        for (var i = y + 1; i < board[0].Length; i++)\\n        {\\n            if (board[x][i] == \\'.\\') continue;\\n            \\n            count += board[x][i] == Pawn ? 1 : 0; \\n            break;\\n        }\\n\\n        return count;\\n    }\\n\\n    private static (int x, int y) findRook(char[][] board)\\n    {\\n        const char rook = \\'R\\';\\n\\n        for (var i = 0; i < board.Length; i++)\\n        {\\n            for (var j = 0; j < board[0].Length; j++)\\n            {\\n                if (board[i][j] == rook)\\n                {\\n                    return (i, j);\\n                }\\n            }\\n        }\\n\\n        return (0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001077,
                "title": "beats-100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    return ans(board,i,j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    public int ans(char[][] mat,int r,int c){\\n        int c1=0;\\n        for(int i=r+1;i<mat.length;i++){\\n            if(mat[i][c]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            if(mat[i][c]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=c+1;i<mat[0].length;i++){\\n            if(mat[r][i]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=c-1;i>=0;i--){\\n            if(mat[r][i]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return c1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRookCaptures(char[][] board) {\\n        for(int i=0;i<8;i++){\\n            for(int j=0;j<8;j++){\\n                if(board[i][j]==\\'R\\'){\\n                    return ans(board,i,j);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    public int ans(char[][] mat,int r,int c){\\n        int c1=0;\\n        for(int i=r+1;i<mat.length;i++){\\n            if(mat[i][c]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=r-1;i>=0;i--){\\n            if(mat[i][c]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[i][c]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=c+1;i<mat[0].length;i++){\\n            if(mat[r][i]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        for(int i=c-1;i>=0;i--){\\n            if(mat[r][i]==\\'p\\'){\\n                c1++;\\n                break;\\n            }else if(mat[r][i]==\\'B\\'){\\n                break;\\n            }\\n        }\\n        return c1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999771,
                "title": "easy-solution-beating-75-96-in-run-time",
                "content": "\\n\\n# Code\\n```\\n\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n*/\\n\\nvar numRookCaptures = function(board) {\\n\\n    let m = board.length;\\n    let n = board[0].length;\\n    \\n    let capture = 0;\\n\\n    for (let i = 0; i < m; i++){\\n        for (let j = 0; j < n; j++){\\n\\n            // finding the rook\\n            if (board[i][j] === \\'R\\'){\\n\\n                let ri = i;\\n                let rj = j;\\n\\n                // right \\n                for(let j = rj; j < n; j++){\\n                    if (board[ri][j] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[ri][j] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n                \\n                // left \\n                for (let j = rj; j >= 0; j--){\\n                        if (board[ri][j] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[ri][j] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n\\n                // bottom \\n                for (let i = ri; i < m; i++){\\n                    if (board[i][rj] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[i][rj] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n\\n                // up\\n                for (let i = ri; i >= 0; i--){\\n                        if (board[i][rj] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[i][rj] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return capture;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {character[][]} board\\n * @return {number}\\n*/\\n\\nvar numRookCaptures = function(board) {\\n\\n    let m = board.length;\\n    let n = board[0].length;\\n    \\n    let capture = 0;\\n\\n    for (let i = 0; i < m; i++){\\n        for (let j = 0; j < n; j++){\\n\\n            // finding the rook\\n            if (board[i][j] === \\'R\\'){\\n\\n                let ri = i;\\n                let rj = j;\\n\\n                // right \\n                for(let j = rj; j < n; j++){\\n                    if (board[ri][j] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[ri][j] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n                \\n                // left \\n                for (let j = rj; j >= 0; j--){\\n                        if (board[ri][j] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[ri][j] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n\\n                // bottom \\n                for (let i = ri; i < m; i++){\\n                    if (board[i][rj] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[i][rj] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n\\n                // up\\n                for (let i = ri; i >= 0; i--){\\n                        if (board[i][rj] === \\'B\\'){\\n                        break;\\n                    }\\n                    else if (board[i][rj] === \\'p\\'){\\n                        capture++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return capture;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985107,
                "title": "rust-python-solutions",
                "content": "# Code\\n```python []\\nfrom typing import Literal, Type\\n\\nMOVE: Type[str] = Literal[\\'up\\', \\'down\\', \\'left\\', \\'right\\']\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def move(board: list[list[str]], moves: range, pos: int, to_move: MOVE) -> int:\\n        count = 0\\n        for move in moves:\\n            if to_move == \\'up\\' or to_move == \\'down\\':\\n                value = board[move][pos]\\n            else:\\n                value = board[pos][move]\\n\\n            if value == \\'B\\':\\n                break\\n            if value == \\'p\\':\\n                count += 1\\n                break\\n        return count\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        count = 0\\n\\n        row, col = [\\n            (r, c)\\n            for r, line in enumerate(board)\\n            for c, value in enumerate(line)\\n            if value == \\'R\\'\\n        ][0]\\n\\n        count += Solution().move(board, range(row, -1, -1), col, \\'up\\')\\n        count += Solution().move(board, range(row, 8, 1), col, \\'down\\')\\n        count += Solution().move(board, range(col, -1, -1), row, \\'left\\')\\n        count += Solution().move(board, range(col, 8, 1), row, \\'right\\')\\n\\n        return count\\n```\\n```rust []\\nenum Moves {\\n    UpDown,\\n    LeftRight\\n}\\n\\nimpl Solution {\\n    fn move_up_down(board: &Vec<Vec<char>>, moves: impl Iterator<Item = usize>, pos: usize, to_move: Moves) -> i32 {\\n        for m in moves {\\n            let value = match to_move {\\n                Moves::UpDown => board[m][pos],\\n                Moves::LeftRight => board[pos][m],\\n            };\\n            if value == \\'B\\' {\\n                break;\\n            }\\n            if value == \\'p\\' {\\n                return 1;\\n            }\\n        }\\n        0\\n    }\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (mut count, mut row, mut col) = (0, 0, 0);\\n        for (r, line) in board.iter().enumerate() {\\n            for (c, value) in line.iter().enumerate() {\\n                if *value == \\'R\\' {\\n                    row = r; \\n                    col = c;\\n                }\\n            }\\n        }\\n        count += Solution::move_up_down(&board, (0..row).rev(), col, Moves::UpDown);\\n        count += Solution::move_up_down(&board, row..8, col, Moves::UpDown);\\n        count += Solution::move_up_down(&board, (0..col).rev(), row, Moves::LeftRight);\\n        count += Solution::move_up_down(&board, col..8, row, Moves::LeftRight);\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nfrom typing import Literal, Type\\n\\nMOVE: Type[str] = Literal[\\'up\\', \\'down\\', \\'left\\', \\'right\\']\\n\\n\\nclass Solution:\\n    @staticmethod\\n    def move(board: list[list[str]], moves: range, pos: int, to_move: MOVE) -> int:\\n        count = 0\\n        for move in moves:\\n            if to_move == \\'up\\' or to_move == \\'down\\':\\n                value = board[move][pos]\\n            else:\\n                value = board[pos][move]\\n\\n            if value == \\'B\\':\\n                break\\n            if value == \\'p\\':\\n                count += 1\\n                break\\n        return count\\n\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        count = 0\\n\\n        row, col = [\\n            (r, c)\\n            for r, line in enumerate(board)\\n            for c, value in enumerate(line)\\n            if value == \\'R\\'\\n        ][0]\\n\\n        count += Solution().move(board, range(row, -1, -1), col, \\'up\\')\\n        count += Solution().move(board, range(row, 8, 1), col, \\'down\\')\\n        count += Solution().move(board, range(col, -1, -1), row, \\'left\\')\\n        count += Solution().move(board, range(col, 8, 1), row, \\'right\\')\\n\\n        return count\\n```\n```rust []\\nenum Moves {\\n    UpDown,\\n    LeftRight\\n}\\n\\nimpl Solution {\\n    fn move_up_down(board: &Vec<Vec<char>>, moves: impl Iterator<Item = usize>, pos: usize, to_move: Moves) -> i32 {\\n        for m in moves {\\n            let value = match to_move {\\n                Moves::UpDown => board[m][pos],\\n                Moves::LeftRight => board[pos][m],\\n            };\\n            if value == \\'B\\' {\\n                break;\\n            }\\n            if value == \\'p\\' {\\n                return 1;\\n            }\\n        }\\n        0\\n    }\\n    pub fn num_rook_captures(board: Vec<Vec<char>>) -> i32 {\\n        let (mut count, mut row, mut col) = (0, 0, 0);\\n        for (r, line) in board.iter().enumerate() {\\n            for (c, value) in line.iter().enumerate() {\\n                if *value == \\'R\\' {\\n                    row = r; \\n                    col = c;\\n                }\\n            }\\n        }\\n        count += Solution::move_up_down(&board, (0..row).rev(), col, Moves::UpDown);\\n        count += Solution::move_up_down(&board, row..8, col, Moves::UpDown);\\n        count += Solution::move_up_down(&board, (0..col).rev(), row, Moves::LeftRight);\\n        count += Solution::move_up_down(&board, col..8, row, Moves::LeftRight);\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565025,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            },
            {
                "id": 1735847,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            },
            {
                "id": 1764027,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            },
            {
                "id": 2076255,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            },
            {
                "id": 1945958,
                "content": [
                    {
                        "username": "abkosar",
                        "content": "The last part of the question `Return the number of pawns the rook can capture in one move.` is confusing because in one move you can only capture one pawn. If you want to capture all the three pawns you have to do three moves. So the question should be `Return the number of pawns the rook can capture`. I don\\'t know who assesses these questions but some of these could be written in a much much better way."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You could not capture those 3 pawns in 3 moves, it'd take 4 moves. But I agree the wording could be better here. Probably something like: `Return the number of pawns the rook is currently attacking` But I believe they have already updated it since your post, it is much clearer now. "
                    },
                    {
                        "username": "ahmed_mostafa14",
                        "content": "actually your correction is confusing , because it means that if a pawn is not on the same horizontal or vertical coordinate as the rook and not completely surrounded by 4 bishops it should be counted in the answer, which is not correct."
                    },
                    {
                        "username": "user4543Nq",
                        "content": "As a chess player who is really bad at coding, this problem was both fun and confusing for me haha"
                    },
                    {
                        "username": "bobjava",
                        "content": "this is definitely more of a medium problem (an easy medium problem)"
                    },
                    {
                        "username": "adis176",
                        "content": "It is just a simple simulation, and the edge cases are somewhat clear. The language isn\\'t clear at all, which can probably confuse a person, make it seem more hard."
                    },
                    {
                        "username": "pangpangdei",
                        "content": "that is lower case \\'p\\' and upper case \\'R\\' and \\'B\\', fml"
                    },
                    {
                        "username": "lenard2626",
                        "content": "The 23rd  test case:\\n\\n `board = [[\"R\",\".\",\"p\",\".\",\"p\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"p\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nSeems to be wrong, as it says 2 is the expected answer, however, that requires two turns to capture instead of one. Following rules the right anwer should be 1, as there\\'s a pawn blocking rock. which contradicts the third given example:\\n\\n `board = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]`\\n\\nwhich expects 3, but have a similar scenario. In order for it to be consistent contrains should establish a pawn is considered to be \"attacked\" even if there\\'s a pawn attacked already\\n\\nEither,test case 23rd should be removed, or, contrains and examples should be updated."
                    }
                ]
            }
        ]
    }
]