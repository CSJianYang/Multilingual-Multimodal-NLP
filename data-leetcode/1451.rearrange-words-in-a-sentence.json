[
    {
        "title": "Find the Town Judge",
        "question_content": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\nIf the town judge exists, then:\n\n\tThe town judge trusts nobody.\n\tEverybody (except for the town judge) trusts the town judge.\n\tThere is exactly one person that satisfies properties 1 and 2.\n\nYou are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.\n&nbsp;\nExample 1:\n\nInput: n = 2, trust = [[1,2]]\nOutput: 2\n\nExample 2:\n\nInput: n = 3, trust = [[1,3],[2,3]]\nOutput: 3\n\nExample 3:\n\nInput: n = 3, trust = [[1,3],[2,3],[3,1]]\nOutput: -1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000\n\t0 <= trust.length <= 104\n\ttrust[i].length == 2\n\tAll the pairs of trust are unique.\n\tai != bi\n\t1 <= ai, bi <= n",
        "solutions": [
            {
                "id": 242938,
                "title": "java-c-python-directed-graph",
                "content": "**Intuition**:\\nConsider `trust` as a graph, all pairs are directed edge.\\nThe point with `in-degree - out-degree = N - 1` become the judge.\\n\\n**Explanation**:\\nCount the degree, and check at the end.\\n\\n**Time Complexity**:\\nTime `O(T + N)`, space `O(N)`\\n\\n<br>\\n\\n**Java:**\\n```\\n    public int findJudge(int N, int[][] trust) {\\n        int[] count = new int[N+1];\\n        for (int[] t: trust) {\\n            count[t[0]]--;\\n            count[t[1]]++;\\n        }\\n        for (int i = 1; i <= N; ++i) {\\n            if (count[i] == N - 1) return i;\\n        }\\n        return -1;\\n    }\\n```\\n\\n**C++:**\\n```\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> count(N + 1, 0);\\n        for (auto& t : trust)\\n            count[t[0]]--, count[t[1]]++;\\n        for (int i = 1; i <= N; ++i) {\\n            if (count[i] == N - 1) return i;\\n        }\\n        return -1;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def findJudge(self, N, trust):\\n        count = [0] * (N + 1)\\n        for i, j in trust:\\n            count[i] -= 1\\n            count[j] += 1\\n        for i in range(1, N + 1):\\n            if count[i] == N - 1:\\n                return i\\n        return -1\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int findJudge(int N, int[][] trust) {\\n        int[] count = new int[N+1];\\n        for (int[] t: trust) {\\n            count[t[0]]--;\\n            count[t[1]]++;\\n        }\\n        for (int i = 1; i <= N; ++i) {\\n            if (count[i] == N - 1) return i;\\n        }\\n        return -1;\\n    }\\n```\n```\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> count(N + 1, 0);\\n        for (auto& t : trust)\\n            count[t[0]]--, count[t[1]]++;\\n        for (int i = 1; i <= N; ++i) {\\n            if (count[i] == N - 1) return i;\\n        }\\n        return -1;\\n    }\\n```\n```\\n    def findJudge(self, N, trust):\\n        count = [0] * (N + 1)\\n        for i, j in trust:\\n            count[i] -= 1\\n            count[j] += 1\\n        for i in range(1, N + 1):\\n            if count[i] == N - 1:\\n                return i\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 660434,
                "title": "c-well-explained-code-based-on-outdegree-and-indegree",
                "content": "```\\nint findJudge(int n, vector<vector<int>>& trust) {\\n        //this condition is to check if given input is empty but n==1\\n\\t\\t\\n\\t\\tif(trust.empty() && n==1)\\n            return 1;\\n\\t\\t\\n\\t\\t//counts outdegree of a person or node \\n\\t\\t//outdegree means number of nodes that are trusted by given specific node \\n        \\n\\t\\tvector<int> out(n+1,0);\\n\\t\\t\\n\\t\\t//counts indegree of a person or node \\n\\t\\t//indegree means number of nodes that trusts a given specific node\\n        \\n\\t\\tvector<int> in(n+1,0);\\n\\t\\t\\n\\t\\t//loop counts indegree and outdegree\\n        \\n\\t\\tfor(auto edge : trust){\\n            out[edge[0]]++;\\n            in[edge[1]]++;\\n        }\\n\\t\\t\\n\\t\\t//if a node has outdegree==0 that means that node doesnot trust anyone and\\n\\t\\t//indegree ==n-1 that means all other nodes trusts this node except himself\\n        \\n\\t\\tfor(int i=0;i<=n;i++){\\n            if(out[i]==0 && in[i]==n-1)\\n                return i;\\n        }\\n\\t\\t//if there is no such node return -1\\n        return -1;\\n    }\\n```\\n**Upvotes are encouraging**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findJudge(int n, vector<vector<int>>& trust) {\\n        //this condition is to check if given input is empty but n==1\\n\\t\\t\\n\\t\\tif(trust.empty() && n==1)\\n            return 1;\\n\\t\\t\\n\\t\\t//counts outdegree of a person or node \\n\\t\\t//outdegree means number of nodes that are trusted by given specific node \\n        \\n\\t\\tvector<int> out(n+1,0);\\n\\t\\t\\n\\t\\t//counts indegree of a person or node \\n\\t\\t//indegree means number of nodes that trusts a given specific node\\n        \\n\\t\\tvector<int> in(n+1,0);\\n\\t\\t\\n\\t\\t//loop counts indegree and outdegree\\n        \\n\\t\\tfor(auto edge : trust){\\n            out[edge[0]]++;\\n            in[edge[1]]++;\\n        }\\n\\t\\t\\n\\t\\t//if a node has outdegree==0 that means that node doesnot trust anyone and\\n\\t\\t//indegree ==n-1 that means all other nodes trusts this node except himself\\n        \\n\\t\\tfor(int i=0;i<=n;i++){\\n            if(out[i]==0 && in[i]==n-1)\\n                return i;\\n        }\\n\\t\\t//if there is no such node return -1\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088104,
                "title": "day-23-easiest-beginner-friendly-solution-o-n-time-and-o-n-space",
                "content": "# Intuition\\n![with_judge.png](https://assets.leetcode.com/users/images/2ea90f88-4f16-4106-b32b-aba3d1f5ae49_1674444310.3956482.png)\\n**For example, with N = 5 and trust = [[1,3],[2,3],[4,3],[4,1],[5,3],[5,1],[5,4]], town judge will be 3.**\\n\\n**In graph theory, we say the outdegree of a vertex (person) is the number of directed edges going out of it. For this graph, the outdegree of the vertex represents the number of other people that person trusts.**\\n\\n**Likewise, we say that the indegree of a vertex (person) is the number of directed edges going into it. So here, it represents the number of people trusted by that person.**\\nSAME CONCEPT WE WILL USE BELOW\\n1. decrements the trust count of the first person in the pair. This is done because if the first person trusts the second person, it means that the first person does not trust themselves.\\n2. increments the trust count of the second person in the pair. This is done because if the first person trusts the second person, it means that the second person is trusted by the first person.\\n3. check if there is a person who is trusted by everyone except themselves (n-1 people) and if such person exists it returns the index of that person.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize an empty array count of size n+1 to keep track of the number of people that trust or are trusted by a particular person.\\n2. Iterate through the trust array, for each pair of people, decrement the trust count of the first person and increment the trust count of the second person.\\n3. Iterate through the count array, for each person, check if their trust count is equal to n-1, if yes return that person\\'s index, as that person is the judge.\\n4. If no such person is found, return -1 as no judge exists.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>> trust) {\\n        if (trust.size() == 0 && n == 1) \\n            return 1;\\n        vector<int> count(n + 1);\\n        for (auto person : trust) {\\n            //count[person[0]]--; decrements the trust count of the first person in the pair. This is done because if the first person trusts the second person, it means that the first person does not trust themselves.\\n            count[person[0]]--;\\n            //count[person[1]]++; increments the trust count of the second person in the pair. This is done because if the first person trusts the second person, it means that the second person is trusted by the first person.\\n            count[person[1]]++;\\n        }\\n\\n        for (int person = 0; person < count.size(); person++) {\\n            // check if there is a person who is trusted by everyone except themselves (n-1 people) and if such person exists it returns the index of that person.\\n            if (count[person] == n - 1) return person;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if (trust.length == 0 && n == 1) \\n            return 1;\\n        int[] count = new int[n + 1];\\n        for (int[] person : trust) {\\n            count[person[0]]--;\\n            count[person[1]]++;\\n        }\\n\\n        for (int person = 0; person < count.length; person++) {\\n            if (count[person] == n - 1) return person;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        if len(trust) == 0 and n == 1: \\n            return 1\\n        count = [0] * (n + 1)\\n        for person in trust:\\n            count[person[0]] -= 1\\n            count[person[1]] += 1\\n\\n        for person in range(len(count)):\\n            if count[person] == n - 1: return person\\n        return -1\\n\\n```\\n\\n# Complexity\\n- Time complexity: **O(n)** \\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>> trust) {\\n        if (trust.size() == 0 && n == 1) \\n            return 1;\\n        vector<int> count(n + 1);\\n        for (auto person : trust) {\\n            //count[person[0]]--; decrements the trust count of the first person in the pair. This is done because if the first person trusts the second person, it means that the first person does not trust themselves.\\n            count[person[0]]--;\\n            //count[person[1]]++; increments the trust count of the second person in the pair. This is done because if the first person trusts the second person, it means that the second person is trusted by the first person.\\n            count[person[1]]++;\\n        }\\n\\n        for (int person = 0; person < count.size(); person++) {\\n            // check if there is a person who is trusted by everyone except themselves (n-1 people) and if such person exists it returns the index of that person.\\n            if (count[person] == n - 1) return person;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if (trust.length == 0 && n == 1) \\n            return 1;\\n        int[] count = new int[n + 1];\\n        for (int[] person : trust) {\\n            count[person[0]]--;\\n            count[person[1]]++;\\n        }\\n\\n        for (int person = 0; person < count.length; person++) {\\n            if (count[person] == n - 1) return person;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        if len(trust) == 0 and n == 1: \\n            return 1\\n        count = [0] * (n + 1)\\n        for person in trust:\\n            count[person[0]] -= 1\\n            count[person[1]] += 1\\n\\n        for person in range(len(count)):\\n            if count[person] == n - 1: return person\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663344,
                "title": "c-java-python3-javascript-everything-you-need-to-know-from-start-to-end",
                "content": "**Reframing the question :-**\\nThere are `1` to `n` people in a town with one of them being a judge. The criteria to being a judge is that :-\\n\\n**1. The judge believes no one than himself.\\n2. Whole town i.e Everybody believes judge .**\\n\\nSo at the end of the statement the constraints leads to pointing out that any person that is trusted by `N-1 persons` and the same person believes no one, then the preson is said to be a judge.\\n***\\n\\n**Intuition:-**\\nA basic intuition can be concluded from question is that, if a person is believing someone else than himself than that person is not qualified for being a judge  or if a person is trusted by others and has everyone\\'s favour i.e <mark>total of N-1 favours, than this person is truly the judge</mark>.\\n***\\n\\n**Algorithm:-**\\n1. Create an array `Trusted` of size `N+1` to represent the total number of peoples in a town and initialize it with 0 . \\n2. After initialization, whenever a person trust someone else than himself, the `trusted` value of that person should be decreased since that person is not satisfying the two conditions that were mentioned in the question. \\n3. Also if a certain `x` person is trusted by others from town, than this `x` person value should be increased and those who trusted that `x` person there values should be decreased.\\n4. At last traverse through every person of town and while traversing If a person is found with `N-1 trusts` than this person should be the judge and return the index of that person .\\n***\\n***\\n\\n**A concept that is used in algo you know but you don\\'t know that you know :))**\\n> In a graph the indegree of a person or node is the number of nodes that trusts a given specific node and outdegree of a person or node is the number of nodes that are trusted by given specific node . \\n**In more technical words:-**\\n> * Out-degree is the number of outgoing edges emanating from a node. &\\n> * In-degree is the number of incoming edges onto a node .\\n\\n***\\n\\n**C++ CODE:-**\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> Trusted(N + 1, 0);\\n        for(auto person : trust){\\n            Trusted[person[0]]--;\\n            Trusted[person[1]]++;\\n        }\\n        for(int i = 1;i <= N;i++){\\n            if(Trusted[i] == N - 1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n***\\n**JAVA CODE:-**\\n```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[] Trusted = new int[N+1];\\n        for(int[] person : trust){\\n            Trusted[person[0]]--;\\n            Trusted[person[1]]++;\\n        }\\n        for(int i = 1;i < Trusted.length;i++){\\n            if(Trusted[i] == N-1) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n***\\n**PYTHON3 CODE:-**\\n```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        Trusted = [0] * (N+1)\\n        for (a, b) in trust:\\n            Trusted[a] -= 1\\n            Trusted[b] += 1\\n            \\n        for i in range(1, len(Trusted)):\\n            if Trusted[i] == N-1:\\n                return i\\n        return -1\\n```\\n***\\n**JAVASCRIPT CODE:-**\\n```\\n/**\\n * @param {number} N\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(n, trust) {\\n    const Trusted = new Array(n+1).fill(0);\\n    for(let [i,j] of trust) {\\n        Trusted[i] -= 1\\n        Trusted[j] += 1\\n    }\\n    for(let i = 1; i < Trusted.length; i++) {\\n        if ((n-1) === Trusted[i]) {\\n            return i;\\n        }\\n    }\\n    return -1\\n};\\n```\\n***\\n**Time Complexity:-** *`O(n) where n is the total number of people living in the town`*\\n**Space Complexity:-** *`O(n) where n is the total number of people living in the town`*\\n\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote ;)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> Trusted(N + 1, 0);\\n        for(auto person : trust){\\n            Trusted[person[0]]--;\\n            Trusted[person[1]]++;\\n        }\\n        for(int i = 1;i <= N;i++){\\n            if(Trusted[i] == N - 1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[] Trusted = new int[N+1];\\n        for(int[] person : trust){\\n            Trusted[person[0]]--;\\n            Trusted[person[1]]++;\\n        }\\n        for(int i = 1;i < Trusted.length;i++){\\n            if(Trusted[i] == N-1) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        Trusted = [0] * (N+1)\\n        for (a, b) in trust:\\n            Trusted[a] -= 1\\n            Trusted[b] += 1\\n            \\n        for i in range(1, len(Trusted)):\\n            if Trusted[i] == N-1:\\n                return i\\n        return -1\\n```\n```\\n/**\\n * @param {number} N\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(n, trust) {\\n    const Trusted = new Array(n+1).fill(0);\\n    for(let [i,j] of trust) {\\n        Trusted[i] -= 1\\n        Trusted[j] += 1\\n    }\\n    for(let i = 1; i < Trusted.length; i++) {\\n        if ((n-1) === Trusted[i]) {\\n            return i;\\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244859,
                "title": "python-o-n-with-explanation",
                "content": "Keep track of the cumulative score of each person: if person a trusts person b, we decrement a\\'s score and increment b\\'s score. \\n**The judge is the only person that ends up with a score of N-1.**\\n\\nI initialize the trusted list with N+1 items to make indexing easier, since the villagers are named 1 thorugh N. \\n\\n**Time complexity** O(N + T): T=len(trust). We iterate through the trust list once and through all villagers once, so the time complexity is linear in these. This is equivalent to |Vertices| + |Edges| in graph terms, if we consider each person as a vertex and each trust relationship as a directed edge. \\n\\n**Space complexity** O(N): We create a trusted list with a size of N+1 to store the cumulative scores.\\n\\n```\\ndef findJudge(self, N, trust):\\n\\ttrusted = [0] * (N+1)\\n\\tfor a, b in trust:\\n\\t\\ttrusted[a] -= 1\\n\\t\\ttrusted[b] += 1\\n\\n\\tfor i in range(1, N+1):\\n\\t\\tif trusted[i] == N-1:\\n\\t\\t\\treturn i\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findJudge(self, N, trust):\\n\\ttrusted = [0] * (N+1)\\n\\tfor a, b in trust:\\n\\t\\ttrusted[a] -= 1\\n\\t\\ttrusted[b] += 1\\n\\n\\tfor i in range(1, N+1):\\n\\t\\tif trusted[i] == N-1:\\n\\t\\t\\treturn i\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3088034,
                "title": "easy-solution-beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will track the trust gained by each person and if any person has gained a trust of n-1 people, and trusts nobody, he is our judge.\\n\\nSince we have to store something i.e the trust we can use either a hashmap or a count array. but its better and efficient to use a count array when we know the range.\\neg [0,0,2] indicates that the trust of person 3 is 2 and the other is 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over the trust array and \\nIncrease the count of trusted person ie A[i][1]++\\nDecrease the count of trusting person ie A[i][0]--\\nwhy, since the trust is unique, this person can never have value = n-1\\n\\nCheck the count array if n-1 exists and that is ans.\\n\\nhttps://youtu.be/5yIf80266jY\\n\\n![sfw-please-upvote-me-v0-u5cacra0rnca1.webp](https://assets.leetcode.com/users/images/c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n==1 && trust.length == 0) return 1;\\n        int [] count = new int[n+1];\\n        for(int i = 0;i<trust.length;i++){\\n            \\n            count[trust[i][0]]--;\\n            \\n            count[trust[i][1]]++;\\n        }\\n\\n       for(int i = 0;i<count.length;i++){\\n           if(count[i] ==n-1)  return i;\\n       }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n==1 && trust.length == 0) return 1;\\n        int [] count = new int[n+1];\\n        for(int i = 0;i<trust.length;i++){\\n            \\n            count[trust[i][0]]--;\\n            \\n            count[trust[i][1]]++;\\n        }\\n\\n       for(int i = 0;i<count.length;i++){\\n           if(count[i] ==n-1)  return i;\\n       }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244198,
                "title": "java-straight-forward-solution",
                "content": "I used two integer arrays to represent who people trust and who were trusted.\\nAfter storing all values into the two arrays just go through those two arrays and find the person with 0 trust person and being trusted by N - 1 people.\\n\\nTime Complexity: O(N).\\n```\\npublic int findJudge(int N, int[][] arr) {\\n        int[] trust = new int[N];\\n        int[] trusted = new int[N];\\n        for(int i = 0; i < arr.length; i++){\\n            int a = arr[i][0]; \\n            int b = arr[i][1];\\n            trust[a - 1]++;\\n            trusted[b - 1]++;\\n        }\\n        for(int i = 0; i < N; i++){\\n            if(trust[i] == 0 && trusted[i] == N - 1)\\n                return i + 1;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findJudge(int N, int[][] arr) {\\n        int[] trust = new int[N];\\n        int[] trusted = new int[N];\\n        for(int i = 0; i < arr.length; i++){\\n            int a = arr[i][0]; \\n            int b = arr[i][1];\\n            trust[a - 1]++;\\n            trusted[b - 1]++;\\n        }\\n        for(int i = 0; i < N; i++){\\n            if(trust[i] == 0 && trusted[i] == N - 1)\\n                return i + 1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242952,
                "title": "c-4-lines-find-the-celebrity",
                "content": "This is the same as [Find the Celebrity](https://leetcode.com/problems/find-the-celebrity/) (Medium), but here we can access all connections directly (so this problem is Easy).\\n# Brute-Force Solution\\nSince we have all connections, we can count people that ```i```-th person```trusts```, and people that ```i```-th person is ```trusted``` by. Then, we just search for a judge.\\n```\\nint findJudge(int N, vector<vector<int>>& trust) {\\n  vector<int> trusts(N + 1), trusted(N + 1);\\n  for (auto &t : trust) ++trusts[t[0]], ++trusted[t[1]];\\n  for (auto i = 1; i <= N; ++i) if (trusts[i] == 0 && trusted[i] == N - 1) return i;\\n  return -1;\\n}\\n```\\nWe can further simplify this by using a single vector and tracking the trust ```balance```. Only the person that has ```N - 1``` trust balance is trusted by everyone and trusts none. \\n```\\nint findJudge(int N, vector<vector<int>>& trust) {\\n  vector<int> balance(N + 1);\\n  for (auto &t : trust) --balance[t[0]], ++balance[t[1]];\\n  for (auto i = 1; i <= N; ++i) if (balance[i] == N - 1) return i;\\n  return -1;\\n}\\n```\\n## Complexity Analysis\\nTime: *O(m)*, where *m* is the number of trust pairs.\\nMemory: *O(N)*.\\n# Find the Celebrity\\nIf we are given trust connections as an adjacency matrix (or a hash map), we can use the same algorithm as in the Find the Celebrity problem. Here is [solution and explanations](https://leetcode.com/problems/find-the-celebrity/discuss/243605/C++-4-lines) to that problem. This cool technique to quickly find a potential celebrity helps reduce the runtime and memory complexity.\\n```\\nint findJudge(int N, vector<vector<int>>& trust) {\\n  vector<vector<int>> knows(N + 1, vector<int>(N + 1));\\n  for (auto &t : trust) knows[t[0]][t[1]] = 1;\\n  return findCelebrity(N, knows);\\n}\\nint findCelebrity(int n, vector<vector<int>>& knows, int i = 1) {\\n  for (auto j = i + 1; j <= n; ++j) if (knows[i][j]) i = j;\\n  for (auto j = 1; j < i; ++j) if (knows[i][j]) return -1;\\n  for (auto j = 1; j <= n; ++j) if (i != j && !knows[j][i]) return -1;\\n  return i;\\n}\\n```\\n## Complexity Analysis\\n> Note that we analyze the complexity of ```findCelebrity``` (without preparation steps).\\n\\nTime: *O(N)*.\\nMemory: *O(1)*.\\n",
                "solutionTags": [],
                "code": "```i```\n```trusts```\n```i```\n```trusted```\n```\\nint findJudge(int N, vector<vector<int>>& trust) {\\n  vector<int> trusts(N + 1), trusted(N + 1);\\n  for (auto &t : trust) ++trusts[t[0]], ++trusted[t[1]];\\n  for (auto i = 1; i <= N; ++i) if (trusts[i] == 0 && trusted[i] == N - 1) return i;\\n  return -1;\\n}\\n```\n```balance```\n```N - 1```\n```\\nint findJudge(int N, vector<vector<int>>& trust) {\\n  vector<int> balance(N + 1);\\n  for (auto &t : trust) --balance[t[0]], ++balance[t[1]];\\n  for (auto i = 1; i <= N; ++i) if (balance[i] == N - 1) return i;\\n  return -1;\\n}\\n```\n```\\nint findJudge(int N, vector<vector<int>>& trust) {\\n  vector<vector<int>> knows(N + 1, vector<int>(N + 1));\\n  for (auto &t : trust) knows[t[0]][t[1]] = 1;\\n  return findCelebrity(N, knows);\\n}\\nint findCelebrity(int n, vector<vector<int>>& knows, int i = 1) {\\n  for (auto j = i + 1; j <= n; ++j) if (knows[i][j]) i = j;\\n  for (auto j = 1; j < i; ++j) if (knows[i][j]) return -1;\\n  for (auto j = 1; j <= n; ++j) if (i != j && !knows[j][i]) return -1;\\n  return i;\\n}\\n```\n```findCelebrity```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663283,
                "title": "well-explained-2-approaches-java-c-easy-for-mind-to-accept-them",
                "content": "**Single Array Approach :**\\n**JAVA**\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int arr[] = new int[n + 1]; // Define an array of length n+1\\n        \\n        for(int i = 0; i < trust.length; i++){ // loop through the \\'trust\\' array\\n            arr[trust[i][0]]--; // if a given person trust someone then decrement the count of his index\\n            arr[trust[i][1]]++; // increment the count of the index whom he trusts\\n            \\n        }\\n        // In last, check the \\'arr\\' array that if there is any index having count equals to n-1\\n        for(int i = 1; i < arr.length; i++){\\n            if(arr[i] == n - 1) return i; // person doesnt trust anybody but everyone else trust him. Return their index\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> arr(n + 1, 0); // Define an array of length n+1\\n        \\n        for(int i = 0; i < trust.size(); i++){ // loop through the \\'trust\\' array\\n            arr[trust[i][0]]--; // if a given person trust someone then decrement the count of his index\\n            arr[trust[i][1]]++; // increment the count of the index whom he trusts\\n            \\n        }\\n        // In last, check the \\'arr\\' array that if there is any index having count equals to n-1\\n        for(int i = 1; i < arr.size(); i++){\\n            if(arr[i] == n - 1) return i; // person doesnt trust anybody but everyone else trust him. Return their index\\n        }\\n        return -1;\\n    }\\n};\\n```\\nANALYSIS :- \\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n\\n**HashTable Approach :**\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n == 1) return 1; // Base Condition, means if trust array length is 0.means No one trust, as only one guy is present in town.\\n        Set<Integer> set = new HashSet<>(); // those who trusting on someone, they can never be the judge so. Put them into HashSet.\\n        Map<Integer, Integer> map = new HashMap<>(); // created an frequency map, for those who trust on someone.\\n        \\n        for(int i = 0; i < trust.length; i++){\\n            set.add(trust[i][0]); // filling the hashset\\n            \\n            int key = trust[i][1]; // created an key variable helps in filling our hashmap\\n            if(map.containsKey(key)){ // if key already present in map update it\\'s frequency by 1\\n                map.put(key, map.get(key) + 1);\\n            }\\n            else{ // otherwise create new frequency,\\n                map.put(key, 1);\\n            }\\n        }\\n        \\n        for(Integer key : map.keySet()){ // Iterating on our HashMap\\n            // The judge we are looking for, it\\'s key value in hashmap is equals to n - 1 && that key is also not present in hashset \\n            if(map.get(key) == n - 1 && set.contains(key) == false) return key; // if so, return key\\n        }\\n        return -1;\\n    }\\n}\\n```\\nANALYSIS :- \\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int arr[] = new int[n + 1]; // Define an array of length n+1\\n        \\n        for(int i = 0; i < trust.length; i++){ // loop through the \\'trust\\' array\\n            arr[trust[i][0]]--; // if a given person trust someone then decrement the count of his index\\n            arr[trust[i][1]]++; // increment the count of the index whom he trusts\\n            \\n        }\\n        // In last, check the \\'arr\\' array that if there is any index having count equals to n-1\\n        for(int i = 1; i < arr.length; i++){\\n            if(arr[i] == n - 1) return i; // person doesnt trust anybody but everyone else trust him. Return their index\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> arr(n + 1, 0); // Define an array of length n+1\\n        \\n        for(int i = 0; i < trust.size(); i++){ // loop through the \\'trust\\' array\\n            arr[trust[i][0]]--; // if a given person trust someone then decrement the count of his index\\n            arr[trust[i][1]]++; // increment the count of the index whom he trusts\\n            \\n        }\\n        // In last, check the \\'arr\\' array that if there is any index having count equals to n-1\\n        for(int i = 1; i < arr.size(); i++){\\n            if(arr[i] == n - 1) return i; // person doesnt trust anybody but everyone else trust him. Return their index\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n == 1) return 1; // Base Condition, means if trust array length is 0.means No one trust, as only one guy is present in town.\\n        Set<Integer> set = new HashSet<>(); // those who trusting on someone, they can never be the judge so. Put them into HashSet.\\n        Map<Integer, Integer> map = new HashMap<>(); // created an frequency map, for those who trust on someone.\\n        \\n        for(int i = 0; i < trust.length; i++){\\n            set.add(trust[i][0]); // filling the hashset\\n            \\n            int key = trust[i][1]; // created an key variable helps in filling our hashmap\\n            if(map.containsKey(key)){ // if key already present in map update it\\'s frequency by 1\\n                map.put(key, map.get(key) + 1);\\n            }\\n            else{ // otherwise create new frequency,\\n                map.put(key, 1);\\n            }\\n        }\\n        \\n        for(Integer key : map.keySet()){ // Iterating on our HashMap\\n            // The judge we are looking for, it\\'s key value in hashmap is equals to n - 1 && that key is also not present in hashset \\n            if(map.get(key) == n - 1 && set.contains(key) == false) return key; // if so, return key\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663196,
                "title": "java-c-python-detailed-explanation-of-intution",
                "content": "**Intution:** So we have following conditions on which we have to work:\\n* Town judge trust nobody\\n* Every other trust town judge.\\n\\nSo here we gonna use concept of indegree and outdegree used in graph:\\n* If a person A trust other person B then we can see it as directed edge from A to B ( A --> B ) and so here edge is coming out of A and going into B.\\n* So increase the oudegree (or decrease the indegree) of A and increase indegree of B.\\n* So here we can observe that if 5 person trust B then indegree of B will be 5 and if B trust 2 other person the  its outdgeree will be 2 i.e., net indegree will be 5 - 2 = 3.\\n* And to become the town judge we know that judge can not have trust on any other person so outdegree of judge = 0 and every other person trust the judge so indegree of judge = n-1.\\n* Hence we can say that judge will be the person for which we have **indegree - outdegree = n-1**.\\n\\n**Java**\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        \\n        int count[] = new int[n+1];\\n        \\n        for(int t[] : trust){\\n            count[t[0]]--;     // outdegree\\n            count[t[1]]++;   // indegree\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            if(count[i]==n-1) return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        \\n        vector<int> count(N + 1, 0);\\n        \\n        for (auto& t : trust){\\n            count[t[0]]--;\\n            count[t[1]]++;\\n        }\\n             \\n        for (int i = 1; i <= N; ++i) {\\n            if (count[i] == N - 1) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n**Python:**\\n```\\nclass Solution(object):\\n    def findJudge(self, N, trust):\\n        \\n        count = [0] * (N + 1)\\n        \\n        for i, j in trust:\\n            count[i] -= 1\\n            count[j] += 1\\n            \\n        for i in range(1, N + 1):\\n            if count[i] == N - 1:\\n                return i\\n            \\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        \\n        int count[] = new int[n+1];\\n        \\n        for(int t[] : trust){\\n            count[t[0]]--;     // outdegree\\n            count[t[1]]++;   // indegree\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            if(count[i]==n-1) return i;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        \\n        vector<int> count(N + 1, 0);\\n        \\n        for (auto& t : trust){\\n            count[t[0]]--;\\n            count[t[1]]++;\\n        }\\n             \\n        for (int i = 1; i <= N; ++i) {\\n            if (count[i] == N - 1) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def findJudge(self, N, trust):\\n        \\n        count = [0] * (N + 1)\\n        \\n        for i, j in trust:\\n            count[i] -= 1\\n            count[j] += 1\\n            \\n        for i in range(1, N + 1):\\n            if count[i] == N - 1:\\n                return i\\n            \\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088191,
                "title": "c-easiest-detailed-solution-beginner-friendly",
                "content": "# Approach\\n\\n- I have created two vectors `trusting` which represents `i`th element trusts how many people and `trusted` whose `i`th element represents it is trusted by how many people.\\n- I have incremented respective indexes in each iteration.\\n- Finally I have initialized `ans = -1`, if there exist any `i` which trusts nobody i.e. `trusting[i] = 0` && it is trusted by all accept him i.e. `trusted[i] = n-1` then update ans.\\n- return ans\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        \\n        //Initialized vectors of size n+1 with 0 to be able to store values for index 1 to n\\n        vector<int> trusting(n+1,0); \\n        vector<int> trusted(n+1,0);\\n\\n        for(int i=0;i<trust.size();i++){\\n            trusting[trust[i][0]]++;\\n            trusted[trust[i][1]]++;\\n        }\\n\\n        int ans = -1;\\n\\n        for(int i=1;i<=n;i++){\\n            if(trusting[i] == 0 && trusted[i] == n-1)\\n                ans = i;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```\\n# Please upvote, if you find this solution helpful \\uD83D\\uDE4F \\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        \\n        //Initialized vectors of size n+1 with 0 to be able to store values for index 1 to n\\n        vector<int> trusting(n+1,0); \\n        vector<int> trusted(n+1,0);\\n\\n        for(int i=0;i<trust.size();i++){\\n            trusting[trust[i][0]]++;\\n            trusted[trust[i][1]]++;\\n        }\\n\\n        int ans = -1;\\n\\n        for(int i=1;i<=n;i++){\\n            if(trusting[i] == 0 && trusted[i] == n-1)\\n                ans = i;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088126,
                "title": "python3-simple-solution-with-comments",
                "content": "**Solution 1** Two Counters\\n```python\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        # Count the number of people this guy is being trusted by.\\n        beingTrustedBy = defaultdict(int)\\n        # Count the number of people this guy trusts\\n        trusting = defaultdict(int)\\n        \\n        # Going through the trust relations.\\n        for a,b in trust:\\n            trusting[a] += 1\\n            beingTrustedBy[b] += 1\\n        \\n        # The judge trusting 0 people, and being trusted by n-1 people\\n        for i in range(1,n+1):\\n            if beingTrustedBy[i] == n-1 and trusting[i] == 0:\\n                return i\\n        \\n        # Didn\\'t find a judge\\n        return -1\\n```\\n\\n**Solution 2** One Counter\\n\\n```python\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        # Combine the 2 counters from the previous one \\n        # Get the difference between the number of people this guy is trusted by and the number of people this guy trusts.\\n        diff_between_beingTrustedBy_and_trusting = defaultdict(int)\\n\\n        # Going through the trust relations.\\n        for a,b in trust:\\n            diff_between_beingTrustedBy_and_trusting[a] -= 1\\n            diff_between_beingTrustedBy_and_trusting[b] += 1\\n\\n        # The judge trusting 0 people, and being trusted by n-1 people.\\n        # As a result the judge will have the difference as: n-1-0 == n-1\\n        for i in range(1,n+1):\\n            if diff_between_beingTrustedBy_and_trusting[i] == n-1:\\n                return i\\n        \\n        # Didn\\'t find a judge\\n        return -1\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        # Count the number of people this guy is being trusted by.\\n        beingTrustedBy = defaultdict(int)\\n        # Count the number of people this guy trusts\\n        trusting = defaultdict(int)\\n        \\n        # Going through the trust relations.\\n        for a,b in trust:\\n            trusting[a] += 1\\n            beingTrustedBy[b] += 1\\n        \\n        # The judge trusting 0 people, and being trusted by n-1 people\\n        for i in range(1,n+1):\\n            if beingTrustedBy[i] == n-1 and trusting[i] == 0:\\n                return i\\n        \\n        # Didn\\'t find a judge\\n        return -1\\n```\n```python\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        # Combine the 2 counters from the previous one \\n        # Get the difference between the number of people this guy is trusted by and the number of people this guy trusts.\\n        diff_between_beingTrustedBy_and_trusting = defaultdict(int)\\n\\n        # Going through the trust relations.\\n        for a,b in trust:\\n            diff_between_beingTrustedBy_and_trusting[a] -= 1\\n            diff_between_beingTrustedBy_and_trusting[b] += 1\\n\\n        # The judge trusting 0 people, and being trusted by n-1 people.\\n        # As a result the judge will have the difference as: n-1-0 == n-1\\n        for i in range(1,n+1):\\n            if diff_between_beingTrustedBy_and_trusting[i] == n-1:\\n                return i\\n        \\n        # Didn\\'t find a judge\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624254,
                "title": "python-js-java-c-go-o-n-t-by-trust-score-w-visualization",
                "content": "Python O(n+t) by trust score.\\n\\n[Tutorial video in Chinese [ \\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247 ]](https://youtu.be/JVcmwA1TVTk)\\n\\nDefine trust score as the net counting of trusting by others.\\n\\nIf person_a trusts person_b, then\\n\\n```\\ntrust_score[ person_a ] -= 1\\ntrust_score[ person_b ] += 1\\n```\\n\\nFinally, **town judge** is the person who has **trust score == (n-1)**\\n\\n---\\n\\n**Visualziation**:\\nGreen node: person id\\n\\nPurple circle: town judge\\n\\nPurple number: trust score\\n\\n![image.png](https://assets.leetcode.com/users/images/b45aef47-9f43-4d43-ad7c-9e6bbfb8de50_1684827019.661572.png)\\n\\n---\\n**Complexity analysis**\\n\\nTime complexity:\\nO( n + T )\\nWe have O(n) person scan loop, and O(T) edge scan loop.\\n\\nSpace complexity:\\nO(n)\\nWe have a table, trust_score, for each person at most.\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        \\n        if N == 1:\\n            # Quick response for small case\\n            return 1\\n        \\n        # first cell is dummy, just for the convenience of indexing start from 1 to N\\n        trust_score = [ 0 for _ in range(N+1) ]\\n        \\n        for p1, p2 in trust:\\n            \\n            # decrease one point from p1 when p1 trusts other people\\n            trust_score[p1] -= 1\\n            \\n            # increase one point to p2 when p2 is trusted by others\\n            trust_score[p2] += 1\\n            \\n            \\n        \\n        for person in range(1, N+1):\\n            \\n            # town judge will be trusted by other N-1 people, and town judge trust nobody.\\n            if trust_score[person] == N-1:\\n                return person\\n        \\n        return -1\\n```\\n\\n---\\n\\nin **Java**:\\n\\n<details>\\n\\t<summary> Expand to see source code</summary>\\n\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n     \\n        if( 1 == n ){\\n            // Quick response on simple case\\n            return 1;\\n        }\\n        \\n        // first cell is dummy, just for the convenience of indexing start from 1 to N\\n        int[] score = new int[ (n+1) ];\\n        \\n        for( int[] pair : trust ){\\n            \\n            int a = pair[0], b = pair[1];\\n            \\n            // decrease one point from p1 when p1 trusts other people\\n            score[ a ] -= 1;\\n            \\n            // increase one point to p2 when p2 is trusted by others\\n            score[ b ] += 1;    \\n        }\\n        \\n        for( int i = 1 ; i <= n ; i++ ){\\n            \\n            // town judge will be trusted by other N-1 people, and town judge trust nobody.\\n            if( score[i] == n-1 ){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n\\n    }\\n}\\n```\\n\\n</details>\\n\\n\\n---\\n\\nin **Javascript**:\\n\\n<details>\\n\\t<summary> Expand to see source code</summary>\\n\\n```\\nvar findJudge = function(n, trust) {\\n    \\n    // Quick response for simple case\\n    if( 1 == n ){\\n        return 1;\\n    }\\n    \\n\\t// first cell is dummy, just for the convenience of indexing start from 1 to N\\n    trustScore = Array( n + 1 ).fill( 0 );\\n    \\n    for( const [p1, p2] of trust){\\n        \\n        // decrease one point from p1 when p1 trusts other people\\n        trustScore[p1] -= 1 ;\\n        \\n        // increase one point to p2 when p2 is trusted by others\\n        trustScore[p2] += 1;\\n    }\\n    \\n    \\n    for( let personID = 1 ; personID <= n ; personID++){\\n        \\n        // town judge will be trusted by other N-1 people, and town judge trust nobody.\\n        if( (n - 1) == trustScore[ personID] ){\\n            return personID;\\n        }\\n    }\\n    \\n    return -1;\\n    \\n};\\n```\\n\\n</details>\\n\\n---\\n\\n\\nin **C++**:\\n\\n<details>\\n\\t<summary> Expand to see source code</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        \\n        // Quick response for simple case\\n        if( 1 == n ){\\n            return 1;\\n        }\\n        \\n        // first cell is dummy, just for the convenience of indexing start from 1 to N\\n        vector< int > trustScore(n+1);\\n        \\n        // General cases:\\n        for( auto trustVector : trust){\\n            \\n            int p1 = trustVector[0], p2 = trustVector[1];\\n            \\n\\t\\t\\t// decrease one point from p1 when p1 trusts other people\\n            trustScore[ p1 ] -= 1;\\n\\t\\t\\t\\n\\t\\t\\t// increase one point to p2 when p2 is trusted by others\\n            trustScore[ p2 ] += 1;\\n        }\\n        \\n        for( int personID = 1 ; personID <= n ; personID++ ){\\n            \\n\\t\\t\\t// town judge will be trusted by other N-1 people, and town judge trust nobody.\\n            if( (n - 1) == trustScore[personID]  ){\\n                return personID;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to see source code</summary>\\n\\n```\\nfunc findJudge(n int, trust [][]int) int {\\n    \\n    // Quick response on simple case\\n    if 1 == n {\\n        return 1\\n    }\\n    \\n    // first cell is dummy, just for the convenience of indexing start from 1 to N\\n    trustScore := make( []int, n+1)\\n    \\n    // General cases:\\n    for _, trustVector := range trust{\\n        \\n        p1 := trustVector[0]\\n        p2 := trustVector[1]\\n        \\n        // decrease one point from p1 when p1 trusts other people\\n        trustScore[ p1 ] -= 1\\n        \\n        // increase one point to p2 when p2 is trusted by others\\n        trustScore[ p2 ] += 1\\n    }\\n    \\n    for personID := 1 ; personID <= n ; personID++{\\n        \\n        // town judge will be trusted by other N-1 people, and town judge trust nobody.\\n        if ( n - 1 ) == trustScore[ personID ]{\\n            return personID\\n        }\\n    }\\n    \\n    return -1\\n}\\n```\\n\\n</details>\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\ntrust_score[ person_a ] -= 1\\ntrust_score[ person_b ] += 1\\n```\n```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        \\n        if N == 1:\\n            # Quick response for small case\\n            return 1\\n        \\n        # first cell is dummy, just for the convenience of indexing start from 1 to N\\n        trust_score = [ 0 for _ in range(N+1) ]\\n        \\n        for p1, p2 in trust:\\n            \\n            # decrease one point from p1 when p1 trusts other people\\n            trust_score[p1] -= 1\\n            \\n            # increase one point to p2 when p2 is trusted by others\\n            trust_score[p2] += 1\\n            \\n            \\n        \\n        for person in range(1, N+1):\\n            \\n            # town judge will be trusted by other N-1 people, and town judge trust nobody.\\n            if trust_score[person] == N-1:\\n                return person\\n        \\n        return -1\\n```\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n     \\n        if( 1 == n ){\\n            // Quick response on simple case\\n            return 1;\\n        }\\n        \\n        // first cell is dummy, just for the convenience of indexing start from 1 to N\\n        int[] score = new int[ (n+1) ];\\n        \\n        for( int[] pair : trust ){\\n            \\n            int a = pair[0], b = pair[1];\\n            \\n            // decrease one point from p1 when p1 trusts other people\\n            score[ a ] -= 1;\\n            \\n            // increase one point to p2 when p2 is trusted by others\\n            score[ b ] += 1;    \\n        }\\n        \\n        for( int i = 1 ; i <= n ; i++ ){\\n            \\n            // town judge will be trusted by other N-1 people, and town judge trust nobody.\\n            if( score[i] == n-1 ){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n\\n    }\\n}\\n```\n```\\nvar findJudge = function(n, trust) {\\n    \\n    // Quick response for simple case\\n    if( 1 == n ){\\n        return 1;\\n    }\\n    \\n\\t// first cell is dummy, just for the convenience of indexing start from 1 to N\\n    trustScore = Array( n + 1 ).fill( 0 );\\n    \\n    for( const [p1, p2] of trust){\\n        \\n        // decrease one point from p1 when p1 trusts other people\\n        trustScore[p1] -= 1 ;\\n        \\n        // increase one point to p2 when p2 is trusted by others\\n        trustScore[p2] += 1;\\n    }\\n    \\n    \\n    for( let personID = 1 ; personID <= n ; personID++){\\n        \\n        // town judge will be trusted by other N-1 people, and town judge trust nobody.\\n        if( (n - 1) == trustScore[ personID] ){\\n            return personID;\\n        }\\n    }\\n    \\n    return -1;\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        \\n        // Quick response for simple case\\n        if( 1 == n ){\\n            return 1;\\n        }\\n        \\n        // first cell is dummy, just for the convenience of indexing start from 1 to N\\n        vector< int > trustScore(n+1);\\n        \\n        // General cases:\\n        for( auto trustVector : trust){\\n            \\n            int p1 = trustVector[0], p2 = trustVector[1];\\n            \\n\\t\\t\\t// decrease one point from p1 when p1 trusts other people\\n            trustScore[ p1 ] -= 1;\\n\\t\\t\\t\\n\\t\\t\\t// increase one point to p2 when p2 is trusted by others\\n            trustScore[ p2 ] += 1;\\n        }\\n        \\n        for( int personID = 1 ; personID <= n ; personID++ ){\\n            \\n\\t\\t\\t// town judge will be trusted by other N-1 people, and town judge trust nobody.\\n            if( (n - 1) == trustScore[personID]  ){\\n                return personID;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\nfunc findJudge(n int, trust [][]int) int {\\n    \\n    // Quick response on simple case\\n    if 1 == n {\\n        return 1\\n    }\\n    \\n    // first cell is dummy, just for the convenience of indexing start from 1 to N\\n    trustScore := make( []int, n+1)\\n    \\n    // General cases:\\n    for _, trustVector := range trust{\\n        \\n        p1 := trustVector[0]\\n        p2 := trustVector[1]\\n        \\n        // decrease one point from p1 when p1 trusts other people\\n        trustScore[ p1 ] -= 1\\n        \\n        // increase one point to p2 when p2 is trusted by others\\n        trustScore[ p2 ] += 1\\n    }\\n    \\n    for personID := 1 ; personID <= n ; personID++{\\n        \\n        // town judge will be trusted by other N-1 people, and town judge trust nobody.\\n        if ( n - 1 ) == trustScore[ personID ]{\\n            return personID\\n        }\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089016,
                "title": "short-c-java-python-js-explained-solution-beginner-friendly",
                "content": "Read Article for Solution and explaination :\\n\\n# *** https://www.nileshblog.tech/leetcode-a-quick-and-simple-solution-to-find-the-town-judge/ ***\\n\\n**time complexity\\n**The time complexity of the solution to the \"Find the Town Judge\" problem is O(n) where n is the number of trust relationships.\\n\\nThis is because the algorithm consists of two loops. The first loop iterates through the trust array and for each relationship, it decrements the trust count of the citizen and increments the trust count of the judge. This loop takes O(n) time, where n is the number of trust relationships.\\n\\n![WhatsApp Image 2023-01-23 at 11.58.36 AM.jpeg](https://assets.leetcode.com/users/images/3fafe09d-f376-4acc-899e-38dcce37c7da_1674456191.304103.jpeg)\\n\\n\\n\\n\\nhttps://www.nileshblog.tech/2023/01/leetcode-a-quick-and-simple-solution-to-find-the-town-judge/\\n\\n![0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg](https://assets.leetcode.com/users/images/9979257d-d828-4702-a882-a114cd2889de_1674456107.744764.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "Read Article for Solution and explaination :\\n\\n# *** https://www.nileshblog.tech/leetcode-a-quick-and-simple-solution-to-find-the-town-judge/ ***\\n\\n**time complexity\\n**The time complexity of the solution to the \"Find the Town Judge\" problem is O(n) where n is the number of trust relationships.\\n\\nThis is because the algorithm consists of two loops. The first loop iterates through the trust array and for each relationship, it decrements the trust count of the citizen and increments the trust count of the judge. This loop takes O(n) time, where n is the number of trust relationships.\\n\\n![WhatsApp Image 2023-01-23 at 11.58.36 AM.jpeg](https://assets.leetcode.com/users/images/3fafe09d-f376-4acc-899e-38dcce37c7da_1674456191.304103.jpeg)\\n\\n\\n\\n\\nhttps://www.nileshblog.tech/2023/01/leetcode-a-quick-and-simple-solution-to-find-the-town-judge/\\n\\n![0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg](https://assets.leetcode.com/users/images/9979257d-d828-4702-a882-a114cd2889de_1674456107.744764.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 726692,
                "title": "c-commented-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> count(N+1);\\n        \\n        for(int i=0; i < trust.size(); i++)\\n        {\\n            // trust[A][B]  => A trusts B // A can never be judge\\n            count[trust[i][0]] = -1;\\n            \\n            // trust[A][B]  => A trusts B // B will be increased because it is trusted by one person\\n            count[trust[i][1]]++;\\n        }\\n            \\n        for (int i = 1; i <= N; ++i) {\\n            // if someone is trusted by N-1 person, ofcourse he is a judge\\n            if (count[i] == N - 1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> count(N+1);\\n        \\n        for(int i=0; i < trust.size(); i++)\\n        {\\n            // trust[A][B]  => A trusts B // A can never be judge\\n            count[trust[i][0]] = -1;\\n            \\n            // trust[A][B]  => A trusts B // B will be increased because it is trusted by one person\\n            count[trust[i][1]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 282752,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} N\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(N, trust) {\\n    // Initialize array with 1..N\\n    // N + 1, so count is easier \\n    const counts = new Array(N+1).fill(0);\\n    \\n    // Iterate through N people    \\n    for(let [i,j] of trust) {\\n        // If the person trusts somebody, then it does not meet requirement 1\\n        counts[i] -= 1\\n        \\n        // Count the people they trust\\n        counts[j] += 1\\n    }\\n\\n    // If N-1 exists, then its the judge since the judge trusts no one except themselves\\n    // and everyone else trusts the judge, then its N-1\\n    for(let i = 1; i < counts.length; i++) {\\n        if ((N-1) === counts[i]) {\\n            return i;\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(N, trust) {\\n    // Initialize array with 1..N\\n    // N + 1, so count is easier \\n    const counts = new Array(N+1).fill(0);\\n    \\n    // Iterate through N people    \\n    for(let [i,j] of trust) {\\n        // If the person trusts somebody, then it does not meet requirement 1\\n        counts[i] -= 1\\n        \\n        // Count the people they trust\\n        counts[j] += 1\\n    }\\n\\n    // If N-1 exists, then its the judge since the judge trusts no one except themselves\\n    // and everyone else trusts the judge, then its N-1\\n    for(let i = 1; i < counts.length; i++) {\\n        if ((N-1) === counts[i]) {\\n            return i;\\n        }\\n    }\\n    \\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1664022,
                "title": "python-short-solution-explained",
                "content": "For each person let us add -1 if it trusts someone and +1 if someone else trust this person. Then the judge is the person with value `n - 1`.\\n\\n#### Complexity\\nIt is `O(n)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def findJudge(self, N, trust):\\n        if not trust and N == 1:\\n            return 1\\n        cands = [0] * (N+1)\\n        for elem1, elem2 in trust:\\n            cands[elem2] += 1\\n            cands[elem1] -= 1\\n            \\n        return cands.index(N-1) if N-1 in cands else -1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findJudge(self, N, trust):\\n        if not trust and N == 1:\\n            return 1\\n        cands = [0] * (N+1)\\n        for elem1, elem2 in trust:\\n            cands[elem2] += 1\\n            cands[elem1] -= 1\\n            \\n        return cands.index(N-1) if N-1 in cands else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500425,
                "title": "c-3-solutions-same-with-277-find-the-celebrity-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Straight forward**\\n```c++\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<unordered_set<int>> graph(n+1, unordered_set<int>());\\n        for (auto& edge : trust) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].insert(b); // a trust b\\n        }\\n        for (int cand = 1; cand <= n; ++cand) {\\n            if (graph[cand].size() == 0) {\\n                bool isGood = true;\\n                for (int other = 1; other <= n; ++other) {\\n                    if (other == cand) continue;\\n                    if (graph[other].count(cand) == 0) {\\n                        isGood = false;\\n                        break;\\n                    }\\n                }\\n                if (isGood) return cand;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Complexity**\\n- Time: `O(M + N^2)`, where `M <= 10^4` is length of `trust` array, `N <= 1000` is number of people.\\n- Space: `O(M + N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: There is only one townJudge**\\n- Since there is only 1 townJudge, so we choose one `townJudge` who doesn\\'t know other people, by `graph[i].size() == 0`.\\n- Then we check whether all other people know this `townJudge`.\\n```c++\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<unordered_set<int>> graph(n+1, unordered_set<int>());\\n        for (auto& edge : trust) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].insert(b); // a trust b\\n        }\\n        int townJudge = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (graph[i].size() == 0) {\\n                townJudge = i;\\n                break;\\n            }\\n        }\\n         \\n        if (townJudge == -1) return -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (i == townJudge) continue;\\n            if (!graph[i].count(townJudge)) return -1;\\n        }\\n        return townJudge;\\n    }\\n};\\n```\\n**Complexity**\\n- Time: `O(M + N)`, where `M <= 10^4` is length of `trust` array, `N <= 1000` is number of people.\\n- Space: `O(M + N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Count inDegree, outDegree of vertices**\\n- We count inDegree, outDegree of vertices.\\n- Let `degree[i]` is the result of `inDegree[i] + outDegree[i]`.\\n- If `degree[i] == N - 1` then `i` is the town judge.\\n```c++\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> degree(n+1); \\n        for (auto& edge : trust) {\\n            int a = edge[0], b = edge[1]; // a trusts b\\n            --degree[a];\\n            ++degree[b];\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            if (degree[i] == n - 1) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Complexity**\\n- Time: `O(M + N)`, where `M <= 10^4` is length of `trust` array, `N <= 1000` is number of people.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<unordered_set<int>> graph(n+1, unordered_set<int>());\\n        for (auto& edge : trust) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].insert(b); // a trust b\\n        }\\n        for (int cand = 1; cand <= n; ++cand) {\\n            if (graph[cand].size() == 0) {\\n                bool isGood = true;\\n                for (int other = 1; other <= n; ++other) {\\n                    if (other == cand) continue;\\n                    if (graph[other].count(cand) == 0) {\\n                        isGood = false;\\n                        break;\\n                    }\\n                }\\n                if (isGood) return cand;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<unordered_set<int>> graph(n+1, unordered_set<int>());\\n        for (auto& edge : trust) {\\n            int a = edge[0], b = edge[1];\\n            graph[a].insert(b); // a trust b\\n        }\\n        int townJudge = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (graph[i].size() == 0) {\\n                townJudge = i;\\n                break;\\n            }\\n        }\\n         \\n        if (townJudge == -1) return -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (i == townJudge) continue;\\n            if (!graph[i].count(townJudge)) return -1;\\n        }\\n        return townJudge;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> degree(n+1); \\n        for (auto& edge : trust) {\\n            int a = edge[0], b = edge[1]; // a trusts b\\n            --degree[a];\\n            ++degree[b];\\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            if (degree[i] == n - 1) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271851,
                "title": "java-simple-3ms-o-n-solution-no-sets-or-maps",
                "content": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        if(trust.length == 0) return N == 1 ? 1 : -1;\\n        int[] trustCount = new int[N+1];\\n        for(int[] t : trust){\\n            trustCount[t[1]]++;\\n            trustCount[t[0]]--;\\n        }\\n        for(int i = 1; i < trustCount.length;i++){\\n            if(trustCount[i] == N-1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        if(trust.length == 0) return N == 1 ? 1 : -1;\\n        int[] trustCount = new int[N+1];\\n        for(int[] t : trust){\\n            trustCount[t[1]]++;\\n            trustCount[t[0]]--;\\n        }\\n        for(int i = 1; i < trustCount.length;i++){\\n            if(trustCount[i] == N-1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312565,
                "title": "java-simple-and-concise-solution-with-detailed-explanation",
                "content": "```\\n\\t// core logic: use two integer arrays to represent the inward and outward connections on the node\\n    // after storing all values into the two arrays just go through those two arrays and find the person with 0 outward connections and being N-1 inward connections\\n    private static int findJudge(int N, int[][] trust) {\\n\\n        int[] in = new int[N + 1];   // to maintain inward connections to a node (N+1 because N is labelled from 1)\\n        int[] out = new int[N + 1];  // to maintain outward connections from a node (N+1 because N is labelled from 1)\\n\\n        for (int i = 0; i < trust.length; i++) {\\n            in[trust[i][1]]++;   // [i, j] -> j represents the inward connection to that node\\n            out[trust[i][0]]++;  // [i, j] -> i represents the outward connection from that node\\n        }\\n\\n        for (int i = 1; i <= N; i++) {\\n            if (in[i] == N - 1 && out[i] == 0) {   // trust person will have N-1 inward connections (as all the people except him trusts him) and 0 outward connections (trusts no one)\\n                return i;\\n            }\\n        }\\n        return -1;   // return -1 when no trust person exists\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t// core logic: use two integer arrays to represent the inward and outward connections on the node\\n    // after storing all values into the two arrays just go through those two arrays and find the person with 0 outward connections and being N-1 inward connections\\n    private static int findJudge(int N, int[][] trust) {\\n\\n        int[] in = new int[N + 1];   // to maintain inward connections to a node (N+1 because N is labelled from 1)\\n        int[] out = new int[N + 1];  // to maintain outward connections from a node (N+1 because N is labelled from 1)\\n\\n        for (int i = 0; i < trust.length; i++) {\\n            in[trust[i][1]]++;   // [i, j] -> j represents the inward connection to that node\\n            out[trust[i][0]]++;  // [i, j] -> i represents the outward connection from that node\\n        }\\n\\n        for (int i = 1; i <= N; i++) {\\n            if (in[i] == N - 1 && out[i] == 0) {   // trust person will have N-1 inward connections (as all the people except him trusts him) and 0 outward connections (trusts no one)\\n                return i;\\n            }\\n        }\\n        return -1;   // return -1 when no trust person exists\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088368,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=BuNcLpTSXmA&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=23) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\t\\t// indegree (in) = trusted by others\\n\\t\\t// outdegree (out) = trust others\\n        vector<int> in(n + 1), out(n + 1);\\n\\t\\t// calculate the in and out\\n        for (auto x : trust) in[x[1]]++, out[x[0]]++;\\n\\t\\t// iterate each person\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\t// the judge will be the one with indegree = n - 1 and outdegree = 0\\n            if (in[i] == n - 1 && out[i] == 0) {\\n\\t\\t\\t\\t// found the judge\\n                return i;\\n            }\\n        }\\n        // cannot identify -> return -1\\n        return -1;\\n    }\\n};\\n```\\n\\nwe can further simplify it with one array since we know `indegrees - outdegrees = n - 1`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        // n people\\n        vector<int> v(n + 1);\\n        for (auto x : trust) {\\n            // out: trust other\\n            v[x[0]]--;\\n            // in: trusted by others\\n            v[x[1]]++;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            // we are looking for indegrees - outdegrees = n - 1\\n            if (v[i] == n - 1) {\\n                // if so, the i-th person will be the judge\\n                return i;\\n            }\\n        }\\n        // cannot identify -> return -1\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\t\\t// indegree (in) = trusted by others\\n\\t\\t// outdegree (out) = trust others\\n        vector<int> in(n + 1), out(n + 1);\\n\\t\\t// calculate the in and out\\n        for (auto x : trust) in[x[1]]++, out[x[0]]++;\\n\\t\\t// iterate each person\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\t// the judge will be the one with indegree = n - 1 and outdegree = 0\\n            if (in[i] == n - 1 && out[i] == 0) {\\n\\t\\t\\t\\t// found the judge\\n                return i;\\n            }\\n        }\\n        // cannot identify -> return -1\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        // n people\\n        vector<int> v(n + 1);\\n        for (auto x : trust) {\\n            // out: trust other\\n            v[x[0]]--;\\n            // in: trusted by others\\n            v[x[1]]++;\\n        }\\n        for (int i = 1; i <= n; i++) {\\n            // we are looking for indegrees - outdegrees = n - 1\\n            if (v[i] == n - 1) {\\n                // if so, the i-th person will be the judge\\n                return i;\\n            }\\n        }\\n        // cannot identify -> return -1\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624196,
                "title": "c-o-n-easy-graph-modelling-concept-only-arrays-2-solutions",
                "content": "It can be treated as a basic graph modelling question.\\nWe have two arrays in and out to calculate the indegrees of vertices ( people of the town) \\nA person is only a Judge if he is trusted by everybody ( or the out[i] should be equal to N -1 , where N is the total number of people ) and he does not trust anybody ( or the in[i] should be equal to 0 ).\\nHope it helps :)\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        int in[1001]={0};\\n        int out[1001]={0};\\n        for ( auto x : trust){\\n            out[x[1]]++;\\n            in[x[0]]++;\\n        }\\n        for ( int i =1; i <= N ; i ++ ) {\\n            if ( in[i] == 0 && out[i] == N-1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**EDIT**\\n\\nHere\\'s another approach as suggested by [@chotu_coder](https://leetcode.com/chotu__coder)\\nHowever i believe the first one was more intuitive \\n\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        int cnt[1001]={0};\\n        for ( auto x : trust){\\n            cnt[x[0]]--;\\n            cnt[x[1]]++;\\n        }\\n        for ( int i =1; i <=N; i++){\\n            if (cnt[i] == N-1 ) return i;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        int in[1001]={0};\\n        int out[1001]={0};\\n        for ( auto x : trust){\\n            out[x[1]]++;\\n            in[x[0]]++;\\n        }\\n        for ( int i =1; i <= N ; i ++ ) {\\n            if ( in[i] == 0 && out[i] == N-1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        int cnt[1001]={0};\\n        for ( auto x : trust){\\n            cnt[x[0]]--;\\n            cnt[x[1]]++;\\n        }\\n        for ( int i =1; i <=N; i++){\\n            if (cnt[i] == N-1 ) return i;\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088204,
                "title": "easy-solution-fully-explained-c-python3-commented",
                "content": "Consider\\uD83D\\uDC4D\\n```\\n                        Please Upvote If You Find It Helpful.\\n```\\n# Intuition\\nThere is a edge between person1 -> person2, if person1 trust person2.\\n\\nCondition is given that everybody should know the judge but judge should know anybody.\\nSo, we count indegree and outdegree of each gives node.\\nIf the indegree of a node is exactly **N-1** and outdegree is 0 then we return that node.That means he(node) is the judge.\\nOtherwise we return -1.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n       // Initialize indeg and outdeg vectors with size n+1 and set all elements to 0\\n       vector<int> indeg(n+1, 0), outdeg(n+1, 0);\\n       \\n       // Iterate through the trust relationships and increment the indeg and outdeg of the corresponding people\\n       for(auto it : trust){\\n           indeg[it[1]]++;\\n           outdeg[it[0]]++;\\n       }\\n       \\n       // Iterate through the indeg vector\\n       for(int i=1;i<=n;i++)\\n           // Check if a person has n-1 incoming trusts and 0 outgoing trusts\\n           if(indeg[i]==n-1 && outdeg[i]==0)\\n                return i;\\n       \\n       // If no such person found, return -1\\n       return -1;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        # Initialize indeg and outdeg lists with size n+1 and set all elements to 0\\n        indeg = [0] * (n+1)\\n        outdeg = [0] * (n+1)\\n        \\n        # Iterate through the trust relationships and increment the indeg and outdeg of the corresponding people\\n        for i, j in trust:\\n            outdeg[i] += 1\\n            indeg[j] += 1\\n            \\n        # Iterate through the indeg list\\n        for i in range(1, n+1):\\n            # Check if a person has n-1 incoming trusts and 0 outgoing trusts\\n            if indeg[i] == n-1 and outdeg[i] == 0:\\n                return i\\n        \\n        # If no such person found, return -1\\n        return -1\\n\\n```\\n```\\n                                Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Graph"
                ],
                "code": "```\\n                        Please Upvote If You Find It Helpful.\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n       // Initialize indeg and outdeg vectors with size n+1 and set all elements to 0\\n       vector<int> indeg(n+1, 0), outdeg(n+1, 0);\\n       \\n       // Iterate through the trust relationships and increment the indeg and outdeg of the corresponding people\\n       for(auto it : trust){\\n           indeg[it[1]]++;\\n           outdeg[it[0]]++;\\n       }\\n       \\n       // Iterate through the indeg vector\\n       for(int i=1;i<=n;i++)\\n           // Check if a person has n-1 incoming trusts and 0 outgoing trusts\\n           if(indeg[i]==n-1 && outdeg[i]==0)\\n                return i;\\n       \\n       // If no such person found, return -1\\n       return -1;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        # Initialize indeg and outdeg lists with size n+1 and set all elements to 0\\n        indeg = [0] * (n+1)\\n        outdeg = [0] * (n+1)\\n        \\n        # Iterate through the trust relationships and increment the indeg and outdeg of the corresponding people\\n        for i, j in trust:\\n            outdeg[i] += 1\\n            indeg[j] += 1\\n            \\n        # Iterate through the indeg list\\n        for i in range(1, n+1):\\n            # Check if a person has n-1 incoming trusts and 0 outgoing trusts\\n            if indeg[i] == n-1 and outdeg[i] == 0:\\n                return i\\n        \\n        # If no such person found, return -1\\n        return -1\\n\\n```\n```\\n                                Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526541,
                "title": "java-from-naive-to-best-1-ms-all-4-solutions",
                "content": "We dont get 1 ms 100% faster solution in one go. Its a learning step.\\nHere is how I went from worst(complex) to best solution  \\n\\n```java\\n    /**\\n     * Approach 1\\n     * Algorithm : Map and Set\\n     * Logic :  In line Comments\\n     * Time Complexity : O(N)\\n     * Space Complexity : O(N)\\n     * Comments - Not efficient and slow\\n     * Resources:-\\n     */\\n\\n    public static int findJudge(int N, int[][] trust) {\\n\\n        if(trust.length == 0){\\n            if(N == 1) return 1;\\n            return -1;\\n        }\\n        HashSet<Integer> set = new HashSet<>();\\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();\\n\\n        for(int[] i : trust){\\n            set.add(i[1]);\\n        }\\n\\n        for (int[] ints : trust) {\\n            for (int j = 0; j <= 1; j++) {\\n                HashSet<Integer> temp;\\n                if (map.containsKey(ints[0])) {    // people is there add in set\\n                    temp = map.get(ints[0]);\\n                } else {\\n                    temp = new HashSet<>();\\n                }\\n\\n                temp.add(ints[1]);\\n                map.put(ints[0], temp);\\n                set.remove(ints[0]);\\n            }\\n        }\\n        int res = -1;\\n        if(set.size() == 1){\\n\\n            Iterator<Integer> itr = set.iterator();\\n            int judge = itr.next();\\n\\n            if(map.containsKey(judge)) return -1;\\n\\n            for (Map.Entry<Integer, HashSet<Integer>> e : map.entrySet()) {\\n\\n                HashSet<Integer> temp = e.getValue();\\n                if (!temp.contains(judge)) return -1;\\n            }\\n            res = judge;\\n        }\\n        return res;\\n    }\\n\\n\\n    /**\\n     * Approach 2\\n     * Algorithm : Graph\\n     * Logic :  Put it in Adajency Matrix and row who sum == 0 and col whose sum == n-1 must be same is answer\\n     * Time Complexity : O(N)\\n     * Space Complexity : O(N^2)\\n     * Comments -\\n     * Resources:-\\n     */\\n\\n    public static int findJudge2(int N, int[][] trust) {\\n\\n        int[][] adj = new int[N+1][N+1];\\n\\n        int[] horizontal = new int[N+1];    // Sum of values in row for i\\n        int[] vertical = new int[N+1];      // Sum of values in col for i\\n\\n        for (int[] ints : trust) {\\n            int a = ints[0];\\n            int b = ints[1];\\n            horizontal[a] += 1;\\n            vertical[b] += 1;\\n            adj[a][b] = 1;\\n        }\\n\\n        int judge = -1;\\n\\n        for(int i = 1 ; i <= N ;i++){\\n            if(horizontal[i] == 0 && vertical[i] == N-1)\\n                judge = i;\\n        }\\n\\n        return judge;\\n    }\\n\\n    // I was not even using adj matrix, thanks to IntelliJ for highlighting it,\\n    // I got the idea\\n\\n    /**\\n     * Approach 3\\n     * Algorithm : Graph, Two Array Storage\\n     * Logic :  Using Above idea, we dont need adj matrix to calculate in degree or out degree\\n     * you can calculate without adj matrix too.\\n     * Time Complexity : O(N)\\n     * Space Complexity : O(N)\\n     * Comments -\\n     * Resources:-\\n     */\\n\\n    public static int findJudge3(int N, int[][] trust) {\\n\\n        int[] in = new int[N+1];\\n        int[] out = new int[N+1];\\n\\n        for( int[] i : trust){\\n            out[i[0]]++;\\n            in[i[1]]++;\\n        }\\n\\n        for( int i =1 ; i <= N ; i++)\\n            if(in[i] == N-1 && out[i] == 0)\\n                return i;\\n\\n\\n        return -1;\\n    }\\n\\n    /**\\n     * Approach 4\\n     * Algorithm : Graph, One Array\\n     * Logic :  Using Above idea, we dont need adj matrix to calculate in degree or out degree\\n     * you can calculate normally also.\\n     * Time Complexity : O(N)\\n     * Space Complexity : O(N)\\n     * Comments -\\n     * Resources:-\\n     */\\n\\n    public static int findJudge4(int N, int[][] trust) {\\n\\n        int[] degree = new int[N+1];\\n\\n        for( int[] i : trust){\\n            degree[i[0]]--;\\n            degree[i[1]]++;\\n        }\\n\\n        for( int i =1 ; i <= N ; i++)\\n            if(degree[i] == N-1)\\n                return i;\\n\\n\\n        return -1;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```java\\n    /**\\n     * Approach 1\\n     * Algorithm : Map and Set\\n     * Logic :  In line Comments\\n     * Time Complexity : O(N)\\n     * Space Complexity : O(N)\\n     * Comments - Not efficient and slow\\n     * Resources:-\\n     */\\n\\n    public static int findJudge(int N, int[][] trust) {\\n\\n        if(trust.length == 0){\\n            if(N == 1) return 1;\\n            return -1;\\n        }\\n        HashSet<Integer> set = new HashSet<>();\\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();\\n\\n        for(int[] i : trust){\\n            set.add(i[1]);\\n        }\\n\\n        for (int[] ints : trust) {\\n            for (int j = 0; j <= 1; j++) {\\n                HashSet<Integer> temp;\\n                if (map.containsKey(ints[0])) {    // people is there add in set\\n                    temp = map.get(ints[0]);\\n                } else {\\n                    temp = new HashSet<>();\\n                }\\n\\n                temp.add(ints[1]);\\n                map.put(ints[0], temp);\\n                set.remove(ints[0]);\\n            }\\n        }\\n        int res = -1;\\n        if(set.size() == 1){\\n\\n            Iterator<Integer> itr = set.iterator();\\n            int judge = itr.next();\\n\\n            if(map.containsKey(judge)) return -1;\\n\\n            for (Map.Entry<Integer, HashSet<Integer>> e : map.entrySet()) {\\n\\n                HashSet<Integer> temp = e.getValue();\\n                if (!temp.contains(judge)) return -1;\\n            }\\n            res = judge;\\n        }\\n        return res;\\n    }\\n\\n\\n    /**\\n     * Approach 2\\n     * Algorithm : Graph\\n     * Logic :  Put it in Adajency Matrix and row who sum == 0 and col whose sum == n-1 must be same is answer\\n     * Time Complexity : O(N)\\n     * Space Complexity : O(N^2)\\n     * Comments -\\n     * Resources:-\\n     */\\n\\n    public static int findJudge2(int N, int[][] trust) {\\n\\n        int[][] adj = new int[N+1][N+1];\\n\\n        int[] horizontal = new int[N+1];    // Sum of values in row for i\\n        int[] vertical = new int[N+1];      // Sum of values in col for i\\n\\n        for (int[] ints : trust) {\\n            int a = ints[0];\\n            int b = ints[1];\\n            horizontal[a] += 1;\\n            vertical[b] += 1;\\n            adj[a][b] = 1;\\n        }\\n\\n        int judge = -1;\\n\\n        for(int i = 1 ; i <= N ;i++){\\n            if(horizontal[i] == 0 && vertical[i] == N-1)\\n                judge = i;\\n        }\\n\\n        return judge;\\n    }\\n\\n    // I was not even using adj matrix, thanks to IntelliJ for highlighting it,\\n    // I got the idea\\n\\n    /**\\n     * Approach 3\\n     * Algorithm : Graph, Two Array Storage\\n     * Logic :  Using Above idea, we dont need adj matrix to calculate in degree or out degree\\n     * you can calculate without adj matrix too.\\n     * Time Complexity : O(N)\\n     * Space Complexity : O(N)\\n     * Comments -\\n     * Resources:-\\n     */\\n\\n    public static int findJudge3(int N, int[][] trust) {\\n\\n        int[] in = new int[N+1];\\n        int[] out = new int[N+1];\\n\\n        for( int[] i : trust){\\n            out[i[0]]++;\\n            in[i[1]]++;\\n        }\\n\\n        for( int i =1 ; i <= N ; i++)\\n            if(in[i] == N-1 && out[i] == 0)\\n                return i;\\n\\n\\n        return -1;\\n    }\\n\\n    /**\\n     * Approach 4\\n     * Algorithm : Graph, One Array\\n     * Logic :  Using Above idea, we dont need adj matrix to calculate in degree or out degree\\n     * you can calculate normally also.\\n     * Time Complexity : O(N)\\n     * Space Complexity : O(N)\\n     * Comments -\\n     * Resources:-\\n     */\\n\\n    public static int findJudge4(int N, int[][] trust) {\\n\\n        int[] degree = new int[N+1];\\n\\n        for( int[] i : trust){\\n            degree[i[0]]--;\\n            degree[i[1]]++;\\n        }\\n\\n        for( int i =1 ; i <= N ; i++)\\n            if(degree[i] == N-1)\\n                return i;\\n\\n\\n        return -1;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405898,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} N\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(N, trust) {\\n    const truster = Array(N).fill(0); // keep track of count of people this person trusts\\n    const trustee = Array(N).fill(0); // keep track of count of people that trust this person\\n    \\n    for(let i = 0; i < trust.length; i++) {\\n        let [a, b] = trust[i];\\n        a--; //get indexes correct\\n        b--;\\n        \\n        truster[a]++;\\n        trustee[b]++;\\n    }\\n    \\n    for(let i = 0; i < N; i++) {\\n        if (truster[i] == 0 && trustee[i] == N - 1) {\\n            return i + 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n\\t",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(N, trust) {\\n    const truster = Array(N).fill(0); // keep track of count of people this person trusts\\n    const trustee = Array(N).fill(0); // keep track of count of people that trust this person\\n    \\n    for(let i = 0; i < trust.length; i++) {\\n        let [a, b] = trust[i];\\n        a--; //get indexes correct\\n        b--;\\n        \\n        truster[a]++;\\n        trustee[b]++;\\n    }\\n    \\n    for(let i = 0; i < N; i++) {\\n        if (truster[i] == 0 && trustee[i] == N - 1) {\\n            return i + 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1664132,
                "title": "c-simple-and-short-solution-explained",
                "content": "We are trying to find a number that doesn\\'t trust anyone -> doesn\\'t appear in the left side of a connection, and everyone trusts it -> has all other numbers in it\\'s left side.\\nSo we use a helping vector `trust_judge`.\\nFor each time we see a number in the left side, we decrement one, and in the right side - we increment one.\\nNow, at the end, if the number is a judge, we should have exactly `n-1`, because we saw it n-1 times in the right side and none in the left side.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> trust_judge(n+1, 0);\\n        \\n        for (auto t : trust) {\\n            trust_judge[t[0]]--;\\n            trust_judge[t[1]]++;\\n        }\\n        \\n        for (int i = 1; i <= n; i++)\\n            if (trust_judge[i] == n-1) return i;\\n        \\n        return -1;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> trust_judge(n+1, 0);\\n        \\n        for (auto t : trust) {\\n            trust_judge[t[0]]--;\\n            trust_judge[t[1]]++;\\n        }\\n        \\n        for (int i = 1; i <= n; i++)\\n            if (trust_judge[i] == n-1) return i;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357660,
                "title": "c-beats-88-96-time-and-100-space",
                "content": "The idea of the problem is to find that vertice whose indegree is N-1 and out degree is 0.\\n\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        \\n        vector<int> in(N+1);\\n        vector<int> out(N+1);\\n        int jud = -1;\\n        \\n        for(int i=0;i<trust.size();i++)\\n        {\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        \\n        for(int i=1;i<=N;i++)\\n        {\\n            //cout<<in[i]<<endl;\\n            if(in[i]==N-1 && out[i]==0)\\n            {\\n                jud = i;\\n            }\\n        }\\n        \\n        return jud;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        \\n        vector<int> in(N+1);\\n        vector<int> out(N+1);\\n        int jud = -1;\\n        \\n        for(int i=0;i<trust.size();i++)\\n        {\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3088016,
                "title": "c-easy-to-understand-simple-code-explained",
                "content": "**Consider a graph**\\n#There is an edge from person1->person2, if person1 trusts person2\\n\\n**Town Judge Criteria**\\n**1. Town Judge trusts nobody**\\nThere is no outgoing edge from town judge\\n\\n**2. Everybody (except town judge) trusts town judge**\\nIf there are \"N\" people(including town judge), then \"N-1\" people will trust town judge\\nThus there will be exactly \"N-1\" incoming edges into town judge\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n        vector<int>inDegree(n + 1, 0);\\n        vector<int>outDegree(n + 1, 0);\\n        for (vector<int>&currTrust : trust)\\n        {\\n            int trustedPerson = currTrust[1];\\n            int trustingPerson = currTrust[0];\\n            inDegree[trustedPerson]++;\\n            outDegree[trustingPerson]++;\\n        }\\n        //============================================================\\n        for (int person = 1; person <= n; person++)\\n        {\\n            if ((inDegree[person] == (n - 1)) && (outDegree[person] == 0))\\n                return person;\\n        }\\n        //===============================================================\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n        vector<int>inDegree(n + 1, 0);\\n        vector<int>outDegree(n + 1, 0);\\n        for (vector<int>&currTrust : trust)\\n        {\\n            int trustedPerson = currTrust[1];\\n            int trustingPerson = currTrust[0];\\n            inDegree[trustedPerson]++;\\n            outDegree[trustingPerson]++;\\n        }\\n        //============================================================\\n        for (int person = 1; person <= n; person++)\\n        {\\n            if ((inDegree[person] == (n - 1)) && (outDegree[person] == 0))\\n                return person;\\n        }\\n        //===============================================================\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243189,
                "title": "detailed-explanation",
                "content": "**Claim 1** ---- There can be only one judge satisfying the conditions 1 and 2. The third statement ***There must be only one person satisfying the above 2 criteria*** is a red-herring.\\n\\n**Proof** ------ Suppose there are actually 2 judges satisfying criteria `1` and `2`. It implies that judge 1 does not trust anybody, It means that the maximum number of trust any other person can have is equal to `(n-2)` [Since a person trusting himself is not being counted]. This implies that person 2 cannot be a judge, as trust count of person 2 can never be equal to `(n-1)`. Hence, we have a contradiction. \\n\\n\\nSo now, we only have to worry about finding out a single judge without worrying about *false positives*.\\n\\n\\nTo accomplish this we make an array `trustCount` which stores the number of person who trust the `i-th` person at the `i-th` index.\\nFurther, we also maintain a *boolean* array `trusts_Some_One` which stores ***true*** at the `i-th` position if the `i-th` person trusts someone.\\n\\nNow we traverse each person and check if `(n-1)` people trust him or not. If yes, we also confirm that he does not trust anybody. If both criteria is met, we terminate immediately as there can be only a sinlge judge.\\n\\n**Miscellaneous** ----- \\n1) The persons are numbered from `1` to `n`. Hence the `0-th` element of the array is never accessed. \\n2) While updating, we traverse the trust vector, and for each entry of the form `[a,b]`, we call `a` as the **currentPerson** and `b` as the **secondPerson**, implying that the first person trusts the second person. Hence we update the counts accordingly.\\n\\n```\\n/* Returns the identity of the town judge, else returns -1 */\\nint Solution :: findJudge(int n, vector<vector<int>>& trust)\\n{\\n    /* trustCount[i] denotes the number of people who trust the i\\'th person */\\n    vector<int> trustCount(n+1);\\n    \\n    /* trusts_Some_one[i] is true if the i\\'th person trusts any other person */\\n    vector<bool> trusts_Some_one(n+1);\\n    \\n    // Traverse the trust vector and update trust count and trusts_Some_one\\n    for(auto row_vec:trust)\\n    {\\n        // The current person trusts the next person\\n        int currentPerson = row_vec[0];\\n        int nextPerson = row_vec[1];\\n        \\n        // The currentPerson trusts the next person, so he does trust some one \\n        trusts_Some_one[currentPerson] = true;\\n        \\n        // The current person trusts the next person, so increase the trust count of the next person\\n        trustCount[nextPerson] ++;\\n    }\\n    \\n    // Traverse each person and check if he is suitable for judge or not\\n    for(int person=1; person<=n; person++)\\n        if(trustCount[person] == (n-1) && trusts_Some_one[person]==false)\\n                return person;\\n    \\n    // If it reaches here, it means no person can be a judge, return -1 */\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* Returns the identity of the town judge, else returns -1 */\\nint Solution :: findJudge(int n, vector<vector<int>>& trust)\\n{\\n    /* trustCount[i] denotes the number of people who trust the i\\'th person */\\n    vector<int> trustCount(n+1);\\n    \\n    /* trusts_Some_one[i] is true if the i\\'th person trusts any other person */\\n    vector<bool> trusts_Some_one(n+1);\\n    \\n    // Traverse the trust vector and update trust count and trusts_Some_one\\n    for(auto row_vec:trust)\\n    {\\n        // The current person trusts the next person\\n        int currentPerson = row_vec[0];\\n        int nextPerson = row_vec[1];\\n        \\n        // The currentPerson trusts the next person, so he does trust some one \\n        trusts_Some_one[currentPerson] = true;\\n        \\n        // The current person trusts the next person, so increase the trust count of the next person\\n        trustCount[nextPerson] ++;\\n    }\\n    \\n    // Traverse each person and check if he is suitable for judge or not\\n    for(int person=1; person<=n; person++)\\n        if(trustCount[person] == (n-1) && trusts_Some_one[person]==false)\\n                return person;\\n    \\n    // If it reaches here, it means no person can be a judge, return -1 */\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088509,
                "title": "python-well-explained-beginner-friendly",
                "content": "# Intituation:\\nA person can be label as judge only if he follows this two criteria\\n\\n1. he is trusted by n-1 persons\\n2. he dont trust anyone.(means no. of people he trust is zero)\\n\\nSo there will be only one person who follow this criteria , if nobody follows this criteria then we will return -1 \\n\\n# Approach:\\nWe will start by iterating the whole trust list and update the list `l`,where every element has two value which where 0th value means `ith` guy trust these much people and 1th value mean `ith` guy is trusted by these much people.\\n\\nAfter this we will iterate the list and check if any person is satifying the conditions or not, if we find someone then just return him and if nobody is satisfying that condition then return -1.\\n# Complexity:\\n**time complexity :** O(m+n) where m is length of trust and n is no. of person in n that Town. so it is simply O(N) \\n**space complexity :** 0(N)\\n \\n# Code\\n```\\n\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        l=[[0,0] for x in range(n+1)]\\n        for i in trust:\\n            l[i[1]][1]+=1\\n            l[i[0]][0]+=1\\n        for i in range(1,len(l)):\\n            if l[i][0]==0 and l[i][1]==n-1:\\n                return i    \\n        return -1        \\n```\\n **UPVOTE IF YOU FIND THIS HELPFUL**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        l=[[0,0] for x in range(n+1)]\\n        for i in trust:\\n            l[i[1]][1]+=1\\n            l[i[0]][0]+=1\\n        for i in range(1,len(l)):\\n            if l[i][0]==0 and l[i][1]==n-1:\\n                return i    \\n        return -1        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663306,
                "title": "c-intuitive-solution-w-explanation",
                "content": "* The 2 conditions here are : \\n      1. Everyone trusts the town judge\\n      2. The town judge trusts no one\\n      \\n**APPROACH :**\\n\\n* We can solve this problem using indegree & outdegree of a node in a graph.\\n* If person ```a``` trusts person ```b```, there\\'s an outgoing edge ```from a to b```. and an incoming edge ```to b from a```.\\n* So the **town judge** has ```n-1``` incoming edges & ```0``` outgoing edges.\\n\\n**ALGORITHM :** \\n\\n* Create an array ```inout``` in which ```inout[i]``` stores the sum of indegree & outdegree of person ```i```(outdegree is -ve & indegree is +ve).\\n* We traverse the ```trust``` array, & for every element ```t``` in ```trust``` we do ```t[0]--``` (outdegree - ```t[0]``` trusts ```t[1]```) & ```t[1]++``` (indegree - ```t[1]``` has gained trust of ```t[0]```).\\n* Finally, we traverse the count array & for any i if ```count[i] == n-1```, then that person trusts no one & everone(all ```n-1``` persons) trusts that person. So we return ```i```.\\n\\nTime Complexity : O(N); N= ```trust.size()```\\n\\nAuxiliary Space : O(n); n = no. of people (The first line in the input)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> inout(n+1, 0);\\n        \\n        for(auto t : trust){\\n            inout[t[0]]--; //outdegree of a node\\n            inout[t[1]]++; //indegree of a node\\n        }\\n        for(int i=1; i<n+1; i++){   //there are n people labelled from 1 to n\\n            if(inout[i]==n-1) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nDo upvote if you like the solution & explanation :)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```a```\n```b```\n```from a to b```\n```to b from a```\n```n-1```\n```0```\n```inout```\n```inout[i]```\n```i```\n```trust```\n```t```\n```trust```\n```t[0]--```\n```t[0]```\n```t[1]```\n```t[1]++```\n```t[1]```\n```t[0]```\n```count[i] == n-1```\n```n-1```\n```i```\n```trust.size()```\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> inout(n+1, 0);\\n        \\n        for(auto t : trust){\\n            inout[t[0]]--; //outdegree of a node\\n            inout[t[1]]++; //indegree of a node\\n        }\\n        for(int i=1; i<n+1; i++){   //there are n people labelled from 1 to n\\n            if(inout[i]==n-1) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663192,
                "title": "python3-easy-to-understand-code-explained",
                "content": "We solve this problem in 2 steps. First, calculate the number of people that trust a person `i`, and also the number of people the person `i` trusts to. Then, on the second step, we iterate over all people and check for which person all conditions are satisfied.\\n\\nTime: **O(n)** - scan\\nSpace: **O(n)** - hashmaps\\n\\n```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        trust_to, trusted = defaultdict(int), defaultdict(int)\\n\\n        for a, b in trust:\\n            trust_to[a] += 1\\n            trusted[b] += 1\\n        \\n        for i in range(1, n+1):\\n            if trust_to[i] == 0 and trusted[i] == n - 1:\\n                return i\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        trust_to, trusted = defaultdict(int), defaultdict(int)\\n\\n        for a, b in trust:\\n            trust_to[a] += 1\\n            trusted[b] += 1\\n        \\n        for i in range(1, n+1):\\n            if trust_to[i] == 0 and trusted[i] == n - 1:\\n                return i\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397707,
                "title": "ruby-graph-solution-very-easy-to-understand",
                "content": "```\\n  degrees = Array.new(n+1, 0) # In degree - Out degree\\n  trust.each { |a,b|\\n    degrees[a] -= 1\\n    degrees[b] += 1\\n  }\\n  p degrees\\n  (1..n).each { |i| return i if degrees[i] == n-1 } # n-1 people should trust town judge\\n  -1\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Graph"
                ],
                "code": "```\\n  degrees = Array.new(n+1, 0) # In degree - Out degree\\n  trust.each { |a,b|\\n    degrees[a] -= 1\\n    degrees[b] += 1\\n  }\\n  p degrees\\n  (1..n).each { |i| return i if degrees[i] == n-1 } # n-1 people should trust town judge\\n  -1\\nend\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3088528,
                "title": "c-easy-solution-hashmap-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFHashMap Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/YpXyjcb2/shared\" frameBorder=\"0\" width=\"800\" height=\"530\"></iframe>\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFHashMap Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/YpXyjcb2/shared\" frameBorder=\"0\" width=\"800\" height=\"530\"></iframe>\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1663776,
                "title": "python-directed-graph-solution-explained",
                "content": "Think of this problem as a directed graph, let us visualise the given examples below\\n\\n![image](https://assets.leetcode.com/users/images/bdd2d6ae-2234-45be-a3d5-cac01d29cc7f_1641192313.9838896.png)\\nSo according to the question. The judge trusts nobody i.e., the number of outward egdes must be zero and everyone else trusts the judge i.e., the number of inward egdes is n-1. So we can keep an array degree and calculate the absolute degree and figure out if there exist a judge.\\n\\n```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        degree = [0]*(n+1)\\n        \\n        # calculate the absolute degree\\n        for x,y in trust:\\n            degree[x]-=1\\n            degree[y]+=1\\n            \\n        # find the node with degree n-1\\n        for i in range(1,n+1):\\n            if degree[i] == n-1: return i\\n            \\n        # if no node is a valid judge\\n        return -1\\n```\\n\\n***Upvote, If the explanation helped***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        degree = [0]*(n+1)\\n        \\n        # calculate the absolute degree\\n        for x,y in trust:\\n            degree[x]-=1\\n            degree[y]+=1\\n            \\n        # find the node with degree n-1\\n        for i in range(1,n+1):\\n            if degree[i] == n-1: return i\\n            \\n        # if no node is a valid judge\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247578,
                "title": "c-easiest-solution-with-explanation-for-beginners",
                "content": "Indegree and Outdegree based approach.\\nIndegree of a node is the number of edges coming \\'in\\' to that node.Similary outdegree is defined as the number of nodes going \\'out\\' of that node.\\nPlease note that Indegree and Outdegree is defined for Directed Graphs.\\nThe two conditions in the description in terms of Indegree and Outdegree are as follows:\\n1) Outdegree of the Judge node will be 0.\\n2) InDegree of the Judge node will be n-1.\\n\\n**Here is the code:**\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int outDeg[n+1],inDeg[n+1];\\n        memset(outDeg,0,sizeof(outDeg));\\n        memset(inDeg,0,sizeof(inDeg));\\n        int m=trust.size();\\n        for(int i=0;i<m;i++){\\n            outDeg[trust[i][0]]++;\\n            inDeg[trust[i][1]]++;\\n        }\\n        for(int i=1;i<=n;i++)if(outDeg[i]==0&&inDeg[i]==n-1)return i;\\n        return -1;\\n    }\\n};\\n```\\nHope it helps :)\\nPlease upvote.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int outDeg[n+1],inDeg[n+1];\\n        memset(outDeg,0,sizeof(outDeg));\\n        memset(inDeg,0,sizeof(inDeg));\\n        int m=trust.size();\\n        for(int i=0;i<m;i++){\\n            outDeg[trust[i][0]]++;\\n            inDeg[trust[i][1]]++;\\n        }\\n        for(int i=1;i<=n;i++)if(outDeg[i]==0&&inDeg[i]==n-1)return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880345,
                "title": "python-solution-beats-98-runtime",
                "content": "\\t\\tclass Solution:\\n\\t\\t\\tdef findJudge(self, N: int, trust: List[List[int]]) -> int:\\n\\t\\t\\t\\t  count = [0]*(N+1)\\n\\t\\t\\t\\t  for i,j in trust:\\n\\t\\t\\t\\t\\tcount[i]-=1#outdegree\\n\\t\\t\\t\\t\\tcount[j]+=1#indegree\\n\\t\\t\\t\\t  #print(count)\\n\\t\\t\\t\\t  for i in range(1,N+1):\\n\\t\\t\\t\\t\\tif count[i] == N-1:\\n\\t\\t\\t\\t\\t  return i\\n\\t\\t\\t\\t  return -1",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "\\t\\tclass Solution:\\n\\t\\t\\tdef findJudge(self, N: int, trust: List[List[int]]) -> int:\\n\\t\\t\\t\\t  count = [0]*(N+1)\\n\\t\\t\\t\\t  for i,j in trust:\\n\\t\\t\\t\\t\\tcount[i]-=1#outdegree\\n\\t\\t\\t\\t\\tcount[j]+=1#indegree\\n\\t\\t\\t\\t  #print(count)\\n\\t\\t\\t\\t  for i in range(1,N+1):\\n\\t\\t\\t\\t\\tif count[i] == N-1:\\n\\t\\t\\t\\t\\t  return i\\n\\t\\t\\t\\t  return -1",
                "codeTag": "Java"
            },
            {
                "id": 3089234,
                "title": "c-use-hashmap-simpe-efficient-approach",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n        vector<int> judge(n+1);\\n        \\n        for(auto it:trust)\\n        {\\n            judge[it[0]]--; //substract 1 from person who trusts other\\n            judge[it[1]]++; //add 1 to person who is trusted by other\\n        }\\n        \\n        //So the judge will be the person who get (n-1) trust count\\n        //because he doesn\\'t trust himself (mentioned)\\n        for(int i=1; i<=n; i++)\\n            if(judge[i]==n-1) return i;\\n        \\n        //when no such person exist\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n        vector<int> judge(n+1);\\n        \\n        for(auto it:trust)\\n        {\\n            judge[it[0]]--; //substract 1 from person who trusts other\\n            judge[it[1]]++; //add 1 to person who is trusted by other\\n        }\\n        \\n        //So the judge will be the person who get (n-1) trust count\\n        //because he doesn\\'t trust himself (mentioned)\\n        for(int i=1; i<=n; i++)\\n            if(judge[i]==n-1) return i;\\n        \\n        //when no such person exist\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088048,
                "title": "simplest-readable-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        if N == 1:\\n            return 1\\n\\n        trusts = [0] * (N + 1)\\n        istrusted_by = [0] * (N + 1)\\n\\n        for a, b in trust:\\n            trusts[a] += 1\\n            istrusted_by[b] += 1\\n\\n        for i in range(1, N + 1):\\n            if trusts[i] == 0 and istrusted_by[i] == N - 1:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        if N == 1:\\n            return 1\\n\\n        trusts = [0] * (N + 1)\\n        istrusted_by = [0] * (N + 1)\\n\\n        for a, b in trust:\\n            trusts[a] += 1\\n            istrusted_by[b] += 1\\n\\n        for i in range(1, N + 1):\\n            if trusts[i] == 0 and istrusted_by[i] == N - 1:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087991,
                "title": "daily-leetcoding-challenge-january-day-23",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1552756,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn find_judge(n: i32, trust: Vec<Vec<i32>>) -> i32 {\\n        if n == 1 {\\n            return n;\\n        }\\n\\n        let mut counter = vec![0; (n + 1) as usize];\\n        trust.iter().for_each(|pair| {\\n            counter[pair[0] as usize] -= 1;\\n            counter[pair[1] as usize] += 1;\\n        });\\n\\n        counter\\n            .iter()\\n            .position(|&num| num == n - 1)\\n            .map_or(-1, |i| i as i32)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_judge(n: i32, trust: Vec<Vec<i32>>) -> i32 {\\n        if n == 1 {\\n            return n;\\n        }\\n\\n        let mut counter = vec![0; (n + 1) as usize];\\n        trust.iter().for_each(|pair| {\\n            counter[pair[0] as usize] -= 1;\\n            counter[pair[1] as usize] += 1;\\n        });\\n\\n        counter\\n            .iter()\\n            .position(|&num| num == n - 1)\\n            .map_or(-1, |i| i as i32)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891189,
                "title": "using-degree",
                "content": "```\\n// https://leetcode.com/problems/find-the-town-judge/\\n\\n// Solution : We will use Degree concept.Town Judge have 0 outDegree and N-1 inDegree.\\n// Time Complexity - O(N), Space Complexity - O(N)\\n\\nclass Solution\\n{\\npublic:\\n    int findJudge(int N, vector<vector<int>> &trust)\\n    {\\n        vector<int> degree(N + 1);\\n        for (int i = 0; i < trust.size(); i++)\\n        {\\n            degree[trust[i][0]]--; // outDegree\\n            degree[trust[i][1]]++; // inDegree\\n        }\\n\\n        for (int i = 1; i <= N; i++)\\n        {\\n            if (degree[i] == N - 1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\n// https://leetcode.com/problems/find-the-town-judge/\\n\\n// Solution : We will use Degree concept.Town Judge have 0 outDegree and N-1 inDegree.\\n// Time Complexity - O(N), Space Complexity - O(N)\\n\\nclass Solution\\n{\\npublic:\\n    int findJudge(int N, vector<vector<int>> &trust)\\n    {\\n        vector<int> degree(N + 1);\\n        for (int i = 0; i < trust.size(); i++)\\n        {\\n            degree[trust[i][0]]--; // outDegree\\n            degree[trust[i][1]]++; // inDegree\\n        }\\n\\n        for (int i = 1; i <= N; i++)\\n        {\\n            if (degree[i] == N - 1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088701,
                "title": "very-simple-c-python-java-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply we have to check if there is an elemnt from 1 to n which doesnot trust on nobody so check its occurence is zero in left half i.e trust[i][0] and second thing check if its occurence in second half i.e trust[i][1] is n-1 beacuse all other n-1 should trust on him if these two conditions are there then we have Judge else -1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Conditions:\\n- Check in trust[i][0]\\'s which element has 0 occurence because judge dont trust of anybody so use a map and check .Also if greater than one people are there who have 0 occurence then ans is -1 because Judge can be only one .\\n- After getting this element check in trust array i.e on right side trust[i][1]\\'s if its occurence is n-1 if yes return that element if not -1.\\n**HelpFull?UpVote\\uD83D\\uDD3C:\\u2B50**\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**C++ CODE**\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& t) {\\n\\n        unordered_map<int,int>mp;\\n        for(auto x:t){\\n            mp[x[0]]=x[1];\\n        }\\n        int ans=-1,c=0;\\n        // check which element has 0 occurence\\n        for(int i=1;i<=n;i++){\\n            if(mp[i]==0)ans=i,c++;\\n        // if geater than 1 has 0 occurence return -1\\n        if(c>1)return -1;\\n        }\\n        c=0;\\n       // check if this element has n-1 trusties\\n        for(auto x:t){\\n            if(x[1]==ans)c++;\\n        }\\n        if(c==n-1)return ans;\\n\\n        return -1;\\n    }\\n};\\n```\\n**PYTHON CODE**\\n```\\ndef findJudge(self, n: int, t: List[List[int]]) -> int:\\n        mp = {}\\n        for x in t:\\n            mp[x[0]] = x[1]\\n        ans = -1\\n        c = 0\\n        for i in range(1, n+1):\\n            if i not in mp:\\n                ans = i\\n                c += 1\\n        if c > 1:\\n            return -1\\n        c = 0\\n        for x in t:\\n            if x[1] == ans:\\n                c += 1\\n        if c == n-1:\\n            return ans\\n        return -1\\n```\\n**Java Code**\\n```\\npublic int findJudge(int N, int[][] trust) {\\n        \\n    Map<Integer, Integer> mp = new HashMap<>();\\n        for (int[] t : trust) {\\n            mp.put(t[0], t[1]);\\n        }\\n        int ans = -1, c = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (!mp.containsKey(i)) {\\n                ans = i;\\n                c++;\\n            }\\n        }\\n        if (c > 1)\\n            return -1;\\n        c = 0;\\n        for (int[] t : trust) {\\n            if (t[1] == ans)\\n                c++;\\n        }\\n        if (c == N - 1)\\n            return ans;\\n\\n        return -1;\\n    }\\n```\\n**NOTE: Do Upvote\\uD83D\\uDD3C**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& t) {\\n\\n        unordered_map<int,int>mp;\\n        for(auto x:t){\\n            mp[x[0]]=x[1];\\n        }\\n        int ans=-1,c=0;\\n        // check which element has 0 occurence\\n        for(int i=1;i<=n;i++){\\n            if(mp[i]==0)ans=i,c++;\\n        // if geater than 1 has 0 occurence return -1\\n        if(c>1)return -1;\\n        }\\n        c=0;\\n       // check if this element has n-1 trusties\\n        for(auto x:t){\\n            if(x[1]==ans)c++;\\n        }\\n        if(c==n-1)return ans;\\n\\n        return -1;\\n    }\\n};\\n```\n```\\ndef findJudge(self, n: int, t: List[List[int]]) -> int:\\n        mp = {}\\n        for x in t:\\n            mp[x[0]] = x[1]\\n        ans = -1\\n        c = 0\\n        for i in range(1, n+1):\\n            if i not in mp:\\n                ans = i\\n                c += 1\\n        if c > 1:\\n            return -1\\n        c = 0\\n        for x in t:\\n            if x[1] == ans:\\n                c += 1\\n        if c == n-1:\\n            return ans\\n        return -1\\n```\n```\\npublic int findJudge(int N, int[][] trust) {\\n        \\n    Map<Integer, Integer> mp = new HashMap<>();\\n        for (int[] t : trust) {\\n            mp.put(t[0], t[1]);\\n        }\\n        int ans = -1, c = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (!mp.containsKey(i)) {\\n                ans = i;\\n                c++;\\n            }\\n        }\\n        if (c > 1)\\n            return -1;\\n        c = 0;\\n        for (int[] t : trust) {\\n            if (t[1] == ans)\\n                c++;\\n        }\\n        if (c == N - 1)\\n            return ans;\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975159,
                "title": "java-easy-line-by-line-explanation",
                "content": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        \\n        // note the +1 so we can directly map 1->N in array since person count starts from 1 - N, leaving out 0 - no person mapped here\\n        int[] trustCount = new int[N+1];\\n        \\n        /*\\n            Imagine trust like a gold coin\\n            if a person gives turst -> Giver loses one gold coin\\n                                    -> receiver gets one gold coin;\\n                                    \\n            since townJudge trusts nobody ( gives nobody ) & everybody trusts ( everybody gives)\\n            he should have received N - total population -1 (himself) no of gold coins\\n            \\n            \\n        */\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            trustCount[trust[i][0]]--;\\n            trustCount[trust[i][1]]++;\\n        }\\n        \\n        // finding person matching that condition\\n        for(int i=1;i<trustCount.length;i++)\\n        {\\n            if(trustCount[i] == N-1)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        \\n        // note the +1 so we can directly map 1->N in array since person count starts from 1 - N, leaving out 0 - no person mapped here\\n        int[] trustCount = new int[N+1];\\n        \\n        /*\\n            Imagine trust like a gold coin\\n            if a person gives turst -> Giver loses one gold coin\\n                                    -> receiver gets one gold coin;\\n                                    \\n            since townJudge trusts nobody ( gives nobody ) & everybody trusts ( everybody gives)\\n            he should have received N - total population -1 (himself) no of gold coins\\n            \\n            \\n        */\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            trustCount[trust[i][0]]--;\\n            trustCount[trust[i][1]]++;\\n        }\\n        \\n        // finding person matching that condition\\n        for(int i=1;i<trustCount.length;i++)\\n        {\\n            if(trustCount[i] == N-1)\\n            {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716508,
                "title": "javascript-easy-approach",
                "content": "```\\nvar findJudge = function(N, trust) {\\n    let trustCounts = new Array(N + 1).fill(0);\\n    for (let [a, b] of trust) {\\n        trustCounts[a] = trustCounts[a] - 1;\\n        trustCounts[b] = trustCounts[b] + 1;\\n    }\\n\\n    for (let i = 1; i < trustCounts.length; i++) {\\n        if (trustCounts[i] === N - 1) {\\n            return i\\n        }\\n    }\\n    return -1\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findJudge = function(N, trust) {\\n    let trustCounts = new Array(N + 1).fill(0);\\n    for (let [a, b] of trust) {\\n        trustCounts[a] = trustCounts[a] - 1;\\n        trustCounts[b] = trustCounts[b] + 1;\\n    }\\n\\n    for (let i = 1; i < trustCounts.length; i++) {\\n        if (trustCounts[i] === N - 1) {\\n            return i\\n        }\\n    }\\n    return -1\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 319054,
                "title": "java-directed-graph-solution-slow-but-simple",
                "content": "Since this question was tagged as `graph`, I tried solving it using a graph.\\nOther very efficient solutions only maintained counts rather than building out a graph.. \\n\\n\\n```\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n    \\n    Node(int val, List<Node> children) {\\n        this.val = val;\\n        this.children = children;\\n    }\\n    \\n    public boolean includes(Node other) {\\n        for(Node n : children) {\\n            if (n.val == other.val) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        //\\n        // in this problem, we want to create a directed graph.\\n        // The graph is represented as an array(or hashmap) of linked lists.\\n        // Each head node, maintains a list of nodes it trusts.\\n        // To find the judge, means to find the head node without children,\\n        // and to assert that this same node, is included in the list of all the other nodes.\\n\\n        if (N == 1) return 1;\\n    \\n        \\n        // I will keep a reference to the nodes in a hashmap.\\n        // because it simplifies finding nodes by value.\\n        Map<Integer, Node> graph = new HashMap<>();\\n        \\n        // First we will build the graph\\n        for(int[] pair : trust) {\\n            Node nodeA = new Node(pair[0], new LinkedList<>());\\n            Node nodeB = new Node(pair[1], new LinkedList<>());\\n            \\n            // initialize if new\\n            graph.putIfAbsent(nodeA.val, nodeA);\\n            graph.putIfAbsent(nodeB.val, nodeB);\\n            \\n            // update node\\n            Node n = graph.get(nodeA.val);\\n            n.children.add(nodeB);\\n            graph.put(n.val, n);\\n        }\\n        \\n        // Then we will find our judge, which is the node without children\\n        Node judge = null;\\n        for(Map.Entry<Integer, Node> entry : graph.entrySet()) {\\n            Node n = entry.getValue();\\n            if (n.children.size()  == 0) {\\n                judge = n;\\n                break;\\n            }    \\n        }\\n        \\n        // If all nodes have children, the judge will be null.\\n        if (judge == null) {\\n            return -1;\\n        }\\n        \\n        // For each node other than the judge, we want to make sure their children nodes include the judge.\\n        for(Map.Entry<Integer, Node> entry : graph.entrySet()) {\\n            Node n = entry.getValue();\\n\\n            if(n.val == judge.val) {\\n                continue;\\n            }\\n            \\n            if(!n.includes(judge)) {\\n                return -1;\\n            }\\n        }\\n        \\n        // if we made it here, it means they all included the judge.\\n        return judge.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n    \\n    Node(int val, List<Node> children) {\\n        this.val = val;\\n        this.children = children;\\n    }\\n    \\n    public boolean includes(Node other) {\\n        for(Node n : children) {\\n            if (n.val == other.val) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        //\\n        // in this problem, we want to create a directed graph.\\n        // The graph is represented as an array(or hashmap) of linked lists.\\n        // Each head node, maintains a list of nodes it trusts.\\n        // To find the judge, means to find the head node without children,\\n        // and to assert that this same node, is included in the list of all the other nodes.\\n\\n        if (N == 1) return 1;\\n    \\n        \\n        // I will keep a reference to the nodes in a hashmap.\\n        // because it simplifies finding nodes by value.\\n        Map<Integer, Node> graph = new HashMap<>();\\n        \\n        // First we will build the graph\\n        for(int[] pair : trust) {\\n            Node nodeA = new Node(pair[0], new LinkedList<>());\\n            Node nodeB = new Node(pair[1], new LinkedList<>());\\n            \\n            // initialize if new\\n            graph.putIfAbsent(nodeA.val, nodeA);\\n            graph.putIfAbsent(nodeB.val, nodeB);\\n            \\n            // update node\\n            Node n = graph.get(nodeA.val);\\n            n.children.add(nodeB);\\n            graph.put(n.val, n);\\n        }\\n        \\n        // Then we will find our judge, which is the node without children\\n        Node judge = null;\\n        for(Map.Entry<Integer, Node> entry : graph.entrySet()) {\\n            Node n = entry.getValue();\\n            if (n.children.size()  == 0) {\\n                judge = n;\\n                break;\\n            }    \\n        }\\n        \\n        // If all nodes have children, the judge will be null.\\n        if (judge == null) {\\n            return -1;\\n        }\\n        \\n        // For each node other than the judge, we want to make sure their children nodes include the judge.\\n        for(Map.Entry<Integer, Node> entry : graph.entrySet()) {\\n            Node n = entry.getValue();\\n\\n            if(n.val == judge.val) {\\n                continue;\\n            }\\n            \\n            if(!n.includes(judge)) {\\n                return -1;\\n            }\\n        }\\n        \\n        // if we made it here, it means they all included the judge.\\n        return judge.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090707,
                "title": "python3-729-ms-faster-than-92-42-of-python3",
                "content": "```\\ndef findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        array = [0] * (n+1)\\n        for (a, b) in trust:\\n            array[a] -= 1\\n            array[b] += 1\\n        for i in range(1, len(array)):\\n            if array[i] == n-1:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\ndef findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        array = [0] * (n+1)\\n        for (a, b) in trust:\\n            array[a] -= 1\\n            array[b] += 1\\n        for i in range(1, len(array)):\\n            if array[i] == n-1:\\n                return i\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3088936,
                "title": "java-solution-hashset",
                "content": "# Intuition\\nI tried the problem using arrays but, was finding to make cases and visualise stuff. Thus, I switched to HashSet. \\n# Approach\\nI stored values of people in one HashSet (trust[i][0]) and stored values of potential judges in another HashSet(trust[i][1]). I covered the edge cases by using if-else conditions i.e. where the array is empty.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Code\\n```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        Set<Integer> judge = new HashSet<Integer>();\\n        if(trust.length == 0 && n==1){\\n            return 1;\\n        }\\n        else if(trust.length == 0){\\n            return -1;\\n        }\\n        for(int i = 0; i<trust.length; i++){\\n            set.add(trust[i][0]);\\n            judge.add(trust[i][1]);\\n        }\\n        judge.removeAll(set);\\n        if(judge.isEmpty() || judge.size() > 1) {\\n            return -1;\\n        }\\n        int judgeId = judge.iterator().next();\\n        int judgeTrust = 0;\\n        for(int i = 0; i<trust.length; i++) {\\n            if(trust[i][1] == judgeId) {\\n                judgeTrust++;\\n            }\\n        }\\n        if(judgeTrust == n-1) {\\n            return judgeId;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        Set<Integer> judge = new HashSet<Integer>();\\n        if(trust.length == 0 && n==1){\\n            return 1;\\n        }\\n        else if(trust.length == 0){\\n            return -1;\\n        }\\n        for(int i = 0; i<trust.length; i++){\\n            set.add(trust[i][0]);\\n            judge.add(trust[i][1]);\\n        }\\n        judge.removeAll(set);\\n        if(judge.isEmpty() || judge.size() > 1) {\\n            return -1;\\n        }\\n        int judgeId = judge.iterator().next();\\n        int judgeTrust = 0;\\n        for(int i = 0; i<trust.length; i++) {\\n            if(trust[i][1] == judgeId) {\\n                judgeTrust++;\\n            }\\n        }\\n        if(judgeTrust == n-1) {\\n            return judgeId;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088075,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/O-GT3BIAzbM\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(n, trust) {\\n    let arr = new Array(n).fill(0)\\n    let count = new Array(n).fill(0)\\n    for(let [x,y] of trust){\\n        arr[x-1] = 1;\\n        count[y-1]++\\n    }\\n    for(let i =0; i<arr.length;i++){\\n        if(arr[i] == 0 && count[i] == n-1){\\n            return i+1\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(n, trust) {\\n    let arr = new Array(n).fill(0)\\n    let count = new Array(n).fill(0)\\n    for(let [x,y] of trust){\\n        arr[x-1] = 1;\\n        count[y-1]++\\n    }\\n    for(let i =0; i<arr.length;i++){\\n        if(arr[i] == 0 && count[i] == n-1){\\n            return i+1\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 994816,
                "title": "indegrees-outdegrees-explanation-visual-python",
                "content": "***TL;DR*** This problem can be solved efficiently by leveraging ***indegrees*** and ***outdegrees***. the judge will always have ```N - 1```  indegrees (people who trust) and will always have ```0``` outdegrees (people the judge trusts)  \\n\\n```python\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        graph = { x: [] for x in range(1, N + 1) }    \\n        indegrees = { x: 0 for x in range(1, N + 1) }\\n        outdegrees = { x: 0 for x in range(1, N + 1) }\\n        \\n        # build graph and count indegress/outdegrees\\n        for u, v in trust:\\n            # directed edge u -> v\\n            graph[u].append(v)\\n            # v as incoming connection\\n            indegrees[v] += 1 \\n            # u has outgoing connection \\n            outdegrees[u] += 1\\n        \\n        # unconnected verticies have outdegree 0\\n        for i in range(1, N + 1):\\n            if i not in outdegrees:\\n                outdegrees[i] = 0 \\n        \\n        # check for vertice that has indegree zero \\n        for v in range(1, N + 1):\\n            if v in indegrees:\\n                if indegrees[v] == N - 1 and outdegrees[v] == 0:\\n                    return v\\n        return -1\\n```\\n### Overview \\n\\nThe problem defines a judge as follows\\n1. The town judge trusts nobody.\\n2. Everybody (except for the town judge) trusts the town judge.\\n3. There is exactly one person that satisfies properties 1 and 2.\\n\\nSince the problem deals with defining relationships between different entities a graph data structure is a good choice. If a person ```A```  trust a person ```B``` , it does not always mean that person ```B``` also trusts person ```A```.  \\n\\nThus it is best to represent the relationship of trust between people as directed graph. trust is only guaranteed one way. ```A -> B``` \\n\\n\\nThe diagram below reads\\n* ```A``` places trust in ```B```\\n* ```B``` places trust in no one \\n\\n![image](https://assets.leetcode.com/users/images/49b8dc8a-cdf8-4a59-afd6-d60a523954d9_1609386097.5714333.png)\\n\\n\\nin graph theory a directed edge is formally defined as an edge with an orientation meaning, it has direction that must be followed. ```A->B``` is a directed edge. \\n\\nObserve ```A``` has an outgoing connection and ```B``` has an incoming connection. \\n\\nMore formally we say ```A```  has an ***outdegree***  (number of outoging connections) of ```1``` and ```B``` has an ***indegree*** (number of incoming connections) of ```1``` \\n\\nAlso note ```A``` has an ***indegree*** of ```0``` and ```B``` has an ***outdegree*** of ```0```.\\n\\nThus we can define trust realtionships via ***indegrees*** and ***outdegrees***\\n\\n* The ***indegree*** value for a person ```P```  represents the number of people who trust person ```P```\\n*  The ***outdegree*** value for a person ```P```  represents the number of people person ```P``` trusts \\n\\nobserve the following examples \\n![image](https://assets.leetcode.com/users/images/2c9e667f-cbba-4ced-a8ec-44c91056e185_1609386431.2723234.png)\\n\\n\\n\\nthe key observation to solving this problem is to recognize that \\n* everyone trusts the judge (except the judge) means the judge has an indegree of ```N - 1``` \\n* the judge trusts no one means the judge has an outdegree of ```0```\\n* will only ever be ```1``` person with this property means the first vertex (person) we find with the above properties is the judge\\n\\nThus all that must be done is to calculate the indegrees and outdegrees for all vertices and find the vertice with an indegree ```N -1``` and outdegree of ```0```. like in **figures 2 & 3*** \\n\\nif no vertex exist with these indegree and outdegree values then no judge is present and ```-1``` is returned like in ***Figure 4***\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```N - 1```\n```0```\n```python\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        graph = { x: [] for x in range(1, N + 1) }    \\n        indegrees = { x: 0 for x in range(1, N + 1) }\\n        outdegrees = { x: 0 for x in range(1, N + 1) }\\n        \\n        # build graph and count indegress/outdegrees\\n        for u, v in trust:\\n            # directed edge u -> v\\n            graph[u].append(v)\\n            # v as incoming connection\\n            indegrees[v] += 1 \\n            # u has outgoing connection \\n            outdegrees[u] += 1\\n        \\n        # unconnected verticies have outdegree 0\\n        for i in range(1, N + 1):\\n            if i not in outdegrees:\\n                outdegrees[i] = 0 \\n        \\n        # check for vertice that has indegree zero \\n        for v in range(1, N + 1):\\n            if v in indegrees:\\n                if indegrees[v] == N - 1 and outdegrees[v] == 0:\\n                    return v\\n        return -1\\n```\n```A```\n```B```\n```B```\n```A```\n```A -> B```\n```A```\n```B```\n```B```\n```A->B```\n```A```\n```B```\n```A```\n```1```\n```B```\n```1```\n```A```\n```0```\n```B```\n```0```\n```P```\n```P```\n```P```\n```P```\n```N - 1```\n```0```\n```1```\n```N -1```\n```0```\n```-1```",
                "codeTag": "Python3"
            },
            {
                "id": 815311,
                "title": "python-easy-to-read-graph-solution",
                "content": "Graphs are fun (on the easy medium level)! The key is figuring out how edges are created and also what exactly those edges can solve by iterating through them. \\n\\n```\\n\"\"\"\\nRuntime: 784 ms, faster than 85.44% of Python3 online submissions for Find the Town Judge.\\nMemory Usage: 18.1 MB, less than 91.28% of Python3 online submissions for Find the Town Judge.\\n\\njudge:\\n- trusts nobody\\n- everybody trust town judge\\n- exactly one person that satisifies 1 and 2\\n\\n** Directed graph **\\n\\nApproach:\\n- create directed graph \\n- candidates are those that do not have any trusts\\n- if candidate - check everybody trusts candidate\\n\"\"\"\\n\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        \\n        if N == 0: return -1\\n        \\n        graph = {}\\n        for i in range(1,N+1):\\n            graph[i] = set()\\n        \\n        for e in trust:\\n            graph[e[0]].add(e[1])\\n        \\n        # if someone in graph has no edges, they are candidate\\n        candidates = [i for i,v in graph.items() if len(v) == 0]\\n        if len(candidates) == 0: return -1\\n        candidate = candidates[0]   # theoretically should have only 1\\n        \\n        # go through edges and see if everybody trusts candidate\\n        for i,v in graph.items():\\n            if candidate == i: continue\\n            if candidate not in graph[i]:\\n                return -1\\n        \\n        return candidate\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n\"\"\"\\nRuntime: 784 ms, faster than 85.44% of Python3 online submissions for Find the Town Judge.\\nMemory Usage: 18.1 MB, less than 91.28% of Python3 online submissions for Find the Town Judge.\\n\\njudge:\\n- trusts nobody\\n- everybody trust town judge\\n- exactly one person that satisifies 1 and 2\\n\\n** Directed graph **\\n\\nApproach:\\n- create directed graph \\n- candidates are those that do not have any trusts\\n- if candidate - check everybody trusts candidate\\n\"\"\"\\n\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        \\n        if N == 0: return -1\\n        \\n        graph = {}\\n        for i in range(1,N+1):\\n            graph[i] = set()\\n        \\n        for e in trust:\\n            graph[e[0]].add(e[1])\\n        \\n        # if someone in graph has no edges, they are candidate\\n        candidates = [i for i,v in graph.items() if len(v) == 0]\\n        if len(candidates) == 0: return -1\\n        candidate = candidates[0]   # theoretically should have only 1\\n        \\n        # go through edges and see if everybody trusts candidate\\n        for i,v in graph.items():\\n            if candidate == i: continue\\n            if candidate not in graph[i]:\\n                return -1\\n        \\n        return candidate\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634457,
                "title": "simplest-graph-based-logic-and-solution-in-c",
                "content": "* Consider every person in the town as a Node in the graph.\\n* If there is a trust between two persons, then there will be an edge between those two nodes\\n* Calculate indegree (no. of incoming edges) and outdegree (no. of outgoing edges) for each node\\n* Town judge will be a Node whose indgree is N-1 and outdegree is 0\\n* Time Complexity: O(N), Space Complexity: O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<pair<int, int>> degree(N+1); //first is indegree, second is outdegree\\n        //calculate in indgree and outdgree of each node\\n        for(int i=0; i<trust.size(); i++){\\n            degree[trust[i][1]].first++;\\n            degree[trust[i][0]].second++;\\n        }\\n        //check if there is any node with indgree as N-1 and outdgree as 0\\n        for(int i=1; i<=N; i++){\\n            if(degree[i].first == N-1 && degree[i].second == 0)\\n                return i;\\n        }\\n        //if no solution found\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<pair<int, int>> degree(N+1); //first is indegree, second is outdegree\\n        //calculate in indgree and outdgree of each node\\n        for(int i=0; i<trust.size(); i++){\\n            degree[trust[i][1]].first++;\\n            degree[trust[i][0]].second++;\\n        }\\n        //check if there is any node with indgree as N-1 and outdgree as 0\\n        for(int i=1; i<=N; i++){\\n            if(degree[i].first == N-1 && degree[i].second == 0)\\n                return i;\\n        }\\n        //if no solution found\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484157,
                "title": "python-3-easy-solution-with-explanation-beats-99-74",
                "content": "consider every person as a node and trust between two as an edge\\nso, if 1 trusts 3, it\\'s an incoming edge for 3 and an outgoing edge for 1\\n\\nmaintain two lists of zeros, each on having a size of N. These will keep record of incoming and outcoign edges. \\nNow look, \\nfor [1, 3]\\nin_edges[3-1] += 1 //array indexes from 0 to N-1\\nout_edges[1-1] += 1\\nAs there will be only one person whom the remining N-1 people trust but he trusts none. so for that person, \\nin_edges[i] == N-1\\nout_edges[i] == 0\\n\\nfind that i and return i+1, return -1 otherwise. \\n\\n\\tdef findJudge(self, N: int, trust: List[List[int]]) -> int:\\n\\t\\t\\tin_edges, out_edges = [0]*N, [0]*N\\n\\n\\t\\t\\tfor t in trust:\\n\\t\\t\\t\\ts, d = t[0]-1, t[1]-1\\n\\t\\t\\t\\tin_edges[d]+=1\\n\\t\\t\\t\\tout_edges[s]+=1\\n\\t\\t\\tfor i in range(0, N):\\n\\t\\t\\t\\tif(in_edges[i]==N-1 and out_edges[i]==0):\\n\\t\\t\\t\\t\\treturn i+1\\n\\t\\t\\treturn -1\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "consider every person as a node and trust between two as an edge\\nso, if 1 trusts 3, it\\'s an incoming edge for 3 and an outgoing edge for 1\\n\\nmaintain two lists of zeros, each on having a size of N. These will keep record of incoming and outcoign edges. \\nNow look, \\nfor [1, 3]\\nin_edges[3-1] += 1 //array indexes from 0 to N-1\\nout_edges[1-1] += 1\\nAs there will be only one person whom the remining N-1 people trust but he trusts none. so for that person, \\nin_edges[i] == N-1\\nout_edges[i] == 0\\n\\nfind that i and return i+1, return -1 otherwise. \\n\\n\\tdef findJudge(self, N: int, trust: List[List[int]]) -> int:\\n\\t\\t\\tin_edges, out_edges = [0]*N, [0]*N\\n\\n\\t\\t\\tfor t in trust:\\n\\t\\t\\t\\ts, d = t[0]-1, t[1]-1\\n\\t\\t\\t\\tin_edges[d]+=1\\n\\t\\t\\t\\tout_edges[s]+=1\\n\\t\\t\\tfor i in range(0, N):\\n\\t\\t\\t\\tif(in_edges[i]==N-1 and out_edges[i]==0):\\n\\t\\t\\t\\t\\treturn i+1\\n\\t\\t\\treturn -1\\n",
                "codeTag": "Python3"
            },
            {
                "id": 4005717,
                "title": "beats-100-easiest-explanation-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We can easily find this using outdegree and indegree concept,\\n- Indegree: the number of incoming edges.\\n- Outdegree: the number of outgoing edges.\\n- If the outdegree = 0, means the person does not trust anyone.\\n- And if indegree = n-1, means that person is trusted by everyone except himself.\\n- He must be the judge of the town.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        //this condition is to check if given input is empty but n==1\\n\\t\\t\\n\\t\\tif(trust.empty() && n==1)\\n            return 1;\\n\\t\\t\\n\\t\\t//counts outdegree of a person or node \\n\\t\\t//outdegree means number of nodes that are trusted by given specific node \\n        \\n\\t\\tvector<int> out(n+1,0);\\n\\t\\t\\n\\t\\t//counts indegree of a person or node \\n\\t\\t//indegree means number of nodes that trusts a given specific node\\n        \\n\\t\\tvector<int> in(n+1,0);\\n\\t\\t\\n\\t\\t//loop counts indegree and outdegree\\n        \\n\\t\\tfor(auto edge : trust){\\n            out[edge[0]]++;\\n            in[edge[1]]++;\\n        }\\n\\t\\t\\n\\t\\t//if a node has outdegree==0 that means that node doesnot trust anyone and\\n\\t\\t//indegree ==n-1 that means all other nodes trusts this node except himself\\n        \\n\\t\\tfor(int i=0;i<=n;i++){\\n            if(out[i]==0 && in[i]==n-1)\\n                return i;\\n        }\\n\\t\\t//if there is no such node return -1\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        //this condition is to check if given input is empty but n==1\\n\\t\\t\\n\\t\\tif(trust.empty() && n==1)\\n            return 1;\\n\\t\\t\\n\\t\\t//counts outdegree of a person or node \\n\\t\\t//outdegree means number of nodes that are trusted by given specific node \\n        \\n\\t\\tvector<int> out(n+1,0);\\n\\t\\t\\n\\t\\t//counts indegree of a person or node \\n\\t\\t//indegree means number of nodes that trusts a given specific node\\n        \\n\\t\\tvector<int> in(n+1,0);\\n\\t\\t\\n\\t\\t//loop counts indegree and outdegree\\n        \\n\\t\\tfor(auto edge : trust){\\n            out[edge[0]]++;\\n            in[edge[1]]++;\\n        }\\n\\t\\t\\n\\t\\t//if a node has outdegree==0 that means that node doesnot trust anyone and\\n\\t\\t//indegree ==n-1 that means all other nodes trusts this node except himself\\n        \\n\\t\\tfor(int i=0;i<=n;i++){\\n            if(out[i]==0 && in[i]==n-1)\\n                return i;\\n        }\\n\\t\\t//if there is no such node return -1\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088827,
                "title": "using-only-1-vector-array-t-c-o-n-and-s-c-o-n",
                "content": "It is a simple approach..\\nAlgo:-  In a vector we store a count , \\n           If any person knows someone then we **decrease** the resp person\\'s count by **1**.\\n\\t\\t   If any person is known by someone then we **increase** the person\\'s count by **1**.\\n\\t\\t   Now,*we know that judge would have a count of (n-1).* Beacause judge knows no one, so, he will           have not any Decrement and since judge is known by everyone, so, he will have (n-1)             increments. \\n\\t\\t   So, now just do a traversal and find the element with count equal to  n-1 and that is **Judge**.\\n\\t\\t   \\n\\t\\t   class Solution {\\n           public:\\n           int findJudge(int n, vector<vector<int>>& trust) {\\n              vector<int> ans(n+1,0);\\n              for(int i=0; i<trust.size(); i++){\\n                 --ans[trust[i][0]];\\n                 ++ans[trust[i][1]];\\n              }\\n        \\n             for(int i=1; i<=n ; i++) if(ans[i]==n-1) return i;\\n             return -1;\\n            }\\n       };\\n\\t\\t   \\n\\t\\t   \\t\\t   \\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n           public:\\n           int findJudge(int n, vector<vector<int>>& trust) {\\n              vector<int> ans(n+1,0);\\n              for(int i=0; i<trust.size(); i++){\\n                 --ans[trust[i][0]];\\n                 ++ans[trust[i][1]];\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3088375,
                "title": "c-solution",
                "content": "# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>> trust) {\\n        if (trust.size() == 0 && n == 1) \\n            return 1;\\n        vector<int> count(n + 1);\\n        for (auto person : trust) {\\n            //count[person[0]]--; decrements the trust count of the first person in the pair. This is done because if the first person trusts the second person, it means that the first person does not trust themselves.\\n            count[person[0]]--;\\n            //count[person[1]]++; increments the trust count of the second person in the pair. This is done because if the first person trusts the second person, it means that the second person is trusted by the first person.\\n            count[person[1]]++;\\n        }\\n\\n        for (int person = 0; person < count.size(); person++) {\\n            // check if there is a person who is trusted by everyone except themselves (n-1 people) and if such person exists it returns the index of that person.\\n            if (count[person] == n - 1) return person;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n*Upvote please*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>> trust) {\\n        if (trust.size() == 0 && n == 1) \\n            return 1;\\n        vector<int> count(n + 1);\\n        for (auto person : trust) {\\n            //count[person[0]]--; decrements the trust count of the first person in the pair. This is done because if the first person trusts the second person, it means that the first person does not trust themselves.\\n            count[person[0]]--;\\n            //count[person[1]]++; increments the trust count of the second person in the pair. This is done because if the first person trusts the second person, it means that the second person is trusted by the first person.\\n            count[person[1]]++;\\n        }\\n\\n        for (int person = 0; person < count.size(); person++) {\\n            // check if there is a person who is trusted by everyone except themselves (n-1 people) and if such person exists it returns the index of that person.\\n            if (count[person] == n - 1) return person;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357107,
                "title": "easy-c-code-please-upvote-with-explanation",
                "content": "**O(n) time and space solution (1 arrays):**\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>indegree(n+1, 0);\\n        for(auto vec : trust){\\n            indegree[vec[0]]--;\\n            indegree[vec[1]]++;\\n        }\\n        for(int i = 1; i<=n; i++)\\n            if(indegree[i] == n-1)\\n                return i;\\n        return -1;\\n    }\\n};\\n```\\n**O(n) time and space solution (2 arrays):**\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>indegree(n+1, 0), outdegree(n+1, 0);\\n        for(auto vec : trust){\\n            outdegree[vec[0]]++;\\n            indegree[vec[1]]++;\\n        }\\n        for(int i = 1; i<=n; i++)\\n            if(indegree[i] == n-1 && outdegree[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n};\\n\\n```\\n- There are people from 1 to n so 0 is extra and is ignored. \\n- First, create adjacency list, as shown below.\\n- Now, iterate over the list from 1 to n.\\n- If we find NULL vector, we choose that value.\\n- Again Iterate the loop and check if that value is present is all people\\'s trust, if YES return the value.\\n- Else find another value with NULL vector.\\n- If we find none and reach at the end of graph, we simply return -1.\\n**Note:** This is brute force. Time: O(N^2) Space: O(N^2)\\n```\\n0: \\n1: 3->4->\\n2: 3->4->\\n3: \\n4: 3->\\n```\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> graph[n+1]; // adjacency list\\n        \\n        for(auto v : trust)\\n            graph[v[0]].push_back(v[1]);    // creating list\\n        \\n        for(int i = 1; i<=n; i++){\\n            if(graph[i].empty()){   // if vector is empty\\n                bool flag = true;\\n                for(int j = 1; j<=n; j++){  // checking if that value is present in all vectors\\n                    if(j == i)continue;     // except the vector with value we are searching\\n                    if(find(graph[j].begin(), graph[j].end(), i) == graph[j].end()){\\n                        flag = false;   // if value not present in any vector\\n                        break;  // go to check another value\\n                    }\\n                }\\n                if(flag)\\n                    return i;   // if value in present in all vectors except self ofc\\n            }\\n        }\\n        return -1;  // no judge\\n            \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>indegree(n+1, 0);\\n        for(auto vec : trust){\\n            indegree[vec[0]]--;\\n            indegree[vec[1]]++;\\n        }\\n        for(int i = 1; i<=n; i++)\\n            if(indegree[i] == n-1)\\n                return i;\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>indegree(n+1, 0), outdegree(n+1, 0);\\n        for(auto vec : trust){\\n            outdegree[vec[0]]++;\\n            indegree[vec[1]]++;\\n        }\\n        for(int i = 1; i<=n; i++)\\n            if(indegree[i] == n-1 && outdegree[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n};\\n\\n```\n```\\n0: \\n1: 3->4->\\n2: 3->4->\\n3: \\n4: 3->\\n```\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> graph[n+1]; // adjacency list\\n        \\n        for(auto v : trust)\\n            graph[v[0]].push_back(v[1]);    // creating list\\n        \\n        for(int i = 1; i<=n; i++){\\n            if(graph[i].empty()){   // if vector is empty\\n                bool flag = true;\\n                for(int j = 1; j<=n; j++){  // checking if that value is present in all vectors\\n                    if(j == i)continue;     // except the vector with value we are searching\\n                    if(find(graph[j].begin(), graph[j].end(), i) == graph[j].end()){\\n                        flag = false;   // if value not present in any vector\\n                        break;  // go to check another value\\n                    }\\n                }\\n                if(flag)\\n                    return i;   // if value in present in all vectors except self ofc\\n            }\\n        }\\n        return -1;  // no judge\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060608,
                "title": "cpp-solution-using-indegree-and-outdegree",
                "content": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int>id(N+1,0);\\n        vector<int>od(N+1,0);\\n        for(auto p:trust)\\n        {\\n            id[p[1]]++;//calculating  indegree\\n            od[p[0]]++;//calculating  outdegree\\n        }\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(id[i] == N-1 && od[i] == 0)//finding a node with indegree n-1 and od = 0\\n                return i;\\n        }\\n        return -1;//not found return -1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int>id(N+1,0);\\n        vector<int>od(N+1,0);\\n        for(auto p:trust)\\n        {\\n            id[p[1]]++;//calculating  indegree\\n            od[p[0]]++;//calculating  outdegree\\n        }\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(id[i] == N-1 && od[i] == 0)//finding a node with indegree n-1 and od = 0\\n                return i;\\n        }\\n        return -1;//not found return -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976803,
                "title": "javascript-solution",
                "content": "```\\nvar findJudge = function(N, trust) {\\n  let peeps = new Map();  // each person (up to N) is a key in a map\\n  for (let i = 1; i <= N; i++) {\\n    peeps.set(i, 0);\\n  }\\n\\n  for (let i = 0; i < trust.length; i++) {\\n  \\tpeeps.delete(trust[i][0]); // if the person trusts someone, delete the person from map\\n  }\\n\\n  if (peeps.size === 0) {\\n  \\t\\treturn -1; // if map is empty, return -1\\n  } else {\\n  \\tlet judge = peeps.keys().next().value; // get the only key remaining in the map\\n  \\tlet count = 0; // used to count how many times the judge was trusted\\n  \\tfor (let i = 0; i < trust.length; i++) {\\n  \\t\\tif (trust[i][1] === judge) { // if judge is found in the array, increment the map value\\n  \\t\\t\\tcount += 1;\\n  \\t\\t}\\n  \\t}\\n  \\tif (count == (N-1)) {\\n  \\t\\treturn judge; // # of needed trusts for the judge must be N-1 (judge can\\'t trust judge)\\n  \\t} else {\\n  \\t\\treturn -1;\\n  \\t}\\n  }\\n    \\n};\\n```\\n\\nRuntime: 96 ms, faster than 100.00% of JavaScript online submissions for Find the Town Judge.\\nMemory Usage: 46.5 MB, less than 61.36% of JavaScript online submissions for Find the Town Judge.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findJudge = function(N, trust) {\\n  let peeps = new Map();  // each person (up to N) is a key in a map\\n  for (let i = 1; i <= N; i++) {\\n    peeps.set(i, 0);\\n  }\\n\\n  for (let i = 0; i < trust.length; i++) {\\n  \\tpeeps.delete(trust[i][0]); // if the person trusts someone, delete the person from map\\n  }\\n\\n  if (peeps.size === 0) {\\n  \\t\\treturn -1; // if map is empty, return -1\\n  } else {\\n  \\tlet judge = peeps.keys().next().value; // get the only key remaining in the map\\n  \\tlet count = 0; // used to count how many times the judge was trusted\\n  \\tfor (let i = 0; i < trust.length; i++) {\\n  \\t\\tif (trust[i][1] === judge) { // if judge is found in the array, increment the map value\\n  \\t\\t\\tcount += 1;\\n  \\t\\t}\\n  \\t}\\n  \\tif (count == (N-1)) {\\n  \\t\\treturn judge; // # of needed trusts for the judge must be N-1 (judge can\\'t trust judge)\\n  \\t} else {\\n  \\t\\treturn -1;\\n  \\t}\\n  }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 885311,
                "title": "java-single-array-intuition-solution-with-explanation",
                "content": "Edit : I have updated the code with more easier implementation.\\n\\n**Intuition :**\\nAcc to the given conditions : \\n1. The town judge trusts nobody.\\n2. Everybody (except for the town judge) trusts the town judge.\\n3. There is exactly one person that satisfies properties 1 and 2.\\n\\nConsider `numbers ( 1- N )` as the nodes in a graph and `trust` as an edge between the given two nodes eg : `[[ a, b ]]` means there is an edge directing from a to b.\\nLe me reiterate the points mentioned : \\n1. The town judge trusts nobody. *`( there is no outward edge from town judge )`*\\n2. Everybody (except for the town judge) trusts the town judge. *`( there is no self loop on the town judge) & indegree will be N-1`*\\n\\n\\nso, for `[[1,2]]` the graph would be something like this : \\n![image](https://assets.leetcode.com/users/images/273d8764-a495-4c3b-ab9b-8811b7718b8e_1602175883.4552398.png)\\n**Observation** : As, 1 `trusts` 2, therefore, there is an edge from 1 to 2. The outdegree of 2 is 0. The indegree of 2 is `N-1` So, it could be a candidate for Town Judge.\\n\\n***Try yourself with this graph :*** \\n![image](https://assets.leetcode.com/users/images/5a028926-c4c4-49d0-a23d-2c9377fd42ad_1602176225.5513077.png)\\n\\n**Solution:**\\n**Step 1:** We have to check the indegree of every node in the graph. If the indegree is equal to the `N-1` count then, we have a candidate for the town judge. \\neg : For `[[1,3],[2,3]]`\\n\\n*Indegree values:*\\nof 1 is 0\\nof 2 is 0\\nof 3 is 2\\n\\nNow, we have `3` as a candidate for being the town judge.\\nSo, for finding the indegree we check the values of `b` in `[[a,b]]` and keep updating them in an array.\\n\\n**But how do we decide, whether the candidate is a town judge ?**\\n\\n**Step 2:** Remember, `there is no self loop on the town judge`, so we need to check whether there is an edge fromthis candidate node or not.\\nSo, for this we need to check if the `candidate` is equal to any `a` value in `[[a,b]]`.\\n\\n\\n```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n\\t\\t// base case\\n        if(N==1) return 1;\\n        int cand = -1;\\n\\t\\t// create an array to store the indegree of every node\\n        int[] tj = new int[N+1];\\n        for(int i=1;i<=trust.length;i++) {\\n            tj[trust[i-1][1]]+=1; \\n            if(tj[trust[i-1][1]]==(N-1)) cand = trust[i-1][1]; // checking if condition 2 is satisfied\\n        }\\n\\t\\t// verfying step 2\\n        for(int i=1;i<=trust.length;i++) {\\n            if(trust[i-1][0] == cand ) return -1;\\n        }\\n        return cand;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n# **Easier Implementation**\\n* TC : `O(n)`\\n* SC : `O(n)`\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        \\n        if(n == 1) return 1;\\n\\t\\t\\n        int[] indegree = new int[n+1];\\n        int[] outdegree = new int[n+1];\\n        \\n\\t\\t// calculate the indegree and outdegree of every pair\\n        for(int[] t : trust) {\\n            indegree[t[1]]++;\\n            outdegree[t[0]]++;\\n        }\\n        \\n\\t\\t// a town judge has indegree = n-1 ( as all knows him ) and outdegree = 0 ( as he knows none )\\n        for(int i=0;i<n+1;i++) {\\n            if(indegree[i] == n-1 && outdegree[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# **Another Implementation with Single Array**:\\nAn observation fom above is : the overall ( `outdegree-indegree`) trust count of the \"town judge\" will be n-1.\\n\\n* TC : `O(n)`\\n* SC : `O(n)`\\n\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n\\t\\n        int[]trust_count = new int[n+1];\\n        \\n        for(int[] t : trust) {\\n            trust_count[t[1]]++;\\n            trust_count[t[0]]--;\\n        }\\n        \\n        // find the candidate\\n        for(int i=1;i<n+1;i++) {\\n            if(trust_count[i] == n-1) \\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n\\t\\t// base case\\n        if(N==1) return 1;\\n        int cand = -1;\\n\\t\\t// create an array to store the indegree of every node\\n        int[] tj = new int[N+1];\\n        for(int i=1;i<=trust.length;i++) {\\n            tj[trust[i-1][1]]+=1; \\n            if(tj[trust[i-1][1]]==(N-1)) cand = trust[i-1][1]; // checking if condition 2 is satisfied\\n        }\\n\\t\\t// verfying step 2\\n        for(int i=1;i<=trust.length;i++) {\\n            if(trust[i-1][0] == cand ) return -1;\\n        }\\n        return cand;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        \\n        if(n == 1) return 1;\\n\\t\\t\\n        int[] indegree = new int[n+1];\\n        int[] outdegree = new int[n+1];\\n        \\n\\t\\t// calculate the indegree and outdegree of every pair\\n        for(int[] t : trust) {\\n            indegree[t[1]]++;\\n            outdegree[t[0]]++;\\n        }\\n        \\n\\t\\t// a town judge has indegree = n-1 ( as all knows him ) and outdegree = 0 ( as he knows none )\\n        for(int i=0;i<n+1;i++) {\\n            if(indegree[i] == n-1 && outdegree[i] == 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n\\t\\n        int[]trust_count = new int[n+1];\\n        \\n        for(int[] t : trust) {\\n            trust_count[t[1]]++;\\n            trust_count[t[0]]--;\\n        }\\n        \\n        // find the candidate\\n        for(int i=1;i<n+1;i++) {\\n            if(trust_count[i] == n-1) \\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625094,
                "title": "java-o-t-where-t-trust-length-with-image-explanation-directed-graph",
                "content": "Just build the Indegree and Outdegree map for all the nodes and check for following conditions:\\n![image](https://assets.leetcode.com/users/ranit-geek111/image_1589132105.png)\\n\\n To make this solution O(T) I have also kept track of node which has highest indegree.As this node could be our judge.If not this node then there is no judge.\\n \\n \\n```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        if(N ==1 && trust.length == 0){\\n            return 1;\\n        }\\n        if(N >1 && trust.length == 0){\\n            return -1;\\n        }\\n        HashMap<Integer,Integer> inDegree = new HashMap<>();\\n        HashMap<Integer,Integer> outDegree = new HashMap<>();\\n        int probableJudge = -1;\\n        int probableJudgeInDegree = -1;\\n        \\n        for(int i=0;i<trust.length;i++){\\n\\t\\t   //update indegree \\n            if(inDegree.containsKey(trust[i][1])){\\n                inDegree.put(trust[i][1],inDegree.get(trust[i][1])+1);\\n            }else{\\n                inDegree.put(trust[i][1],1);\\n            }\\n\\t\\t\\t//Keeping track of the node which has highest indegree till now\\n            if(inDegree.get(trust[i][1])>probableJudgeInDegree){\\n                probableJudgeInDegree = inDegree.get(trust[i][1]);\\n                probableJudge = trust[i][1];\\n            }\\n\\t\\t\\t //update outdegree \\n            if(outDegree.containsKey(trust[i][0])){\\n                outDegree.put(trust[i][0],outDegree.get(trust[i][0])+1);\\n            }else{\\n                outDegree.put(trust[i][0],0);\\n            }\\n        }\\n        if(inDegree.get(probableJudge) == N-1 && !outDegree.containsKey(probableJudge)){\\n            return probableJudge;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        if(N ==1 && trust.length == 0){\\n            return 1;\\n        }\\n        if(N >1 && trust.length == 0){\\n            return -1;\\n        }\\n        HashMap<Integer,Integer> inDegree = new HashMap<>();\\n        HashMap<Integer,Integer> outDegree = new HashMap<>();\\n        int probableJudge = -1;\\n        int probableJudgeInDegree = -1;\\n        \\n        for(int i=0;i<trust.length;i++){\\n\\t\\t   //update indegree \\n            if(inDegree.containsKey(trust[i][1])){\\n                inDegree.put(trust[i][1],inDegree.get(trust[i][1])+1);\\n            }else{\\n                inDegree.put(trust[i][1],1);\\n            }\\n\\t\\t\\t//Keeping track of the node which has highest indegree till now\\n            if(inDegree.get(trust[i][1])>probableJudgeInDegree){\\n                probableJudgeInDegree = inDegree.get(trust[i][1]);\\n                probableJudge = trust[i][1];\\n            }\\n\\t\\t\\t //update outdegree \\n            if(outDegree.containsKey(trust[i][0])){\\n                outDegree.put(trust[i][0],outDegree.get(trust[i][0])+1);\\n            }else{\\n                outDegree.put(trust[i][0],0);\\n            }\\n        }\\n        if(inDegree.get(probableJudge) == N-1 && !outDegree.containsKey(probableJudge)){\\n            return probableJudge;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623395,
                "title": "java-mimic-topology",
                "content": "Directed graph, need to use topology. \\nBut just simply cacluate diff ind - outd;\\nOrig: https://leetcode.com/problems/find-the-town-judge/discuss/242938/JavaC%2B%2BPython-Directed-Graph\\n```\\npublic int findJudge(int N, int[][] ts) {\\n        int[] tr = new int[N +1];\\n        for (int[] t : ts) {\\n            tr[t[0]]--;\\n            tr[t[1]]++;\\n        }\\n        for (int i = 1; i <= N; i++) {\\n            if (tr[i] == N - 1) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findJudge(int N, int[][] ts) {\\n        int[] tr = new int[N +1];\\n        for (int[] t : ts) {\\n            tr[t[0]]--;\\n            tr[t[1]]++;\\n        }\\n        for (int i = 1; i <= N; i++) {\\n            if (tr[i] == N - 1) return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342878,
                "title": "javascript-with-graph-116ms",
                "content": "```\\nvar findJudge = function(N, trust) {\\n    let graph = new Graph();\\n    for(let i = 1; i <= N; i++){\\n        let node = new Node(i);\\n        graph.addNode(node);\\n    }\\n    \\n    trust.forEach(trust => {\\n        graph.addTrust(trust[0], trust[1]);\\n    });\\n\\n    return graph.getJudge()\\n    \\n};\\n\\nfunction Graph(){\\n    this.nodes = {};\\n    \\n    this.addNode = function(node){\\n        if(!this.nodes[node.val]) this.nodes[node.val] = node;\\n    }\\n    \\n    this.addTrust = function(val1, val2){\\n        if(!this.nodes[val1] || !this.nodes[val2]) return false;\\n        this.nodes[val1].trusts.push(val2);\\n    }\\n    \\n    this.getJudge = function(){\\n        let judge = null;\\n        let nodeKeys = Object.keys(this.nodes);\\n        nodeKeys.forEach(nodeKey => {\\n            let node = this.nodes[nodeKey];\\n            if(node.trusts.length == 0 && judge !== null) judge = -1;\\n            else if(node.trusts.length == 0) judge = node.val;\\n        })\\n        if(judge == null || judge == -1) return -1;\\n        \\n        nodeKeys.forEach(nodeKey => {\\n            let node = this.nodes[nodeKey];\\n            if(node.val !== judge && !node.trusts.includes(judge)) judge = -1;\\n        })\\n        return judge;\\n    }\\n \\n}\\n\\nfunction Node(val){\\n    this.val = val;\\n    this.trusts = [];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findJudge = function(N, trust) {\\n    let graph = new Graph();\\n    for(let i = 1; i <= N; i++){\\n        let node = new Node(i);\\n        graph.addNode(node);\\n    }\\n    \\n    trust.forEach(trust => {\\n        graph.addTrust(trust[0], trust[1]);\\n    });\\n\\n    return graph.getJudge()\\n    \\n};\\n\\nfunction Graph(){\\n    this.nodes = {};\\n    \\n    this.addNode = function(node){\\n        if(!this.nodes[node.val]) this.nodes[node.val] = node;\\n    }\\n    \\n    this.addTrust = function(val1, val2){\\n        if(!this.nodes[val1] || !this.nodes[val2]) return false;\\n        this.nodes[val1].trusts.push(val2);\\n    }\\n    \\n    this.getJudge = function(){\\n        let judge = null;\\n        let nodeKeys = Object.keys(this.nodes);\\n        nodeKeys.forEach(nodeKey => {\\n            let node = this.nodes[nodeKey];\\n            if(node.trusts.length == 0 && judge !== null) judge = -1;\\n            else if(node.trusts.length == 0) judge = node.val;\\n        })\\n        if(judge == null || judge == -1) return -1;\\n        \\n        nodeKeys.forEach(nodeKey => {\\n            let node = this.nodes[nodeKey];\\n            if(node.val !== judge && !node.trusts.includes(judge)) judge = -1;\\n        })\\n        return judge;\\n    }\\n \\n}\\n\\nfunction Node(val){\\n    this.val = val;\\n    this.trusts = [];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249423,
                "title": "100-c",
                "content": "\\u5B9E\\u73B0\\u601D\\u8DEF\\uFF1A\\n\\n1\\u3001\\u5982\\u679C trust \\u5C0F\\u4E8E N - 1\\uFF0C\\u660E\\u663E\\u6CA1\\u6709 judge\\uFF1B\\n2\\u3001\\u904D\\u5386 trust\\uFF0C\\u8BB0\\u5F55\\u4FE1\\u4EFB a \\u548C \\u88AB\\u4FE1\\u4EFB b \\u7684\\u6570\\u503C\\uFF1B\\n3\\u3001\\u68C0\\u67E5 a \\u548C b \\u4E2D\\u7B26\\u5408\\u6761\\u4EF6\\u7684\\u8BB0\\u5F55\\u3002\\n\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        if (trust.size() < N - 1)\\n            return -1;\\n\\n        vector<int> a(N + 1, 0), b(N + 1, 0);\\n\\n        for (vector<int> t: trust) {\\n            a[t[0]] ++;\\n            b[t[1]] ++;\\n        }\\n\\n        int ans = -1;\\n\\n        for (int i = 1; i <= N; i++) {\\n            if (ans == -1 && a[i] == 0 && b[i] == N - 1)\\n                ans = i;\\n        }\\n\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\u5B9E\\u73B0\\u601D\\u8DEF\\uFF1A\\n\\n1\\u3001\\u5982\\u679C trust \\u5C0F\\u4E8E N - 1\\uFF0C\\u660E\\u663E\\u6CA1\\u6709 judge\\uFF1B\\n2\\u3001\\u904D\\u5386 trust\\uFF0C\\u8BB0\\u5F55\\u4FE1\\u4EFB a \\u548C \\u88AB\\u4FE1\\u4EFB b \\u7684\\u6570\\u503C\\uFF1B\\n3\\u3001\\u68C0\\u67E5 a \\u548C b \\u4E2D\\u7B26\\u5408\\u6761\\u4EF6\\u7684\\u8BB0\\u5F55\\u3002\\n\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        if (trust.size() < N - 1)\\n            return -1;\\n\\n        vector<int> a(N + 1, 0), b(N + 1, 0);\\n\\n        for (vector<int> t: trust) {\\n            a[t[0]] ++;\\n            b[t[1]] ++;\\n        }\\n\\n        int ans = -1;\\n\\n        for (int i = 1; i <= N; i++) {\\n            if (ans == -1 && a[i] == 0 && b[i] == N - 1)\\n                ans = i;\\n        }\\n\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3090248,
                "title": "c-two-approaches-explained-maps-vectors",
                "content": "\\n# Approach 1 : using two maps\\n\\n# Code \\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int N = trust.size();\\n        \\n        unordered_map<int,int> in;\\n        unordered_map<int,int> out;\\n        \\n        for(auto it: trust){\\n            \\n            out[it[0]]++; //update count of outgoing edge of ai in [ai,bi]\\n            in[it[1]]++;  //update count of incoming edge of bi in [ai,bi]\\n                \\n        }\\n        \\n        //Idea : now check if there is a node whose incoming edge is n-1 and outgoing edge is 0\\n        for(int i=1; i<=n; i++){\\n            if(in[i] == n-1 && out[i] == 0){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n# Approach 2: using only one array [better approach]\\n Algo: \\n    \\n1. Create an array of Size N + 1 to represent each person.\\n   arr[i] represents trust score of i th person\\n   \\n   and arr[i] = number of persons trusts him - number of \\n   persons he trusts.\\n2. Now, traverse through given array. \\n    a, b = a trusts b.\\n    if a person trusts others,\\n\\tthen decrease his score by 1. i.e, arr[a]--\\n    if a person is trusted by others, \\n    then increase his score by 1. i.e, arr[b]++\\n3. At last traverse through each person,\\n    if anyone found with N - 1 trusts,\\n\\tthen return his index.\\n4. if not found, return -1\\n# Complexity\\n- Time complexity: O(N)\\n\\n\\n- Space complexity: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> score(n+1,0);\\n        \\n        for(auto person : trust){\\n            score[person[0]]--;\\n            score[person[1]]++;\\n        }\\n        \\n        for(int i=1; i<=n; i++){\\n            if(score[i] == n-1) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n# Don\\'t forget to upvote, if you understood the solution!\\u2705\\nHappy coding :)\\n",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int N = trust.size();\\n        \\n        unordered_map<int,int> in;\\n        unordered_map<int,int> out;\\n        \\n        for(auto it: trust){\\n            \\n            out[it[0]]++; //update count of outgoing edge of ai in [ai,bi]\\n            in[it[1]]++;  //update count of incoming edge of bi in [ai,bi]\\n                \\n        }\\n        \\n        //Idea : now check if there is a node whose incoming edge is n-1 and outgoing edge is 0\\n        for(int i=1; i<=n; i++){\\n            if(in[i] == n-1 && out[i] == 0){\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> score(n+1,0);\\n        \\n        for(auto person : trust){\\n            score[person[0]]--;\\n            score[person[1]]++;\\n        }\\n        \\n        for(int i=1; i<=n; i++){\\n            if(score[i] == n-1) return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089482,
                "title": "java-2-solutions-explained",
                "content": "# Please Upvote \\uD83D\\uDE07\\n---\\n![image.png](https://assets.leetcode.com/users/images/de9459ba-f843-49b1-aa69-dcbce8ec4e67_1674463766.6991827.png)\\nWe will use a hashmap to count the number of trust each person has got.\\n- If a person is trusted by someone, we will increase his trust count.\\n- If a person trusts someone, we will decrease his trust count.\\n\\nBecause the the judge will always get trusted and never trust himself.\\n\\n``` java []\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        // map to store the trust counts\\n        Map<Integer, Integer> adj = new HashMap<>();\\n        for (int[] e : trust) {\\n            // [a, b]\\n            // a trusts b, decrease a\\'s count coz he\\'ll never be the judge\\n            // b is trusted by a, increase b\\'s count \\n            adj.put(e[1], 1 + adj.getOrDefault(e[1], 0)); \\n            adj.put(e[0], adj.getOrDefault(e[0], 0) - 1);\\n        }\\n\\n        // now we will check from 1 to n, who has got n-1 trusts\\n        for (int i = 1; i <= n; i++) {\\n            if (adj.getOrDefault(i, 0) == n - 1) {\\n                return i;\\n            }\\n        }\\n\\n        // if no one got n-1 trusts, there is no judge\\n        return -1;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n#### We can implement the same logic using an array instead of a hashmap *(Better runtime)*:\\n``` java []\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        // each index is the each person, \\n        // the value at every index is each of their trust counts\\n        // persons are from 1-n so we took a size of n+1 (0-based indexing)\\n        int[] adj = new int[n + 1]; \\n        for (int[] e : trust) {\\n            // [a, b], a trusts b, b is trusted by a\\n            adj[e[0]]--;    // decrease a\\'s count\\n            adj[e[1]]++;    // increase b\\'s count\\n        }\\n\\n        // now we will check from 1 to n, who has got n-1 trusts\\n        for (int i = 1; i <= n; i++) {\\n            if (adj[i] == n - 1) {\\n                return i;\\n            }\\n        }\\n\\n        // if no one got n-1 trusts, there is no judge\\n        return -1;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Graph"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        // map to store the trust counts\\n        Map<Integer, Integer> adj = new HashMap<>();\\n        for (int[] e : trust) {\\n            // [a, b]\\n            // a trusts b, decrease a\\'s count coz he\\'ll never be the judge\\n            // b is trusted by a, increase b\\'s count \\n            adj.put(e[1], 1 + adj.getOrDefault(e[1], 0)); \\n            adj.put(e[0], adj.getOrDefault(e[0], 0) - 1);\\n        }\\n\\n        // now we will check from 1 to n, who has got n-1 trusts\\n        for (int i = 1; i <= n; i++) {\\n            if (adj.getOrDefault(i, 0) == n - 1) {\\n                return i;\\n            }\\n        }\\n\\n        // if no one got n-1 trusts, there is no judge\\n        return -1;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        // each index is the each person, \\n        // the value at every index is each of their trust counts\\n        // persons are from 1-n so we took a size of n+1 (0-based indexing)\\n        int[] adj = new int[n + 1]; \\n        for (int[] e : trust) {\\n            // [a, b], a trusts b, b is trusted by a\\n            adj[e[0]]--;    // decrease a\\'s count\\n            adj[e[1]]++;    // increase b\\'s count\\n        }\\n\\n        // now we will check from 1 to n, who has got n-1 trusts\\n        for (int i = 1; i <= n; i++) {\\n            if (adj[i] == n - 1) {\\n                return i;\\n            }\\n        }\\n\\n        // if no one got n-1 trusts, there is no judge\\n        return -1;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088821,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        unordered_map<int,int> mp;\\n        unordered_map<int,int> mp1;\\n        for(int i=0;i<trust.size();i++)\\n        {\\n            mp[trust[i][0]]++;\\n            mp1[trust[i][1]]++;\\n        }\\n        int ans=-1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            ans=i;\\n        }\\n        if(mp1[ans]==n-1)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        unordered_map<int,int> mp;\\n        unordered_map<int,int> mp1;\\n        for(int i=0;i<trust.size();i++)\\n        {\\n            mp[trust[i][0]]++;\\n            mp1[trust[i][1]]++;\\n        }\\n        int ans=-1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            ans=i;\\n        }\\n        if(mp1[ans]==n-1)\\n            return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088692,
                "title": "java-c-100-solution-using-directed-graph-find-the-town-judge",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int[] trustValue = new int[n+1];\\n        for(int[] x: trust)\\n        {\\n            trustValue[x[0]]--;\\n            trustValue[x[1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n            if(trustValue[i]==(n-1))\\n                return i;\\n        return -1; \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> trustValue(n+1);\\n        for(vector<int> x: trust)\\n        {\\n            trustValue[x[0]]--;\\n            trustValue[x[1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n            if(trustValue[i]==(n-1))\\n                return i;\\n        return -1;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int[] trustValue = new int[n+1];\\n        for(int[] x: trust)\\n        {\\n            trustValue[x[0]]--;\\n            trustValue[x[1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n            if(trustValue[i]==(n-1))\\n                return i;\\n        return -1; \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> trustValue(n+1);\\n        for(vector<int> x: trust)\\n        {\\n            trustValue[x[0]]--;\\n            trustValue[x[1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n            if(trustValue[i]==(n-1))\\n                return i;\\n        return -1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088217,
                "title": "multiple-approaches-explained-hashset-array-single-array-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### 1. HashSet + Array Approach\\n1. Keep an `freq` integer array to count the number of people that trusts a particular person.\\n2. Have a HashSet `trustSet` which will hold the all the people who trust someone or the other.\\n3. Now iterate from `1` to `n` and check `if(freq[i] == n-1 && !trustSet.contains(i))` i.e. the `i`th person is trusted by all and the `i`th person trusts no one.\\n4. Edge case: If `n == 1`, that would mean `trust = [[]]`, hence return 1\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n == 1) return 1;\\n\\n        int[] freq = new int[n+1];\\n        Set<Integer> trustSet = new HashSet<>();\\n\\n        for(int i=0; i<trust.length; i++){\\n            trustSet.add(trust[i][0]);\\n            freq[trust[i][1]] += 1;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(freq[i] == n-1 && !trustSet.contains(i)) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n### 2. Single Array Approach\\n1. In this appraoch we just keep a single integer array `freq`. \\n2. If we have `trust[i] = [a,b]` we simple increment `freq[b]` by 1 and decrement `freq[a]` by 1.\\n3. This would make sure that if `i`th person is trusted by all and also if that person trusts no one then `freq[i] == n-1`.\\n4. So Just iterate over the array and check if frequency of any element is `n-1`.\\n5. Edge case: If `n == 1`, that would mean `trust = [[]]`, hence return 1\\n\\n# Code\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n == 1) return 1;\\n        int[] freq = new int[n+1];\\n        for(int i=0; i<trust.length; i++){\\n            freq[trust[i][0]] -= 1;\\n            freq[trust[i][1]] += 1;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(freq[i] == n-1) return i;\\n        }\\n        return -1;\\n    }\\n}\\n``` \\n\\n##### Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n### Please do Upvote if this helped you",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n == 1) return 1;\\n\\n        int[] freq = new int[n+1];\\n        Set<Integer> trustSet = new HashSet<>();\\n\\n        for(int i=0; i<trust.length; i++){\\n            trustSet.add(trust[i][0]);\\n            freq[trust[i][1]] += 1;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(freq[i] == n-1 && !trustSet.contains(i)) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n == 1) return 1;\\n        int[] freq = new int[n+1];\\n        for(int i=0; i<trust.length; i++){\\n            freq[trust[i][0]] -= 1;\\n            freq[trust[i][1]] += 1;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(freq[i] == n-1) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088141,
                "title": "indegree-outdegree-concept-graph-code-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        // store indegree and outdegree of every people\\n        // trust[i] = [a, b] means a trust b so a is src and b is des. Hence there will be a directed edge from a to b\\n        vector<int> indegree(n), outdegree(n);\\n        for(auto it : trust){\\n            indegree[it[1] - 1]++;\\n            outdegree[it[0] - 1]++;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            // judge will be trusted by every other people and himself does not trust anyone\\n            if(indegree[i] == (n - 1) && outdegree[i] == 0){\\n                return i + 1;\\n            }\\n        }\\n        // no judge exists\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        // store indegree and outdegree of every people\\n        // trust[i] = [a, b] means a trust b so a is src and b is des. Hence there will be a directed edge from a to b\\n        vector<int> indegree(n), outdegree(n);\\n        for(auto it : trust){\\n            indegree[it[1] - 1]++;\\n            outdegree[it[0] - 1]++;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            // judge will be trusted by every other people and himself does not trust anyone\\n            if(indegree[i] == (n - 1) && outdegree[i] == 0){\\n                return i + 1;\\n            }\\n        }\\n        // no judge exists\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088120,
                "title": "c-very-easy-solution-degree-in-graph-intuition-approach-complexity-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind Out and In degree && for town judge total degree should be n-1(present in all and missing in one ).  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- store degree in degree vector\\n- traverse vector trust and count outdegree and indegree\\n- check if total degree is n-1 or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> degree(n+1, 0);\\n        \\n        for(auto t : trust){\\n            degree[t[0]]--; //outdegree of a node\\n            degree[t[1]]++; //indegree of a node\\n        }\\n        for(int i=1; i<=n; i++){  \\n            if(degree[i]==n-1) return i;\\n        }\\n        return -1;\\n    }\\n};\\n//The town judge trusts nobody. -> 0\\n//Everybody (except for the town judge) trusts the town judge. -> n -1\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> degree(n+1, 0);\\n        \\n        for(auto t : trust){\\n            degree[t[0]]--; //outdegree of a node\\n            degree[t[1]]++; //indegree of a node\\n        }\\n        for(int i=1; i<=n; i++){  \\n            if(degree[i]==n-1) return i;\\n        }\\n        return -1;\\n    }\\n};\\n//The town judge trusts nobody. -> 0\\n//Everybody (except for the town judge) trusts the town judge. -> n -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864663,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int findJudge(int n, int[][] t) {\\n        if(n==1)\\n            return 1;\\n        HashMap<Integer,Integer> nm=new HashMap<>();\\n        int k=t.length;\\n        for(int i[]: t)\\n        {\\n            nm.put(i[0] , nm.getOrDefault(i[0],0)+(-1));\\n            nm.put(i[1] , nm.getOrDefault(i[1],0)+1);\\n        }\\n        for(int i:nm.keySet())\\n        {\\n            if(nm.get(i)==n-1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int findJudge(int n, int[][] t) {\\n        if(n==1)\\n            return 1;\\n        HashMap<Integer,Integer> nm=new HashMap<>();\\n        int k=t.length;\\n        for(int i[]: t)\\n        {\\n            nm.put(i[0] , nm.getOrDefault(i[0],0)+(-1));\\n            nm.put(i[1] , nm.getOrDefault(i[1],0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1664922,
                "title": "c-indegree-outdegree-approach",
                "content": "```\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> inDegree(n + 1, 0), adj[n + 1], outDegree(n + 1, 0);\\n        \\n        for(auto it : trust)\\n            adj[it[0]].push_back(it[1]);\\n            \\n        for(int i = 1; i <= n; i++)\\n            for(auto it : adj[i]) {\\n                inDegree[it]++;\\n                outDegree[i]++;\\n            }\\n        \\n        for(int i = 1; i <= n; i++)\\n            if(inDegree[i] == n - 1 && outDegree[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> inDegree(n + 1, 0), adj[n + 1], outDegree(n + 1, 0);\\n        \\n        for(auto it : trust)\\n            adj[it[0]].push_back(it[1]);\\n            \\n        for(int i = 1; i <= n; i++)\\n            for(auto it : adj[i]) {\\n                inDegree[it]++;\\n                outDegree[i]++;\\n            }\\n        \\n        for(int i = 1; i <= n; i++)\\n            if(inDegree[i] == n - 1 && outDegree[i] == 0)\\n                return i;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1664127,
                "title": "c-linear-solution-explained-100-time-116ms-99-space",
                "content": "This is a nice warmup problem, and also a graph problem in disguise, if you wish: we are hunting for a single node which has indegree equal to `n - 1` and `0` outdegree.\\n\\nIn order to solve it efficiently, anyway, we only need to take into account the overall number of indegrees and if each node has outdegrees or not, so we can optimise a bit in that sense too.\\n\\nWe will create a few support variables to help us first:\\n* `trusted` will store our indegrees, increasing `n` since we will have to include that element too;\\n* `trusting` will  be our outdegrees store and since we just need to know if a node trusts others or not, we can have it as a boolean.\\n\\nAfter initialising them to be all `0`s and `false`s respectivevly, we can parse `trust` to populate them and for each element, update `trusted` and `trusting` to mark the information we store in them.\\n\\nWe can now start parsing all the elements in our stores going with `i` from `1` (since we were given `1`-indexed nodes in this problem) up to `n` and as soon as we find an element with no outdegrees (`!trusting[i]`), we will check if the same node also has a number of indegrees equal to `target` (which in turn equals `n -2`, since we have to remove the previous increase to the value of `n` and of course one of the node, not trusting itself) and have two scenarios:\\n* the same node has indeed `target` indegrees, so it means it matches our condition and we can just `return` `i`;\\n* alternatively, we know that no other element can have `target` indegrees (since all the connections in `trust` are stated to be uniques, so no repetitions will be given) and this also means that no other valid element can have `0` outdegrees, so we can confidently `return` `-1`.\\n\\nIf we leave the loop for any other reason (ie: no node actually had `target` connections), we can similarly be sure that there is no judge and `return` `-1`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        // support variables\\n        int trusted[++n];\\n        bool trusting[n];\\n        fill(trusted, trusted + n, 0);\\n        fill(trusting, trusting + n, false);\\n        // populating trusted and trusting\\n        for (auto &e: trust) {\\n            trusted[e[1]]++;\\n            trusting[e[0]] = true;\\n        }\\n       // hunting for the one trusting no one\\n        for (int i = 1, target = n - 2; i < n; i++) {\\n            if (!trusting[i]) {\\n                if (trusted[i] == target) {\\n                    return i;\\n                }\\n                return -1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nCan we do better? Well, yes - if we store the node that first reaches the value of `target` in the first pass, we can avoid the last loop altogether; I also tried to use a `bitset` for `trusting`, but that did not improve performance (possibly slowing it down a bit for our relatively small numbers), so I reverted it to a `bool` array.\\n\\nThe updated code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        // edge case - empty trust\\n        if (!trust.size()) return n == 1 ? 1 : -1;\\n        // support variables\\n        int trusted[++n], res = 0, target = n - 2;\\n        bool trusting[n];\\n        fill(trusted, trusted + n, 0);\\n        fill(trusting, trusting + n, false);\\n        // populating trusted and trusting\\n        for (auto &e: trust) {\\n            // storing the first match we find in res\\n            if (++trusted[e[1]] == target) res = e[1];\\n            trusting[e[0]] = true;\\n            \\n        }\\n        return !res || trusting[res] ? -1 : res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/b0e3c3be-6737-4f18-a8c1-82172c045ce2_1641206300.7861629.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        // support variables\\n        int trusted[++n];\\n        bool trusting[n];\\n        fill(trusted, trusted + n, 0);\\n        fill(trusting, trusting + n, false);\\n        // populating trusted and trusting\\n        for (auto &e: trust) {\\n            trusted[e[1]]++;\\n            trusting[e[0]] = true;\\n        }\\n       // hunting for the one trusting no one\\n        for (int i = 1, target = n - 2; i < n; i++) {\\n            if (!trusting[i]) {\\n                if (trusted[i] == target) {\\n                    return i;\\n                }\\n                return -1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        // edge case - empty trust\\n        if (!trust.size()) return n == 1 ? 1 : -1;\\n        // support variables\\n        int trusted[++n], res = 0, target = n - 2;\\n        bool trusting[n];\\n        fill(trusted, trusted + n, 0);\\n        fill(trusting, trusting + n, false);\\n        // populating trusted and trusting\\n        for (auto &e: trust) {\\n            // storing the first match we find in res\\n            if (++trusted[e[1]] == target) res = e[1];\\n            trusting[e[0]] = true;\\n            \\n        }\\n        return !res || trusting[res] ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663144,
                "title": "c-solution-map-deatiled-explaination",
                "content": "->here we are considering two maps , m and x\\n-> m represents the number of persons a person trusts\\n->x reprents the number of persons who trust the person \\n-> the logic is simple  , we iterate theough the matrix and count the number of person a person trusts (m) , and how many people trust the person \\n->after that we just go through the map , and find a person who trusts nobody ( m[i]==0) , everyone except the person himself can trust of the person (x[i]==n-1)\\n_____________________________________________________________________________________________________________________________\\nEXAMPLE 2 :  n = 3, trust = [[1,3],[2,3]]\\ntotal number of persons : 3\\nm[1]=1 ( since 1 trusts 3)\\nm[2]=1 ( since 2 trusts 3)\\nm[3]=0 (since 3 trusts no-one)  //note , uninitialized values are 0 in map\\n\\nx[1]=0 ( since no-one trusts 1)\\nx[2]=0 ( since no-one trusts 2)\\nx[3]=2 ( since 1 and 2 trust 3 )\\n\\nfrom the above values we see that , m[3]=0 and x[3]=2 (n-1) , hence 3 is the town judge\\n_______________________________________________________________________________________________________________________________\\nEXAMPLE 3:  n = 3, trust = [[1,3],[2,3],[3,1]]\\ntotal number of person : 3\\nm[1]=1 ( 1 trusts 3)\\nm[2]=1 ( 2 trusts 3)\\nm[3]=1 ( 3 trusts 1)\\n\\nx[1]=1  ( 3 trusts 1 ) \\nx[2]=0 ( no-one trusts 2)\\nx[3]=2 (1 and 2 trusts 3)\\n\\nwe see that the above condition  ( m[i]==0&&x[i]==n-1 ) is not satisfied for any of the values , hence we return 1 \\n\\nthe code for the same can be written as follows\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n map<int , int > m;\\nif(n==1) return 1;\\nmap<int , int >x;\\nfor(int i=0 ; i<trust.size() ; i++)\\n{\\n    m[trust[i][0]]++;\\n}\\nfor(int i=0 ; i<trust.size() ; i++)\\n{\\n    x[trust[i][1]]++;\\n}\\nfor(int i= 0 ; i<=n ; i++)\\n{\\n    if(m[i]==0&&x[i]==n-1)\\n         return i;\\n}\\n        return -1;\\n    }\\n};\\n```\\nfound it helpful ? please upvote ;)\\nhave doubts ? comment below !",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n map<int , int > m;\\nif(n==1) return 1;\\nmap<int , int >x;\\nfor(int i=0 ; i<trust.size() ; i++)\\n{\\n    m[trust[i][0]]++;\\n}\\nfor(int i=0 ; i<trust.size() ; i++)\\n{\\n    x[trust[i][1]]++;\\n}\\nfor(int i= 0 ; i<=n ; i++)\\n{\\n    if(m[i]==0&&x[i]==n-1)\\n         return i;\\n}\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621150,
                "title": "o-n-solution-in-python",
                "content": "considering the \"trust relationship\" as a directed graph where for each vertex `v` has `in-degree` and `out-degree`, representing the number of people that trust `v` and the amount of whom `v` trusts, respectively. the `judge` would be the vertex with `in-degree - out-degree == n - 1`.\\nso we can calculate `in-degree - out-degree ` on the fly and find the judge eventually.\\n```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        dg = [0] * (n + 1)\\n        for a, b in trust:\\n            dg[a] -= 1 # out\\n            dg[b] += 1 # in\\n        return next((i for i in range(1, n + 1) if dg[i] == n - 1), -1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        dg = [0] * (n + 1)\\n        for a, b in trust:\\n            dg[a] -= 1 # out\\n            dg[b] += 1 # in\\n        return next((i for i in range(1, n + 1) if dg[i] == n - 1), -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553071,
                "title": "997-find-the-town-judge-java-solution",
                "content": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[] isTrusted = new int[N+1];\\n        for(int[] person : trust){\\n            isTrusted[person[0]]--;\\n            isTrusted[person[1]]++;\\n        }\\n        for(int i = 1;i < isTrusted.length;i++){\\n            if(isTrusted[i] == N-1) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[] isTrusted = new int[N+1];\\n        for(int[] person : trust){\\n            isTrusted[person[0]]--;\\n            isTrusted[person[1]]++;\\n        }\\n        for(int i = 1;i < isTrusted.length;i++){\\n            if(isTrusted[i] == N-1) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505112,
                "title": "java-easy-approach-with-explanation-khan-s-algo-intution",
                "content": "```\\nclass Solution \\n{//calculating the indegree and outdegree of every node and storing it into the hash map\\n//The judge will have no outdegree and the indegree is equivalent to n-1\\n    class degree\\n    {\\n        int indegree;\\n        int outdegree;\\n        degree(int indegree, int outdegree)\\n        {\\n            this.indegree= indegree;\\n            this.outdegree= outdegree;\\n        }\\n    }\\n    public int findJudge(int n, int[][] trust) \\n    {\\n        if(trust.length == 0 && n == 1)\\n            return 1;\\n        \\n        HashMap<Integer, degree> map= new HashMap<>();//Node && indegree, outdegree\\n        \\n        for(int []relationship: trust)\\n        {\\n            int from= relationship[0];\\n            int to= relationship[1];\\n            \\n            map.putIfAbsent(to, new degree(0, 0));\\n            map.putIfAbsent(from, new degree(0, 0));\\n            \\n            degree degreefrom= map.get(from);\\n            degree degreeto= map.get(to);\\n            \\n            map.put(to, new degree(degreeto.indegree+1, degreeto.outdegree));\\n            map.put(from, new degree(degreefrom.indegree, degreefrom.outdegree+1));\\n        }\\n        \\n        for(Map.Entry<Integer, degree> entry: map.entrySet())\\n        {\\n            int indeg= entry.getValue().indegree;\\n            int outdeg= entry.getValue().outdegree;\\n            \\n            if(indeg == n-1 && outdeg == 0)\\n                return entry.getKey();\\n        }\\n        \\n        return -1;\\n    }\\n}//please do upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{//calculating the indegree and outdegree of every node and storing it into the hash map\\n//The judge will have no outdegree and the indegree is equivalent to n-1\\n    class degree\\n    {\\n        int indegree;\\n        int outdegree;\\n        degree(int indegree, int outdegree)\\n        {\\n            this.indegree= indegree;\\n            this.outdegree= outdegree;\\n        }\\n    }\\n    public int findJudge(int n, int[][] trust) \\n    {\\n        if(trust.length == 0 && n == 1)\\n            return 1;\\n        \\n        HashMap<Integer, degree> map= new HashMap<>();//Node && indegree, outdegree\\n        \\n        for(int []relationship: trust)\\n        {\\n            int from= relationship[0];\\n            int to= relationship[1];\\n            \\n            map.putIfAbsent(to, new degree(0, 0));\\n            map.putIfAbsent(from, new degree(0, 0));\\n            \\n            degree degreefrom= map.get(from);\\n            degree degreeto= map.get(to);\\n            \\n            map.put(to, new degree(degreeto.indegree+1, degreeto.outdegree));\\n            map.put(from, new degree(degreefrom.indegree, degreefrom.outdegree+1));\\n        }\\n        \\n        for(Map.Entry<Integer, degree> entry: map.entrySet())\\n        {\\n            int indeg= entry.getValue().indegree;\\n            int outdeg= entry.getValue().outdegree;\\n            \\n            if(indeg == n-1 && outdeg == 0)\\n                return entry.getKey();\\n        }\\n        \\n        return -1;\\n    }\\n}//please do upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332652,
                "title": "997-graph-solution-set-only-solution-indegree-outdegree-solution",
                "content": "---\\n\\nGraph looks like an overkill for the problem\\nbut its good to learn Graph on simple problems\\n\\n---\\n\\n**Algo**\\n- **Graph solution**\\n  - Given `edges` are `trusts`\\n    - A `trust` can be from `u person to v person`\\n    - Save these in some kind of Map\\n  - Assume everyone `does not trust` everyone else - so add all `u`s in a `Set`\\n    - For each trust, if `u` trusts `v`, remove `u` from `Set`\\n    - We `must` have only 1 person in `Set`\\n      - If `less` than or `more` persons left in `Set` then we are `no` judges/ or `might have multiple` judges, return `-1`\\n      - else call the remaining in `Set` as `j` since j is a possible judge label\\n  - Now do reverse for `j`\\n    - Check who all `j` trusts\\n    - We `must` have 0 trusts from `j`\\n\\t  - If `j` does trusts someone return `-1`\\n\\t  - else return `j`\\n- **Set solution**\\n  - Same algo as above, but using `Set` only\\n  - Inline comments explain the algorithm also, see 2nd solution below\\n- **Indegree & outdegree solution**\\n  - For each edge `(u,v)`\\n    - Count the `indegree` and `outdegree` - that is, number of incoming edges & outgoing edges\\n  - Find all whose `outdegree` is `0`\\n    - Of those found ones, find if their `indegree` is `V-1`, that is incoming edges is really from all others\\n      - Since we can\\'t have multiple judges, check these found nodes is really only one node\\n        - if only one judge node is found then return it, else return `-1`\\n- **Indegree & outdegree solution - simpler**\\n  - same as above, just easy to read\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Graph solution**\\n\\n```\\nclass Graph {\\n    // undirected; V; E; edges; /* edge list */; adjacents; /* or, adj list */ G;\\n\\n    buildGraphG_asMofM_fromEdges = ({ undirected, V, E, edges }) => {\\n        const addConnM = (u, v) => {\\n            this.G.has(u) || this.G.set(u, new Map());\\n            const adjFreqMap = this.G.get(u);\\n            adjFreqMap.set(v, adjFreqMap.has(v) ? adjFreqMap.get(v) + 1 : 1);\\n        };\\n\\n        this.undirected = undirected;\\n        this.V = V;\\n        this.E = E !== undefined ? E : this.undirected ? 2 * edges.length : edges.length;\\n        this.edges = edges;\\n        this.G = undefined;\\n\\n        this.G = new Map();\\n        if (undirected) {\\n            for (let [u, v] of this.edges) addConnM(u, v), addConnM(v, u);\\n        } else {\\n            for (let [u, v] of this.edges) addConnM(u, v);\\n        }\\n    };\\n    constructor({ undirected, V, E, edges, adjacents }) {\\n        this.buildGraphG_asMofM_fromEdges({ undirected, V, E, edges });\\n    }\\n}\\n\\nvar findJudge = function (V, edges) {\\n    let set = new Set();\\n    for (let u = 1; u <= V; u++) set.add(u); // assume all does not trust any other\\n    for (let [u] of edges) set.delete(u);    // remove who trusts others\\n    if (set.size !== 1) return -1;           // remaining, who dont trust - shud be only 1 judge\\n\\n    let j = [...set][0];                     // found the judge\\n\\n    let g = new Graph({ V, edges });\\n    for (let [_, adjFreqMap] of g.G) {\\n        if (!adjFreqMap.has(j)) return -1;   // 1 person does not trust j\\n    }\\n    return j;                                // everyone trusts j\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/936dfc4b-55e0-44ed-bb6d-eb537aa7cc66_1626079764.850067.png)\\n\\n---\\n\\n**Set solution**\\n\\n```\\nvar findJudge = function (V, edges) {\\n                                                          // edges = array of [u,v] pairs,   u is from,  v is to\\n    let set = new Set(edges.map((uv) => uv[0]));          // set of all unique u\\n\\n    let A = Array.from({ length: V + 1 }, (_, i) => i)    // 0 to V\\n        .filter((u) => u)                                 // remove 0\\n        .filter((u) => !set.has(u));                      // remove all u\\n    if (A.length !== 1) return -1;                        // remaining are possible judges, but < 1 or > 1 is fail\\n\\n    let j = A[0];                                         // found the judge\\n\\n    A = edges //\\n        .map(([u, v]) => (v === j ? u : 0))               // if v is judge, take u or 0\\n        .filter((u) => u);                                // remove 0\\n    return A.length === V - 1 ? j : -1;                   // everyone else trusts j ? j, or not (-1)\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6b4b1874-35e7-4819-bd84-e70809d5f957_1626095551.3254156.png)\\n\\n---\\n\\n**Indegree & outdegree solution**\\n\\n```\\nvar findJudge = function (V, edges) {\\n                                                                               // edges = array of [u,v] pairs,   u is from,  v is to\\n    let outdegree = new Array(V + 1).fill(0);                                  // index 0 is dummy\\n    let indegree = new Array(V + 1).fill(0);                                   // index 0 is dummy\\n\\n    edges.forEach(([u, v]) => (outdegree[u]++, indegree[v]++));                // count of each outgoing (trust from) & incoming (trust to)\\n\\n    let judgeIndexes = outdegree\\n        .reduce((arr, u, i) => (i != 0 && u === 0 && arr.push(i), arr), [])    // those whose \"outdegree\" is 0\\n        .filter((ji) => indegree[ji] === V - 1);                               // and also \"indegree\" is from all others\\n\\n    return judgeIndexes.length !== 0 ? judgeIndexes[0] : -1;                   // only 1 (yes, only 1 max is possible)? then its judge: else not (-1)\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/15c380d2-2f37-476a-bf6b-ec1436e5241a_1626107336.9640932.png)\\n\\n---\\n\\n**Indegree & outdegree solution - simpler**\\n\\n```\\nvar findJudge = function (V, edges) {\\n                                                                               // edges = array of [u,v] pairs,   u is from,  v is to\\n    let outdegree = new Array(V + 1).fill(0);                                  // index 0 is dummy\\n    let indegree = new Array(V + 1).fill(0);                                   // index 0 is dummy\\n\\n    edges.forEach(([u, v]) => (outdegree[u]++, indegree[v]++));                // count of each outgoing (trust from) & incoming (trust to)\\n\\n    for (let u = 1; u <= V; u++)\\n        if (outdegree[u] === 0 && indegree[u] === V - 1) {\\n            return u;                                                          // outgoing is 0, and incoming is all others => u is judge\\n        }\\n    return -1;                                                                 // no judge\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a3c63618-72a2-4da3-9ac1-8bfe15dac077_1626137904.5237896.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Graph {\\n    // undirected; V; E; edges; /* edge list */; adjacents; /* or, adj list */ G;\\n\\n    buildGraphG_asMofM_fromEdges = ({ undirected, V, E, edges }) => {\\n        const addConnM = (u, v) => {\\n            this.G.has(u) || this.G.set(u, new Map());\\n            const adjFreqMap = this.G.get(u);\\n            adjFreqMap.set(v, adjFreqMap.has(v) ? adjFreqMap.get(v) + 1 : 1);\\n        };\\n\\n        this.undirected = undirected;\\n        this.V = V;\\n        this.E = E !== undefined ? E : this.undirected ? 2 * edges.length : edges.length;\\n        this.edges = edges;\\n        this.G = undefined;\\n\\n        this.G = new Map();\\n        if (undirected) {\\n            for (let [u, v] of this.edges) addConnM(u, v), addConnM(v, u);\\n        } else {\\n            for (let [u, v] of this.edges) addConnM(u, v);\\n        }\\n    };\\n    constructor({ undirected, V, E, edges, adjacents }) {\\n        this.buildGraphG_asMofM_fromEdges({ undirected, V, E, edges });\\n    }\\n}\\n\\nvar findJudge = function (V, edges) {\\n    let set = new Set();\\n    for (let u = 1; u <= V; u++) set.add(u); // assume all does not trust any other\\n    for (let [u] of edges) set.delete(u);    // remove who trusts others\\n    if (set.size !== 1) return -1;           // remaining, who dont trust - shud be only 1 judge\\n\\n    let j = [...set][0];                     // found the judge\\n\\n    let g = new Graph({ V, edges });\\n    for (let [_, adjFreqMap] of g.G) {\\n        if (!adjFreqMap.has(j)) return -1;   // 1 person does not trust j\\n    }\\n    return j;                                // everyone trusts j\\n};\\n```\n```\\nvar findJudge = function (V, edges) {\\n                                                          // edges = array of [u,v] pairs,   u is from,  v is to\\n    let set = new Set(edges.map((uv) => uv[0]));          // set of all unique u\\n\\n    let A = Array.from({ length: V + 1 }, (_, i) => i)    // 0 to V\\n        .filter((u) => u)                                 // remove 0\\n        .filter((u) => !set.has(u));                      // remove all u\\n    if (A.length !== 1) return -1;                        // remaining are possible judges, but < 1 or > 1 is fail\\n\\n    let j = A[0];                                         // found the judge\\n\\n    A = edges //\\n        .map(([u, v]) => (v === j ? u : 0))               // if v is judge, take u or 0\\n        .filter((u) => u);                                // remove 0\\n    return A.length === V - 1 ? j : -1;                   // everyone else trusts j ? j, or not (-1)\\n};\\n```\n```\\nvar findJudge = function (V, edges) {\\n                                                                               // edges = array of [u,v] pairs,   u is from,  v is to\\n    let outdegree = new Array(V + 1).fill(0);                                  // index 0 is dummy\\n    let indegree = new Array(V + 1).fill(0);                                   // index 0 is dummy\\n\\n    edges.forEach(([u, v]) => (outdegree[u]++, indegree[v]++));                // count of each outgoing (trust from) & incoming (trust to)\\n\\n    let judgeIndexes = outdegree\\n        .reduce((arr, u, i) => (i != 0 && u === 0 && arr.push(i), arr), [])    // those whose \"outdegree\" is 0\\n        .filter((ji) => indegree[ji] === V - 1);                               // and also \"indegree\" is from all others\\n\\n    return judgeIndexes.length !== 0 ? judgeIndexes[0] : -1;                   // only 1 (yes, only 1 max is possible)? then its judge: else not (-1)\\n};\\n```\n```\\nvar findJudge = function (V, edges) {\\n                                                                               // edges = array of [u,v] pairs,   u is from,  v is to\\n    let outdegree = new Array(V + 1).fill(0);                                  // index 0 is dummy\\n    let indegree = new Array(V + 1).fill(0);                                   // index 0 is dummy\\n\\n    edges.forEach(([u, v]) => (outdegree[u]++, indegree[v]++));                // count of each outgoing (trust from) & incoming (trust to)\\n\\n    for (let u = 1; u <= V; u++)\\n        if (outdegree[u] === 0 && indegree[u] === V - 1) {\\n            return u;                                                          // outgoing is 0, and incoming is all others => u is judge\\n        }\\n    return -1;                                                                 // no judge\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294360,
                "title": "c-easy-both-graph-array-solutions-explained-in-detail",
                "content": "Array solution- We take a vector arr and initialize all its elements to 0. Then we traverse trust and mark arr[ trust[i][0] ] as 1 bcoz trust[i][0] trusts trust[i][1] so it can never be judge(as judge trusts nobody). Now,we\\'ve marked all the people who trust someone as 1. If there is a solution then there should be only one element(ans) in arr which is 0 ( apart from arr[0]). Another condition-Everybody trusts judge, so we keep a counter and increment it if trust[i][1]==ans. If counter=n-1(i.e. n-1 people trust him) then ans is our answer otherwise return -1.\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int count=0,ans;\\n        vector<int> arr(n+1,0);\\n      \\n        for(int i=0;i<trust.size();i++){\\n            arr[trust[i][0]]=1;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(arr[i]==0) {\\n                ans= i;\\n            }\\n        }\\n        for(int i=0;i<trust.size();i++){\\n            if(trust[i][1]==ans) count++;\\n        }\\n        if(count==n-1) return ans;\\n        return -1;\\n    }\\n};\\n```\\n\\nGraph Solution- According to the two conditions for being a judge,we can relate it to such a node of a graph that has indegree=n-1(n-1 people trust him) and outdegree=0(He trusts nobody).So we create an adjacency list and count indegree and outdegree for each node(person).\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==1 && trust.size()==0) return n;\\n        if(n>1 && trust.size()==0) return -1;\\n        vector<int> adj_list[n+1];\\n        vector<int>indegree(n+1,0);\\n        vector<int>outdegree(n+1,0);\\n        for(int i=0;i<trust.size();i++){\\n            adj_list[trust[i][1]].push_back(trust[i][0]);\\n        }\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<adj_list[i].size();j++){\\n                indegree[i]++;\\n                outdegree[adj_list[i][j]]++;\\n            }\\n        }\\n        for( int i=0;i<n+1;i++){\\n            if(indegree[i]==n-1 && outdegree[i]==0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nHope you found it useful :)",
                "solutionTags": [
                    "C",
                    "Array",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int count=0,ans;\\n        vector<int> arr(n+1,0);\\n      \\n        for(int i=0;i<trust.size();i++){\\n            arr[trust[i][0]]=1;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(arr[i]==0) {\\n                ans= i;\\n            }\\n        }\\n        for(int i=0;i<trust.size();i++){\\n            if(trust[i][1]==ans) count++;\\n        }\\n        if(count==n-1) return ans;\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==1 && trust.size()==0) return n;\\n        if(n>1 && trust.size()==0) return -1;\\n        vector<int> adj_list[n+1];\\n        vector<int>indegree(n+1,0);\\n        vector<int>outdegree(n+1,0);\\n        for(int i=0;i<trust.size();i++){\\n            adj_list[trust[i][1]].push_back(trust[i][0]);\\n        }\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<adj_list[i].size();j++){\\n                indegree[i]++;\\n                outdegree[adj_list[i][j]]++;\\n            }\\n        }\\n        for( int i=0;i<n+1;i++){\\n            if(indegree[i]==n-1 && outdegree[i]==0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205833,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        if(N == 1 && trust.length == 0){\\n            return 1;\\n        }\\n        int [] people = new int [N + 1];\\n        int [] trusted = new int [N + 1];\\n        \\n        for(int i = 0; i < trust.length; i++){\\n            people[trust[i][0]] ++;\\n            trusted[trust[i][1]] ++;\\n        }\\n        for(int i = 0; i < trust.length; i++ ){\\n            if(people[trust[i][1]] == 0 && trusted[trust[i][1]] == N - 1){\\n                return trust[i][1];\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        if(N == 1 && trust.length == 0){\\n            return 1;\\n        }\\n        int [] people = new int [N + 1];\\n        int [] trusted = new int [N + 1];\\n        \\n        for(int i = 0; i < trust.length; i++){\\n            people[trust[i][0]] ++;\\n            trusted[trust[i][1]] ++;\\n        }\\n        for(int i = 0; i < trust.length; i++ ){\\n            if(people[trust[i][1]] == 0 && trusted[trust[i][1]] == N - 1){\\n                return trust[i][1];\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625168,
                "title": "python-3-single-loop",
                "content": "The idea is to keep track of the index with highest trust score.\\n\\n```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        if N == 1:\\n            return 1\\n\\n        folks = [0] * (N + 1)\\n        judge = 0\\n        for src, dst in trust:\\n            folks[src] -= 1\\n            folks[dst] += 1\\n            if folks[dst] > folks[judge]:\\n                judge = dst\\n\\n        return judge if folks[judge] == N - 1 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        if N == 1:\\n            return 1\\n\\n        folks = [0] * (N + 1)\\n        judge = 0\\n        for src, dst in trust:\\n            folks[src] -= 1\\n            folks[dst] += 1\\n            if folks[dst] > folks[judge]:\\n                judge = dst\\n\\n        return judge if folks[judge] == N - 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513884,
                "title": "c-simple-using-vector-to-store-the-trust",
                "content": "We use `vector<int> people` to all trust from other people.\\nIf somebody trust to `people[i]` we increment by 1.\\n\\nIf `people[i]` trusts somebody, we can do anything that prevent `people[i]` get `N - 1` votes:\\nI do decrement, but we can also set to `-N` or `-1`, does\\'t matter. Just make sure it prevents `people[i]` to get `N-1` trust from others.\\n\\nThe judge is the `people[i] == N - 1`;\\n\\nOh, I also allocate `people` size `N + 1`, so I can use indexes `[1..N]` instead of `[0..N-1]`, one extra element but less calculations.\\n\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> people(N + 1, 0);\\n        for (vector<int> t: trust) {\\n            people[t[0]]--;\\n            people[t[1]]++;\\n        }\\n        for (int i = 1; i <= N; i++)\\n            if (people[i] == N - 1) return i;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> people(N + 1, 0);\\n        for (vector<int> t: trust) {\\n            people[t[0]]--;\\n            people[t[1]]++;\\n        }\\n        for (int i = 1; i <= N; i++)\\n            if (people[i] == N - 1) return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493285,
                "title": "c-o-m-n",
                "content": "```\\npublic class Solution {\\n    public int FindJudge(int N, int[][] trust) {\\n        int[] countTrusted = new int[N];\\n        int[] countTrusters = new int[N];\\n        foreach (int[] relation in trust) \\n        {\\n            countTrusters[relation[1] - 1]++;\\n            countTrusted[relation[0] - 1]++;\\n        }\\n        for (int i = 0; i < N; ++i) \\n        {\\n            if (countTrusters[i] == N - 1 && countTrusted[i] == 0) \\n            {\\n                return i + 1;\\n            }    \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindJudge(int N, int[][] trust) {\\n        int[] countTrusted = new int[N];\\n        int[] countTrusters = new int[N];\\n        foreach (int[] relation in trust) \\n        {\\n            countTrusters[relation[1] - 1]++;\\n            countTrusted[relation[0] - 1]++;\\n        }\\n        for (int i = 0; i < N; ++i) \\n        {\\n            if (countTrusters[i] == N - 1 && countTrusted[i] == 0) \\n            {\\n                return i + 1;\\n            }    \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355098,
                "title": "java-3ms-solution-calculate-indegree-and-outdegree",
                "content": "```java\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        \\n        int[] inDegree = new int[N + 1];\\n        int[] outDegree = new int[N + 1];\\n        \\n        for (int[] t : trust) {\\n            outDegree[t[0]]++;\\n            inDegree[t[1]]++;\\n        }\\n        \\n        for (int i = 1; i <= N; i++) {\\n            if (inDegree[i] == N - 1 && outDegree[i] == 0) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        \\n        int[] inDegree = new int[N + 1];\\n        int[] outDegree = new int[N + 1];\\n        \\n        for (int[] t : trust) {\\n            outDegree[t[0]]++;\\n            inDegree[t[1]]++;\\n        }\\n        \\n        for (int i = 1; i <= N; i++) {\\n            if (inDegree[i] == N - 1 && outDegree[i] == 0) {\\n                return i;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289336,
                "title": "96-ms-faster-than-99-24-and-16-3-mb-less-than-100-00-of-python3",
                "content": "```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        trues = [0] * N\\n        for p in trust:\\n            trues[p[0] - 1] += 1\\n            trues[p[1] - 1] -= 1\\n        if min(trues) - 1 == -N:\\n            return trues.index(1-N) + 1\\n        else:\\n            return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        trues = [0] * N\\n        for p in trust:\\n            trues[p[0] - 1] += 1\\n            trues[p[1] - 1] -= 1\\n        if min(trues) - 1 == -N:\\n            return trues.index(1-N) + 1\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247328,
                "title": "c-100-with-explanation-comments",
                "content": "```\\n/*\\nTime - O(T+N) where T is the trust.Length\\nSpace - O(N)\\n*/\\npublic class Solution {\\n    public int FindJudge(int N, int[][] trust) {\\n        \\n        // if there is only 1 person (N=1) or trust is empty, then\\n        // the person is the town judge.\\n        if (N==1 || trust.Length == 0) return 1;\\n        \\n        int[] truster = new int[N+1];\\n        int[] trustee = new int[N+1];\\n        \\n        for (int i=0; i<trust.Length; i++ ){            \\n            \\n            // plus1 to trust[i][1] index of truster and trustee\\n            truster[trust[i][0]]++;\\n            trustee[trust[i][1]]++;\\n            \\n        }\\n        \\n        // to satify to be the town judge:\\n        // trustee of index j must be total number of people(N)-1\\n        // truster of index j must be 0\\n        for (int j=0; j<trustee.Length; j++){\\n            if (trustee[j] == N-1 && truster[j] == 0) return j;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nTime - O(T+N) where T is the trust.Length\\nSpace - O(N)\\n*/\\npublic class Solution {\\n    public int FindJudge(int N, int[][] trust) {\\n        \\n        // if there is only 1 person (N=1) or trust is empty, then\\n        // the person is the town judge.\\n        if (N==1 || trust.Length == 0) return 1;\\n        \\n        int[] truster = new int[N+1];\\n        int[] trustee = new int[N+1];\\n        \\n        for (int i=0; i<trust.Length; i++ ){            \\n            \\n            // plus1 to trust[i][1] index of truster and trustee\\n            truster[trust[i][0]]++;\\n            trustee[trust[i][1]]++;\\n            \\n        }\\n        \\n        // to satify to be the town judge:\\n        // trustee of index j must be total number of people(N)-1\\n        // truster of index j must be 0\\n        for (int j=0; j<trustee.Length; j++){\\n            if (trustee[j] == N-1 && truster[j] == 0) return j;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690708,
                "title": "easy-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n      //creating a array to store the indegree and outdegree or we can say we are counting who trusts whom to store this info we are creating a array\\n      int []count = new int[n+1];\\n      //n+1 because it is from 1 to N not 0 to n;\\n      for(int i = 0;i<trust.length;i++){\\n            //now decrementing count for outdegree or trusting others \\n            count[trust[i][0]]--;\\n            //now incrementing count for indegree or for getting trusted\\n            count[trust[i][1]]++;\\n      }\\n      for(int j = 0;j<=n;j++){\\n          //checking whichever indegree in count array matches n-1 for town judge condition we return the answer\\n          if(count[i] == n - 1){\\n            return i;\\n          }\\n      }\\n      return -1;\\n      //if noone is town judge\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n      //creating a array to store the indegree and outdegree or we can say we are counting who trusts whom to store this info we are creating a array\\n      int []count = new int[n+1];\\n      //n+1 because it is from 1 to N not 0 to n;\\n      for(int i = 0;i<trust.length;i++){\\n            //now decrementing count for outdegree or trusting others \\n            count[trust[i][0]]--;\\n            //now incrementing count for indegree or for getting trusted\\n            count[trust[i][1]]++;\\n      }\\n      for(int j = 0;j<=n;j++){\\n          //checking whichever indegree in count array matches n-1 for town judge condition we return the answer\\n          if(count[i] == n - 1){\\n            return i;\\n          }\\n      }\\n      return -1;\\n      //if noone is town judge\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107207,
                "title": "java-solution-with-degree-arrays",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Instead of adjacency list, we make array of indegrees and outdegrees for each person. We just the number of people that trust, not a record of it\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int[] indegrees = new int[n+1];\\n        int[] outdegrees = new int[n+1];\\n        \\n        // assign indegree and out degree for each person\\n        for (int i = 0; i < trust.length; i++) {\\n            outdegrees[trust[i][0]]++;\\n            indegrees[trust[i][1]]++;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            // town judge must have 0 degrees out, and n-1 degrees in\\n            if (outdegrees[i] == 0 && indegrees[i] == n-1) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int[] indegrees = new int[n+1];\\n        int[] outdegrees = new int[n+1];\\n        \\n        // assign indegree and out degree for each person\\n        for (int i = 0; i < trust.length; i++) {\\n            outdegrees[trust[i][0]]++;\\n            indegrees[trust[i][1]]++;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            // town judge must have 0 degrees out, and n-1 degrees in\\n            if (outdegrees[i] == 0 && indegrees[i] == n-1) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094259,
                "title": "easy-to-understand-and-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==1) return 1;\\n        if((n!=1) && trust.empty()) return -1;\\n        map <int,int> mp;\\n        int k=-1;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto it:mp) {\\n            if(it.second==n-1) k=it.first;\\n        }\\n        for(int i=0;i<trust.size();i++){\\n            if(trust[i][0]==k) return -1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==1) return 1;\\n        if((n!=1) && trust.empty()) return -1;\\n        map <int,int> mp;\\n        int k=-1;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto it:mp) {\\n            if(it.second==n-1) k=it.first;\\n        }\\n        for(int i=0;i<trust.size();i++){\\n            if(trust[i][0]==k) return -1;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091747,
                "title": "easy-and-short-javascript-solution-only-5-lines",
                "content": "# Intuition\\n<!-- Describe your approach to solving the problem. -->\\nEverybody except the town judge himself trust the town judge. Total number of people is n. So To exist a town judge there has to be a person who is trusted by n-1 people.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(n, trust) {\\n    let arr = Array(n+1).fill(0);\\n    for([i, j] of trust){\\n        arr[i] -= 1;\\n        arr[j] += 1;\\n    }\\n    return arr.lastIndexOf(n-1);\\n  /*  indexOf() is not used beacause for the case of n =1 and trusted = []\\n      index of n-1 is 0 which is wrong answer.*/\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(n, trust) {\\n    let arr = Array(n+1).fill(0);\\n    for([i, j] of trust){\\n        arr[i] -= 1;\\n        arr[j] += 1;\\n    }\\n    return arr.lastIndexOf(n-1);\\n  /*  indexOf() is not used beacause for the case of n =1 and trusted = []\\n      index of n-1 is 0 which is wrong answer.*/\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090862,
                "title": "kotlin-o-n-very-simple-solution",
                "content": "# Approach\\nJust keep track of how many does each n trust and is trusted by. Then traverse these and try to find the judge.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun findJudge(n: Int, trust: Array<IntArray>): Int {\\n        val trustFreq = IntArray(n+1) { 0 }\\n\\n        for ((from, to) in trust) {\\n            trustFreq[from]--\\n            trustFreq[to]++\\n        }\\n\\n        for (i in 1 .. n) {\\n            if (trustFreq[i] == n-1) return i\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findJudge(n: Int, trust: Array<IntArray>): Int {\\n        val trustFreq = IntArray(n+1) { 0 }\\n\\n        for ((from, to) in trust) {\\n            trustFreq[from]--\\n            trustFreq[to]++\\n        }\\n\\n        for (i in 1 .. n) {\\n            if (trustFreq[i] == n-1) return i\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090667,
                "title": "python-short-and-clean",
                "content": "# Approach\\n1. Count the number of `in_degrees` and `out_degrees` for every `person`.\\n\\n2. If a `person` has `in_degree = n - 1` and `out_degree = 0`, then he is the `judge`. If not, then no `judge` exists.\\n\\n3. To simplify the computation, finding a `person` with `in_degree - out_degree = n - 1` works the same as finding them explicitly.\\n\\n4. Hence, create an array `degrees`, such that `degree[i] = in_degree - out_degree, of person i`.\\n\\n5. Find the `index` in `degrees` which has value equals `n - 1` and rerturn it as `judge`.\\n\\n6. To handle the edge case of only one `person` present, set `degrees[0] = -1`\\n\\n7. To handle the edge case of no `judge` present, set `degrees[n + 1] = n - 1`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def findJudge(self, n: int, trust: list[list[int]]) -> int:\\n        degrees = list(chain((-1,), repeat(0, n), (n - 1,))) # Same as [-1] + [0] * n + [n - 1]\\n        \\n        for u, v in trust: degrees[u] -= 1; degrees[v] += 1\\n        \\n        judge = degrees.index(n - 1)\\n        return judge if judge <= n else -1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def findJudge(self, n: int, trust: list[list[int]]) -> int:\\n        degrees = list(chain((-1,), repeat(0, n), (n - 1,))) # Same as [-1] + [0] * n + [n - 1]\\n        \\n        for u, v in trust: degrees[u] -= 1; degrees[v] += 1\\n        \\n        judge = degrees.index(n - 1)\\n        return judge if judge <= n else -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090196,
                "title": "c-full-code-with-comments-simple-explanation",
                "content": "![997. Find the Town Judge.png](https://assets.leetcode.com/users/images/e68951ec-48d3-419d-997e-c0276015b783_1674478609.6216276.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        // base cases\\n        if(n==1)\\n        return n;\\n\\n        if(trust.size()==0)\\n        return -1;\\n\\n        vector<int>trusted(n+1);\\n\\n        for(auto x:trust)\\n        {\\n            // increment person who is trusted by everyone\\n            trusted[x[1]]++;\\n\\n            // decrement person who is not trusted by everyone\\n            trusted[x[0]]--;\\n        }\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            // return person who only trusts himself & no one else \\n            if(trusted[i]==n-1)\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        // base cases\\n        if(n==1)\\n        return n;\\n\\n        if(trust.size()==0)\\n        return -1;\\n\\n        vector<int>trusted(n+1);\\n\\n        for(auto x:trust)\\n        {\\n            // increment person who is trusted by everyone\\n            trusted[x[1]]++;\\n\\n            // decrement person who is not trusted by everyone\\n            trusted[x[0]]--;\\n        }\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            // return person who only trusts himself & no one else \\n            if(trusted[i]==n-1)\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090160,
                "title": "c-counting-degrees-of-graph",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>in(n+1),out(n+1);\\n        for(auto &i:trust)\\n        {\\n            in[i[1]]++;\\n            out[i[0]]--;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(in[i]==(n-1) and out[i]==0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>in(n+1),out(n+1);\\n        for(auto &i:trust)\\n        {\\n            in[i[1]]++;\\n            out[i[0]]--;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(in[i]==(n-1) and out[i]==0) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089996,
                "title": "c-easy-solution-beats-100-please-upvote",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>freq(n+1);\\n        for(int i=0;i<trust.size();i++){\\n            freq[trust[i][0]]--;\\n            freq[trust[i][1]]++;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(freq[i]==(n-1))\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>freq(n+1);\\n        for(int i=0;i<trust.size();i++){\\n            freq[trust[i][0]]--;\\n            freq[trust[i][1]]++;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(freq[i]==(n-1))\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089927,
                "title": "easy-c-solution-beats-80-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(trust.size()==0 && n==1) return 1;\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<trust.size();i++){\\n            adj[trust[i][0]].push_back(trust[i][1]);\\n        }\\n        for(int i=0;i<adj.size();i++){\\n            cout<<adj[i].size()<<endl;\\n        }\\n        vector<int>v;\\n        for(int i=0;i<adj.size();i++){\\n            if(adj[i].size()==0)\\n                v.push_back(i);\\n        }\\n        for(auto it:v){\\n            cout<<it<<\" \";\\n        }\\n        for(int k=0;k<v.size();k++){\\n            int c=0;\\n            for(int i=0;i<adj.size();i++){\\n                 for(int j=0;j<adj[i].size();j++){\\n                    if(v[k]==adj[i][j]){\\n                        c++;\\n                        break;\\n                    }\\n                }\\n            }\\n            cout<<c<<\" \";\\n            if(c==n-1){\\n                return v[k];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(trust.size()==0 && n==1) return 1;\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<trust.size();i++){\\n            adj[trust[i][0]].push_back(trust[i][1]);\\n        }\\n        for(int i=0;i<adj.size();i++){\\n            cout<<adj[i].size()<<endl;\\n        }\\n        vector<int>v;\\n        for(int i=0;i<adj.size();i++){\\n            if(adj[i].size()==0)\\n                v.push_back(i);\\n        }\\n        for(auto it:v){\\n            cout<<it<<\" \";\\n        }\\n        for(int k=0;k<v.size();k++){\\n            int c=0;\\n            for(int i=0;i<adj.size();i++){\\n                 for(int j=0;j<adj[i].size();j++){\\n                    if(v[k]==adj[i][j]){\\n                        c++;\\n                        break;\\n                    }\\n                }\\n            }\\n            cout<<c<<\" \";\\n            if(c==n-1){\\n                return v[k];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3089652,
                "title": "c-begineer-friendly-easy-understanding-array-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ONxGGZ_UhaE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int findJudge(int n, vector<vector<int>>& trust) {\\n        // trust and trustedby.\\n        vector<pair<int,int>>mp(n+1,{0,0});\\n        for(int i=0;i<trust.size();i++){\\n            int person = trust[i][0];\\n            int trustTo = trust[i][1];\\n\\n            mp[person].first +=1;\\n            mp[trustTo].second +=1;\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            if(mp[i].first == 0 && mp[i].second == n-1){return i;}\\n        }\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int findJudge(int n, vector<vector<int>>& trust) {\\n        // trust and trustedby.\\n        vector<pair<int,int>>mp(n+1,{0,0});\\n        for(int i=0;i<trust.size();i++){\\n            int person = trust[i][0];\\n            int trustTo = trust[i][1];\\n\\n            mp[person].first +=1;\\n            mp[trustTo].second +=1;\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            if(mp[i].first == 0 && mp[i].second == n-1){return i;}\\n        }\\n\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089537,
                "title": "c-2-array-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindJudge(int n, int[][] trust) \\n    {\\n        \\n        int[] howMuchTrustAPerson = new int[n+1];\\n        int[] whoDoesThePersonTrust = new int[n+1]; \\n\\n        for(int i = 0; i < trust.Length; i++)\\n        {\\n            howMuchTrustAPerson[trust[i][1]]++;\\n            whoDoesThePersonTrust[trust[i][0]]++;\\n        }\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(howMuchTrustAPerson[i] == n-1 && whoDoesThePersonTrust[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindJudge(int n, int[][] trust) \\n    {\\n        \\n        int[] howMuchTrustAPerson = new int[n+1];\\n        int[] whoDoesThePersonTrust = new int[n+1]; \\n\\n        for(int i = 0; i < trust.Length; i++)\\n        {\\n            howMuchTrustAPerson[trust[i][1]]++;\\n            whoDoesThePersonTrust[trust[i][0]]++;\\n        }\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(howMuchTrustAPerson[i] == n-1 && whoDoesThePersonTrust[i] == 0) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089277,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<br>\\nWe have 2 conditions to determine if someone\\'s a judge\\n\\n- Everybody trusts them\\n- Trusts no one\\n\\nIf we can map each person\\'s list of trusted people we can figure out whether the first condition applies\\nAnd if we can map each person\\'s trustees we can figure out whether the second condition applies\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. Use 2 hashmaps, one to store people whom the ith person \\ntrusts and another to store people who trust the ith person \\n2. Loop through one of the hashmaps and check the validity of the 2 conditions as follows\\n\\n```\\nforeach person in trustedHashmap:\\n    If size(trustedPeople[person]) == n - 1 and size(trustees[person]) == 0:\\n        return person\\nreturn -1\\n\\n```\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        trustMap = {i:[] for i in range(1, n+1)}\\n        trusteeMap = {i:[] for i in range(1, n+1)}\\n\\n        for t in trust:\\n            trustMap[t[1]].append(t[0])\\n            trusteeMap[t[0]].append(t[1])\\n        \\n        for i, jList in trustMap.items():\\n            if len(jList) == (n - 1) and len(trusteeMap[i]) == 0:\\n                return i\\n\\n        return -1\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nforeach person in trustedHashmap:\\n    If size(trustedPeople[person]) == n - 1 and size(trustees[person]) == 0:\\n        return person\\nreturn -1\\n\\n```\n```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        trustMap = {i:[] for i in range(1, n+1)}\\n        trusteeMap = {i:[] for i in range(1, n+1)}\\n\\n        for t in trust:\\n            trustMap[t[1]].append(t[0])\\n            trusteeMap[t[0]].append(t[1])\\n        \\n        for i, jList in trustMap.items():\\n            if len(jList) == (n - 1) and len(trusteeMap[i]) == 0:\\n                return i\\n\\n        return -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089242,
                "title": "easy-c-hash-implementation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        unordered_map<int,int>mp;\\n        int mx=INT_MIN;\\n        //o(n);\\n        int n1=trust.size();\\n        for(int i=0;i<n1;i++){\\n            mp[trust[i][0]]=trust[i][1];\\n        }\\n        int temp=-1;\\n        for(int i=1;i<=n;i++){\\n            if(mp.find(i)==mp.end()){\\n                temp=i; break;\\n            }\\n        }\\n        if(temp==-1) return -1;\\n        int count=0;\\n        for(int i=0;i<n1;i++){\\n            if(trust[i][1]==temp){\\n               count++;\\n            }\\n        }\\n        if(count==n-1) return temp;\\n\\n        return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        unordered_map<int,int>mp;\\n        int mx=INT_MIN;\\n        //o(n);\\n        int n1=trust.size();\\n        for(int i=0;i<n1;i++){\\n            mp[trust[i][0]]=trust[i][1];\\n        }\\n        int temp=-1;\\n        for(int i=1;i<=n;i++){\\n            if(mp.find(i)==mp.end()){\\n                temp=i; break;\\n            }\\n        }\\n        if(temp==-1) return -1;\\n        int count=0;\\n        for(int i=0;i<n1;i++){\\n            if(trust[i][1]==temp){\\n               count++;\\n            }\\n        }\\n        if(count==n-1) return temp;\\n\\n        return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089193,
                "title": "simplest-code-with-explanation-beats-99-90-time-and-90-memory",
                "content": "\\n![leetcode.png](https://assets.leetcode.com/users/images/96fe86de-624f-4c0e-90fe-da8a79994a32_1674459823.8859031.png)\\n# Intuition\\nThe Basic idea is to find 2 things:\\n1.A valueless key in dictionary.\\n2.That key should be value of all other keys.\\n\\n# Approach\\nThe approach is simple:\\n1.Create a hashmap or dict d() to check if a particular element or key has any value or not.\\n2.If a key doesn\\'t have any value then its a candidate for being a judge.\\n3.Then we check that for that particular key if it has N-1 trusts,that we already did with check dict ().\\n4.If condition 2 and 3 satisfies return the key else -1.\\n\\nMy First LeetCode try,would love your suggestions for improvement and if you like the code please upvote.Happy Koding :)\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(h):h-hashmap\\n\\n# Code\\n```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        d={}\\n        check=defaultdict(int)\\n        for i in trust:\\n            d[i[0]]=i[1] #To check key having no value\\n            check[i[1]]+=1  #This dict find total number of keys trusting a particular key\\n    \\n        for i in range(1,n+1):\\n            if d.get(i) is None and check[i]==n-1:\\n                return i\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        d={}\\n        check=defaultdict(int)\\n        for i in trust:\\n            d[i[0]]=i[1] #To check key having no value\\n            check[i[1]]+=1  #This dict find total number of keys trusting a particular key\\n    \\n        for i in range(1,n+1):\\n            if d.get(i) is None and check[i]==n-1:\\n                return i\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089135,
                "title": "using-set-c",
                "content": "\\tint findJudge(int n, vector<vector<int>>& v) {\\n\\t\\t\\tset<int> s;\\n\\t\\t\\tset<int> s2;\\n\\t\\t\\tfor(int i=0;i<v.size();i++){\\n\\t\\t\\t\\ts.insert(v[i][0]);\\n\\t\\t\\t\\ts2.insert(v[i][1]);\\n\\t\\t\\t}\\n\\t\\t\\tint jd=-1;\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tif(s.find(i)==s.end()){\\n\\t\\t\\t\\t\\tjd=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(s.size()==n-1){\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int i=0;i<v.size();i++){\\n\\t\\t\\t\\t\\tif(v[i][1]==jd){\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(cnt>1){\\n\\t\\t\\t\\t   return jd; \\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tif(n<=2){\\n\\t\\t\\t\\t\\t\\treturn jd;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tint findJudge(int n, vector<vector<int>>& v) {\\n\\t\\t\\tset<int> s;\\n\\t\\t\\tset<int> s2;\\n\\t\\t\\tfor(int i=0;i<v.size();i++){\\n\\t\\t\\t\\ts.insert(v[i][0]);\\n\\t\\t\\t\\ts2.insert(v[i][1]);\\n\\t\\t\\t}\\n\\t\\t\\tint jd=-1;\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tif(s.find(i)==s.end()){\\n\\t\\t\\t\\t\\tjd=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(s.size()==n-1){\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\tfor(int i=0;i<v.size();i++){\\n\\t\\t\\t\\t\\tif(v[i][1]==jd){\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(cnt>1){\\n\\t\\t\\t\\t   return jd; \\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tif(n<=2){\\n\\t\\t\\t\\t\\t\\treturn jd;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3089109,
                "title": "easy-c-using-maps",
                "content": "very abstractly implemented code.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        map<int,vector<int>>m;\\n\\n           int ans=-1;\\n         for(int i=1;i<=n;i++)\\n         m[i].push_back(-1);\\n\\n        \\n           for(auto x:trust)\\n           {\\n             if(m[x[0]].back()==-1)\\n             m[x[0]].pop_back();\\n            m[x[0]].push_back(x[1]);\\n           }\\n           for(auto x:m)\\n           {\\n             if(x.second.back()==-1)\\n             ans= x.first;\\n           }\\n           if(ans==-1)\\n           {\\n           return -1;}\\n          \\n           for(auto x:m)\\n           {\\n            int flag=-1;\\n            if(x.first==ans)\\n             continue;\\n             for(auto j:x.second)\\n             {if(j==ans)\\n              flag=1;\\n            \\n             }\\n             if(flag==-1)\\n              {\\n                return -1;}\\n             \\n           }\\n           return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        map<int,vector<int>>m;\\n\\n           int ans=-1;\\n         for(int i=1;i<=n;i++)\\n         m[i].push_back(-1);\\n\\n        \\n           for(auto x:trust)\\n           {\\n             if(m[x[0]].back()==-1)\\n             m[x[0]].pop_back();\\n            m[x[0]].push_back(x[1]);\\n           }\\n           for(auto x:m)\\n           {\\n             if(x.second.back()==-1)\\n             ans= x.first;\\n           }\\n           if(ans==-1)\\n           {\\n           return -1;}\\n          \\n           for(auto x:m)\\n           {\\n            int flag=-1;\\n            if(x.first==ans)\\n             continue;\\n             for(auto j:x.second)\\n             {if(j==ans)\\n              flag=1;\\n            \\n             }\\n             if(flag==-1)\\n              {\\n                return -1;}\\n             \\n           }\\n           return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088583,
                "title": "easiest-beginner-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        \\n    if(trust.length==0&&n==1)return 1;\\n    else if(trust.length==0)return -1;\\n\\n    HashMap<Integer,Boolean>count=new HashMap<>();\\n    HashMap<Integer,Integer>know=new HashMap<>();\\n\\n    for(int i=0;i<trust.length;i++){\\n        count.put(trust[i][0],true);\\n        if(!know.containsKey(trust[i][1])){\\n            know.put(trust[i][1],1);\\n        }\\n        else{\\n            know.put(trust[i][1],know.get(trust[i][1])+1);\\n        }\\n    }\\n\\n    for(int i=1;i<=n;i++){\\n        if(!count.containsKey(i)&&know.containsKey(i)&&know.get(i)==n-1){\\n            return i;\\n        }\\n    }\\n    \\n    return -1;\\n\\n    }\\n}\\n```\\n# Optimized Approach\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        \\n    if(trust.length==0&&n==1)return 1;\\n\\n    else if(trust.length==0)return -1;\\n\\n    int[] count=new int[n];\\n    \\n    int[] know=new int[n];\\n\\n    for(int i=0;i<trust.length;i++){\\n    \\n        count[trust[i][0]-1]=1;\\n    \\n        know[trust[i][1]-1]++;\\n    }\\n\\n    for(int i=0;i<n;i++){\\n    \\n        if(count[i]==0&&know[i]==n-1){\\n    \\n            return i+1;\\n    \\n        }\\n    }\\n    \\n    return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        \\n    if(trust.length==0&&n==1)return 1;\\n    else if(trust.length==0)return -1;\\n\\n    HashMap<Integer,Boolean>count=new HashMap<>();\\n    HashMap<Integer,Integer>know=new HashMap<>();\\n\\n    for(int i=0;i<trust.length;i++){\\n        count.put(trust[i][0],true);\\n        if(!know.containsKey(trust[i][1])){\\n            know.put(trust[i][1],1);\\n        }\\n        else{\\n            know.put(trust[i][1],know.get(trust[i][1])+1);\\n        }\\n    }\\n\\n    for(int i=1;i<=n;i++){\\n        if(!count.containsKey(i)&&know.containsKey(i)&&know.get(i)==n-1){\\n            return i;\\n        }\\n    }\\n    \\n    return -1;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        \\n    if(trust.length==0&&n==1)return 1;\\n\\n    else if(trust.length==0)return -1;\\n\\n    int[] count=new int[n];\\n    \\n    int[] know=new int[n];\\n\\n    for(int i=0;i<trust.length;i++){\\n    \\n        count[trust[i][0]-1]=1;\\n    \\n        know[trust[i][1]-1]++;\\n    }\\n\\n    for(int i=0;i<n;i++){\\n    \\n        if(count[i]==0&&know[i]==n-1){\\n    \\n            return i+1;\\n    \\n        }\\n    }\\n    \\n    return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403458,
                "title": "indegree-outdegree-c-easy",
                "content": "**CALCULATE INDEGREE AND OUTDEGREE OF EACH NODE**\\n```\\nint findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==1) return 1;\\n        map<int,int>in,out;\\n        for(int i=0;i<trust.size();i++){\\n            in[trust[i][1]]++;\\n            in[trust[i][0]]+=0;\\n            out[trust[i][0]]++;\\n            out[trust[i][1]]+=0;\\n        }\\n        for(auto it:in){\\n            if(it.second==n-1) {\\n                if(out[it.first]==0) return it.first;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "**CALCULATE INDEGREE AND OUTDEGREE OF EACH NODE**\\n```\\nint findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==1) return 1;\\n        map<int,int>in,out;\\n        for(int i=0;i<trust.size();i++){\\n            in[trust[i][1]]++;\\n            in[trust[i][0]]+=0;\\n            out[trust[i][0]]++;\\n            out[trust[i][1]]+=0;\\n        }\\n        for(auto it:in){\\n            if(it.second==n-1) {\\n                if(out[it.first]==0) return it.first;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2254506,
                "title": "find-the-town-judge-explained",
                "content": "Intuition :- \\nThe town judge trusts no one => the number of outgoing edges of town judge will be 0.\\nEveryone trusts the town judge => the number of incoming edges of the town judge will be n-1.\\n\\n1. Store the number of incoming and outgoing edges of all the vertex in two unordered maps respectively.\\n2. Now traverse trough all the vertex and if a vertex has 0 outgoing and n-1 incoming edges the return it.\\n3. Else return -1.\\n\\n- Time Complexity = O(n) + O(n) , for storing the number incoming & outgoing edges + traversing trough the vertices to find the town judge\\n- Space Complexity = O(n) + O(n) , for storing the number incoming & outgoing edges\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n\\n        unordered_map<int,int>out;//it stores the number of outgoing edges for a vertex\\n        unordered_map<int,int>in; // it stores the number of incoming edges for a vertex\\n        \\n        for(auto index : trust)\\n        {\\n            out[index[0]] ++; //outgoing edges\\n            in[index[1]]++;//incoming edges\\n        }\\n        \\n        for(int i =1;i<=n;i++)\\n        {\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n\\n        unordered_map<int,int>out;//it stores the number of outgoing edges for a vertex\\n        unordered_map<int,int>in; // it stores the number of incoming edges for a vertex\\n        \\n        for(auto index : trust)\\n        {\\n            out[index[0]] ++; //outgoing edges\\n            in[index[1]]++;//incoming edges\\n        }\\n        \\n        for(int i =1;i<=n;i++)\\n        {\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233863,
                "title": "c-solution-easy-approach-7-lines-code-easy-to-understand",
                "content": "```\\nint findJudge(int n, vector<vector<int>>& trust) {\\n        int sz = trust.size(); \\n        vector<int> arr(n+1, 0);\\n        for(int i=0; i<sz; i++)\\n            arr[trust[i][1]]++, arr[trust[i][0]]--;\\n        for(int i=1; i<n+1; i++)\\n            if(arr[i]==n-1)  return i;\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nint findJudge(int n, vector<vector<int>>& trust) {\\n        int sz = trust.size(); \\n        vector<int> arr(n+1, 0);\\n        for(int i=0; i<sz; i++)\\n            arr[trust[i][1]]++, arr[trust[i][0]]--;\\n        for(int i=1; i<n+1; i++)\\n            if(arr[i]==n-1)  return i;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2182808,
                "title": "java-well-explained-code-based-on-indegree-and-outdegree",
                "content": "![image](https://assets.leetcode.com/users/images/609c3c6c-b97a-42ee-9860-a6f15fe47134_1655895928.7668374.jpeg)\\n![image](https://assets.leetcode.com/users/images/4b35578e-4dd3-4279-9762-2b2dd169c6cf_1655895937.651557.jpeg)\\n*this solution has a 5 ms runtime *\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        //Initialise an indegree and outdegree\\n        //The size of this indegree array and outdegree array will be n+1 \\n        //because the array of people which is n = 4 starts from 1,2,3,4 \\n        //we will start the array from 0,1,2,3,4 so then we have one extra index so we will put n+1\\n        int[] inDegree = new int[n+1];\\n        int[] outDegree = new int[n+1];\\n        //we will iterate over our array \\n        for(int[] currentTrust: trust){\\n            int a = currentTrust[0];\\n            int b = currentTrust[1];\\n            //When a is trusting b Indegree of b will increase\\n            //And outdegree of a will increase \\n            inDegree[b] += 1;\\n            outDegree[a] += 1;\\n        }\\n        //When it is populated completely \\n        //I need to iterate over those n people\\n         for(int currentPeople = 1; currentPeople <= n; currentPeople++){\\n            //check the condition for town judge  \\n             //indegree[currentPeople]  == n-1 this means that we have all these incoming edges towards this person \\n             //if this condition is true return the town judge\\n             if(inDegree[currentPeople] == n-1 && outDegree[currentPeople] == 0)\\n                 return currentPeople;\\n        }\\n        //if we are not finding the town judge after this for loop return -1\\n         return -1;\\n    }\\n }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        //Initialise an indegree and outdegree\\n        //The size of this indegree array and outdegree array will be n+1 \\n        //because the array of people which is n = 4 starts from 1,2,3,4 \\n        //we will start the array from 0,1,2,3,4 so then we have one extra index so we will put n+1\\n        int[] inDegree = new int[n+1];\\n        int[] outDegree = new int[n+1];\\n        //we will iterate over our array \\n        for(int[] currentTrust: trust){\\n            int a = currentTrust[0];\\n            int b = currentTrust[1];\\n            //When a is trusting b Indegree of b will increase\\n            //And outdegree of a will increase \\n            inDegree[b] += 1;\\n            outDegree[a] += 1;\\n        }\\n        //When it is populated completely \\n        //I need to iterate over those n people\\n         for(int currentPeople = 1; currentPeople <= n; currentPeople++){\\n            //check the condition for town judge  \\n             //indegree[currentPeople]  == n-1 this means that we have all these incoming edges towards this person \\n             //if this condition is true return the town judge\\n             if(inDegree[currentPeople] == n-1 && outDegree[currentPeople] == 0)\\n                 return currentPeople;\\n        }\\n        //if we are not finding the town judge after this for loop return -1\\n         return -1;\\n    }\\n }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893623,
                "title": "c-simple-solution-for-begineers-easy-to-understand",
                "content": "```\\n\\tTime Complexity :~ O(n log(n))\\n\\tSpace Complexity :~ O(n^2)\\n\\t\\n    //Taking input in adjacency list. a -> b ----> adj[a] = [b]\\n    vector<int> adj[1001];\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n        for(auto a : trust)\\n        {\\n            adj[a[0]].push_back(a[1]);\\n        }\\n        \\n        //Interating from 1 to N to check who is not trusting to anybody\\n        //which implies adj[i] should be empty.\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            // checking adj[i] is empty or not.\\n            if(adj[i].size() == 0)\\n            {\\n                \\n                //Now, we to ensure that everybody trust this judge except self.\\n                \\n                bool flag = 0;\\n                for(int j=1; j<=n; j++)\\n                {\\n                    // adj[i] is a vector. So, we are copying in other vector.\\n                    vector<int> a = adj[j];\\n                    \\n                    //sorting is required to apply binary search.\\n                    sort(a.begin(), a.end());\\n                    \\n                    // Now check that this judge ( i ) is present in all others adjacency list except their own (i != j ).\\n                    // If not present we break the loop and change the flag value.\\n                    if(j!=i && !binary_search(a.begin(), a.end(), i))\\n                    {\\n                        flag = 1;\\n                        break;\\n                    }\\n                }\\n                \\n                // This ensures the judge (i) is present in all except and returns the value.\\n                if(!flag)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        \\n        //returning -1 when no judge is present in the town.\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\tTime Complexity :~ O(n log(n))\\n\\tSpace Complexity :~ O(n^2)\\n\\t\\n    //Taking input in adjacency list. a -> b ----> adj[a] = [b]\\n    vector<int> adj[1001];\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n        for(auto a : trust)\\n        {\\n            adj[a[0]].push_back(a[1]);\\n        }\\n        \\n        //Interating from 1 to N to check who is not trusting to anybody\\n        //which implies adj[i] should be empty.\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            // checking adj[i] is empty or not.\\n            if(adj[i].size() == 0)\\n            {\\n                \\n                //Now, we to ensure that everybody trust this judge except self.\\n                \\n                bool flag = 0;\\n                for(int j=1; j<=n; j++)\\n                {\\n                    // adj[i] is a vector. So, we are copying in other vector.\\n                    vector<int> a = adj[j];\\n                    \\n                    //sorting is required to apply binary search.\\n                    sort(a.begin(), a.end());\\n                    \\n                    // Now check that this judge ( i ) is present in all others adjacency list except their own (i != j ).\\n                    // If not present we break the loop and change the flag value.\\n                    if(j!=i && !binary_search(a.begin(), a.end(), i))\\n                    {\\n                        flag = 1;\\n                        break;\\n                    }\\n                }\\n                \\n                // This ensures the judge (i) is present in all except and returns the value.\\n                if(!flag)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n        \\n        //returning -1 when no judge is present in the town.\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783752,
                "title": "short-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>arr(n+1,0);\\n        for(int i=0 ; i<trust.size();i++){\\n            arr[trust[i][0]]--;\\n            arr[trust[i][1]]++;\\n        }\\n        for(int i=1; i<=n;i++){\\n           if(arr[i]==n-1)\\n               return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int>arr(n+1,0);\\n        for(int i=0 ; i<trust.size();i++){\\n            arr[trust[i][0]]--;\\n            arr[trust[i][1]]++;\\n        }\\n        for(int i=1; i<=n;i++){\\n           if(arr[i]==n-1)\\n               return i;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665197,
                "title": "find-the-town-judge-using-c",
                "content": "It\\'ll be solved using **directed graph** by counting in & outdegree for all people, then make sure that the judge doesn\\'t have any **outdegree** and have n-1 **indegree**.\\n\\nFor ex: Input: n = 3, trust = [[1, 3], [2, 3]] will be represent by the follwing graph\\n![image](https://assets.leetcode.com/users/images/30c7a729-c4e7-4f9b-aad3-04af664001de_1641252032.3218687.png)\\nNode 3 will have indegree = 2 which equal n-1 \\'3-1\\' and outdegree = 0\\n\\n##### Solution:\\n\\n```\\n public int FindJudge(int n, int[][] trust) {\\n        int[] indegree = new int[n +1];\\n        int[] outdegree = new int[n +1];\\n        int judge = -1;\\n        foreach(int[] person in trust){\\n            indegree[person[1]]++;\\n            outdegree[person[0]]++;\\n        }\\n        \\n        for(int i=1; i <= n; i++)\\n            if(indegree[i] == n-1 && outdegree[i] == 0 && judge == -1)\\n                judge = i;\\n        \\n        return judge;     \\n    }\\n```",
                "solutionTags": [
                    "C#",
                    "Graph"
                ],
                "code": "```\\n public int FindJudge(int n, int[][] trust) {\\n        int[] indegree = new int[n +1];\\n        int[] outdegree = new int[n +1];\\n        int judge = -1;\\n        foreach(int[] person in trust){\\n            indegree[person[1]]++;\\n            outdegree[person[0]]++;\\n        }\\n        \\n        for(int i=1; i <= n; i++)\\n            if(indegree[i] == n-1 && outdegree[i] == 0 && judge == -1)\\n                judge = i;\\n        \\n        return judge;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1664738,
                "title": "c-linq-one-liner-o-n",
                "content": "```\\npublic class Solution {\\n    public int FindJudge(int n, int[][] trust)\\n        => Enumerable\\n            .Range(1, n).Except(trust.Select(tp => tp[0])) // ones who trust nobody\\n            .Take(1) // there can be only one\\n            .Where(x => trust.Count(tp => tp[1] == x) == n - 1) // do everyone trust him?\\n            .FirstOrDefault(-1); // return -1 if empty\\n} \\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindJudge(int n, int[][] trust)\\n        => Enumerable\\n            .Range(1, n).Except(trust.Select(tp => tp[0])) // ones who trust nobody\\n            .Take(1) // there can be only one\\n            .Where(x => trust.Count(tp => tp[1] == x) == n - 1) // do everyone trust him?\\n            .FirstOrDefault(-1); // return -1 if empty\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664542,
                "title": "java-simple-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int res[] = new int[n];\\n        for(int i = 0;i<trust.length;i++){\\n            res[trust[i][1] - 1]++;\\n            res[trust[i][0] - 1]--;\\n        }\\n        for(int i = 0;i<res.length;i++){\\n            if(res[i] == n-1){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int res[] = new int[n];\\n        for(int i = 0;i<trust.length;i++){\\n            res[trust[i][1] - 1]++;\\n            res[trust[i][0] - 1]--;\\n        }\\n        for(int i = 0;i<res.length;i++){\\n            if(res[i] == n-1){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664024,
                "title": "java-using-streams-optional",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Optional;\\n\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n == 1) return 1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        boolean[] isntTownJudge = new boolean[n + 1];\\n        for(int[] e: trust) {\\n            isntTownJudge[e[0]] = true;\\n            map.put(e[1], map.getOrDefault(e[1], 0) + 1);\\n        }\\n        Optional<Map.Entry<Integer, Integer>> judge = map.entrySet().stream().filter(item -> item.getValue() == (n - 1) && !isntTownJudge[item.getKey()]).findFirst();\\n        return judge.isPresent() ? judge.get().getKey() : -1;\\n\\n    }\\n}\\n```\\n\\nPlease upvote If you like it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.Optional;\\n\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        if(n == 1) return 1;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        boolean[] isntTownJudge = new boolean[n + 1];\\n        for(int[] e: trust) {\\n            isntTownJudge[e[0]] = true;\\n            map.put(e[1], map.getOrDefault(e[1], 0) + 1);\\n        }\\n        Optional<Map.Entry<Integer, Integer>> judge = map.entrySet().stream().filter(item -> item.getValue() == (n - 1) && !isntTownJudge[item.getKey()]).findFirst();\\n        return judge.isPresent() ? judge.get().getKey() : -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601272,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        d = {}\\n        for i in trust:\\n            try:\\n                x = d[i[0]]\\n                x.append(i[1])\\n                d[i[0]] = x\\n            except KeyError:\\n                d[i[0]] = [i[1]]\\n        \\n        townjudgeCandidates = []\\n        for i in range(1,n+1):\\n            try:\\n                x = d[i]\\n            except KeyError:\\n                d[i] = []\\n                townjudgeCandidates.append(i)\\n        \\n        if len(townjudgeCandidates) == 0:\\n            return -1\\n        \\n        found = True\\n        for cand in townjudgeCandidates:\\n            for i in range(1,n+1):\\n                if i != cand:\\n                    if cand not in d[i]:\\n                        found = False\\n                        break\\n            if found == True:\\n                return cand\\n        if found == False:\\n            return -1\\n        \\n            \\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 1530758,
                "title": "python-counter-easy-to-understand",
                "content": "```\\ndef findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        a = [0] * n\\n        b = [0] * n\\n        for t in trust:\\n            a[t[0]-1] += 1\\n            b[t[1]-1] += 1\\n        \\n        for i in range(n):\\n            if b[i] == n - 1 and a[i] == 0:\\n                return i + 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        a = [0] * n\\n        b = [0] * n\\n        for t in trust:\\n            a[t[0]-1] += 1\\n            b[t[1]-1] += 1\\n        \\n        for i in range(n):\\n            if b[i] == n - 1 and a[i] == 0:\\n                return i + 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1450823,
                "title": "c-simple-solution-based-on-outdegree-and-indegree",
                "content": "Maintain two array which will keep track of indegree and outdegree, then check for index for which indegree==n-1 and outdegree==0 ( It will satisfy the condition of being Town Judge).\\n\\n\\n````\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int res=-1;\\n        //const int len=n;\\n        int inOrder[n+1];\\n        int outOrder[n+1];\\n        fill(inOrder,inOrder+n+1,0);\\n        fill(outOrder,outOrder+n+1,0);\\n        for(auto x:trust)\\n        {\\n            inOrder[x[1]]++;\\n            outOrder[x[0]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inOrder[i]==n-1 and outOrder[i]==0)\\n                res=i;\\n        }\\n        return res;\\n    }\\n};\\n````\\n Thank You!\\n Keep Coding :)",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int res=-1;\\n        //const int len=n;\\n        int inOrder[n+1];\\n        int outOrder[n+1];\\n        fill(inOrder,inOrder+n+1,0);\\n        fill(outOrder,outOrder+n+1,0);\\n        for(auto x:trust)\\n        {\\n            inOrder[x[1]]++;\\n            outOrder[x[0]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(inOrder[i]==n-1 and outOrder[i]==0)\\n                res=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364072,
                "title": "java-99-85-faster-2ms-no-maps-sets",
                "content": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int[] judges = new int[n+1];\\n        boolean[] trusts = new boolean[n+1];\\n    \\n        for(int i=0;i<trust.length;i++) {\\n            judges[trust[i][1]]++;\\n            trusts[trust[i][0]] = true;\\n        }\\n        \\n        for(int i =1;i<n+1;i++) {\\n            if(judges[i] == (n-1) && !trusts[i]) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int[] judges = new int[n+1];\\n        boolean[] trusts = new boolean[n+1];\\n    \\n        for(int i=0;i<trust.length;i++) {\\n            judges[trust[i][1]]++;\\n            trusts[trust[i][0]] = true;\\n        }\\n        \\n        for(int i =1;i<n+1;i++) {\\n            if(judges[i] == (n-1) && !trusts[i]) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359649,
                "title": "python-counter-set-difference",
                "content": "```python\\ndef findJudge(self, n, trust):\\n\\n\\t# Condition 1\\n\\tcannidates = set(range(1, n+1)) - set([i[0] for i in trust])\\n\\t\\n\\t# Condition 2\\n\\tcounts = collections.Counter()\\n\\tfor a, b in trust: counts[b] += 1\\n\\n\\t# Greedy\\n\\tfor i in cannidates:\\n\\t\\tif counts[i] == n-1:\\n\\t\\t\\treturn i\\n\\n\\treturn -1 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```python\\ndef findJudge(self, n, trust):\\n\\n\\t# Condition 1\\n\\tcannidates = set(range(1, n+1)) - set([i[0] for i in trust])\\n\\t\\n\\t# Condition 2\\n\\tcounts = collections.Counter()\\n\\tfor a, b in trust: counts[b] += 1\\n\\n\\t# Greedy\\n\\tfor i in cannidates:\\n\\t\\tif counts[i] == n-1:\\n\\t\\t\\treturn i\\n\\n\\treturn -1 \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1304298,
                "title": "javascript-99-faster",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(n, trust) {\\n    const trustRecord = new Array(n+1).fill(0)\\n    for (const [person, trusted] of trust) {\\n        trustRecord[person]--\\n        trustRecord[trusted]++\\n    }\\n    for (let i = 1; i <= n; i++) {\\n        if (trustRecord[i] === n-1)\\n            return i\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} trust\\n * @return {number}\\n */\\nvar findJudge = function(n, trust) {\\n    const trustRecord = new Array(n+1).fill(0)\\n    for (const [person, trusted] of trust) {\\n        trustRecord[person]--\\n        trustRecord[trusted]++\\n    }\\n    for (let i = 1; i <= n; i++) {\\n        if (trustRecord[i] === n-1)\\n            return i\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145954,
                "title": "java-simple-graph-solution",
                "content": "```class Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[] arr = new int[N];\\n\\n        for (int[] citizens : trust) {\\n            arr[citizens[0] - 1] --;\\n            arr[citizens[1] - 1] ++;\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == N - 1 ) {\\n                return i + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[] arr = new int[N];\\n\\n        for (int[] citizens : trust) {\\n            arr[citizens[0] - 1] --;\\n            arr[citizens[1] - 1] ++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1102698,
                "title": "easy-java-solution-in-degree-and-out-degree",
                "content": "In this question we check for the in degee and out degree of each node and check if count of outdegree = 0(judge trust no body) and count degree = N-1(every body trust judge).which ever node satisfy this condition return that node else return -1 .\\nStiil stuck check the solution.\\n```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[] in = new int[N+1];\\n        int[] out = new int[N+1];\\n        for(int[] item : trust){\\n            in[item[1]]++;\\n            out[item[0]]++;\\n        }\\n            for(int i = 1 ; i <= N ; i++){\\n                if(in[i] == N-1 && out[i] == 0)\\n                    return i ;\\n            }\\n        return -1 ;\\n    \\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/b102ea15-740e-4661-a32e-1ad050a581d2_1615364850.5187428.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[] in = new int[N+1];\\n        int[] out = new int[N+1];\\n        for(int[] item : trust){\\n            in[item[1]]++;\\n            out[item[0]]++;\\n        }\\n            for(int i = 1 ; i <= N ; i++){\\n                if(in[i] == N-1 && out[i] == 0)\\n                    return i ;\\n            }\\n        return -1 ;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976724,
                "title": "99-faster-in-java-with-explanation",
                "content": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n\\t// empty input edge case\\n        if(trust.length==0)\\n            return N==trust.length+1?N:-1;\\n\\t\\t\\t//store people info\\n      int[]ar = new int[N+1];\\n\\t  //each one in index 0 is not the town judge\\n        for(int i = 0 ; i < trust.length ;i++)\\n        {\\n            ar[trust[i][0]] =-1;\\n        }\\n\\t\\t//increment the trust value given to each one from the city \\n\\t\\t// if and only if the current person is a possible judge( meaning that he is not in the index 0)\\n        for(int i = 0 ; i < trust.length ;i++)\\n        {\\n            if(ar[trust[i][1]]!=-1)\\n                ar[trust[i][1]]++;\\n        }\\n\\t\\t//the town judge must have N-1 trusts (because he can\\'t trust himself)\\n        for(int i = 0 ; i < ar.length ;i++)\\n            if(ar[i]==N-1)\\n                return i;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n\\t// empty input edge case\\n        if(trust.length==0)\\n            return N==trust.length+1?N:-1;\\n\\t\\t\\t//store people info\\n      int[]ar = new int[N+1];\\n\\t  //each one in index 0 is not the town judge\\n        for(int i = 0 ; i < trust.length ;i++)\\n        {\\n            ar[trust[i][0]] =-1;\\n        }\\n\\t\\t//increment the trust value given to each one from the city \\n\\t\\t// if and only if the current person is a possible judge( meaning that he is not in the index 0)\\n        for(int i = 0 ; i < trust.length ;i++)\\n        {\\n            if(ar[trust[i][1]]!=-1)\\n                ar[trust[i][1]]++;\\n        }\\n\\t\\t//the town judge must have N-1 trusts (because he can\\'t trust himself)\\n        for(int i = 0 ; i < ar.length ;i++)\\n            if(ar[i]==N-1)\\n                return i;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874663,
                "title": "brute-force-c",
                "content": "\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint findJudge(int N, vector<vector<int>>& trust) {\\n\\t\\t\\t\\t\\tif(N==1) return 1;\\n\\t\\t\\t\\t\\tvector<int> vals(N+1,0);\\n\\t\\t\\t\\t\\tfor(auto x:trust)\\n\\t\\t\\t\\t\\t{  vals[x[0]]-=1;\\n\\t\\t\\t\\t\\t\\tvals[x[1]]+=1;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int i=1;i<vals.size();i++){\\n\\t\\t\\t\\t\\t\\tif(vals[i]==N-1) return i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint findJudge(int N, vector<vector<int>>& trust) {\\n\\t\\t\\t\\t\\tif(N==1) return 1;\\n\\t\\t\\t\\t\\tvector<int> vals(N+1,0);\\n\\t\\t\\t\\t\\tfor(auto x:trust)\\n\\t\\t\\t\\t\\t{  vals[x[0]]-=1;\\n\\t\\t\\t\\t\\t\\tvals[x[1]]+=1;\\n\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 859111,
                "title": "go-solution-graph",
                "content": "https://github.com/phea/leetcode-go\\n```go\\nfunc findJudge(N int, trust [][]int) int {\\n\\tif len(trust) == 0 && N == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\t// out, in\\n\\tedges := make([][2]int, N+1)\\n\\tcandidates := []int{}\\n\\tfor _, t := range trust {\\n\\t\\tedges[t[0]][0]++\\n\\t\\tedges[t[1]][1]++\\n\\t\\tif edges[t[1]][1] == N-1 {\\n\\t\\t\\tcandidates = append(candidates, t[1])\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, c := range candidates {\\n\\t\\tif edges[c][0] == 0 {\\n\\t\\t\\treturn c\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Graph"
                ],
                "code": "```go\\nfunc findJudge(N int, trust [][]int) int {\\n\\tif len(trust) == 0 && N == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\t// out, in\\n\\tedges := make([][2]int, N+1)\\n\\tcandidates := []int{}\\n\\tfor _, t := range trust {\\n\\t\\tedges[t[0]][0]++\\n\\t\\tedges[t[1]][1]++\\n\\t\\tif edges[t[1]][1] == N-1 {\\n\\t\\t\\tcandidates = append(candidates, t[1])\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, c := range candidates {\\n\\t\\tif edges[c][0] == 0 {\\n\\t\\t\\treturn c\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678376,
                "title": "c-using-direct-graph",
                "content": "**Intuition:**\\nConsider trust as a graph, all pairs are directed edge.\\nThe point with  **in-degree - out-degree = N - 1** become the judge.\\n\\n**Explanation:**\\nCount the degree, and check at the end.\\n\\n**Time Complexity:**\\nTime O(T + N), space O(N)\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> degree(N+1,0);\\n        for(auto people : trust) \\n        {\\n            degree[people[0]]--;\\n            degree[people[1]]++;\\n        }\\n        \\n        for(int i=1; i<=N; i++) \\n        {\\n            if(degree[i] == N-1)\\n            {\\n                return i; \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};**\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> degree(N+1,0);\\n        for(auto people : trust) \\n        {\\n            degree[people[0]]--;\\n            degree[people[1]]++;\\n        }\\n        \\n        for(int i=1; i<=N; i++) \\n        {\\n            if(degree[i] == N-1)\\n            {\\n                return i; \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673711,
                "title": "python-3-solution-with-explanation-faster-than-99-40",
                "content": "\\tdef findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        arr = [0] * N                #Create an array of length N\\n        for i,j in trust:            #itterate each 2-element array in trust\\n                arr[j-1] += 1        #add 1 to the incoming element node             \\n                arr[i-1] -= 1        #subtract 1 to the outgoing element index  \\n        if max(arr) == N-1:          # If maximum element in the array is N-1 it means there\\'s one node which does not trust any other person)\\n            return arr.index(max(arr))+1\\n        else:\\n            return -1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tdef findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        arr = [0] * N                #Create an array of length N\\n        for i,j in trust:            #itterate each 2-element array in trust\\n                arr[j-1] += 1        #add 1 to the incoming element node             \\n                arr[i-1] -= 1        #subtract 1 to the outgoing element index  \\n        if max(arr) == N-1:          # If maximum element in the array is N-1 it means there\\'s one node which does not trust any other person)\\n            return arr.index(max(arr))+1\\n        else:\\n            return -1",
                "codeTag": "Python3"
            },
            {
                "id": 624996,
                "title": "java-o-n-solution-faster-than-100-100-less-memory",
                "content": "```\\npublic int findJudge(int N, int[][] trust) {\\n        if(N==0)return 0;\\n        if(N==1 && trust.length==0)return 1;\\n        int[] t=new int[N+1];\\n        for(int[] p:trust){\\n            t[p[0]]--;\\n            t[p[1]]++;\\n        }\\n        int ans=-1;\\n        for(int i=0;i<t.length;i++){\\n            if(t[i]==N-1)\\n            {ans=i;return ans;}\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findJudge(int N, int[][] trust) {\\n        if(N==0)return 0;\\n        if(N==1 && trust.length==0)return 1;\\n        int[] t=new int[N+1];\\n        for(int[] p:trust){\\n            t[p[0]]--;\\n            t[p[1]]++;\\n        }\\n        int ans=-1;\\n        for(int i=0;i<t.length;i++){\\n            if(t[i]==N-1)\\n            {ans=i;return ans;}\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624742,
                "title": "cpp-simple-easy-straightforward-linear-time-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        if(N==1)\\n            return 1;\\n        int tr[1002]={0};\\n        for(auto x:trust){\\n            tr[x[1]]++;\\n            tr[x[0]]--;\\n        }\\n        auto x=find(tr,tr+N+2,N-1);\\n        return x!=tr+N+2?distance(tr, x):-1;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        if(N==1)\\n            return 1;\\n        int tr[1002]={0};\\n        for(auto x:trust){\\n            tr[x[1]]++;\\n            tr[x[0]]--;\\n        }\\n        auto x=find(tr,tr+N+2,N-1);\\n        return x!=tr+N+2?distance(tr, x):-1;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624330,
                "title": "rust-o-n-20ms",
                "content": "```\\nimpl Solution {\\n    pub fn find_judge(n: i32, trust: Vec<Vec<i32>>) -> i32 {\\n        let mut outbound = vec![0; n as usize];\\n        let mut inbound = vec![0; n as usize];\\n\\n        for v in trust.iter() {\\n            outbound[(v[0] - 1) as usize] += 1;\\n            inbound[(v[1] - 1) as usize] += 1;\\n        }\\n\\n        for i in 0..n {\\n            if inbound[i as usize] == (n - 1) as usize\\n                && outbound[i as usize] == 0 {\\n                return i + 1;\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn find_judge(n: i32, trust: Vec<Vec<i32>>) -> i32 {\\n        let mut outbound = vec![0; n as usize];\\n        let mut inbound = vec![0; n as usize];\\n\\n        for v in trust.iter() {\\n            outbound[(v[0] - 1) as usize] += 1;\\n            inbound[(v[1] - 1) as usize] += 1;\\n        }\\n\\n        for i in 0..n {\\n            if inbound[i as usize] == (n - 1) as usize\\n                && outbound[i as usize] == 0 {\\n                return i + 1;\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454147,
                "title": "python3-one-pass-solution",
                "content": "```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        cnt, trust_sb, judge = [0] * N, set(), 1\\n        for s, t in trust:\\n            trust_sb.add(s)\\n            cnt[t - 1] += 1\\n            if cnt[t - 1] == N - 1: \\n                judge = t\\n        return judge not in trust_sb and judge or -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        cnt, trust_sb, judge = [0] * N, set(), 1\\n        for s, t in trust:\\n            trust_sb.add(s)\\n            cnt[t - 1] += 1\\n            if cnt[t - 1] == N - 1: \\n                judge = t\\n        return judge not in trust_sb and judge or -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404001,
                "title": "python-logical-solution-no-hashing-required",
                "content": "\\tclass Solution(object):\\n\\t\\tdef findJudge(self, N, trust):\\n\\t\\t\\tif trust==[] and N==1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tx1 = [x[1] for x in trust]\\n\\t\\t\\tx0 = [x[0] for x in trust]\\n\\t\\t\\tfor i in range(1, N+1):\\n\\t\\t\\t\\tif i in x1:\\n\\t\\t\\t\\t\\tif x1.count(i)==(N-1):\\n\\t\\t\\t\\t\\t\\tif i not in x0:\\n\\t\\t\\t\\t\\t\\t\\treturn i\\n\\t\\t\\treturn -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef findJudge(self, N, trust):\\n\\t\\t\\tif trust==[] and N==1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tx1 = [x[1] for x in trust]\\n\\t\\t\\tx0 = [x[0] for x in trust]\\n\\t\\t\\tfor i in range(1, N+1):\\n\\t\\t\\t\\tif i in x1:\\n\\t\\t\\t\\t\\tif x1.count(i)==(N-1):\\n\\t\\t\\t\\t\\t\\tif i not in x0:\\n\\t\\t\\t\\t\\t\\t\\treturn i\\n\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 394793,
                "title": "easy-c-solution-clean-code",
                "content": "Runtime: 156 ms, faster than 77.99% of C++ online submissions for Find the Town Judge.\\nMemory Usage: 42.4 MB, less than 75.00% of C++ online submissions for Find the Town Judge.\\n\\n```\\nint findJudge(int N, vector<vector<int>>& trust) {\\n        \\n        vector<int> in(N+1);\\n        vector<int> out(N+1);\\n        int judge = -1;\\n        \\n        for(int i=0; i<trust.size(); i++)\\n        {\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        \\n        for(int i=0; i<=N; i++)\\n            if(in[i] == N - 1 && out[i] == 0)\\n                judge = i;\\n        \\n        return judge;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 156 ms, faster than 77.99% of C++ online submissions for Find the Town Judge.\\nMemory Usage: 42.4 MB, less than 75.00% of C++ online submissions for Find the Town Judge.\\n\\n```\\nint findJudge(int N, vector<vector<int>>& trust) {\\n        \\n        vector<int> in(N+1);\\n        vector<int> out(N+1);\\n        int judge = -1;\\n        \\n        for(int i=0; i<trust.size(); i++)\\n        {\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        \\n        for(int i=0; i<=N; i++)\\n            if(in[i] == N - 1 && out[i] == 0)\\n                judge = i;\\n        \\n        return judge;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 264024,
                "title": "simple-java-99-100",
                "content": "I use a trustTable where the first element indicates how many people a persons trusts and the second - how many people is the person trusted by.\\n\\nAssumption - **no duplicates in the input array.** (I see that other solutions have that assumption as well)\\n\\n```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[][] trustTable = new int[N][2];\\n        \\n        for (int i=0;i<trust.length; i++) {\\n            trustTable[trust[i][0] - 1][0]++;\\n            trustTable[trust[i][1] - 1][1]++;\\n        }\\n        \\n        for (int i=0;i<trustTable.length;i++) {\\n            if (trustTable[i][0] == 0 && trustTable[i][1] == N-1) {\\n                return i+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findJudge(int N, int[][] trust) {\\n        int[][] trustTable = new int[N][2];\\n        \\n        for (int i=0;i<trust.length; i++) {\\n            trustTable[trust[i][0] - 1][0]++;\\n            trustTable[trust[i][1] - 1][1]++;\\n        }\\n        \\n        for (int i=0;i<trustTable.length;i++) {\\n            if (trustTable[i][0] == 0 && trustTable[i][1] == N-1) {\\n                return i+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 245042,
                "title": "easy-simple-javascript-solution-100",
                "content": "Start off with a map of size N starting with all 1\\'s.\\nWhen someone trusts somebody, decrease thier number in the map (judge trusts nobody)\\nincrease the number of who they trust (judge is trusted by everybody).\\nAt the end, if someone is trusted by everyone and trusts no one, their number will be N in the map\\n\\n```\\nvar findJudge = function(N, trust) {\\n    const map = new Map();\\n    for(let nums=1; nums<=N; nums++)\\n    {\\n        map.set(nums,1);\\n    }\\n\\n    for(let t=0; t<trust.length; t++)\\n    {\\n\\n        map.set(trust[t][0],map.get(trust[t][0])-1); //judge trusts nobody\\n        map.set(trust[t][1],map.get(trust[t][1])+1); //everyone trusts the judge\\n    }\\n    //The judge should be trusted by N people. (+1)\\n    //If the judge trusted anyone, it would not be N because -1\\n    \\n    for (const [k, v] of map.entries()) {\\n      if(v==N) return k;\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findJudge = function(N, trust) {\\n    const map = new Map();\\n    for(let nums=1; nums<=N; nums++)\\n    {\\n        map.set(nums,1);\\n    }\\n\\n    for(let t=0; t<trust.length; t++)\\n    {\\n\\n        map.set(trust[t][0],map.get(trust[t][0])-1); //judge trusts nobody\\n        map.set(trust[t][1],map.get(trust[t][1])+1); //everyone trusts the judge\\n    }\\n    //The judge should be trusted by N people. (+1)\\n    //If the judge trusted anyone, it would not be N because -1\\n    \\n    for (const [k, v] of map.entries()) {\\n      if(v==N) return k;\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243732,
                "title": "c-super-easy-and-short-7-line-solution-beats-100-time-and-100-space",
                "content": "```\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> score(N, 1);\\n        for(int i=0;i<trust.size();i++) {\\n            score[trust[i][0]-1]--;\\n            score[trust[i][1]-1]++;\\n        }\\n        for(int i=0;i<N;i++) {\\n            if(score[i]==N) return i+1;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n        vector<int> score(N, 1);\\n        for(int i=0;i<trust.size();i++) {\\n            score[trust[i][0]-1]--;\\n            score[trust[i][1]-1]++;\\n        }\\n        for(int i=0;i<N;i++) {\\n            if(score[i]==N) return i+1;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 242910,
                "title": "simple-python-soution",
                "content": "```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        if N==1:\\n            return 1\\n        ans = []\\n        for i in range(len(trust)):\\n            ans.append(trust[i][1])\\n        counts = collections.Counter(ans)\\n        y = sorted(ans, key=counts.get, reverse=True)[0]\\n        for i in range(len(trust)):\\n            if trust[i][0] == y:\\n                return -1\\n        return y\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findJudge(self, N: int, trust: List[List[int]]) -> int:\\n        if N==1:\\n            return 1\\n        ans = []\\n        for i in range(len(trust)):\\n            ans.append(trust[i][1])\\n        counts = collections.Counter(ans)\\n        y = sorted(ans, key=counts.get, reverse=True)[0]\\n        for i in range(len(trust)):\\n            if trust[i][0] == y:\\n                return -1\\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 242900,
                "title": "my-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n\\t\\tvector<int> in(N + 1), out(N + 1);\\n\\t\\tfor (auto a : trust) {\\n\\t\\t\\t++out[a[0]];\\n\\t\\t\\t++in[a[1]];\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= N; ++i) {\\n\\t\\t\\tif (in[i] == N - 1 && out[i] == 0) return i;\\n\\t\\t}\\n\\t\\treturn -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findJudge(int N, vector<vector<int>>& trust) {\\n\\t\\tvector<int> in(N + 1), out(N + 1);\\n\\t\\tfor (auto a : trust) {\\n\\t\\t\\t++out[a[0]];\\n\\t\\t\\t++in[a[1]];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3938383,
                "title": "c-killer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n        vector<int> v(n+1,0);\\n        for(auto i :trust)\\n        {\\n            v[i[0]]--;\\n            v[i[1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(v[i]==n-1)\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) \\n    {\\n        vector<int> v(n+1,0);\\n        for(auto i :trust)\\n        {\\n            v[i[0]]--;\\n            v[i[1]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(v[i]==n-1)\\n            return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800130,
                "title": "simple-c-solution-using-indegree-and-outdegree",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(trust.empty() && n==1) return 1;\\n        vector<int>indegree(n+1,0);\\n        vector<int>outdegree(n+1,0);\\n        for(auto it:trust)\\n        {\\n            outdegree[it[0]]++;\\n            indegree[it[1]]++;\\n        }\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(outdegree[i]==0 && indegree[i]==n-1)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(trust.empty() && n==1) return 1;\\n        vector<int>indegree(n+1,0);\\n        vector<int>outdegree(n+1,0);\\n        for(auto it:trust)\\n        {\\n            outdegree[it[0]]++;\\n            indegree[it[1]]++;\\n        }\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(outdegree[i]==0 && indegree[i]==n-1)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603233,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int count=0;\\n        int x[]=new int[n+1];\\n        int y[]=new int[n+1];\\n         Arrays.fill(x, 0);\\n         Arrays.fill(y, 0);\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            x[trust[i][0]]=1;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(x[i]!=0)\\n            count++;\\n            if(x[i]==0)\\n            y[i]=1;\\n        }\\n        if(count==n)\\n        return -1;\\n       for(int i=1;i<=n;i++)\\n       System.out.println(y[i]);\\n       int jud=0;\\n         for(int i=1;i<=n;i++)\\n        {\\n            if(y[i]==1)\\n            jud=i;\\n        }\\n        int c=0;\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            if(trust[i][1]==jud)\\n            c++;\\n        }\\n        if(c==n-1)\\n        return jud;\\n        return -1;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int count=0;\\n        int x[]=new int[n+1];\\n        int y[]=new int[n+1];\\n         Arrays.fill(x, 0);\\n         Arrays.fill(y, 0);\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            x[trust[i][0]]=1;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(x[i]!=0)\\n            count++;\\n            if(x[i]==0)\\n            y[i]=1;\\n        }\\n        if(count==n)\\n        return -1;\\n       for(int i=1;i<=n;i++)\\n       System.out.println(y[i]);\\n       int jud=0;\\n         for(int i=1;i<=n;i++)\\n        {\\n            if(y[i]==1)\\n            jud=i;\\n        }\\n        int c=0;\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            if(trust[i][1]==jud)\\n            c++;\\n        }\\n        if(c==n-1)\\n        return jud;\\n        return -1;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521822,
                "title": "find-the-town-judge-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int i, j, count;\\n        if(n==1 && trust.size()==0)\\n        {\\n            return 1;\\n        }\\n        for(i=0 ; i<trust.size() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<trust.size() ; j++)\\n            {\\n                if(trust[j][1]==trust[i][1])\\n                {\\n                    count++;\\n                }\\n                if(trust[j][0]==trust[i][1])\\n                {\\n                    count=0;\\n                    break;\\n                }\\n            }\\n            if(count==n-1 && n!=1)\\n            {\\n                return trust[i][1];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/a91e8278-dbc8-4060-b39f-ed79eb8015f9_1684035622.9046552.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        int i, j, count;\\n        if(n==1 && trust.size()==0)\\n        {\\n            return 1;\\n        }\\n        for(i=0 ; i<trust.size() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<trust.size() ; j++)\\n            {\\n                if(trust[j][1]==trust[i][1])\\n                {\\n                    count++;\\n                }\\n                if(trust[j][0]==trust[i][1])\\n                {\\n                    count=0;\\n                    break;\\n                }\\n            }\\n            if(count==n-1 && n!=1)\\n            {\\n                return trust[i][1];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474081,
                "title": "easy-c-solution-based-on-in-degree-and-out-degree",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTown judge should have an in_degree equal to n-1 and out_degree equal to zero.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFinding the out degree and in degree of every vertex and finding the vertex with out_degree=0 and in_degree=n-1\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> in(n+1,0), out(n+1,0);\\n        \\n        for(int i=0;i<trust.size();i++){\\n            out[trust[i][0]]+=1;\\n            in[trust[i][1]]+=1;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<=n;i++){\\n            if(out[i]==0){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans==INT_MIN) return -1;\\n        if(in[ans]==n-1) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        vector<int> in(n+1,0), out(n+1,0);\\n        \\n        for(int i=0;i<trust.size();i++){\\n            out[trust[i][0]]+=1;\\n            in[trust[i][1]]+=1;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<=n;i++){\\n            if(out[i]==0){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        if(ans==INT_MIN) return -1;\\n        if(in[ans]==n-1) return ans;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389730,
                "title": "java-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will calculate the indegree and outdegree of the graph and than se if there is a node whose indegree equal to n-1 and outdegree of that node should be 0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIndegree and outdegree\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int findJudge(int n, int[][] trust) \\n    {\\n        int indegree[]=new int[n+1];\\n        int outdegree[]=new int[n+1];\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            \\n          indegree[trust[i][1]]++;\\n          outdegree[trust[i][0]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indegree[i]==n-1 && outdegree[i]==0)\\n            return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findJudge(int n, int[][] trust) \\n    {\\n        int indegree[]=new int[n+1];\\n        int outdegree[]=new int[n+1];\\n        for(int i=0;i<trust.length;i++)\\n        {\\n            \\n          indegree[trust[i][1]]++;\\n          outdegree[trust[i][0]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(indegree[i]==n-1 && outdegree[i]==0)\\n            return i;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150946,
                "title": "java-without-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n+t)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int trusts[]=new int[n+1];\\n        int trustedBy[]=new int[n+1];\\n        for (int i=0;i<trust.length;i++)\\n        {\\n            trusts[trust[i][0]]++;\\n            trustedBy[trust[i][1]]++;\\n        }\\n        for(int i = 1; i <= n; i++) {\\n            if(trusts[i] == 0 && trustedBy[i] == n-1) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int trusts[]=new int[n+1];\\n        int trustedBy[]=new int[n+1];\\n        for (int i=0;i<trust.length;i++)\\n        {\\n            trusts[trust[i][0]]++;\\n            trustedBy[trust[i][1]]++;\\n        }\\n        for(int i = 1; i <= n; i++) {\\n            if(trusts[i] == 0 && trustedBy[i] == n-1) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124249,
                "title": "java-array-based-sol-n-explained-beats-100-graph-soln-also-discussed",
                "content": "```\\nclass Solution {\\n    // solving usig array soln\\n    // can be done using indegree and outdegree, more intuitive soln\\n    // the judge wont have an outdegree and indegree should be n-1, then judge is found\\n    public int findJudge(int n, int[][] trust) {\\n        int count []= new int[n+1];\\n        if(trust.length==0 && n==1)\\n            return 1;\\n        \\n        for(int i =0;i<trust.length;i++)\\n        {\\n            int [] arr = trust[i];\\n            \\n            // the person who trusts will be given -1 and the person on which the trust is happening will get +1\\n            // so if there is a judge he will have count as n-1 as he trusts nobody and there will be always +1 for him\\n            // in every situation,if the so called judge trusts somebody he wont ever reach n-1 count value \\n            \\n            count[arr[0]]-=1;\\n            count[arr[1]]+=1;\\n        }\\n        // now check which value satisfies the condn\\n        for(int i=0;i<count.length;i++)\\n        {\\n            if(count[i]==n-1)\\n                return i;\\n                \\n        }\\n            \\n        return -1;\\n                  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    // solving usig array soln\\n    // can be done using indegree and outdegree, more intuitive soln\\n    // the judge wont have an outdegree and indegree should be n-1, then judge is found\\n    public int findJudge(int n, int[][] trust) {\\n        int count []= new int[n+1];\\n        if(trust.length==0 && n==1)\\n            return 1;\\n        \\n        for(int i =0;i<trust.length;i++)\\n        {\\n            int [] arr = trust[i];\\n            \\n            // the person who trusts will be given -1 and the person on which the trust is happening will get +1\\n            // so if there is a judge he will have count as n-1 as he trusts nobody and there will be always +1 for him\\n            // in every situation,if the so called judge trusts somebody he wont ever reach n-1 count value \\n            \\n            count[arr[0]]-=1;\\n            count[arr[1]]+=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3092559,
                "title": "most-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int in[]=new int[n+1];\\n        int out[]=new int[n+1];\\n        for(int k[]:trust){\\n            out[k[0]]++;\\n            in[k[1]]++;\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            if(in[i]==n-1 && out[i]==0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findJudge(int n, int[][] trust) {\\n        int in[]=new int[n+1];\\n        int out[]=new int[n+1];\\n        for(int k[]:trust){\\n            out[k[0]]++;\\n            in[k[1]]++;\\n        }\\n\\n        for(int i=1;i<=n;i++){\\n            if(in[i]==n-1 && out[i]==0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091613,
                "title": "using-map-easy-solution-must-check",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n  \\nint findJudge(int n, vector<vector<int>>& t) {\\n       \\n         unordered_map<int,int>mp;\\n        \\n        for(auto i:t){\\n            \\n            mp[i[0]]--;\\n            mp[i[1]]++;\\n        }\\n        \\n         for(int i=1;i<=n;i++){\\n             \\n             if(mp[i]==n-1)return i;\\n         }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n  \\nint findJudge(int n, vector<vector<int>>& t) {\\n       \\n         unordered_map<int,int>mp;\\n        \\n        for(auto i:t){\\n            \\n            mp[i[0]]--;\\n            mp[i[1]]++;\\n        }\\n        \\n         for(int i=1;i<=n;i++){\\n             \\n             if(mp[i]==n-1)return i;\\n         }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091278,
                "title": "easy-to-understand-python-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe intend to solve this problem via dynamic programming. Keeping track of all the occurences.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We maintain a list containing all the values that the judge could be. In this case, it would be from 1 to n (both inclusive). This list is called the `judge_list` and is a 2d array. The first index consisting the judge value as mentioned earlier and the second index is initialized as 0.\\n2. We the run a loop to iterate through the `trust` list provided to us. While iterating through each element, we add 1 to which ever value is in the first index and we subtract which ever value is in the second index.\\n3. This a dynamic approach to keep track of all the values in the `judge_list`.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThere are three loops used. So, the time complexity would be:\\nO(n+n+n) = O(3n) = O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe program uses constant space. So, space complexity would be O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        judge_list = [[i, 0] for i in range(1,n+1)]\\n        for i, j in trust:\\n            judge_list[j-1][1] += 1\\n            judge_list[i-1][1] -= 1\\n        for i, j in judge_list:\\n            if j == n-1:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\\n        judge_list = [[i, 0] for i in range(1,n+1)]\\n        for i, j in trust:\\n            judge_list[j-1][1] += 1\\n            judge_list[i-1][1] -= 1\\n        for i, j in judge_list:\\n            if j == n-1:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1764941,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770665,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1573817,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770529,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1573796,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1565339,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770492,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770317,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770308,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770435,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1764941,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770665,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1573817,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770529,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1573796,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1565339,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770492,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770317,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770308,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770435,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "Who all missed the (n==1) testcase :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "bhaveshgarg2000",
                        "content": "Me Too :("
                    },
                    {
                        "username": "Fath123",
                        "content": "i did lol. the term town judge maybe doesnt fit if theres only one person but tbf they did state 0 <= trust.length <= 10^4. cheap trick but fair enuf"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@rqebmm](/rqebmm) Huh. Then I have the only correct solution, and its O(1) for runtime and speed: \n\n```\nreturn -1\n```\n\nAs written, the problem states: *\"IF the town judge exists...\"*. We don't know whether or not he does, and the fact that there may be an identifiable resident who satisfies the conditions does not actually imply that there is the judge at all. The premise does not exclude the possibility of the conditions being true incidentally! We cannot confidently identify the judge as it is always possible there is no judge per the question. They need to specify the conditions are true if and only if there is a judge. "
                    },
                    {
                        "username": "ankity00",
                        "content": "I also missed it."
                    },
                    {
                        "username": "rqebmm",
                        "content": "[@witiwak](/witiwak) Not quite. The conditions state \"Return the label of the town judge if the town judge exists **and can be identified**\".  We cannot identify the judge given an empty trust graph, so the correct answer should be -1. But the base case is easy to identify so :shrug:"
                    },
                    {
                        "username": "witiwak",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does satisfy the conditions. The judge trusts nobody (the trust array is empty, so there is no trust, and thus the 1 person does not trust anyone). Everyone else in the town trusts the judge (there is no one else, so thus everyone else trusts the judge)."
                    },
                    {
                        "username": "PARANOID_XD",
                        "content": "I did :)"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "[@abhisheksharma5023](/abhisheksharma5023) It does. There is only 1 person in town. And, he doesn\\'t trust anybody. His trustness is = 0 = n-1."
                    },
                    {
                        "username": "abhisheksharma5023",
                        "content": "Why does it expect the output  to be 1 in this case?\n It doesn't satisfy any of the required conditions since the input array will be empty in this case, which means no one trusts anyone. So how can 1 be a judge?\nAm i missing something here?"
                    },
                    {
                        "username": "abhilashgaurav003",
                        "content": "opps I did"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "same"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I did!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "my solution is worst but i wrote it by my self without seeing anywhere after many submissions but its okay \\ni still proud of that : ) \\nif this happens with you also you must be proud of your self too!  \\uD83D\\uDE01 "
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@wild_knight](/wild_knight) thx for the suggestion : ) "
                    },
                    {
                        "username": "wild_knight",
                        "content": "We need to keep grinding and we certainly must be proud of our attempts.\\nI would just like to give an advice though, it is better to find the issues on our own without submitting, dry running your algorithm will eventually shape your thought process and also strengthen your edge case detection abilities. Just give it a try.."
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@rushabhvg](/rushabhvg) true but at first if you are able to think then you must write it down in any way it will increase your implementation skills \\nafter that you can surely visit different solution and try different approach  \\n"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Aside from being proud, we should learn to improve (or as geeks say, optimize) our code, too! Otherwise this practise which we are doing is just wasting out time!!!"
                    },
                    {
                        "username": "monishnjs",
                        "content": "This is one of the sample input and output.\\n\\nInput: N = 3, trust = [[1,3],[2,3]]\\nOutput: 3\\n\\nWhen i run with this test case, it is expecting -1 and not 3. a test case fails"
                    },
                    {
                        "username": "GrkmEldeniz",
                        "content": "[@Krantiy](/Krantiy) 1 trust 2 and  2 trust 3 therefore  2 cant be true trust but  3 could be,  do not gotta return -1 there is a possibility  "
                    },
                    {
                        "username": "sudiptapahari21",
                        "content": "[@mkprajapati1614](/mkprajapati1614)  here the test case is trust=[[1,2],[2,3]] that\\'s why expected answer is -1 i think you got the testcase wrong"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Wrong. Testcase also expecting 3."
                    },
                    {
                        "username": "Krantiy",
                        "content": "because of 2nd condition that is all others should trust town judge .\\nhere 1 don\\'t trust 3 "
                    },
                    {
                        "username": "reddyvijay1667",
                        "content": "yes a mistake"
                    },
                    {
                        "username": "deepi_badshah",
                        "content": "because 1 should know 3 then only answer will be 3 otherwise -1. Hence the test case is correct"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "This test case is present in the sample test cases section already(Example 2). The output -1 belongs to the Example 3 test case where there exists one more trust value i.e. [3,1] "
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of outgoing arrows is 0 and incoming arrows is (n-1). Only one condition is not enough."
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I also have the same issue"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I think it should be n == 3 and [[1,2],[2,3]], where did you get the array ? The challenge was fine for me."
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "All vertices on the graph should have a direct directed path to the \"town judge\" not an indirect path like with the edges in that test case!"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Below are the steps you need to follow in order to solve this problem:\n\n1. Think in terms of Graph.\n2. Consider every people as node and trust[i] = \n    [ai, bi] as a directed edge from ai to bi.\n3. Create two vectors named indegree and \n    outdegree of size n for storing the indegree \n    and outdegree for every node.\n4. Iterate the trust vector and for every [ai, bi] \n    increment indegree[bi] by 1 and outdegree of \n    ai by 1. \n5. After traversing the entire trust vector you \n    have to find the node which has outdegree 0 \n    and indegree = (n - 1) and return that node as \n    answer. \n6. Since it's mentioned in the question \n    that if possible there will be only one people \n    who satisfies both the properties, so there \n    will be only one node having indegree = n - 1 \n    && outdegree = 0.  \n7. If there is no node having indegree = n - 1 \n    and outdegree 0 return -1;\n\nPlease upvote if you are able to understand the logic by following these steps. if you have any doubts feel free to comment.\n\nThanks :)"
                    },
                    {
                        "username": "shashi675",
                        "content": "[@Crispy_coffee](/Crispy_coffee) in the second for loop, there should be (i<=n)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) create a test case where nth node will be judge and see what your code is returning. You will be able to figure out where you are making mistakes.\\n\\nError is in the second for loop. Think what your code will return if JUDGE will be the nth people.\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i change it, but i don\\'t think it\\'s still correct , would you please make it work for me? to get better understanding for me\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][1]]++;\\n            out[trust[i][0]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) [trust[i][0], trust[i][1]] means trust[i][0] trusts trust[i][1] so indegree[trust[i][1]] should be increased by 1 and outdegree[trust[i][0]] should be increased by one.\\n\\nPlease check your code carefully, you have made mistakes in incrementing indegree and outdegree.\\n\\nIf you have any other doubts, please feel free to comment.\\nPlease upvote if it helps.\\n\\nThanks :)"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@strive_hard](/strive_hard) i didn\\'t get you,here is my code, can you tell me by it please?\\n```\\nvector<int> out(n+1,0),in(n+1,0);\\n        for(int i=0; i<trust.size(); i++){\\n            cout <<\"Enter\";\\n            in[trust[i][0]]++;\\n            out[trust[i][1]]++;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(out[i] == 0 && in[i] == n-1)\\n                return i;\\n        }\\n        return -1;\\n```"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) we are not incrementing both values of trust we are incrementing the indegree of bi by 1 and outdegree of ai by 1. "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "if we are increment the both values of trust by 1 then how would we have the value of outdegree 0 ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "It should be marked medium problem."
                    },
                    {
                        "username": "cwooldridge",
                        "content": "I agree it is more of an easy medium."
                    },
                    {
                        "username": "gbiems",
                        "content": "It\\'s an interesting situation. When I first read the problem, I thought this would be easy, as in 5-10 minutes easy. A half hour and many failed submissions later, I realized that there are a lot of test cases you can overlook if you aren\\'t careful.\\n\\nSo in that sense, yeah, it isn\\'t really \"Easy\". The main argument against making it a medium problem is that it doesn\\'t really require any of the more advanced concepts in dynamic programming, backtracking, tree traversal, divide and conquer, and so forth. The programming required to solve this is pretty straightforward. But it\\'s definitely a test of whether you can think of and anticipate adverse test cases. \\n\\nBut if you can anticipate them all and get this in one try, yeah, well done, that\\'s definitely not easy. "
                    },
                    {
                        "username": "Panda_2397",
                        "content": "wait. how you guys do this question. I just make an array record trust and being trust, then see if beingTrust[i] = n -1 && trust[i] = 0"
                    },
                    {
                        "username": "anoyash",
                        "content": "[@stefancomanita] me also.. including edge case also"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "i think the brute force is very easy to implement , i just kept in mind all the condition and ran a loop to check each condition "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "I agree it\\'s not a very easy question, maybe even a medium one. I failed 3 times before getting it :)"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Nah, its just the wording thats complex"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-the-town-judge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Arrays\n\n  \n**Approach 2:** One Array\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Marking it as EASY makes me solve the problems in mind by change in mindset only\\n"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "can someone plss explain me the question.."
                    },
                    {
                        "username": "vishaljoshi1998",
                        "content": "[@_BREEZE_](/_BREEZE_)  incoming edges vs out going edges"
                    },
                    {
                        "username": "ranjan511",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) its like voting, The person which get all vote ( n-1 ) and same person haven\\'t vote anyone. We need to find this person , if exists then idx of that person otherwise -1.\\nHope now you got some idea.\\n\\nWe can maintain two arrays , count of vote received and count of vote given for each person.\\nThen search for person who have received n-1 vote and not gave single vote.\\nThanks"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "An array is given that has n people 1 to n. \nyou have to find town judge if exist\n\ncondition for town judge -\n1. town judge won't trust anyone\n2. All the n people will trust town judge except the town judge himself/herself.\n\narray=[a,b] \n'a' person trust 'b' person"
                    },
                    {
                        "username": "BristolJ",
                        "content": "OMG! An easy difficulty question?!\\nI forgot they existed"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "Don\\'t worry! You will forget this again, as LeetCode has started graph week!!!!"
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "lol tru\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach O(n) time and O(n) space: \n\n* Use `HashTable` (Array/List/Vector/Map) (`trustedBy`) of size n+1 to store count of people who trust person i, (`1<=i<=n`)  and another `HashTable` (Array/List/Vector/Map) (`trustsSomeone `) which is a boolean value to indicate whether person i trust someone or not.\n\n* You can also use one `hashtable` instead of two by using `2D HashTable` of `n*2`.\n\n* If For any person i in `[1,n]`, if `trustsSomeone[i]==false && trustedBy[i]==n-1` is true then person i is the town judge, else `return -1`."
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\nint findJudge(int N, vector<vector<int>>& trust) {\\n    vector<int> indegree(N+1, 0);\\n    vector<int> outdegree(N+1, 0);\\n    for (auto t : trust) {\\n        outdegree[t[0]]++;\\n        indegree[t[1]]++;\\n    }\\n    for (int i = 1; i <= N; i++) {\\n        if (outdegree[i] == 0 && indegree[i] == N - 1) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}"
                    },
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "[@ramSde](/ramSde)\\nif two loops are nested we say O(n^2)\\nelse we say O(2*n) which is O(n) because 2 is constant\\nhope you understand ^^"
                    },
                    {
                        "username": "bhagya_rana",
                        "content": "Thank you for Nice Hint of Using Two Vectors! "
                    },
                    {
                        "username": "nishant7372",
                        "content": "[@ramSde](/ramSde) use single loop.\n\n       for(int[] x:trust){\n            trustsSomeone[x[0]]=true;\n            trustedBy[x[1]]++;\n        }"
                    },
                    {
                        "username": "whoisjustinngo",
                        "content": "[@ramSde](/ramSde) it is true that 2 for loops are used, first one to process the pairs in the trust array, and the second to check through trustedBy and trustsSomeone for persons numbered 1 to n. but the loops aren\\'t nested, they\\'re one after another, so running time still increases linearly as n increases. "
                    },
                    {
                        "username": "ramSde",
                        "content": "How this can be o(n)? Please explain, to store ith persons count we will use two for loops don't we? "
                    }
                ]
            },
            {
                "id": 1770361,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1770632,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1568108,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1770706,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1770426,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1572477,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1770305,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1771757,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1771513,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1771095,
                "content": [
                    {
                        "username": "abdul_sohail24",
                        "content": "Use 1D Array for getting the Potential Town Judge & then check whether the Potential Town Judge trusts some other person."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "days when you struggle with an easy problem"
                    },
                    {
                        "username": "piyushatleet",
                        "content": "lol yeah"
                    },
                    {
                        "username": "myjiayan",
                        "content": "I thought it should be 3.\\nAny hints?\\nthanks"
                    },
                    {
                        "username": "stefancomanita",
                        "content": "yes, it\\'s -1. Not everybody trusts the judge. It got me too :)"
                    },
                    {
                        "username": "alby_francis",
                        "content": "Input : n = 3, trust =  [[1,2],[2,3]]\nMy output : 3\nExpected : -1\nHow it is -1 as 3 dose not trust anyone so it make him the candidate to be the judge.\nCan anyone explain.\n\nEdit : Got it , as the question explain EVERYBODY trust the town judge except the judge  . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "After a week of mediums, this easy one is a breath of fresh air."
                    },
                    {
                        "username": "yorkshire",
                        "content": "Is that obvious?\\nI would prefer it if the question stated that if a trusts b abd b trustes c then a trusts c."
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "zeta_omicron",
                        "content": "no its not applicable in this question , if [[a,b],[b,c]] then [a,c] is totallly not true \\n "
                    },
                    {
                        "username": "stefancomanita",
                        "content": "This is not the case, the trust is not transitive."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Relief from tough daily challenges which took all my day :)"
                    },
                    {
                        "username": "BitUnWise",
                        "content": "I really wish these problems used \"proper\" rust types instead of i32 everywhere,\\nit would be so much more elegant if the input vecs were usize instead and the return was an Option<usize>.\\n\\nalso why does this question have 1-based indexing? it\\'s just annoying for no good reason."
                    },
                    {
                        "username": "amar2307",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = [] it is expecting -1;"
                    },
                    {
                        "username": "mohnad-0b",
                        "content": "if n=1 and trust = [] this means just one person in Town and this person trust no one and all person in Town except this person trust him, Because the number of  persons in Town except this person is zero\\nif n=2 this mean two person in Town and them trust no one, so them did not achieve the condition that everyone trusts them"
                    },
                    {
                        "username": "raghavaggarwal2000",
                        "content": "This is one of the sample input and output\\nInput: N = 3, trust = [[1,2],[2,3]]\\nOutput: -1\\n\\nShouldn\\'t output of this be 3 as 3 is not trusting someone while other\\'s are trusting him."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@shubhamabhale](/shubhamabhale) No, if 1 trusts 2 and 2 trusts 3 then we cannot conclude that 1 trusts 3."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@Cyllindra](/Cyllindra) now that is an example :) thank you!"
                    },
                    {
                        "username": "Cyllindra",
                        "content": "[@shubhamabhale](/shubhamabhale) No -- it doesn\\'t. For example: I trust my sister, she trusts my dad\\'s ex-mistress, I don\\'t trust my dad\\'s ex-mistress."
                    },
                    {
                        "username": "shubhamabhale",
                        "content": "[@strive_hard](/strive_hard) 1 trusts 2 and 2 trusts 3, doesnt that mean 1 trusts 3?\\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raghav Aggarwal](/raghavaggarwal2000) the statement \"3 is not trusting anyone\" is correct but for a person to be a judge the other condition must also hold and that is \"all except 3 must trust 3\" and here 1 does not trust 3. So, 3 will not be the answer.\\n\\nFeel free to comment if you have any other doubts.\\nPlease upvote if it helps. Thanks :)"
                    }
                ]
            },
            {
                "id": 1771074,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 1770989,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 1770968,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 1770390,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 1770348,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 1770327,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 2048805,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 2013096,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 1991972,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 1989549,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Do we trust Leetcode?\\nYes !! \\ndoes that mean Leetcode is the judge ?\\nYes !! \\nIt judges our solutions !!\\n"
                    },
                    {
                        "username": "trivshekhar",
                        "content": "Count how many people trust a person, and how many people does that person trust, it should be n-1 and 0, After completing a full loop."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Empty `trust` array is a deadly edge case lol"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "An EASY aka MEDIUM problem\\nP.S.: tagging a problem easy doesn\\'t make it easy \\uD83D\\uDE02"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Think in terms of graph(indegree and outdegree concept), this problem will look easy to you."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Intuition is quite simple. At first you may think of graph, but it has a easier implementation without it too !!\\nBut implementation is a bit tricky but very very super easy.\\nYou know that for a person to be town judge, he should be trusted ny n-1 people and he should not trust anybody.\\nSo why don\\'t we just keep a track of x trusts how many people and x is trustted by how many people."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "I have did the same, do check my code.\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088023/easy-c-logical-solution-without-graph/?orderBy=most_votes"
                    },
                    {
                        "username": "quan_mai",
                        "content": "Think as when you being trusted, you can borrow your friends money (say, \\$1). In the end of the day, you can borrow up to \\$\\#friends. "
                    },
                    {
                        "username": "mijanur21",
                        "content": "can anyone tell me why this code is not working on testcase [[1,2],[2,3]]\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        unordered_map<int, vector<int>> umap(n);\\n        for(auto x : trust){\\n            // vector<int> temp = x;\\n\\n            int u = x[0];\\n            int v = x[1];      \\n\\n            umap[u].push_back(v);\\n        }\\n        int ans = -1;\\n        for(int i = 1; i<=n; i++){\\n            if(umap[i].size() == 0) ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "Cindy_Su",
                        "content": "Is the reason trust = [[1, 2], [2, 3]] should return n = -1 instead of n = 3 because it is possible the town judge might not exist? Because otherwise wouldn\\'t the town judge be 3 by process of elimination?"
                    },
                    {
                        "username": "user0256wQ",
                        "content": "How does n == 1 mean that the judge exists?\\n\\nRegardless of whether the 1 person in town is a judge or not, the inputs will still be 1 and and empty array\\n\\nIt says: \"Return the label of the town judge if the town judge exists <b>and can be identified</b>, or return -1 otherwise.\"\\n\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "this one was hard for me..... I kept on failing certain test cases, so I had to keep changing my approach!  In the end, I came up with a brute force method that works "
                    }
                ]
            },
            {
                "id": 1979219,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1950578,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1935726,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1897113,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1862597,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1856013,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1849592,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1771965,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1771767,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1771631,
                "content": [
                    {
                        "username": "user5410Mr",
                        "content": "it took me 14 hours to solve , ('\"_'\")  99.01 % beat !!!!!!!!!!!!!"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I changed 1 line in my code and the run time reduced around 100ms.\\nBut whats interesting is runtime beat % changed from 9% to 92%. is it even possible! or its just leetcode issue?\\n\\n#graph = [[] for i in range(n + 1)]\\ngraph = dict()"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**A game of inDegree and outDegree of nodes in graph**\\nIndeed.. It was an interesting problem!"
                    },
                    {
                        "username": "shashi675",
                        "content": "n==1 : this testcase is invalid, as if n=1, then the person should know itself (but it is specified that ai != bi)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "is  anyone try indegree  approach i  tried and failed  87 / 92 "
                    },
                    {
                        "username": "FZYBB",
                        "content": "I trust u, u trust her, then I trust her? This is not what the world is."
                    },
                    {
                        "username": "wnoland90",
                        "content": "How is [[1,2], [2,3]] -1? wouldn\\'t it be 3 because 3 doesn\\'t trust anyone?"
                    },
                    {
                        "username": "thartman94",
                        "content": "correct 3 doesn\\'t trust anyone - but to be mayor everyone must trust 3 as well. and only 2 trusts 3 so 3 is not the mayor"
                    },
                    {
                        "username": "eshadx",
                        "content": "In description should be writen that one person can trust to many include judge!!! At now it\\'s uncertant."
                    },
                    {
                        "username": "cswartzell",
                        "content": "And, per usual, the few and too short examples don\\'t make this clear"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There is a logic error in the description. As stated, the problem says \"If the judge exist...\" and then lists some simple rules. However, the conditions being true *do not* imply the existence of a judge. The rules can be true incidentally, whether or not there is a judge; \"If the judge exists\" is the implication, the consequence happening to be true has no bearing on the truth of the premise.\n\nAs such, we can never be certain if there is a judge. We *may* be able to pick the only candidate if there happens to be a judge, but we don't know whether there *is* one. The only correct answer to this problem is:\n\nreturn -1\n\nLeetcode should change the problem to state \"there is a judge IFF the following conditions are true\"\n\nThis is a material implication and the antecedent has no bearing on the conditional. In programing terms, this would be like \n```\nmain\n    if judge:\n       if rule 1 and rule 2 for judge_id in citizens:\n           return judge_id\n````\nbut judge is undeclared, and we'd throw an error. "
                    },
                    {
                        "username": "denkochev",
                        "content": "Fresh air for my mind. Thank you."
                    }
                ]
            },
            {
                "id": 1771601,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771538,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771536,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771526,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771523,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771457,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771455,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771442,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771440,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771410,
                "content": [
                    {
                        "username": "m_e_shivam",
                        "content": "Example\\nIf 1 trusts 2 and \\n2 trusts 3 \\nThen 3 should be the judge\\nBut why the output is -1 \\n[EXPLANATION]\\nTo be the judge everyone has to trust him, so since 1 doesn\\'t trust 3, 3 can\\'t be the judge."
                    },
                    {
                        "username": "Sahil_23",
                        "content": "our aim is to just find the maximum trusted person and check if it is n-1 times because if it less than that, one or more people don\\'t trust that person and at last we have to check that if this person trusts someone we will return -1 and if not we can just return the value of the judge\\nEither we do this in two loops and one data structures for frequency of trustees or\\nwe can make do it in single loop and make two data structures one for frequency of trustees and another for trusts someone, if for any value in [1,n] satisfies freq == n-1 and trustsSomeone == false, then that person is the judge\\nHope this help :)"
                    },
                    {
                        "username": "gk779866",
                        "content": "Time:0(|trust|+n)\\nspace:0(n @)"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "test case no 91 :|\nBe aware of n=1 and trust = [ ]\nand n=2 and trust = [ ]"
                    },
                    {
                        "username": "crimemaster007",
                        "content": "-> find the possible ans that is not mapped with anyone.\\n     * if possible answer is more than 1 than return -1 else continue further.\\n->check the possible answer is mapped with every number except himself\\n  *if true return possible ans else return -1."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Since every one in the town trusts the judge so does judge trust himself too..?? "
                    },
                    {
                        "username": "cswartzell",
                        "content": "The rules clearly state \"Everybody (except for the town judge) trusts the town judge.\""
                    },
                    {
                        "username": "_sumit__negi_",
                        "content": "its just a basic indegree and outdegree count question. :)"
                    },
                    {
                        "username": "Bobzero",
                        "content": "How you people come with this approach of creating an array for counting and increasing each number that is trusted and decreasing the number that is trusting.. wow"
                    },
                    {
                        "username": "mdcse",
                        "content": "Can any one tell me why on input : n = 1, trust = [] --> output = 1.\\nand on input n = 2, trust = []  it is expecting -1;\\n\\n"
                    },
                    {
                        "username": "shrutika051220",
                        "content": "To find the town judge, you should use an array of size n + 1 to keep track of the number of people each person trusts, and another array of size n + 1 to keep track of the number of people who trust each person. Then, iterate through the trust array and increment the first array at the index of the person who trusts someone and increment the second array at the index of the person who is trusted. Finally, iterate through the array again and check if there is a person who has trust count of 0 and the trust count of n - 1. If such a person is found, return their label, otherwise return -1.\\n\\n`int findJudge(int N, vector<vector>& trust) {\\nvector indegree(N+1, 0);\\nvector outdegree(N+1, 0);\\nfor (auto t : trust) {\\noutdegree[t[0]]++;\\nindegree[t[1]]++;\\n}\\nfor (int i = 1; i <= N; i++) {\\nif (outdegree[i] == 0 && indegree[i] == N - 1) {\\nreturn i;\\n}\\n}\\nreturn -1;\\n}`"
                    }
                ]
            },
            {
                "id": 1771395,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771391,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771336,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771321,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771313,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771276,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771234,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771232,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771204,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771186,
                "content": [
                    {
                        "username": "faisalirfan2502",
                        "content": "n=4\n[[1,4],[2,4]]\nexpected : -1 can someone explain why not 4 should be ouput? \neveryone is trusting 4 i guess"
                    },
                    {
                        "username": "mohitkanodia",
                        "content": "no status of 3, assume it not trusts 4... so no answer found!!"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "thesadsatan",
                        "content": "I run my solution in a python file in vscode it passes all the tests but when I run it here, it doesn\\'t pass I get a runtime error or wrong answer, anytidea?\\n\\n\\n"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "you can use a hashmap (or unordered_map in C++) to keep track of the number of people each person trusts and the number of people who trust them. Then, iterate through the trust array and update the values in the hashmap accordingly. Finally, iterate through the hashmap and check if there is exactly one person who trusts nobody and is trusted by everybody else."
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "A small suggestion to my code buddies that never start a probleam directly on editor have a solution on paper that will helps you definetly ..."
                    },
                    {
                        "username": "Raushan_Ranjan",
                        "content": "from test case no . 89 =  [[1,2], [1,3]];  1 is trusting 2 and 2 is trusting 3; So i think 3 should be the town judge. but the answer is -1;  Correct me please."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Raushan Ranjan](/Raushan_Ranjan) 1 is trusting 2 and 2 is trusting 3 does not mean 1 trusts 3. So, 3 is not trusted by 1 and hence 3 will not be the answer as 1 does not trust 3. "
                    },
                    {
                        "username": "Sahil_23",
                        "content": "*TestCase Failure*\ntestcase number = 92 ;\nInput: n = 5,  and trust = [[1,2],[3,2],[4,1],[3,1],[2,1],[2,3],[5,1],[3,4],[2,4],[5,3]]\noutput : 1     expected output : -1\nbut 1 should the answer as everybody trusts 1 and 1 trusts nobody, so why 1 is not the judge.\nThanks in advance for helping"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Sahil Gupta](/Sahil_23) [1, 2] means 1 trusts 2 so the statement \"1 trusts nobody is wrong\". Hence -1 will be the answer. \\n\\nFeel free to comment it you have any other doubts.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "sel0nidas",
                        "content": "what does the variable \"trustColSize\" mean in this problem? I can\\'t figure out why i gotta use it."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Selahattin Emre Kutlu](/sel0nidas) you can think of  trust as a 2D matrix of shape (trust.size(), 2). Hence, trustColSize will be 2 and trustRowSize will be trust.size()"
                    },
                    {
                        "username": "sergeevii123",
                        "content": "hahahah, finally easy one. I was waiting for this"
                    },
                    {
                        "username": "aadityaagrawal11",
                        "content": "class Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n        if(n==0 )return -1;\\n        unordered_map<int,int>mp;\\n        for(int i=1;i<=n;i++)mp[i]=0;\\n        for(int i=0;i<trust.size();i++){\\n            mp[trust[i][0]]--;\\n            mp[trust[i][1]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second==n-1)return x.first;\\n        }\\n        return -1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771118,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771067,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771045,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771003,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770978,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770963,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770949,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770876,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770870,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770807,
                "content": [
                    {
                        "username": "user2313f",
                        "content": "One medium problem that I could solve(possibly not the best approaches):\\n1. Scan the  `trust` array to check if a person is missing - that\\'s the first condition of a judge(trusts nobody)\\n2. With a list of all possible judges, check if all citizens trust this judge by maintaining a count. If you find a match, return immediately else return -1"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Everybody (except for the town judge) trusts the town judge.\\nshould be written like\\nEverybody (except for the town judge) trusts the town judge only."
                    },
                    {
                        "username": "diakula",
                        "content": "Anyone else thought of using a BTreeMap or something like that to optimize ?"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally, got an easy problem in daily LeetCoding.\\nJust need some extra O(n) and you are there!\\nhttps://youtu.be/W-oUziOH1Xk"
                    },
                    {
                        "username": "Adarsh_Reddy",
                        "content": "Approach,\nWithout using graph,\nUsing unordered_map\n\nIdea is to, 1) find an element which has the potential to be the judge(majority element), and then\n2) check if all the other elements trust the judge.\n\nTo find the potential element\n- All the elements are inserted into an unordered map and element with max frequency is obtained, which will be\n- the element that might be the judge (i.e either the judge is this element or -1).\n\nAfter finding the element,\n- Check if all the other elements trust the judge, this can be done by a single traversal over the whole vector.\n\nEdge Case:\n\nThere might be some elements which doesn't trust no one just like the judge,\n- A function can be employed here which traverses the whole vector while checking whether each element other than the potential judge which we obtained earlier, trusts other element.(i.e each element at some time must be the first element in the vector atleast once)\n\n## Approach 2\nCheck the indegree and outdegree of each element, for the element to be the judge its indegree must be equal to n-1(i.e all the elements other than itself will point to it) and outdegree must be equal to 0(it should not trust(point to other elements))\n\n\n\nSolution Link:\n[my Sol](https://leetcode.com/problems/find-the-town-judge/solutions/3089489/c-without-using-graph-array-unordered-map-approach-explained-accepted/?orderBy=newest_to_oldest)"
                    },
                    {
                        "username": "aryan112345",
                        "content": "Leetcode\\'s testcase: [[1,3],[1,4],[2,3],[2,4],[4,3]]\\nerror: \\'trust\\' must consist of values from 1 to 3 only\\n\\ncan anyone help??"
                    },
                    {
                        "username": "aryan112345",
                        "content": "[@Mariia_89](/Mariia_89) ohk. thanks.\\n"
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You have n == 3, so \\'trust\\' must consist of values from 1 to 3 only. If you have n == 4, you wouldn\\'t get this error."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Today\\'s problem was an easy trailer to the coming graph days that will be not so easy. Brace for the impact!!"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findJudge(int n, int[][] trust) {\\n       int max=-1;\\n       if(trust.length==1){\\n           return trust[0][1];\\n       } \\n       if(n==1) return 1;\\n        if(trust.length==0){\\n           return -1;\\n       } \\n    \\n      int[] a=new int[n+1];\\n        int[] b=new int[n+1];\\n       for(int i=0;i<trust.length;i++){\\n       a[trust[i][0]]++;\\n        b[trust[i][1]]++;\\n       }\\n       for(int i=0;i<a.length;i++){\\n        if(a[i]==0 && b[i]==n-1){\\n            return i;\\n        }\\n       }\\n       return -1;\\n    }\\n}"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Great problem, thank you!\\n\\nIs it possible that everybody but judge trusts all people in the town? For example,\\n`findJudge(3, [[1,2],[1,3],[2,1],[2,3]]) == 3`\\n\\nCould you specify it in description, pls?\\n\\n\\n\\n"
                    },
                    {
                        "username": "FMK52",
                        "content": "but is nt it mentioned already?\\n"
                    },
                    {
                        "username": "_ultimate_",
                        "content": "using map able to solve in first attempt\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int findJudge(int n, vector<vector<int>>& trust) {\\n\\n        map<int,int> mp;\\n\\n       \\n\\n        for(auto i:trust)\\n        {\\n            mp[i[0]]=1;\\n        }\\n\\n        if(mp.size()!=n-1){return -1;}\\n        int suspect;\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0){suspect=i;break;}\\n        }\\n        map<int,int> mp2;\\n\\n        for(auto i:trust)\\n        {\\n            if(i[1]==suspect){mp2[i[0]]=1;}\\n        }\\n\\n        if(mp2.size()!=n-1){return -1;}\\n\\n        return suspect;\\n\\n\\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770791,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770786,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770672,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770637,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770614,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770612,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770555,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770553,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770519,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770514,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/997_find_the_town_judge.cpp\\nLEAVE A STAR "
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "To anyone who is feeling like they could solve this problem yet couldn't like me in one go: \n\nThis requires handling of test cases in a proper manner. So think thoroughly and you'll be able to do it.\n\n"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Can someone please explain...\\n`n=2 trust=[] Expected: -1`\\n`n=1 trust=[] Expected: 1`"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Khushi Dusad](/kd_5304) for n = 1 there is nobody except 1 so we can conclude that 1 trust nobody and 1 is trusted by every others as others is an empty list.\\n\\nfor n = 2 and trust = [], we can conclude that 1 is not trusted by 2 and also 2 is not trusted by 1. So there is no one who is trusted by every others and also trust no one. Hence expected answer is -1.\\n\\nPlease upvote if it helps. Feel free to comment if you are unable to understand the explanation.\\n\\nThanks :)"
                    },
                    {
                        "username": "schanjr",
                        "content": "Got a odd test case below: \\n```ruby\\nn = 1\\ntrust = []\\nanswer = 1\\nexpected = -1\\n```\\nSince nobody is trusting 1, the condition should not match. Hence the answer should\\'ve been -1, but the test case is expecting 1.  \\n\\nGot any clue??"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "The conditions are - \n1. Everyone should trust judge except the judge.\n2. The judge should not trust anyone.\n\nOnly 1 person in the town means total people (or everyone) in the town are 1. Everyone should trust judge, so, if everyone is 1, then, the trust array should have [1,1]. But there's not because it's not allowed. But, we can assume 1 trusting 1 is true only considering 1st condition, not 2nd.\n\nAlso, If everyone is 1, we can only assume this one person to be  the judge. And if he's not trusting anyone in the town (which is no one or 0 because there are total of 1 person), then trust array should be empty. In other words, if there's only one person and we're assuming he's the judge, then trust array should be empty, which in fact is empty.\n\n\nTherefore, the answer is 1.\n\n\n"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "The judge does not trust anyone, the only person in the town is the judge, therefore the answer is 1. "
                    },
                    {
                        "username": "Knight-03",
                        "content": "test case : [[1,3], [1,4], [2,3]]\\noutput : -1 \\n\\ncuz there should be a pair of [4,3] also "
                    },
                    {
                        "username": "tiwarivishnu426",
                        "content": "Just think about to store no. of individuals trusted by anyone as well as no . of individuals trust them. Implement conditions, get the answer."
                    },
                    {
                        "username": "JS1DH",
                        "content": " `How is this an easy problem?. Should be marked as medium`"
                    },
                    {
                        "username": "anoyash",
                        "content": "### 1. once you understood think for the edge cases and check the constraints limit also. like lower limit of n and lower limit of trust length\n### 2. to further improve the code we can use frequency count array over map STL .\n### 3. Important Test Case : [ [1,3],[2,3],[4,3],[1,4],[2,4] ] ."
                    },
                    {
                        "username": "anoyash",
                        "content": "[@Knight-03](/Knight-03)  3"
                    },
                    {
                        "username": "Knight-03",
                        "content": "what is the output of that test case "
                    },
                    {
                        "username": "space_invader",
                        "content": "[[1,2],[2,3]]\n\noutput = -1"
                    },
                    {
                        "username": "Ramana_411",
                        "content": "Fine, Easy Medium Exist !!!!!"
                    }
                ]
            },
            {
                "id": 1770510,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770501,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770463,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770460,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770420,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770415,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770381,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770350,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770349,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            },
            {
                "id": 1770330,
                "content": [
                    {
                        "username": "sanasdh",
                        "content": "is this gonna be a graph week again?\\uD83D\\uDE1F "
                    },
                    {
                        "username": "mahmadamin_08",
                        "content": "it Just Need One Good Idea to Turn Hard Problem to EASY..\n"
                    },
                    {
                        "username": "mahayat",
                        "content": "People, just be mindful of the condition of being a Judge. In this directed graph, for a Judge, number of `outgoing` arrows is `0` and `incoming` arrows is `(n-1)`. Only one condition is not enough."
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel  \\uD83D\\uDC49https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/1JSH11AQY_4"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "N=3\\n[[1,2],[2,3]]\\nexpected ansr is -1\\nmy ansr is 3...\\n\\nPLSS help"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) [1, 2] means 1 trusts 2 and [2, 3] means 2 trusts 3. So 1 is not trusted by 2 & 3, similarly 2 is not trusted by 3 and 3 is not trusted by 1. Hence, we can conclude that no among 1, 2, 3 is trusted by every others. So -1 will be the answer. \\nNote : ai trusts bi does not mean bi trusts ai.\\n\\nAlso if you want, you can check my solution here:\\n\\nhttps://leetcode.com/problems/find-the-town-judge/solutions/3088141/indegree-outdegree-concept-graph-code-with-comments/\\n\\nFeel free to comment if you have any other doubts.\\nThanks :)\\n"
                    },
                    {
                        "username": "eduardo_f45",
                        "content": "I figured it out, the key was that everybody must trust the town judge, if it exists. In that problem, 3 is a good candidate since its the only one that hasn\\'t trusted but 1 needs to trust 3 in order to complete the 2 requirements. I thought it was enough to find the candidate that hasn\\'t trusted but it turns out that everybody must show that they trust the candidate that hasn\\'t trusted."
                    },
                    {
                        "username": "harshit17bis",
                        "content": "This Judge gives a Super-hero vibe."
                    },
                    {
                        "username": "cjatherton19",
                        "content": "bad description"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Create a vector of pair of type int to keep track of trusted and trustedby"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "simply iterate over the given vector of vectors and go on increasing count of people who trust somebody .i.e. suppose 1->3 si increase count of 1 in arr.first and increase count of 3 in arr.second"
                    },
                    {
                        "username": "meow_power",
                        "content": "MeaooooWWWWWWWW GRAPH WEEK STARTED!!!!!!!!!!!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Rearrange Words in a Sentence",
        "question_content": "<p>Given a sentence&nbsp;<code>text</code> (A&nbsp;<em>sentence</em>&nbsp;is a string of space-separated words) in the following format:</p>\n\n<ul>\n\t<li>First letter is in upper case.</li>\n\t<li>Each word in <code>text</code> are separated by a single space.</li>\n</ul>\n\n<p>Your task is to rearrange the words in text such that&nbsp;all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.</p>\n\n<p>Return the new text&nbsp;following the format shown above.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;Leetcode is cool&quot;\n<strong>Output:</strong> &quot;Is cool leetcode&quot;\n<strong>Explanation: </strong>There are 3 words, &quot;Leetcode&quot; of length 8, &quot;is&quot; of length 2 and &quot;cool&quot; of length 4.\nOutput is ordered by length and the new first word starts with capital letter.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;Keep calm and code on&quot;\n<strong>Output:</strong> &quot;On and keep calm code&quot;\n<strong>Explanation: </strong>Output is ordered as follows:\n&quot;On&quot; 2 letters.\n&quot;and&quot; 3 letters.\n&quot;keep&quot; 4 letters in case of tie order by position in original text.\n&quot;calm&quot; 4 letters.\n&quot;code&quot; 4 letters.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> text = &quot;To be or not to be&quot;\n<strong>Output:</strong> &quot;To be or to be not&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>text</code> begins with a capital letter and then contains lowercase letters and single space between words.</li>\n\t<li><code>1 &lt;= text.length &lt;= 10^5</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 636286,
                "title": "java-4-line",
                "content": "```\\npublic String arrangeWords(String text) {\\n        String []s = text.toLowerCase().split(\" \");\\n        Arrays.sort(s, (a,b) ->  a.length() - b.length());\\n        String ans = String.join(\" \", s);\\n        return Character.toUpperCase(ans.charAt(0)) + ans.substring(1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String arrangeWords(String text) {\\n        String []s = text.toLowerCase().split(\" \");\\n        Arrays.sort(s, (a,b) ->  a.length() - b.length());\\n        String ans = String.join(\" \", s);\\n        return Character.toUpperCase(ans.charAt(0)) + ans.substring(1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636348,
                "title": "python3-one-line",
                "content": "A few string operations chained together to get the job done. \\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636353,
                "title": "c-map-bucket-solution",
                "content": "```\\nstring arrangeWords(string text) {\\n    text[0] = tolower(text[0]);\\n    stringstream ss(text), rs;\\n    string word;\\n    map<int, string> m;\\n    while (ss >> word) m[word.size()] += word + \" \";\\n    \\n    for (const auto& pair: m) rs << pair.second;\\n    string result = rs.str();\\n    result.pop_back();\\n    result[0] = toupper(result[0]);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring arrangeWords(string text) {\\n    text[0] = tolower(text[0]);\\n    stringstream ss(text), rs;\\n    string word;\\n    map<int, string> m;\\n    while (ss >> word) m[word.size()] += word + \" \";\\n    \\n    for (const auto& pair: m) rs << pair.second;\\n    string result = rs.str();\\n    result.pop_back();\\n    result[0] = toupper(result[0]);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636347,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        PriorityQueue<Word> queue = new PriorityQueue<>((x,y) -> x.word.length() != y.word.length()?x.word.length() - y.word.length(): x.timeStamp - y.timeStamp);\\n        String[] words = text.split(\" \");\\n        int i = 0, n = words.length;\\n        for (String word: words) queue.offer(new Word(word.toLowerCase(), i++));\\n        StringBuffer result = new StringBuffer();\\n        for(i=0;!queue.isEmpty();i++) {\\n            result.append(queue.poll().word);\\n            if(i==0) result.setCharAt(0, Character.toUpperCase(result.charAt(0)));\\n            if(i!=n-1) result.append(\" \");\\n        }\\n        return result.toString();\\n    }\\n}\\n\\nclass Word {\\n    String word;\\n    int timeStamp;\\n    public Word(String word, int timeStamp) {\\n        this.word = word;\\n        this.timeStamp = timeStamp;\\n    }\\n}\\n```\\n<br>\\n<br>\\n\\n\\n**Update:** As suggested by @ganoush in comments, we do not need additional class.\\n```\\npublic String arrangeWords(String text) {\\n\\tString[] words = text.split(\" \");\\n\\tPriorityQueue<Integer> queue = new PriorityQueue<>((i1,i2) -> words[i1].length() != words[i2].length() ?\\nwords[i1].length()- words[i2].length() : i1-i2);\\n\\tfor (int i=0;i<words.length;i++) queue.offer(i);\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(int i=0;!queue.isEmpty();i++) {\\n\\t\\tresult.append(words[queue.poll()].toLowerCase());\\n\\t\\tif(i==0) result.setCharAt(0, Character.toUpperCase(result.charAt(0)));\\n\\t\\tif(i!=words.length-1) result.append(\" \");\\n\\t}\\n\\treturn result.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        PriorityQueue<Word> queue = new PriorityQueue<>((x,y) -> x.word.length() != y.word.length()?x.word.length() - y.word.length(): x.timeStamp - y.timeStamp);\\n        String[] words = text.split(\" \");\\n        int i = 0, n = words.length;\\n        for (String word: words) queue.offer(new Word(word.toLowerCase(), i++));\\n        StringBuffer result = new StringBuffer();\\n        for(i=0;!queue.isEmpty();i++) {\\n            result.append(queue.poll().word);\\n            if(i==0) result.setCharAt(0, Character.toUpperCase(result.charAt(0)));\\n            if(i!=n-1) result.append(\" \");\\n        }\\n        return result.toString();\\n    }\\n}\\n\\nclass Word {\\n    String word;\\n    int timeStamp;\\n    public Word(String word, int timeStamp) {\\n        this.word = word;\\n        this.timeStamp = timeStamp;\\n    }\\n}\\n```\n```\\npublic String arrangeWords(String text) {\\n\\tString[] words = text.split(\" \");\\n\\tPriorityQueue<Integer> queue = new PriorityQueue<>((i1,i2) -> words[i1].length() != words[i2].length() ?\\nwords[i1].length()- words[i2].length() : i1-i2);\\n\\tfor (int i=0;i<words.length;i++) queue.offer(i);\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(int i=0;!queue.isEmpty();i++) {\\n\\t\\tresult.append(words[queue.poll()].toLowerCase());\\n\\t\\tif(i==0) result.setCharAt(0, Character.toUpperCase(result.charAt(0)));\\n\\t\\tif(i!=words.length-1) result.append(\" \");\\n\\t}\\n\\treturn result.toString();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637565,
                "title": "c-4-solutions-from-naive-to-more-experienced",
                "content": "Solution 1: This is my solution submited during conest since this is what I am most comfortable with:\\n```\\nclass Solution { // sort based solution\\npublic: // Time/Space: O(NlogN); N:|text|\\n    string arrangeWords(string text) {\\n        text[0] += (\\'a\\' - \\'A\\');\\n        stringstream ss(text);\\n        string word;\\n        vector<pair<string, int>> vec;\\n        int index = 0;\\n        while(ss >> word) vec.emplace_back(word, index++);                    \\n        sort(vec.begin(), vec.end(), [](auto& a, auto& b){ return (a.first.size() < b.first.size() )||  ( a.first.size() == b.first.size() &&  a.second < b.second); });        \\n        string ans;\\n        for(auto& w: vec) ans += w.first + \" \";\\n        ans.pop_back();\\n        ans[0] -= (\\'a\\' - \\'A\\');\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nSolution 2: post-contest optimized version\\n```\\nclass Solution { // stable_sort based solution\\npublic: // Time/Space: O(NlogN); N:|text|\\n    string arrangeWords(string& text) {\\n        text[0] += (\\'a\\' - \\'A\\');\\n        stringstream ss(text);\\n        string word;        \\n        vector<string> vec;        \\n        while(ss >> word)  vec.emplace_back(word);                         \\n        stable_sort(vec.begin(), vec.end(), [](const auto& a, const auto& b){ return a.size() < b.size(); });        \\n        string ans;\\n        //for(const auto& w: vec) ans = ans + w + \\' \\'; // EER: Memory Limit Exceeded\\n        //for(const auto& w: vec) ans += w + \\' \\'; // ok\\n        for(const auto& w: vec) ans.append(move(w + \\' \\'));  //Better\\n        ans[0] -= (\\'a\\' - \\'A\\');\\n        return {ans.begin(), ans.begin() + ans.size() - 1};\\n    }\\n};\\n```\\n\\n\\n\\nSolution 3: reference to others\\n```\\nclass Solution { // Map bucket solution\\npublic: // Time/Space: O(NlogN); N:=|text|\\n    string arrangeWords(string text) {\\n        text[0] = tolower(text[0]);\\n        stringstream ss(text), rs;\\n        string word;\\n        map<int, vector<string>> m;\\n        while (ss >> word) m[word.size()].emplace_back(word);    \\n        for (const auto& [k, v]: m)\\n            for(const auto& word: v)                \\n              rs << (word + \\' \\');\\n        string result(rs.str());\\n        result.pop_back();\\n        result[0] = toupper(result[0]);\\n        return result;\\n    }\\n};\\n// ref:  https://leetcode.com/problems/rearrange-words-in-a-sentence/discuss/636353/C%2B%2B-map-bucket-solution\\n```\\n\\nSolution 4: strtok based version\\n```\\nclass Solution {\\npublic: // Time/Space: O(NlogN); N:|text|\\n    string arrangeWords(string text) {        \\n        text[0] -= \\'A\\' - \\'a\\';\\n        map<int, vector<string>> dict;\\n        char* token = strtok((char*)text.c_str(), \" \");      \\n        while( token){\\n            string temp1(token);        \\n            dict[temp1.size()].emplace_back(temp1);        \\n            token = strtok(NULL, \" \");\\n        }\\n        string ans;\\n        for (auto& d : dict)\\n            for (auto& w : d.second)\\n                ans += w + \\' \\';\\n      \\n        ans[0] -= \\'a\\' - \\'A\\';\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n// ref: http://www.cplusplus.com/reference/cstring/strtok/\\n```\\n\\nSolution 5: vector based hash map\\n```\\nclass Solution {\\npublic: // Time/Space: O(N); N:=|text|\\n    string arrangeWords(string text) {        \\n        text[0] -= \\'A\\' - \\'a\\';           \\n        vector<vector<string>> dict(10000); // 1 <= text.length <= 10^5\\n        char* token = strtok((char*)text.c_str(), \" \");      \\n        while( token){\\n            string temp1(token);        \\n            dict[temp1.size()].emplace_back(temp1);        \\n            token = strtok(NULL, \" \");\\n        }\\n        string ans;\\n        for (auto& d : dict){            \\n            for (auto& w : d)\\n                ans += w + \\' \\';\\n        }\\n        ans[0] -= \\'a\\' - \\'A\\';\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n// ref: http://www.cplusplus.com/reference/cstring/strtok/\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution { // sort based solution\\npublic: // Time/Space: O(NlogN); N:|text|\\n    string arrangeWords(string text) {\\n        text[0] += (\\'a\\' - \\'A\\');\\n        stringstream ss(text);\\n        string word;\\n        vector<pair<string, int>> vec;\\n        int index = 0;\\n        while(ss >> word) vec.emplace_back(word, index++);                    \\n        sort(vec.begin(), vec.end(), [](auto& a, auto& b){ return (a.first.size() < b.first.size() )||  ( a.first.size() == b.first.size() &&  a.second < b.second); });        \\n        string ans;\\n        for(auto& w: vec) ans += w.first + \" \";\\n        ans.pop_back();\\n        ans[0] -= (\\'a\\' - \\'A\\');\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution { // stable_sort based solution\\npublic: // Time/Space: O(NlogN); N:|text|\\n    string arrangeWords(string& text) {\\n        text[0] += (\\'a\\' - \\'A\\');\\n        stringstream ss(text);\\n        string word;        \\n        vector<string> vec;        \\n        while(ss >> word)  vec.emplace_back(word);                         \\n        stable_sort(vec.begin(), vec.end(), [](const auto& a, const auto& b){ return a.size() < b.size(); });        \\n        string ans;\\n        //for(const auto& w: vec) ans = ans + w + \\' \\'; // EER: Memory Limit Exceeded\\n        //for(const auto& w: vec) ans += w + \\' \\'; // ok\\n        for(const auto& w: vec) ans.append(move(w + \\' \\'));  //Better\\n        ans[0] -= (\\'a\\' - \\'A\\');\\n        return {ans.begin(), ans.begin() + ans.size() - 1};\\n    }\\n};\\n```\n```\\nclass Solution { // Map bucket solution\\npublic: // Time/Space: O(NlogN); N:=|text|\\n    string arrangeWords(string text) {\\n        text[0] = tolower(text[0]);\\n        stringstream ss(text), rs;\\n        string word;\\n        map<int, vector<string>> m;\\n        while (ss >> word) m[word.size()].emplace_back(word);    \\n        for (const auto& [k, v]: m)\\n            for(const auto& word: v)                \\n              rs << (word + \\' \\');\\n        string result(rs.str());\\n        result.pop_back();\\n        result[0] = toupper(result[0]);\\n        return result;\\n    }\\n};\\n// ref:  https://leetcode.com/problems/rearrange-words-in-a-sentence/discuss/636353/C%2B%2B-map-bucket-solution\\n```\n```\\nclass Solution {\\npublic: // Time/Space: O(NlogN); N:|text|\\n    string arrangeWords(string text) {        \\n        text[0] -= \\'A\\' - \\'a\\';\\n        map<int, vector<string>> dict;\\n        char* token = strtok((char*)text.c_str(), \" \");      \\n        while( token){\\n            string temp1(token);        \\n            dict[temp1.size()].emplace_back(temp1);        \\n            token = strtok(NULL, \" \");\\n        }\\n        string ans;\\n        for (auto& d : dict)\\n            for (auto& w : d.second)\\n                ans += w + \\' \\';\\n      \\n        ans[0] -= \\'a\\' - \\'A\\';\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n// ref: http://www.cplusplus.com/reference/cstring/strtok/\\n```\n```\\nclass Solution {\\npublic: // Time/Space: O(N); N:=|text|\\n    string arrangeWords(string text) {        \\n        text[0] -= \\'A\\' - \\'a\\';           \\n        vector<vector<string>> dict(10000); // 1 <= text.length <= 10^5\\n        char* token = strtok((char*)text.c_str(), \" \");      \\n        while( token){\\n            string temp1(token);        \\n            dict[temp1.size()].emplace_back(temp1);        \\n            token = strtok(NULL, \" \");\\n        }\\n        string ans;\\n        for (auto& d : dict){            \\n            for (auto& w : d)\\n                ans += w + \\' \\';\\n        }\\n        ans[0] -= \\'a\\' - \\'A\\';\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n// ref: http://www.cplusplus.com/reference/cstring/strtok/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864169,
                "title": "c-two-neat-solutions",
                "content": "**Solution 1 (28 ms %100) Using Ordered Map**\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int, string>> beSorted;\\n        map<int, string> sizeStrMap;\\n        string res = \"\";\\n        for (int i = 0; i < text.size(); i++) {\\n            string word = \"\";\\n            while (isalpha(text[i])) {\\n                word += tolower(text[i]);\\n                i++;\\n            }\\n            sizeStrMap[word.size()] += word + \" \";\\n        }\\n        \\n        for (auto pair : sizeStrMap) {\\n            res += pair.second;\\n        }\\n        \\n        res.pop_back();\\n        res[0] = toupper(res[0]);\\n        return res;\\n    }\\n};\\n```\\n\\n**Solution 2 (56 ms) Using Stable Sort and Custom Comparator**\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int, string>> beSorted;\\n        string res = \"\";\\n        for (int i = 0; i < text.size(); i++) {\\n            string word = \"\";\\n            while (isalpha(text[i])) {\\n                word += tolower(text[i]);\\n                i++;\\n            }\\n            beSorted.push_back({word.size(), word});\\n        }\\n        \\n        stable_sort(beSorted.begin(), beSorted.end(), [](const pair<int, string> &a, const pair<int, string> &b) {\\n            return (a.first < b.first);\\n        });\\n        \\n        for (pair<int, string> pair : beSorted) {\\n            res += pair.second + \" \";\\n        }\\n        \\n        res.pop_back();\\n        res[0] = toupper(res[0]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int, string>> beSorted;\\n        map<int, string> sizeStrMap;\\n        string res = \"\";\\n        for (int i = 0; i < text.size(); i++) {\\n            string word = \"\";\\n            while (isalpha(text[i])) {\\n                word += tolower(text[i]);\\n                i++;\\n            }\\n            sizeStrMap[word.size()] += word + \" \";\\n        }\\n        \\n        for (auto pair : sizeStrMap) {\\n            res += pair.second;\\n        }\\n        \\n        res.pop_back();\\n        res[0] = toupper(res[0]);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int, string>> beSorted;\\n        string res = \"\";\\n        for (int i = 0; i < text.size(); i++) {\\n            string word = \"\";\\n            while (isalpha(text[i])) {\\n                word += tolower(text[i]);\\n                i++;\\n            }\\n            beSorted.push_back({word.size(), word});\\n        }\\n        \\n        stable_sort(beSorted.begin(), beSorted.end(), [](const pair<int, string> &a, const pair<int, string> &b) {\\n            return (a.first < b.first);\\n        });\\n        \\n        for (pair<int, string> pair : beSorted) {\\n            res += pair.second + \" \";\\n        }\\n        \\n        res.pop_back();\\n        res[0] = toupper(res[0]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636445,
                "title": "python-sorting",
                "content": "* sort by length of each word\\n* capitalize the first word and merge rest of words\\n\\n```\\nclass Solution(object):\\n    def arrangeWords(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: str\\n        \"\"\"\\n        res = []\\n        for w in text.split():\\n            w = w.lower()            \\n            res.append(w)\\n        res = sorted(res, key=len)\\n        res = [res[0].capitalize()] + res[1:]\\n        return \\' \\'.join(res)\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrangeWords(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: str\\n        \"\"\"\\n        res = []\\n        for w in text.split():\\n            w = w.lower()            \\n            res.append(w)\\n        res = sorted(res, key=len)\\n        res = [res[0].capitalize()] + res[1:]\\n        return \\' \\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638261,
                "title": "javascript-easy-to-understand-bucket-sort",
                "content": "The algorithm for this problem is pretty straight forward. But the `Array.prototype.sort` in JS is not always stable which can\\'t fit this requirement:\\n\\n> If two words have the same length, arrange them in their original order.\\n\\nSo we need to implement a stable sort instead of it. Here, I choose a bucket sort since the range is not too large.\\n\\nThe code is here:\\n\\n```js\\nconst arrangeWords = text => {\\n  const buckets = [];\\n  const words = text.split(\\' \\');\\n  let ret = \\'\\';\\n  words[0] = words[0].toLowerCase();\\n  for (const word of words) {\\n    buckets[word.length] ? buckets[word.length].push(word) : (buckets[word.length] = [word]);\\n  }\\n  for (const list of buckets) {\\n    list && list.forEach(word => ret += word + \\' \\');\\n  }\\n  return ret[0].toUpperCase() + ret.slice(1, -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst arrangeWords = text => {\\n  const buckets = [];\\n  const words = text.split(\\' \\');\\n  let ret = \\'\\';\\n  words[0] = words[0].toLowerCase();\\n  for (const word of words) {\\n    buckets[word.length] ? buckets[word.length].push(word) : (buckets[word.length] = [word]);\\n  }\\n  for (const list of buckets) {\\n    list && list.forEach(word => ret += word + \\' \\');\\n  }\\n  return ret[0].toUpperCase() + ret.slice(1, -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 664649,
                "title": "python-3-simple-readable-fast",
                "content": "```python\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        \\n        # convert string to an array\\n        arr = text.split()\\n        \\n        # convert the first letter of the array to a lower case letter\\n        arr[0] = arr[0].lower()\\n        \\n        # sort array by length\\n        arr.sort(key=len)\\n        \\n        # convert the first letter of the array to an upper case letter\\n        arr[0] = arr[0].capitalize()\\n        \\n        # convert array to string\\n        return \" \".join(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        \\n        # convert string to an array\\n        arr = text.split()\\n        \\n        # convert the first letter of the array to a lower case letter\\n        arr[0] = arr[0].lower()\\n        \\n        # sort array by length\\n        arr.sort(key=len)\\n        \\n        # convert the first letter of the array to an upper case letter\\n        arr[0] = arr[0].capitalize()\\n        \\n        # convert array to string\\n        return \" \".join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636428,
                "title": "java-short-and-custom-sort",
                "content": "```\\n  public static String arrangeWords(String text) {\\n    String[] s = text.split(\" \");\\n    Arrays.sort(s, (s1, s2) -> {\\n      return s1.length() - s2.length();\\n    });\\n    StringBuilder v = new StringBuilder();\\n    for (String value : s) {\\n      v.append(\" \").append(value.toLowerCase());\\n    }\\n    char[] ans = v.substring(1).toCharArray();// remove space from front\\n    ans[0] = (char) (ans[0] + \\'A\\' - \\'a\\');//change uppercase\\n    return new String(ans);\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public static String arrangeWords(String text) {\\n    String[] s = text.split(\" \");\\n    Arrays.sort(s, (s1, s2) -> {\\n      return s1.length() - s2.length();\\n    });\\n    StringBuilder v = new StringBuilder();\\n    for (String value : s) {\\n      v.append(\" \").append(value.toLowerCase());\\n    }\\n    char[] ans = v.substring(1).toCharArray();// remove space from front\\n    ans[0] = (char) (ans[0] + \\'A\\' - \\'a\\');//change uppercase\\n    return new String(ans);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2584154,
                "title": "python-easy-solution",
                "content": "```\\ndef arrangeWords(self, text: str) -> str:\\n        seen = {}\\n        output = \"\"\\n        text_list = text.split()\\n        for word in text_list:\\n            n = len(word)\\n            if n in seen:\\n                value = seen[n]\\n                value.append(word.lower())\\n                seen[n] = value\\n            else:\\n                seen[n] = [word]\\n                                # seen = {4: [\\'Keep\\', \\'calm\\', \\'code\\'], 3: [\\'and\\'], 2: [\\'on\\']}\\n        for key in sorted(seen):\\n            output += \" \".join(seen[key]) + \" \"\\n        return output[:len(output)-1].capitalize()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef arrangeWords(self, text: str) -> str:\\n        seen = {}\\n        output = \"\"\\n        text_list = text.split()\\n        for word in text_list:\\n            n = len(word)\\n            if n in seen:\\n                value = seen[n]\\n                value.append(word.lower())\\n                seen[n] = value\\n            else:\\n                seen[n] = [word]\\n                                # seen = {4: [\\'Keep\\', \\'calm\\', \\'code\\'], 3: [\\'and\\'], 2: [\\'on\\']}\\n        for key in sorted(seen):\\n            output += \" \".join(seen[key]) + \" \"\\n        return output[:len(output)-1].capitalize()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 636397,
                "title": "arraylist-using-collection-sort-java-concise",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        if(text.length() == 0)\\n            return text;\\n        text = text.toLowerCase();\\n        String[] split = (text.split(\"\\\\\\\\s+\"));\\n    \\n        Arrays.sort(split,(s1,s2)->(s1.length() - s2.length()));\\n        StringBuilder sb = new StringBuilder();\\n       for(int i=0;i<split.length;i++){\\n           if(i == 0)\\n               split[i] = Character.toUpperCase(split[i].charAt(0)) + split[i].substring(1);\\n           sb.append(split[i]);\\n           if(i != split.length-1)\\n           sb.append(\" \");\\n        }\\n        \\n        return new String(sb);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        if(text.length() == 0)\\n            return text;\\n        text = text.toLowerCase();\\n        String[] split = (text.split(\"\\\\\\\\s+\"));\\n    \\n        Arrays.sort(split,(s1,s2)->(s1.length() - s2.length()));\\n        StringBuilder sb = new StringBuilder();\\n       for(int i=0;i<split.length;i++){\\n           if(i == 0)\\n               split[i] = Character.toUpperCase(split[i].charAt(0)) + split[i].substring(1);\\n           sb.append(split[i]);\\n           if(i != split.length-1)\\n           sb.append(\" \");\\n        }\\n        \\n        return new String(sb);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659766,
                "title": "java-simple-map",
                "content": "```\\npublic String arrangeWords(String text) {\\n        String t = text.toLowerCase();\\n        String[] ss = t.split(\"\\\\\\\\s+\");\\n        Map<Integer, List<String>> map = new HashMap<>();\\n        for (int i = 0; i < ss.length; i++) {\\n            map.computeIfAbsent(ss[i].length(), k -> new ArrayList<>());\\n            map.get(ss[i].length()).add(ss[i]);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i : map.keySet()) {\\n            for (String s : map.get(i)) {\\n                sb.append(sb.length() == 0 ? \"\" : \" \").append(s);\\n            }\\n        }\\n        sb.setCharAt(0, (char) (\\'A\\' + sb.charAt(0) - \\'a\\'));\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String arrangeWords(String text) {\\n        String t = text.toLowerCase();\\n        String[] ss = t.split(\"\\\\\\\\s+\");\\n        Map<Integer, List<String>> map = new HashMap<>();\\n        for (int i = 0; i < ss.length; i++) {\\n            map.computeIfAbsent(ss[i].length(), k -> new ArrayList<>());\\n            map.get(ss[i].length()).add(ss[i]);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i : map.keySet()) {\\n            for (String s : map.get(i)) {\\n                sb.append(sb.length() == 0 ? \"\" : \" \").append(s);\\n            }\\n        }\\n        sb.setCharAt(0, (char) (\\'A\\' + sb.charAt(0) - \\'a\\'));\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2870133,
                "title": "java-easiest-solution",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n        words[0] = words[0].toLowerCase();\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        words[0] = words[0].substring(0, 1).toUpperCase() + words[0].substring(1);\\n        return String.join(\" \", words);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n        words[0] = words[0].toLowerCase();\\n        Arrays.sort(words, Comparator.comparingInt(String::length));\\n        words[0] = words[0].substring(0, 1).toUpperCase() + words[0].substring(1);\\n        return String.join(\" \", words);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681504,
                "title": "c-clean-code-beat-99",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] = tolower(text[0]);\\n        stringstream ss(text);\\n        string buf;\\n        map<int,string> mymap;\\n        while(ss >> buf) \\n            mymap[buf.size()] += buf + \" \";\\n        \\n        string tmp = string();\\n        for(auto it : mymap)\\n            tmp += it.second;\\n        tmp[0] = toupper(tmp[0]);\\n        tmp.pop_back();\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] = tolower(text[0]);\\n        stringstream ss(text);\\n        string buf;\\n        map<int,string> mymap;\\n        while(ss >> buf) \\n            mymap[buf.size()] += buf + \" \";\\n        \\n        string tmp = string();\\n        for(auto it : mymap)\\n            tmp += it.second;\\n        tmp[0] = toupper(tmp[0]);\\n        tmp.pop_back();\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488438,
                "title": "98-53-faster-19ms-java-solution",
                "content": "```\\npublic String arrangeWords(String text) {\\n        \\n        String[] strArr = text.split(\" \");\\n        Arrays.sort(strArr, (str1, str2) -> str1.length()-str2.length());\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < strArr.length; i++){\\n            if(i == 0){\\n                sb.append(strArr[i].substring(0,1).toUpperCase() + strArr[i].substring(1));\\n            }\\n            else{\\n                sb.append(strArr[i].toLowerCase());\\n            }\\n            sb.append(\" \");\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\npublic String arrangeWords(String text) {\\n        \\n        String[] strArr = text.split(\" \");\\n        Arrays.sort(strArr, (str1, str2) -> str1.length()-str2.length());\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < strArr.length; i++){\\n            if(i == 0){\\n                sb.append(strArr[i].substring(0,1).toUpperCase() + strArr[i].substring(1));\\n            }\\n            else{\\n                sb.append(strArr[i].toLowerCase());\\n            }\\n            sb.append(\" \");\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 636446,
                "title": "java-simple-sort-array",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n        String result = \"\";\\n\\n\\t\\tComparator<String> lengthComparator = new Comparator<String>() {\\n    \\t\\t@Override    \\n\\t\\t\\tpublic int compare(String o1, String o2) {\\n        \\t\\treturn Integer.compare(o1.length(), o2.length());\\n    \\t\\t}\\n\\t\\t};\\n\\t\\tArrays.sort(words, lengthComparator);\\n        \\n        for (String word : words) {\\n            result = result + \" \" + word.toLowerCase();\\n        }\\n        result = result.substring(1, 2).toUpperCase() + result.substring(2);\\n        return result.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n        String result = \"\";\\n\\n\\t\\tComparator<String> lengthComparator = new Comparator<String>() {\\n    \\t\\t@Override    \\n\\t\\t\\tpublic int compare(String o1, String o2) {\\n        \\t\\treturn Integer.compare(o1.length(), o2.length());\\n    \\t\\t}\\n\\t\\t};\\n\\t\\tArrays.sort(words, lengthComparator);\\n        \\n        for (String word : words) {\\n            result = result + \" \" + word.toLowerCase();\\n        }\\n        result = result.substring(1, 2).toUpperCase() + result.substring(2);\\n        return result.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227297,
                "title": "easy-python-solution-using-sorting",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def arrangeWords(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: str\\n        \"\"\"\\n        text=list(text.split())\\n        lst=[]\\n        c=0\\n        for i in sorted(text,key=len):\\n            if c==0:\\n                lst.append(i.title())\\n                c+=1\\n            else:\\n                lst.append(i.lower())\\n        return \" \".join(lst)\\n```",
                "solutionTags": [
                    "Python",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrangeWords(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: str\\n        \"\"\"\\n        text=list(text.split())\\n        lst=[]\\n        c=0\\n        for i in sorted(text,key=len):\\n            if c==0:\\n                lst.append(i.title())\\n                c+=1\\n            else:\\n                lst.append(i.lower())\\n        return \" \".join(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802564,
                "title": "c-easy-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        string s=\"\";\\n        int n=text.length();\\n        char c=tolower(text[0]);\\n        text[0]=c;\\n        map<int,vector<string>>m;\\n        for(auto x:text){\\n            if(x!=\\' \\'){\\n                s+=x;\\n            }\\n            else{\\n                int len=s.length();\\n                m[len].push_back(s);\\n                s=\"\";\\n            }\\n        }\\n        int len=s.length();\\n        m[len].push_back(s);\\n        s=\"\";\\n        for(auto x:m){\\n            for(auto y:x.second){\\n                s+=y;\\n                s+=\" \";\\n            }\\n        }\\n        \\n        c=toupper(s[0]);\\n        s[0]=c;\\n        s.pop_back();\\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        string s=\"\";\\n        int n=text.length();\\n        char c=tolower(text[0]);\\n        text[0]=c;\\n        map<int,vector<string>>m;\\n        for(auto x:text){\\n            if(x!=\\' \\'){\\n                s+=x;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1663599,
                "title": "c-custom-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool static comp(pair<int,string> a, pair<int,string> b){\\n                 if(a.second.size() > b.second.size()) return false;\\n                 if(a.second.size() == b.second.size() && a.first > b.first) return false;\\n                 return true;\\n    }\\n    \\n    string arrangeWords(string text) {\\n            vector<pair<int,string>> vp;\\n            text[0] += 32;\\n            \\n            for(int i=0; i<text.size(); i++){\\n                int k = i;\\n                string cur = \"\";\\n                while(i<text.size() && text[i]!=\\' \\'){\\n                    cur += text[i];\\n                    i++;\\n                }\\n                \\n                vp.push_back({k,cur});                \\n            }\\n        \\n          sort(vp.begin(),vp.end(),comp);\\n          string ans;\\n        \\n          for(int i=0; i<vp.size(); i++){\\n               ans+=vp[i].second + \" \"  ;        \\n          }\\n         \\n           if(ans[0] >= \\'a\\' && ans[0] <= \\'z\\') ans[0] -= 32;\\n           ans.pop_back();\\n        \\n           return ans;\\n          \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool static comp(pair<int,string> a, pair<int,string> b){\\n                 if(a.second.size() > b.second.size()) return false;\\n                 if(a.second.size() == b.second.size() && a.first > b.first) return false;\\n                 return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1408850,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        map<int,vector<string>> mp;\\n        string temp;\\n        for(int i=0;i<text.size();i++){\\n            if(i<text.size() && text[i]!=\\' \\'){\\n                temp+=tolower(text[i]);\\n            }\\n            if(text[i]==\\' \\'){\\n                mp[temp.size()].push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        mp[temp.size()].push_back(temp);\\n        string res;\\n        for(auto i:mp){\\n            for(auto c:i.second){\\n                res+=c+\" \";\\n            }\\n        }\\n        res[0]=toupper(res[0]);\\n        res=res.substr(0,res.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        map<int,vector<string>> mp;\\n        string temp;\\n        for(int i=0;i<text.size();i++){\\n            if(i<text.size() && text[i]!=\\' \\'){\\n                temp+=tolower(text[i]);\\n            }\\n            if(text[i]==\\' \\'){\\n                mp[temp.size()].push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        mp[temp.size()].push_back(temp);\\n        string res;\\n        for(auto i:mp){\\n            for(auto c:i.second){\\n                res+=c+\" \";\\n            }\\n        }\\n        res[0]=toupper(res[0]);\\n        res=res.substr(0,res.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005999,
                "title": "java-sort-easy",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] arr = text.split(\" \");\\n        arr[0] = arr[0].substring(0,1).toLowerCase() + arr[0].substring(1);\\n        Arrays.sort(arr, (a,b)->(a.length()-b.length()));\\n        arr[0] = arr[0].substring(0,1).toUpperCase() + arr[0].substring(1);\\n        \\n        StringBuilder result = new StringBuilder(arr[0]);\\n        for(int i = 1; i < arr.length; i++) {\\n            result.append(\" \" + arr[i]);\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] arr = text.split(\" \");\\n        arr[0] = arr[0].substring(0,1).toLowerCase() + arr[0].substring(1);\\n        Arrays.sort(arr, (a,b)->(a.length()-b.length()));\\n        arr[0] = arr[0].substring(0,1).toUpperCase() + arr[0].substring(1);\\n        \\n        StringBuilder result = new StringBuilder(arr[0]);\\n        for(int i = 1; i < arr.length; i++) {\\n            result.append(\" \" + arr[i]);\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958020,
                "title": "c-stable-sort-and-custom-operator",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) \\n    {\\n     int n=text.size();\\n     if(n==0)\\n     {\\n         return text;\\n     }\\n        text[0]=text[0]-\\'A\\'+\\'a\\';\\n        vector<string> v;\\n        string s=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                v.push_back(s);\\n                s=\"\";\\n            }\\n            else\\n            {\\n                s.push_back(text[i]);\\n            }\\n        }\\n        v.push_back(s);\\n        stable_sort(v.begin(),v.end(),[](string a,string b)->bool\\n             {\\n                 return a.size()<b.size();\\n             });\\n        string ans=\"\";\\n        for(string &word: v)\\n        {\\n            ans.append(word);\\n            ans.push_back(\\' \\');\\n        }\\n        ans[0]=ans[0]+\\'A\\'-\\'a\\';\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) \\n    {\\n     int n=text.size();\\n     if(n==0)\\n     {\\n         return text;\\n     }\\n        text[0]=text[0]-\\'A\\'+\\'a\\';\\n        vector<string> v;\\n        string s=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(text[i]==\\' \\')\\n            {\\n                v.push_back(s);\\n                s=\"\";\\n            }\\n            else\\n            {\\n                s.push_back(text[i]);\\n            }\\n        }\\n        v.push_back(s);\\n        stable_sort(v.begin(),v.end(),[](string a,string b)->bool\\n             {\\n                 return a.size()<b.size();\\n             });\\n        string ans=\"\";\\n        for(string &word: v)\\n        {\\n            ans.append(word);\\n            ans.push_back(\\' \\');\\n        }\\n        ans[0]=ans[0]+\\'A\\'-\\'a\\';\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883182,
                "title": "java-4-lines-solution",
                "content": "```public String arrangeWords(String text) {\\n        String []res = text.toLowerCase().split(\" \");\\n        Arrays.sort(res, (a,b) ->  a.length() - b.length());\\n        String ans = String.join(\" \", res);\\n        return Character.toUpperCase(ans.charAt(0)) + ans.substring(1);\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```public String arrangeWords(String text) {\\n        String []res = text.toLowerCase().split(\" \");\\n        Arrays.sort(res, (a,b) ->  a.length() - b.length());\\n        String ans = String.join(\" \", res);\\n        return Character.toUpperCase(ans.charAt(0)) + ans.substring(1);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 636893,
                "title": "javascript-solution-using-sorting-no-map-used",
                "content": "```\\nRuntime: 76 ms, faster than 100.00% of JavaScript online submissions for Rearrange Words in a Sentence.\\nMemory Usage: 39.2 MB, less than 100.00% of JavaScript online submissions for Rearrange Words in a Sentence.\\n```\\n\\nFollow the comments for explaination\\n\\n```\\nvar arrangeWords = function(text) {\\n    //sort the array based on length and keeping the order same if length is same\\n    var sortArray = function(s){\\n        for (var i=1 ;i<s.length; i++){ \\n            var temp = s[i];\\n            var j = i - 1; \\n            while (j >= 0 && temp.length < s[j].length){ \\n                s[j+1] = s[j]; \\n                j--; \\n            } \\n            s[j+1] = temp; \\n        } \\n    }\\n    //to capitalize First letter\\n    var capitalizeFirstLetter = function (string) {\\n        return string.charAt(0).toUpperCase() + string.slice(1);\\n    }\\n    //convert the string to lowercase from sentence case\\n    text = text.toLowerCase();\\n    //split the string to form an array of words\\n    var text = text.split(\" \");\\n    //sort the array\\n    sortArray(text);\\n    //join the array to form a string\\n    text = text.join(\" \");\\n    //convert the string to sentence case\\n    return capitalizeFirstLetter(text);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nRuntime: 76 ms, faster than 100.00% of JavaScript online submissions for Rearrange Words in a Sentence.\\nMemory Usage: 39.2 MB, less than 100.00% of JavaScript online submissions for Rearrange Words in a Sentence.\\n```\n```\\nvar arrangeWords = function(text) {\\n    //sort the array based on length and keeping the order same if length is same\\n    var sortArray = function(s){\\n        for (var i=1 ;i<s.length; i++){ \\n            var temp = s[i];\\n            var j = i - 1; \\n            while (j >= 0 && temp.length < s[j].length){ \\n                s[j+1] = s[j]; \\n                j--; \\n            } \\n            s[j+1] = temp; \\n        } \\n    }\\n    //to capitalize First letter\\n    var capitalizeFirstLetter = function (string) {\\n        return string.charAt(0).toUpperCase() + string.slice(1);\\n    }\\n    //convert the string to lowercase from sentence case\\n    text = text.toLowerCase();\\n    //split the string to form an array of words\\n    var text = text.split(\" \");\\n    //sort the array\\n    sortArray(text);\\n    //join the array to form a string\\n    text = text.join(\" \");\\n    //convert the string to sentence case\\n    return capitalizeFirstLetter(text);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828860,
                "title": "python-3-simple-easy-to-understand-fast",
                "content": "# Code\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        a = []\\n        for x in text.split(\" \"):\\n            a.append(x.lower())\\n        return \" \".join(sorted(a, key=len)).capitalize()\\n```\\n\\n# One Liner\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(\" \"), key=len)).capitalize()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        a = []\\n        for x in text.split(\" \"):\\n            a.append(x.lower())\\n        return \" \".join(sorted(a, key=len)).capitalize()\\n```\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(\" \"), key=len)).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822109,
                "title": "python-easy-solution-using-dictionary-and-sorting",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        a=text.split()\\n        d,t={},\\'\\'\\n        for i in a:\\n            l=len(i)\\n            if l in d:\\n                d[l]+=\" \"+i\\n            else:\\n                d[l]=i\\n        for i in sorted(d):\\n            t+=\" \"+d[i]\\n        t=t.lstrip().capitalize()\\n        return t\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        a=text.split()\\n        d,t={},\\'\\'\\n        for i in a:\\n            l=len(i)\\n            if l in d:\\n                d[l]+=\" \"+i\\n            else:\\n                d[l]=i\\n        for i in sorted(d):\\n            t+=\" \"+d[i]\\n        t=t.lstrip().capitalize()\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780961,
                "title": "cpp-solution-using-multimap-for-sorting",
                "content": "# Intuition\\nSort them according to there size and append it to a empty string\\n\\n# Approach\\n-> Sort each word of the string according to there size by the help of multimap(where key is size of the word an value is the word in map)\\n\\n-> Convert every character to lowercase(using transform function)\\n\\n-> Remove the extra last space that is added in the string while creating the answer string, and lastly covert the first character to uppercase and then return it.\\n\\n# Complexity\\n- Time complexity: O(n), 78.15% better than Cpp online submissions\\n\\n- Space complexity: O(n),49.17% better than Cpp online submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string t) {\\n        multimap<int,string> mp;\\n        string s=\"\";\\n        for(int i=0;i<t.size();i++)\\n        {\\n           if(t[i]==\\' \\')\\n           {\\n               mp.insert({s.size(),s});\\n               s=\"\";\\n           }\\n           else\\n             s+=t[i];\\n        }\\n        mp.insert({s.size(),s});\\n        s=\"\";\\n        for (auto& it : mp) \\n        {\\n           string s2=it.second;\\n           transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\\n           s+=(s2+\" \");\\n        }\\n        s=s.substr(0,s.size()-1);\\n        s[0]=toupper(s[0]);\\n  return s;  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string t) {\\n        multimap<int,string> mp;\\n        string s=\"\";\\n        for(int i=0;i<t.size();i++)\\n        {\\n           if(t[i]==\\' \\')\\n           {\\n               mp.insert({s.size(),s});\\n               s=\"\";\\n           }\\n           else\\n             s+=t[i];\\n        }\\n        mp.insert({s.size(),s});\\n        s=\"\";\\n        for (auto& it : mp) \\n        {\\n           string s2=it.second;\\n           transform(s2.begin(), s2.end(), s2.begin(), ::tolower);\\n           s+=(s2+\" \");\\n        }\\n        s=s.substr(0,s.size()-1);\\n        s[0]=toupper(s[0]);\\n  return s;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513056,
                "title": "easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        transform(text.begin(), text.begin()+1,text.begin(), ::tolower);\\n        map<int,vector<string> > m;\\n        string str = \"\";\\n        int l = text.length();\\n        for(int i=0; i<l; ++i){\\n            if(text[i] != \\' \\'){\\n                str += text[i];\\n            }\\n            else{\\n                int p = str.length();\\n                m[p].push_back(str);\\n                str = \"\";\\n            }\\n        }\\n        int p = str.length();\\n        m[p].push_back(str);\\n        string s = \"\";\\n        for(auto& itr : m){\\n            for(auto& i : itr.second){\\n                s += i + \" \";\\n            }\\n        }\\n        s.pop_back();\\n        transform(s.begin(),s.begin()+1,s.begin(), ::toupper);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        transform(text.begin(), text.begin()+1,text.begin(), ::tolower);\\n        map<int,vector<string> > m;\\n        string str = \"\";\\n        int l = text.length();\\n        for(int i=0; i<l; ++i){\\n            if(text[i] != \\' \\'){\\n                str += text[i];\\n            }\\n            else{\\n                int p = str.length();\\n                m[p].push_back(str);\\n                str = \"\";\\n            }\\n        }\\n        int p = str.length();\\n        m[p].push_back(str);\\n        string s = \"\";\\n        for(auto& itr : m){\\n            for(auto& i : itr.second){\\n                s += i + \" \";\\n            }\\n        }\\n        s.pop_back();\\n        transform(s.begin(),s.begin()+1,s.begin(), ::toupper);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958479,
                "title": "c-easy-to-understand-simple-solution-stable-sort-comparator",
                "content": "**we need to use stable_sort() instead of sort() because here we need to keep the ordering of words with same length as it is in the new string as in the old one. And, it\\'s important to note that stable_sort() internally makes use of merge sort so the relative ordering stays same in case the lengths of substrings are equal**\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string s) {\\n        s+=\\' \\';\\n        int n=s.size();\\n        int j=0;\\n        vector<string> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(j,i-j);\\n                j=i+1;\\n                v.push_back(str);\\n            }\\n        }\\n        stable_sort(v.begin(),v.end(), [](const auto &s1, const auto &s2) { return s1.length() < s2.length(); });\\n        string ans=\"\";\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string str=v[i];\\n            if(str[0]>=65&&str[0]<=90)\\n            {\\n                str[0]+=32;    \\n            }\\n            ans+=str;\\n            if(i!=n-1)\\n            ans+=\\' \\';\\n        }\\n        ans[0]=(char)(ans[0]-32);\\n        return ans;\\n    }\\n};\\n```\\n**Another Way to implement comparator**\\n```\\n#include<algorithm>\\nclass Solution {\\npublic:\\n    bool static comp(string a,string b)\\n    {\\n        return a.size()<b.size();\\n    }\\n    string arrangeWords(string s) {\\n        s+=\\' \\';\\n        int n=s.size();\\n        int j=0;\\n        vector<string> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(j,i-j);\\n                j=i+1;\\n                v.push_back(str);\\n            }\\n        }\\n        stable_sort(v.begin(),v.end(),comp);\\n        string ans=\"\";\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string str=v[i];\\n            if(str[0]>=65&&str[0]<=90)\\n            {\\n                str[0]+=32;    \\n            }\\n            ans+=str;\\n            if(i!=n-1)\\n            ans+=\\' \\';\\n        }\\n        ans[0]=(char)(ans[0]-32);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string s) {\\n        s+=\\' \\';\\n        int n=s.size();\\n        int j=0;\\n        vector<string> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(j,i-j);\\n                j=i+1;\\n                v.push_back(str);\\n            }\\n        }\\n        stable_sort(v.begin(),v.end(), [](const auto &s1, const auto &s2) { return s1.length() < s2.length(); });\\n        string ans=\"\";\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string str=v[i];\\n            if(str[0]>=65&&str[0]<=90)\\n            {\\n                str[0]+=32;    \\n            }\\n            ans+=str;\\n            if(i!=n-1)\\n            ans+=\\' \\';\\n        }\\n        ans[0]=(char)(ans[0]-32);\\n        return ans;\\n    }\\n};\\n```\n```\\n#include<algorithm>\\nclass Solution {\\npublic:\\n    bool static comp(string a,string b)\\n    {\\n        return a.size()<b.size();\\n    }\\n    string arrangeWords(string s) {\\n        s+=\\' \\';\\n        int n=s.size();\\n        int j=0;\\n        vector<string> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(j,i-j);\\n                j=i+1;\\n                v.push_back(str);\\n            }\\n        }\\n        stable_sort(v.begin(),v.end(),comp);\\n        string ans=\"\";\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string str=v[i];\\n            if(str[0]>=65&&str[0]<=90)\\n            {\\n                str[0]+=32;    \\n            }\\n            ans+=str;\\n            if(i!=n-1)\\n            ans+=\\' \\';\\n        }\\n        ans[0]=(char)(ans[0]-32);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1483577,
                "title": "python-faster-than-99-49-easy-implementation",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, s: str) -> str:\\n        s1= s.split() \\n        s1=sorted(s1,key= lambda x: len(x))\\n        s2= \" \".join(s1)\\n        \\n        s2= s2.capitalize()\\n        \\n        return s2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, s: str) -> str:\\n        s1= s.split() \\n        s1=sorted(s1,key= lambda x: len(x))\\n        s2= \" \".join(s1)\\n        \\n        s2= s2.capitalize()\\n        \\n        return s2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166969,
                "title": "map-16ms-c",
                "content": "```\\nclass Solution {\\n    public:\\n    string arrangeWords(string text) {\\n        \\n        map<int , vector<string> > mp ;\\n        \\n        text[0]=tolower(text[0]);\\n        string s=\"\";\\n        \\n        for(int i=0; i<text.length() ; i++)\\n        {\\n            if(isspace(text[i]))\\n            {        \\n                s.push_back(\\' \\');\\n                mp[s.length()].push_back(s);\\n                s=\"\";\\n            }\\n            else\\n            s.push_back(text[i]);\\n        }\\n        \\n          s.push_back(\\' \\');\\n           mp[s.length()].push_back(s);\\n              text=\"\";\\n        \\n        for(auto i=mp.begin(); i!=mp.end() ; i++)   \\n        {\\n           for(int j=0; j<i->second.size() ; j++) \\n                text.append(i->second[j]);\\n        }\\n        \\n         text.pop_back();\\n         text[0]=toupper(text[0]);\\n        \\n    \\n        return text;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n    string arrangeWords(string text) {\\n        \\n        map<int , vector<string> > mp ;\\n        \\n        text[0]=tolower(text[0]);\\n        string s=\"\";\\n        \\n        for(int i=0; i<text.length() ; i++)\\n        {\\n            if(isspace(text[i]))\\n            {        \\n                s.push_back(\\' \\');\\n                mp[s.length()].push_back(s);\\n                s=\"\";\\n            }\\n            else\\n            s.push_back(text[i]);\\n        }\\n        \\n          s.push_back(\\' \\');\\n           mp[s.length()].push_back(s);\\n              text=\"\";\\n        \\n        for(auto i=mp.begin(); i!=mp.end() ; i++)   \\n        {\\n           for(int j=0; j<i->second.size() ; j++) \\n                text.append(i->second[j]);\\n        }\\n        \\n         text.pop_back();\\n         text[0]=toupper(text[0]);\\n        \\n    \\n        return text;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075289,
                "title": "java-custom-sort-16ms-beats-95-o-text-length-words-size-log-words-size",
                "content": "\\n    class Pair implements Comparable<Pair> {\\n\\n\\t\\tint idx;\\n\\t\\tint length;\\n\\t\\tString word;\\n\\n\\t\\tpublic Pair(int idx, int length, String word) {\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.length = length;\\n\\t\\t\\tthis.word = word;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic int compareTo(Pair o) {\\n\\t\\t\\treturn (this.length == o.length) ? this.idx - o.idx : this.length - o.length;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic String arrangeWords(String text) {\\n\\n\\t\\tList<Pair> words = new ArrayList<Pair>();\\n\\t\\tStringBuilder ans = new StringBuilder();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint idx = 0;\\n\\t\\tfor (char ch : text.toCharArray()) {\\n\\t\\t\\tif (ch == \\' \\') {\\n\\t\\t\\t\\tsb.setCharAt(0, Character.toLowerCase(sb.charAt(0)));\\n\\t\\t\\t\\twords.add(new Pair(idx++, sb.length(), sb.toString()));\\n\\t\\t\\t\\tsb.setLength(0);\\n\\t\\t\\t} else\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t}\\n\\t\\tsb.setCharAt(0, Character.toLowerCase(sb.charAt(0)));\\n\\t\\twords.add(new Pair(idx, sb.length(), sb.toString()));\\n\\t\\tCollections.sort(words);\\n\\n\\t\\tPair first = words.get(0);\\n\\t\\tString s = first.word;\\n\\t\\tchar[] str = new char[first.length];\\n\\t\\tfor (int i = 0; i < str.length; i++)\\n\\t\\t\\tstr[i] = s.charAt(i);\\n\\n\\t\\tstr[0] = Character.toUpperCase(str[0]);\\n\\t\\tans.append(str);\\n\\t\\tans.append(\\' \\');\\n\\t\\tint len = words.size();\\n\\n\\t\\tfor (int i = 1; i < len - 1; i++) {\\n\\t\\t\\tans.append(words.get(i).word);\\n\\t\\t\\tans.append(\\' \\');\\n\\t\\t}\\n\\n\\t\\tans.append(words.get(len - 1).word);\\n\\t\\treturn ans.toString();\\n\\t}\\n\\n",
                "solutionTags": [],
                "code": "\\n    class Pair implements Comparable<Pair> {\\n\\n\\t\\tint idx;\\n\\t\\tint length;\\n\\t\\tString word;\\n\\n\\t\\tpublic Pair(int idx, int length, String word) {\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.length = length;\\n\\t\\t\\tthis.word = word;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic int compareTo(Pair o) {\\n\\t\\t\\treturn (this.length == o.length) ? this.idx - o.idx : this.length - o.length;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic String arrangeWords(String text) {\\n\\n\\t\\tList<Pair> words = new ArrayList<Pair>();\\n\\t\\tStringBuilder ans = new StringBuilder();\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tint idx = 0;\\n\\t\\tfor (char ch : text.toCharArray()) {\\n\\t\\t\\tif (ch == \\' \\') {\\n\\t\\t\\t\\tsb.setCharAt(0, Character.toLowerCase(sb.charAt(0)));\\n\\t\\t\\t\\twords.add(new Pair(idx++, sb.length(), sb.toString()));\\n\\t\\t\\t\\tsb.setLength(0);\\n\\t\\t\\t} else\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t}\\n\\t\\tsb.setCharAt(0, Character.toLowerCase(sb.charAt(0)));\\n\\t\\twords.add(new Pair(idx, sb.length(), sb.toString()));\\n\\t\\tCollections.sort(words);\\n\\n\\t\\tPair first = words.get(0);\\n\\t\\tString s = first.word;\\n\\t\\tchar[] str = new char[first.length];\\n\\t\\tfor (int i = 0; i < str.length; i++)\\n\\t\\t\\tstr[i] = s.charAt(i);\\n\\n\\t\\tstr[0] = Character.toUpperCase(str[0]);\\n\\t\\tans.append(str);\\n\\t\\tans.append(\\' \\');\\n\\t\\tint len = words.size();\\n\\n\\t\\tfor (int i = 1; i < len - 1; i++) {\\n\\t\\t\\tans.append(words.get(i).word);\\n\\t\\t\\tans.append(\\' \\');\\n\\t\\t}\\n\\n\\t\\tans.append(words.get(len - 1).word);\\n\\t\\treturn ans.toString();\\n\\t}\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 988023,
                "title": "simple-python-99-using-sort-with-comments",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n\\t\\t# get all words\\n        words = text.split()\\n\\t\\t#lowercase first word\\n        words[0] = words[0].lower()\\n\\t\\t# sort based on length, this internally uses tim sort which preserves the order when length is same\\n        words.sort(key= len)\\n\\t\\t# uppercase the first one\\n        words[0] = words[0][0].upper() + words[0][1:]\\n\\t\\t# join and return\\n        return \\' \\'.join(words)\\n```\\nTime - O(nlogn) beacuse of sort\\nSpace - O(n), array has same space as the text",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n\\t\\t# get all words\\n        words = text.split()\\n\\t\\t#lowercase first word\\n        words[0] = words[0].lower()\\n\\t\\t# sort based on length, this internally uses tim sort which preserves the order when length is same\\n        words.sort(key= len)\\n\\t\\t# uppercase the first one\\n        words[0] = words[0][0].upper() + words[0][1:]\\n\\t\\t# join and return\\n        return \\' \\'.join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987373,
                "title": "o-n-time-and-o-n-space-using-hash-and-min-heap",
                "content": "```\\npublic String arrangeWords(String text) {\\n\\t\\tString[] sentences = text.split(\" \");\\n\\t\\tHashMap<Integer,String> hash = new HashMap<Integer,String>();\\n\\t\\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\\n\\t\\tfor(String s : sentences) \\n\\t\\t{\\n\\t\\t\\tif(!hash.containsKey(s.length())) \\n\\t\\t\\t{\\n\\t\\t\\t\\thash.put(s.length(),s+\" \");\\n\\t\\t\\t\\tq.add(s.length());\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\thash.put(s.length(), hash.get(s.length())+s+\" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tString sentence = \"\";\\n\\t\\tInteger length = q.poll();\\n\\t\\tchar c = hash.get(length).charAt(0);\\n\\t\\tString s = hash.get(length).replaceFirst(c+\"\", Character.toUpperCase(c)+\"\");\\n\\t\\tsentence = s.trim()+\" \";\\n\\t\\twhile(!q.isEmpty()) \\n\\t\\t{\\n\\t\\t\\tlength = q.poll();\\n\\t\\t\\tsentence += hash.get(length).trim().toLowerCase() + \" \";\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sentence.trim();\\n\\t}\\n```\\n\\nIf anyone has any suggestions or questions, please throw them my way!",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic String arrangeWords(String text) {\\n\\t\\tString[] sentences = text.split(\" \");\\n\\t\\tHashMap<Integer,String> hash = new HashMap<Integer,String>();\\n\\t\\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\\n\\t\\tfor(String s : sentences) \\n\\t\\t{\\n\\t\\t\\tif(!hash.containsKey(s.length())) \\n\\t\\t\\t{\\n\\t\\t\\t\\thash.put(s.length(),s+\" \");\\n\\t\\t\\t\\tq.add(s.length());\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\thash.put(s.length(), hash.get(s.length())+s+\" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tString sentence = \"\";\\n\\t\\tInteger length = q.poll();\\n\\t\\tchar c = hash.get(length).charAt(0);\\n\\t\\tString s = hash.get(length).replaceFirst(c+\"\", Character.toUpperCase(c)+\"\");\\n\\t\\tsentence = s.trim()+\" \";\\n\\t\\twhile(!q.isEmpty()) \\n\\t\\t{\\n\\t\\t\\tlength = q.poll();\\n\\t\\t\\tsentence += hash.get(length).trim().toLowerCase() + \" \";\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn sentence.trim();\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877656,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \\' \\'.join(sorted(text.lower().split(), key = lambda s: len(s))).capitalize()\\n```\\nMore verbose for understanding:\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n\\t\\ttext.lower() #convert to lowercase\\n\\t\\twords = text.split() #separate words, put them in to an array\\n\\t\\twords.sort(key = lambda s: len(s)) #sort the words by length\\n\\t\\treturn \\' \\'.join(words).capitalize() #join the words with a space in between, capitalize the first letter\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \\' \\'.join(sorted(text.lower().split(), key = lambda s: len(s))).capitalize()\\n```\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n\\t\\ttext.lower() #convert to lowercase\\n\\t\\twords = text.split() #separate words, put them in to an array\\n\\t\\twords.sort(key = lambda s: len(s)) #sort the words by length\\n\\t\\treturn \\' \\'.join(words).capitalize() #join the words with a space in between, capitalize the first letter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872201,
                "title": "my-java-solution-with-idea-and-comment-for-each-line-of-code",
                "content": "```\\n/* \\nMy thought process\\nHere the idea is to sort each words based on the length and join them with the new first letter as uppercase.\\n*/\\n\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        // 1. First lets make a string array with only lowercase and separated by space.\\n        String [] array = text.toLowerCase().split(\"\\\\\\\\s\");\\n        // 2. Now sort the words based on their length.\\n        Arrays.sort(array, (a, b) -> a.length() - b.length());\\n        // 3. We have string.join() to join the string with a delimiter\\n        String result = String.join(\" \", array);\\n        // 4. Now return the final string making the first character uppercase and concatenating the remaining string.\\n        return Character.toUpperCase(result.charAt(0)) + result.substring(1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n/* \\nMy thought process\\nHere the idea is to sort each words based on the length and join them with the new first letter as uppercase.\\n*/\\n\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        // 1. First lets make a string array with only lowercase and separated by space.\\n        String [] array = text.toLowerCase().split(\"\\\\\\\\s\");\\n        // 2. Now sort the words based on their length.\\n        Arrays.sort(array, (a, b) -> a.length() - b.length());\\n        // 3. We have string.join() to join the string with a delimiter\\n        String result = String.join(\" \", array);\\n        // 4. Now return the final string making the first character uppercase and concatenating the remaining string.\\n        return Character.toUpperCase(result.charAt(0)) + result.substring(1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855761,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        text=text.toLowerCase();\\nString b[]=text.split(\"[ ]+\");\\nArrays.sort(b, (x,y) -> Integer.compare(x.length(),y.length()));\\nString c=String.valueOf(b[0].charAt(0));\\nc=c.toUpperCase();\\nString d=b[0].substring(1,b[0].length());\\nb[0]=c+d;\\nString solution=\"\";\\nfor(int i=0;i<b.length;i++){\\n    solution+=b[i]+\" \";\\n}\\n        return solution.trim();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        text=text.toLowerCase();\\nString b[]=text.split(\"[ ]+\");\\nArrays.sort(b, (x,y) -> Integer.compare(x.length(),y.length()));\\nString c=String.valueOf(b[0].charAt(0));\\nc=c.toUpperCase();\\nString d=b[0].substring(1,b[0].length());\\nb[0]=c+d;\\nString solution=\"\";\\nfor(int i=0;i<b.length;i++){\\n    solution+=b[i]+\" \";\\n}\\n        return solution.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837131,
                "title": "cpp-solution-using-map-of-vectors",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0]=tolower(text[0]);\\n        stringstream s(text);\\n       map<int,vector<string>>mp;\\n        string word;\\n        while(s>>word)\\n        {\\n           int p=word.size();\\n            mp[p].push_back(word);\\n        }\\n        string ans=\"\";\\n        for(auto i:mp)\\n        {\\n            for(int j=0;j<i.second.size();j++)\\n            {\\n                ans+=i.second[j];\\n                ans+=\" \";\\n            }\\n        }\\n        ans.erase(ans.size()-1,1);\\n        ans[0]=toupper(ans[0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0]=tolower(text[0]);\\n        stringstream s(text);\\n       map<int,vector<string>>mp;\\n        string word;\\n        while(s>>word)\\n        {\\n           int p=word.size();\\n            mp[p].push_back(word);\\n        }\\n        string ans=\"\";\\n        for(auto i:mp)\\n        {\\n            for(int j=0;j<i.second.size();j++)\\n            {\\n                ans+=i.second[j];\\n                ans+=\" \";\\n            }\\n        }\\n        ans.erase(ans.size()-1,1);\\n        ans[0]=toupper(ans[0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824657,
                "title": "c-custom-sort-code",
                "content": "Create a vector<pair<string,int>> where you store the string and its serial number (the order in which the string appears). then in the sort funtion , compare two strings, if their lengths are equal return true if the string that comes first has smaller serial number.\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool compare(pair<string,int> &a, pair<string,int> &b)\\n    {\\n        if(a.first.length() == b.first.length())\\n        {\\n            return a.second < b.second;\\n        }\\n        return a.first.length() < b.first.length();\\n    }\\n    \\n    string arrangeWords(string text) {\\n       int n = text.length();\\n        if(n==1)\\n            return text;\\n        \\n        text[0] += 32;\\n        \\n        stringstream st(text);\\n        string word;\\n        vector<pair<string,int>>a;\\n        int c = 0;\\n        while(st>>word)\\n        {\\n            a.push_back({word,c});\\n            c++;\\n        }\\n        sort(a.begin(),a.end(),compare);\\n        text = \"\";\\n        text = a[0].first;\\n        \\n        for(int i=1;i<a.size();i++)\\n        {\\n            text += \\' \\';\\n            text += a[i].first;\\n        }\\n        text[0] -= 32;\\n        return text;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    static bool compare(pair<string,int> &a, pair<string,int> &b)\\n    {\\n        if(a.first.length() == b.first.length())\\n        {\\n            return a.second < b.second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 783763,
                "title": "6-lines-go-solution-beats-95-using-sort-stable",
                "content": "```\\nfunc arrangeWords(str string) string {\\n\\n\\t// convert 1st letter to small\\n    str = strings.ToLower(string(str[0])) + str[1:]\\n\\tstrArr := strings.Split(str, \" \")\\n\\tsort.SliceStable(strArr, func(i, j int) bool {\\n\\t\\treturn len(strArr[i]) < len(strArr[j])\\n\\t})\\n\\n\\t// convert the finall 1st words first letter to caps\\n\\tstrArr[0] = strings.ToUpper(string(strArr[0][0])) + strArr[0][1:]\\n    \\n    return strings.Join(strArr , \" \")\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc arrangeWords(str string) string {\\n\\n\\t// convert 1st letter to small\\n    str = strings.ToLower(string(str[0])) + str[1:]\\n\\tstrArr := strings.Split(str, \" \")\\n\\tsort.SliceStable(strArr, func(i, j int) bool {\\n\\t\\treturn len(strArr[i]) < len(strArr[j])\\n\\t})\\n\\n\\t// convert the finall 1st words first letter to caps\\n\\tstrArr[0] = strings.ToUpper(string(strArr[0][0])) + strArr[0][1:]\\n    \\n    return strings.Join(strArr , \" \")\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640637,
                "title": "javascript-python3-c-stable-sort",
                "content": "**Synopsis:**\\n\\nPerform stable sort based on word length.\\n\\n---\\n\\n*Javascript*\\n```\\nlet arrangeWords = text => {\\n    let S = text.split(\\' \\');\\n    S[0] = S[0][0].toLowerCase() + S[0].substring(1);\\n    S.sort((a, b) => a.length - b.length);\\n    S[0] = S[0][0].toUpperCase() + S[0].substring(1);\\n    return S.join(\\' \\');\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        S = text.split(\\' \\')\\n        S[0] = S[0][0].lower() + S[0][1:]\\n        S.sort(key = lambda s: len(s))\\n        S[0] = S[0][0].upper() + S[0][1:]\\n        return \\' \\'.join(S)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Words = vector<string>;\\n    string arrangeWords(string text, string word = {}, Words S = {}, ostringstream out = ostringstream()) {\\n        for (istringstream stream{ text }; stream >> word; S.emplace_back(word));\\n        S[0][0] = tolower(S[0][0]);\\n        stable_sort(S.begin(), S.end(), [](auto& a, auto& b) { return a.size() < b.size(); });\\n        S[0][0] = toupper(S[0][0]);\\n        copy(S.begin(), S.end(), ostream_iterator<string>(out, \" \"));\\n        auto ans = out.str(); ans.pop_back(); // pop trailing whitespace\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet arrangeWords = text => {\\n    let S = text.split(\\' \\');\\n    S[0] = S[0][0].toLowerCase() + S[0].substring(1);\\n    S.sort((a, b) => a.length - b.length);\\n    S[0] = S[0][0].toUpperCase() + S[0].substring(1);\\n    return S.join(\\' \\');\\n};\\n```\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        S = text.split(\\' \\')\\n        S[0] = S[0][0].lower() + S[0][1:]\\n        S.sort(key = lambda s: len(s))\\n        S[0] = S[0][0].upper() + S[0][1:]\\n        return \\' \\'.join(S)\\n```\n```\\nclass Solution {\\npublic:\\n    using Words = vector<string>;\\n    string arrangeWords(string text, string word = {}, Words S = {}, ostringstream out = ostringstream()) {\\n        for (istringstream stream{ text }; stream >> word; S.emplace_back(word));\\n        S[0][0] = tolower(S[0][0]);\\n        stable_sort(S.begin(), S.end(), [](auto& a, auto& b) { return a.size() < b.size(); });\\n        S[0][0] = toupper(S[0][0]);\\n        copy(S.begin(), S.end(), ostream_iterator<string>(out, \" \"));\\n        auto ans = out.str(); ans.pop_back(); // pop trailing whitespace\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638898,
                "title": "java-optimal-solution-o-n-log-n-time",
                "content": "class Solution {\\n \\n\\tpublic String arrangeWords(String text) {\\n\\t\\n\\t\\tList<String> list = new LinkedList<>();\\n\\t\\tfor(String s : text.split(\" \")) list.add(s.toLowerCase());\\n \\n\\t\\tCollections.sort(list, (s1, s2) -> s1.length() - s2.length());\\n\\t\\tStringBuffer sb = new StringBuffer();\\n\\t\\tfor(String s : list) sb.append(s + \" \");\\n\\t\\t\\n\\t\\tString ans = sb.toString();\\n\\t\\tans = ans.trim();\\n\\t\\tans =  Character.toUpperCase(ans.charAt(0)) + ans.substring(1);\\n\\t\\treturn ans;\\n\\t}\\n}\\n \\nTime Complexity: O(N)\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "class Solution {\\n \\n\\tpublic String arrangeWords(String text) {\\n\\t\\n\\t\\tList<String> list = new LinkedList<>();\\n\\t\\tfor(String s : text.split(\" \")) list.add(s.toLowerCase());\\n \\n\\t\\tCollections.sort(list, (s1, s2) -> s1.length() - s2.length());\\n\\t\\tStringBuffer sb = new StringBuffer();\\n\\t\\tfor(String s : list) sb.append(s + \" \");\\n\\t\\t\\n\\t\\tString ans = sb.toString();\\n\\t\\tans = ans.trim();\\n\\t\\tans =  Character.toUpperCase(ans.charAt(0)) + ans.substring(1);\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 636884,
                "title": "c-o-n-using-map-video-solution",
                "content": "https://youtu.be/2-rw4dzoZtQ\\nAlgo:\\nmake a map  of int , vector< string >\\ncalculate the length of each string separated by space and on the run add to corresponding key of the map\\nconvert to lower case all characters while making the string\\n\\tc = tolower(c);\\n\\ttemp+=c;\\nmake a new string \\nand then iterate over the map ( map is already sorted acc to key ) \\nadd the string from the value of the map ( also add a space )\\njust remove the last space\\nconvert the first character to upper case\\n\\n```\\n string arrangeWords(string text) {\\n        map<int,vector<string>> mp;\\n        string temp;\\n        int len = 0 ;\\n        for(char c : text){\\n            \\n            if(c == \\' \\'){\\n                mp[len].push_back(temp);\\n                temp=\"\";\\n                len = 0;\\n            }else{\\n                len+=1;\\n                c = tolower(c);\\n                temp+=c;\\n            }\\n        }\\n        mp[len].push_back(temp);\\n        string ans;\\n        for(auto it : mp){\\n            for(string s : it.second){\\n                ans+= s;\\n                ans+= \" \";\\n            }\\n        }\\n        ans.pop_back();\\n        \\n        ans[0] = toupper(ans[0]);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n string arrangeWords(string text) {\\n        map<int,vector<string>> mp;\\n        string temp;\\n        int len = 0 ;\\n        for(char c : text){\\n            \\n            if(c == \\' \\'){\\n                mp[len].push_back(temp);\\n                temp=\"\";\\n                len = 0;\\n            }else{\\n                len+=1;\\n                c = tolower(c);\\n                temp+=c;\\n            }\\n        }\\n        mp[len].push_back(temp);\\n        string ans;\\n        for(auto it : mp){\\n            for(string s : it.second){\\n                ans+= s;\\n                ans+= \" \";\\n            }\\n        }\\n        ans.pop_back();\\n        \\n        ans[0] = toupper(ans[0]);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636654,
                "title": "c-what-is-the-difference-between-these-two-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] = text[0]+\\'a\\'-\\'A\\';        \\n        stringstream ss;\\n        ss << text;\\n        map<int, vector<string>> mp;\\n\\n        while (!ss.eof())\\n        {\\n            string t;\\n            ss >> t;\\n            mp[t.length()].push_back(t);\\n        }\\n        \\n        string tex;\\n        for(auto m:mp)\\n        {\\n            for(auto it : m.second)\\n//                tex = tex + it + \" \";   ///Memory Limit Exceeded\\n\\t\\t\\t\\ttex += it + \" \"; ///Accepted\\n        }\\n        tex.pop_back();\\n        tex[0]=tex[0]+\\'A\\' - \\'a\\';\\n        return tex;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] = text[0]+\\'a\\'-\\'A\\';        \\n        stringstream ss;\\n        ss << text;\\n        map<int, vector<string>> mp;\\n\\n        while (!ss.eof())\\n        {\\n            string t;\\n            ss >> t;\\n            mp[t.length()].push_back(t);\\n        }\\n        \\n        string tex;\\n        for(auto m:mp)\\n        {\\n            for(auto it : m.second)\\n//                tex = tex + it + \" \";   ///Memory Limit Exceeded\\n\\t\\t\\t\\ttex += it + \" \"; ///Accepted\\n        }\\n        tex.pop_back();\\n        tex[0]=tex[0]+\\'A\\' - \\'a\\';\\n        return tex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636554,
                "title": "c-linq-2-lines",
                "content": "```\\npublic string ArrangeWords(string text)\\n{\\n\\tvar s = String.Join(\" \", text.ToLower().Split(\\' \\').ToList().OrderBy(x => x.Length));\\n\\treturn char.ToUpper(s[0]) + s.Substring(1);\\n}\\n```\\nTechnically it could be done in one line by copying the whole expression twice instead of using a variable, but that would make all the split, join, sort operations run twice.\\n",
                "solutionTags": [],
                "code": "```\\npublic string ArrangeWords(string text)\\n{\\n\\tvar s = String.Join(\" \", text.ToLower().Split(\\' \\').ToList().OrderBy(x => x.Length));\\n\\treturn char.ToUpper(s[0]) + s.Substring(1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636542,
                "title": "c-solution-split-custom-sort-combine",
                "content": "C++\\n\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<string> v;\\n        string res = \"\";\\n        \\n        text[0] = tolower(text[0]);\\n        int first = 0;\\n        for (int i = 0; i < text.size(); i++) {\\n            if (text[i] == \\' \\') {\\n                v.push_back(text.substr(first, i - first));\\n                first = i + 1;\\n            } else if (i == text.size() - 1)\\n                v.push_back(text.substr(first, i - first + 1));\\n        }\\n        \\n        std::stable_sort(std::begin(v), std::end(v),\\n                 [](const auto &s1, const auto &s2) {\\n                     return s1.length() < s2.length();\\n                 });\\n        \\n        for (int i = 0; i < v.size(); i++) {\\n            res += v[i];\\n            if (i == 0)\\n                res[0] = toupper(res[0]);\\n            if (i != v.size() - 1)\\n                res += \" \";\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<string> v;\\n        string res = \"\";\\n        \\n        text[0] = tolower(text[0]);\\n        int first = 0;\\n        for (int i = 0; i < text.size(); i++) {\\n            if (text[i] == \\' \\') {\\n                v.push_back(text.substr(first, i - first));\\n                first = i + 1;\\n            } else if (i == text.size() - 1)\\n                v.push_back(text.substr(first, i - first + 1));\\n        }\\n        \\n        std::stable_sort(std::begin(v), std::end(v),\\n                 [](const auto &s1, const auto &s2) {\\n                     return s1.length() < s2.length();\\n                 });\\n        \\n        for (int i = 0; i < v.size(); i++) {\\n            res += v[i];\\n            if (i == 0)\\n                res[0] = toupper(res[0]);\\n            if (i != v.size() - 1)\\n                res += \" \";\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636340,
                "title": "stringstream-easy-solution-o-n",
                "content": "```\\ntext[0] = tolower(text[0]);\\nstringstream ss{text};\\nstring token;\\nint maxLen(0);\\nwhile(getline(ss, token, \\' \\')) {\\n    maxLen = max(maxLen, (int)token.size());\\n}\\nvector<vector<string>> arr(maxLen + 1);\\nstringstream ss1{text};\\nwhile(getline(ss1, token, \\' \\')) {\\n    arr[token.size()].push_back(token);\\n}\\nstring ans;\\nfor(int i = 0; i < arr.size(); i++) {\\n    if(arr[i].size()) {\\n        for(int j = 0; j < arr[i].size(); j++) {\\n            ans += arr[i][j];\\n            ans += \\' \\';\\n        }\\n    }\\n}\\nans.pop_back();\\nans[0] = toupper(ans[0]);\\nreturn ans;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntext[0] = tolower(text[0]);\\nstringstream ss{text};\\nstring token;\\nint maxLen(0);\\nwhile(getline(ss, token, \\' \\')) {\\n    maxLen = max(maxLen, (int)token.size());\\n}\\nvector<vector<string>> arr(maxLen + 1);\\nstringstream ss1{text};\\nwhile(getline(ss1, token, \\' \\')) {\\n    arr[token.size()].push_back(token);\\n}\\nstring ans;\\nfor(int i = 0; i < arr.size(); i++) {\\n    if(arr[i].size()) {\\n        for(int j = 0; j < arr[i].size(); j++) {\\n            ans += arr[i][j];\\n            ans += \\' \\';\\n        }\\n    }\\n}\\nans.pop_back();\\nans[0] = toupper(ans[0]);\\nreturn ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636309,
                "title": "c-why-my-compare-is-not-working-properly",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(string &s1, string &s2){\\n        return s1.size() < s2.size();\\n    }\\n    \\n    string arrangeWords(string text) {\\n        if(text == \"\") return text;\\n        \\n        text[0] = tolower(text[0]);\\n        \\n        stringstream s(text);\\n        string temp;\\n        vector<string> tokens;\\n        while(getline(s,temp,\\' \\')) tokens.push_back(temp);\\n        \\n        \\n        if(tokens.size() == 1){\\n            tokens[0][0] = toupper(tokens[0][0]);\\n            return tokens[0];\\n        }\\n        \\n        sort(tokens.begin(),tokens.end(), compare);\\n        //sort(tokens,tokens.size());\\n        \\n        tokens[0][0] = toupper(tokens[0][0]);\\n        string ans = \"\";\\n        for(string ss: tokens) ans += ss + \" \";\\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(string &s1, string &s2){\\n        return s1.size() < s2.size();\\n    }\\n    \\n    string arrangeWords(string text) {\\n        if(text == \"\") return text;\\n        \\n        text[0] = tolower(text[0]);\\n        \\n        stringstream s(text);\\n        string temp;\\n        vector<string> tokens;\\n        while(getline(s,temp,\\' \\')) tokens.push_back(temp);\\n        \\n        \\n        if(tokens.size() == 1){\\n            tokens[0][0] = toupper(tokens[0][0]);\\n            return tokens[0];\\n        }\\n        \\n        sort(tokens.begin(),tokens.end(), compare);\\n        //sort(tokens,tokens.size());\\n        \\n        tokens[0][0] = toupper(tokens[0][0]);\\n        string ans = \"\";\\n        for(string ss: tokens) ans += ss + \" \";\\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636308,
                "title": "python-4-line-solution-easy-to-understand",
                "content": "```\\ndef arrangeWords(self, text: str) -> str:\\n        lst = text.split(\\' \\')\\n        lst = sorted(lst, key=len) \\n        s = \\' \\'.join(lst)\\n        return s.capitalize() \\n```",
                "solutionTags": [],
                "code": "```\\ndef arrangeWords(self, text: str) -> str:\\n        lst = text.split(\\' \\')\\n        lst = sorted(lst, key=len) \\n        s = \\' \\'.join(lst)\\n        return s.capitalize() \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 636289,
                "title": "java-4-lines-self-explanatory-clean-and-concise",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] sa= text.toLowerCase().split(\" \");\\n        Arrays.sort(sa, (a, b) -> a.length()-b.length());\\n        sa[0]=Character.toUpperCase(sa[0].charAt(0))+sa[0].substring(1);\\n        return String.join(\" \", sa);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] sa= text.toLowerCase().split(\" \");\\n        Arrays.sort(sa, (a, b) -> a.length()-b.length());\\n        sa[0]=Character.toUpperCase(sa[0].charAt(0))+sa[0].substring(1);\\n        return String.join(\" \", sa);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043744,
                "title": "java-solution-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n*log(n))\\n\\n# Code\\n```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        text = text.replace(text.charAt(0)+\"\", (char)(text.charAt(0)+32)+\"\");\\n\\n        String[] arr = text.split(\" \");\\n        Arrays.sort(arr, new Comparator<String>(){\\n            public int compare(String s1, String s2){\\n                return Integer.compare(s1.length(), s2.length());\\n            }\\n        });\\n\\n        StringBuilder str = new StringBuilder(arr[0]);\\n\\n        for(int i = 1; i < arr.length; i++)\\n            str.append(\" \"+arr[i]);\\n\\n        text = (char)(str.charAt(0)-32)+str.substring(1, str.length());\\n\\n        return text;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        text = text.replace(text.charAt(0)+\"\", (char)(text.charAt(0)+32)+\"\");\\n\\n        String[] arr = text.split(\" \");\\n        Arrays.sort(arr, new Comparator<String>(){\\n            public int compare(String s1, String s2){\\n                return Integer.compare(s1.length(), s2.length());\\n            }\\n        });\\n\\n        StringBuilder str = new StringBuilder(arr[0]);\\n\\n        for(int i = 1; i < arr.length; i++)\\n            str.append(\" \"+arr[i]);\\n\\n        text = (char)(str.charAt(0)-32)+str.substring(1, str.length());\\n\\n        return text;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013738,
                "title": "easiest-c-approach-vector-pair-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int,pair<int,string>>> x;\\n        string s=\"\";\\n        text[0]=tolower(text[0]);\\n        int i;\\n        for(i=0;i<text.size();i++){\\n            if(text[i]==\\' \\'){\\n                x.push_back({s.size(),{i-s.size(),s}});\\n                s=\"\";\\n            } else{\\n                s+=text[i];\\n            } \\n        }\\n        x.push_back({s.size(),{i-s.size(),s}});\\n        sort(x.begin(),x.end());\\n        string ans=\"\";\\n        for(i=0;i<x.size();i++){\\n            ans+=x[i].second.second+\" \";\\n        }\\n        ans[0]=toupper(ans[0]);\\n        ans=ans.substr(0,ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int,pair<int,string>>> x;\\n        string s=\"\";\\n        text[0]=tolower(text[0]);\\n        int i;\\n        for(i=0;i<text.size();i++){\\n            if(text[i]==\\' \\'){\\n                x.push_back({s.size(),{i-s.size(),s}});\\n                s=\"\";\\n            } else{\\n                s+=text[i];\\n            } \\n        }\\n        x.push_back({s.size(),{i-s.size(),s}});\\n        sort(x.begin(),x.end());\\n        string ans=\"\";\\n        for(i=0;i<x.size();i++){\\n            ans+=x[i].second.second+\" \";\\n        }\\n        ans[0]=toupper(ans[0]);\\n        ans=ans.substr(0,ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777037,
                "title": "sort-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<pair<int, int>, string>> v;\\n\\n        string w;\\n        int n = text.size(), cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            if(text[i] == \\' \\') {\\n                w[0] = tolower(w[0]);\\n                v.push_back({{cnt, i}, w});\\n                w = \"\";\\n                cnt = 0;\\n            }\\n            else {\\n                w += text[i];\\n                cnt++;\\n            }\\n        }\\n        v.push_back({{cnt, n}, w});\\n        sort(v.begin(), v.end());\\n\\n        string ans;\\n        for(auto i : v) {\\n            ans += i.second + \" \";\\n        }\\n        ans[0] = toupper(ans[0]);\\n        ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<pair<int, int>, string>> v;\\n\\n        string w;\\n        int n = text.size(), cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            if(text[i] == \\' \\') {\\n                w[0] = tolower(w[0]);\\n                v.push_back({{cnt, i}, w});\\n                w = \"\";\\n                cnt = 0;\\n            }\\n            else {\\n                w += text[i];\\n                cnt++;\\n            }\\n        }\\n        v.push_back({{cnt, n}, w});\\n        sort(v.begin(), v.end());\\n\\n        string ans;\\n        for(auto i : v) {\\n            ans += i.second + \" \";\\n        }\\n        ans[0] = toupper(ans[0]);\\n        ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546066,
                "title": "c-easy-solution-multimap-explained",
                "content": "# Intuition\\nStore different words(string) in Sorted order and then put it back in same fashion.\\n\\n# Approach\\nMultimap is data structure used. Elements are stored in ascending order of keys with multi values (Diff strings with same length).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string t) {\\n        multimap<int,string> mp;\\n        string s=\"\";\\n        //Convert first character tp LowerCase\\n        t[0] = \\'a\\' + (t[0] -\\'A\\');\\n\\n        //Insert words into map to sort and order them\\n        for(int i=0;i<t.size();i++)\\n        {\\n           if(t[i]==\\' \\')\\n           {\\n               mp.insert({s.size(),s});\\n               s=\"\";\\n           }\\n           else\\n             s+=t[i];\\n        }\\n        mp.insert({s.size(),s});\\n        s=\"\";\\n\\n        //Form new string according to map\\n        for(auto it : mp){\\n            string s2 = it.second;\\n            s += s2;\\n            s += \" \";\\n        }\\n        //Remove last space\\n        s.pop_back();\\n\\n        //Convert first character to UpperCase\\n        s[0] = \\'A\\' + (s[0] -\\'a\\');\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string t) {\\n        multimap<int,string> mp;\\n        string s=\"\";\\n        //Convert first character tp LowerCase\\n        t[0] = \\'a\\' + (t[0] -\\'A\\');\\n\\n        //Insert words into map to sort and order them\\n        for(int i=0;i<t.size();i++)\\n        {\\n           if(t[i]==\\' \\')\\n           {\\n               mp.insert({s.size(),s});\\n               s=\"\";\\n           }\\n           else\\n             s+=t[i];\\n        }\\n        mp.insert({s.size(),s});\\n        s=\"\";\\n\\n        //Form new string according to map\\n        for(auto it : mp){\\n            string s2 = it.second;\\n            s += s2;\\n            s += \" \";\\n        }\\n        //Remove last space\\n        s.pop_back();\\n\\n        //Convert first character to UpperCase\\n        s[0] = \\'A\\' + (s[0] -\\'a\\');\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493806,
                "title": "heavily-commented-only-stl-no-stringstream",
                "content": "# Intuition\\nNo stringstream just use of basic stl \\n# Approach\\n - create a pair of int (to store size of each string) and pair of\\n  int (to store index to keep relativity of same size string) and string  \\n\\n---\\n\\n  Example : - \"To be or not to be\"\\n\\n- for just according to size we would have taken \\n    vector pair<int(size),string>  \\n \\n ---> after sorting = To to be be or not   \\n\\n---\\n\\n\\n - but since we want Store each word , size  and their relative position.\\n    So,  vector<pair<int,pair<int,string>>> \\n\\n ---> after sorting = To be or to be not  \\n\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int,pair<int,string>>> v;\\n        string ans=\"\";\\n        for(int i=0;i<text.size();i++) // traversing through the text string\\n        {\\n            string temp=\"\"; // to get current letter of text before space \\n            while(!isspace(text[i])&&i<text.size()) // while we don\\'t get any space \\n            {\\n                temp+=text[i];//keep adding alphabets to our temp string\\n                i++; // keep increasing while we don;t get space or last of text\\n            }\\n            int siz=temp.size(); // get the size of current string that has come before space so that we can arrange in increasing order\\n            v.push_back({siz,{i,temp}}); // push the size and index and current string into vector\\n            temp.clear();// clear the current string as we have found space so that next string get added\\n        }\\n        sort(v.begin(),v.end());// sorted according to size and relative positon\\n       for(auto x:v)\\n        {        \\n          ans+=x.second.second;// add the string stored in our vector which is pair<int, pair <int , STRING >> (x.second.second)\\n          ans+=\" \"; // add space after each letter added\\n        }\\n        ans.pop_back();// remove the last space that we added in our answer text\\n        for(int i=0;i<ans.size();i++)\\n        {\\n          if(i==0) ans[i]=toupper(ans[i]);// change first char to uppercase\\n          else ans[i]=tolower(ans[i]);// rest to lower \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int,pair<int,string>>> v;\\n        string ans=\"\";\\n        for(int i=0;i<text.size();i++) // traversing through the text string\\n        {\\n            string temp=\"\"; // to get current letter of text before space \\n            while(!isspace(text[i])&&i<text.size()) // while we don\\'t get any space \\n            {\\n                temp+=text[i];//keep adding alphabets to our temp string\\n                i++; // keep increasing while we don;t get space or last of text\\n            }\\n            int siz=temp.size(); // get the size of current string that has come before space so that we can arrange in increasing order\\n            v.push_back({siz,{i,temp}}); // push the size and index and current string into vector\\n            temp.clear();// clear the current string as we have found space so that next string get added\\n        }\\n        sort(v.begin(),v.end());// sorted according to size and relative positon\\n       for(auto x:v)\\n        {        \\n          ans+=x.second.second;// add the string stored in our vector which is pair<int, pair <int , STRING >> (x.second.second)\\n          ans+=\" \"; // add space after each letter added\\n        }\\n        ans.pop_back();// remove the last space that we added in our answer text\\n        for(int i=0;i<ans.size();i++)\\n        {\\n          if(i==0) ans[i]=toupper(ans[i]);// change first char to uppercase\\n          else ans[i]=tolower(ans[i]);// rest to lower \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165794,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] = tolower(text[0]);\\n        stringstream ss(text);\\n        string buf;\\n        map<int,string> mymap;\\n        while(ss >> buf) \\n            mymap[buf.size()] += buf + \" \";\\n        \\n        string tmp = string();\\n        for(auto it : mymap)\\n            tmp += it.second;\\n        tmp[0] = toupper(tmp[0]);\\n        tmp.pop_back();\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] = tolower(text[0]);\\n        stringstream ss(text);\\n        string buf;\\n        map<int,string> mymap;\\n        while(ss >> buf) \\n            mymap[buf.size()] += buf + \" \";\\n        \\n        string tmp = string();\\n        for(auto it : mymap)\\n            tmp += it.second;\\n        tmp[0] = toupper(tmp[0]);\\n        tmp.pop_back();\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164262,
                "title": "easy-mapping-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        string res=\"\";\\n        map<int,vector<string>>mp;\\n        int start;\\n        for(int i=0;i<text.length();i++){\\n            start=i;\\n            while(i<text.length() && text[i]!=\\' \\'){\\n                i++;\\n            }\\n            mp[i-start].push_back(text.substr(start,i-start));\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            for(auto x:it->second){\\n                res+=x;\\n                res+=\\' \\';\\n            }\\n        }\\n        res.pop_back();\\n        if(res[0]>=97 && res[0]<=122)res[0]-=32;\\n        for(int i=1;i<res.length();i++){\\n            if(res[i]!=\\' \\' && res[i]>=65 && res[i]<=90)res[i]+=32;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        string res=\"\";\\n        map<int,vector<string>>mp;\\n        int start;\\n        for(int i=0;i<text.length();i++){\\n            start=i;\\n            while(i<text.length() && text[i]!=\\' \\'){\\n                i++;\\n            }\\n            mp[i-start].push_back(text.substr(start,i-start));\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            for(auto x:it->second){\\n                res+=x;\\n                res+=\\' \\';\\n            }\\n        }\\n        res.pop_back();\\n        if(res[0]>=97 && res[0]<=122)res[0]-=32;\\n        for(int i=1;i<res.length();i++){\\n            if(res[i]!=\\' \\' && res[i]>=65 && res[i]<=90)res[i]+=32;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815090,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n  Method 1 $$O(n)$$\\n  Method 2 $$O(n^2)$$\\n\\n- Space complexity:\\n  Method 1 $$O(n)$$\\n  Method 2 $$O(1)$$\\n# Code\\n```\\n/**\\n * @param {string} text\\n * @return {string}\\n */\\n// Method 1\\nvar arrangeWords = function(text) {\\n   let Obj = {}\\n   let count = 0\\n   let str = \"\"\\n   text = text.toLocaleLowerCase()\\n   for (let i = 0; i <= text.length; i++) {\\n      if (text[i] !== \" \" && i <= text.length - 1) {\\n         count++\\n         str += text[i]\\n      }\\n      else {\\n         if (Obj[count])\\n            Obj[count] +=\" \"+ str\\n         else Obj[count] = str\\n         count = 0\\n         str = \"\"\\n      }\\n   }// Sorting the string according to their length\\n\\n   let newstr = \\'\\'\\n   for (let str in Obj) {\\n      newstr += Obj[str] + \" \"\\n   } // creating new string\\n\\n   text = newstr[0].toUpperCase()\\n   for (let i = 1; i < newstr.length - 1; i++) {\\n      text += newstr[i]\\n   }\\n   return text\\n\\n\\n//Method 2\\n   text = text.toLowerCase().split(\" \").sort((a,b)=> a.length - b.length).join(\" \")\\n   text = text[0].toUpperCase() + text.slice(1)\\n   return text\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @return {string}\\n */\\n// Method 1\\nvar arrangeWords = function(text) {\\n   let Obj = {}\\n   let count = 0\\n   let str = \"\"\\n   text = text.toLocaleLowerCase()\\n   for (let i = 0; i <= text.length; i++) {\\n      if (text[i] !== \" \" && i <= text.length - 1) {\\n         count++\\n         str += text[i]\\n      }\\n      else {\\n         if (Obj[count])\\n            Obj[count] +=\" \"+ str\\n         else Obj[count] = str\\n         count = 0\\n         str = \"\"\\n      }\\n   }// Sorting the string according to their length\\n\\n   let newstr = \\'\\'\\n   for (let str in Obj) {\\n      newstr += Obj[str] + \" \"\\n   } // creating new string\\n\\n   text = newstr[0].toUpperCase()\\n   for (let i = 1; i < newstr.length - 1; i++) {\\n      text += newstr[i]\\n   }\\n   return text\\n\\n\\n//Method 2\\n   text = text.toLowerCase().split(\" \").sort((a,b)=> a.length - b.length).join(\" \")\\n   text = text[0].toUpperCase() + text.slice(1)\\n   return text\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2608344,
                "title": "c-solution-using-stringstream-and-sorting",
                "content": "**Solution:** Using stringstream\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        stringstream take(text);\\n        vector<pair<string,int>> arr;\\n        string ans,word;\\n        int cnt = 0;\\n        while(take>>word)arr.push_back({word,cnt++});\\n        sort(arr.begin(),arr.end(),[&](auto &a,auto &b){\\n            if(a.first.size() == b.first.size())return a.second <= b.second;\\n            return a.first.size() <= b.first.size();\\n        });\\n        for(auto ele:arr){\\n            transform(ele.first.begin(),ele.first.end(), ele.first.begin(), ::tolower);\\n            ans+=ele.first + \" \";\\n        }\\n        if(ans[0]>=\\'a\\' and ans[0] <= \\'z\\')ans[0] -=32;\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution 2:** Using stable sorting library function\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int, string>> arr;\\n        string res;\\n        for (int i = 0; i < text.size(); i++) {\\n            string word;\\n            while (isalpha(text[i])) {\\n                word += tolower(text[i]);\\n                i++;\\n            }\\n            arr.push_back({word.size(), word});\\n        }\\n        stable_sort(arr.begin(),arr.end(), [](auto &a,auto &b) {\\n            return (a.first < b.first);\\n        });\\n        for (auto ele:arr)res +=ele.second + \" \";\\n        res.pop_back();\\n        res[0] = toupper(res[0]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        stringstream take(text);\\n        vector<pair<string,int>> arr;\\n        string ans,word;\\n        int cnt = 0;\\n        while(take>>word)arr.push_back({word,cnt++});\\n        sort(arr.begin(),arr.end(),[&](auto &a,auto &b){\\n            if(a.first.size() == b.first.size())return a.second <= b.second;\\n            return a.first.size() <= b.first.size();\\n        });\\n        for(auto ele:arr){\\n            transform(ele.first.begin(),ele.first.end(), ele.first.begin(), ::tolower);\\n            ans+=ele.first + \" \";\\n        }\\n        if(ans[0]>=\\'a\\' and ans[0] <= \\'z\\')ans[0] -=32;\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<int, string>> arr;\\n        string res;\\n        for (int i = 0; i < text.size(); i++) {\\n            string word;\\n            while (isalpha(text[i])) {\\n                word += tolower(text[i]);\\n                i++;\\n            }\\n            arr.push_back({word.size(), word});\\n        }\\n        stable_sort(arr.begin(),arr.end(), [](auto &a,auto &b) {\\n            return (a.first < b.first);\\n        });\\n        for (auto ele:arr)res +=ele.second + \" \";\\n        res.pop_back();\\n        res[0] = toupper(res[0]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451558,
                "title": "c-ordered-map-stringstream",
                "content": "Algorithm-\\n1. Create an ordered map with integer as key and vector of strings as its pair, the key will store the length of the words and pair will contain the original ordering of the words in given string if words have same length\\n2. Break the sentence in words using stringstream class in c++\\n3. If the first character of word is capital make it small by adding 32 to it\\n4. Store the word in word length key of map\\n5. Then iterate the map and add all words to answer\\n6. Check if ans[0] is small alphabet, then subtract 32 to it to make it capital\\n7. Return ans\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        stringstream ss(text);\\n        string word;\\n        map<int, vector<string>> mp;\\n        while(ss >> word){\\n            if(word[0] < 92){\\n                word[0] += 32;\\n            }\\n            mp[word.length()].push_back(word);\\n        }\\n        \\n        string ans = \"\";\\n        \\n        for(auto it: mp){\\n            vector<string> v = it.second;\\n            for(string s: v){\\n                ans += s + \" \";\\n            }\\n        }\\n        \\n        ans.pop_back();\\n        if(ans[0] > 96){\\n            ans[0] -= 32;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        stringstream ss(text);\\n        string word;\\n        map<int, vector<string>> mp;\\n        while(ss >> word){\\n            if(word[0] < 92){\\n                word[0] += 32;\\n            }\\n            mp[word.length()].push_back(word);\\n        }\\n        \\n        string ans = \"\";\\n        \\n        for(auto it: mp){\\n            vector<string> v = it.second;\\n            for(string s: v){\\n                ans += s + \" \";\\n            }\\n        }\\n        \\n        ans.pop_back();\\n        if(ans[0] > 96){\\n            ans[0] -= 32;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278858,
                "title": "is-this-cheating",
                "content": "I kindda felt guilty writing this code. Felt like cheating. \\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        l=list(text.split(\" \"))\\n        l=sorted(l,key= lambda word: len(word))\\n        l=\\' \\'.join(l)\\n        return l.capitalize()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        l=list(text.split(\" \"))\\n        l=sorted(l,key= lambda word: len(word))\\n        l=\\' \\'.join(l)\\n        return l.capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202867,
                "title": "priority-queue-simple-solution-with-comments",
                "content": "* Split the words of the string\\n* add the words to priority queue with a custom comparator\\n* poll from the queue till it is empty\\n* capatalist the first words\\n* for rest the words convert to lowercase\\n* keep on appending the words\\n```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String str[]=text.split(\" \");\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((s1,s2)->str[s1].length()-str[s2].length()==0?s1-s2:str[s1].length()-str[s2].length());\\n        \\n//         add all the words to priority queue\\n        for(int i=0;i<str.length;i++){\\n            pq.add(i);\\n        }\\n        \\n//         define a string builder string with capacity equals length of the text\\n        StringBuilder ans=new StringBuilder(text.length());\\n//         i is used as a flag for the first word\\n        int i=0;\\n        while(!pq.isEmpty()){\\n            int temp=pq.poll();\\n//             capetalise the first word\\n           if(i==0){\\n                ans.append(str[temp].substring(0, 1).toUpperCase() + str[temp].substring(1));\\n               }\\n//             lowercase the other words\\n            else{\\n                ans.append(\" \");\\n                ans.append(str[temp].toLowerCase());\\n            }\\n            i++;\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String str[]=text.split(\" \");\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((s1,s2)->str[s1].length()-str[s2].length()==0?s1-s2:str[s1].length()-str[s2].length());\\n        \\n//         add all the words to priority queue\\n        for(int i=0;i<str.length;i++){\\n            pq.add(i);\\n        }\\n        \\n//         define a string builder string with capacity equals length of the text\\n        StringBuilder ans=new StringBuilder(text.length());\\n//         i is used as a flag for the first word\\n        int i=0;\\n        while(!pq.isEmpty()){\\n            int temp=pq.poll();\\n//             capetalise the first word\\n           if(i==0){\\n                ans.append(str[temp].substring(0, 1).toUpperCase() + str[temp].substring(1));\\n               }\\n//             lowercase the other words\\n            else{\\n                ans.append(\" \");\\n                ans.append(str[temp].toLowerCase());\\n            }\\n            i++;\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914363,
                "title": "one-liner-python",
                "content": "from functools import cmp_to_key\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(),key = cmp_to_key(lambda x,y: -1 if len(x)<len(y) else 1 if len(x)>len(y) else 0))).capitalize()",
                "solutionTags": [],
                "code": "from functools import cmp_to_key\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(),key = cmp_to_key(lambda x,y: -1 if len(x)<len(y) else 1 if len(x)>len(y) else 0))).capitalize()",
                "codeTag": "Java"
            },
            {
                "id": 1860558,
                "title": "rearrange-words-in-a-sentence-self",
                "content": "/* Here the idea is to use a priority queue that store the index of the word. and sort them based of length and then on index if same length. Once that is done we pull eachindex and then output the array*/\\n\\n```\\npublic String arrangeWords(String text) {\\n\\tString[] words = text.split(\" \");\\n\\tPriorityQueue<Integer> queue = new PriorityQueue<>((i1,i2) -> words[i1].length() != words[i2].length() ?\\nwords[i1].length()- words[i2].length() : i1-i2);\\n\\tfor (int i=0;i<words.length;i++) queue.offer(i);\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(int i=0;!queue.isEmpty();i++) {\\n\\t\\tresult.append(words[queue.poll()].toLowerCase());\\n\\t\\tif(i==0) result.setCharAt(0, Character.toUpperCase(result.charAt(0)));\\n\\t\\tif(i!=words.length-1) result.append(\" \");\\n\\t}\\n\\treturn result.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String arrangeWords(String text) {\\n\\tString[] words = text.split(\" \");\\n\\tPriorityQueue<Integer> queue = new PriorityQueue<>((i1,i2) -> words[i1].length() != words[i2].length() ?\\nwords[i1].length()- words[i2].length() : i1-i2);\\n\\tfor (int i=0;i<words.length;i++) queue.offer(i);\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(int i=0;!queue.isEmpty();i++) {\\n\\t\\tresult.append(words[queue.poll()].toLowerCase());\\n\\t\\tif(i==0) result.setCharAt(0, Character.toUpperCase(result.charAt(0)));\\n\\t\\tif(i!=words.length-1) result.append(\" \");\\n\\t}\\n\\treturn result.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848606,
                "title": "c-simple-code-with-comments-using-hash-map",
                "content": "```\\n// Space: O(N)\\n// Time: O(N)\\n\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] = tolower(text[0]); // convert 1st alphabet into lowercase\\n        // store all words in order mapping of int to array of strings. Example;\\n        // 2 -> on\\n        // 3 -> and\\n        // 4 -> keep, calm, code\\n        map<int, vector<string>> hashmap;\\n        for (int i = 0; i < text.size(); i++) {\\n            string cur = \"\";\\n            while (i < text.size() && text[i] != \\' \\')\\n                cur += text[i++];\\n            hashmap[cur.size()].push_back(cur);\\n        }\\n        \\n        // add all the letters one by one into resultant string\\n        string res = \"\";\\n        for (auto kv : hashmap)\\n            for (string s : kv.second)\\n                res += s + \" \";\\n        res[0] = toupper(res[0]); // convert 1st alphabet into uppercase\\n        res.pop_back(); // remove last added extra space\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Space: O(N)\\n// Time: O(N)\\n\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] = tolower(text[0]); // convert 1st alphabet into lowercase\\n        // store all words in order mapping of int to array of strings. Example;\\n        // 2 -> on\\n        // 3 -> and\\n        // 4 -> keep, calm, code\\n        map<int, vector<string>> hashmap;\\n        for (int i = 0; i < text.size(); i++) {\\n            string cur = \"\";\\n            while (i < text.size() && text[i] != \\' \\')\\n                cur += text[i++];\\n            hashmap[cur.size()].push_back(cur);\\n        }\\n        \\n        // add all the letters one by one into resultant string\\n        string res = \"\";\\n        for (auto kv : hashmap)\\n            for (string s : kv.second)\\n                res += s + \" \";\\n        res[0] = toupper(res[0]); // convert 1st alphabet into uppercase\\n        res.pop_back(); // remove last added extra space\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846465,
                "title": "python3-2-lines-o-nlogn",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        arr=sorted(text.lower().split(\\' \\'),key=len)\\n        return \\' \\'.join(arr).capitalize()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        arr=sorted(text.lower().split(\\' \\'),key=len)\\n        return \\' \\'.join(arr).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818695,
                "title": "java-easy-to-understand-fastest-using-sorting",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] res = text.split(\" \");\\n        Arrays.sort(res, (a, b)->Integer.compare(a.length(), b.length()));\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(Character.toUpperCase(res[0].charAt(0)));\\n        sb.append(res[0].substring(1,res[0].length()));\\n        for(int i = 1;i<res.length;i++){\\n            sb.append(\" \");\\n            sb.append(res[i].toLowerCase());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] res = text.split(\" \");\\n        Arrays.sort(res, (a, b)->Integer.compare(a.length(), b.length()));\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(Character.toUpperCase(res[0].charAt(0)));\\n        sb.append(res[0].substring(1,res[0].length()));\\n        for(int i = 1;i<res.length;i++){\\n            sb.append(\" \");\\n            sb.append(res[i].toLowerCase());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782757,
                "title": "c-leetcode-1451-easy-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string s) {\\n        map<int,vector<string>> m;\\n        s[0] = tolower(s[0]);s.push_back(\\' \\');\\n        string str = \"\",ans = \"\";\\n        for(char ch : s){\\n            if(ch!=\\' \\')str.push_back(ch);\\n            else{\\n                m[(int)str.size()].push_back(str);\\n                str = \"\";\\n            }\\n        }\\n        for(auto x : m){\\n            for(auto y : x.second){\\n                ans+=(y+\\' \\');                \\n            }\\n        }\\n        ans.pop_back();\\n        ans[0] = toupper(ans[0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string s) {\\n        map<int,vector<string>> m;\\n        s[0] = tolower(s[0]);s.push_back(\\' \\');\\n        string str = \"\",ans = \"\";\\n        for(char ch : s){\\n            if(ch!=\\' \\')str.push_back(ch);\\n            else{\\n                m[(int)str.size()].push_back(str);\\n                str = \"\";\\n            }\\n        }\\n        for(auto x : m){\\n            for(auto y : x.second){\\n                ans+=(y+\\' \\');                \\n            }\\n        }\\n        ans.pop_back();\\n        ans[0] = toupper(ans[0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702549,
                "title": "store-each-words-in-vector-and-then-sort-vector",
                "content": "```\\nstatic bool comp(pair<int,string>&a,pair<int,string>&b)\\n    {\\n        if(a.second.size()==b.second.size())\\n        {\\n            return a.first<b.first;\\n        }\\n        return a.second.size()<b.second.size();\\n    }\\n    string arrangeWords(string text) \\n    {\\n        text[0]=tolower(text[0]);\\n        text.append(\" \");\\n        int size=text.size();\\n        int index=1;\\n        vector<pair<int,string>>vec;\\n        string temp;\\n        for(int i=0;i<size;i++)\\n        {\\n            if(text[i]!=\\' \\')\\n            {\\n                temp+=(text[i]);\\n            }else{\\n                vec.push_back({index,temp});\\n                temp=\"\";\\n                index+=1;\\n            }\\n        }\\n        sort(vec.begin(),vec.end(),comp);\\n        temp=\"\";\\n        for(auto it:vec)\\n        {\\n            temp.append(it.second);\\n            temp.append(\" \");\\n        }\\n        temp.erase(temp.size()-1,1);\\n        temp[0]=toupper(temp[0]);\\n        return temp;\\n    }\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nstatic bool comp(pair<int,string>&a,pair<int,string>&b)\\n    {\\n        if(a.second.size()==b.second.size())\\n        {\\n            return a.first<b.first;\\n        }\\n        return a.second.size()<b.second.size();\\n    }\\n    string arrangeWords(string text) \\n    {\\n        text[0]=tolower(text[0]);\\n        text.append(\" \");\\n        int size=text.size();\\n        int index=1;\\n        vector<pair<int,string>>vec;\\n        string temp;\\n        for(int i=0;i<size;i++)\\n        {\\n            if(text[i]!=\\' \\')\\n            {\\n                temp+=(text[i]);\\n            }else{\\n                vec.push_back({index,temp});\\n                temp=\"\";\\n                index+=1;\\n            }\\n        }\\n        sort(vec.begin(),vec.end(),comp);\\n        temp=\"\";\\n        for(auto it:vec)\\n        {\\n            temp.append(it.second);\\n            temp.append(\" \");\\n        }\\n        temp.erase(temp.size()-1,1);\\n        temp[0]=toupper(temp[0]);\\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1691538,
                "title": "c-easy-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        string result=\"\";\\n        map<int,vector<string>>m;//ordered map keep the keys sorted so small keys will be printed first;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            string str=\"\";\\n            while(i<text.size() && text[i]!=\\' \\')\\n            {\\n                str+=tolower(text[i]);\\n                i++;\\n            }\\n            m[str.size()].push_back(str);\\n        }\\n        for(auto k:m)\\n        {\\n            for(auto k1:k.second)\\n            {\\n                result+=k1;//k1 is a vector\\n                 result+=\" \";\\n            }\\n           \\n        }\\n        result[0]=toupper(result[0]);//first letter to be uppercase\\n        result.pop_back();//popping the last space char \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        string result=\"\";\\n        map<int,vector<string>>m;//ordered map keep the keys sorted so small keys will be printed first;\\n        for(int i=0;i<text.size();i++)\\n        {\\n            string str=\"\";\\n            while(i<text.size() && text[i]!=\\' \\')\\n            {\\n                str+=tolower(text[i]);\\n                i++;\\n            }\\n            m[str.size()].push_back(str);\\n        }\\n        for(auto k:m)\\n        {\\n            for(auto k1:k.second)\\n            {\\n                result+=k1;//k1 is a vector\\n                 result+=\" \";\\n            }\\n           \\n        }\\n        result[0]=toupper(result[0]);//first letter to be uppercase\\n        result.pop_back();//popping the last space char \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686925,
                "title": "single-line-python-solution",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(),key=lambda x:len(x))).capitalize()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(),key=lambda x:len(x))).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645042,
                "title": "o-n-in-space-and-time-12ms",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        Map<Integer, StringBuilder> lenToWordsMap = new HashMap<>();\\n        String[] words = text.split(\" \"); //can do this as no other special chars are there except space\\n        words[0] = words[0].toLowerCase(); // to handle the first letter being uppercase\\n        int maxLength = 0;\\n        for(String word:words) {\\n            int currentWordLength = word.length();\\n            // first we check if we have already seen any words of same length before\\n            // if yes, then the current Word needs to be added after the previously seen\\n            // words. \\n            StringBuilder previousWordsOfSameLength = lenToWordsMap.get(currentWordLength);\\n            // if we haven\\'t seen this length before then simply add it to map\\n            if(null == previousWordsOfSameLength) {\\n                StringBuilder wordStr = new StringBuilder(word);\\n                lenToWordsMap.put(currentWordLength, wordStr);\\n            } else {\\n                previousWordsOfSameLength.append(\" \").append(word);\\n            }\\n            // we also track maximum word length in this loop\\n            maxLength = Math.max(maxLength, currentWordLength);\\n        }\\n        // now we need to simply take everything from map starting from smallest possible\\n        // length to maxLength\\n        StringBuilder result = new StringBuilder();\\n        for(int i = 0; i <= maxLength; i++) {\\n            StringBuilder stringPortion = lenToWordsMap.get(i);\\n            if(null != stringPortion) {\\n                result.append(stringPortion);\\n                if(i != maxLength) {\\n                    result.append(\" \");\\n                }\\n            }\\n        }\\n        char firstChar = result.charAt(0);\\n        result.setCharAt(0, Character.toUpperCase(firstChar));\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        Map<Integer, StringBuilder> lenToWordsMap = new HashMap<>();\\n        String[] words = text.split(\" \"); //can do this as no other special chars are there except space\\n        words[0] = words[0].toLowerCase(); // to handle the first letter being uppercase\\n        int maxLength = 0;\\n        for(String word:words) {\\n            int currentWordLength = word.length();\\n            // first we check if we have already seen any words of same length before\\n            // if yes, then the current Word needs to be added after the previously seen\\n            // words. \\n            StringBuilder previousWordsOfSameLength = lenToWordsMap.get(currentWordLength);\\n            // if we haven\\'t seen this length before then simply add it to map\\n            if(null == previousWordsOfSameLength) {\\n                StringBuilder wordStr = new StringBuilder(word);\\n                lenToWordsMap.put(currentWordLength, wordStr);\\n            } else {\\n                previousWordsOfSameLength.append(\" \").append(word);\\n            }\\n            // we also track maximum word length in this loop\\n            maxLength = Math.max(maxLength, currentWordLength);\\n        }\\n        // now we need to simply take everything from map starting from smallest possible\\n        // length to maxLength\\n        StringBuilder result = new StringBuilder();\\n        for(int i = 0; i <= maxLength; i++) {\\n            StringBuilder stringPortion = lenToWordsMap.get(i);\\n            if(null != stringPortion) {\\n                result.append(stringPortion);\\n                if(i != maxLength) {\\n                    result.append(\" \");\\n                }\\n            }\\n        }\\n        char firstChar = result.charAt(0);\\n        result.setCharAt(0, Character.toUpperCase(firstChar));\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617816,
                "title": "python-easy-one-line-solution",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \\' \\'.join(sorted(text.split(), key=len)).capitalize() \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \\' \\'.join(sorted(text.split(), key=len)).capitalize() \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545991,
                "title": "c-sort-function-faster-than-67",
                "content": "```\\nclass Solution {\\npublic:\\n    struct dattebayo {\\n        template<typename T, typename U>\\n        bool operator()(const pair<T,U> &fir, const pair<T,U> &sec) const {\\n            if(fir.first.size() == sec.first.size())\\n                return fir.second < sec.second;\\n            return fir.first.size() < sec.first.size();\\n        }\\n    };\\n        \\n    string arrangeWords(string s) {\\n        s[0] = tolower(s[0]);\\n        vector<pair<string,int>> v;\\n        stringstream ss(s);\\n        string word;\\n        int i = 1;\\n        while(ss >> word) {\\n            v.push_back({word, i});\\n            i++;\\n        }\\n        sort(begin(v), end(v), dattebayo());\\n        string temp = v[0].first;\\n        temp[0] = toupper(temp[0]);\\n        v[0].first = temp;\\n        string res;\\n        for(auto i: v) {\\n            res += i.first;\\n            res.push_back(\\' \\');\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct dattebayo {\\n        template<typename T, typename U>\\n        bool operator()(const pair<T,U> &fir, const pair<T,U> &sec) const {\\n            if(fir.first.size() == sec.first.size())\\n                return fir.second < sec.second;\\n            return fir.first.size() < sec.first.size();\\n        }\\n    };\\n        \\n    string arrangeWords(string s) {\\n        s[0] = tolower(s[0]);\\n        vector<pair<string,int>> v;\\n        stringstream ss(s);\\n        string word;\\n        int i = 1;\\n        while(ss >> word) {\\n            v.push_back({word, i});\\n            i++;\\n        }\\n        sort(begin(v), end(v), dattebayo());\\n        string temp = v[0].first;\\n        temp[0] = toupper(temp[0]);\\n        v[0].first = temp;\\n        string res;\\n        for(auto i: v) {\\n            res += i.first;\\n            res.push_back(\\' \\');\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541790,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        l=list(map(str,text.split()))\\n        l.sort(key = len)\\n        #print(l)\\n        x=\"\"\\n        for i in range(len(l)):\\n            if(i==0):\\n                a=l[0]\\n                #print(a)\\n                a=a.replace(a[0],a[0].upper())\\n                a=a.replace(a[1:],a[1:].lower())\\n                #print(a)\\n                x=x+a+\" \"\\n                #print(x)\\n                \\n            elif(i==(len(l)-1)):\\n                a=l[i]\\n                a=a.lower()\\n                x=x+a\\n                \\n            else:\\n                a=l[i]\\n                a=a.lower()\\n                x=x+a+\" \"\\n            #print(x)\\n        return(x)\\n```\\nif u liked the code plz...upvote...thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        l=list(map(str,text.split()))\\n        l.sort(key = len)\\n        #print(l)\\n        x=\"\"\\n        for i in range(len(l)):\\n            if(i==0):\\n                a=l[0]\\n                #print(a)\\n                a=a.replace(a[0],a[0].upper())\\n                a=a.replace(a[1:],a[1:].lower())\\n                #print(a)\\n                x=x+a+\" \"\\n                #print(x)\\n                \\n            elif(i==(len(l)-1)):\\n                a=l[i]\\n                a=a.lower()\\n                x=x+a\\n                \\n            else:\\n                a=l[i]\\n                a=a.lower()\\n                x=x+a+\" \"\\n            #print(x)\\n        return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519087,
                "title": "python-one-liner-23ms",
                "content": "```\\nclass Solution(object):\\n    def arrangeWords(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: str\\n        \"\"\"\\n        return \\' \\'.join(sorted(text.split(\\' \\'), key=lambda x:len(x))).capitalize()\\n    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrangeWords(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: str\\n        \"\"\"\\n        return \\' \\'.join(sorted(text.split(\\' \\'), key=lambda x:len(x))).capitalize()\\n    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1451499,
                "title": "java-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        //split the array in word\\n        String[] str = text.split(\" \");\\n        //sort the array on word length\\n        Arrays.sort(str, (a,b) -> a.length() - b.length());\\n\\n        StringBuilder sb = new StringBuilder();\\n        //capital first letter of first word\\n        sb.append(str[0].substring(0, 1).toUpperCase());\\n        sb.append(str[0].substring(1).toLowerCase());\\n        \\n        int i = 1;\\n        while( i < str.length){\\n            //add all the words in lowercase\\n            sb.append(\" \" + str[i].toLowerCase());\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        //split the array in word\\n        String[] str = text.split(\" \");\\n        //sort the array on word length\\n        Arrays.sort(str, (a,b) -> a.length() - b.length());\\n\\n        StringBuilder sb = new StringBuilder();\\n        //capital first letter of first word\\n        sb.append(str[0].substring(0, 1).toUpperCase());\\n        sb.append(str[0].substring(1).toLowerCase());\\n        \\n        int i = 1;\\n        while( i < str.length){\\n            //add all the words in lowercase\\n            sb.append(\" \" + str[i].toLowerCase());\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450527,
                "title": "java-5-lines",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n        words[0]=words[0].toLowerCase();\\n        Arrays.sort(words,(a,b)-> a.length()-b.length());\\n        words[0]=words[0].substring(0, 1).toUpperCase() + words[0].substring(1);\\n        return String.join(\" \", words);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n        words[0]=words[0].toLowerCase();\\n        Arrays.sort(words,(a,b)-> a.length()-b.length());\\n        words[0]=words[0].substring(0, 1).toUpperCase() + words[0].substring(1);\\n        return String.join(\" \", words);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381245,
                "title": "rearrange-words-in-a-sentence",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        map<int,vector<string>> help;\\n      text[0] = text[0]+32;\\n        for(int i = 0 ; i<text.length();i++)\\n        {\\n          string temp = \"\";\\n          int j = i;\\n          while(j<text.length() && text[j]!=\\' \\')\\n          {\\n            temp.push_back(text[j]);\\n            j++;\\n          }\\n          help[temp.length()].push_back(temp);\\n          i = j;\\n        }\\n      text.clear();\\n      for(auto it = help.begin();it!=help.end();it++)\\n      {\\n        vector<string> h = it->second;\\n        for(string s:h)\\n        {\\n          text+=s;\\n          text.push_back(\\' \\');\\n        }\\n      }\\n      text[0] = text[0]-32;\\n      text.pop_back();\\n      return text;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        map<int,vector<string>> help;\\n      text[0] = text[0]+32;\\n        for(int i = 0 ; i<text.length();i++)\\n        {\\n          string temp = \"\";\\n          int j = i;\\n          while(j<text.length() && text[j]!=\\' \\')\\n          {\\n            temp.push_back(text[j]);\\n            j++;\\n          }\\n          help[temp.length()].push_back(temp);\\n          i = j;\\n        }\\n      text.clear();\\n      for(auto it = help.begin();it!=help.end();it++)\\n      {\\n        vector<string> h = it->second;\\n        for(string s:h)\\n        {\\n          text+=s;\\n          text.push_back(\\' \\');\\n        }\\n      }\\n      text[0] = text[0]-32;\\n      text.pop_back();\\n      return text;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350948,
                "title": "c-10-lines-map",
                "content": "```\\n\\n```public:\\n    string arrangeWords(string text) {\\n     text[0]=(char)text[0]+32;\\n        map<int,string>mp;\\n        stringstream ss(text);\\n        string s,ans=\"\";\\n        while(ss>>s)\\n        {\\n            mp[s.length()]+=s+\\' \\';\\n        }\\n        for(auto i:mp)\\n        {\\n            ans=ans+i.second;\\n        }\\n        ans.pop_back();\\n        ans[0]=(char)ans[0]-32;\\n        return ans;   \\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248369,
                "title": "using-multimap",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text)\\n    {\\n        multimap<int,string>M;\\n\\n   \\n\\n    text[0] += 32;\\n\\n   \\n\\n    stringstream str(text);\\n\\n    string w;\\n\\n    while(str >> w)\\n\\n    {\\n\\n        M.insert(pair<int,string> (w.size(),w));\\n\\n    }\\n\\n    text = \"\";\\n\\n    for(auto x:M)\\n\\n        text += x.second + \" \";\\n\\n        text.pop_back();\\n\\n        if(text[0] >= \\'a\\' && text[0] <= \\'z\\')\\n\\n            text[0] -=  32;\\n        return text;\\n        \\n    }\\n};\\n``\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string arrangeWords(string text)\\n    {\\n        multimap<int,string>M;\\n\\n   \\n\\n    text[0] += 32;\\n\\n   \\n\\n    stringstream str(text);\\n\\n    string w;\\n\\n    while(str >> w)\\n\\n    {\\n\\n        M.insert(pair<int,string> (w.size(),w));\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1234075,
                "title": "java-easy-custom-comparator",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String arr[] = text.split(\" \");\\n       Arrays.sort(arr,new Comparator<>(){\\n         public int compare(String a,String b){\\n            return a.length()-b.length();\\n         }\\n       });\\n      \\n        arr[0] = Character.toUpperCase(arr[0].charAt(0)) + arr[0].substring(1,arr[0].length());\\n        \\n      StringBuilder sb = new StringBuilder();\\n       for(int i = 0; i<arr.length ; i++){\\n          if(i != 0 && Character.isUpperCase(arr[i].charAt(0))){\\n           sb.append(arr[i].toLowerCase()+\" \"); \\n          } \\n         else{\\n           sb.append(arr[i]+\" \");\\n         }\\n       }\\n       \\n       \\n      return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String arr[] = text.split(\" \");\\n       Arrays.sort(arr,new Comparator<>(){\\n         public int compare(String a,String b){\\n            return a.length()-b.length();\\n         }\\n       });\\n      \\n        arr[0] = Character.toUpperCase(arr[0].charAt(0)) + arr[0].substring(1,arr[0].length());\\n        \\n      StringBuilder sb = new StringBuilder();\\n       for(int i = 0; i<arr.length ; i++){\\n          if(i != 0 && Character.isUpperCase(arr[i].charAt(0))){\\n           sb.append(arr[i].toLowerCase()+\" \"); \\n          } \\n         else{\\n           sb.append(arr[i]+\" \");\\n         }\\n       }\\n       \\n       \\n      return sb.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222070,
                "title": "kotlin",
                "content": "```\\nfun arrangeWords(s: String) = s.split(\" \").sortedBy { it.length }.mapIndexed { i, w ->\\n    if (i == 0) \"${w[0].toUpperCase()}${w.drop(1)}\" else \"${w[0].toLowerCase()}${w.drop(1)}\"\\n}.joinToString(\" \")\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun arrangeWords(s: String) = s.split(\" \").sortedBy { it.length }.mapIndexed { i, w ->\\n    if (i == 0) \"${w[0].toUpperCase()}${w.drop(1)}\" else \"${w[0].toLowerCase()}${w.drop(1)}\"\\n}.joinToString(\" \")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163031,
                "title": "java-sorting-without-function",
                "content": "```\\nclass Solution {\\n      public static String arrangeWords(String text) {\\n\\n        StringBuilder stringBuilder = new StringBuilder();\\n\\n        String[] word = text.split(\" \");\\n\\n        for (int i=0; i<word.length; i++){\\n\\n            for (int j=0; j<word.length-1; j++){\\n\\n                if (word[j].length() > word[j+1].length()){\\n\\n                    String temp = word[j];\\n                    word[j] = word[j+1];\\n                    word[j+1] = temp;\\n                }\\n\\n            }\\n            \\n            \\n        }\\n\\n        for (int i=0; i<word.length; i++) {\\n\\n            if (i==0) {\\n                word[0] = word[0].substring(0, 1).toUpperCase() + word[0].substring(1);\\n                stringBuilder.append(word[0]);\\n            }else\\n                stringBuilder.append(\" \").append(word[i].toLowerCase());\\n\\n        }\\n\\n        return stringBuilder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n      public static String arrangeWords(String text) {\\n\\n        StringBuilder stringBuilder = new StringBuilder();\\n\\n        String[] word = text.split(\" \");\\n\\n        for (int i=0; i<word.length; i++){\\n\\n            for (int j=0; j<word.length-1; j++){\\n\\n                if (word[j].length() > word[j+1].length()){\\n\\n                    String temp = word[j];\\n                    word[j] = word[j+1];\\n                    word[j+1] = temp;\\n                }\\n\\n            }\\n            \\n            \\n        }\\n\\n        for (int i=0; i<word.length; i++) {\\n\\n            if (i==0) {\\n                word[0] = word[0].substring(0, 1).toUpperCase() + word[0].substring(1);\\n                stringBuilder.append(word[0]);\\n            }else\\n                stringBuilder.append(\" \").append(word[i].toLowerCase());\\n\\n        }\\n\\n        return stringBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080847,
                "title": "golang-solution-better-space-than-100",
                "content": "```\\nfunc arrangeWords(text string) string {\\n\\tsplit := strings.Split(text, \" \")\\n\\n\\tfor i := 1; i < len(split); i++ {\\n\\t\\tif len(split[i-1]) > len(split[i]) {\\n\\t\\t\\thasPut := false\\n\\t\\t\\tl := split[i]\\n\\t\\t\\tfor j := i - 1; j >= 0; j-- {\\n\\t\\t\\t\\tif (len(split[j]) <= len(l)) || \\n\\t\\t\\t\\t\\t\\t(j >= 1 && len(split[j-1]) <= len(l) && len(split[j]) >= len(l)) {\\n\\t\\t\\t\\t\\tsplit[j+1] = split[j]\\n\\t\\t\\t\\t\\tsplit[j] = l\\n\\t\\t\\t\\t\\thasPut = true\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsplit[j+1] = split[j]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif !hasPut {\\n\\t\\t\\t\\tsplit[0] = l\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tg := strings.Join(split, \" \")\\n\\tg = strings.ToLower(g)\\n\\tres := strings.ToUpper(string(g[0]))\\n\\tres += g[1:]\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc arrangeWords(text string) string {\\n\\tsplit := strings.Split(text, \" \")\\n\\n\\tfor i := 1; i < len(split); i++ {\\n\\t\\tif len(split[i-1]) > len(split[i]) {\\n\\t\\t\\thasPut := false\\n\\t\\t\\tl := split[i]\\n\\t\\t\\tfor j := i - 1; j >= 0; j-- {\\n\\t\\t\\t\\tif (len(split[j]) <= len(l)) || \\n\\t\\t\\t\\t\\t\\t(j >= 1 && len(split[j-1]) <= len(l) && len(split[j]) >= len(l)) {\\n\\t\\t\\t\\t\\tsplit[j+1] = split[j]\\n\\t\\t\\t\\t\\tsplit[j] = l\\n\\t\\t\\t\\t\\thasPut = true\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsplit[j+1] = split[j]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif !hasPut {\\n\\t\\t\\t\\tsplit[0] = l\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tg := strings.Join(split, \" \")\\n\\tg = strings.ToLower(g)\\n\\tres := strings.ToUpper(string(g[0]))\\n\\tres += g[1:]\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055961,
                "title": "my-simple-code-using-string-methods",
                "content": "*class Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        out = sorted(text.lower().split(), key = len)\\n        r = \\' \\'.join(out)\\n        return r.capitalize()*",
                "solutionTags": [
                    "Python3"
                ],
                "code": "*class Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        out = sorted(text.lower().split(), key = len)\\n        r = \\' \\'.join(out)\\n        return r.capitalize()*",
                "codeTag": "Java"
            },
            {
                "id": 1040401,
                "title": "java-linkedhashmap-solution-with-detailed-explanation",
                "content": "\\nclass Solution {\\n\\n    public String arrangeWords(String text) {\\n\\t\\n        LinkedHashMap<String, Integer> hm = new LinkedHashMap<String, Integer>();\\n        List<String> strList = new ArrayList<>();\\n        \\n        String[]  array = text.split(\" \");    // Split sentence into words\\n        \\n        String smallCase = array[0].substring(0,1).toLowerCase() + array[0].substring(1);   //convert 1st letter of 1st word in small letter.\\n        array[0] = smallCase;\\n        \\n        for(String s : array) {\\n            hm.put(s, s.length());     // add words and their length in map.\\n            strList.add(s);                // add words in list to sort\\n        } \\n\\t\\t\\n        Collections.sort(strList, (a,b)->hm.get(a) - hm.get(b));   // sort the list\\n        \\n        String retString = strList.get(0);\\n        String capString = retString.substring(0,1).toUpperCase() + retString.substring(1);  // convert 1st letter of the 1st sorted word in caps.\\n        \\n        for(int i = 1; i < strList.size(); i++){            \\n            capString = capString + \" \" + strList.get(i);               // Create the sentence.\\n        }        \\n        return capString;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public String arrangeWords(String text) {\\n\\t\\n        LinkedHashMap<String, Integer> hm = new LinkedHashMap<String, Integer>();\\n        List<String> strList = new ArrayList<>();\\n        \\n        String[]  array = text.split(\" \");    // Split sentence into words\\n        \\n        String smallCase = array[0].substring(0,1).toLowerCase() + array[0].substring(1);   //convert 1st letter of 1st word in small letter.\\n        array[0] = smallCase;\\n        \\n        for(String s : array) {\\n            hm.put(s, s.length());     // add words and their length in map.\\n            strList.add(s);                // add words in list to sort\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1028289,
                "title": "c-faster-99-19-memory-less-than-97-76",
                "content": "std::string arrangeWords(std::string text)\\n    {\\n        text[0] = std::tolower(text[0]);\\n        std::map<int, std::string> map;\\n        int counter = 0;\\n        std::string word;\\n        for (const auto& s : text)\\n        {\\n            if (s != \\' \\')\\n            {\\n                ++counter;\\n                word += s;\\n                continue;\\n            }\\n            auto it = map.find(counter);\\n            it == map.end() ? map[counter] = word : it->second += \\' \\' + word;\\n            counter = 0;\\n            word.clear();\\n        }\\n        auto it = map.find(counter);\\n        it == map.end() ? map[counter] = word : it->second += \\' \\' + word;\\n        \\n        it = map.begin();\\n        std::string res = it->second;\\n        res[0] = std::toupper(res[0]);\\n        while (++it != map.end())\\n        {\\n            res += \\' \\' + it->second;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "std::string arrangeWords(std::string text)\\n    {\\n        text[0] = std::tolower(text[0]);\\n        std::map<int, std::string> map;\\n        int counter = 0;\\n        std::string word;\\n        for (const auto& s : text)\\n        {\\n            if (s != \\' \\')\\n            {\\n                ++counter;\\n                word += s;\\n                continue;\\n            }\\n            auto it = map.find(counter);\\n            it == map.end() ? map[counter] = word : it->second += \\' \\' + word;\\n            counter = 0;\\n            word.clear();\\n        }\\n        auto it = map.find(counter);\\n        it == map.end() ? map[counter] = word : it->second += \\' \\' + word;\\n        \\n        it = map.begin();\\n        std::string res = it->second;\\n        res[0] = std::toupper(res[0]);\\n        while (++it != map.end())\\n        {\\n            res += \\' \\' + it->second;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1028248,
                "title": "java-simplest-solution",
                "content": "```\\n public String arrangeWords(String text) {\\n       String str = Arrays.stream(text.split(\" \"))\\n              .map(word -> word.toLowerCase())\\n              .sorted(Comparator.comparingInt(String::length))              \\n              .collect(Collectors.joining(\" \"));\\n        \\n        return str.substring(0, 1).toUpperCase() + str.substring(1);\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public String arrangeWords(String text) {\\n       String str = Arrays.stream(text.split(\" \"))\\n              .map(word -> word.toLowerCase())\\n              .sorted(Comparator.comparingInt(String::length))              \\n              .collect(Collectors.joining(\" \"));\\n        \\n        return str.substring(0, 1).toUpperCase() + str.substring(1);\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997653,
                "title": "java-priority-queue-with-explanation-runtime-o-nlogn-space-o-n",
                "content": "```\\nclass Solution {\\n    \\n    public String arrangeWords(String text) {\\n        String[] textArray = text.toLowerCase().split(\" \"); \\n        \\n        PriorityQueue<Word> queue = new PriorityQueue<>(\\n            textArray.length,  // queue size wouldn\\'t exceed the textArray\\'s length\\n            (a, b) -> a.val.length() == b.val.length()? a.index - b.index : a.val.length() - b.val.length()\\n            // if the two words are of the same length, sort them by their indices\\n        ); \\n        \\n        // populate the queue\\n        for (int i = 0; i < textArray.length; i++) { \\n            queue.add(new Word(textArray[i], i)); \\n        }\\n        \\n        StringBuilder sb = new StringBuilder(); \\n        \\n        while (!queue.isEmpty()) {\\n            String curr = queue.poll().val; \\n            sb.append(curr).append(\" \"); \\n        }\\n        \\n        sb.setCharAt(0, Character.toUpperCase(sb.charAt(0))); \\n        \\n        return sb.toString().trim();  // trim off the empty space at the very end\\n    }\\n    \\n    class Word {\\n        String val; \\n        int index; \\n        \\n        Word(String val, int index) {\\n            this.val = val; \\n            this.index = index;  // Adding an index to maintain the output order for words with same lengths\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public String arrangeWords(String text) {\\n        String[] textArray = text.toLowerCase().split(\" \"); \\n        \\n        PriorityQueue<Word> queue = new PriorityQueue<>(\\n            textArray.length,  // queue size wouldn\\'t exceed the textArray\\'s length\\n            (a, b) -> a.val.length() == b.val.length()? a.index - b.index : a.val.length() - b.val.length()\\n            // if the two words are of the same length, sort them by their indices\\n        ); \\n        \\n        // populate the queue\\n        for (int i = 0; i < textArray.length; i++) { \\n            queue.add(new Word(textArray[i], i)); \\n        }\\n        \\n        StringBuilder sb = new StringBuilder(); \\n        \\n        while (!queue.isEmpty()) {\\n            String curr = queue.poll().val; \\n            sb.append(curr).append(\" \"); \\n        }\\n        \\n        sb.setCharAt(0, Character.toUpperCase(sb.charAt(0))); \\n        \\n        return sb.toString().trim();  // trim off the empty space at the very end\\n    }\\n    \\n    class Word {\\n        String val; \\n        int index; \\n        \\n        Word(String val, int index) {\\n            this.val = val; \\n            this.index = index;  // Adding an index to maintain the output order for words with same lengths\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987796,
                "title": "java-beats-100-manually-parse-words-and-sort-indices",
                "content": "There are bunch of posts out there which solve this problem in very few lines of code. However, I present this solution to anyone who\\'d like to know how to solve it efficiently.\\n\\n- Figure out starting index and length of each word by parsing manually instead of using ```split()```.\\n- Sort these pairs and use the sorted order to construct the result.\\n- In case you didn\\'t know, ```c ^= 32``` toggles case of an alphabet.\\n\\n```\\n// 11 ms. 100%\\npublic String arrangeWords(String text) {\\n    char[] t = text.toCharArray(), s = new char[t.length];\\n    t[0] ^= 32;\\n    List<int[]> A = new ArrayList<>();\\n    for(int i = 0, beg = 0; i <= t.length; i++) if(i == t.length || t[i] == \\' \\') {\\n        A.add(new int[] {i - beg, beg});\\n        beg = i + 1;\\n    }\\n    Collections.sort(A, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    for(int i = 0, j = 0; i < A.size(); i++) {\\n        int len = A.get(i)[0], beg = A.get(i)[1];\\n        while(len-- > 0) s[j++] = t[beg++];\\n        if(i < A.size() - 1) s[j++] = \\' \\';\\n    }\\n    s[0] ^= 32;\\n    return new String(s);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```split()```\n```c ^= 32```\n```\\n// 11 ms. 100%\\npublic String arrangeWords(String text) {\\n    char[] t = text.toCharArray(), s = new char[t.length];\\n    t[0] ^= 32;\\n    List<int[]> A = new ArrayList<>();\\n    for(int i = 0, beg = 0; i <= t.length; i++) if(i == t.length || t[i] == \\' \\') {\\n        A.add(new int[] {i - beg, beg});\\n        beg = i + 1;\\n    }\\n    Collections.sort(A, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    for(int i = 0, j = 0; i < A.size(); i++) {\\n        int len = A.get(i)[0], beg = A.get(i)[1];\\n        while(len-- > 0) s[j++] = t[beg++];\\n        if(i < A.size() - 1) s[j++] = \\' \\';\\n    }\\n    s[0] ^= 32;\\n    return new String(s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945886,
                "title": "python3-using-hashtable-and-sorted",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        \\n        list_text = text.split(\\' \\')\\n        if len(list_text) == 1:\\n            return list_text[0]\\n        len_map = {}\\n        res_str = \\'\\'\\n        for idx,value in enumerate(list_text):\\n            len_map[idx] = [len(value),value]\\n        \\n        sorted_len = sorted(len_map.items(),key=lambda kv: (kv[1][0],kv[0]))\\n        \\n        n = len(sorted_len)\\n        \\n        for i in range(n):\\n            if i == 0:\\n                res_str +=sorted_len[i][1][1].capitalize() + \\' \\'\\n            elif i < n -1:\\n                res_str += sorted_len[i][1][1].lower() + \\' \\'\\n            else:\\n                res_str += sorted_len[i][1][1].lower()\\n        return res_str\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        \\n        list_text = text.split(\\' \\')\\n        if len(list_text) == 1:\\n            return list_text[0]\\n        len_map = {}\\n        res_str = \\'\\'\\n        for idx,value in enumerate(list_text):\\n            len_map[idx] = [len(value),value]\\n        \\n        sorted_len = sorted(len_map.items(),key=lambda kv: (kv[1][0],kv[0]))\\n        \\n        n = len(sorted_len)\\n        \\n        for i in range(n):\\n            if i == 0:\\n                res_str +=sorted_len[i][1][1].capitalize() + \\' \\'\\n            elif i < n -1:\\n                res_str += sorted_len[i][1][1].lower() + \\' \\'\\n            else:\\n                res_str += sorted_len[i][1][1].lower()\\n        return res_str\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 923581,
                "title": "java-easiest-solution-simple-treemap",
                "content": "```\\n    public String arrangeWords(String text) {\\n        \\n        if(text == null || text.length() == 0){\\n            return text;\\n        }\\n        \\n        //Calculate freqMap - key is the String size, value is ArrayList<String>\\n        //Instead of value being ArrayList - you can also use StringBuilder\\n        Map<Integer, List<String>> freqMap = new TreeMap<>();\\n        int length = 0;\\n        List<String> temp = null;\\n        for(String s: text.split(\" \")){\\n            length = s.length();\\n            if(freqMap.containsKey(length)){\\n                temp = freqMap.get(length);\\n            }else{\\n                temp = new ArrayList<>();\\n            }\\n            temp.add(s.toLowerCase());\\n            freqMap.put(length, temp); \\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        \\n        for(List strList : freqMap.values()){\\n            if(strList != null || strList.size() != 0){\\n                strList.forEach((str) -> {result.append(str).append(\" \");});\\n            }\\n        }\\n        \\n        //make the first char as capital letter\\n        String firstChar = Character.toString(result.charAt(0));\\n        result.replace(0,1, firstChar.toUpperCase());\\n        return result.substring(0, result.length()-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String arrangeWords(String text) {\\n        \\n        if(text == null || text.length() == 0){\\n            return text;\\n        }\\n        \\n        //Calculate freqMap - key is the String size, value is ArrayList<String>\\n        //Instead of value being ArrayList - you can also use StringBuilder\\n        Map<Integer, List<String>> freqMap = new TreeMap<>();\\n        int length = 0;\\n        List<String> temp = null;\\n        for(String s: text.split(\" \")){\\n            length = s.length();\\n            if(freqMap.containsKey(length)){\\n                temp = freqMap.get(length);\\n            }else{\\n                temp = new ArrayList<>();\\n            }\\n            temp.add(s.toLowerCase());\\n            freqMap.put(length, temp); \\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        \\n        for(List strList : freqMap.values()){\\n            if(strList != null || strList.size() != 0){\\n                strList.forEach((str) -> {result.append(str).append(\" \");});\\n            }\\n        }\\n        \\n        //make the first char as capital letter\\n        String firstChar = Character.toString(result.charAt(0));\\n        result.replace(0,1, firstChar.toUpperCase());\\n        return result.substring(0, result.length()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 911088,
                "title": "100-faster-logic-explained-c",
                "content": "/*\\nLOGIC IS USING HASHMAP..\\n\\njust get the string from the text and store in map corresponding to there lengths and  finally print.\\n\\n\\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        \\n        map<int,string>mp;\\n        for(int i=0;i<text.length();i++){\\n            \\n\\t\\t\\t   int j=i;\\n\\t\\t\\t\\twhile(i<text.length() and text[i]!=\\' \\')\\n\\t\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t\\tstring s=text.substr(j,i-j);\\n\\t\\t\\t\\ts[0]=tolower(s[0]);\\n\\t\\t\\t\\tint len=s.length();\\n\\t\\t\\t\\tmp[len]+=s+\\' \\';\\n\\n        }\\n        \\n        string ans=\"\";\\n        \\n\\t\\t\\tfor(auto it=mp.begin();it!=mp.end();it++)\\n\\t\\t\\t\\tans+=it->second;\\n\\n            \\n        ans[0]=toupper(ans[0]);\\n        int lenght=ans.length();\\n        return ans.substr(0,lenght-1);\\n   \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        \\n        map<int,string>mp;\\n        for(int i=0;i<text.length();i++){\\n            \\n\\t\\t\\t   int j=i;\\n\\t\\t\\t\\twhile(i<text.length() and text[i]!=\\' \\')\\n\\t\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t\\tstring s=text.substr(j,i-j);\\n\\t\\t\\t\\ts[0]=tolower(s[0]);\\n\\t\\t\\t\\tint len=s.length();\\n\\t\\t\\t\\tmp[len]+=s+\\' \\';\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 882460,
                "title": "java-easy-and-simple-solution",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tresult.add(words[i].toLowerCase());\\n\\t\\t}\\n\\t\\t// THIS CODE ORDER INCREASING ORDER BUT IF THE WORD LENGTH EQUAL TO EACH OTHER \\n\\t\\t// THEN KEEP THE ORDER SAME.\\n\\t\\tCollections.sort(result, Comparator.comparingInt(a -> a.length()));\\n\\t\\t\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < result.size(); i++) {\\n\\t\\t\\tsb.append(result.get(i) + \" \");\\n\\t\\t}\\n\\t\\tString firstChar = sb.charAt(0) + \"\";\\n\\t\\tString ch = firstChar.toUpperCase()+\"\";\\n\\t\\tsb.setCharAt(0, ch.charAt(0)); \\n\\n\\t\\t\\n\\t\\treturn sb.toString().strip();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] words = text.split(\" \");\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tresult.add(words[i].toLowerCase());\\n\\t\\t}\\n\\t\\t// THIS CODE ORDER INCREASING ORDER BUT IF THE WORD LENGTH EQUAL TO EACH OTHER \\n\\t\\t// THEN KEEP THE ORDER SAME.\\n\\t\\tCollections.sort(result, Comparator.comparingInt(a -> a.length()));\\n\\t\\t\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < result.size(); i++) {\\n\\t\\t\\tsb.append(result.get(i) + \" \");\\n\\t\\t}\\n\\t\\tString firstChar = sb.charAt(0) + \"\";\\n\\t\\tString ch = firstChar.toUpperCase()+\"\";\\n\\t\\tsb.setCharAt(0, ch.charAt(0)); \\n\\n\\t\\t\\n\\t\\treturn sb.toString().strip();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882172,
                "title": "java-treemap-solution",
                "content": "Not the most efficient solution by any means. I use a TreeMap (sorted map by length ascending) to get the lowest lengths first, but also preserve the original order through the lists of strings. \\n```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        // Map from length to word in orig order\\n        TreeMap<Integer, List<String>> map = new TreeMap<>();\\n        List<String> res = new LinkedList<>();\\n        \\n        String[] arr = text.toLowerCase().split(\" \");\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            int len = arr[i].length();\\n            List<String> list = map.getOrDefault(len, new LinkedList<>());\\n            list.add(arr[i]);\\n            map.put(len, list);\\n        }\\n        \\n        for(Map.Entry<Integer, List<String>> e : map.entrySet()){\\n            res.addAll(e.getValue());\\n        }\\n        \\n        String[] newStr = res.toArray(new String[res.size()]);\\n        newStr[0] = Character.toUpperCase(newStr[0].charAt(0)) + newStr[0].substring(1);\\n        return String.join(\" \", newStr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        // Map from length to word in orig order\\n        TreeMap<Integer, List<String>> map = new TreeMap<>();\\n        List<String> res = new LinkedList<>();\\n        \\n        String[] arr = text.toLowerCase().split(\" \");\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            int len = arr[i].length();\\n            List<String> list = map.getOrDefault(len, new LinkedList<>());\\n            list.add(arr[i]);\\n            map.put(len, list);\\n        }\\n        \\n        for(Map.Entry<Integer, List<String>> e : map.entrySet()){\\n            res.addAll(e.getValue());\\n        }\\n        \\n        String[] newStr = res.toArray(new String[res.size()]);\\n        newStr[0] = Character.toUpperCase(newStr[0].charAt(0)) + newStr[0].substring(1);\\n        return String.join(\" \", newStr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855759,
                "title": "simple-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n     String ar[]=text.split(\"[ ]+\");\\n    Arrays.sort(ar,(x,y)->Integer.compare(x.length(),y.length()));\\n    String x=\" \".join(\" \",ar).toLowerCase();\\n    return (Character.toUpperCase(x.charAt(0))+x.substring(1));\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n     String ar[]=text.split(\"[ ]+\");\\n    Arrays.sort(ar,(x,y)->Integer.compare(x.length(),y.length()));\\n    String x=\" \".join(\" \",ar).toLowerCase();\\n    return (Character.toUpperCase(x.charAt(0))+x.substring(1));\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842235,
                "title": "java-comparator-beats-97-of-other-java-submissions",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        if(text==null || text.length()==0) return text;\\n        String[] arr = text.split(\" \");\\n        char c = Character.toLowerCase(arr[0].charAt(0));\\n        arr[0] = String.valueOf(c).concat(arr[0].substring(1));\\n        \\n        Comparator<String> cmp = new Comparator<String>(){\\n            @Override\\n            public int compare(String s1,String s2){\\n                int l1 = s1.length();\\n                int l2 = s2.length();\\n                return Integer.compare(l1,l2);\\n            }\\n        };\\n        Arrays.sort(arr,cmp);\\n        c = Character.toUpperCase(arr[0].charAt(0));\\n        arr[0] = String.valueOf(c).concat(arr[0].substring(1));\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : arr){\\n            sb.append(\" \");\\n            sb.append(s);\\n        }\\n        return sb.toString().trim();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        if(text==null || text.length()==0) return text;\\n        String[] arr = text.split(\" \");\\n        char c = Character.toLowerCase(arr[0].charAt(0));\\n        arr[0] = String.valueOf(c).concat(arr[0].substring(1));\\n        \\n        Comparator<String> cmp = new Comparator<String>(){\\n            @Override\\n            public int compare(String s1,String s2){\\n                int l1 = s1.length();\\n                int l2 = s2.length();\\n                return Integer.compare(l1,l2);\\n            }\\n        };\\n        Arrays.sort(arr,cmp);\\n        c = Character.toUpperCase(arr[0].charAt(0));\\n        arr[0] = String.valueOf(c).concat(arr[0].substring(1));\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : arr){\\n            sb.append(\" \");\\n            sb.append(s);\\n        }\\n        return sb.toString().trim();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790716,
                "title": "python3-solution-easy",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        text = text.split(\\' \\')\\n        text.sort(key=len)\\n        text = \" \".join(text)\\n        return text.capitalize()\\n    \\nRuntime: 32 ms, faster than 97.07% of Python3 online submissions for Rearrange Words in a Sentence.\\nMemory Usage: 15.5 MB, less than 70.53% of Python3 online submissions for Rearrange Words in a Sentence.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        text = text.split(\\' \\')\\n        text.sort(key=len)\\n        text = \" \".join(text)\\n        return text.capitalize()\\n    \\nRuntime: 32 ms, faster than 97.07% of Python3 online submissions for Rearrange Words in a Sentence.\\nMemory Usage: 15.5 MB, less than 70.53% of Python3 online submissions for Rearrange Words in a Sentence.",
                "codeTag": "Java"
            },
            {
                "id": 787728,
                "title": "c-14-lines-solution-stable-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0]+=32;\\n        vector<string>words(1);\\n        for(int i=0;i<text.size();i++){\\n            if(text[i]==\\' \\'){words.push_back(\"\");}\\n            else{words.back().push_back(text[i]);}\\n        }\\n        stable_sort(words.begin(), words.end(), [](const auto& a, const auto& b){ return a.size() < b.size(); }); \\n        string result;\\n        for(int i=0;i<words.size()-1;i++){result += words[i];result.push_back(\\' \\');}\\n        result += words.back();\\n        result[0]-=32;\\n        return result;\\n    }\\n};\\n```\\nRuntime %60 and 128ms",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0]+=32;\\n        vector<string>words(1);\\n        for(int i=0;i<text.size();i++){\\n            if(text[i]==\\' \\'){words.push_back(\"\");}\\n            else{words.back().push_back(text[i]);}\\n        }\\n        stable_sort(words.begin(), words.end(), [](const auto& a, const auto& b){ return a.size() < b.size(); }); \\n        string result;\\n        for(int i=0;i<words.size()-1;i++){result += words[i];result.push_back(\\' \\');}\\n        result += words.back();\\n        result[0]-=32;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741231,
                "title": "javascript-1-line-solution",
                "content": "Array.sort is required to be stable in ES2019. Before that it varied by implementation. Generally, stability is a reasonable assumption these days. And we know it\\'s stable in the environment here, Node.js v14.3.0, and has been stable since Node.js v11.\\n\\n_Runtime: 104 ms, faster than 37.39% of JavaScript online submissions_\\n_Memory Usage: 40.1 MB, less than 80.19% of JavaScript online submissions_\\n\\n```javascript\\nconst arrangeWords = text =>\\n  text\\n    .toLowerCase()\\n    .split(\\' \\')\\n    .sort(({ length: a }, { length: b }) => a - b)\\n    .join(\\' \\')\\n    .replace(/^./, firstLetter => firstLetter.toUpperCase());\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst arrangeWords = text =>\\n  text\\n    .toLowerCase()\\n    .split(\\' \\')\\n    .sort(({ length: a }, { length: b }) => a - b)\\n    .join(\\' \\')\\n    .replace(/^./, firstLetter => firstLetter.toUpperCase());\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703230,
                "title": "c-solution-with-explanation",
                "content": "First Approach :\\n  Tokenizing words and sorting. This is a horrible idea because sorting shall make it expensive. We also need to maintain the relative order of the tokens of the same length. Also concatenating all the tokens in the right order shall add to the complexity.\\n\\n\\nSecond Approach:\\nTo make it linear time: We need to use a hashmap with key being length of string and value being vector of strings. \\nStore each token in the map by indexing the token by its length. At the end we only need to traverse the map in the increasing order of the key and concatenate all the tokens.\\nThis approach is better than before, however though concatenation looks simple but its expensive because inherently you need to reallocate each time new memory each time.\\nThis too shall not work.\\n\\nThird Approach:\\nInstead of using vector<string>, let us maintain the string as the value for the hashmap.  So for a token, as it is extracted we shall append it to the string in the hash map corresponding to its length.\\nIn the end we have strings containing partial answers which need to be concatenated.\\nIn this case we are relatively doing less concatenation making it optimal.\\n\\n\\n```\\nstring arrangeWords(string text) {\\n       unordered_map<int, string> mymap;\\n        set<int> myset;\\n        int pos=0;\\n        string tmp;\\n        int start=0;\\n        while(pos<text.length()){\\n            if(isalpha(text[pos])){\\n                tmp += tolower(text[pos]);\\n            }\\n            else{\\n                mymap[pos-start] += (tmp+\" \");\\n                myset.insert(pos-start);\\n                start=pos+1;\\n                tmp=\"\";\\n            }\\n            pos++;\\n        }\\n        mymap[pos-start]+= (tmp+\" \");\\n        myset.insert(pos-start);            \\n        string res;\\n        for(auto it=myset.begin(); it!=myset.end(); it++){\\n                res += mymap[*it];\\n        }\\n        res[0] = toupper(res[0]);\\n        return res.substr(0, res.length()-1);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstring arrangeWords(string text) {\\n       unordered_map<int, string> mymap;\\n        set<int> myset;\\n        int pos=0;\\n        string tmp;\\n        int start=0;\\n        while(pos<text.length()){\\n            if(isalpha(text[pos])){\\n                tmp += tolower(text[pos]);\\n            }\\n            else{\\n                mymap[pos-start] += (tmp+\" \");\\n                myset.insert(pos-start);\\n                start=pos+1;\\n                tmp=\"\";\\n            }\\n            pos++;\\n        }\\n        mymap[pos-start]+= (tmp+\" \");\\n        myset.insert(pos-start);            \\n        string res;\\n        for(auto it=myset.begin(); it!=myset.end(); it++){\\n                res += mymap[*it];\\n        }\\n        res[0] = toupper(res[0]);\\n        return res.substr(0, res.length()-1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696583,
                "title": "o-n-bucket-sort",
                "content": "Using a built in stable sort is concise, but O(nlogn) runtime.\\n\\nBucket sort gives O(n) for runtime and memory.\\n\\n```\\npublic class Solution {\\n    public string ArrangeWords(string str) {\\n        if (str == null || str.Length == 0)\\n            return str;\\n            \\n        var split = str.Split();\\n        split[0] = split[0].ToLower();\\n        \\n        var longest = split.Max(x => x.Length);\\n        var buckets = new List<string>[longest];\\n        \\n        foreach (var word in split) {\\n            var i = word.Length - 1;\\n            if (buckets[i] == null)\\n                buckets[i] = new List<string>();\\n            buckets[i].Add(word);\\n        }\\n        \\n        var sb = new StringBuilder();\\n        foreach (var list in buckets) {\\n            if (list == null)\\n                continue;\\n            foreach (var word in list) {\\n                sb.Append(word);\\n                sb.Append(\" \");\\n            }\\n        }\\n        \\n        sb[0] = char.ToUpper(sb[0]);\\n        sb.Length--;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bucket Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public string ArrangeWords(string str) {\\n        if (str == null || str.Length == 0)\\n            return str;\\n            \\n        var split = str.Split();\\n        split[0] = split[0].ToLower();\\n        \\n        var longest = split.Max(x => x.Length);\\n        var buckets = new List<string>[longest];\\n        \\n        foreach (var word in split) {\\n            var i = word.Length - 1;\\n            if (buckets[i] == null)\\n                buckets[i] = new List<string>();\\n            buckets[i].Add(word);\\n        }\\n        \\n        var sb = new StringBuilder();\\n        foreach (var list in buckets) {\\n            if (list == null)\\n                continue;\\n            foreach (var word in list) {\\n                sb.Append(word);\\n                sb.Append(\" \");\\n            }\\n        }\\n        \\n        sb[0] = char.ToUpper(sb[0]);\\n        sb.Length--;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695636,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        \\n        transform(text.begin(),text.end(),text.begin(),::tolower);\\n        map<int,queue<string>> mp;\\n        \\n        int val=text.size();\\n        stringstream s(text);\\n        string word;\\n        while(s>>word){\\n            int size=word.size();\\n            mp[size].push(word);\\n        }\\n        \\n        string ans;\\n        for(auto el:mp){\\n            if(ans.empty()){\\n                string temp=el.second.front();\\n                el.second.pop();\\n                temp[0]-=32;\\n                ans+=temp+\\' \\';\\n                int size=el.second.size();\\n                while(size>0){\\n                    string s1=el.second.front();\\n                    el.second.pop();\\n                    ans+=s1+\\' \\';\\n                    size--;\\n                }\\n            }\\n            else{\\n                int size=el.second.size();\\n                while(size>0){\\n                    string s1=el.second.front();\\n                    el.second.pop();\\n                    ans+=s1+\\' \\';\\n                    size--;\\n                }\\n            }\\n        }\\n        return ans.substr(0,val);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        \\n        transform(text.begin(),text.end(),text.begin(),::tolower);\\n        map<int,queue<string>> mp;\\n        \\n        int val=text.size();\\n        stringstream s(text);\\n        string word;\\n        while(s>>word){\\n            int size=word.size();\\n            mp[size].push(word);\\n        }\\n        \\n        string ans;\\n        for(auto el:mp){\\n            if(ans.empty()){\\n                string temp=el.second.front();\\n                el.second.pop();\\n                temp[0]-=32;\\n                ans+=temp+\\' \\';\\n                int size=el.second.size();\\n                while(size>0){\\n                    string s1=el.second.front();\\n                    el.second.pop();\\n                    ans+=s1+\\' \\';\\n                    size--;\\n                }\\n            }\\n            else{\\n                int size=el.second.size();\\n                while(size>0){\\n                    string s1=el.second.front();\\n                    el.second.pop();\\n                    ans+=s1+\\' \\';\\n                    size--;\\n                }\\n            }\\n        }\\n        return ans.substr(0,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687345,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n    \\n     String[]arr=text.split(\" \");\\n     Arrays.sort(arr,new Comparator<String>(){\\n         @Override\\n         public int compare(String a,String b){\\n             if(a.length()<b.length()){\\n                 return -1;\\n             }\\n             if(a.length()>b.length()){\\n                 return 1;\\n             }\\n             return 0;\\n         }\\n     });\\n      StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<arr.length;i++){\\n         if(i==0){   \\n          String x=arr[i].substring(0,1).toUpperCase()+arr[i].substring(1);\\n            sb.append(x);\\n         }\\n         else{\\n         sb.append(\" \");\\n         sb.append(arr[i].toLowerCase());\\n        }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n    \\n     String[]arr=text.split(\" \");\\n     Arrays.sort(arr,new Comparator<String>(){\\n         @Override\\n         public int compare(String a,String b){\\n             if(a.length()<b.length()){\\n                 return -1;\\n             }\\n             if(a.length()>b.length()){\\n                 return 1;\\n             }\\n             return 0;\\n         }\\n     });\\n      StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<arr.length;i++){\\n         if(i==0){   \\n          String x=arr[i].substring(0,1).toUpperCase()+arr[i].substring(1);\\n            sb.append(x);\\n         }\\n         else{\\n         sb.append(\" \");\\n         sb.append(arr[i].toLowerCase());\\n        }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680968,
                "title": "python-simple-oneliner",
                "content": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \\' \\'.join(sorted(text.split(), key=len)).capitalize()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \\' \\'.join(sorted(text.split(), key=len)).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651740,
                "title": "76ms-98-12-mb-100",
                "content": "public:\\nstatic bool cmp(pair<int,int> a , pair<int,int> b)\\n    {\\n        if(a.second!=b.second)\\n            return a.second  < b.second;\\n        else\\n           return  a.first < b.first;\\n        \\n        \\n    }\\nstring arrangeWords(string text) {\\n        vector< pair<int,int>  > vect;\\n        \\n        for(int i=0;i<text.size();i++)\\n        {   char temp = \\' \\';\\n            int start = i;\\n            int end =i+1;\\n            while(end<text.size()&&text[end]!=temp)\\n            {\\n                end++;\\n            }\\n            i=end;\\n          \\n           \\n            int len =  end-start-1;\\n         \\n            pair<int,int> p;\\n            p.first = start;\\n            p.second = len;\\n            vect.push_back(p);\\n            \\n        }\\n      sort(vect.begin(),vect.end(),cmp);    \\n        \\n        string ans;\\n    \\n    for(int i=0;i<vect.size();i++)\\n    {   \\n        \\n        for(int j = vect[i].first;j<=vect[i].first+vect[i].second;j++)\\n        {   if(j==0)\\n        {\\n            ans.push_back(text[j]+32);\\n        }else\\n            ans.push_back(text[j]);\\n        }\\n        ans.push_back(\\' \\');\\n    }\\n     ans.pop_back();  \\n    char temp =  ans[0];\\n    ans[0] = temp-32;\\n     return ans;\\n    }\\n   \\n};",
                "solutionTags": [],
                "code": "public:\\nstatic bool cmp(pair<int,int> a , pair<int,int> b)\\n    {\\n        if(a.second!=b.second)\\n            return a.second  < b.second;\\n        else\\n           return  a.first < b.first;\\n        \\n        \\n    }\\nstring arrangeWords(string text) {\\n        vector< pair<int,int>  > vect;\\n        \\n        for(int i=0;i<text.size();i++)\\n        {   char temp = \\' \\';\\n            int start = i;\\n            int end =i+1;\\n            while(end<text.size()&&text[end]!=temp)\\n            {\\n                end++;\\n            }\\n            i=end;\\n          \\n           \\n            int len =  end-start-1;\\n         \\n            pair<int,int> p;\\n            p.first = start;\\n            p.second = len;\\n            vect.push_back(p);\\n            \\n        }\\n      sort(vect.begin(),vect.end(),cmp);    \\n        \\n        string ans;\\n    \\n    for(int i=0;i<vect.size();i++)\\n    {   \\n        \\n        for(int j = vect[i].first;j<=vect[i].first+vect[i].second;j++)\\n        {   if(j==0)\\n        {\\n            ans.push_back(text[j]+32);\\n        }else\\n            ans.push_back(text[j]);\\n        }\\n        ans.push_back(\\' \\');\\n    }\\n     ans.pop_back();  \\n    char temp =  ans[0];\\n    ans[0] = temp-32;\\n     return ans;\\n    }\\n   \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 648025,
                "title": "python3-one-liner",
                "content": "```\\nclass Solution:\\n  def arrangeWords(self, text: str) -> str:\\n    return \\' \\'.join(sorted(text.lower().split(), key=len)).capitalize()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def arrangeWords(self, text: str) -> str:\\n    return \\' \\'.join(sorted(text.lower().split(), key=len)).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645468,
                "title": "java-clean-code-and-easy-to-understand-o-n-counting-sort-solution",
                "content": "I used a counting sort approach to solve this problem. Basically I create an array `wordsToCount` with the length of the text. Each index at the array stores a list of all words with the length of the index.  Add the words to `wordsToCount` according to their length. At the end I just have to iterate over my `wordsToCount` array and the list of words at each index and add it to my result string.\\n\\nTime complexity: O(n)\\nSpace Complexity: O(n)\\n\\n**Example:**\\n\\ntext = \"Hello dog cat house\"\\n\\nThe wordToCount array will look like this\\nA[1] -> []\\nA[2] -> []\\nA[3] -> [\"dog\", \"cat\"]\\nA[4] -> []\\nA[5] -> [\"Hello\", \"house\"]\\nA[6] -> []\\n...\\nA[text.length() + 1] -> []\\n\\nresult = \"Dog cat hello house\"\\n\\n\\n```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        text = Character.toLowerCase(text.charAt(0)) + text.substring(1, text.length());\\n        List<String>[] wordsToLength = new ArrayList[text.length() + 1];\\n        String[] words = text.split(\" \");\\n        \\n        for (String word : words) {\\n            int len = word.length();\\n                \\n            if (wordsToLength[len] == null) {\\n                wordsToLength[len] = new ArrayList<>();\\n            }\\n            \\n            wordsToLength[len].add(word);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (List<String> wordList : wordsToLength) {\\n            if (wordList == null) {\\n                continue;\\n            }\\n            \\n            for (String word : wordList) {\\n                sb.append(word);\\n                sb.append(\" \");\\n            }\\n        }\\n        \\n        sb.setLength(sb.length() - 1);\\n        sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        text = Character.toLowerCase(text.charAt(0)) + text.substring(1, text.length());\\n        List<String>[] wordsToLength = new ArrayList[text.length() + 1];\\n        String[] words = text.split(\" \");\\n        \\n        for (String word : words) {\\n            int len = word.length();\\n                \\n            if (wordsToLength[len] == null) {\\n                wordsToLength[len] = new ArrayList<>();\\n            }\\n            \\n            wordsToLength[len].add(word);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (List<String> wordList : wordsToLength) {\\n            if (wordList == null) {\\n                continue;\\n            }\\n            \\n            for (String word : wordList) {\\n                sb.append(word);\\n                sb.append(\" \");\\n            }\\n        }\\n        \\n        sb.setLength(sb.length() - 1);\\n        sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640428,
                "title": "java-1-using-arrays-sort-2-using-priorityqueue",
                "content": "**Using Arrays.sort() :-**\\n```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] arr = text.split(\" \", 10000000);\\n        Arrays.sort(arr, ((a,b) -> {\\n            if(a.length() > b.length()) return 1;\\n            if(a.length() < b.length()) return -1;\\n            return 0;\\n        }));\\n        StringBuilder s = new StringBuilder();\\n        for(String x : arr){\\n            s.append(x.toLowerCase());\\n            s.append(\" \");\\n        }\\n        char c = Character.toUpperCase(s.charAt(0));\\n        s.deleteCharAt(0);\\n        s.deleteCharAt(s.length() - 1);\\n        s.insert(0, c);\\n        return s.toString();\\n    }\\n}\\n```\\n**Using PriorityQueue :-**\\n```\\nclass Solution {\\n    class MyType{\\n        int len, ind;\\n        MyType(int x, int y){\\n            len = x;\\n            ind = y;\\n        }\\n    }\\n    public String arrangeWords(String text) {\\n        PriorityQueue<MyType> q = new PriorityQueue<MyType>((a,b) -> {\\n            if(a.len > b.len) return 1;\\n            if(a.len < b.len) return -1;\\n            return a.ind - b.ind;\\n        });\\n        String[] arr = text.split(\" \", 10000000);\\n        for(int i = 0; i < arr.length; i++)\\n            q.add(new MyType(arr[i].length(), i));\\n        int i = 0;\\n        StringBuilder s = new StringBuilder();\\n        while(q.size() > 0){\\n            s.append(arr[q.poll().ind].toLowerCase());\\n            s.append(\" \");\\n        }\\n        char c = Character.toUpperCase(s.charAt(0));\\n        s.deleteCharAt(0);\\n        s.deleteCharAt(s.length() - 1);\\n        s.insert(0, c);\\n        return s.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] arr = text.split(\" \", 10000000);\\n        Arrays.sort(arr, ((a,b) -> {\\n            if(a.length() > b.length()) return 1;\\n            if(a.length() < b.length()) return -1;\\n            return 0;\\n        }));\\n        StringBuilder s = new StringBuilder();\\n        for(String x : arr){\\n            s.append(x.toLowerCase());\\n            s.append(\" \");\\n        }\\n        char c = Character.toUpperCase(s.charAt(0));\\n        s.deleteCharAt(0);\\n        s.deleteCharAt(s.length() - 1);\\n        s.insert(0, c);\\n        return s.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639022,
                "title": "go-using-sort-slicestable",
                "content": "\\n```\\ntype x struct {\\n    k string\\n    val int\\n}\\n\\nfunc arrangeWords(text string) string {\\n    m := strings.Split(text, \" \")\\n    m[0] = strings.ToLower(m[0])\\n    mp := make([]x, len(m))\\n    for i := 0; i < len(m); i++ {\\n        mp[i].k= m[i]\\n        mp[i].val = len(m[i])\\n    }\\n    sort.SliceStable(mp, func (i, j int) bool {\\n        return mp[i].val < mp[j].val\\n    })\\n    mp[0].k = strings.Title(mp[0].k)    \\n    ret := \"\"\\n    for i := 0; i < len(mp); i++ {\\n        ret += mp[i].k + \" \" \\n    }\\n    return strings.TrimRight(ret, \" \")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype x struct {\\n    k string\\n    val int\\n}\\n\\nfunc arrangeWords(text string) string {\\n    m := strings.Split(text, \" \")\\n    m[0] = strings.ToLower(m[0])\\n    mp := make([]x, len(m))\\n    for i := 0; i < len(m); i++ {\\n        mp[i].k= m[i]\\n        mp[i].val = len(m[i])\\n    }\\n    sort.SliceStable(mp, func (i, j int) bool {\\n        return mp[i].val < mp[j].val\\n    })\\n    mp[0].k = strings.Title(mp[0].k)    \\n    ret := \"\"\\n    for i := 0; i < len(mp); i++ {\\n        ret += mp[i].k + \" \" \\n    }\\n    return strings.TrimRight(ret, \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638893,
                "title": "c-detailed-explanation-linear-time-solution-without-sorting",
                "content": "Keep track of min length and max length of words. \\nUse unordered_map to store words according to their length.\\nLater iterate through min length to max length and add words.\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        unordered_map<int,vector<string>> m;\\n        int i=0;\\n        int mn = INT_MAX;\\n        int mx = INT_MIN;\\n        text[0] = tolower(text[0]);\\n        \\n        while(i < text.length()){\\n            string s = \"\";\\n            while(i < text.length() && text[i] != \\' \\'){\\n                s += text[i];\\n                i++;\\n            }\\n            \\n            if(text[i] == \\' \\'){\\n                i++;\\n            }\\n            \\n            if(s.length() > 0){\\n                mn = min(mn, int(s.length()));\\n                mx = max(mx, int(s.length()));\\n                m[s.length()].push_back(s);\\n            }\\n            \\n        }\\n        \\n        string s1 = \"\";\\n        \\n        for(int i = mn; i <= mx; i++){\\n            if(m.find(i) != m.end()){\\n                for(int j = 0; j < m[i].size(); j++){\\n                    string s2 = m[i][j];\\n                    s1 += s2;\\n                    s1 += \\' \\';\\n                }\\n            }\\n            \\n        }\\n        \\n        s1[0] = toupper(s1[0]);\\n        s1.pop_back();\\n        return s1;\\n    }\\n};\\n```\\nPlease upvote if you find this useful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        unordered_map<int,vector<string>> m;\\n        int i=0;\\n        int mn = INT_MAX;\\n        int mx = INT_MIN;\\n        text[0] = tolower(text[0]);\\n        \\n        while(i < text.length()){\\n            string s = \"\";\\n            while(i < text.length() && text[i] != \\' \\'){\\n                s += text[i];\\n                i++;\\n            }\\n            \\n            if(text[i] == \\' \\'){\\n                i++;\\n            }\\n            \\n            if(s.length() > 0){\\n                mn = min(mn, int(s.length()));\\n                mx = max(mx, int(s.length()));\\n                m[s.length()].push_back(s);\\n            }\\n            \\n        }\\n        \\n        string s1 = \"\";\\n        \\n        for(int i = mn; i <= mx; i++){\\n            if(m.find(i) != m.end()){\\n                for(int j = 0; j < m[i].size(); j++){\\n                    string s2 = m[i][j];\\n                    s1 += s2;\\n                    s1 += \\' \\';\\n                }\\n            }\\n            \\n        }\\n        \\n        s1[0] = toupper(s1[0]);\\n        s1.pop_back();\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637541,
                "title": "swift-100",
                "content": "```\\nextension String {\\n    func capitalizingFirstLetter() -> String {\\n        return prefix(1).capitalized + dropFirst()\\n    }\\n\\n    mutating func capitalizeFirstLetter() {\\n        self = self.capitalizingFirstLetter()\\n    }\\n}\\nclass Solution {\\nfunc arrangeWords(_ text: String) -> String {\\n    var arr = text.split(separator: \" \").map{String($0)}\\n    arr = arr.sorted{$0.count < $1.count}\\n    var st = \"\"\\n    for i in 0..<arr.count{\\n        st.append(arr[i].lowercased())\\n        if i < arr.count - 1{\\n        st.append(\" \")\\n            }\\n    }\\n    return st.capitalizingFirstLetter()\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nextension String {\\n    func capitalizingFirstLetter() -> String {\\n        return prefix(1).capitalized + dropFirst()\\n    }\\n\\n    mutating func capitalizeFirstLetter() {\\n        self = self.capitalizingFirstLetter()\\n    }\\n}\\nclass Solution {\\nfunc arrangeWords(_ text: String) -> String {\\n    var arr = text.split(separator: \" \").map{String($0)}\\n    arr = arr.sorted{$0.count < $1.count}\\n    var st = \"\"\\n    for i in 0..<arr.count{\\n        st.append(arr[i].lowercased())\\n        if i < arr.count - 1{\\n        st.append(\" \")\\n            }\\n    }\\n    return st.capitalizingFirstLetter()\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637499,
                "title": "rust-solution-with-stable-sort-by",
                "content": "The key point is: `sort_by`  will preserve the relative order of words with same length. \\n\\n\\nAlso, capitalize a string in `Rust` is painful, the best way I can think of is the following long combinators, any idea on how to improve this is welcome.\\n\\n` fw = fw.chars().take(1).flat_map(char::to_uppercase).chain(fw.chars().skip(1)).collect::<String>();`\\n\\n### Rust solution\\n```\\nimpl Solution {\\n    pub fn arrange_words(text: String) -> String {\\n        let text = text.to_lowercase();\\n        let mut words: Vec<&str> = text.split_whitespace().collect();\\n        # words.sort_by(|a, b| a.len().cmp(&b.len()));\\n        words.sort_by_key(|w| w.len()); \\n        \\n        let mut fw = words[0].to_string(); // first word\\n        fw = fw.chars().take(1).flat_map(char::to_uppercase).chain(fw.chars().skip(1)).collect::<String>();\\n        words[0] = &fw;\\n\\n        words.join(\" \")\\n    }\\n}\\n```\\n\\nEdit : replace `words.sort_by(|a, b| a.len().cmp(&b.len()));` with `words.sort_by_key(|w| w.len()); ` as suggested by @rcode0 .",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn arrange_words(text: String) -> String {\\n        let text = text.to_lowercase();\\n        let mut words: Vec<&str> = text.split_whitespace().collect();\\n        # words.sort_by(|a, b| a.len().cmp(&b.len()));\\n        words.sort_by_key(|w| w.len()); \\n        \\n        let mut fw = words[0].to_string(); // first word\\n        fw = fw.chars().take(1).flat_map(char::to_uppercase).chain(fw.chars().skip(1)).collect::<String>();\\n        words[0] = &fw;\\n\\n        words.join(\" \")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 637271,
                "title": "pythonic-sol-by-split-and-join-w-comment",
                "content": "Pythonic sol by split and join\\n\\n---\\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        \\n        # Split each word by white space, store them in list\\n        words = [ *text.split() ]\\n        \\n        # Convert first word to lower case\\n        words[0] = words[0].lower()\\n        \\n        # Sort words by character length\\n        words.sort( key = len )\\n        \\n        # Convert back to string, separated by space\\n        # Then capitalize the result\\n        return ( \\' \\'.join( words ) ).capitalize()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        \\n        # Split each word by white space, store them in list\\n        words = [ *text.split() ]\\n        \\n        # Convert first word to lower case\\n        words[0] = words[0].lower()\\n        \\n        # Sort words by character length\\n        words.sort( key = len )\\n        \\n        # Convert back to string, separated by space\\n        # Then capitalize the result\\n        return ( \\' \\'.join( words ) ).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636971,
                "title": "golang-sort-stable",
                "content": "It\\'s important to use sort.Stable instead sort.Sort because stable sorts data while keeping the original order of equal elements.\\n```\\ntype ByStringLen struct {\\n    s []string\\n}\\n\\nfunc (s ByStringLen) Len() int {\\n    return len(s.s)\\n}\\n\\nfunc (s ByStringLen) Swap(i,j int) {\\n    s.s[i], s.s[j] = s.s[j], s.s[i] \\n}\\n\\nfunc (s ByStringLen) Less(i, j int) bool {\\n    return len(s.s[i]) < len(s.s[j])\\n}\\n\\nfunc (s ByStringLen) getStr() string {\\n    return strings.Join(s.s, \" \")\\n}\\n\\nfunc arrangeWords(text string) string {\\n    words := ByStringLen{\\n        s: strings.Split(text, \" \"),\\n    }\\n    sort.Stable(words)\\n    res := words.getStr()\\n    res = strings.ToLower(res)\\n    res = strings.ToUpper(res[0:1]) + res[1:]\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype ByStringLen struct {\\n    s []string\\n}\\n\\nfunc (s ByStringLen) Len() int {\\n    return len(s.s)\\n}\\n\\nfunc (s ByStringLen) Swap(i,j int) {\\n    s.s[i], s.s[j] = s.s[j], s.s[i] \\n}\\n\\nfunc (s ByStringLen) Less(i, j int) bool {\\n    return len(s.s[i]) < len(s.s[j])\\n}\\n\\nfunc (s ByStringLen) getStr() string {\\n    return strings.Join(s.s, \" \")\\n}\\n\\nfunc arrangeWords(text string) string {\\n    words := ByStringLen{\\n        s: strings.Split(text, \" \"),\\n    }\\n    sort.Stable(words)\\n    res := words.getStr()\\n    res = strings.ToLower(res)\\n    res = strings.ToUpper(res[0:1]) + res[1:]\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636900,
                "title": "c-sorteddictionary-solution-o-n-time-beats-100-o-n-space-beats-100",
                "content": "public class Solution {\\n    public string ArrangeWords(string text) {\\n        var map = new SortedDictionary<int, List<string>>();\\n        string[] words = text.Split(null);\\n        \\n        for( int i = 0; i < words.Length; i++){\\n            string word = words[i];\\n            int len = word.Length;\\n            \\n            if(map.ContainsKey(len)){\\n                var list = map[len];                \\n                list.Add(word);                \\n            }\\n            else{               \\n                var list = new List<string>();\\n                if( i == 0) list.Add(word.ToLower());\\n                else list.Add(word);\\n                \\n                map.Add(len,list);\\n            }           \\n        }\\n                \\n        StringBuilder sb = new StringBuilder();\\n        foreach( var item in map){\\n            List<string> list = item.Value;\\n            foreach(var word in list){              \\n                sb.Append(word);               \\n                sb.Append(\" \");\\n            }\\n            var ch = Char.ToUpper(sb[0]);   \\n            sb.Replace(sb[0],ch,0,1);\\n        }\\n        return sb.ToString().Trim();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string ArrangeWords(string text) {\\n        var map = new SortedDictionary<int, List<string>>();\\n        string[] words = text.Split(null);\\n        \\n        for( int i = 0; i < words.Length; i++){\\n            string word = words[i];\\n            int len = word.Length;\\n            \\n            if(map.ContainsKey(len)){\\n                var list = map[len];                \\n                list.Add(word);                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 636840,
                "title": "mle-tle-solution-must-see",
                "content": "I wasted 1hour in this problem and tried nearly everything! At the end, what was the result? MLE,TLE! Got so irritated during the contest! :( At the end, after seeing the solutions, I started to debug my code line by line and when I found the difference, I was shocked! Never ever such thing happened to me before. Maybe it was new for me or maybe it was leetcode OJ\\'s fault. I don\\'t know but what is important is that everyone should be aware of it and not make the same mistake again in future contests! Here is my incorrect MLE solution first:\\n```\\nstring arrangeWords(string text) {\\n        text[0]=text[0]+32;\\n        text=text+\\' \\';\\n        string temp=\"\";\\n        map<int,vector<string>> mp;\\n        for(char c:text){\\n            if(c!=\\' \\')\\n                temp=temp+c;\\n            else {\\n                mp[temp.size()].push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        string res=\"\";\\n        for(auto it:mp)\\n            for(auto j:it.second)\\n                res=res+j + \\' \\';\\n        \\n        res[0]=toupper(res[0]);\\n        return res.substr(0,res.size()-1);\\n    }\\n```\\nNow here is the correct solution:\\n\\n```\\nstring arrangeWords(string text) {\\n        text[0]+=32;\\n        text+=\\' \\';\\n        string temp=\"\";\\n        map<int,vector<string>> mp;\\n        for(char c:text){\\n            if(c!=\\' \\')\\n                temp+=c;\\n            else {\\n                mp[temp.size()].push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        string res=\"\";\\n        for(auto it:mp)\\n            for(auto j:it.second)\\n                res+=j + \\' \\';\\n        \\n        res[0]=toupper(res[0]);\\n        return res.substr(0,res.size()-1);\\n    }\\n```\\nSaw the difference? If not, see the line where we are adding character\\t```c``` to temp or where we are adding string ```j``` to our ```res``` string,etc.\\nThe complexity of my correct solution is: 92ms! \\nNever knew such small techniques can make a huge difference!\\n\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring arrangeWords(string text) {\\n        text[0]=text[0]+32;\\n        text=text+\\' \\';\\n        string temp=\"\";\\n        map<int,vector<string>> mp;\\n        for(char c:text){\\n            if(c!=\\' \\')\\n                temp=temp+c;\\n            else {\\n                mp[temp.size()].push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        string res=\"\";\\n        for(auto it:mp)\\n            for(auto j:it.second)\\n                res=res+j + \\' \\';\\n        \\n        res[0]=toupper(res[0]);\\n        return res.substr(0,res.size()-1);\\n    }\\n```\n```\\nstring arrangeWords(string text) {\\n        text[0]+=32;\\n        text+=\\' \\';\\n        string temp=\"\";\\n        map<int,vector<string>> mp;\\n        for(char c:text){\\n            if(c!=\\' \\')\\n                temp+=c;\\n            else {\\n                mp[temp.size()].push_back(temp);\\n                temp=\"\";\\n            }\\n        }\\n        string res=\"\";\\n        for(auto it:mp)\\n            for(auto j:it.second)\\n                res+=j + \\' \\';\\n        \\n        res[0]=toupper(res[0]);\\n        return res.substr(0,res.size()-1);\\n    }\\n```\n```c```\n```j```\n```res```",
                "codeTag": "Unknown"
            },
            {
                "id": 636692,
                "title": "c-easy-map-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0]=text[0]+32; \\n        map<int,vector<string>>v;\\n        string k=\"\";\\n        int m=0;        \\n        //stores the strings of same length in same vector\\n        for(int i=0;i<text.length();i++){\\n            if(text[i]!=\\' \\'){\\n               k+=text[i]; \\n            }\\n            else{\\n                if(k.length()>m)m=k.length();\\n                v[k.length()-1].push_back(k);\\n                k=\"\";\\n            }\\n        }\\n        if(k.length()>m)m=k.length();\\n        v[k.length()-1].push_back(k);\\n        k=\"\";\\n        for(int i=0;i<=m;i++){\\n            if(v[i].size()!=0){\\n                for(int j=0;j<v[i].size();j++){\\n                    k+=v[i][j]+\" \";\\n                }\\n            \\n            }\\n        }\\n        if(k[k.size()-1]==\\' \\')k.pop_back();\\n        k[0]=k[0]-32;\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0]=text[0]+32; \\n        map<int,vector<string>>v;\\n        string k=\"\";\\n        int m=0;        \\n        //stores the strings of same length in same vector\\n        for(int i=0;i<text.length();i++){\\n            if(text[i]!=\\' \\'){\\n               k+=text[i]; \\n            }\\n            else{\\n                if(k.length()>m)m=k.length();\\n                v[k.length()-1].push_back(k);\\n                k=\"\";\\n            }\\n        }\\n        if(k.length()>m)m=k.length();\\n        v[k.length()-1].push_back(k);\\n        k=\"\";\\n        for(int i=0;i<=m;i++){\\n            if(v[i].size()!=0){\\n                for(int j=0;j<v[i].size();j++){\\n                    k+=v[i][j]+\" \";\\n                }\\n            \\n            }\\n        }\\n        if(k[k.size()-1]==\\' \\')k.pop_back();\\n        k[0]=k[0]-32;\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636597,
                "title": "python-heaq-solution",
                "content": "\\n\\n    class Solution(object):\\n        def arrangeWords(self, text):\\n\\n\\t\\t\\ttextList = text.split(\\' \\')\\n\\t\\t\\tif len(textList) == 1:\\n\\t\\t\\t\\treturn text\\n\\n\\t\\t\\ttextList[0] = textList[0].lower()  \\n\\t\\t\\thq = []\\n\\t\\t\\tfor idx in range(len(textList)):\\n\\t\\t\\t\\ttxt = textList[idx]\\n\\t\\t\\t\\theapq.heappush(hq, (len(txt), idx, txt))\\n\\n\\t\\t\\tres = []\\n\\t\\t\\twhile hq:\\n\\t\\t\\t\\ttext = heapq.heappop(hq)\\n\\t\\t\\t\\tres.append(text[2])\\n\\n\\t\\t\\tres =  \\' \\'.join(res).capitalize() \\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\n\\n    class Solution(object):\\n        def arrangeWords(self, text):\\n\\n\\t\\t\\ttextList = text.split(\\' \\')\\n\\t\\t\\tif len(textList) == 1:\\n\\t\\t\\t\\treturn text\\n\\n\\t\\t\\ttextList[0] = textList[0].lower()  \\n\\t\\t\\thq = []\\n\\t\\t\\tfor idx in range(len(textList)):\\n\\t\\t\\t\\ttxt = textList[idx]\\n\\t\\t\\t\\theapq.heappush(hq, (len(txt), idx, txt))\\n\\n\\t\\t\\tres = []\\n\\t\\t\\twhile hq:\\n\\t\\t\\t\\ttext = heapq.heappop(hq)\\n\\t\\t\\t\\tres.append(text[2])\\n\\n\\t\\t\\tres =  \\' \\'.join(res).capitalize() \\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 636586,
                "title": "js-faster-efficient",
                "content": "```\\n/**\\n * @param {string} text\\n * @return {string}\\n */\\nvar arrangeWords = function(text) {\\n    var modified = text.toLowerCase().split(\\' \\').map((a, i) => {\\n        return {\\n            word: a,\\n            index: i\\n        }\\n    });\\n    var sorted = [...modified.sort(function(a, b) {\\n        return a.word.length - b.word.length <= 0 ? -1 : 1;\\n    })];\\n    sorted = modified.sort(function(a, b) {\\n        var aLen = a.word.length, bLen = b.word.length;\\n        if (aLen === bLen) {\\n            return a.index - b.index;\\n        }\\n        return aLen - bLen <= 0 ? -1 : 1;\\n    });\\n    var finalString = sorted.map(a => a.word).join(\\' \\');\\n    return finalString[0].toUpperCase() + finalString.substring(1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} text\\n * @return {string}\\n */\\nvar arrangeWords = function(text) {\\n    var modified = text.toLowerCase().split(\\' \\').map((a, i) => {\\n        return {\\n            word: a,\\n            index: i\\n        }\\n    });\\n    var sorted = [...modified.sort(function(a, b) {\\n        return a.word.length - b.word.length <= 0 ? -1 : 1;\\n    })];\\n    sorted = modified.sort(function(a, b) {\\n        var aLen = a.word.length, bLen = b.word.length;\\n        if (aLen === bLen) {\\n            return a.index - b.index;\\n        }\\n        return aLen - bLen <= 0 ? -1 : 1;\\n    });\\n    var finalString = sorted.map(a => a.word).join(\\' \\');\\n    return finalString[0].toUpperCase() + finalString.substring(1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636524,
                "title": "python-super-easy-and-straight-forward-one-line-solution",
                "content": "Most of time, I am not a big fan of the one-line solution, but this one is pretty straight forward. \\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \\' \\'.join(sorted(text.split(), key = len)).capitalize()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \\' \\'.join(sorted(text.split(), key = len)).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636479,
                "title": "c-simple-sort-and-combine",
                "content": "```csharp\\npublic string ArrangeWords(string text) \\n{\\n\\tvar words = text.Split(new char[]{\\' \\'}, StringSplitOptions.RemoveEmptyEntries);\\n\\tvar newWords = words.OrderBy(x => x.Length).Select(x => x.ToLowerInvariant()).ToArray();\\n\\tif(newWords.Length > 0)\\n\\t{\\n\\t\\tnewWords[0] = (newWords[0].Substring(0, 1).ToUpperInvariant() + newWords[0].Substring(1));\\n\\t}\\n\\treturn string.Join(\" \", newWords);\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic string ArrangeWords(string text) \\n{\\n\\tvar words = text.Split(new char[]{\\' \\'}, StringSplitOptions.RemoveEmptyEntries);\\n\\tvar newWords = words.OrderBy(x => x.Length).Select(x => x.ToLowerInvariant()).ToArray();\\n\\tif(newWords.Length > 0)\\n\\t{\\n\\t\\tnewWords[0] = (newWords[0].Substring(0, 1).ToUpperInvariant() + newWords[0].Substring(1));\\n\\t}\\n\\treturn string.Join(\" \", newWords);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636449,
                "title": "simple-cpp-solution-using-map-with-detailed-explanation-o-string-length-tc",
                "content": "```\\n    string arrangeWords(string text) {\\n        //Convert first letter to lowercase\\n        if(text[0] >= \\'A\\' && text[0] <= \\'Z\\')\\n            text[0] = text[0] + \\'a\\' - \\'A\\';\\n        //Stringstream to iterate word by word in given text\\n        stringstream ss(text);\\n        string temp, res = \"\";\\n        map<int, vector<string>> mp;\\n        \\n        //Iterate through each word and store them as per their size\\n        while(!ss.eof())\\n        {\\n            ss >> temp;\\n            mp[temp.size()].push_back(temp);\\n        }\\n        //If string is empty, then you had no words. So, return empty string\\n        if(mp.size() == 0)\\n            return res;\\n        \\n        //Traverse through the stored map and add to result string.\\n        for(auto itr = mp.begin(); itr != mp.end(); itr++)\\n        {\\n            for(auto str : itr->second)\\n                res += str + \" \";\\n        }\\n        //Pop back last added space\\n        res.pop_back();\\n        \\n        //Convert first letter to uppercase\\n        if(res[0] >= \\'a\\' && res[0] <= \\'z\\')\\n            res[0] = res[0] - \\'a\\' + \\'A\\';\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string arrangeWords(string text) {\\n        //Convert first letter to lowercase\\n        if(text[0] >= \\'A\\' && text[0] <= \\'Z\\')\\n            text[0] = text[0] + \\'a\\' - \\'A\\';\\n        //Stringstream to iterate word by word in given text\\n        stringstream ss(text);\\n        string temp, res = \"\";\\n        map<int, vector<string>> mp;\\n        \\n        //Iterate through each word and store them as per their size\\n        while(!ss.eof())\\n        {\\n            ss >> temp;\\n            mp[temp.size()].push_back(temp);\\n        }\\n        //If string is empty, then you had no words. So, return empty string\\n        if(mp.size() == 0)\\n            return res;\\n        \\n        //Traverse through the stored map and add to result string.\\n        for(auto itr = mp.begin(); itr != mp.end(); itr++)\\n        {\\n            for(auto str : itr->second)\\n                res += str + \" \";\\n        }\\n        //Pop back last added space\\n        res.pop_back();\\n        \\n        //Convert first letter to uppercase\\n        if(res[0] >= \\'a\\' && res[0] <= \\'z\\')\\n            res[0] = res[0] - \\'a\\' + \\'A\\';\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 636396,
                "title": "priority-queue-c",
                "content": "Sort by Size in a min heap and then by index position.\\n```\\n  string arrangeWords(string text) {\\n        \\n        priority_queue<pair<int, pair<int, string>>, vector<pair<int, pair<int, string>>>, greater<pair<int, pair<int, string>>>> pq;\\n        string s = \"\";\\n        string res = \"\";\\n        int i = 1;\\n        char t = tolower(text[0]);\\n        text[0] = t;\\n        for(char c : text){\\n           if(c == \\' \\'){\\n                pq.push(make_pair(s.size(), make_pair(i, s)));\\n                s = \"\";\\n                i++;\\n            }\\n            else s += c;\\n        }\\n        pq.push(make_pair(s.size(), make_pair(i, s))); // push last word.\\n        \\n\\t\\twhile(!pq.empty()){\\n            auto node = pq.top();\\n            pq.pop();\\n            res += node.second.second + \" \";\\n        }\\n        char c = toupper(res[0]);\\n        res = res.substr(0, res.size() - 1);\\n        res[0] = c;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Sort by Size in a min heap and then by index position.\\n```\\n  string arrangeWords(string text) {\\n        \\n        priority_queue<pair<int, pair<int, string>>, vector<pair<int, pair<int, string>>>, greater<pair<int, pair<int, string>>>> pq;\\n        string s = \"\";\\n        string res = \"\";\\n        int i = 1;\\n        char t = tolower(text[0]);\\n        text[0] = t;\\n        for(char c : text){\\n           if(c == \\' \\'){\\n                pq.push(make_pair(s.size(), make_pair(i, s)));\\n                s = \"\";\\n                i++;\\n            }\\n            else s += c;\\n        }\\n        pq.push(make_pair(s.size(), make_pair(i, s))); // push last word.\\n        \\n\\t\\twhile(!pq.empty()){\\n            auto node = pq.top();\\n            pq.pop();\\n            res += node.second.second + \" \";\\n        }\\n        char c = toupper(res[0]);\\n        res = res.substr(0, res.size() - 1);\\n        res[0] = c;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 636352,
                "title": "clean-python-3-sorting",
                "content": "Time: `O(N + WlogW)` for sorting words\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        arranged = sorted(enumerate(text.lower().split()), key=lambda e: (len(e[1]), e[0]))\\n        return \\' \\'.join(map(lambda e: e[1], arranged)).capitalize()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        arranged = sorted(enumerate(text.lower().split()), key=lambda e: (len(e[1]), e[0]))\\n        return \\' \\'.join(map(lambda e: e[1], arranged)).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636314,
                "title": "sorting-python",
                "content": "```\\ndef arrangeWords(self, text: str) -> str:\\n        arr=text.split(\" \")\\n        arr.sort(key=lambda x:(len(x)))\\n        ans=\\' \\'.join(arr).lower()\\n        ans=ans[0].upper()+ans[1:]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef arrangeWords(self, text: str) -> str:\\n        arr=text.split(\" \")\\n        arr.sort(key=lambda x:(len(x)))\\n        ans=\\' \\'.join(arr).lower()\\n        ans=ans[0].upper()+ans[1:]\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 636311,
                "title": "java-custom-sort",
                "content": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        String[] aux = text.split(\" \");\\n        List<String[]> list = new ArrayList<>();\\n        for(int i = 0; i < aux.length; i++) list.add(new String[] {aux[i], Integer.toString(i)});\\n        Collections.sort(list, new Comparator<String[]>(){\\n            public int compare(String[] a1, String[] a2) {\\n                if(a1[0].length() < a2[0].length()) return -1;\\n                if(a1[0].length() > a2[0].length()) return 1;\\n                if(Integer.parseInt(a1[1]) < Integer.parseInt(a2[1])) return -1;\\n                return 1;\\n            }\\n        });\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < list.size(); i++) {\\n            String curr = list.get(i)[0];\\n            if(i == 0) {\\n                char[] t = curr.toCharArray();\\n                if(t[0] - \\'a\\' >= 0) t[0] = (char)((int)t[0] - 32);\\n                sb.append(new String(t));\\n            } else sb.append(curr.toLowerCase());\\n            if(i != list.size() - 1) sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String arrangeWords(String text) {\\n        String[] aux = text.split(\" \");\\n        List<String[]> list = new ArrayList<>();\\n        for(int i = 0; i < aux.length; i++) list.add(new String[] {aux[i], Integer.toString(i)}",
                "codeTag": "Java"
            },
            {
                "id": 636304,
                "title": "java-solution-using-treemap",
                "content": "* Split sentence by space .\\n* Change first word to lowercase.\\n* Add each word to TreeMap with key as word length.\\n* Poll first entry from TreeMap\\n* Change the first character of first word to uppercase.\\n* Keep on polling and updating the result string until treemap is empty.\\n\\n```\\nstatic public String arrangeWords(String text) {\\n\\n\\t\\tTreeMap<Integer, List<String>> map = new TreeMap<Integer, List<String>>();\\n\\t\\tStringBuilder builder = new StringBuilder();\\n\\t\\tString[] words = text.split(\" \");\\n\\t\\twords[0] = words[0].toLowerCase();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tint length = word.length();\\n\\t\\t\\tif (!map.containsKey(length))\\n\\t\\t\\t\\tmap.put(length, new ArrayList<String>());\\n\\t\\t\\tmap.get(length).add(word);\\n\\t\\t}\\n\\n\\t\\tList<String> lowestLengthList = map.pollFirstEntry().getValue();\\n\\t\\tString firstWord = lowestLengthList.get(0);\\n\\t\\tString upperCase = firstWord.substring(0, 1).toUpperCase() + firstWord.substring(1);\\n\\n\\t\\tbuilder.append(upperCase);\\n\\n\\t\\tfor (int index = 1; index < lowestLengthList.size(); index++)\\n\\t\\t\\tbuilder.append(\" \" + lowestLengthList.get(index));\\n\\n\\t\\twhile (!map.isEmpty()) {\\n\\t\\t\\tList<String> list = map.pollFirstEntry().getValue();\\n\\t\\t\\tfor (String str : list)\\n\\t\\t\\t\\tbuilder.append(\" \" + str);\\n\\t\\t}\\n\\n\\t\\treturn builder.toString();\\n\\t}",
                "solutionTags": [],
                "code": "* Split sentence by space .\\n* Change first word to lowercase.\\n* Add each word to TreeMap with key as word length.\\n* Poll first entry from TreeMap\\n* Change the first character of first word to uppercase.\\n* Keep on polling and updating the result string until treemap is empty.\\n\\n```\\nstatic public String arrangeWords(String text) {\\n\\n\\t\\tTreeMap<Integer, List<String>> map = new TreeMap<Integer, List<String>>();\\n\\t\\tStringBuilder builder = new StringBuilder();\\n\\t\\tString[] words = text.split(\" \");\\n\\t\\twords[0] = words[0].toLowerCase();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tint length = word.length();\\n\\t\\t\\tif (!map.containsKey(length))\\n\\t\\t\\t\\tmap.put(length, new ArrayList<String>());\\n\\t\\t\\tmap.get(length).add(word);\\n\\t\\t}\\n\\n\\t\\tList<String> lowestLengthList = map.pollFirstEntry().getValue();\\n\\t\\tString firstWord = lowestLengthList.get(0);\\n\\t\\tString upperCase = firstWord.substring(0, 1).toUpperCase() + firstWord.substring(1);\\n\\n\\t\\tbuilder.append(upperCase);\\n\\n\\t\\tfor (int index = 1; index < lowestLengthList.size(); index++)\\n\\t\\t\\tbuilder.append(\" \" + lowestLengthList.get(index));\\n\\n\\t\\twhile (!map.isEmpty()) {\\n\\t\\t\\tList<String> list = map.pollFirstEntry().getValue();\\n\\t\\t\\tfor (String str : list)\\n\\t\\t\\t\\tbuilder.append(\" \" + str);\\n\\t\\t}\\n\\n\\t\\treturn builder.toString();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 4093519,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\nO(logN)\\n\\n- Space complexity:\\n<O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0]=tolower(text[0]);\\n        vector<pair<int,string>>res;\\n        text=text+\\' \\';\\n        string p=\"\";\\n        for(int i=0;i<text.size();i++){\\n            \\n            if(text[i]!=\\' \\'){\\n               p+=text[i];\\n            }\\n            else{\\n                res.push_back({p.size(),p});\\n                p=\"\";\\n                \\n            }\\n        }\\n        stable_sort(res.begin(), res.end(), [](const pair<int, string> &a, const pair<int, string> &b) {\\n            return (a.first < b.first);\\n        });\\n        string a=\"\";\\n        for(int i=0;i<res.size();i++){\\n            a+=res[i].second;\\n            a+=\\' \\';\\n        }\\n        a.pop_back();\\n        a[0]=toupper(a[0]);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0]=tolower(text[0]);\\n        vector<pair<int,string>>res;\\n        text=text+\\' \\';\\n        string p=\"\";\\n        for(int i=0;i<text.size();i++){\\n            \\n            if(text[i]!=\\' \\'){\\n               p+=text[i];\\n            }\\n            else{\\n                res.push_back({p.size(),p});\\n                p=\"\";\\n                \\n            }\\n        }\\n        stable_sort(res.begin(), res.end(), [](const pair<int, string> &a, const pair<int, string> &b) {\\n            return (a.first < b.first);\\n        });\\n        string a=\"\";\\n        for(int i=0;i<res.size();i++){\\n            a+=res[i].second;\\n            a+=\\' \\';\\n        }\\n        a.pop_back();\\n        a[0]=toupper(a[0]);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073039,
                "title": "simple-o-n-solution-easy-to-understand",
                "content": "# Intuition\\nUse map with key as length and value as vector of words if multiple words have same length\\n# Approach\\nbefore parsing the string make sure that first character is made lowercase. Calculate the length of each word and use length as key. if multiple words have same length push it back at the vector end. once done itearte through the map and add each word and single space.\\nbecause one extra space is added resize the string by one. Also reset the bit to make it uppercase.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        map<int,vector<string>> orderMap;\\n        int idx=0;\\n        int len=0;\\n        int prev=0;\\n        text[0] = text[0] | (1<<5); // make it lowercase\\n        string temp;\\n\\n        while(text[idx])\\n        {\\n            if (text[idx] != \\' \\')\\n            {\\n                temp.push_back(text[idx]);\\n            }\\n            else\\n            {\\n                len = idx - prev;\\n                orderMap[len].push_back(temp);\\n                temp.clear();\\n                prev = idx+1;\\n            }\\n            idx++;\\n        }\\n        // last word in sentence \\n        len = idx - prev;\\n        orderMap[len].push_back(temp);\\n        temp.clear();\\n\\n        for(auto itr:orderMap)\\n        {\\n            len = itr.second.size();\\n            idx=0;\\n            while(idx <len)\\n            {\\n                temp += itr.second[idx];\\n                temp += \\' \\';\\n                idx++; \\n            }\\n        }\\n        temp.resize(temp.size()-1); // to remove the last trailing space\\n        temp[0] = temp[0] ^ (1<<5);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        map<int,vector<string>> orderMap;\\n        int idx=0;\\n        int len=0;\\n        int prev=0;\\n        text[0] = text[0] | (1<<5); // make it lowercase\\n        string temp;\\n\\n        while(text[idx])\\n        {\\n            if (text[idx] != \\' \\')\\n            {\\n                temp.push_back(text[idx]);\\n            }\\n            else\\n            {\\n                len = idx - prev;\\n                orderMap[len].push_back(temp);\\n                temp.clear();\\n                prev = idx+1;\\n            }\\n            idx++;\\n        }\\n        // last word in sentence \\n        len = idx - prev;\\n        orderMap[len].push_back(temp);\\n        temp.clear();\\n\\n        for(auto itr:orderMap)\\n        {\\n            len = itr.second.size();\\n            idx=0;\\n            while(idx <len)\\n            {\\n                temp += itr.second[idx];\\n                temp += \\' \\';\\n                idx++; \\n            }\\n        }\\n        temp.resize(temp.size()-1); // to remove the last trailing space\\n        temp[0] = temp[0] ^ (1<<5);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047926,
                "title": "simple-solution-time-15ms-memory-6-20mb",
                "content": "# Intuition\\nFirst opinion it was, get a count of letter in each words in first loop\\nand after that use a buble sort for sorted original slice.\\n\\n# Approach\\nIn Go have a nice function sort.SliceStable\\nfor this task\\n\\n# Complexity\\n- \\u0421omplexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n\\nfunc arrangeWords(text string) string {\\n    text = strings.ToLower(text)\\n\\twords := strings.Fields(text)\\n\\n\\tsort.SliceStable(words, func(i, j int) bool {\\n        c := len(words[i]) < len(words[j])\\n\\t\\tif c {\\n\\t\\t\\treturn c\\n\\t\\t}\\n\\t\\treturn i <  j\\n\\t})\\n\\n\\twords[0] = capitalize(words[0])\\n\\treturn strings.Join(words, \" \")\\n}\\n\\nfunc capitalize(str string) string {\\n\\tif len(str) == 0 {\\n\\t\\treturn str\\n\\t}\\n\\trunes := []rune(str)\\n\\trunes[0] = unicode.ToUpper(runes[0])\\n\\treturn string(runes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc arrangeWords(text string) string {\\n    text = strings.ToLower(text)\\n\\twords := strings.Fields(text)\\n\\n\\tsort.SliceStable(words, func(i, j int) bool {\\n        c := len(words[i]) < len(words[j])\\n\\t\\tif c {\\n\\t\\t\\treturn c\\n\\t\\t}\\n\\t\\treturn i <  j\\n\\t})\\n\\n\\twords[0] = capitalize(words[0])\\n\\treturn strings.Join(words, \" \")\\n}\\n\\nfunc capitalize(str string) string {\\n\\tif len(str) == 0 {\\n\\t\\treturn str\\n\\t}\\n\\trunes := []rune(str)\\n\\trunes[0] = unicode.ToUpper(runes[0])\\n\\treturn string(runes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047239,
                "title": "1-liner-solution-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- sort by length using lambda function \\n- use .capitalize() to make the first letter of the string into uppercase and all of the remaining letter into lowercase\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(\" \"), key=lambda x : len(x))).capitalize()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(\" \"), key=lambda x : len(x))).capitalize()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031363,
                "title": "easy-to-understand-just-make-a-custom-sort-function",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<string,int>> temp; int pos = 0;\\n        string curr = \"\";\\n        text[0] = tolower(text[0]); //convert first letter to lower case\\n        for(int i=0; i<=text.length(); i++)\\n        {\\n            if(text[i] == \\' \\' || i == text.length())\\n            {\\n                temp.push_back({curr,pos++}); //enter [string,order] in vector temp\\n                curr = \"\";\\n                continue;\\n            }\\n        curr += text[i];\\n        }\\n    \\n    //Below is a representation of lambda function in C++\\n    sort(temp.begin(),temp.end(),\\n     [](const pair<string,int>& a, const pair<string,int>& b)\\n     { //first sort in ascending order of length\\n        if(a.first.length() != b.first.length()) //(if they have unequal length)\\n          return a.first.length() < b.first.length();\\n      //otherwise, sort in ascending order of position in given string\\n     return  a.second < b.second; \\n     });\\n\\n    string ans = \"\";\\n    for(auto str : temp)\\n     { //make answer string by adding all strings from temp and one space \\n        ans += (str.first + \\' \\');\\n     }\\n    ans.pop_back(); //remove the last added space\\n    ans[0] = toupper(ans[0]); //convert first letter to upper case\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        vector<pair<string,int>> temp; int pos = 0;\\n        string curr = \"\";\\n        text[0] = tolower(text[0]); //convert first letter to lower case\\n        for(int i=0; i<=text.length(); i++)\\n        {\\n            if(text[i] == \\' \\' || i == text.length())\\n            {\\n                temp.push_back({curr,pos++}); //enter [string,order] in vector temp\\n                curr = \"\";\\n                continue;\\n            }\\n        curr += text[i];\\n        }\\n    \\n    //Below is a representation of lambda function in C++\\n    sort(temp.begin(),temp.end(),\\n     [](const pair<string,int>& a, const pair<string,int>& b)\\n     { //first sort in ascending order of length\\n        if(a.first.length() != b.first.length()) //(if they have unequal length)\\n          return a.first.length() < b.first.length();\\n      //otherwise, sort in ascending order of position in given string\\n     return  a.second < b.second; \\n     });\\n\\n    string ans = \"\";\\n    for(auto str : temp)\\n     { //make answer string by adding all strings from temp and one space \\n        ans += (str.first + \\' \\');\\n     }\\n    ans.pop_back(); //remove the last added space\\n    ans[0] = toupper(ans[0]); //convert first letter to upper case\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019408,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        string answer;\\n        vector<pair<int,pair<int,string>>> temp;\\n        int start=0,end=0;\\n        for(int i=0;i<=text.length();i++){\\n            if(i!=text.length() && text[i]!=\\' \\'){\\n                continue;\\n            }\\n            else{\\n                end=i;\\n                string t=text.substr(start,end-start);\\n                temp.push_back({t.length(),{i-t.length(),t}});\\n                start=end+1;\\n            }\\n        }\\n       \\n        sort(temp.begin(),temp.end());\\n\\n        for(int i=0;i<temp.size();i++){\\n            answer+=temp[i].second.second;\\n            if(i<temp.size()-1)\\n            answer+=\" \";\\n        }\\n        transform(answer.begin(), answer.end(), answer.begin(), ::tolower);\\n        answer[0] = ::toupper(answer[0]);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        string answer;\\n        vector<pair<int,pair<int,string>>> temp;\\n        int start=0,end=0;\\n        for(int i=0;i<=text.length();i++){\\n            if(i!=text.length() && text[i]!=\\' \\'){\\n                continue;\\n            }\\n            else{\\n                end=i;\\n                string t=text.substr(start,end-start);\\n                temp.push_back({t.length(),{i-t.length(),t}});\\n                start=end+1;\\n            }\\n        }\\n       \\n        sort(temp.begin(),temp.end());\\n\\n        for(int i=0;i<temp.size();i++){\\n            answer+=temp[i].second.second;\\n            if(i<temp.size()-1)\\n            answer+=\" \";\\n        }\\n        transform(answer.begin(), answer.end(), answer.begin(), ::tolower);\\n        answer[0] = ::toupper(answer[0]);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988522,
                "title": "c-code-using-map-with-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        map<int, queue<string>> m;\\n        string s, ans;\\n        for(int i=0; i<text.size(); i++)\\n        {\\n            if(isalpha(text[i]))\\n            {\\n                s.push_back(tolower(text[i]));\\n            }\\n            else if(text[i] == \\' \\')\\n            {\\n                int n = s.size();\\n                m[n].push(s);\\n                s = \"\";\\n            }\\n        }\\n        int n = s.size();\\n        m[n].push(s);\\n        s = \"\";\\n        for(auto i:m)\\n        {\\n            while(i.second.size() > 0)\\n            {\\n                ans += i.second.front() + \" \";\\n                i.second.pop();\\n            }\\n        }\\n        ans[0] = toupper(ans[0]);\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        map<int, queue<string>> m;\\n        string s, ans;\\n        for(int i=0; i<text.size(); i++)\\n        {\\n            if(isalpha(text[i]))\\n            {\\n                s.push_back(tolower(text[i]));\\n            }\\n            else if(text[i] == \\' \\')\\n            {\\n                int n = s.size();\\n                m[n].push(s);\\n                s = \"\";\\n            }\\n        }\\n        int n = s.size();\\n        m[n].push(s);\\n        s = \"\";\\n        for(auto i:m)\\n        {\\n            while(i.second.size() > 0)\\n            {\\n                ans += i.second.front() + \" \";\\n                i.second.pop();\\n            }\\n        }\\n        ans[0] = toupper(ans[0]);\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988498,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        l=[]\\n        b=0\\n        for i in text.split():\\n            if(b==0):\\n                i=i[0].lower()+i[1:]\\n            l1=[i,len(i)]\\n            l.append(l1)\\n        l=list(sorted(l,key=lambda x:x[1]))\\n        res=\"\"\\n        b=0\\n        for i in l:\\n            if(b==0):\\n                res+=i[0][0].upper()+i[0][1:]\\n                \\n            else:\\n                res+=i[0]\\n            b+=1\\n            if(b!=len(l)):\\n                    res+=\" \"\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        l=[]\\n        b=0\\n        for i in text.split():\\n            if(b==0):\\n                i=i[0].lower()+i[1:]\\n            l1=[i,len(i)]\\n            l.append(l1)\\n        l=list(sorted(l,key=lambda x:x[1]))\\n        res=\"\"\\n        b=0\\n        for i in l:\\n            if(b==0):\\n                res+=i[0][0].upper()+i[0][1:]\\n                \\n            else:\\n                res+=i[0]\\n            b+=1\\n            if(b!=len(l)):\\n                    res+=\" \"\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950480,
                "title": "dictionary-solution-o-n-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        d=defaultdict(list)\\n        \\n        max_length=float(\\'-inf\\')\\n        a=text.split()\\n        #Loop through text, putting each word in a dictionary\\n        for word in a:\\n            #The key will be the word\\'s length, and the value will be a list containing each word of that length, so all word\\'s of the same length will be in the list in the order it appeared in the text\\n            curr_word_length=len(word)\\n            max_length=max(curr_word_length, max_length)\\n            d[curr_word_length].append(word)\\n        res=\"\"\\n\\n        for i in range(1,max_length+1):\\n            \\n                for word in d[i]:\\n                    res+=word + \" \"\\n        return res.capitalize()[:-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        d=defaultdict(list)\\n        \\n        max_length=float(\\'-inf\\')\\n        a=text.split()\\n        #Loop through text, putting each word in a dictionary\\n        for word in a:\\n            #The key will be the word\\'s length, and the value will be a list containing each word of that length, so all word\\'s of the same length will be in the list in the order it appeared in the text\\n            curr_word_length=len(word)\\n            max_length=max(curr_word_length, max_length)\\n            d[curr_word_length].append(word)\\n        res=\"\"\\n\\n        for i in range(1,max_length+1):\\n            \\n                for word in d[i]:\\n                    res+=word + \" \"\\n        return res.capitalize()[:-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943004,
                "title": "c-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] += \\'a\\' - \\'A\\';\\n        string word = \"\";\\n        vector<pair<string, int>> words;\\n        text += \" \";\\n        int index = 0;\\n        for(int i = 0; i < text.length(); i++) {\\n            if(text[i] != \\' \\') word += text[i];\\n            else {\\n                words.push_back({word, index++});\\n                word = \"\";\\n            }\\n        }\\n        sort(words.begin(), words.end(), [&](pair<string, int> &A, pair<string, int> &B) {\\n            return A.first.length() < B.first.length() || (A.first.length() == B.first.length() && A.second < B.second);\\n        });\\n        text = words[0].first;\\n        for(int i = 1; i < words.size(); i++) {\\n            text += \" \" + words[i].first;\\n        }\\n        text[0] += \\'A\\' - \\'a\\';\\n        return text;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string arrangeWords(string text) {\\n        text[0] += \\'a\\' - \\'A\\';\\n        string word = \"\";\\n        vector<pair<string, int>> words;\\n        text += \" \";\\n        int index = 0;\\n        for(int i = 0; i < text.length(); i++) {\\n            if(text[i] != \\' \\') word += text[i];\\n            else {\\n                words.push_back({word, index++});\\n                word = \"\";\\n            }\\n        }\\n        sort(words.begin(), words.end(), [&](pair<string, int> &A, pair<string, int> &B) {\\n            return A.first.length() < B.first.length() || (A.first.length() == B.first.length() && A.second < B.second);\\n        });\\n        text = words[0].first;\\n        for(int i = 1; i < words.size(); i++) {\\n            text += \" \" + words[i].first;\\n        }\\n        text[0] += \\'A\\' - \\'a\\';\\n        return text;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909633,
                "title": "python-easy-code-heap-sorting-used-with-detailed-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we will split the given string into an array where we will be keeping all the words used in the string separately\\n2. Now we will create a dictionary and group words of same lengths in one i.e if the string is \"Hi i am vishal\" then the dictionary will be {2:[\\'Hi\\',\\'am\\'],1:[\\'i\\'],6:[\\'vishal\\']}.\\n3. Now we will create a heap and push all these value into it and our min heap will automatically sort the dictionary based on its length. Here in heap we will be storing a tuple whose first element will be the length of the words and the second element will the array of words of the given length.\\n4. Now we will pop out the top tuples from the heap one by one and if the word which we are going to add in the ansString is our first words so then we capatalize it else we add that word with all its letters in lower case. For doing so we have used some variable and some inbuilt functions as you can see below.\\n5. One more thing to note is that after adding every word in the ansString we also have to add space \" \", but while returing the ansString we slice the string in such a way that the last space \" \" we have added in not displayed as shown below.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def arrangeWords(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: str\\n        \"\"\"\\n        ansString = \"\"\\n        useDict ={}\\n        useArr = list(map(str,text.split()))\\n        #print(useArr)\\n\\n        for i in useArr:\\n            if len(i) not in useDict:\\n                useDict[len(i)] = []\\n            useDict[len(i)].append(i)\\n\\n        #print(useDict)\\n        heap = []\\n        for length,words in useDict.items():\\n            heapq.heappush(heap,(length,words))\\n\\n        start = True\\n        while len(heap) != 0:\\n            length,wordArr = heapq.heappop(heap)\\n\\n            if start == True:\\n                element = 1\\n                for i in wordArr:\\n                    if element == 1:\\n                        ansString += i.capitalize()\\n                        ansString += \" \"\\n                        element += 1\\n                    else:\\n                        ansString += i.lower()\\n                        ansString += \" \"\\n            \\n                start = False\\n            else:\\n                for i in wordArr:\\n                    ansString += i.lower()\\n                    ansString += \" \"\\n\\n        #print(len(ansString))\\n        return ansString[:len(ansString)-1]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrangeWords(self, text):\\n        \"\"\"\\n        :type text: str\\n        :rtype: str\\n        \"\"\"\\n        ansString = \"\"\\n        useDict ={}\\n        useArr = list(map(str,text.split()))\\n        #print(useArr)\\n\\n        for i in useArr:\\n            if len(i) not in useDict:\\n                useDict[len(i)] = []\\n            useDict[len(i)].append(i)\\n\\n        #print(useDict)\\n        heap = []\\n        for length,words in useDict.items():\\n            heapq.heappush(heap,(length,words))\\n\\n        start = True\\n        while len(heap) != 0:\\n            length,wordArr = heapq.heappop(heap)\\n\\n            if start == True:\\n                element = 1\\n                for i in wordArr:\\n                    if element == 1:\\n                        ansString += i.capitalize()\\n                        ansString += \" \"\\n                        element += 1\\n                    else:\\n                        ansString += i.lower()\\n                        ansString += \" \"\\n            \\n                start = False\\n            else:\\n                for i in wordArr:\\n                    ansString += i.lower()\\n                    ansString += \" \"\\n\\n        #print(len(ansString))\\n        return ansString[:len(ansString)-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897201,
                "title": "java-100-faster",
                "content": "# Approach\\nMaintian a map that stores lengths with the associated strings. Then append the strings in order of length and original index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public String arrangeWords(String text)\\n    {\\n        TreeMap<Integer,ArrayList<String>> h = new TreeMap<>();\\n\\n        String [] a = text.split(\" \");\\n\\n        for(String s : a)\\n            h.computeIfAbsent(s.length(),k->new ArrayList<>()).add(s);\\n\\n        StringBuilder s = new StringBuilder(text.length());\\n\\n        for(Map.Entry<Integer,ArrayList<String>> e : h.entrySet())\\n            for(String w : e.getValue())\\n            {\\n                if(s.length()==0)\\n                    s.append(title(w)).append(\" \");\\n\\n                else\\n                    s.append(w.toLowerCase()).append(\" \");\\n            }\\n\\n        return s.toString().trim();\\n    }\\n\\n    private String title(String s)\\n    {\\n        return s.substring(0,1).toUpperCase() + s.substring(1,s.length()).toLowerCase();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public String arrangeWords(String text)\\n    {\\n        TreeMap<Integer,ArrayList<String>> h = new TreeMap<>();\\n\\n        String [] a = text.split(\" \");\\n\\n        for(String s : a)\\n            h.computeIfAbsent(s.length(),k->new ArrayList<>()).add(s);\\n\\n        StringBuilder s = new StringBuilder(text.length());\\n\\n        for(Map.Entry<Integer,ArrayList<String>> e : h.entrySet())\\n            for(String w : e.getValue())\\n            {\\n                if(s.length()==0)\\n                    s.append(title(w)).append(\" \");\\n\\n                else\\n                    s.append(w.toLowerCase()).append(\" \");\\n            }\\n\\n        return s.toString().trim();\\n    }\\n\\n    private String title(String s)\\n    {\\n        return s.substring(0,1).toUpperCase() + s.substring(1,s.length()).toLowerCase();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877789,
                "title": "javascript-sort-95-runtime",
                "content": "```javascript\\nconst arrangeWords = (text) => {\\n  const res = text\\n    .toLowerCase()\\n    .split(\" \")\\n    .sort((a, b) => (a.length == b.length ? 0 : a.length > b.length ? 1 : -1))\\n    .join(\" \");\\n\\n  return res[0].toUpperCase() + res.slice(1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst arrangeWords = (text) => {\\n  const res = text\\n    .toLowerCase()\\n    .split(\" \")\\n    .sort((a, b) => (a.length == b.length ? 0 : a.length > b.length ? 1 : -1))\\n    .join(\" \");\\n\\n  return res[0].toUpperCase() + res.slice(1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861831,
                "title": "java-easy-solution-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n      \\n    String arr [] = text.split(\" \");\\n   Arrays.sort(arr,(s1,s2)->s1.length()-s2.length());\\n   StringBuilder sb = new StringBuilder();\\n   for(int i =0; i< arr.length; i++){\\n    if(i==0){\\n\\n      sb.append(arr[i].substring(0, 1).toUpperCase()+arr[i].substring( 1));\\n    }\\n    else{\\n      sb.append(arr[i].toLowerCase());\\n    }\\n    sb.append(\" \");\\n   }\\n   \\n  return sb.toString().trim();\\n  // System.out.println(s);\\n    \\n    \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n      \\n    String arr [] = text.split(\" \");\\n   Arrays.sort(arr,(s1,s2)->s1.length()-s2.length());\\n   StringBuilder sb = new StringBuilder();\\n   for(int i =0; i< arr.length; i++){\\n    if(i==0){\\n\\n      sb.append(arr[i].substring(0, 1).toUpperCase()+arr[i].substring( 1));\\n    }\\n    else{\\n      sb.append(arr[i].toLowerCase());\\n    }\\n    sb.append(\" \");\\n   }\\n   \\n  return sb.toString().trim();\\n  // System.out.println(s);\\n    \\n    \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858967,
                "title": "easy-to-understand-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool cmp(pair<int,int>a,pair<int,int>b){\\n    if(a.first!=b.first){\\n        if(a.first<b.first)return true;\\n        return false;\\n    }\\n    else{\\n        if(a.second<b.second)return true;\\n        return false;\\n    }\\n}\\n    string arrangeWords(string text) {\\n    vector<string>ans;\\n        vector<pair<int,int>>v;\\n        string str=\"\",s=\"\",s1=\"\";\\n        for(int i=0; i<text.length(); i++){\\n            if(text[i]==\\' \\'){\\n                ans.push_back(str);\\n                str=\"\";\\n            }\\n            else{str+=text[i];}\\n        }\\n        ans.push_back(str);\\n        for(int i=0; i<ans.size(); i++){\\n            int n=ans[i].length();\\n            v.push_back(make_pair(n,i));\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        for(int i=0; i<v.size(); i++){\\n            s+=ans[v[i].second]+\\' \\';\\n        }\\n        transform(s.begin(), s.end(), s.begin(), ::tolower);\\n        s1=toupper(s[0]);\\n        for(int i=1; i<s.length()-1; i++){\\n            s1+=s[i];\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool cmp(pair<int,int>a,pair<int,int>b){\\n    if(a.first!=b.first){\\n        if(a.first<b.first)return true;\\n        return false;\\n    }\\n    else{\\n        if(a.second<b.second)return true;\\n        return false;\\n    }\\n}\\n    string arrangeWords(string text) {\\n    vector<string>ans;\\n        vector<pair<int,int>>v;\\n        string str=\"\",s=\"\",s1=\"\";\\n        for(int i=0; i<text.length(); i++){\\n            if(text[i]==\\' \\'){\\n                ans.push_back(str);\\n                str=\"\";\\n            }\\n            else{str+=text[i];}\\n        }\\n        ans.push_back(str);\\n        for(int i=0; i<ans.size(); i++){\\n            int n=ans[i].length();\\n            v.push_back(make_pair(n,i));\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        for(int i=0; i<v.size(); i++){\\n            s+=ans[v[i].second]+\\' \\';\\n        }\\n        transform(s.begin(), s.end(), s.begin(), ::tolower);\\n        s1=toupper(s[0]);\\n        for(int i=1; i<s.length()-1; i++){\\n            s1+=s[i];\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854412,
                "title": "best-java-solution-using-string-builder-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n\\n        String arr[] = text.split(\" \");\\n\\n        Arrays.sort(arr,(str1,str2)-> str1.length()-str2.length());\\n\\n        StringBuilder ans = new StringBuilder(\"\");\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(i==0){\\n                ans.append(arr[i].substring(0,1).toUpperCase() + arr[i].substring(1));\\n            }else{\\n                ans.append(arr[i].toLowerCase());\\n            }\\n\\n            ans.append(\" \");\\n        }\\n\\n        return ans.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n\\n        String arr[] = text.split(\" \");\\n\\n        Arrays.sort(arr,(str1,str2)-> str1.length()-str2.length());\\n\\n        StringBuilder ans = new StringBuilder(\"\");\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(i==0){\\n                ans.append(arr[i].substring(0,1).toUpperCase() + arr[i].substring(1));\\n            }else{\\n                ans.append(arr[i].toLowerCase());\\n            }\\n\\n            ans.append(\" \");\\n        }\\n\\n        return ans.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827617,
                "title": "rearrange-words-in-a-sentence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        text=text.lower().split(\" \")\\n        text=sorted(text, key=len)\\n        text=\" \".join(text)\\n        text=text.capitalize()\\n        return text\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        text=text.lower().split(\" \")\\n        text=sorted(text, key=len)\\n        text=\" \".join(text)\\n        text=text.capitalize()\\n        return text\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810064,
                "title": "simple-easy-to-understand-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    \\n    static bool compare(pair<int,int> a,pair<int,int> b){\\n        return (a.second == b.second ? (a.first<b.first) : (a.second<b.second) );\\n    }\\n\\n    string arrangeWords(string text) {\\n        vector<string> t;\\n        string word=\"\";\\n        for(char c: text){\\n        \\n            if(c==\\' \\'){\\n                t.push_back(word);\\n                word=\"\";\\n            }\\n            else{\\n                if(c>=\\'a\\' && c<=\\'z\\'){\\n                    word.push_back(c);\\n                }\\n                else{\\n                    word.push_back(c - \\'A\\' + \\'a\\');\\n                }\\n                \\n            }\\n            \\n        }\\n        t.push_back(word);\\n\\n        vector<pair<int,int>> len;\\n\\n        for(int i =0;i<t.size();i++){\\n            len.push_back({i,t[i].length()});\\n        }\\n\\n        sort(len.begin(),len.end(),compare);\\n\\n        \\n        string s = \"\";\\n        t[len[0].first][0]= t[len[0].first][0] - \\'a\\' + \\'A\\' ;\\n        for(int i=0;i<len.size();i++){\\n            s+= t[len[i].first];\\n            s.push_back(\\' \\');\\n        }\\n        s.pop_back();\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    \\n    static bool compare(pair<int,int> a,pair<int,int> b){\\n        return (a.second == b.second ? (a.first<b.first) : (a.second<b.second) );\\n    }\\n\\n    string arrangeWords(string text) {\\n        vector<string> t;\\n        string word=\"\";\\n        for(char c: text){\\n        \\n            if(c==\\' \\'){\\n                t.push_back(word);\\n                word=\"\";\\n            }\\n            else{\\n                if(c>=\\'a\\' && c<=\\'z\\'){\\n                    word.push_back(c);\\n                }\\n                else{\\n                    word.push_back(c - \\'A\\' + \\'a\\');\\n                }\\n                \\n            }\\n            \\n        }\\n        t.push_back(word);\\n\\n        vector<pair<int,int>> len;\\n\\n        for(int i =0;i<t.size();i++){\\n            len.push_back({i,t[i].length()});\\n        }\\n\\n        sort(len.begin(),len.end(),compare);\\n\\n        \\n        string s = \"\";\\n        t[len[0].first][0]= t[len[0].first][0] - \\'a\\' + \\'A\\' ;\\n        for(int i=0;i<len.size();i++){\\n            s+= t[len[i].first];\\n            s.push_back(\\' \\');\\n        }\\n        s.pop_back();\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772264,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar arrangeWords = function(text) {\\n    const words = text.split(\\' \\');\\n    const buckets = [];\\n\\n    for (let index = 0; index < words.length; index++) {\\n        const word = index\\n            ? words[index] \\n            : words[index][0].toLowerCase() + words[index].slice(1);\\n        const bocket = buckets[word.length];\\n\\n        if (!bocket) buckets[word.length] = [];\\n        buckets[word.length].push(word);\\n    }\\n\\n    return buckets.filter(Boolean).reduce((result, bocket, index) => {\\n        if (index === 0) {\\n            bocket[0] = bocket[0][0].toUpperCase() + bocket[0].slice(1);\\n            return bocket.join(\\' \\');\\n        }\\n        return `${result} ${bocket.join(\\' \\')}`;\\n    }, \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arrangeWords = function(text) {\\n    const words = text.split(\\' \\');\\n    const buckets = [];\\n\\n    for (let index = 0; index < words.length; index++) {\\n        const word = index\\n            ? words[index] \\n            : words[index][0].toLowerCase() + words[index].slice(1);\\n        const bocket = buckets[word.length];\\n\\n        if (!bocket) buckets[word.length] = [];\\n        buckets[word.length].push(word);\\n    }\\n\\n    return buckets.filter(Boolean).reduce((result, bocket, index) => {\\n        if (index === 0) {\\n            bocket[0] = bocket[0][0].toUpperCase() + bocket[0].slice(1);\\n            return bocket.join(\\' \\');\\n        }\\n        return `${result} ${bocket.join(\\' \\')}`;\\n    }, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770970,
                "title": "solution-with-no-comparator-used-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution -> not using comparator for sorting. \\n1. Used HashMap to store length and words mapping\\n2. Stores lengths in arraylist then sort\\n3. added to strings in req manner\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Theta(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:Theta(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        \\n        String[] arr = text.split(\" \");\\n        ArrayList<Integer> lens = new ArrayList<>();\\n        HashMap<Integer,List<String>> m = new HashMap<>();\\n\\n        for(int i = 0; i < arr.length; i++){\\n\\n            int x = arr[i].length();\\n            List<String> temp = new ArrayList<>();\\n            temp.add(arr[i]);\\n\\n            if(m.containsKey(x)){\\n                temp = m.get(x);\\n                temp.add(arr[i]);\\n            }\\n\\n            m.put(x,temp);\\n    \\n        }\\n\\n        for(Map.Entry<Integer,List<String>> e : m.entrySet()){\\n            lens.add(e.getKey());\\n        }\\n\\n        Collections.sort(lens);\\n        StringBuilder res = new StringBuilder();\\n\\n        for(int i = 0; i < lens.size(); i++){\\n            \\n            List<String> temp = m.get(lens.get(i));\\n\\n            for(int j = 0; j < temp.size(); j++){\\n               \\n                String t = temp.get(j).substring(0,1).toLowerCase() + temp.get(j).substring(1);\\n               \\n                if(i==lens.size()-1 && j == temp.size()-1 ){\\n                    res.append(t);\\n                }else{\\n                    res.append(t+\" \");\\n                }\\n            }\\n         \\n        }\\n\\n        String ans = res.substring(0,1).toUpperCase() + res.substring(1);\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String arrangeWords(String text) {\\n        \\n        String[] arr = text.split(\" \");\\n        ArrayList<Integer> lens = new ArrayList<>();\\n        HashMap<Integer,List<String>> m = new HashMap<>();\\n\\n        for(int i = 0; i < arr.length; i++){\\n\\n            int x = arr[i].length();\\n            List<String> temp = new ArrayList<>();\\n            temp.add(arr[i]);\\n\\n            if(m.containsKey(x)){\\n                temp = m.get(x);\\n                temp.add(arr[i]);\\n            }\\n\\n            m.put(x,temp);\\n    \\n        }\\n\\n        for(Map.Entry<Integer,List<String>> e : m.entrySet()){\\n            lens.add(e.getKey());\\n        }\\n\\n        Collections.sort(lens);\\n        StringBuilder res = new StringBuilder();\\n\\n        for(int i = 0; i < lens.size(); i++){\\n            \\n            List<String> temp = m.get(lens.get(i));\\n\\n            for(int j = 0; j < temp.size(); j++){\\n               \\n                String t = temp.get(j).substring(0,1).toLowerCase() + temp.get(j).substring(1);\\n               \\n                if(i==lens.size()-1 && j == temp.size()-1 ){\\n                    res.append(t);\\n                }else{\\n                    res.append(t+\" \");\\n                }\\n            }\\n         \\n        }\\n\\n        String ans = res.substring(0,1).toUpperCase() + res.substring(1);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566943,
                "content": [
                    {
                        "username": "aqibm",
                        "content": "I created a vector of the words and their timestamps in C++ and got MLE. Did anyone else experience this?"
                    },
                    {
                        "username": "VoiD_27",
                        "content": "here we are using the inbuilt functions for string , available in python\\n\\n`return \\' \\'.join(sorted(text.split(),key=len)).lower().capitalize()`\\n\\n1. \\' \\'.join() -space is included, else the words joined will be a single string\\n2. sorted() - inbuilt sorted function which sorts by `key=len` , it takes into account the original positioning of the words in the array\\n3. text.split()- makes an array of words \\n4. lower()- initially makes all the words in the joined string as lowercase\\n5. capitalize()- Makes the first letter of the first word as Upper/Capital"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "Do not post solutions in discussion section"
                    },
                    {
                        "username": "posadsky84",
                        "content": "should be easy"
                    },
                    {
                        "username": "has12zen",
                        "content": "The idea is to have a map with key ( length) and value (vector\\\\<string>) so if we find a word with same length we push in the same order as it occured in given sentence.\\nThis works a lot better than simple sort solution.\\n"
                    },
                    {
                        "username": "user9605y",
                        "content": "Depends on what sort algorithm you\\'re using. If your language provides a stable one like merge sort, it makes this problem trivial."
                    },
                    {
                        "username": "jaintle",
                        "content": "PLEASE RESOLVE THIS ERROR FOR CPP:\\n\\n```\\nterminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\\n```\\n\\nThe following is my code:\\n\\n ```\\nclass Solution {\\npublic:\\n    static bool mysort(string a, string b){\\n        return a.length()<=b.length();\\n    }\\n    string arrangeWords(string text) {\\n        stringstream s(text);\\n        string word;\\n        vector<string>v;\\n        while(s>>word){\\n            v.push_back(word);\\n        }\\n        sort(v.begin(),v.end(),mysort);\\n        string ans=\"\";\\n        for(int i = 0; i<v.size(); i++){\\n            if(i==0){\\n                if(v[i][0]>91){\\n                    v[i][0]-=32;\\n                }\\n            }\\n            else{\\n                if(v[i][0]<91){\\n                    v[i][0]+=32;\\n                }\\n            }\\n            ans+=v[i]+\" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1574152,
                "content": [
                    {
                        "username": "aqibm",
                        "content": "I created a vector of the words and their timestamps in C++ and got MLE. Did anyone else experience this?"
                    },
                    {
                        "username": "VoiD_27",
                        "content": "here we are using the inbuilt functions for string , available in python\\n\\n`return \\' \\'.join(sorted(text.split(),key=len)).lower().capitalize()`\\n\\n1. \\' \\'.join() -space is included, else the words joined will be a single string\\n2. sorted() - inbuilt sorted function which sorts by `key=len` , it takes into account the original positioning of the words in the array\\n3. text.split()- makes an array of words \\n4. lower()- initially makes all the words in the joined string as lowercase\\n5. capitalize()- Makes the first letter of the first word as Upper/Capital"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "Do not post solutions in discussion section"
                    },
                    {
                        "username": "posadsky84",
                        "content": "should be easy"
                    },
                    {
                        "username": "has12zen",
                        "content": "The idea is to have a map with key ( length) and value (vector\\\\<string>) so if we find a word with same length we push in the same order as it occured in given sentence.\\nThis works a lot better than simple sort solution.\\n"
                    },
                    {
                        "username": "user9605y",
                        "content": "Depends on what sort algorithm you\\'re using. If your language provides a stable one like merge sort, it makes this problem trivial."
                    },
                    {
                        "username": "jaintle",
                        "content": "PLEASE RESOLVE THIS ERROR FOR CPP:\\n\\n```\\nterminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\\n```\\n\\nThe following is my code:\\n\\n ```\\nclass Solution {\\npublic:\\n    static bool mysort(string a, string b){\\n        return a.length()<=b.length();\\n    }\\n    string arrangeWords(string text) {\\n        stringstream s(text);\\n        string word;\\n        vector<string>v;\\n        while(s>>word){\\n            v.push_back(word);\\n        }\\n        sort(v.begin(),v.end(),mysort);\\n        string ans=\"\";\\n        for(int i = 0; i<v.size(); i++){\\n            if(i==0){\\n                if(v[i][0]>91){\\n                    v[i][0]-=32;\\n                }\\n            }\\n            else{\\n                if(v[i][0]<91){\\n                    v[i][0]+=32;\\n                }\\n            }\\n            ans+=v[i]+\" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1991691,
                "content": [
                    {
                        "username": "aqibm",
                        "content": "I created a vector of the words and their timestamps in C++ and got MLE. Did anyone else experience this?"
                    },
                    {
                        "username": "VoiD_27",
                        "content": "here we are using the inbuilt functions for string , available in python\\n\\n`return \\' \\'.join(sorted(text.split(),key=len)).lower().capitalize()`\\n\\n1. \\' \\'.join() -space is included, else the words joined will be a single string\\n2. sorted() - inbuilt sorted function which sorts by `key=len` , it takes into account the original positioning of the words in the array\\n3. text.split()- makes an array of words \\n4. lower()- initially makes all the words in the joined string as lowercase\\n5. capitalize()- Makes the first letter of the first word as Upper/Capital"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "Do not post solutions in discussion section"
                    },
                    {
                        "username": "posadsky84",
                        "content": "should be easy"
                    },
                    {
                        "username": "has12zen",
                        "content": "The idea is to have a map with key ( length) and value (vector\\\\<string>) so if we find a word with same length we push in the same order as it occured in given sentence.\\nThis works a lot better than simple sort solution.\\n"
                    },
                    {
                        "username": "user9605y",
                        "content": "Depends on what sort algorithm you\\'re using. If your language provides a stable one like merge sort, it makes this problem trivial."
                    },
                    {
                        "username": "jaintle",
                        "content": "PLEASE RESOLVE THIS ERROR FOR CPP:\\n\\n```\\nterminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\\n```\\n\\nThe following is my code:\\n\\n ```\\nclass Solution {\\npublic:\\n    static bool mysort(string a, string b){\\n        return a.length()<=b.length();\\n    }\\n    string arrangeWords(string text) {\\n        stringstream s(text);\\n        string word;\\n        vector<string>v;\\n        while(s>>word){\\n            v.push_back(word);\\n        }\\n        sort(v.begin(),v.end(),mysort);\\n        string ans=\"\";\\n        for(int i = 0; i<v.size(); i++){\\n            if(i==0){\\n                if(v[i][0]>91){\\n                    v[i][0]-=32;\\n                }\\n            }\\n            else{\\n                if(v[i][0]<91){\\n                    v[i][0]+=32;\\n                }\\n            }\\n            ans+=v[i]+\" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1570406,
                "content": [
                    {
                        "username": "aqibm",
                        "content": "I created a vector of the words and their timestamps in C++ and got MLE. Did anyone else experience this?"
                    },
                    {
                        "username": "VoiD_27",
                        "content": "here we are using the inbuilt functions for string , available in python\\n\\n`return \\' \\'.join(sorted(text.split(),key=len)).lower().capitalize()`\\n\\n1. \\' \\'.join() -space is included, else the words joined will be a single string\\n2. sorted() - inbuilt sorted function which sorts by `key=len` , it takes into account the original positioning of the words in the array\\n3. text.split()- makes an array of words \\n4. lower()- initially makes all the words in the joined string as lowercase\\n5. capitalize()- Makes the first letter of the first word as Upper/Capital"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "Do not post solutions in discussion section"
                    },
                    {
                        "username": "posadsky84",
                        "content": "should be easy"
                    },
                    {
                        "username": "has12zen",
                        "content": "The idea is to have a map with key ( length) and value (vector\\\\<string>) so if we find a word with same length we push in the same order as it occured in given sentence.\\nThis works a lot better than simple sort solution.\\n"
                    },
                    {
                        "username": "user9605y",
                        "content": "Depends on what sort algorithm you\\'re using. If your language provides a stable one like merge sort, it makes this problem trivial."
                    },
                    {
                        "username": "jaintle",
                        "content": "PLEASE RESOLVE THIS ERROR FOR CPP:\\n\\n```\\nterminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\\n```\\n\\nThe following is my code:\\n\\n ```\\nclass Solution {\\npublic:\\n    static bool mysort(string a, string b){\\n        return a.length()<=b.length();\\n    }\\n    string arrangeWords(string text) {\\n        stringstream s(text);\\n        string word;\\n        vector<string>v;\\n        while(s>>word){\\n            v.push_back(word);\\n        }\\n        sort(v.begin(),v.end(),mysort);\\n        string ans=\"\";\\n        for(int i = 0; i<v.size(); i++){\\n            if(i==0){\\n                if(v[i][0]>91){\\n                    v[i][0]-=32;\\n                }\\n            }\\n            else{\\n                if(v[i][0]<91){\\n                    v[i][0]+=32;\\n                }\\n            }\\n            ans+=v[i]+\" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1774439,
                "content": [
                    {
                        "username": "aqibm",
                        "content": "I created a vector of the words and their timestamps in C++ and got MLE. Did anyone else experience this?"
                    },
                    {
                        "username": "VoiD_27",
                        "content": "here we are using the inbuilt functions for string , available in python\\n\\n`return \\' \\'.join(sorted(text.split(),key=len)).lower().capitalize()`\\n\\n1. \\' \\'.join() -space is included, else the words joined will be a single string\\n2. sorted() - inbuilt sorted function which sorts by `key=len` , it takes into account the original positioning of the words in the array\\n3. text.split()- makes an array of words \\n4. lower()- initially makes all the words in the joined string as lowercase\\n5. capitalize()- Makes the first letter of the first word as Upper/Capital"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "Do not post solutions in discussion section"
                    },
                    {
                        "username": "posadsky84",
                        "content": "should be easy"
                    },
                    {
                        "username": "has12zen",
                        "content": "The idea is to have a map with key ( length) and value (vector\\\\<string>) so if we find a word with same length we push in the same order as it occured in given sentence.\\nThis works a lot better than simple sort solution.\\n"
                    },
                    {
                        "username": "user9605y",
                        "content": "Depends on what sort algorithm you\\'re using. If your language provides a stable one like merge sort, it makes this problem trivial."
                    },
                    {
                        "username": "jaintle",
                        "content": "PLEASE RESOLVE THIS ERROR FOR CPP:\\n\\n```\\nterminate called after throwing an instance of \\'std::length_error\\'\\n  what():  basic_string::_M_create\\n```\\n\\nThe following is my code:\\n\\n ```\\nclass Solution {\\npublic:\\n    static bool mysort(string a, string b){\\n        return a.length()<=b.length();\\n    }\\n    string arrangeWords(string text) {\\n        stringstream s(text);\\n        string word;\\n        vector<string>v;\\n        while(s>>word){\\n            v.push_back(word);\\n        }\\n        sort(v.begin(),v.end(),mysort);\\n        string ans=\"\";\\n        for(int i = 0; i<v.size(); i++){\\n            if(i==0){\\n                if(v[i][0]>91){\\n                    v[i][0]-=32;\\n                }\\n            }\\n            else{\\n                if(v[i][0]<91){\\n                    v[i][0]+=32;\\n                }\\n            }\\n            ans+=v[i]+\" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    }
]